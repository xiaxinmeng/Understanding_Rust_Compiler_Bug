{"sha": "f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4Y2ZkMjQ4MGI2OWExY2MyNjZmYzkxZDBiNjBjODI1YTlkYzE4YTc=", "commit": {"author": {"name": "Florian Wilkens", "email": "floya@live.de", "date": "2014-12-19T20:52:10Z"}, "committer": {"name": "Florian Wilkens", "email": "floya@live.de", "date": "2014-12-22T11:58:55Z"}, "message": "Renaming of the Iter types as in RFC #344\n\nlibcore: slice::Items -> slice::Iter, slice::MutItems -> slice::IterMut\nlibcollections: *::Items -> *::Iter, *::MoveItems -> *::IntoIter, *::MutItems -> *::IterMut\n\nThis is of course a [breaking-change].", "tree": {"sha": "6d0eff18d899f6a660797fa3fa4265fd59ad4ed7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d0eff18d899f6a660797fa3fa4265fd59ad4ed7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "html_url": "https://github.com/rust-lang/rust/commit/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/comments", "author": {"login": "1wilkens", "id": 2774469, "node_id": "MDQ6VXNlcjI3NzQ0Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/2774469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1wilkens", "html_url": "https://github.com/1wilkens", "followers_url": "https://api.github.com/users/1wilkens/followers", "following_url": "https://api.github.com/users/1wilkens/following{/other_user}", "gists_url": "https://api.github.com/users/1wilkens/gists{/gist_id}", "starred_url": "https://api.github.com/users/1wilkens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1wilkens/subscriptions", "organizations_url": "https://api.github.com/users/1wilkens/orgs", "repos_url": "https://api.github.com/users/1wilkens/repos", "events_url": "https://api.github.com/users/1wilkens/events{/privacy}", "received_events_url": "https://api.github.com/users/1wilkens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "1wilkens", "id": 2774469, "node_id": "MDQ6VXNlcjI3NzQ0Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/2774469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1wilkens", "html_url": "https://github.com/1wilkens", "followers_url": "https://api.github.com/users/1wilkens/followers", "following_url": "https://api.github.com/users/1wilkens/following{/other_user}", "gists_url": "https://api.github.com/users/1wilkens/gists{/gist_id}", "starred_url": "https://api.github.com/users/1wilkens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1wilkens/subscriptions", "organizations_url": "https://api.github.com/users/1wilkens/orgs", "repos_url": "https://api.github.com/users/1wilkens/repos", "events_url": "https://api.github.com/users/1wilkens/events{/privacy}", "received_events_url": "https://api.github.com/users/1wilkens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34d680009205de2302b902d8f9f5f7ae7a042f1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/34d680009205de2302b902d8f9f5f7ae7a042f1a", "html_url": "https://github.com/rust-lang/rust/commit/34d680009205de2302b902d8f9f5f7ae7a042f1a"}], "stats": {"total": 348, "additions": 173, "deletions": 175}, "files": [{"sha": "c9d1d9d13fb26c1e92956531a5945a05c4315907", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -239,9 +239,8 @@ impl<T: Ord> BinaryHeap<T> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter(&self) -> Items<T> {\n-        Items { iter: self.data.iter() }\n-    }\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter { iter: self.data.iter() } }\n \n     /// Creates a consuming iterator, that is, one that moves each value out of\n     /// the binary heap in arbitrary order.  The binary heap cannot be used\n@@ -260,8 +259,8 @@ impl<T: Ord> BinaryHeap<T> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n-        MoveItems { iter: self.data.into_iter() }\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        IntoIter { iter: self.data.into_iter() }\n     }\n \n     /// Returns the greatest item in a queue, or `None` if it is empty.\n@@ -571,44 +570,44 @@ impl<T: Ord> BinaryHeap<T> {\n }\n \n /// `BinaryHeap` iterator.\n-pub struct Items<'a, T: 'a> {\n-    iter: slice::Items<'a, T>,\n+pub struct Iter <'a, T: 'a> {\n+    iter: slice::Iter<'a, T>,\n }\n \n-impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n+impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n \n-impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n /// An iterator that moves out of a `BinaryHeap`.\n-pub struct MoveItems<T> {\n-    iter: vec::MoveItems<T>,\n+pub struct IntoIter<T> {\n+    iter: vec::IntoIter<T>,\n }\n \n-impl<T> Iterator<T> for MoveItems<T> {\n+impl<T> Iterator<T> for IntoIter<T> {\n     #[inline]\n     fn next(&mut self) -> Option<T> { self.iter.next() }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n+impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n \n-impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n+impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n \n /// An iterator that drains a `BinaryHeap`.\n pub struct Drain<'a, T: 'a> {"}, {"sha": "8ceeb99d5856e5672cee671431aeb6be7bcfe11b", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -145,7 +145,7 @@ impl Index<uint,bool> for Bitv {\n }\n \n struct MaskWords<'a> {\n-    iter: slice::Items<'a, u32>,\n+    iter: slice::Iter<'a, u32>,\n     next_word: Option<&'a u32>,\n     last_word_mask: u32,\n     offset: uint"}, {"sha": "2c3c546fdb7ff9c924984e491c4e625e6b17443b", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -1382,14 +1382,14 @@ pub enum TraversalItem<K, V, E> {\n }\n \n /// A traversal over a node's entries and edges\n-pub type Traversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Items<'a, K>,\n-                                                              slice::Items<'a, V>>,\n-                                                              slice::Items<'a, Node<K, V>>>>;\n+pub type Traversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Iter<'a, K>,\n+                                                              slice::Iter<'a, V>>,\n+                                                              slice::Iter<'a, Node<K, V>>>>;\n \n /// A mutable traversal over a node's entries and edges\n-pub type MutTraversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Items<'a, K>,\n-                                                                 slice::MutItems<'a, V>>,\n-                                                                 slice::MutItems<'a, Node<K, V>>>>;\n+pub type MutTraversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Iter<'a, K>,\n+                                                                 slice::IterMut<'a, V>>,\n+                                                                 slice::IterMut<'a, Node<K, V>>>>;\n \n /// An owning traversal over a node's entries and edges\n pub type MoveTraversal<K, V> = AbsTraversal<MoveTraversalImpl<K, V>>;"}, {"sha": "26e82994f5673ca4d658ec329c7a83fd8983002b", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -33,37 +33,37 @@ pub struct BTreeSet<T>{\n }\n \n /// An iterator over a BTreeSet's items.\n-pub struct Items<'a, T: 'a> {\n+pub struct Iter<'a, T: 'a> {\n     iter: Keys<'a, T, ()>\n }\n \n /// An owning iterator over a BTreeSet's items.\n-pub struct MoveItems<T> {\n+pub struct IntoIter<T> {\n     iter: Map<(T, ()), T, MoveEntries<T, ()>, fn((T, ())) -> T>\n }\n \n /// A lazy iterator producing elements in the set difference (in-order).\n pub struct DifferenceItems<'a, T:'a> {\n-    a: Peekable<&'a T, Items<'a, T>>,\n-    b: Peekable<&'a T, Items<'a, T>>,\n+    a: Peekable<&'a T, Iter<'a, T>>,\n+    b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set symmetric difference (in-order).\n pub struct SymDifferenceItems<'a, T:'a> {\n-    a: Peekable<&'a T, Items<'a, T>>,\n-    b: Peekable<&'a T, Items<'a, T>>,\n+    a: Peekable<&'a T, Iter<'a, T>>,\n+    b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set intersection (in-order).\n pub struct IntersectionItems<'a, T:'a> {\n-    a: Peekable<&'a T, Items<'a, T>>,\n-    b: Peekable<&'a T, Items<'a, T>>,\n+    a: Peekable<&'a T, Iter<'a, T>>,\n+    b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set union (in-order).\n pub struct UnionItems<'a, T:'a> {\n-    a: Peekable<&'a T, Items<'a, T>>,\n-    b: Peekable<&'a T, Items<'a, T>>,\n+    a: Peekable<&'a T, Iter<'a, T>>,\n+    b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n impl<T: Ord> BTreeSet<T> {\n@@ -107,8 +107,8 @@ impl<T> BTreeSet<T> {\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n-        Items { iter: self.map.keys() }\n+    pub fn iter<'a>(&'a self) -> Iter<'a, T> {\n+        Iter { iter: self.map.keys() }\n     }\n \n     /// Gets an iterator for moving out the BtreeSet's contents.\n@@ -124,10 +124,10 @@ impl<T> BTreeSet<T> {\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n+    pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n \n-        MoveItems { iter: self.map.into_iter().map(first) }\n+        IntoIter { iter: self.map.into_iter().map(first) }\n     }\n }\n \n@@ -544,24 +544,24 @@ impl<T: Show> Show for BTreeSet<T> {\n     }\n }\n \n-impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n+impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n-impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n \n-impl<T> Iterator<T> for MoveItems<T> {\n+impl<T> Iterator<T> for IntoIter<T> {\n     fn next(&mut self) -> Option<T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n+impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n-impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n+impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n \n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,"}, {"sha": "eb057b4885310e84c295eb4ddf21e8dbfd43325c", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -51,21 +51,21 @@ struct Node<T> {\n }\n \n /// An iterator over references to the items of a `DList`.\n-pub struct Items<'a, T:'a> {\n+pub struct Iter<'a, T:'a> {\n     head: &'a Link<T>,\n     tail: Rawlink<Node<T>>,\n     nelem: uint,\n }\n \n // FIXME #11820: the &'a Option<> of the Link stops clone working.\n-impl<'a, T> Clone for Items<'a, T> {\n-    fn clone(&self) -> Items<'a, T> { *self }\n+impl<'a, T> Clone for Iter<'a, T> {\n+    fn clone(&self) -> Iter<'a, T> { *self }\n }\n \n-impl<'a,T> Copy for Items<'a,T> {}\n+impl<'a,T> Copy for Iter<'a,T> {}\n \n /// An iterator over mutable references to the items of a `DList`.\n-pub struct MutItems<'a, T:'a> {\n+pub struct IterMut<'a, T:'a> {\n     list: &'a mut DList<T>,\n     head: Rawlink<Node<T>>,\n     tail: Rawlink<Node<T>>,\n@@ -74,7 +74,7 @@ pub struct MutItems<'a, T:'a> {\n \n /// An iterator over mutable references to the items of a `DList`.\n #[deriving(Clone)]\n-pub struct MoveItems<T> {\n+pub struct IntoIter<T> {\n     list: DList<T>\n }\n \n@@ -394,19 +394,19 @@ impl<T> DList<T> {\n     /// Provides a forward iterator.\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n-        Items{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n+    pub fn iter<'a>(&'a self) -> Iter<'a, T> {\n+        Iter{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n     /// Provides a forward iterator with mutable references.\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n+    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         let head_raw = match self.list_head {\n             Some(ref mut h) => Rawlink::some(&mut **h),\n             None => Rawlink::none(),\n         };\n-        MutItems{\n+        IterMut{\n             nelem: self.len(),\n             head: head_raw,\n             tail: self.list_tail,\n@@ -417,8 +417,8 @@ impl<T> DList<T> {\n     /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n-        MoveItems{list: self}\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        IntoIter{list: self}\n     }\n \n     /// Returns `true` if the `DList` is empty.\n@@ -579,7 +579,7 @@ impl<T> Drop for DList<T> {\n }\n \n \n-impl<'a, A> Iterator<&'a A> for Items<'a, A> {\n+impl<'a, A> Iterator<&'a A> for Iter<'a, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a A> {\n         if self.nelem == 0 {\n@@ -598,7 +598,7 @@ impl<'a, A> Iterator<&'a A> for Items<'a, A> {\n     }\n }\n \n-impl<'a, A> DoubleEndedIterator<&'a A> for Items<'a, A> {\n+impl<'a, A> DoubleEndedIterator<&'a A> for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> {\n         if self.nelem == 0 {\n@@ -612,9 +612,9 @@ impl<'a, A> DoubleEndedIterator<&'a A> for Items<'a, A> {\n     }\n }\n \n-impl<'a, A> ExactSizeIterator<&'a A> for Items<'a, A> {}\n+impl<'a, A> ExactSizeIterator<&'a A> for Iter<'a, A> {}\n \n-impl<'a, A> Iterator<&'a mut A> for MutItems<'a, A> {\n+impl<'a, A> Iterator<&'a mut A> for IterMut<'a, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut A> {\n         if self.nelem == 0 {\n@@ -636,7 +636,7 @@ impl<'a, A> Iterator<&'a mut A> for MutItems<'a, A> {\n     }\n }\n \n-impl<'a, A> DoubleEndedIterator<&'a mut A> for MutItems<'a, A> {\n+impl<'a, A> DoubleEndedIterator<&'a mut A> for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> {\n         if self.nelem == 0 {\n@@ -650,7 +650,7 @@ impl<'a, A> DoubleEndedIterator<&'a mut A> for MutItems<'a, A> {\n     }\n }\n \n-impl<'a, A> ExactSizeIterator<&'a mut A> for MutItems<'a, A> {}\n+impl<'a, A> ExactSizeIterator<&'a mut A> for IterMut<'a, A> {}\n \n /// Allows mutating a `DList` while iterating.\n pub trait ListInsertion<A> {\n@@ -664,8 +664,8 @@ pub trait ListInsertion<A> {\n     fn peek_next<'a>(&'a mut self) -> Option<&'a mut A>;\n }\n \n-// private methods for MutItems\n-impl<'a, A> MutItems<'a, A> {\n+// private methods for IterMut\n+impl<'a, A> IterMut<'a, A> {\n     fn insert_next_node(&mut self, mut ins_node: Box<Node<A>>) {\n         // Insert before `self.head` so that it is between the\n         // previously yielded element and self.head.\n@@ -687,7 +687,7 @@ impl<'a, A> MutItems<'a, A> {\n     }\n }\n \n-impl<'a, A> ListInsertion<A> for MutItems<'a, A> {\n+impl<'a, A> ListInsertion<A> for IterMut<'a, A> {\n     #[inline]\n     fn insert_next(&mut self, elt: A) {\n         self.insert_next_node(box Node::new(elt))\n@@ -702,7 +702,7 @@ impl<'a, A> ListInsertion<A> for MutItems<'a, A> {\n     }\n }\n \n-impl<A> Iterator<A> for MoveItems<A> {\n+impl<A> Iterator<A> for IntoIter<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.list.pop_front() }\n \n@@ -712,7 +712,7 @@ impl<A> Iterator<A> for MoveItems<A> {\n     }\n }\n \n-impl<A> DoubleEndedIterator<A> for MoveItems<A> {\n+impl<A> DoubleEndedIterator<A> for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n }"}, {"sha": "fd04ce94247b7f2a352556dc0c6d519a4b4f3fae", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -178,8 +178,8 @@ impl<E:CLike> EnumSet<E> {\n \n     /// Returns an iterator over an `EnumSet`.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter(&self) -> Items<E> {\n-        Items::new(self.bits)\n+    pub fn iter(&self) -> Iter<E> {\n+        Iter::new(self.bits)\n     }\n }\n \n@@ -208,18 +208,18 @@ impl<E:CLike> BitXor<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n }\n \n /// An iterator over an EnumSet\n-pub struct Items<E> {\n+pub struct Iter<E> {\n     index: uint,\n     bits: uint,\n }\n \n-impl<E:CLike> Items<E> {\n-    fn new(bits: uint) -> Items<E> {\n-        Items { index: 0, bits: bits }\n+impl<E:CLike> Iter<E> {\n+    fn new(bits: uint) -> Iter<E> {\n+        Iter { index: 0, bits: bits }\n     }\n }\n \n-impl<E:CLike> Iterator<E> for Items<E> {\n+impl<E:CLike> Iterator<E> for Iter<E> {\n     fn next(&mut self) -> Option<E> {\n         if self.bits == 0 {\n             return None;"}, {"sha": "37c088f74536e229752b3c93573c758e74d73da2", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -376,8 +376,8 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), b);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter(&self) -> Items<T> {\n-        Items {\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter {\n             tail: self.tail,\n             head: self.head,\n             ring: unsafe { self.buffer_as_slice() }\n@@ -402,8 +402,8 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n-        MutItems {\n+    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n+        IterMut {\n             tail: self.tail,\n             head: self.head,\n             cap: self.cap,\n@@ -414,8 +414,8 @@ impl<T> RingBuf<T> {\n \n     /// Consumes the list into an iterator yielding elements by value.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n-        MoveItems {\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        IntoIter {\n             inner: self,\n         }\n     }\n@@ -1122,13 +1122,13 @@ fn count(tail: uint, head: uint, size: uint) -> uint {\n }\n \n /// `RingBuf` iterator.\n-pub struct Items<'a, T:'a> {\n+pub struct Iter<'a, T:'a> {\n     ring: &'a [T],\n     tail: uint,\n     head: uint\n }\n \n-impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n+impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n         if self.tail == self.head {\n@@ -1146,7 +1146,7 @@ impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> {\n         if self.tail == self.head {\n@@ -1157,9 +1157,9 @@ impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n     }\n }\n \n-impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n-impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         let (len, _) = self.size_hint();\n@@ -1177,19 +1177,19 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     }\n }\n \n-// FIXME This was implemented differently from Items because of a problem\n+// FIXME This was implemented differently from Iter because of a problem\n //       with returning the mutable reference. I couldn't find a way to\n //       make the lifetime checker happy so, but there should be a way.\n /// `RingBuf` mutable iterator.\n-pub struct MutItems<'a, T:'a> {\n+pub struct IterMut<'a, T:'a> {\n     ptr: *mut T,\n     tail: uint,\n     head: uint,\n     cap: uint,\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n-impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n+impl<'a, T> Iterator<&'a mut T> for IterMut<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut T> {\n         if self.tail == self.head {\n@@ -1210,7 +1210,7 @@ impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a mut T> for MutItems<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a mut T> for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> {\n         if self.tail == self.head {\n@@ -1224,14 +1224,14 @@ impl<'a, T> DoubleEndedIterator<&'a mut T> for MutItems<'a, T> {\n     }\n }\n \n-impl<'a, T> ExactSizeIterator<&'a mut T> for MutItems<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n \n // A by-value RingBuf iterator\n-pub struct MoveItems<T> {\n+pub struct IntoIter<T> {\n     inner: RingBuf<T>,\n }\n \n-impl<T> Iterator<T> for MoveItems<T> {\n+impl<T> Iterator<T> for IntoIter<T> {\n     #[inline]\n     fn next(&mut self) -> Option<T> {\n         self.inner.pop_front()\n@@ -1244,14 +1244,14 @@ impl<T> Iterator<T> for MoveItems<T> {\n     }\n }\n \n-impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n+impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n-impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n+impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n \n /// A draining RingBuf iterator\n pub struct Drain<'a, T: 'a> {"}, {"sha": "d6d94f57acf45b88c6739aa9c3736980c833a799", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -37,7 +37,7 @@\n //!\n //! ## Structs\n //!\n-//! There are several structs that are useful for slices, such as `Items`, which\n+//! There are several structs that are useful for slices, such as `Iter`, which\n //! represents iteration over a slice.\n //!\n //! ## Traits\n@@ -104,7 +104,7 @@ use self::Direction::*;\n use vec::Vec;\n \n pub use core::slice::{Chunks, AsSlice, SplitsN, Windows};\n-pub use core::slice::{Items, MutItems, PartialEqSliceExt};\n+pub use core::slice::{Iter, IterMut, PartialEqSliceExt};\n pub use core::slice::{ImmutableIntSlice, MutableIntSlice};\n pub use core::slice::{MutSplits, MutChunks, Splits};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n@@ -771,7 +771,7 @@ pub trait SliceExt<T> for Sized? {\n \n     /// Returns an iterator over the slice\n     #[unstable = \"iterator type may change\"]\n-    fn iter(&self) -> Items<T>;\n+    fn iter(&self) -> Iter<T>;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`.  The matched element is not contained in the subslices.\n@@ -970,7 +970,7 @@ pub trait SliceExt<T> for Sized? {\n \n     /// Returns an iterator that allows modifying each value\n     #[unstable = \"waiting on iterator type name conventions\"]\n-    fn iter_mut(&mut self) -> MutItems<T>;\n+    fn iter_mut(&mut self) -> IterMut<T>;\n \n     /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n     #[unstable = \"name may change\"]\n@@ -1137,7 +1137,7 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn iter<'a>(&'a self) -> Items<'a, T> {\n+    fn iter<'a>(&'a self) -> Iter<'a, T> {\n         core_slice::SliceExt::iter(self)\n     }\n \n@@ -1246,7 +1246,7 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n+    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         core_slice::SliceExt::iter_mut(self)\n     }\n "}, {"sha": "fa0e4a2340e2aac37cad0a601e384b6efd4b44aa", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -888,7 +888,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveItems<T> {\n+    pub fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n             let ptr = self.ptr;\n             let cap = self.cap;\n@@ -899,7 +899,7 @@ impl<T> Vec<T> {\n                 ptr.offset(self.len() as int) as *const T\n             };\n             mem::forget(self);\n-            MoveItems { allocation: ptr, cap: cap, ptr: begin, end: end }\n+            IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n         }\n     }\n \n@@ -1402,21 +1402,21 @@ impl<T:fmt::Show> fmt::Show for Vec<T> {\n }\n \n /// An iterator that moves out of a vector.\n-pub struct MoveItems<T> {\n+pub struct IntoIter<T> {\n     allocation: *mut T, // the block of memory allocated for the vector\n     cap: uint, // the capacity of the vector\n     ptr: *const T,\n     end: *const T\n }\n \n-impl<T> MoveItems<T> {\n+impl<T> IntoIter<T> {\n     /// Drops all items that have not yet been moved and returns the empty vector.\n     #[inline]\n     #[unstable]\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n             for _x in self { }\n-            let MoveItems { allocation, cap, ptr: _ptr, end: _end } = self;\n+            let IntoIter { allocation, cap, ptr: _ptr, end: _end } = self;\n             mem::forget(self);\n             Vec { ptr: allocation, cap: cap, len: 0 }\n         }\n@@ -1427,7 +1427,7 @@ impl<T> MoveItems<T> {\n     pub fn unwrap(self) -> Vec<T> { self.into_inner() }\n }\n \n-impl<T> Iterator<T> for MoveItems<T> {\n+impl<T> Iterator<T> for IntoIter<T> {\n     #[inline]\n     fn next<'a>(&'a mut self) -> Option<T> {\n         unsafe {\n@@ -1461,7 +1461,7 @@ impl<T> Iterator<T> for MoveItems<T> {\n     }\n }\n \n-impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n+impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n     #[inline]\n     fn next_back<'a>(&'a mut self) -> Option<T> {\n         unsafe {\n@@ -1484,10 +1484,10 @@ impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n     }\n }\n \n-impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n+impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n \n #[unsafe_destructor]\n-impl<T> Drop for MoveItems<T> {\n+impl<T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n         if self.cap != 0 {"}, {"sha": "802be4271898483411a94e89fa331eef2ae8e515", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -235,13 +235,13 @@ impl<V> VecMap<V> {\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(&mut self) -> MoveItems<V> {\n+    pub fn into_iter(&mut self) -> IntoIter<V> {\n         fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n             v.map(|v| (i, v))\n         }\n \n         let values = replace(&mut self.v, vec!());\n-        MoveItems { iter: values.into_iter().enumerate().filter_map(filter) }\n+        IntoIter { iter: values.into_iter().enumerate().filter_map(filter) }\n     }\n \n     /// Return the number of elements in the map.\n@@ -608,7 +608,7 @@ macro_rules! double_ended_iterator {\n pub struct Entries<'a, V:'a> {\n     front: uint,\n     back: uint,\n-    iter: slice::Items<'a, Option<V>>\n+    iter: slice::Iter<'a, Option<V>>\n }\n \n iterator! { impl Entries -> (uint, &'a V), as_ref }\n@@ -619,7 +619,7 @@ double_ended_iterator! { impl Entries -> (uint, &'a V), as_ref }\n pub struct MutEntries<'a, V:'a> {\n     front: uint,\n     back: uint,\n-    iter: slice::MutItems<'a, Option<V>>\n+    iter: slice::IterMut<'a, Option<V>>\n }\n \n iterator! { impl MutEntries -> (uint, &'a mut V), as_mut }\n@@ -636,11 +636,11 @@ pub struct Values<'a, V: 'a> {\n }\n \n /// A consuming iterator over the key-value pairs of a map.\n-pub struct MoveItems<V> {\n+pub struct IntoIter<V> {\n     iter: FilterMap<\n     (uint, Option<V>),\n     (uint, V),\n-    Enumerate<vec::MoveItems<Option<V>>>,\n+    Enumerate<vec::IntoIter<Option<V>>>,\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }\n \n@@ -662,11 +662,11 @@ impl<'a, V> DoubleEndedIterator<&'a V> for Values<'a, V> {\n }\n \n \n-impl<V> Iterator<(uint, V)> for MoveItems<V> {\n+impl<V> Iterator<(uint, V)> for IntoIter<V> {\n     fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-impl<V> DoubleEndedIterator<(uint, V)> for MoveItems<V> {\n+impl<V> DoubleEndedIterator<(uint, V)> for IntoIter<V> {\n     fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n }\n "}, {"sha": "96f67ac4f7a11ba6be02fc1725e7df528ac15bf0", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -89,7 +89,7 @@ pub struct Formatter<'a> {\n     precision: Option<uint>,\n \n     buf: &'a mut (FormatWriter+'a),\n-    curarg: slice::Items<'a, Argument<'a>>,\n+    curarg: slice::Iter<'a, Argument<'a>>,\n     args: &'a [Argument<'a>],\n }\n "}, {"sha": "6092a45c97d930670fbcccfbe2fcaa0dee418337", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -67,7 +67,7 @@ pub trait SliceExt<T> for Sized? {\n     fn slice_from<'a>(&'a self, start: uint) -> &'a [T];\n     fn slice_to<'a>(&'a self, end: uint) -> &'a [T];\n     fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]);\n-    fn iter<'a>(&'a self) -> Items<'a, T>;\n+    fn iter<'a>(&'a self) -> Iter<'a, T>;\n     fn split<'a, P>(&'a self, pred: P) -> Splits<'a, T, P>\n                     where P: FnMut(&T) -> bool;\n     fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>>\n@@ -92,7 +92,7 @@ pub trait SliceExt<T> for Sized? {\n     fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T];\n     fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T];\n     fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T];\n-    fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T>;\n+    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T>;\n     fn head_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n     fn tail_mut<'a>(&'a mut self) -> &'a mut [T];\n     fn init_mut<'a>(&'a mut self) -> &'a mut [T];\n@@ -141,15 +141,15 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn iter<'a>(&'a self) -> Items<'a, T> {\n+    fn iter<'a>(&'a self) -> Iter<'a, T> {\n         unsafe {\n             let p = self.as_ptr();\n             if mem::size_of::<T>() == 0 {\n-                Items{ptr: p,\n+                Iter{ptr: p,\n                       end: (p as uint + self.len()) as *const T,\n                       marker: marker::ContravariantLifetime::<'a>}\n             } else {\n-                Items{ptr: p,\n+                Iter{ptr: p,\n                       end: p.offset(self.len() as int),\n                       marker: marker::ContravariantLifetime::<'a>}\n             }\n@@ -286,15 +286,15 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[inline]\n-    fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n+    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         unsafe {\n             let p = self.as_mut_ptr();\n             if mem::size_of::<T>() == 0 {\n-                MutItems{ptr: p,\n+                IterMut{ptr: p,\n                          end: (p as uint + self.len()) as *mut T,\n                          marker: marker::ContravariantLifetime::<'a>}\n             } else {\n-                MutItems{ptr: p,\n+                IterMut{ptr: p,\n                          end: p.offset(self.len() as int),\n                          marker: marker::ContravariantLifetime::<'a>}\n             }\n@@ -655,7 +655,7 @@ impl<'a, T> Default for &'a [T] {\n // Iterators\n //\n \n-// The shared definition of the `Item` and `MutItems` iterators\n+// The shared definition of the `Item` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n         #[experimental = \"needs review\"]\n@@ -738,14 +738,14 @@ macro_rules! make_slice {\n \n /// Immutable slice iterator\n #[experimental = \"needs review\"]\n-pub struct Items<'a, T: 'a> {\n+pub struct Iter<'a, T: 'a> {\n     ptr: *const T,\n     end: *const T,\n     marker: marker::ContravariantLifetime<'a>\n }\n \n #[experimental]\n-impl<'a, T> ops::Slice<uint, [T]> for Items<'a, T> {\n+impl<'a, T> ops::Slice<uint, [T]> for Iter<'a, T> {\n     fn as_slice_(&self) -> &[T] {\n         self.as_slice()\n     }\n@@ -763,7 +763,7 @@ impl<'a, T> ops::Slice<uint, [T]> for Items<'a, T> {\n     }\n }\n \n-impl<'a, T> Items<'a, T> {\n+impl<'a, T> Iter<'a, T> {\n     /// View the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n@@ -774,20 +774,20 @@ impl<'a, T> Items<'a, T> {\n     }\n }\n \n-impl<'a,T> Copy for Items<'a,T> {}\n+impl<'a,T> Copy for Iter<'a,T> {}\n \n-iterator!{struct Items -> *const T, &'a T}\n+iterator!{struct Iter -> *const T, &'a T}\n \n #[experimental = \"needs review\"]\n-impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n-#[stable]\n-impl<'a, T> Clone for Items<'a, T> {\n-    fn clone(&self) -> Items<'a, T> { *self }\n+    #[experimental = \"needs review\"]\n+impl<'a, T> Clone for Iter<'a, T> {\n+    fn clone(&self) -> Iter<'a, T> { *self }\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n+impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         let (exact, _) = self.size_hint();\n@@ -813,14 +813,14 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n \n /// Mutable slice iterator.\n #[experimental = \"needs review\"]\n-pub struct MutItems<'a, T: 'a> {\n+pub struct IterMut<'a, T: 'a> {\n     ptr: *mut T,\n     end: *mut T,\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n #[experimental]\n-impl<'a, T> ops::Slice<uint, [T]> for MutItems<'a, T> {\n+impl<'a, T> ops::Slice<uint, [T]> for IterMut<'a, T> {\n     fn as_slice_<'b>(&'b self) -> &'b [T] {\n         make_slice!(T -> &'b [T]: self.ptr, self.end)\n     }\n@@ -839,7 +839,7 @@ impl<'a, T> ops::Slice<uint, [T]> for MutItems<'a, T> {\n }\n \n #[experimental]\n-impl<'a, T> ops::SliceMut<uint, [T]> for MutItems<'a, T> {\n+impl<'a, T> ops::SliceMut<uint, [T]> for IterMut<'a, T> {\n     fn as_mut_slice_<'b>(&'b mut self) -> &'b mut [T] {\n         make_slice!(T -> &'b mut [T]: self.ptr, self.end)\n     }\n@@ -857,7 +857,7 @@ impl<'a, T> ops::SliceMut<uint, [T]> for MutItems<'a, T> {\n     }\n }\n \n-impl<'a, T> MutItems<'a, T> {\n+impl<'a, T> IterMut<'a, T> {\n     /// View the underlying data as a subslice of the original data.\n     ///\n     /// To avoid creating `&mut` references that alias, this is forced\n@@ -870,10 +870,10 @@ impl<'a, T> MutItems<'a, T> {\n     }\n }\n \n-iterator!{struct MutItems -> *mut T, &'a mut T}\n+iterator!{struct IterMut -> *mut T, &'a mut T}\n \n #[experimental = \"needs review\"]\n-impl<'a, T> ExactSizeIterator<&'a mut T> for MutItems<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n \n /// An abstraction over the splitting iterators, so that splitn, splitn_mut etc\n /// can be implemented once."}, {"sha": "e147229bcbddf5c0477e40d8763ce7d6937ff836", "filename": "src/libcore/str.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -167,7 +167,7 @@ Section: Iterators\n /// Created with the method `.chars()`.\n #[deriving(Clone, Copy)]\n pub struct Chars<'a> {\n-    iter: slice::Items<'a, u8>\n+    iter: slice::Iter<'a, u8>\n }\n \n // Return the initial codepoint accumulator for the first byte.\n@@ -315,7 +315,7 @@ impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n \n /// External iterator for a string's bytes.\n /// Use with the `std::iter` module.\n-pub type Bytes<'a> = Map<&'a u8, u8, slice::Items<'a, u8>, BytesFn>;\n+pub type Bytes<'a> = Map<&'a u8, u8, slice::Iter<'a, u8>, BytesFn>;\n \n /// A temporary new type wrapper that ensures that the `Bytes` iterator\n /// is cloneable.\n@@ -893,7 +893,7 @@ Section: Misc\n /// `iter` reset such that it is pointing at the first byte in the\n /// invalid sequence.\n #[inline(always)]\n-fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>) -> bool {\n+fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>) -> bool {\n     loop {\n         // save the current thing we're pointing at.\n         let old = *iter;\n@@ -993,7 +993,7 @@ pub fn is_utf16(v: &[u16]) -> bool {\n /// of `u16`s.\n #[deriving(Clone)]\n pub struct Utf16Items<'a> {\n-    iter: slice::Items<'a, u16>\n+    iter: slice::Iter<'a, u16>\n }\n /// The possibilities for values decoded from a `u16` stream.\n #[deriving(Copy, PartialEq, Eq, Clone, Show)]\n@@ -2366,4 +2366,3 @@ impl<'a> Default for &'a str {\n     #[stable]\n     fn default() -> &'a str { \"\" }\n }\n-"}, {"sha": "88483b6c935435dc440afb03026c995fb4743af0", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -63,7 +63,7 @@ impl<'a,T> IntoMaybeOwnedVector<'a,T> for &'a [T] {\n }\n \n impl<'a,T> MaybeOwnedVector<'a,T> {\n-    pub fn iter(&'a self) -> slice::Items<'a,T> {\n+    pub fn iter(&'a self) -> slice::Iter<'a,T> {\n         match self {\n             &Growable(ref v) => v.as_slice().iter(),\n             &Borrowed(ref v) => v.iter(),"}, {"sha": "bd11f38c14344250731e54c1b341df65a091699f", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -370,7 +370,7 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n \n fn enabled(level: u32,\n            module: &str,\n-           iter: slice::Items<directive::LogDirective>)\n+           iter: slice::Iter<directive::LogDirective>)\n            -> bool {\n     // Search for the longest match, the vector is assumed to be pre-sorted.\n     for directive in iter.rev() {"}, {"sha": "5c84c0a55d6908ef56927fb8746a6d7212258c00", "filename": "src/libregex/re.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -540,8 +540,8 @@ impl Regex {\n }\n \n pub enum NamesIter<'a> {\n-    NamesIterNative(::std::slice::Items<'a, Option<&'static str>>),\n-    NamesIterDynamic(::std::slice::Items<'a, Option<String>>)\n+    NamesIterNative(::std::slice::Iter<'a, Option<&'static str>>),\n+    NamesIterDynamic(::std::slice::Iter<'a, Option<String>>)\n }\n \n impl<'a> Iterator<Option<String>> for NamesIter<'a> {"}, {"sha": "967e7f070c5ae19697571b910e4234f723052c92", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -65,7 +65,7 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn items<'a>(&'a self) -> Enumerate<slice::Items<'a, Option<ast::DefId>>> {\n+    pub fn items<'a>(&'a self) -> Enumerate<slice::Iter<'a, Option<ast::DefId>>> {\n         self.items.iter().enumerate()\n     }\n "}, {"sha": "6098e0065e04ce71ae71797fd7e177c1f71bd3e6", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -18,7 +18,7 @@ use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n use std::fmt;\n-use std::slice::Items;\n+use std::slice::Iter;\n use std::vec::Vec;\n use syntax::codemap::{Span, DUMMY_SP};\n \n@@ -400,7 +400,7 @@ impl<T> VecPerParamSpace<T> {\n         &self.get_slice(space)[index]\n     }\n \n-    pub fn iter<'a>(&'a self) -> Items<'a,T> {\n+    pub fn iter<'a>(&'a self) -> Iter<'a,T> {\n         self.content.iter()\n     }\n "}, {"sha": "8028971a46346270ba41d91bfa83dae77c25d327", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -19,7 +19,7 @@ use middle::subst;\n use middle::ty::{mod, Ty};\n use middle::infer::InferCtxt;\n use std::rc::Rc;\n-use std::slice::Items;\n+use std::slice::Iter;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n \n@@ -304,7 +304,7 @@ impl<'tcx> ObligationCause<'tcx> {\n }\n \n impl<'tcx, N> Vtable<'tcx, N> {\n-    pub fn iter_nested(&self) -> Items<N> {\n+    pub fn iter_nested(&self) -> Iter<N> {\n         match *self {\n             VtableImpl(ref i) => i.iter_nested(),\n             VtableFnPointer(..) => (&[]).iter(),\n@@ -338,7 +338,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n }\n \n impl<'tcx, N> VtableImplData<'tcx, N> {\n-    pub fn iter_nested(&self) -> Items<N> {\n+    pub fn iter_nested(&self) -> Iter<N> {\n         self.nested.iter()\n     }\n \n@@ -365,7 +365,7 @@ impl<'tcx, N> VtableImplData<'tcx, N> {\n }\n \n impl<N> VtableBuiltinData<N> {\n-    pub fn iter_nested(&self) -> Items<N> {\n+    pub fn iter_nested(&self) -> Iter<N> {\n         self.nested.iter()\n     }\n "}, {"sha": "c8c7297f790a7f32951b1ba9efc13f5f294d62a6", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -73,9 +73,9 @@ impl<'a> Iterator<PathElem> for LinkedPath<'a> {\n     }\n }\n \n-// HACK(eddyb) move this into libstd (value wrapper for slice::Items).\n+// HACK(eddyb) move this into libstd (value wrapper for slice::Iter).\n #[deriving(Clone)]\n-pub struct Values<'a, T:'a>(pub slice::Items<'a, T>);\n+pub struct Values<'a, T:'a>(pub slice::Iter<'a, T>);\n \n impl<'a, T: Copy> Iterator<T> for Values<'a, T> {\n     fn next(&mut self) -> Option<T> {"}, {"sha": "2f06271d8de3954266addda65797476b1610807f", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -766,7 +766,7 @@ impl<'a> MethodDef<'a> {\n         let fields = if raw_fields.len() > 0 {\n             let mut raw_fields = raw_fields.into_iter().map(|v| v.into_iter());\n             let first_field = raw_fields.next().unwrap();\n-            let mut other_fields: Vec<vec::MoveItems<(Span, Option<Ident>, P<Expr>)>>\n+            let mut other_fields: Vec<vec::IntoIter<(Span, Option<Ident>, P<Expr>)>>\n                 = raw_fields.collect();\n             first_field.map(|(span, opt_id, field)| {\n                 FieldInfo {"}, {"sha": "3023c547fb05302e1eccc647a0c16577788085bc", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -45,7 +45,7 @@ impl<T> OwnedSlice<T> {\n         &*self.data\n     }\n \n-    pub fn move_iter(self) -> vec::MoveItems<T> {\n+    pub fn move_iter(self) -> vec::IntoIter<T> {\n         self.into_vec().into_iter()\n     }\n "}, {"sha": "946181770c8e95d7437c88b21151046ba51aeaa6", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n use self::SmallVectorRepr::*;\n-use self::MoveItemsRepr::*;\n+use self::IntoIterRepr::*;\n \n use std::mem;\n use std::slice;\n@@ -111,17 +111,17 @@ impl<T> SmallVector<T> {\n \n     /// Deprecated: use `into_iter`.\n     #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> MoveItems<T> {\n+    pub fn move_iter(self) -> IntoIter<T> {\n         self.into_iter()\n     }\n \n-    pub fn into_iter(self) -> MoveItems<T> {\n+    pub fn into_iter(self) -> IntoIter<T> {\n         let repr = match self.repr {\n             Zero => ZeroIterator,\n             One(v) => OneIterator(v),\n             Many(vs) => ManyIterator(vs.into_iter())\n         };\n-        MoveItems { repr: repr }\n+        IntoIter { repr: repr }\n     }\n \n     pub fn len(&self) -> uint {\n@@ -135,17 +135,17 @@ impl<T> SmallVector<T> {\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n-pub struct MoveItems<T> {\n-    repr: MoveItemsRepr<T>,\n+pub struct IntoIter<T> {\n+    repr: IntoIterRepr<T>,\n }\n \n-enum MoveItemsRepr<T> {\n+enum IntoIterRepr<T> {\n     ZeroIterator,\n     OneIterator(T),\n-    ManyIterator(vec::MoveItems<T>),\n+    ManyIterator(vec::IntoIter<T>),\n }\n \n-impl<T> Iterator<T> for MoveItems<T> {\n+impl<T> Iterator<T> for IntoIter<T> {\n     fn next(&mut self) -> Option<T> {\n         match self.repr {\n             ZeroIterator => None,"}, {"sha": "6aa6b02857fbe3d86646dea5d27e79a8f181a5e2", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -130,7 +130,7 @@ struct Table {\n \n struct Items<'a> {\n     cur: Option<&'a Entry>,\n-    items: slice::Items<'a, Option<Box<Entry>>>,\n+    items: slice::Iter<'a, Option<Box<Entry>>>,\n }\n \n impl Table {"}, {"sha": "de934286a7cba65010cb1500694953750dd42d74", "filename": "src/test/compile-fail/resolve-conflict-type-vs-import.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::slice::Items;\n-//~^ ERROR import `Items` conflicts with type in this module\n+use std::slice::Iter;\n+//~^ ERROR import `Iter` conflicts with type in this module\n \n-struct Items;\n+struct Iter;\n \n fn main() {\n }"}, {"sha": "1282077028ffbe93128ed341ade6c20e077831c9", "filename": "src/test/run-pass/issue-13167.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Ftest%2Frun-pass%2Fissue-13167.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7/src%2Ftest%2Frun-pass%2Fissue-13167.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13167.rs?ref=f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "patch": "@@ -11,7 +11,7 @@\n use std::slice;\n \n pub struct PhfMapEntries<'a, T: 'a> {\n-    iter: slice::Items<'a, (&'static str, T)>,\n+    iter: slice::Iter<'a, (&'static str, T)>,\n }\n \n impl<'a, T> Iterator<(&'static str, &'a T)> for PhfMapEntries<'a, T> {"}]}