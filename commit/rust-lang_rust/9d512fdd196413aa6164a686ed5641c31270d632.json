{"sha": "9d512fdd196413aa6164a686ed5641c31270d632", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNTEyZmRkMTk2NDEzYWE2MTY0YTY4NmVkNTY0MWMzMTI3MGQ2MzI=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-05-03T17:09:49Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-05-05T20:54:34Z"}, "message": "TRPL: guessing game\n\nThis also made me realize that I wasn't using the correct term,\n'associated functions', rather than 'static methods'. So I corrected\nthat in the method syntax chapter.", "tree": {"sha": "1b570a67c6a705cd557bf7ceaa01be6d593140c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b570a67c6a705cd557bf7ceaa01be6d593140c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d512fdd196413aa6164a686ed5641c31270d632", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d512fdd196413aa6164a686ed5641c31270d632", "html_url": "https://github.com/rust-lang/rust/commit/9d512fdd196413aa6164a686ed5641c31270d632", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d512fdd196413aa6164a686ed5641c31270d632/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26933a638c360442412b51aa70fe25e419f44314", "url": "https://api.github.com/repos/rust-lang/rust/commits/26933a638c360442412b51aa70fe25e419f44314", "html_url": "https://github.com/rust-lang/rust/commit/26933a638c360442412b51aa70fe25e419f44314"}], "stats": {"total": 1016, "additions": 1011, "deletions": 5}, "files": [{"sha": "fb04b323cb05cb1f517b47e35b59f91b35aec49f", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d512fdd196413aa6164a686ed5641c31270d632/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/9d512fdd196413aa6164a686ed5641c31270d632/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=9d512fdd196413aa6164a686ed5641c31270d632", "patch": "@@ -5,6 +5,7 @@\n     * [Hello, world!](hello-world.md)\n     * [Hello, Cargo!](hello-cargo.md)\n * [Learn Rust](learn-rust.md)\n+    * [Guessing Game](guessing-game.md)\n * [Effective Rust](effective-rust.md)\n     * [The Stack and the Heap](the-stack-and-the-heap.md)\n     * [Testing](testing.md)"}, {"sha": "431b7dc50a29983fa471b8e1490a892290f36a34", "filename": "src/doc/trpl/guessing-game.md", "status": "added", "additions": 999, "deletions": 0, "changes": 999, "blob_url": "https://github.com/rust-lang/rust/blob/9d512fdd196413aa6164a686ed5641c31270d632/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/9d512fdd196413aa6164a686ed5641c31270d632/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=9d512fdd196413aa6164a686ed5641c31270d632", "patch": "@@ -0,0 +1,999 @@\n+% Guessing Game\n+\n+For our first project, we\u2019ll implement a classic beginner programming problem:\n+the guessing game. Here\u2019s how it works: Our program will generate a random\n+integer between one and a hundred. It will then prompt us to enter a guess.\n+Upon entering our guess, it will tell us if we\u2019re too low or too high. Once we\n+guess correctly, it will congratulate us. Sounds good?\n+\n+# Set up\n+\n+Let\u2019s set up a new project. Go to your projects directory. Remember how we had\n+to create our directory structure and a `Cargo.toml` for `hello_world`? Cargo\n+has a command that does that for us. Let\u2019s give it a shot:\n+\n+```bash\n+$ cd ~/projects\n+$ cargo new guessing_game --bin\n+$ cd guessing_game\n+```\n+\n+We pass the name of our project to `cargo new`, and then the `--bin` flag,\n+since we\u2019re making a binary, rather than a library.\n+\n+Check out the generated `Cargo.toml`:\n+\n+```toml\n+[package]\n+\n+name = \"guessing_game\"\n+version = \"0.0.1\"\n+authors = [\"Your Name <you@example.com>\"]\n+```\n+\n+Cargo gets this information from your environment. If it\u2019s not correct, go ahead\n+and fix that.\n+\n+Finally, Cargo generated a \u2018Hello, world!\u2019 for us. Check out `src/main.rs`:\n+\n+```rust\n+fn main() {\n+    println!(\"Hello, world!\")\n+}\n+```\n+\n+Let\u2019s try compiling what Cargo gave us:\n+\n+```{bash}\n+$ cargo build\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+```\n+\n+Excellent! Open up your `src/main.rs` again. We\u2019ll be writing all of\n+our code in this file.\n+\n+Before we move on, let me show you one more Cargo command: `run`. `cargo run`\n+is kind of like `cargo build`, but it also then runs the produced executable.\n+Try it out:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/debug/guessing_game`\n+Hello, world!\n+```\n+\n+Great! The `run` command comes in handy when you need to rapidly iterate on a\n+project. Our game is just such a project, we need to quickly test each\n+iteration before moving on to the next one.\n+\n+# Processing a Guess\n+\n+Let\u2019s get to it! The first thing we need to do for our guessing game is\n+allow our player to input a guess. Put this in your `src/main.rs`:\n+\n+```rust,no_run\n+use std::io;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    println!(\"Please input your guess.\");\n+\n+    let mut guess = String::new();\n+\n+    let input = io::stdin().read_line(&mut guess)\n+        .ok()\n+        .expect(\"Failed to read line\");\n+\n+    println!(\"You guessed: {}\", input);\n+}\n+```\n+\n+There\u2019s a lot here! Let\u2019s go over it, bit by bit.\n+\n+```rust,ignore\n+use std::io;\n+```\n+\n+We\u2019ll need to take user input, and then print the result as output. As such, we\n+need the `io` library from the standard library. Rust only imports a few things\n+into every program, [the \u2018prelude\u2019][prelude]. If it\u2019s not in the prelude,\n+you\u2019ll have to `use` it directly.\n+\n+[prelude]: ../std/prelude/index.html\n+\n+```rust,ignore\n+fn main() {\n+```\n+\n+As you\u2019ve seen before, the `main()` function is the entry point into your\n+program. The `fn` syntax declares a new function, the `()`s indicate that\n+there are no arguments, and `{` starts the body of the function. Because\n+we didn\u2019t include a return type, it\u2019s assumed to be `()`, an empty\n+[tuple][tuples].\n+\n+[tuples]: primitive-types.html#tuples\n+\n+```rust,ignore\n+    println!(\"Guess the number!\");\n+\n+    println!(\"Please input your guess.\");\n+```\n+\n+We previously learned that `println!()` is a [macro][macros] that\n+prints a [string][strings] to the screen.\n+\n+[macros]: macros.html\n+[strings]: strings.html\n+\n+```rust,ignore\n+    let mut guess = String::new();\n+```\n+\n+Now we\u2019re getting interesting! There\u2019s a lot going on in this little line. The first thing to notice is that this is a [let statement][let], which is used to create \u2018variable bindings\u2019. They take this form:\n+\n+```rust,ignore\n+let foo = bar;\n+```\n+\n+[let]: variable-bindings.html\n+\n+This will create a new binding named `foo`, and bind it to the value `bar`. In\n+many languages, this is called a \u2018variable\u2019, but Rust\u2019s variable bindings have\n+a few tricks up their sleeves.\n+\n+For example, they\u2019re [immutable][immutable] by default. That\u2019s why our example\n+uses `mut`: it makes a binding mutable, rather than immutable. `let` doesn\u2019t\n+take a name on the left hand side, it actually accepts a\n+\u2018[pattern][patterns]\u2019. We\u2019ll use patterns more later. It\u2019s easy enough\n+to use for now:\n+\n+```\n+let foo = 5; // immutable.\n+let mut bar = 5; // mutable\n+```\n+\n+[immutable]: mutability.html\n+[patterns]: patterns.html\n+\n+Oh, and `//` will start a comment, until the end of the line. Rust ignores\n+everything in [comments][comments].\n+\n+[comments]: comments.html\n+\n+So now we know that `let mut guess` will introduce a mutable binding named\n+`guess`, but we have to look at the other side of the `=` for what it\u2019s\n+bound to: `String::new()`.\n+\n+`String` is a string type, provided by the standard library. A\n+[`String`][string] is a growable, UTF-8 encoded bit of text.\n+\n+[string]: ../std/string/struct.String.html\n+\n+The `::new()` syntax is uses `::` because this is an \u2018associated function\u2019 of\n+a particular type. That is to say, it\u2019s associated with `String` itself,\n+rather than a particular instance of a `String`. Some languages call this a\n+\u2018static method\u2019.\n+\n+This function is named `new()`, because it creates a new, empty `String`.\n+You\u2019ll find a `new()` function on many types, as it\u2019s a common name for making\n+a new value of some kind.\n+\n+Let\u2019s move forward:\n+\n+```rust,ignore\n+    io::stdin().read_line(&mut guess)\n+        .ok()\n+        .expect(\"Failed to read line\");\n+```\n+\n+That\u2019s a lot more! Let\u2019s go bit-by-bit. The first line has two parts. Here\u2019s\n+the first:\n+\n+```rust,ignore\n+io::stdin()\n+```\n+\n+Remember how we `use`d `std::io` on the first line of the program? We\u2019re now\n+calling an associated function on it. If we didn\u2019t `use std::io`, we could\n+have written this line as `std::io::stdin()`.\n+\n+This particular function returns a handle to the standard input for your\n+terminal. More specifically, a [std::io::Stdin][iostdin].\n+\n+[iostdin]: ../std/io/struct.Stdin.html\n+\n+The next part will use this handle to get input from the user:\n+\n+```rust,ignore\n+.read_line(&mut guess)\n+```\n+\n+Here, we call the [`read_line()`][read_line] method on our handle.\n+[Method][method]s are like associated functions, but are only available on a\n+particular instance of a type, rather than the type itself. We\u2019re also passing\n+one argument to `read_line()`: `&mut guess`.\n+\n+[read_line]: ../std/io/struct.Stdin.html#method.read_line\n+[method]: methods.html\n+\n+Remember how we bound `guess` above? We said it was mutable. However,\n+`read_line` doesn\u2019t take a `String` as an argument: it takes a `&mut String`.\n+Rust has a feature called \u2018[references][references]\u2019, which allows you to have\n+multiple references to one piece of data, which can reduce copying. References\n+are a complex feature, as one of Rust\u2019s major selling points is how safe and\n+easy it is to use references. We don\u2019t need to know a lot of those details to\n+finish our program right now, though. For now, all we need to know is that\n+like `let` bindings, references are immutable by default. Hence, we need to\n+write `&mut guess`, rather than `&guess`.\n+\n+Why does `read_line()` take a mutable reference to a string? Its job is\n+to take what the user types into standard input, and place that into a\n+string. So it takes that string as an argument, and in order to add\n+the input, it needs to be mutable.\n+\n+[references]: references-and-borrowing.html\n+\n+But we\u2019re not quite done with this line of code, though. While it\u2019s\n+a single line of text, it\u2019s only the first part of the single logical line of\n+code:\n+\n+```rust,ignore\n+        .ok()\n+        .expect(\"Failed to read line\");\n+```\n+\n+When you call a method with the `.foo()` syntax, you may introduce a newline\n+and other whitespace. This helps you split up long lines. We _could_ have\n+done:\n+\n+```rust,ignore\n+    io::stdin().read_line(&mut guess).ok().expect(\"failed to read line\");\n+```\n+\n+But that gets hard to read. So we\u2019ve split it up, three lines for three\n+method calls. We already talked about `read_line()`, but what about `ok()`\n+and `expect()`? Well, we already mentioned that `read_line()` puts what\n+the user types into the `&mut String` we pass it. But it also returns\n+a value: in this case, an [`io::Result`][ioresult]. Rust has a number of\n+types named `Result` in its standard library: a generic [`Result`][result],\n+and then specific versions for sub-libraries, like `io::Result`.\n+\n+[ioresult]: ../std/io/type.Result.html\n+[result]: ../std/result/enum.Result.html\n+\n+The purpose of these `Result` types is to encode error handling information.\n+Values of the `Result` type, like any type, have methods defined on them. In\n+this case, `io::Result` has an `ok()` method, which says \u2018we want to assume\n+this value is a successful one. If not, just throw away the error\n+information\u2019. Why throw it away? Well, for a basic program, we just want to\n+print a generic error, as basically any issue means we can\u2019t continue. The\n+[`ok()` method][ok] returns a value which has another method defined on it:\n+`expect()`. The [`expect()` method][expect] takes a value it\u2019s called on, and\n+if it isn\u2019t a successful one, [`panic!`][panic]s with a message you passed you\n+passed it. A `panic!` like this will cause our program to crash, displaying\n+the message.\n+\n+[ok]: ../std/result/enum.Result.html#method.ok\n+[expect]: ../std/option/enum.Option.html#method.expect\n+[panic]: error-handling.html\n+\n+If we leave off calling these two methods, our program will compile, but\n+we\u2019ll get a warning:\n+\n+```bash\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+src/main.rs:10:5: 10:39 warning: unused result which must be used,\n+#[warn(unused_must_use)] on by default\n+src/main.rs:10     io::stdin().read_line(&mut guess);\n+                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+```\n+\n+Rust warns us that we haven\u2019t used the `Result` value. This warning comes from\n+a special annotation that `io::Result` has. Rust is trying to tell you that\n+you haven\u2019t handled a possible error. The right way to suppress the error is\n+to actually write error handling. Luckily, if we just want to crash if there\u2019s\n+a problem, we can use these two little methods. If we can recover from the\n+error somehow, we\u2019d do something else, but we\u2019ll save that for a future\n+project.\n+\n+There\u2019s just one line of this first example left:\n+\n+```rust,ignore\n+    println!(\"You guessed: {}\", input);\n+}\n+```\n+\n+This prints out the string we saved our input in. The `{}`s are a placeholder,\n+and so we pass it `input` as an argument. If we had multiple `{}`s, we would\n+pass multiple arguments:\n+\n+```rust\n+let x = 5;\n+let y = 10;\n+\n+println!(\"x and y: {} and {}\", x, y);\n+```\n+\n+Easy.\n+\n+Anyway, that\u2019s the tour. We can run what we have with `cargo run`:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+     Running `target/debug/guessing_game`\n+Guess the number!\n+Please input your guess.\n+6\n+You guessed: 6\n+```\n+\n+All right! Our first part is done: we can get input from the keyboard,\n+and then print it back out.\n+\n+# Generating a secret number\n+\n+Next, we need to generate a secret number. Rust does not yet include random\n+number functionality in its standard library. The Rust team does, however,\n+provide a [`rand` crate][randcrate]. A \u2018crate\u2019 is a package of Rust code.\n+We\u2019ve been building a \u2018binary crate\u2019, which is an executable. `rand` is a\n+\u2018library crate\u2019, which contains code that\u2019s intended to be used with other\n+programs.\n+\n+[randcrate]: https://crates.io/crates/rand\n+\n+Using external crates is where Cargo really shines. Before we can write\n+the code using `rand`, we need to modify our `Cargo.toml`. Open it up, and\n+add these few lines at the bottom:\n+\n+```toml\n+[dependencies]\n+\n+rand=\"0.3.0\"\n+```\n+\n+The `[dependencies]` section of `Cargo.toml` is like the `[package]` section:\n+everything that follows it is part of it, until the next section starts.\n+Cargo uses the dependencies section to know what dependencies on external\n+crates you have, and what versions you require. In this case, we\u2019ve used `*`,\n+which means that we\u2019ll use the latest version of `rand`. Cargo understands\n+[Semantic Versioning][semver], which is a standard for writing version\n+numbers. If we wanted a specific version or range of versions, we could be\n+more specific here. [Cargo\u2019s documentation][cargodoc] contains more details.\n+\n+[semver]: http://semver.org\n+[cargodoc]: http://doc.crates.io/crates-io.html\n+\n+Now, without changing any of our code, let\u2019s build our project:\n+\n+```bash\n+$ cargo build\n+    Updating registry `https://github.com/rust-lang/crates.io-index`\n+ Downloading rand v0.3.8\n+ Downloading libc v0.1.6\n+   Compiling libc v0.1.6\n+   Compiling rand v0.3.8\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+```\n+\n+(You may see different versions, of course.)\n+\n+Lots of new output! Now that we have an external dependency, Cargo fetches the\n+latest versions of everything from the registry, which is a copy of data from\n+[Crates.io][cratesio]. Crates.io is where people in the Rust ecosystem\n+post their open source Rust projects for others to use.\n+\n+[cratesio]: https://crates.io\n+\n+After updating the registry, Cargo checks our `[dependencies]` and downloads\n+any we don\u2019t have yet. In this case, while we only said we wanted to depend on\n+`rand`, we\u2019ve also grabbed a copy of `libc`. This is because `rand` depends on\n+`libc` to work. After downloading them, it compiles them, and then compiles\n+our project.\n+\n+If we run `cargo build` again, we\u2019ll get different output:\n+\n+```bash\n+$ cargo build\n+```\n+\n+That\u2019s right, no output! Cargo knows that our project has been built, and that\n+all of its dependencies are built, and so there\u2019s no reason to do all that\n+stuff. With nothing to do, it simply exits. If we open up `src/main.rs` again,\n+make a trivial change, and then save it again, we\u2019ll just see one line:\n+\n+```bash\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+```\n+\n+So, we told Cargo we wanted any version of `rand`, and so it fetched the\n+latest version at the time this was written, `v0.3.8`. But what happens\n+when next week, version `v0.4.0` comes out, which changes something with\n+`rand`, and it includes a breaking change? After all, a `v0.y.z` version\n+in SemVer can change every release.\n+\n+The answer to this problem is the `Cargo.lock` file you\u2019ll now find in your\n+project directory. When you build your project for the first time, Cargo\n+figures out all of the versions that fit your criteria, and then writes them\n+to the `Cargo.lock` file. When you build your project in the future, Cargo\n+will see that the `Cargo.lock` file exists, and then use that specific version\n+rather than do all the work of figuring out versions again. This lets you\n+have a repeatable build automatically.\n+\n+What about when we _do_ want to use `v0.4.0`? Cargo has another command,\n+`update`, which says \u2018ignore the lock, figure out all the latest versions that\n+fit what we\u2019ve specified. If that works, write those versions out to the lock\n+file\u2019.\n+\n+There\u2019s a lot more to say about [Cargo][doccargo] and [its\n+ecosystem][doccratesio], but for now, that\u2019s all we need to know. Cargo makes\n+it really easy to re-use libraries, and so Rustaceans tend to write smaller\n+projects which are assembled out of a number of sub-packages.\n+\n+[doccargo]: http://doc.crates.io\n+[doccratesio]: http://doc.crates.io/crates-io.html\n+\n+Let\u2019s get on to actually _using_ `rand`. Here\u2019s our next step:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let mut guess = String::new();\n+\n+    io::stdin().read_line(&mut guess)\n+        .ok()\n+        .expect(\"failed to read line\");\n+\n+    println!(\"You guessed: {}\", guess);\n+}\n+```\n+\n+The first thing we\u2019ve done is change the first line. It now says\n+`extern crate rand`. Because we declared `rand` in our `[dependencies]`, we\n+can use `extern crate` to let Rust know we\u2019ll be making use of it. This also\n+does the equivalent of a `use rand;` as well, so we can make use of anything\n+in the `rand` crate by prefixing it with `rand::`.\n+\n+Next, we added another `use` line: `use rand::Rng`. We\u2019re going to use a\n+method in a moment, and it requires that `Rng` be in scope to work. The basic\n+idea is this: methods are defined on something called \u2018traits\u2019, and for the\n+method to work, it needs the trait to be in scope. For more about the\n+details, read the [traits][traits] section.\n+\n+[traits]: traits.html\n+\n+There are two other lines we added, in the middle:\n+\n+```rust,ignore\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+```\n+\n+We use the `rand::thread_rng()` function to get a copy of the random number\n+generator, which is local to the particular [thread][concurrency] of execution\n+we\u2019re in. Because we `use rand::Rng`\u2019d above, it has a `gen_range()` method\n+available. This method takes two arguments, and generates a number between\n+them. It\u2019s inclusive on the lower bound, but exclusive on the upper bound,\n+so we need `1` and `101` to get a number between one and a hundred.\n+\n+[concurrency]: concurrency.html\n+\n+The second line just prints out the secret number. This is useful while\n+we\u2019re developing our program, so we can easily test it out. But we\u2019ll be\n+deleting it for the final version. It\u2019s not much of a game if it prints out\n+the answer when you start it up!\n+\n+Try running our new program a few times:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+     Running `target/debug/guessing_game`\n+Guess the number!\n+The secret number is: 7\n+Please input your guess.\n+4\n+You guessed: 4\n+$ cargo run\n+     Running `target/debug/guessing_game`\n+Guess the number!\n+The secret number is: 83\n+Please input your guess.\n+5\n+You guessed: 5\n+```\n+\n+Great! Next up: let\u2019s compare our guess to the secret guess.\n+\n+# Comparing guesses\n+\n+Now that we\u2019ve got user input, let\u2019s compare our guess to the random guess.\n+Here\u2019s our next step, though it doesn\u2019t quite work yet:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let mut guess = String::new();\n+\n+    io::stdin().read_line(&mut guess)\n+        .ok()\n+        .expect(\"failed to read line\");\n+\n+    println!(\"You guessed: {}\", guess);\n+\n+    match guess.cmp(&secret_number) {\n+        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Greater => println!(\"Too big!\"),\n+        Ordering::Equal   => println!(\"You win!\"),\n+    }\n+}\n+```\n+\n+A few new bits here. The first is another `use`. We bring a type called\n+`std::cmp::Ordering` into scope. Then, five new lines at the bottom that use\n+it:\n+\n+```rust,ignore\n+match guess.cmp(&secret_number) {\n+    Ordering::Less    => println!(\"Too small!\"),\n+    Ordering::Greater => println!(\"Too big!\"),\n+    Ordering::Equal   => println!(\"You win!\"),\n+}\n+```\n+\n+The `cmp()` method can be called on anything that can be compared, and it\n+takes a reference to the thing you want to compare it to. It returns the\n+`Ordering` type we `use`d earlier. We use a [`match`][match] statement to\n+determine exactly what kind of `Ordering` it is. `Ordering` is an\n+[`enum`][enum], short for \u2018enumeration\u2019, which looks like this:\n+\n+```rust\n+enum Foo {\n+    Bar,\n+    Baz,\n+}\n+```\n+\n+[match]: match.html\n+[enum]: enums.html\n+\n+With this definition, anything of type `Foo` can be either a\n+`Foo::Bar` or a `Foo::Baz`. We use the `::` to indicate the\n+namespace for a particular `enum` variant.\n+\n+The [`Ordering`][ordering] enum has three possible variants: `Less`, `Equal`,\n+and `Greater`. The `match` statement takes a value of a type, and lets you\n+create an \u2018arm\u2019 for each possible value. Since we have three types of\n+`Ordering`, we have three arms:\n+\n+```rust,ignore\n+match guess.cmp(&secret_number) {\n+    Ordering::Less    => println!(\"Too small!\"),\n+    Ordering::Greater => println!(\"Too big!\"),\n+    Ordering::Equal   => println!(\"You win!\"),\n+}\n+```\n+\n+[ordering]: ../std/cmp/enum.Ordering.html\n+\n+If it\u2019s `Less`, we print `Too small!`, if it\u2019s `Greater`, `Too big!`, and if\n+`Equal`, `You win!`. `match` is really useful, and is used often in Rust.\n+\n+I did mention that this won\u2019t quite work yet, though. Let\u2019s try it:\n+\n+```bash\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+src/main.rs:28:21: 28:35 error: mismatched types:\n+ expected `&collections::string::String`,\n+    found `&_`\n+(expected struct `collections::string::String`,\n+    found integral variable) [E0308]\n+src/main.rs:28     match guess.cmp(&secret_number) {\n+                                   ^~~~~~~~~~~~~~\n+error: aborting due to previous error\n+Could not compile `guessing_game`.\n+```\n+\n+Whew! This is a big error. The core of it is that we have \u2018mismatched types\u2019.\n+Rust has a strong, static type system. However, it also has type inference.\n+When we wrote `let guess = String::new()`, Rust was able to infer that `guess`\n+should be a `String`, and so it doesn\u2019t make us write out the type. And with\n+our `secret_number`, there are a number of types which can have a value\n+between one and a hundred: `i32`, a thirty-two-bit number, or `u32`, an\n+unsigned thirty-two-bit number, or `i64`, a sixty-four-bit number. Or others.\n+So far, that hasn\u2019t mattered, and so Rust defaults to an `i32`. However, here,\n+Rust doesn\u2019t know how to compare the `guess` and the `secret_number`. They\n+need to be the same type. Ultimately, we want to convert the `String` we\n+read as input into a real number type, for comparison. We can do that\n+with three more lines. Here\u2019s our new program:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let mut guess = String::new();\n+\n+    io::stdin().read_line(&mut guess)\n+        .ok()\n+        .expect(\"failed to read line\");\n+\n+    let guess: u32 = guess.trim().parse()\n+        .ok()\n+        .expect(\"Please type a number!\");\n+\n+    println!(\"You guessed: {}\", guess);\n+\n+    match guess.cmp(&secret_number) {\n+        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Greater => println!(\"Too big!\"),\n+        Ordering::Equal   => println!(\"You win!\"),\n+    }\n+}\n+```\n+\n+The new three lines:\n+\n+```rust,ignore\n+    let guess: u32 = guess.trim().parse()\n+        .ok()\n+        .expect(\"Please type a number!\");\n+```\n+\n+Wait a minute, I thought we already had a `guess`? We do, but Rust allows us\n+to \u2018shadow\u2019 the previous `guess` with a new one. This is often used in this\n+exact situation, where `guess` starts as a `String`, but we want to convert it\n+to an `u32`. Shadowing lets us re-use the `guess` name, rather than forcing us\n+to come up with two unique names like `guess_str` and `guess`, or something\n+else.\n+\n+We bind `guess` to an expression that looks like something we wrote earlier:\n+\n+```rust,ignore\n+guess.trim().parse()\n+```\n+\n+Followed by an `ok().expect()` invocation. Here, `guess` refers to the old\n+`guess`, the one that was a `String` with our input in it. The `trim()`\n+method on `String`s will eliminate any white space at the beginning and end of\n+our string. This is important, as we had to press the \u2018return\u2019 key to satisfy\n+`read_line()`. This means that if we type `5` and hit return, `guess` looks\n+like this: `5\\n`. The `\\n` represents \u2018newline\u2019, the enter key. `trim()` gets\n+rid of this, leaving our string with just the `5`. The [`parse()` method on\n+strings][parse] parses a string into some kind of number. Since it can parse a\n+variety of numbers, we need to give Rust a hint as to the exact type of number\n+we want. Hence, `let guess: u32`. The colon (`:`) after `guess` tells Rust\n+we\u2019re going to annotate its type. `u32` is an unsigned, thirty-two bit\n+integer. Rust has [a number of built-in number types][number], but we\u2019ve\n+chosen `u32`. It\u2019s a good default choice for a small positive numer.\n+\n+[parse]: ../std/primitive.str.html#method.parse\n+[number]: primitive-types.html#numeric-types\n+\n+Just like `read_line()`, our call to `parse()` could cause an error. What if\n+our string contained `A\ud83d\udc4d%`? There\u2019d be no way to convert that to a number. As\n+such, we\u2019ll do the same thing we did with `read_line()`: use the `ok()` and\n+`expect()` methods to crash if there\u2019s an error.\n+\n+Let\u2019s try our program out!\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/guessing_game`\n+Guess the number!\n+The secret number is: 58\n+Please input your guess.\n+  76\n+You guessed: 76\n+Too big!\n+```\n+\n+Nice! You can see I even added spaces before my guess, and it still figured\n+out that I guessed 76. Run the program a few times, and verify that guessing\n+the number works, as well as guessing a number too small.\n+\n+Now we\u2019ve got most of the game working, but we can only make one guess. Let\u2019s\n+change that by adding loops!\n+\n+# Looping\n+\n+The `loop` keyword gives us an infinite loop. Let\u2019s add that in:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+        println!(\"Please input your guess.\");\n+\n+        let mut guess = String::new();\n+\n+        io::stdin().read_line(&mut guess)\n+            .ok()\n+            .expect(\"failed to read line\");\n+\n+        let guess: u32 = guess.trim().parse()\n+            .ok()\n+            .expect(\"Please type a number!\");\n+\n+        println!(\"You guessed: {}\", guess);\n+\n+        match guess.cmp(&secret_number) {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => println!(\"You win!\"),\n+        }\n+    }\n+}\n+```\n+\n+And try it out. But wait, didn\u2019t we just add an infinite loop? Yup. Remember\n+our discussion about `parse()`? If we give a non-number answer, we\u2019ll `return`\n+and quit. Observe:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/guessing_game`\n+Guess the number!\n+The secret number is: 59\n+Please input your guess.\n+45\n+You guessed: 45\n+Too small!\n+Please input your guess.\n+60\n+You guessed: 60\n+Too big!\n+Please input your guess.\n+59\n+You guessed: 59\n+You win!\n+Please input your guess.\n+quit\n+thread '<main>' panicked at 'Please type a number!'\n+```\n+\n+Ha! `quit` actually quits. As does any other non-number input. Well, this is\n+suboptimal to say the least. First, let\u2019s actually quit when you win the game:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+        println!(\"Please input your guess.\");\n+\n+        let mut guess = String::new();\n+\n+        io::stdin().read_line(&mut guess)\n+            .ok()\n+            .expect(\"failed to read line\");\n+\n+        let guess: u32 = guess.trim().parse()\n+            .ok()\n+            .expect(\"Please type a number!\");\n+\n+        println!(\"You guessed: {}\", guess);\n+\n+        match guess.cmp(&secret_number) {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => {\n+                println!(\"You win!\"),\n+                break;\n+            }\n+        }\n+    }\n+}\n+```\n+\n+By adding the `break` line after the `You win!`, we\u2019ll exit the loop when we\n+win. Exiting the loop also means exiting the program, since it\u2019s the last\n+thing in `main()`. We have just one more tweak to make: when someone inputs a\n+non-number, we don\u2019t want to quit, we just want to ignore it. We can do that\n+like this:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+        println!(\"Please input your guess.\");\n+\n+        let mut guess = String::new();\n+\n+        io::stdin().read_line(&mut guess)\n+            .ok()\n+            .expect(\"failed to read line\");\n+\n+        let guess: u32 = match guess.trim().parse() {\n+            Ok(num) => num,\n+            Err(_) => continue,\n+        };\n+\n+        println!(\"You guessed: {}\", guess);\n+\n+        match guess.cmp(&secret_number) {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => {\n+                println!(\"You win!\");\n+                break;\n+            }\n+        }\n+    }\n+}\n+```\n+\n+These are the lines that changed:\n+\n+```rust,ignore\n+let guess: u32 = match guess.trim().parse() {\n+    Ok(num) => num,\n+    Err(_) => continue,\n+};\n+```\n+\n+This is how you generally move from \u2018crash on error\u2019 to \u2018actually handle the\n+error\u2019, by switching from `ok().expect()` to a `match` statement. The `Result`\n+returned by `parse()` is an enum just like `Ordering`, but in this case, each\n+variant has some data associated with it: `Ok` is a success, and `Err` is a\n+failure. Each contains more information: the successful parsed integer, or an\n+error type. In this case, we `match` on `Ok(num)`, which sets the inner value\n+of the `Ok` to the name `num`, and then we just return it on the right-hand\n+side. In the `Err` case, we don\u2019t care what kind of error it is, so we just\n+use `_` intead of a name. This ignores the error, and `continue` causes us\n+to go to the next iteration of the `loop`.\n+\n+Now we should be good! Let\u2019s try:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/guessing_game`\n+Guess the number!\n+The secret number is: 61\n+Please input your guess.\n+10\n+You guessed: 10\n+Too small!\n+Please input your guess.\n+99\n+You guessed: 99\n+Too big!\n+Please input your guess.\n+foo\n+Please input your guess.\n+61\n+You guessed: 61\n+You win!\n+```\n+\n+Awesome! With one tiny last tweak, we have finished the guessing game. Can you\n+think of what it is? That\u2019s right, we don\u2019t want to print out the secret\n+number. It was good for testing, but it kind of ruins the game. Here\u2019s our\n+final source:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+        println!(\"Please input your guess.\");\n+\n+        let mut guess = String::new();\n+\n+        io::stdin().read_line(&mut guess)\n+            .ok()\n+            .expect(\"failed to read line\");\n+\n+        let guess: u32 = match guess.trim().parse() {\n+            Ok(num) => num,\n+            Err(_) => continue,\n+        };\n+\n+        println!(\"You guessed: {}\", guess);\n+\n+        match guess.cmp(&secret_number) {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => {\n+                println!(\"You win!\");\n+                break;\n+            }\n+        }\n+    }\n+}\n+```\n+\n+# Complete!\n+\n+At this point, you have successfully built the Guessing Game! Congratulations!\n+\n+This first project showed you a lot: `let`, `match`, methods, associated\n+functions, using external crates, and more. Our next project will show off\n+even more."}, {"sha": "1a02bc95e9d9c84247ff01c674415697457a0b04", "filename": "src/doc/trpl/learn-rust.md", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d512fdd196413aa6164a686ed5641c31270d632/src%2Fdoc%2Ftrpl%2Flearn-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/9d512fdd196413aa6164a686ed5641c31270d632/src%2Fdoc%2Ftrpl%2Flearn-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flearn-rust.md?ref=9d512fdd196413aa6164a686ed5641c31270d632", "patch": "@@ -1,4 +1,9 @@\n % Learn Rust\n \n-This section is coming soon! It will eventually have a few tutorials with\n-building real Rust projects, but they are under development.\n+Welcome! This section has a few tutorials that teach you Rust through building\n+projects. You\u2019ll get a high-level overview, but we\u2019ll skim over the details.\n+\n+If you\u2019d prefer a more \u2018from the ground up\u2019-style experience, check\n+out [Syntax and Semantics][ss].\n+\n+[ss]: syntax-and-semantics.html"}, {"sha": "ed4e9dd359b6d048159437bab7f4dfa466ca0111", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d512fdd196413aa6164a686ed5641c31270d632/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/9d512fdd196413aa6164a686ed5641c31270d632/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=9d512fdd196413aa6164a686ed5641c31270d632", "patch": "@@ -154,9 +154,10 @@ fn main() {\n }\n ```\n \n-This \u2018static method\u2019 builds a new `Circle` for us. Note that static methods\n-are called with the `Struct::method()` syntax, rather than the `ref.method()`\n-syntax.\n+This \u2018associated function\u2019 builds a new `Circle` for us. Note that associated\n+functions are called with the `Struct::function()` syntax, rather than the\n+`ref.method()` syntax. Some other langauges call associated functions \u2018static\n+methods\u2019.\n \n # Builder Pattern\n "}]}