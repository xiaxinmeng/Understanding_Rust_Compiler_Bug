{"sha": "38fdd50e0b16e947c5a3879f593f51fd769deae2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ZmRkNTBlMGIxNmU5NDdjNWEzODc5ZjU5M2Y1MWZkNzY5ZGVhZTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-01T08:41:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-02T17:25:06Z"}, "message": "Remove *most* mentions of phantom fns and variance on traits. Leave some\ncomments and also leave the entries in the variance tables for now.", "tree": {"sha": "b1b990c5eadbb2c6d79de39e9de6a1d253cbeebb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1b990c5eadbb2c6d79de39e9de6a1d253cbeebb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38fdd50e0b16e947c5a3879f593f51fd769deae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38fdd50e0b16e947c5a3879f593f51fd769deae2", "html_url": "https://github.com/rust-lang/rust/commit/38fdd50e0b16e947c5a3879f593f51fd769deae2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38fdd50e0b16e947c5a3879f593f51fd769deae2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "628d715ff42c83ab74bef3a5a5c5ac3c2f915c11", "url": "https://api.github.com/repos/rust-lang/rust/commits/628d715ff42c83ab74bef3a5a5c5ac3c2f915c11", "html_url": "https://github.com/rust-lang/rust/commit/628d715ff42c83ab74bef3a5a5c5ac3c2f915c11"}], "stats": {"total": 346, "additions": 174, "deletions": 172}, "files": [{"sha": "352f7d869774c3c18ed5feeefeedf8a149c73633", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=38fdd50e0b16e947c5a3879f593f51fd769deae2", "patch": "@@ -276,12 +276,15 @@ macro_rules! impls{\n #[unstable(feature = \"core\", reason = \"deprecated\")]\n #[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n #[allow(deprecated)]\n+#[cfg(stage0)]\n pub trait MarkerTrait : PhantomFn<Self,Self> { }\n-//                                    ~~~~~ <-- FIXME(#22806)?\n-//\n-// Marker trait has been made invariant so as to avoid inf recursion,\n-// but we should ideally solve the underlying problem. That's a bit\n-// complicated.\n+\n+/// `MarkerTrait` is deprecated and no longer needed.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n+#[allow(deprecated)]\n+#[cfg(not(stage0))]\n+pub trait MarkerTrait { }\n \n #[allow(deprecated)]\n impl<T:?Sized> MarkerTrait for T { }\n@@ -290,7 +293,20 @@ impl<T:?Sized> MarkerTrait for T { }\n #[lang=\"phantom_fn\"]\n #[unstable(feature = \"core\", reason = \"deprecated\")]\n #[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n-pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n+#[cfg(stage0)]\n+pub trait PhantomFn<A:?Sized,R:?Sized=()> {\n+}\n+\n+/// `PhantomFn` is a deprecated marker trait that is no longer needed.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n+#[cfg(not(stage0))]\n+pub trait PhantomFn<A:?Sized,R:?Sized=()> {\n+}\n+\n+#[allow(deprecated)]\n+#[cfg(not(stage0))]\n+impl<A:?Sized,R:?Sized,T:?Sized> PhantomFn<A,R> for T { }\n \n /// `PhantomData<T>` allows you to describe that a type acts as if it stores a value of type `T`,\n /// even though it does not. This allows you to inform the compiler about certain safety properties"}, {"sha": "89a8625856c2c61851d1e5258e63899677ea2ab0", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=38fdd50e0b16e947c5a3879f593f51fd769deae2", "patch": "@@ -321,7 +321,6 @@ lets_do_this! {\n     ExchangeHeapLangItem,            \"exchange_heap\",           exchange_heap;\n     OwnedBoxLangItem,                \"owned_box\",               owned_box;\n \n-    PhantomFnItem,                   \"phantom_fn\",              phantom_fn;\n     PhantomDataItem,                 \"phantom_data\",            phantom_data;\n \n     // Deprecated:"}, {"sha": "a2ff86cd065901d4115458f6a4fb323bde8541cb", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=38fdd50e0b16e947c5a3879f593f51fd769deae2", "patch": "@@ -138,11 +138,10 @@ fn supertraits_reference_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n             match predicate {\n                 ty::Predicate::Trait(ref data) => {\n                     // In the case of a trait predicate, we can skip the \"self\" type.\n-                    Some(data.def_id()) != tcx.lang_items.phantom_fn() &&\n-                        data.0.trait_ref.substs.types.get_slice(TypeSpace)\n-                                                     .iter()\n-                                                     .cloned()\n-                                                     .any(is_self)\n+                    data.0.trait_ref.substs.types.get_slice(TypeSpace)\n+                                                 .iter()\n+                                                 .cloned()\n+                                                 .any(is_self)\n                 }\n                 ty::Predicate::Projection(..) |\n                 ty::Predicate::TypeOutlives(..) |"}, {"sha": "ad7d96c652d9ba670be1df207c598d0c235df1b0", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=38fdd50e0b16e947c5a3879f593f51fd769deae2", "patch": "@@ -836,14 +836,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ambiguous: false\n         };\n \n-        // Check for the `PhantomFn` trait. This is really just a\n-        // special annotation that is *always* considered to match, no\n-        // matter what the type parameters are etc.\n-        if self.tcx().lang_items.phantom_fn() == Some(obligation.predicate.def_id()) {\n-            candidates.vec.push(PhantomFnCandidate);\n-            return Ok(candidates);\n-        }\n-\n         // Other bounds. Consider both in-scope bounds from fn decl\n         // and applicable impls. There is a certain set of precedence rules here.\n "}, {"sha": "eb06caf7d5a63ecb9a3f53b886620fa4fa817531", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 7, "deletions": 35, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=38fdd50e0b16e947c5a3879f593f51fd769deae2", "patch": "@@ -117,15 +117,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n                 self.check_variances_for_type_defn(item, ast_generics);\n             }\n-            ast::ItemTrait(_, ref ast_generics, _, ref items) => {\n+            ast::ItemTrait(_, _, _, ref items) => {\n                 let trait_predicates =\n                     ty::lookup_predicates(ccx.tcx, local_def(item.id));\n-                reject_non_type_param_bounds(\n-                    ccx.tcx,\n-                    item.span,\n-                    &trait_predicates);\n-                self.check_variances(item, ast_generics, &trait_predicates,\n-                                     self.tcx().lang_items.phantom_fn());\n+                reject_non_type_param_bounds(ccx.tcx, item.span, &trait_predicates);\n                 if ty::trait_has_default_impl(ccx.tcx, local_def(item.id)) {\n                     if !items.is_empty() {\n                         ccx.tcx.sess.span_err(\n@@ -287,30 +282,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                      ast_generics: &ast::Generics)\n     {\n         let item_def_id = local_def(item.id);\n-        let predicates = ty::lookup_predicates(self.tcx(), item_def_id);\n-        self.check_variances(item,\n-                             ast_generics,\n-                             &predicates,\n-                             self.tcx().lang_items.phantom_data());\n-    }\n-\n-    fn check_variances(&self,\n-                       item: &ast::Item,\n-                       ast_generics: &ast::Generics,\n-                       ty_predicates: &ty::GenericPredicates<'tcx>,\n-                       suggested_marker_id: Option<ast::DefId>)\n-    {\n-        let variance_lang_items = &[\n-            self.tcx().lang_items.phantom_fn(),\n-            self.tcx().lang_items.phantom_data(),\n-        ];\n-\n-        let item_def_id = local_def(item.id);\n-        let is_lang_item = variance_lang_items.iter().any(|n| *n == Some(item_def_id));\n-        if is_lang_item {\n-            return;\n-        }\n-\n+        let ty_predicates = ty::lookup_predicates(self.tcx(), item_def_id);\n         let variances = ty::item_variances(self.tcx(), item_def_id);\n \n         let mut constrained_parameters: HashSet<_> =\n@@ -331,7 +303,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 continue;\n             }\n             let span = self.ty_param_span(ast_generics, item, space, index);\n-            self.report_bivariance(span, param_ty.name, suggested_marker_id);\n+            self.report_bivariance(span, param_ty.name);\n         }\n \n         for (space, index, &variance) in variances.regions.iter_enumerated() {\n@@ -342,7 +314,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             assert_eq!(space, TypeSpace);\n             let span = ast_generics.lifetimes[index].lifetime.span;\n             let name = ast_generics.lifetimes[index].lifetime.name;\n-            self.report_bivariance(span, name, suggested_marker_id);\n+            self.report_bivariance(span, name);\n         }\n     }\n \n@@ -377,14 +349,14 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n     fn report_bivariance(&self,\n                          span: Span,\n-                         param_name: ast::Name,\n-                         suggested_marker_id: Option<ast::DefId>)\n+                         param_name: ast::Name)\n     {\n         self.tcx().sess.span_err(\n             span,\n             &format!(\"parameter `{}` is never used\",\n                      param_name.user_string(self.tcx())));\n \n+        let suggested_marker_id = self.tcx().lang_items.phantom_data();\n         match suggested_marker_id {\n             Some(def_id) => {\n                 self.tcx().sess.fileline_help("}, {"sha": "da2de731d648a570a8e06174a12eb882445e13b1", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 124, "deletions": 115, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=38fdd50e0b16e947c5a3879f593f51fd769deae2", "patch": "@@ -18,34 +18,121 @@\n //! defined on type `X`, we only consider the definition of the type `X`\n //! and the definitions of any types it references.\n //!\n-//! We only infer variance for type parameters found on *types*: structs,\n-//! enums, and traits. We do not infer variance for type parameters found\n-//! on fns or impls. This is because those things are not type definitions\n-//! and variance doesn't really make sense in that context.\n-//!\n-//! It is worth covering what variance means in each case. For structs and\n-//! enums, I think it is fairly straightforward. The variance of the type\n+//! We only infer variance for type parameters found on *data types*\n+//! like structs and enums. In these cases, there is fairly straightforward\n+//! explanation for what variance means. The variance of the type\n //! or lifetime parameters defines whether `T<A>` is a subtype of `T<B>`\n //! (resp. `T<'a>` and `T<'b>`) based on the relationship of `A` and `B`\n-//! (resp. `'a` and `'b`). (FIXME #3598 -- we do not currently make use of\n-//! the variances we compute for type parameters.)\n+//! (resp. `'a` and `'b`).\n+//!\n+//! We do not infer variance for type parameters found on traits, fns,\n+//! or impls. Variance on trait parameters can make indeed make sense\n+//! (and we used to compute it) but it is actually rather subtle in\n+//! meaning and not that useful in practice, so we removed it. See the\n+//! addendum for some details. Variances on fn/impl parameters, otoh,\n+//! doesn't make sense because these parameters are instantiated and\n+//! then forgotten, they don't persist in types or compiled\n+//! byproducts.\n+//!\n+//! ### The algorithm\n+//!\n+//! The basic idea is quite straightforward. We iterate over the types\n+//! defined and, for each use of a type parameter X, accumulate a\n+//! constraint indicating that the variance of X must be valid for the\n+//! variance of that use site. We then iteratively refine the variance of\n+//! X until all constraints are met. There is *always* a sol'n, because at\n+//! the limit we can declare all type parameters to be invariant and all\n+//! constraints will be satisfied.\n+//!\n+//! As a simple example, consider:\n+//!\n+//!     enum Option<A> { Some(A), None }\n+//!     enum OptionalFn<B> { Some(|B|), None }\n+//!     enum OptionalMap<C> { Some(|C| -> C), None }\n+//!\n+//! Here, we will generate the constraints:\n+//!\n+//!     1. V(A) <= +\n+//!     2. V(B) <= -\n+//!     3. V(C) <= +\n+//!     4. V(C) <= -\n+//!\n+//! These indicate that (1) the variance of A must be at most covariant;\n+//! (2) the variance of B must be at most contravariant; and (3, 4) the\n+//! variance of C must be at most covariant *and* contravariant. All of these\n+//! results are based on a variance lattice defined as follows:\n+//!\n+//!       *      Top (bivariant)\n+//!    -     +\n+//!       o      Bottom (invariant)\n+//!\n+//! Based on this lattice, the solution V(A)=+, V(B)=-, V(C)=o is the\n+//! optimal solution. Note that there is always a naive solution which\n+//! just declares all variables to be invariant.\n+//!\n+//! You may be wondering why fixed-point iteration is required. The reason\n+//! is that the variance of a use site may itself be a function of the\n+//! variance of other type parameters. In full generality, our constraints\n+//! take the form:\n+//!\n+//!     V(X) <= Term\n+//!     Term := + | - | * | o | V(X) | Term x Term\n+//!\n+//! Here the notation V(X) indicates the variance of a type/region\n+//! parameter `X` with respect to its defining class. `Term x Term`\n+//! represents the \"variance transform\" as defined in the paper:\n+//!\n+//!   If the variance of a type variable `X` in type expression `E` is `V2`\n+//!   and the definition-site variance of the [corresponding] type parameter\n+//!   of a class `C` is `V1`, then the variance of `X` in the type expression\n+//!   `C<E>` is `V3 = V1.xform(V2)`.\n+//!\n+//! ### Constraints\n+//!\n+//! If I have a struct or enum with where clauses:\n+//!\n+//!     struct Foo<T:Bar> { ... }\n+//!\n+//! you might wonder whether the variance of `T` with respect to `Bar`\n+//! affects the variance `T` with respect to `Foo`. I claim no.  The\n+//! reason: assume that `T` is invariant w/r/t `Bar` but covariant w/r/t\n+//! `Foo`. And then we have a `Foo<X>` that is upcast to `Foo<Y>`, where\n+//! `X <: Y`. However, while `X : Bar`, `Y : Bar` does not hold.  In that\n+//! case, the upcast will be illegal, but not because of a variance\n+//! failure, but rather because the target type `Foo<Y>` is itself just\n+//! not well-formed. Basically we get to assume well-formedness of all\n+//! types involved before considering variance.\n //!\n-//! ### Variance on traits\n+//! ### Addendum: Variance on traits\n //!\n-//! The meaning of variance for trait parameters is more subtle and worth\n-//! expanding upon. There are in fact two uses of the variance values we\n-//! compute.\n+//! As mentioned above, we used to permit variance on traits. This was\n+//! computed based on the appearance of trait type parameters in\n+//! method signatures and was used to represent the compatibility of\n+//! vtables in trait objects (and also \"virtual\" vtables or dictionary\n+//! in trait bounds). One complication was that variance for\n+//! associated types is less obvious, since they can be projected out\n+//! and put to myriad uses, so it's not clear when it is safe to allow\n+//! `X<A>::Bar` to vary (or indeed just what that means). Moreover (as\n+//! covered below) all inputs on any trait with an associated type had\n+//! to be invariant, limiting the applicability. Finally, the\n+//! annotations (`MarkerTrait`, `PhantomFn`) needed to ensure that all\n+//! trait type parameters had a variance were confusing and annoying\n+//! for little benefit.\n //!\n-//! #### Trait variance and object types\n+//! Just for historical reference,I am going to preserve some text indicating\n+//! how one could interpret variance and trait matching.\n //!\n-//! The first is for object types. Just as with structs and enums, we can\n-//! decide the subtyping relationship between two object types `&Trait<A>`\n-//! and `&Trait<B>` based on the relationship of `A` and `B`. Note that\n-//! for object types we ignore the `Self` type parameter -- it is unknown,\n-//! and the nature of dynamic dispatch ensures that we will always call a\n+//! #### Variance and object types\n+//!\n+//! Just as with structs and enums, we can decide the subtyping\n+//! relationship between two object types `&Trait<A>` and `&Trait<B>`\n+//! based on the relationship of `A` and `B`. Note that for object\n+//! types we ignore the `Self` type parameter -- it is unknown, and\n+//! the nature of dynamic dispatch ensures that we will always call a\n //! function that is expected the appropriate `Self` type. However, we\n-//! must be careful with the other type parameters, or else we could end\n-//! up calling a function that is expecting one type but provided another.\n+//! must be careful with the other type parameters, or else we could\n+//! end up calling a function that is expecting one type but provided\n+//! another.\n //!\n //! To see what I mean, consider a trait like so:\n //!\n@@ -135,104 +222,24 @@\n //!\n //! These conditions are satisfied and so we are happy.\n //!\n-//! ### The algorithm\n-//!\n-//! The basic idea is quite straightforward. We iterate over the types\n-//! defined and, for each use of a type parameter X, accumulate a\n-//! constraint indicating that the variance of X must be valid for the\n-//! variance of that use site. We then iteratively refine the variance of\n-//! X until all constraints are met. There is *always* a sol'n, because at\n-//! the limit we can declare all type parameters to be invariant and all\n-//! constraints will be satisfied.\n-//!\n-//! As a simple example, consider:\n-//!\n-//!     enum Option<A> { Some(A), None }\n-//!     enum OptionalFn<B> { Some(|B|), None }\n-//!     enum OptionalMap<C> { Some(|C| -> C), None }\n-//!\n-//! Here, we will generate the constraints:\n-//!\n-//!     1. V(A) <= +\n-//!     2. V(B) <= -\n-//!     3. V(C) <= +\n-//!     4. V(C) <= -\n-//!\n-//! These indicate that (1) the variance of A must be at most covariant;\n-//! (2) the variance of B must be at most contravariant; and (3, 4) the\n-//! variance of C must be at most covariant *and* contravariant. All of these\n-//! results are based on a variance lattice defined as follows:\n-//!\n-//!       *      Top (bivariant)\n-//!    -     +\n-//!       o      Bottom (invariant)\n+//! #### Variance and associated types\n //!\n-//! Based on this lattice, the solution V(A)=+, V(B)=-, V(C)=o is the\n-//! optimal solution. Note that there is always a naive solution which\n-//! just declares all variables to be invariant.\n-//!\n-//! You may be wondering why fixed-point iteration is required. The reason\n-//! is that the variance of a use site may itself be a function of the\n-//! variance of other type parameters. In full generality, our constraints\n-//! take the form:\n-//!\n-//!     V(X) <= Term\n-//!     Term := + | - | * | o | V(X) | Term x Term\n-//!\n-//! Here the notation V(X) indicates the variance of a type/region\n-//! parameter `X` with respect to its defining class. `Term x Term`\n-//! represents the \"variance transform\" as defined in the paper:\n-//!\n-//!   If the variance of a type variable `X` in type expression `E` is `V2`\n-//!   and the definition-site variance of the [corresponding] type parameter\n-//!   of a class `C` is `V1`, then the variance of `X` in the type expression\n-//!   `C<E>` is `V3 = V1.xform(V2)`.\n-//!\n-//! ### Constraints\n-//!\n-//! If I have a struct or enum with where clauses:\n-//!\n-//!     struct Foo<T:Bar> { ... }\n-//!\n-//! you might wonder whether the variance of `T` with respect to `Bar`\n-//! affects the variance `T` with respect to `Foo`. I claim no.  The\n-//! reason: assume that `T` is invariant w/r/t `Bar` but covariant w/r/t\n-//! `Foo`. And then we have a `Foo<X>` that is upcast to `Foo<Y>`, where\n-//! `X <: Y`. However, while `X : Bar`, `Y : Bar` does not hold.  In that\n-//! case, the upcast will be illegal, but not because of a variance\n-//! failure, but rather because the target type `Foo<Y>` is itself just\n-//! not well-formed. Basically we get to assume well-formedness of all\n-//! types involved before considering variance.\n-//!\n-//! ### Associated types\n-//!\n-//! Any trait with an associated type is invariant with respect to all\n-//! of its inputs. To see why this makes sense, consider what\n-//! subtyping for a trait reference means:\n+//! Traits with associated types -- or at minimum projection\n+//! expressions -- must be invariant with respect to all of their\n+//! inputs. To see why this makes sense, consider what subtyping for a\n+//! trait reference means:\n //!\n //!    <T as Trait> <: <U as Trait>\n //!\n-//! means that if I know that `T as Trait`,\n-//! I also know that `U as\n-//! Trait`. Moreover, if you think of it as\n-//! dictionary passing style, it means that\n-//! a dictionary for `<T as Trait>` is safe\n-//! to use where a dictionary for `<U as\n-//! Trait>` is expected.\n-//!\n-//! The problem is that when you can\n-//! project types out from `<T as Trait>`,\n-//! the relationship to types projected out\n-//! of `<U as Trait>` is completely unknown\n-//! unless `T==U` (see #21726 for more\n-//! details). Making `Trait` invariant\n-//! ensures that this is true.\n+//! means that if I know that `T as Trait`, I also know that `U as\n+//! Trait`. Moreover, if you think of it as dictionary passing style,\n+//! it means that a dictionary for `<T as Trait>` is safe to use where\n+//! a dictionary for `<U as Trait>` is expected.\n //!\n-//! *Historical note: we used to preserve this invariant another way,\n-//! by tweaking the subtyping rules and requiring that when a type `T`\n-//! appeared as part of a projection, that was considered an invariant\n-//! location, but this version does away with the need for those\n-//! somewhat \"special-case-feeling\" rules.*\n+//! The problem is that when you can project types out from `<T as\n+//! Trait>`, the relationship to types projected out of `<U as Trait>`\n+//! is completely unknown unless `T==U` (see #21726 for more\n+//! details). Making `Trait` invariant ensures that this is true.\n //!\n //! Another related reason is that if we didn't make traits with\n //! associated types invariant, then projection is no longer a\n@@ -383,7 +390,6 @@ fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n \n fn lang_items(tcx: &ty::ctxt) -> Vec<(ast::NodeId,Vec<ty::Variance>)> {\n     let all = vec![\n-        (tcx.lang_items.phantom_fn(), vec![ty::Contravariant, ty::Covariant]),\n         (tcx.lang_items.phantom_data(), vec![ty::Covariant]),\n         (tcx.lang_items.unsafe_cell_type(), vec![ty::Invariant]),\n \n@@ -520,6 +526,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n                 self.add_inferreds_for_item(item.id, false, generics);\n             }\n             ast::ItemTrait(_, ref generics, _, _) => {\n+                // Note: all inputs for traits are ultimately\n+                // constrained to be invariant. See `visit_item` in\n+                // the impl for `ConstraintContext` below.\n                 self.add_inferreds_for_item(item.id, true, generics);\n                 visit::walk_item(self, item);\n             }"}, {"sha": "1795ac95358d7c6c29c2bde494f0212b16ad6076", "filename": "src/test/compile-fail/variance-contravariant-arg-object.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs?ref=38fdd50e0b16e947c5a3879f593f51fd769deae2", "patch": "@@ -10,8 +10,8 @@\n \n #![allow(dead_code)]\n \n-// This test was previously testing variance on traits.\n-// But now that it is removed, both cases error.\n+// Test that even when `T` is only used in contravariant position, it\n+// is treated as invariant.\n \n trait Get<T> : 'static {\n     fn get(&self, t: T);"}, {"sha": "9b6e3c9de3bbd26482d1d2c82d9d1acccc0308f9", "filename": "src/test/compile-fail/variance-contravariant-arg-trait-match.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-trait-match.rs?ref=38fdd50e0b16e947c5a3879f593f51fd769deae2", "patch": "@@ -10,6 +10,9 @@\n \n #![allow(dead_code)]\n \n+// Test that even when `T` is only used in contravariant position, it\n+// is treated as invariant.\n+\n trait Get<T> {\n     fn get(&self, t: T);\n }"}, {"sha": "6d9d1e61fed61165e7fd2578870367e052c9aa9b", "filename": "src/test/compile-fail/variance-contravariant-self-trait-match.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-self-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-self-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-self-trait-match.rs?ref=38fdd50e0b16e947c5a3879f593f51fd769deae2", "patch": "@@ -10,6 +10,9 @@\n \n #![allow(dead_code)]\n \n+// Test that even when `Self` is only used in contravariant position, it\n+// is treated as invariant.\n+\n trait Get {\n     fn get(&self);\n }"}, {"sha": "ad059a467f570bb2d4b9e5ef872d907ff1f8522c", "filename": "src/test/compile-fail/variance-covariant-arg-object.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs?ref=38fdd50e0b16e947c5a3879f593f51fd769deae2", "patch": "@@ -10,6 +10,9 @@\n \n #![allow(dead_code)]\n \n+// Test that even when `T` is only used in covariant position, it\n+// is treated as invariant.\n+\n trait Get<T> : 'static {\n     fn get(&self) -> T;\n }"}, {"sha": "c42a845b3b504202b085664417e086e974dcccbf", "filename": "src/test/compile-fail/variance-covariant-arg-trait-match.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-trait-match.rs?ref=38fdd50e0b16e947c5a3879f593f51fd769deae2", "patch": "@@ -10,6 +10,9 @@\n \n #![allow(dead_code)]\n \n+// Test that even when `T` is only used in covariant position, it\n+// is treated as invariant.\n+\n trait Get<T> {\n     fn get(&self) -> T;\n }"}, {"sha": "25148dfc0208a672776bf3156ee56dc3700c7712", "filename": "src/test/compile-fail/variance-covariant-self-trait-match.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-self-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fdd50e0b16e947c5a3879f593f51fd769deae2/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-self-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-self-trait-match.rs?ref=38fdd50e0b16e947c5a3879f593f51fd769deae2", "patch": "@@ -10,6 +10,9 @@\n \n #![allow(dead_code)]\n \n+// Test that even when `Self` is only used in covariant position, it\n+// is treated as invariant.\n+\n trait Get {\n     fn get() -> Self;\n }"}]}