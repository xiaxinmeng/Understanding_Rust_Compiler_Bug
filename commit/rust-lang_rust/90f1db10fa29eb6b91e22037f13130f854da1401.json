{"sha": "90f1db10fa29eb6b91e22037f13130f854da1401", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwZjFkYjEwZmEyOWViNmI5MWUyMjAzN2YxMzEzMGY4NTRkYTE0MDE=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-02T23:51:39Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-08T08:54:41Z"}, "message": "remove headers from exchange allocations", "tree": {"sha": "ebaee526480dc5966e8b072d43dd607eb97a6cc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebaee526480dc5966e8b072d43dd607eb97a6cc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90f1db10fa29eb6b91e22037f13130f854da1401", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90f1db10fa29eb6b91e22037f13130f854da1401", "html_url": "https://github.com/rust-lang/rust/commit/90f1db10fa29eb6b91e22037f13130f854da1401", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90f1db10fa29eb6b91e22037f13130f854da1401/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0aedecf96b08c41ea481eaaebd4e5d2e2325d9c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0aedecf96b08c41ea481eaaebd4e5d2e2325d9c9", "html_url": "https://github.com/rust-lang/rust/commit/0aedecf96b08c41ea481eaaebd4e5d2e2325d9c9"}], "stats": {"total": 242, "additions": 166, "deletions": 76}, "files": [{"sha": "241b97e0e2ab2f9bd94cfc3343661913a3bc9282", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=90f1db10fa29eb6b91e22037f13130f854da1401", "patch": "@@ -1395,8 +1395,12 @@ pub fn compile_submatch(bcx: block,\n     }\n \n     if any_uniq_pat(m, col) {\n+        let pat_ty = node_id_type(bcx, pat_id);\n         let llbox = Load(bcx, val);\n-        let unboxed = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n+        let unboxed = match ty::get(pat_ty).sty {\n+            ty::ty_uniq(*) if !ty::type_contents(bcx.tcx(), pat_ty).contains_managed() => llbox,\n+            _ => GEPi(bcx, llbox, [0u, abi::box_field_body])\n+        };\n         compile_submatch(bcx, enter_uniq(bcx, dm, m, col, val),\n                          vec::append(~[unboxed], vals_left), chk);\n         return;\n@@ -1868,8 +1872,12 @@ pub fn bind_irrefutable_pat(bcx: block,\n             }\n         }\n         ast::pat_box(inner) | ast::pat_uniq(inner) => {\n+            let pat_ty = node_id_type(bcx, pat.id);\n             let llbox = Load(bcx, val);\n-            let unboxed = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n+            let unboxed = match ty::get(pat_ty).sty {\n+                ty::ty_uniq(*) if !ty::type_contents(bcx.tcx(), pat_ty).contains_managed() => llbox,\n+                    _ => GEPi(bcx, llbox, [0u, abi::box_field_body])\n+            };\n             bcx = bind_irrefutable_pat(bcx,\n                                        inner,\n                                        unboxed,"}, {"sha": "e2795f77d7d86b338a56edefe96df09c3c97171d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=90f1db10fa29eb6b91e22037f13130f854da1401", "patch": "@@ -289,24 +289,25 @@ pub fn malloc_raw_dyn(bcx: block,\n     let _icx = push_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n-    let (mk_fn, langcall) = match heap {\n-        heap_managed | heap_managed_unique => {\n-            (ty::mk_imm_box, bcx.tcx().lang_items.malloc_fn())\n-        }\n-        heap_exchange => {\n-            (ty::mk_imm_uniq, bcx.tcx().lang_items.exchange_malloc_fn())\n-        }\n-        heap_exchange_vector => {\n-            (ty::mk_imm_uniq, bcx.tcx().lang_items.vector_exchange_malloc_fn())\n-        }\n-        heap_exchange_closure => {\n-            (ty::mk_imm_uniq, bcx.tcx().lang_items.closure_exchange_malloc_fn())\n-        }\n-    };\n+    if heap == heap_exchange {\n+        let llty_value = type_of::type_of(ccx, t);\n+        let llalign = llalign_of_min(ccx, llty_value);\n \n-    if heap == heap_exchange || heap == heap_exchange_vector {\n+        // Allocate space:\n+        let rval = alloca(bcx, Type::i8p());\n+        let bcx = callee::trans_lang_call(\n+            bcx,\n+            bcx.tcx().lang_items.exchange_malloc_fn(),\n+            [C_i32(llalign as i32), size],\n+            expr::SaveIn(rval));\n+        rslt(bcx, PointerCast(bcx, Load(bcx, rval), llty_value.ptr_to()))\n+    } else if heap == heap_exchange_vector {\n         // Grab the TypeRef type of box_ptr_ty.\n-        let box_ptr_ty = mk_fn(bcx.tcx(), t);\n+        let element_type = match ty::get(t).sty {\n+            ty::ty_unboxed_vec(e) => e,\n+            _ => fail!(\"not a vector body\")\n+        };\n+        let box_ptr_ty = ty::mk_evec(bcx.tcx(), element_type, ty::vstore_uniq);\n         let llty = type_of(ccx, box_ptr_ty);\n \n         let llty_value = type_of::type_of(ccx, t);\n@@ -316,11 +317,22 @@ pub fn malloc_raw_dyn(bcx: block,\n         let rval = alloca(bcx, Type::i8p());\n         let bcx = callee::trans_lang_call(\n             bcx,\n-            langcall,\n+            bcx.tcx().lang_items.vector_exchange_malloc_fn(),\n             [C_i32(llalign as i32), size],\n             expr::SaveIn(rval));\n         rslt(bcx, PointerCast(bcx, Load(bcx, rval), llty))\n     } else {\n+        // we treat ~fn, @fn and @[] as @ here, which isn't ideal\n+        let (mk_fn, langcall) = match heap {\n+            heap_managed | heap_managed_unique => {\n+                (ty::mk_imm_box, bcx.tcx().lang_items.malloc_fn())\n+            }\n+            heap_exchange_closure => {\n+                (ty::mk_imm_box, bcx.tcx().lang_items.closure_exchange_malloc_fn())\n+            }\n+            _ => fail!(\"heap_exchange/heap_exchange_vector already handled\")\n+        };\n+\n         // Grab the TypeRef type of box_ptr_ty.\n         let box_ptr_ty = mk_fn(bcx.tcx(), t);\n         let llty = type_of(ccx, box_ptr_ty);\n@@ -362,16 +374,17 @@ pub struct MallocResult {\n // and pulls out the body\n pub fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef)\n     -> MallocResult {\n+    assert!(heap != heap_exchange);\n     let _icx = push_ctxt(\"malloc_general\");\n     let Result {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, t, heap, size);\n     let body = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n \n     MallocResult { bcx: bcx, box: llbox, body: body }\n }\n \n-pub fn malloc_general(bcx: block, t: ty::t, heap: heap)\n-    -> MallocResult {\n-        let ty = type_of(bcx.ccx(), t);\n+pub fn malloc_general(bcx: block, t: ty::t, heap: heap) -> MallocResult {\n+    let ty = type_of(bcx.ccx(), t);\n+    assert!(heap != heap_exchange);\n     malloc_general_dyn(bcx, t, heap, llsize_of(bcx.ccx(), ty))\n }\n pub fn malloc_boxed(bcx: block, t: ty::t)\n@@ -388,6 +401,7 @@ pub fn heap_for_unique(bcx: block, t: ty::t) -> heap {\n }\n \n pub fn maybe_set_managed_unique_rc(bcx: block, bx: ValueRef, heap: heap) {\n+    assert!(heap != heap_exchange);\n     if heap == heap_managed_unique {\n         // In cases where we are looking at a unique-typed allocation in the\n         // managed heap (thus have refcount 1 from the managed allocator),\n@@ -399,11 +413,6 @@ pub fn maybe_set_managed_unique_rc(bcx: block, bx: ValueRef, heap: heap) {\n     }\n }\n \n-pub fn malloc_unique(bcx: block, t: ty::t)\n-    -> MallocResult {\n-    malloc_general(bcx, t, heap_for_unique(bcx, t))\n-}\n-\n // Type descriptor and type glue stuff\n \n pub fn get_tydesc_simple(ccx: &mut CrateContext, t: ty::t) -> ValueRef {"}, {"sha": "e86709d72b329e296365339be90fa47d20b6337c", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=90f1db10fa29eb6b91e22037f13130f854da1401", "patch": "@@ -100,6 +100,7 @@ use middle::trans::glue;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::trans::write_guard;\n+use middle::trans::type_::Type;\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::ty_to_str;\n@@ -567,18 +568,31 @@ impl Datum {\n          * This datum must represent an @T or ~T box.  Returns a new\n          * by-ref datum of type T, pointing at the contents. */\n \n-        let content_ty = match ty::get(self.ty).sty {\n-            ty::ty_box(mt) | ty::ty_uniq(mt) => mt.ty,\n+        let (content_ty, header) = match ty::get(self.ty).sty {\n+            ty::ty_box(mt) => (mt.ty, true),\n+            ty::ty_uniq(mt) => (mt.ty, false),\n+            ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n+                let unit_ty = ty::sequence_element_type(bcx.tcx(), self.ty);\n+                let unboxed_vec_ty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n+                (unboxed_vec_ty, true)\n+            }\n             _ => {\n                 bcx.tcx().sess.bug(fmt!(\n                     \"box_body() invoked on non-box type %s\",\n                     ty_to_str(bcx.tcx(), self.ty)));\n             }\n         };\n \n-        let ptr = self.to_value_llval(bcx);\n-        let body = opaque_box_body(bcx, content_ty, ptr);\n-        Datum {val: body, ty: content_ty, mode: ByRef(ZeroMem)}\n+        if !header && !ty::type_contents(bcx.tcx(), content_ty).contains_managed() {\n+            let ptr = self.to_value_llval(bcx);\n+            let ty = type_of(bcx.ccx(), content_ty);\n+            let body = PointerCast(bcx, ptr, ty.ptr_to());\n+            Datum {val: body, ty: content_ty, mode: ByRef(ZeroMem)}\n+        } else { // has a header\n+            let ptr = self.to_value_llval(bcx);\n+            let body = opaque_box_body(bcx, content_ty, ptr);\n+            Datum {val: body, ty: content_ty, mode: ByRef(ZeroMem)}\n+        }\n     }\n \n     pub fn to_rptr(&self, bcx: block) -> Datum {"}, {"sha": "d2a83814f31220bcf51884fab831e124a3cbbe46", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=90f1db10fa29eb6b91e22037f13130f854da1401", "patch": "@@ -150,6 +150,7 @@ use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn,\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::Repr;\n+use middle::trans::machine::llsize_of;\n \n use middle::trans::type_::Type;\n \n@@ -1329,12 +1330,23 @@ fn trans_unary_datum(bcx: block,\n                         contents_ty: ty::t,\n                         heap: heap) -> DatumBlock {\n         let _icx = push_ctxt(\"trans_boxed_expr\");\n-        let base::MallocResult { bcx, box: bx, body } =\n-            base::malloc_general(bcx, contents_ty, heap);\n-        add_clean_free(bcx, bx, heap);\n-        let bcx = trans_into(bcx, contents, SaveIn(body));\n-        revoke_clean(bcx, bx);\n-        return immediate_rvalue_bcx(bcx, bx, box_ty);\n+        if heap == heap_exchange {\n+            let llty = type_of(bcx.ccx(), contents_ty);\n+            let size = llsize_of(bcx.ccx(), llty);\n+            let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, contents_ty,\n+                                                               heap_exchange, size);\n+            add_clean_free(bcx, val, heap_exchange);\n+            let bcx = trans_into(bcx, contents, SaveIn(val));\n+            revoke_clean(bcx, val);\n+            return immediate_rvalue_bcx(bcx, val, box_ty);\n+        } else {\n+            let base::MallocResult { bcx, box: bx, body } =\n+                base::malloc_general(bcx, contents_ty, heap);\n+            add_clean_free(bcx, bx, heap);\n+            let bcx = trans_into(bcx, contents, SaveIn(body));\n+            revoke_clean(bcx, bx);\n+            return immediate_rvalue_bcx(bcx, bx, box_ty);\n+        }\n     }\n }\n "}, {"sha": "682a4f133c08d3a845ac6e8345400e6b670defb2", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=90f1db10fa29eb6b91e22037f13130f854da1401", "patch": "@@ -386,7 +386,9 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_uniq(*) => {\n         uniq::make_free_glue(bcx, v, t)\n       }\n-      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n+      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n+        tvec::make_uniq_free_glue(bcx, v, t)\n+      }\n       ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n         make_free_glue(bcx, v,\n                        tvec::expand_boxed_vec_ty(bcx.tcx(), t));"}, {"sha": "14cc822b5a571687ecc97787076f20e03918404a", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=90f1db10fa29eb6b91e22037f13130f854da1401", "patch": "@@ -548,6 +548,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n \n     let _icx = push_ctxt(\"impl::trans_trait_callee\");\n     let ccx = bcx.ccx();\n+    let mut bcx = bcx;\n \n     // Load the vtable from the @Trait pair\n     debug!(\"(translating trait callee) loading vtable from pair %s\",\n@@ -576,6 +577,10 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n         }\n         ast::sty_region(*) => {\n             match store {\n+                ty::UniqTraitStore\n+                    if !ty::type_contents(bcx.tcx(), callee_ty).contains_managed() => {\n+                    llself = llbox;\n+                }\n                 ty::BoxTraitStore |\n                 ty::UniqTraitStore => {\n                     llself = GEPi(bcx, llbox, [0u, abi::box_field_body]);"}, {"sha": "de91993f345a83c10870baeb7d5478be36a1f82f", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=90f1db10fa29eb6b91e22037f13130f854da1401", "patch": "@@ -194,7 +194,11 @@ impl Reflector {\n           }\n           ty::ty_uniq(ref mt) => {\n               let extra = self.c_mt(mt);\n-              self.visit(\"uniq\", extra)\n+              if ty::type_contents(bcx.tcx(), t).contains_managed() {\n+                  self.visit(\"uniq_managed\", extra)\n+              } else {\n+                  self.visit(\"uniq\", extra)\n+              }\n           }\n           ty::ty_ptr(ref mt) => {\n               let extra = self.c_mt(mt);"}, {"sha": "809838ded0ab13fdc91b1f1419fca16e118b80c1", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=90f1db10fa29eb6b91e22037f13130f854da1401", "patch": "@@ -33,6 +33,23 @@ use std::option::None;\n use syntax::ast;\n use syntax::codemap;\n \n+pub fn make_uniq_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n+    -> block {\n+    let box_datum = immediate_rvalue(Load(bcx, vptrptr), box_ty);\n+\n+    let not_null = IsNotNull(bcx, box_datum.val);\n+    do with_cond(bcx, not_null) |bcx| {\n+        let body_datum = box_datum.box_body(bcx);\n+        let bcx = glue::drop_ty(bcx, body_datum.to_ref_llval(bcx),\n+                                body_datum.ty);\n+        if ty::type_contents(bcx.tcx(), box_ty).contains_managed() {\n+            glue::trans_free(bcx, box_datum.val)\n+        } else {\n+            glue::trans_exchange_free(bcx, box_datum.val)\n+        }\n+    }\n+}\n+\n // Boxed vector types are in some sense currently a \"shorthand\" for a box\n // containing an unboxed vector. This expands a boxed vector type into such an\n // expanded type. It doesn't respect mutability, but that doesn't matter at\n@@ -42,7 +59,7 @@ pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let unboxed_vec_ty = ty::mk_mut_unboxed_vec(tcx, unit_ty);\n     match ty::get(t).sty {\n       ty::ty_estr(ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_uniq) => {\n-        ty::mk_imm_uniq(tcx, unboxed_vec_ty)\n+        fail!(\"cannot treat vectors/strings as exchange allocations yet\");\n       }\n       ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) => {\n         ty::mk_imm_box(tcx, unboxed_vec_ty)"}, {"sha": "1d20481617575c5dfc39c0a257be0f3f14ea6eb1", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=90f1db10fa29eb6b91e22037f13130f854da1401", "patch": "@@ -72,29 +72,6 @@ pub fn type_of_fn_from_ty(cx: &mut CrateContext, fty: ty::t) -> Type {\n     }\n }\n \n-pub fn type_of_non_gc_box(cx: &mut CrateContext, t: ty::t) -> Type {\n-    assert!(!ty::type_needs_infer(t));\n-\n-    let t_norm = ty::normalize_ty(cx.tcx, t);\n-    if t != t_norm {\n-        type_of_non_gc_box(cx, t_norm)\n-    } else {\n-        match ty::get(t).sty {\n-          ty::ty_box(mt) => {\n-              let ty = type_of(cx, mt.ty);\n-              Type::box(cx, &ty).ptr_to()\n-          }\n-          ty::ty_uniq(mt) => {\n-              let ty = type_of(cx, mt.ty);\n-              Type::unique(cx, &ty).ptr_to()\n-          }\n-          _ => {\n-            cx.sess.bug(\"non-box in type_of_non_gc_box\");\n-          }\n-        }\n-    }\n-}\n-\n // A \"sizing type\" is an LLVM type, the size and alignment of which are\n // guaranteed to be equivalent to what you would get out of `type_of()`. It's\n // useful because:\n@@ -231,7 +208,11 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n       ty::ty_opaque_box => Type::opaque_box(cx).ptr_to(),\n       ty::ty_uniq(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n-          Type::unique(cx, &ty).ptr_to()\n+          if ty::type_contents(cx.tcx, mt.ty).contains_managed() {\n+              Type::unique(cx, &ty).ptr_to()\n+          } else {\n+              ty.ptr_to()\n+          }\n       }\n       ty::ty_evec(ref mt, ty::vstore_uniq) => {\n           let ty = type_of(cx, mt.ty);"}, {"sha": "df9e29cad7f78397fd82b718402d3c0abbb67447", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=90f1db10fa29eb6b91e22037f13130f854da1401", "patch": "@@ -17,6 +17,9 @@ use middle::trans::datum::immediate_rvalue;\n use middle::trans::datum;\n use middle::trans::glue;\n use middle::ty;\n+use middle::trans::machine::llsize_of;\n+use middle::trans::type_of;\n+use middle::trans::type_of::*;\n \n pub fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n     -> block {\n@@ -44,12 +47,21 @@ pub fn duplicate(bcx: block, src_box: ValueRef, src_ty: ty::t) -> Result {\n     let body_datum = src_datum.box_body(bcx);\n \n     // Malloc space in exchange heap and copy src into it\n-    let MallocResult {\n-        bcx: bcx,\n-        box: dst_box,\n-        body: dst_body\n-    } = malloc_unique(bcx, body_datum.ty);\n-    body_datum.copy_to(bcx, datum::INIT, dst_body);\n-\n-    rslt(bcx, dst_box)\n+    if ty::type_contents(bcx.tcx(), src_ty).contains_managed() {\n+        let MallocResult {\n+            bcx: bcx,\n+            box: dst_box,\n+            body: dst_body\n+        } = malloc_general(bcx, body_datum.ty, heap_managed_unique);\n+        body_datum.copy_to(bcx, datum::INIT, dst_body);\n+\n+        rslt(bcx, dst_box)\n+    } else {\n+        let body_datum = body_datum.to_value_datum(bcx);\n+        let llty = type_of(bcx.ccx(), body_datum.ty);\n+        let size = llsize_of(bcx.ccx(), llty);\n+        let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, body_datum.ty, heap_exchange, size);\n+        body_datum.copy_to(bcx, datum::INIT, val);\n+        Result { bcx: bcx, val: val }\n+    }\n }"}, {"sha": "9075133b08617b12f94674096c4b733bf3e1dcc2", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=90f1db10fa29eb6b91e22037f13130f854da1401", "patch": "@@ -248,6 +248,14 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n+    #[cfg(not(stage0))]\n+    fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~u8>();\n+        if ! self.inner.visit_uniq_managed(mtbl, inner) { return false; }\n+        self.bump_past::<~u8>();\n+        true\n+    }\n+\n     fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<*u8>();\n         if ! self.inner.visit_ptr(mtbl, inner) { return false; }"}, {"sha": "dd5075f8e66887a2913c5ff6036ddee219e1eb6e", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=90f1db10fa29eb6b91e22037f13130f854da1401", "patch": "@@ -300,6 +300,15 @@ impl TyVisitor for ReprVisitor {\n     }\n \n     fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write_char('~');\n+        self.write_mut_qualifier(mtbl);\n+        do self.get::<*c_void> |b| {\n+            self.visit_ptr_inner(*b, inner);\n+        }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write_char('~');\n         self.write_mut_qualifier(mtbl);\n         do self.get::<&managed::raw::BoxRepr> |b| {"}, {"sha": "54deb8924f5c708add448532266a1a8483cfa8aa", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=90f1db10fa29eb6b91e22037f13130f854da1401", "patch": "@@ -80,9 +80,8 @@ pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n #[cfg(not(stage0), not(test))]\n #[lang=\"exchange_malloc\"]\n #[inline]\n-pub unsafe fn exchange_malloc(align: u32, size: uintptr_t) -> *c_char {\n-    let total_size = get_box_size(size as uint, align as uint);\n-    malloc_raw(total_size as uint) as *c_char\n+pub unsafe fn exchange_malloc(_align: u32, size: uintptr_t) -> *c_char {\n+    malloc_raw(size as uint) as *c_char\n }\n \n #[cfg(not(test))]"}, {"sha": "ce5ccf2401dbd00ea6e64ad1e9ca14f6ae8f95ce", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=90f1db10fa29eb6b91e22037f13130f854da1401", "patch": "@@ -91,6 +91,7 @@ pub trait TyVisitor {\n \n     fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool;\n "}, {"sha": "53b39d5ed3038876612bf21144ae9d9277e02d40", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=90f1db10fa29eb6b91e22037f13130f854da1401", "patch": "@@ -232,6 +232,13 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n         true\n     }\n \n+    fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~u8>();\n+        if ! self.inner.visit_uniq_managed(mtbl, inner) { return false; }\n+        self.bump_past::<~u8>();\n+        true\n+    }\n+\n     fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<*u8>();\n         if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n@@ -552,6 +559,7 @@ impl TyVisitor for my_visitor {\n \n     fn visit_box(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_uniq(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_uniq_managed(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_ptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_rptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n "}, {"sha": "4ce229526ffbaf865b9178ca64526129eafdaf80", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f1db10fa29eb6b91e22037f13130f854da1401/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=90f1db10fa29eb6b91e22037f13130f854da1401", "patch": "@@ -70,6 +70,7 @@ impl TyVisitor for MyVisitor {\n \n     fn visit_box(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_uniq(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_uniq_managed(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_ptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_rptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n "}]}