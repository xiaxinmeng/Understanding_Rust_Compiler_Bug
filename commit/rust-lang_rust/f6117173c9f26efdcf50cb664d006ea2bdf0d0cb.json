{"sha": "f6117173c9f26efdcf50cb664d006ea2bdf0d0cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MTE3MTczYzlmMjZlZmRjZjUwY2I2NjRkMDA2ZWEyYmRmMGQwY2I=", "commit": {"author": {"name": "Rob Arnold", "email": "robarnold@cs.cmu.edu", "date": "2011-07-06T05:55:41Z"}, "committer": {"name": "Rob Arnold", "email": "robarnold@cs.cmu.edu", "date": "2011-07-07T03:41:24Z"}, "message": "Allocate rust_ivec buffers out of the kernel pool\n\nThe duplication of upcalls is due to the fact that the runtime is\nshared between stage0/rustc and stage1/rustc. Once snapshots are\nupdated, they should be de-duplicated.", "tree": {"sha": "04f20cc1e1a057d520b9329e343ef6b63ddb52e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04f20cc1e1a057d520b9329e343ef6b63ddb52e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb", "html_url": "https://github.com/rust-lang/rust/commit/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb/comments", "author": {"login": "robarnold", "id": 326113, "node_id": "MDQ6VXNlcjMyNjExMw==", "avatar_url": "https://avatars.githubusercontent.com/u/326113?v=4", "gravatar_id": "", "url": "https://api.github.com/users/robarnold", "html_url": "https://github.com/robarnold", "followers_url": "https://api.github.com/users/robarnold/followers", "following_url": "https://api.github.com/users/robarnold/following{/other_user}", "gists_url": "https://api.github.com/users/robarnold/gists{/gist_id}", "starred_url": "https://api.github.com/users/robarnold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/robarnold/subscriptions", "organizations_url": "https://api.github.com/users/robarnold/orgs", "repos_url": "https://api.github.com/users/robarnold/repos", "events_url": "https://api.github.com/users/robarnold/events{/privacy}", "received_events_url": "https://api.github.com/users/robarnold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "robarnold", "id": 326113, "node_id": "MDQ6VXNlcjMyNjExMw==", "avatar_url": "https://avatars.githubusercontent.com/u/326113?v=4", "gravatar_id": "", "url": "https://api.github.com/users/robarnold", "html_url": "https://github.com/robarnold", "followers_url": "https://api.github.com/users/robarnold/followers", "following_url": "https://api.github.com/users/robarnold/following{/other_user}", "gists_url": "https://api.github.com/users/robarnold/gists{/gist_id}", "starred_url": "https://api.github.com/users/robarnold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/robarnold/subscriptions", "organizations_url": "https://api.github.com/users/robarnold/orgs", "repos_url": "https://api.github.com/users/robarnold/repos", "events_url": "https://api.github.com/users/robarnold/events{/privacy}", "received_events_url": "https://api.github.com/users/robarnold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e2e1f7cb36aeac0abb730a752fcd78cf91a380f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e2e1f7cb36aeac0abb730a752fcd78cf91a380f", "html_url": "https://github.com/rust-lang/rust/commit/2e2e1f7cb36aeac0abb730a752fcd78cf91a380f"}], "stats": {"total": 194, "additions": 182, "deletions": 12}, "files": [{"sha": "db750fe7a6d7cd33abf9772a599b9ccc83a2fd9b", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=f6117173c9f26efdcf50cb664d006ea2bdf0d0cb", "patch": "@@ -47,6 +47,8 @@ type upcalls =\n         ValueRef exit,\n         ValueRef malloc,\n         ValueRef free,\n+        ValueRef shared_malloc,\n+        ValueRef shared_free,\n         ValueRef mark,\n         ValueRef new_str,\n         ValueRef dup_str,\n@@ -56,7 +58,9 @@ type upcalls =\n         ValueRef new_task,\n         ValueRef start_task,\n         ValueRef ivec_resize,\n-        ValueRef ivec_spill);\n+        ValueRef ivec_spill,\n+        ValueRef ivec_resize_shared,\n+        ValueRef ivec_spill_shared);\n \n fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n     fn decl(type_names tn, ModuleRef llmod, str name, vec[TypeRef] tys,\n@@ -97,6 +101,9 @@ fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n              malloc=d(\"malloc\", [T_size_t(), T_ptr(T_tydesc(tn))],\n                       T_ptr(T_i8())),\n              free=dv(\"free\", [T_ptr(T_i8()), T_int()]),\n+             shared_malloc=d(\"shared_malloc\",\n+                      [T_size_t(), T_ptr(T_tydesc(tn))], T_ptr(T_i8())),\n+             shared_free=dv(\"shared_free\", [T_ptr(T_i8())]),\n              mark=d(\"mark\", [T_ptr(T_i8())], T_int()),\n              new_str=d(\"new_str\", [T_ptr(T_i8()), T_size_t()],\n                        T_ptr(T_str())),\n@@ -119,7 +126,11 @@ fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n              ivec_resize=d(\"ivec_resize\", [T_ptr(T_opaque_ivec()), T_int()],\n                            T_void()),\n              ivec_spill=d(\"ivec_spill\", [T_ptr(T_opaque_ivec()), T_int()],\n-                          T_void()));\n+                          T_void()),\n+             ivec_resize_shared=d(\"ivec_resize_shared\",\n+                           [T_ptr(T_opaque_ivec()), T_int()], T_void()),\n+             ivec_spill_shared=d(\"ivec_spill_shared\",\n+                          [T_ptr(T_opaque_ivec()), T_int()], T_void()));\n }\n //\n // Local Variables:"}, {"sha": "6a7b5a412ded76841007d8894401eb426199b903", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=f6117173c9f26efdcf50cb664d006ea2bdf0d0cb", "patch": "@@ -1150,6 +1150,12 @@ fn trans_non_gc_free(&@block_ctxt cx, ValueRef v) -> result {\n     ret rslt(cx, C_int(0));\n }\n \n+fn trans_shared_free(&@block_ctxt cx, ValueRef v) -> result {\n+    cx.build.Call(cx.fcx.lcx.ccx.upcalls.shared_free,\n+                  [cx.fcx.lltaskptr, cx.build.PointerCast(v, T_ptr(T_i8()))]);\n+    ret rslt(cx, C_int(0));\n+}\n+\n fn find_scope_cx(&@block_ctxt cx) -> @block_ctxt {\n     if (cx.kind != NON_SCOPE_BLOCK) { ret cx; }\n     alt (cx.parent) {\n@@ -1578,6 +1584,18 @@ fn trans_raw_malloc(&@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize) ->\n     ret rslt(cx, cx.build.PointerCast(rval, llptr_ty));\n }\n \n+// trans_shared_malloc: expects a type indicating which pointer type we want\n+// and a size indicating how much space we want malloc'd.\n+fn trans_shared_malloc(&@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize) ->\n+   result {\n+    // FIXME: need a table to collect tydesc globals.\n+\n+    auto tydesc = C_null(T_ptr(T_tydesc(cx.fcx.lcx.ccx.tn)));\n+    auto rval =\n+        cx.build.Call(cx.fcx.lcx.ccx.upcalls.shared_malloc,\n+                      [cx.fcx.lltaskptr, llsize, tydesc]);\n+    ret rslt(cx, cx.build.PointerCast(rval, llptr_ty));\n+}\n \n // trans_malloc_boxed: expects an unboxed type and returns a pointer to enough\n // space for something of that type, along with space for a reference count;\n@@ -2097,7 +2115,7 @@ fn maybe_free_ivec_heap_part(&@block_ctxt cx, ValueRef v0, ty::t unit_ty) ->\n             auto m = maybe_on_heap_cx.build.InBoundsGEP(stub_ptr, v);\n             maybe_on_heap_cx.build.Load(m)\n         };\n-    auto after_free_cx = trans_non_gc_free(maybe_on_heap_cx, heap_ptr).bcx;\n+    auto after_free_cx = trans_shared_free(maybe_on_heap_cx, heap_ptr).bcx;\n     after_free_cx.build.Br(next_cx.llbb);\n     ret rslt(next_cx, C_nil());\n }\n@@ -3617,7 +3635,8 @@ mod ivec {\n         {\n             auto p =\n                 heap_resize_cx.build.PointerCast(v, T_ptr(T_opaque_ivec()));\n-            heap_resize_cx.build.Call(cx.fcx.lcx.ccx.upcalls.ivec_resize,\n+            auto upcall = cx.fcx.lcx.ccx.upcalls.ivec_resize_shared;\n+            heap_resize_cx.build.Call(upcall,\n                                       [cx.fcx.lltaskptr, p, new_heap_len]);\n         }\n         auto heap_ptr_resize =\n@@ -3657,7 +3676,8 @@ mod ivec {\n         {\n             auto p =\n                 stack_spill_cx.build.PointerCast(v, T_ptr(T_opaque_ivec()));\n-            stack_spill_cx.build.Call(cx.fcx.lcx.ccx.upcalls.ivec_spill,\n+            auto upcall = cx.fcx.lcx.ccx.upcalls.ivec_spill_shared;\n+            stack_spill_cx.build.Call(upcall,\n                                       [cx.fcx.lltaskptr, p, new_stack_len]);\n         }\n         auto spill_stub =\n@@ -3908,7 +3928,7 @@ mod ivec {\n                             heap_cx.build.InBoundsGEP(stub_ptr_heap,\n                                                       stub_a));\n         auto heap_sz = heap_cx.build.Add(llsize_of(llheappartty), lllen);\n-        auto rs = trans_raw_malloc(heap_cx, T_ptr(llheappartty), heap_sz);\n+        auto rs = trans_shared_malloc(heap_cx, T_ptr(llheappartty), heap_sz);\n         auto heap_part = rs.val;\n         heap_cx = rs.bcx;\n         heap_cx.build.Store(heap_part,\n@@ -4045,7 +4065,7 @@ mod ivec {\n \n         auto heap_part_sz = on_heap_cx.build.Add(alen,\n             llsize_of(T_opaque_ivec_heap_part()));\n-        auto rs = trans_raw_malloc(on_heap_cx, T_ptr(llheappartty),\n+        auto rs = trans_shared_malloc(on_heap_cx, T_ptr(llheappartty),\n                                    heap_part_sz);\n         on_heap_cx = rs.bcx;\n         auto new_heap_ptr = rs.val;\n@@ -6003,7 +6023,7 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, ast::node_id id) ->\n             bcx.build.Store(lllen, bcx.build.InBoundsGEP(llstubptr, stub_a));\n \n             auto llheapsz = bcx.build.Add(llsize_of(llheapty), lllen);\n-            auto rslt = trans_raw_malloc(bcx, T_ptr(llheapty), llheapsz);\n+            auto rslt = trans_shared_malloc(bcx, T_ptr(llheapty), llheapsz);\n             bcx = rslt.bcx;\n             auto llheapptr = rslt.val;\n             bcx.build.Store(llheapptr,"}, {"sha": "d34b54d68e4c40f649cded880fbf13620655c342", "filename": "src/lib/ivec.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb/src%2Flib%2Fivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb/src%2Flib%2Fivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fivec.rs?ref=f6117173c9f26efdcf50cb664d006ea2bdf0d0cb", "patch": "@@ -11,15 +11,16 @@ native \"rust-intrinsic\" mod rusti {\n }\n \n native \"rust\" mod rustrt {\n-    fn ivec_reserve[T](&mutable T[mutable?] v, uint n);\n+    fn ivec_reserve_shared[T](&mutable T[mutable?] v, uint n);\n     fn ivec_on_heap[T](&T[] v) -> uint;\n     fn ivec_to_ptr[T](&T[] v) -> *T;\n-    fn ivec_copy_from_buf[T](&mutable T[mutable?] v, *T ptr, uint count);\n+    fn ivec_copy_from_buf_shared[T](&mutable T[mutable?] v,\n+                                    *T ptr, uint count);\n }\n \n /// Reserves space for `n` elements in the given vector.\n fn reserve[T](&mutable T[mutable?] v, uint n) {\n-    rustrt::ivec_reserve(v, n);\n+    rustrt::ivec_reserve_shared(v, n);\n }\n \n fn on_heap[T](&T[] v) -> bool {\n@@ -204,7 +205,7 @@ fn all[T](fn(&T)->bool f, &T[] v) -> bool {\n \n mod unsafe {\n     fn copy_from_buf[T](&mutable T[] v, *T ptr, uint count) {\n-        ret rustrt::ivec_copy_from_buf(v, ptr, count);\n+        ret rustrt::ivec_copy_from_buf_shared(v, ptr, count);\n     }\n }\n "}, {"sha": "872a317ca38e11c00b5d2fdadc960113f8b014b1", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=f6117173c9f26efdcf50cb664d006ea2bdf0d0cb", "patch": "@@ -648,6 +648,37 @@ ivec_reserve(rust_task *task, type_desc *ty, rust_ivec *v, size_t n_elems)\n     v->alloc = new_alloc;\n }\n \n+/**\n+ * Preallocates the exact number of bytes in the given interior vector.\n+ */\n+extern \"C\" CDECL void\n+ivec_reserve_shared(rust_task *task, type_desc *ty, rust_ivec *v,\n+                    size_t n_elems)\n+{\n+    size_t new_alloc = n_elems * ty->size;\n+    if (new_alloc <= v->alloc)\n+        return;     // Already big enough.\n+\n+    rust_ivec_heap *heap_part;\n+    if (v->fill || !v->payload.ptr) {\n+        // On stack; spill to heap.\n+        heap_part = (rust_ivec_heap *)task->kernel->malloc(new_alloc +\n+                                                           sizeof(size_t));\n+        heap_part->fill = v->fill;\n+        memcpy(&heap_part->data, v->payload.data, v->fill);\n+\n+        v->fill = 0;\n+        v->payload.ptr = heap_part;\n+    } else {\n+        // On heap; resize.\n+        heap_part = (rust_ivec_heap *)task->kernel->realloc(v->payload.ptr,\n+                                                new_alloc + sizeof(size_t));\n+        v->payload.ptr = heap_part;\n+    }\n+\n+    v->alloc = new_alloc;\n+}\n+\n /**\n  * Returns true if the given vector is on the heap and false if it's on the\n  * stack.\n@@ -706,6 +737,35 @@ ivec_copy_from_buf(rust_task *task, type_desc *ty, rust_ivec *v, void *ptr,\n     v->payload.ptr->fill = new_size;\n }\n \n+/**\n+ * Copies elements in an unsafe buffer to the given interior vector. The\n+ * vector must have size zero.\n+ */\n+extern \"C\" CDECL void\n+ivec_copy_from_buf_shared(rust_task *task, type_desc *ty, rust_ivec *v,\n+                   void *ptr, size_t count)\n+{\n+    size_t old_size = get_ivec_size(v);\n+    if (old_size) {\n+        task->fail(1);\n+        return;\n+    }\n+\n+    ivec_reserve_shared(task, ty, v, count);\n+\n+    size_t new_size = count * ty->size;\n+    if (v->fill || !v->payload.ptr) {\n+        // On stack.\n+        memmove(v->payload.data, ptr, new_size);\n+        v->fill = new_size;\n+        return;\n+    }\n+\n+    // On heap.\n+    memmove(v->payload.ptr->data, ptr, new_size);\n+    v->payload.ptr->fill = new_size;\n+}\n+\n extern \"C\" CDECL void\n pin_task(rust_task *task) {\n     task->pin();"}, {"sha": "a89c01ebdfba5dc6787c9385833edd7b305ed52b", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=f6117173c9f26efdcf50cb664d006ea2bdf0d0cb", "patch": "@@ -289,6 +289,36 @@ upcall_free(rust_task *task, void* ptr, uintptr_t is_gc) {\n     task->free(ptr, (bool) is_gc);\n }\n \n+extern \"C\" CDECL uintptr_t\n+upcall_shared_malloc(rust_task *task, size_t nbytes, type_desc *td) {\n+    LOG_UPCALL_ENTRY(task);\n+    scoped_lock with(task->kernel->scheduler_lock);\n+\n+    LOG(task, mem,\n+                   \"upcall shared_malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \")\",\n+                   nbytes, td);\n+    void *p = task->kernel->malloc(nbytes);\n+    LOG(task, mem,\n+                   \"upcall shared_malloc(%\" PRIdPTR \", 0x%\" PRIxPTR\n+                   \") = 0x%\" PRIxPTR,\n+                   nbytes, td, (uintptr_t)p);\n+    return (uintptr_t) p;\n+}\n+\n+/**\n+ * Called whenever an object's ref count drops to zero.\n+ */\n+extern \"C\" CDECL void\n+upcall_shared_free(rust_task *task, void* ptr) {\n+    LOG_UPCALL_ENTRY(task);\n+    scoped_lock with(task->kernel->scheduler_lock);\n+    rust_scheduler *sched = task->sched;\n+    DLOG(sched, mem,\n+             \"upcall shared_free(0x%\" PRIxPTR\")\",\n+             (uintptr_t)ptr);\n+    task->kernel->free(ptr);\n+}\n+\n extern \"C\" CDECL uintptr_t\n upcall_mark(rust_task *task, void* ptr) {\n     LOG_UPCALL_ENTRY(task);\n@@ -537,6 +567,7 @@ extern \"C\" CDECL void\n upcall_ivec_resize(rust_task *task,\n                    rust_ivec *v,\n                    size_t newsz) {\n+    LOG_UPCALL_ENTRY(task);\n     scoped_lock with(task->kernel->scheduler_lock);\n     I(task->sched, !v->fill);\n \n@@ -556,6 +587,7 @@ extern \"C\" CDECL void\n upcall_ivec_spill(rust_task *task,\n                   rust_ivec *v,\n                   size_t newsz) {\n+    LOG_UPCALL_ENTRY(task);\n     scoped_lock with(task->kernel->scheduler_lock);\n     size_t new_alloc = next_power_of_two(newsz);\n \n@@ -569,6 +601,46 @@ upcall_ivec_spill(rust_task *task,\n     v->payload.ptr = heap_part;\n }\n \n+/**\n+ * Resizes an interior vector that has been spilled to the heap.\n+ */\n+extern \"C\" CDECL void\n+upcall_ivec_resize_shared(rust_task *task,\n+                          rust_ivec *v,\n+                          size_t newsz) {\n+    LOG_UPCALL_ENTRY(task);\n+    scoped_lock with(task->kernel->scheduler_lock);\n+    I(task->sched, !v->fill);\n+\n+    size_t new_alloc = next_power_of_two(newsz);\n+    rust_ivec_heap *new_heap_part = (rust_ivec_heap *)\n+        task->kernel->realloc(v->payload.ptr, new_alloc + sizeof(size_t));\n+\n+    new_heap_part->fill = newsz;\n+    v->alloc = new_alloc;\n+    v->payload.ptr = new_heap_part;\n+}\n+\n+/**\n+ * Spills an interior vector to the heap.\n+ */\n+extern \"C\" CDECL void\n+upcall_ivec_spill_shared(rust_task *task,\n+                         rust_ivec *v,\n+                         size_t newsz) {\n+    LOG_UPCALL_ENTRY(task);\n+    scoped_lock with(task->kernel->scheduler_lock);\n+    size_t new_alloc = next_power_of_two(newsz);\n+\n+    rust_ivec_heap *heap_part = (rust_ivec_heap *)\n+        task->kernel->malloc(new_alloc + sizeof(size_t));\n+    heap_part->fill = newsz;\n+    memcpy(&heap_part->data, v->payload.data, v->fill);\n+\n+    v->fill = 0;\n+    v->alloc = new_alloc;\n+    v->payload.ptr = heap_part;\n+}\n //\n // Local Variables:\n // mode: C++"}, {"sha": "481936eee69daf9842202f8236954fc46335377c", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/f6117173c9f26efdcf50cb664d006ea2bdf0d0cb/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=f6117173c9f26efdcf50cb664d006ea2bdf0d0cb", "patch": "@@ -11,8 +11,10 @@ debug_tydesc\n do_gc\n get_time\n ivec_copy_from_buf\n+ivec_copy_from_buf_shared\n ivec_on_heap\n ivec_reserve\n+ivec_reserve_shared\n ivec_to_ptr\n last_os_error\n nano_time\n@@ -59,7 +61,9 @@ upcall_free\n upcall_get_type_desc\n upcall_grow_task\n upcall_ivec_resize\n+upcall_ivec_resize_shared\n upcall_ivec_spill\n+upcall_ivec_spill_shared\n upcall_kill\n upcall_log_double\n upcall_log_float\n@@ -74,6 +78,8 @@ upcall_new_task\n upcall_new_vec\n upcall_recv\n upcall_send\n+upcall_shared_malloc\n+upcall_shared_free\n upcall_sleep\n upcall_start_task\n upcall_trace_str"}]}