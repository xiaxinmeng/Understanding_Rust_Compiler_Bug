{"sha": "e3fdae9d81052cf521298d19f8bb32ba0332b589", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZmRhZTlkODEwNTJjZjUyMTI5OGQxOWY4YmIzMmJhMDMzMmI1ODk=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2020-09-23T16:33:54Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2020-12-16T10:33:47Z"}, "message": "cg_llvm: implement split dwarf support\n\nThis commit implements Split DWARF support, wiring up the flag (added in\nearlier commits) to the modified FFI wrapper (also from earlier\ncommits).\n\nSigned-off-by: David Wood <david@davidtw.co>", "tree": {"sha": "6db6a7c40140ce62404e34abc104ea2da417768e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6db6a7c40140ce62404e34abc104ea2da417768e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3fdae9d81052cf521298d19f8bb32ba0332b589", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEfgm2/wUjk9OnjxlyJZLnbIc4H9kFAl/Z4osACgkQJZLnbIc4\nH9n5HBAAjsVC4N+jgsGa/sXrfh67M5KZfw1Obu0Wgt6OjADVN/W+dnUAijF0M9Wl\nO0qkL05lNoz+Yg42j6Xp5ioT2mMN48BWgB7hBbqOXhP8fc0P94j1I2LdIedvfMr8\nAXX9uqLOj+Q8tQo8h9v3TZM7xXMOF+nxAT6gyaKjj4j4WvbbRBAG/d0FefzExM0b\nn0oCY1UsRKXv0ar6y91xSUSZRU2x6zBI0bW203JSel4llUWzuvcP4Ta/FwM9NcIH\nS52sTgt1QJNonx/kLDkPFZOzhkMOxYs543bBHCPcD5dixMSiW8M6ejtNbwsrV7SR\nOBLj9A2ejjRFNwzjidXVK7ur5hRBh8FozMYLeMCTP5ilMcF7M/rboYikwoWNH/+X\nVFCyxclrMJ1XjZRIitQYW7wFtc377XIy1joXMlFvl0RnX35MDNyKg4DGK7SCDtkm\nZRDCW1gmdTaAHG/sZ020Bsrz38UEosk21I6VARngjS2j8iJILF3KIoxSCuHg5bJz\nS96llhD3MvZmWjXeMzT5tAIt0/SxrUOEAIY6h/2bOWQejgSUHwZq89G75czFeXmi\nIEszYRHdRCTnPmcUhWEG5sVWHTtO4gLbZ12T6i+7bSnxj0Ol7xgFhbxr1XDzJ+a9\nNMI9jIvIzih9GEyTnllProEaex7muboUjGYPZyGZ0wjSkrpphew=\n=codU\n-----END PGP SIGNATURE-----", "payload": "tree 6db6a7c40140ce62404e34abc104ea2da417768e\nparent 241160de72b5b55187ca54243e2a6e82e336d07c\nauthor David Wood <david@davidtw.co> 1600878834 +0100\ncommitter David Wood <david@davidtw.co> 1608114827 +0000\n\ncg_llvm: implement split dwarf support\n\nThis commit implements Split DWARF support, wiring up the flag (added in\nearlier commits) to the modified FFI wrapper (also from earlier\ncommits).\n\nSigned-off-by: David Wood <david@davidtw.co>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3fdae9d81052cf521298d19f8bb32ba0332b589", "html_url": "https://github.com/rust-lang/rust/commit/e3fdae9d81052cf521298d19f8bb32ba0332b589", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3fdae9d81052cf521298d19f8bb32ba0332b589/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "241160de72b5b55187ca54243e2a6e82e336d07c", "url": "https://api.github.com/repos/rust-lang/rust/commits/241160de72b5b55187ca54243e2a6e82e336d07c", "html_url": "https://github.com/rust-lang/rust/commit/241160de72b5b55187ca54243e2a6e82e336d07c"}], "stats": {"total": 274, "additions": 228, "deletions": 46}, "files": [{"sha": "834fc02c48ab8cf7a4de009e2cb06f1637876d4a", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e3fdae9d81052cf521298d19f8bb32ba0332b589/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fdae9d81052cf521298d19f8bb32ba0332b589/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=e3fdae9d81052cf521298d19f8bb32ba0332b589", "patch": "@@ -6,7 +6,9 @@ use crate::llvm::{self, build_string, False, True};\n use crate::{LlvmCodegenBackend, ModuleLlvm};\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule, ThinShared};\n use rustc_codegen_ssa::back::symbol_export;\n-use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, ModuleConfig};\n+use rustc_codegen_ssa::back::write::{\n+    CodegenContext, FatLTOInput, ModuleConfig, TargetMachineFactoryConfig,\n+};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{looks_like_rust_object_file, ModuleCodegen, ModuleKind};\n use rustc_data_structures::fx::FxHashMap;\n@@ -728,20 +730,23 @@ pub unsafe fn optimize_thin_module(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n ) -> Result<ModuleCodegen<ModuleLlvm>, FatalError> {\n     let diag_handler = cgcx.create_diag_handler();\n-    let tm = (cgcx.tm_factory)().map_err(|e| write::llvm_err(&diag_handler, &e))?;\n+\n+    let module_name = &thin_module.shared.module_names[thin_module.idx];\n+    let split_dwarf_file = cgcx\n+        .output_filenames\n+        .split_dwarf_file(cgcx.split_dwarf_kind, Some(module_name.to_str().unwrap()));\n+    let tm_factory_config = TargetMachineFactoryConfig { split_dwarf_file };\n+    let tm =\n+        (cgcx.tm_factory)(tm_factory_config).map_err(|e| write::llvm_err(&diag_handler, &e))?;\n \n     // Right now the implementation we've got only works over serialized\n     // modules, so we create a fresh new LLVM context and parse the module\n     // into that context. One day, however, we may do this for upstream\n     // crates but for locally codegened modules we may be able to reuse\n     // that LLVM Context and Module.\n     let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n-    let llmod_raw = parse_module(\n-        llcx,\n-        &thin_module.shared.module_names[thin_module.idx],\n-        thin_module.data(),\n-        &diag_handler,\n-    )? as *const _;\n+    let llmod_raw =\n+        parse_module(llcx, &module_name, thin_module.data(), &diag_handler)? as *const _;\n     let module = ModuleCodegen {\n         module_llvm: ModuleLlvm { llmod_raw, llcx, tm },\n         name: thin_module.name().to_string(),"}, {"sha": "ef99c87053c7653e0bf80746d48c958297028604", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 59, "deletions": 17, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e3fdae9d81052cf521298d19f8bb32ba0332b589/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fdae9d81052cf521298d19f8bb32ba0332b589/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=e3fdae9d81052cf521298d19f8bb32ba0332b589", "patch": "@@ -12,7 +12,8 @@ use crate::type_::Type;\n use crate::LlvmCodegenBackend;\n use crate::ModuleLlvm;\n use rustc_codegen_ssa::back::write::{\n-    BitcodeSection, CodegenContext, EmitObj, ModuleConfig, TargetMachineFactoryFn,\n+    BitcodeSection, CodegenContext, EmitObj, ModuleConfig, TargetMachineFactoryConfig,\n+    TargetMachineFactoryFn,\n };\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{CompiledModule, ModuleCodegen};\n@@ -22,7 +23,9 @@ use rustc_fs_util::{link_or_copy, path_to_c_string};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{self, Lto, OutputType, Passes, SanitizerSet, SwitchWithOptPath};\n+use rustc_session::config::{\n+    self, Lto, OutputType, Passes, SanitizerSet, SplitDwarfKind, SwitchWithOptPath,\n+};\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::InnerSpan;\n@@ -51,18 +54,31 @@ pub fn write_output_file(\n     pm: &llvm::PassManager<'ll>,\n     m: &'ll llvm::Module,\n     output: &Path,\n+    dwo_output: Option<&Path>,\n     file_type: llvm::FileType,\n ) -> Result<(), FatalError> {\n     unsafe {\n         let output_c = path_to_c_string(output);\n-        let result = llvm::LLVMRustWriteOutputFile(\n-            target,\n-            pm,\n-            m,\n-            output_c.as_ptr(),\n-            std::ptr::null(),\n-            file_type,\n-        );\n+        let result = if let Some(dwo_output) = dwo_output {\n+            let dwo_output_c = path_to_c_string(dwo_output);\n+            llvm::LLVMRustWriteOutputFile(\n+                target,\n+                pm,\n+                m,\n+                output_c.as_ptr(),\n+                dwo_output_c.as_ptr(),\n+                file_type,\n+            )\n+        } else {\n+            llvm::LLVMRustWriteOutputFile(\n+                target,\n+                pm,\n+                m,\n+                output_c.as_ptr(),\n+                std::ptr::null(),\n+                file_type,\n+            )\n+        };\n         result.into_result().map_err(|()| {\n             let msg = format!(\"could not write output to {}\", output.display());\n             llvm_err(handler, &msg)\n@@ -71,12 +87,17 @@ pub fn write_output_file(\n }\n \n pub fn create_informational_target_machine(sess: &Session) -> &'static mut llvm::TargetMachine {\n-    target_machine_factory(sess, config::OptLevel::No)()\n+    let config = TargetMachineFactoryConfig { split_dwarf_file: None };\n+    target_machine_factory(sess, config::OptLevel::No)(config)\n         .unwrap_or_else(|err| llvm_err(sess.diagnostic(), &err).raise())\n }\n \n-pub fn create_target_machine(tcx: TyCtxt<'_>) -> &'static mut llvm::TargetMachine {\n-    target_machine_factory(&tcx.sess, tcx.backend_optimization_level(LOCAL_CRATE))()\n+pub fn create_target_machine(tcx: TyCtxt<'_>, mod_name: &str) -> &'static mut llvm::TargetMachine {\n+    let split_dwarf_file = tcx\n+        .output_filenames(LOCAL_CRATE)\n+        .split_dwarf_file(tcx.sess.opts.debugging_opts.split_dwarf, Some(mod_name));\n+    let config = TargetMachineFactoryConfig { split_dwarf_file };\n+    target_machine_factory(&tcx.sess, tcx.backend_optimization_level(LOCAL_CRATE))(config)\n         .unwrap_or_else(|err| llvm_err(tcx.sess.diagnostic(), &err).raise())\n }\n \n@@ -172,8 +193,10 @@ pub fn target_machine_factory(\n     let use_init_array =\n         !sess.opts.debugging_opts.use_ctors_section.unwrap_or(sess.target.use_ctors_section);\n \n-    Arc::new(move || {\n-        let split_dwarf_file = std::ptr::null();\n+    Arc::new(move |config: TargetMachineFactoryConfig| {\n+        let split_dwarf_file = config.split_dwarf_file.unwrap_or_default();\n+        let split_dwarf_file = CString::new(split_dwarf_file.to_str().unwrap()).unwrap();\n+\n         let tm = unsafe {\n             llvm::LLVMRustCreateTargetMachine(\n                 triple.as_ptr(),\n@@ -192,7 +215,7 @@ pub fn target_machine_factory(\n                 emit_stack_size_section,\n                 relax_elf_relocations,\n                 use_init_array,\n-                split_dwarf_file,\n+                split_dwarf_file.as_ptr(),\n             )\n         };\n \n@@ -796,7 +819,15 @@ pub(crate) unsafe fn codegen(\n                 llmod\n             };\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(diag_handler, tm, cpm, llmod, &path, llvm::FileType::AssemblyFile)\n+                write_output_file(\n+                    diag_handler,\n+                    tm,\n+                    cpm,\n+                    llmod,\n+                    &path,\n+                    None,\n+                    llvm::FileType::AssemblyFile,\n+                )\n             })?;\n         }\n \n@@ -805,13 +836,23 @@ pub(crate) unsafe fn codegen(\n                 let _timer = cgcx\n                     .prof\n                     .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &module.name[..]);\n+\n+                let dwo_out = cgcx.output_filenames.temp_path_dwo(module_name);\n+                let dwo_out = match cgcx.split_dwarf_kind {\n+                    // Don't change how DWARF is emitted in single mode (or when disabled).\n+                    SplitDwarfKind::None | SplitDwarfKind::Single => None,\n+                    // Emit (a subset of the) DWARF into a separate file in split mode.\n+                    SplitDwarfKind::Split => Some(dwo_out.as_path()),\n+                };\n+\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     write_output_file(\n                         diag_handler,\n                         tm,\n                         cpm,\n                         llmod,\n                         &obj_out,\n+                        dwo_out,\n                         llvm::FileType::ObjectFile,\n                     )\n                 })?;\n@@ -839,6 +880,7 @@ pub(crate) unsafe fn codegen(\n \n     Ok(module.into_compiled_module(\n         config.emit_obj != EmitObj::None,\n+        cgcx.split_dwarf_kind == SplitDwarfKind::Split,\n         config.emit_bc,\n         &cgcx.output_filenames,\n     ))"}, {"sha": "a9eff59b6affa713784d776374b082e65276d14d", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3fdae9d81052cf521298d19f8bb32ba0332b589/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fdae9d81052cf521298d19f8bb32ba0332b589/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=e3fdae9d81052cf521298d19f8bb32ba0332b589", "patch": "@@ -995,7 +995,11 @@ pub fn compile_unit_metadata(\n     let name_in_debuginfo = name_in_debuginfo.to_string_lossy();\n     let work_dir = tcx.sess.working_dir.0.to_string_lossy();\n     let flags = \"\\0\";\n-    let split_name = \"\";\n+    let split_name = tcx\n+        .output_filenames(LOCAL_CRATE)\n+        .split_dwarf_file(tcx.sess.opts.debugging_opts.split_dwarf, Some(codegen_unit_name))\n+        .unwrap_or_default();\n+    let split_name = split_name.to_str().unwrap();\n \n     // FIXME(#60020):\n     //\n@@ -1040,7 +1044,7 @@ pub fn compile_unit_metadata(\n             split_name.len(),\n             kind,\n             0,\n-            true,\n+            tcx.sess.opts.debugging_opts.split_dwarf_inlining,\n         );\n \n         if tcx.sess.opts.debugging_opts.profile {"}, {"sha": "a5f125d114d28d2a32943b7cc269b5b459d1c0d4", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e3fdae9d81052cf521298d19f8bb32ba0332b589/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fdae9d81052cf521298d19f8bb32ba0332b589/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=e3fdae9d81052cf521298d19f8bb32ba0332b589", "patch": "@@ -20,7 +20,7 @@ pub use llvm_util::target_features;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule};\n use rustc_codegen_ssa::back::write::{\n-    CodegenContext, FatLTOInput, ModuleConfig, TargetMachineFactoryFn,\n+    CodegenContext, FatLTOInput, ModuleConfig, TargetMachineFactoryConfig, TargetMachineFactoryFn,\n };\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::ModuleCodegen;\n@@ -332,7 +332,7 @@ impl ModuleLlvm {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(tcx.sess.fewer_names());\n             let llmod_raw = context::create_module(tcx, llcx, mod_name) as *const _;\n-            ModuleLlvm { llmod_raw, llcx, tm: create_target_machine(tcx) }\n+            ModuleLlvm { llmod_raw, llcx, tm: create_target_machine(tcx, mod_name) }\n         }\n     }\n \n@@ -353,7 +353,13 @@ impl ModuleLlvm {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n             let llmod_raw = back::lto::parse_module(llcx, name, buffer, handler)?;\n-            let tm = match (cgcx.tm_factory)() {\n+\n+            let split_dwarf_file = cgcx\n+                .output_filenames\n+                .split_dwarf_file(cgcx.split_dwarf_kind, Some(name.to_str().unwrap()));\n+            let tm_factory_config = TargetMachineFactoryConfig { split_dwarf_file };\n+\n+            let tm = match (cgcx.tm_factory)(tm_factory_config) {\n                 Ok(m) => m,\n                 Err(e) => {\n                     handler.struct_err(&e).emit();"}, {"sha": "123d1ae55fb97007ccc1b8c7515175143cf06d36", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 88, "deletions": 12, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e3fdae9d81052cf521298d19f8bb32ba0332b589/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fdae9d81052cf521298d19f8bb32ba0332b589/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=e3fdae9d81052cf521298d19f8bb32ba0332b589", "patch": "@@ -21,7 +21,9 @@ use super::archive::ArchiveBuilder;\n use super::command::Command;\n use super::linker::{self, Linker};\n use super::rpath::{self, RPathConfig};\n-use crate::{looks_like_rust_object_file, CodegenResults, CrateInfo, METADATA_FILENAME};\n+use crate::{\n+    looks_like_rust_object_file, CodegenResults, CompiledModule, CrateInfo, METADATA_FILENAME,\n+};\n \n use cc::windows_registry;\n use tempfile::Builder as TempFileBuilder;\n@@ -96,6 +98,9 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n                         path.as_ref(),\n                         target_cpu,\n                     );\n+                    if sess.opts.debugging_opts.split_dwarf == config::SplitDwarfKind::Split {\n+                        link_dwarf_object(sess, &out_filename);\n+                    }\n                 }\n             }\n             if sess.opts.json_artifact_notifications {\n@@ -107,22 +112,30 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n     // Remove the temporary object file and metadata if we aren't saving temps\n     sess.time(\"link_binary_remove_temps\", || {\n         if !sess.opts.cg.save_temps {\n+            let remove_temps_from_module = |module: &CompiledModule| {\n+                if let Some(ref obj) = module.object {\n+                    remove(sess, obj);\n+                }\n+\n+                if let Some(ref obj) = module.dwarf_object {\n+                    remove(sess, obj);\n+                }\n+            };\n+\n             if sess.opts.output_types.should_codegen()\n                 && !preserve_objects_for_their_debuginfo(sess)\n             {\n-                for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-                    remove(sess, obj);\n+                for module in &codegen_results.modules {\n+                    remove_temps_from_module(module);\n                 }\n             }\n+\n             if let Some(ref metadata_module) = codegen_results.metadata_module {\n-                if let Some(ref obj) = metadata_module.object {\n-                    remove(sess, obj);\n-                }\n+                remove_temps_from_module(metadata_module);\n             }\n+\n             if let Some(ref allocator_module) = codegen_results.allocator_module {\n-                if let Some(ref obj) = allocator_module.object {\n-                    remove(sess, obj);\n-                }\n+                remove_temps_from_module(allocator_module);\n             }\n         }\n     });\n@@ -446,6 +459,69 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n     }\n }\n \n+fn escape_stdout_stderr_string(s: &[u8]) -> String {\n+    str::from_utf8(s).map(|s| s.to_owned()).unwrap_or_else(|_| {\n+        let mut x = \"Non-UTF-8 output: \".to_string();\n+        x.extend(s.iter().flat_map(|&b| ascii::escape_default(b)).map(char::from));\n+        x\n+    })\n+}\n+\n+const LLVM_DWP_EXECUTABLE: &'static str = \"rust-llvm-dwp\";\n+\n+/// Invoke `llvm-dwp` (shipped alongside rustc) to link `dwo` files from Split DWARF into a `dwp`\n+/// file.\n+fn link_dwarf_object<'a>(sess: &'a Session, executable_out_filename: &Path) {\n+    info!(\"preparing dwp to {}.dwp\", executable_out_filename.to_str().unwrap());\n+\n+    let dwp_out_filename = executable_out_filename.with_extension(\"dwp\");\n+    let mut cmd = Command::new(LLVM_DWP_EXECUTABLE);\n+    cmd.arg(\"-e\");\n+    cmd.arg(executable_out_filename);\n+    cmd.arg(\"-o\");\n+    cmd.arg(&dwp_out_filename);\n+\n+    let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths(false);\n+    if let Some(path) = env::var_os(\"PATH\") {\n+        new_path.extend(env::split_paths(&path));\n+    }\n+    let new_path = env::join_paths(new_path).unwrap();\n+    cmd.env(\"PATH\", new_path);\n+\n+    info!(\"{:?}\", &cmd);\n+    match sess.time(\"run_dwp\", || cmd.output()) {\n+        Ok(prog) if !prog.status.success() => {\n+            sess.struct_err(&format!(\n+                \"linking dwarf objects with `{}` failed: {}\",\n+                LLVM_DWP_EXECUTABLE, prog.status\n+            ))\n+            .note(&format!(\"{:?}\", &cmd))\n+            .note(&escape_stdout_stderr_string(&prog.stdout))\n+            .note(&escape_stdout_stderr_string(&prog.stderr))\n+            .emit();\n+            info!(\"linker stderr:\\n{}\", escape_stdout_stderr_string(&prog.stderr));\n+            info!(\"linker stdout:\\n{}\", escape_stdout_stderr_string(&prog.stdout));\n+        }\n+        Ok(_) => {}\n+        Err(e) => {\n+            let dwp_not_found = e.kind() == io::ErrorKind::NotFound;\n+            let mut err = if dwp_not_found {\n+                sess.struct_err(&format!(\"linker `{}` not found\", LLVM_DWP_EXECUTABLE))\n+            } else {\n+                sess.struct_err(&format!(\"could not exec the linker `{}`\", LLVM_DWP_EXECUTABLE))\n+            };\n+\n+            err.note(&e.to_string());\n+\n+            if !dwp_not_found {\n+                err.note(&format!(\"{:?}\", &cmd));\n+            }\n+\n+            err.emit();\n+        }\n+    }\n+}\n+\n /// Create a dynamic library or executable.\n ///\n /// This will invoke the system linker/cc to create the resulting file. This links to all upstream\n@@ -661,7 +737,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n                     prog.status\n                 ))\n                 .note(&format!(\"{:?}\", &cmd))\n-                .note(&escape_string(&output))\n+                .note(&escape_stdout_stderr_string(&output))\n                 .emit();\n \n                 // If MSVC's `link.exe` was expected but the return code\n@@ -714,8 +790,8 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n \n                 sess.abort_if_errors();\n             }\n-            info!(\"linker stderr:\\n{}\", escape_string(&prog.stderr));\n-            info!(\"linker stdout:\\n{}\", escape_string(&prog.stdout));\n+            info!(\"linker stderr:\\n{}\", escape_stdout_stderr_string(&prog.stderr));\n+            info!(\"linker stdout:\\n{}\", escape_stdout_stderr_string(&prog.stdout));\n         }\n         Err(e) => {\n             let linker_not_found = e.kind() == io::ErrorKind::NotFound;"}, {"sha": "c84b87964b845507b673af2c29247d24e7ddfc35", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e3fdae9d81052cf521298d19f8bb32ba0332b589/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fdae9d81052cf521298d19f8bb32ba0332b589/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=e3fdae9d81052cf521298d19f8bb32ba0332b589", "patch": "@@ -274,8 +274,19 @@ impl ModuleConfig {\n     }\n }\n \n-pub type TargetMachineFactoryFn<B> =\n-    Arc<dyn Fn() -> Result<<B as WriteBackendMethods>::TargetMachine, String> + Send + Sync>;\n+/// Configuration passed to the function returned by the `target_machine_factory`.\n+pub struct TargetMachineFactoryConfig {\n+    /// Split DWARF is enabled in LLVM by checking that `TM.MCOptions.SplitDwarfFile` isn't empty,\n+    /// so the path to the dwarf object has to be provided when we create the target machine.\n+    /// This can be ignored by backends which do not need it for their Split DWARF support.\n+    pub split_dwarf_file: Option<PathBuf>,\n+}\n+\n+pub type TargetMachineFactoryFn<B> = Arc<\n+    dyn Fn(TargetMachineFactoryConfig) -> Result<<B as WriteBackendMethods>::TargetMachine, String>\n+        + Send\n+        + Sync,\n+>;\n \n pub type ExportedSymbols = FxHashMap<CrateNum, Arc<Vec<(String, SymbolExportLevel)>>>;\n \n@@ -303,6 +314,7 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub target_pointer_width: u32,\n     pub target_arch: String,\n     pub debuginfo: config::DebugInfo,\n+    pub split_dwarf_kind: config::SplitDwarfKind,\n \n     // Number of cgus excluding the allocator/metadata modules\n     pub total_cgus: usize,\n@@ -619,6 +631,12 @@ fn produce_final_output_artifacts(\n                 }\n             }\n \n+            if let Some(ref path) = module.dwarf_object {\n+                if !keep_numbered_objects {\n+                    remove(sess, path);\n+                }\n+            }\n+\n             if let Some(ref path) = module.bytecode {\n                 if !keep_numbered_bitcode {\n                     remove(sess, path);\n@@ -841,6 +859,7 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n         name: module.name,\n         kind: ModuleKind::Regular,\n         object,\n+        dwarf_object: None,\n         bytecode: None,\n     }))\n }\n@@ -1019,6 +1038,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         target_pointer_width: tcx.sess.target.pointer_width,\n         target_arch: tcx.sess.target.arch.clone(),\n         debuginfo: tcx.sess.opts.debuginfo,\n+        split_dwarf_kind: tcx.sess.opts.debugging_opts.split_dwarf,\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen."}, {"sha": "ee889d552412e295d8df11790f1afb5ecac25b9e", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e3fdae9d81052cf521298d19f8bb32ba0332b589/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fdae9d81052cf521298d19f8bb32ba0332b589/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=e3fdae9d81052cf521298d19f8bb32ba0332b589", "patch": "@@ -64,13 +64,15 @@ impl<M> ModuleCodegen<M> {\n     pub fn into_compiled_module(\n         self,\n         emit_obj: bool,\n+        emit_dwarf_obj: bool,\n         emit_bc: bool,\n         outputs: &OutputFilenames,\n     ) -> CompiledModule {\n         let object = emit_obj.then(|| outputs.temp_path(OutputType::Object, Some(&self.name)));\n+        let dwarf_object = emit_dwarf_obj.then(|| outputs.temp_path_dwo(Some(&self.name)));\n         let bytecode = emit_bc.then(|| outputs.temp_path(OutputType::Bitcode, Some(&self.name)));\n \n-        CompiledModule { name: self.name.clone(), kind: self.kind, object, bytecode }\n+        CompiledModule { name: self.name.clone(), kind: self.kind, object, dwarf_object, bytecode }\n     }\n }\n \n@@ -79,6 +81,7 @@ pub struct CompiledModule {\n     pub name: String,\n     pub kind: ModuleKind,\n     pub object: Option<PathBuf>,\n+    pub dwarf_object: Option<PathBuf>,\n     pub bytecode: Option<PathBuf>,\n }\n "}, {"sha": "b3d4c6e3ec73b4f20d8472a2895ac020a51ea82f", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e3fdae9d81052cf521298d19f8bb32ba0332b589/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fdae9d81052cf521298d19f8bb32ba0332b589/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=e3fdae9d81052cf521298d19f8bb32ba0332b589", "patch": "@@ -550,6 +550,7 @@ impl_stable_hash_via_hash!(OutputFilenames);\n \n pub const RLINK_EXT: &str = \"rlink\";\n pub const RUST_CGU_EXT: &str = \"rcgu\";\n+pub const DWARF_OBJECT_EXT: &str = \"dwo\";\n \n impl OutputFilenames {\n     pub fn new(\n@@ -583,7 +584,12 @@ impl OutputFilenames {\n         self.temp_path_ext(extension, codegen_unit_name)\n     }\n \n-    /// Like temp_path, but also supports things where there is no corresponding\n+    /// Like `temp_path`, but specifically for dwarf objects.\n+    pub fn temp_path_dwo(&self, codegen_unit_name: Option<&str>) -> PathBuf {\n+        self.temp_path_ext(DWARF_OBJECT_EXT, codegen_unit_name)\n+    }\n+\n+    /// Like `temp_path`, but also supports things where there is no corresponding\n     /// OutputType, like noopt-bitcode or lto-bitcode.\n     pub fn temp_path_ext(&self, ext: &str, codegen_unit_name: Option<&str>) -> PathBuf {\n         let mut extension = String::new();\n@@ -610,6 +616,26 @@ impl OutputFilenames {\n         path.set_extension(extension);\n         path\n     }\n+\n+    /// Returns the path for the Split DWARF file - this can differ depending on which Split DWARF\n+    /// mode is being used, which is the logic that this function is intended to encapsulate.\n+    pub fn split_dwarf_file(\n+        &self,\n+        split_dwarf_kind: SplitDwarfKind,\n+        cgu_name: Option<&str>,\n+    ) -> Option<PathBuf> {\n+        let obj_out = self.temp_path(OutputType::Object, cgu_name);\n+        let dwo_out = self.temp_path_dwo(cgu_name);\n+        match split_dwarf_kind {\n+            SplitDwarfKind::None => None,\n+            // Single mode doesn't change how DWARF is emitted, but does add Split DWARF attributes\n+            // (pointing at the path which is being determined here). Use the path to the current\n+            // object file.\n+            SplitDwarfKind::Single => Some(obj_out),\n+            // Split mode emits the DWARF into a different file, use that path.\n+            SplitDwarfKind::Split => Some(dwo_out),\n+        }\n+    }\n }\n \n pub fn host_triple() -> &'static str {"}]}