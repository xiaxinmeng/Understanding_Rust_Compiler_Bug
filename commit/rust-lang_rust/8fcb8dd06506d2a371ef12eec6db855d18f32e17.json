{"sha": "8fcb8dd06506d2a371ef12eec6db855d18f32e17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmY2I4ZGQwNjUwNmQyYTM3MWVmMTJlZWM2ZGI4NTVkMThmMzJlMTc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-03-17T01:43:47Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-03-19T01:22:33Z"}, "message": "std: Improve option docs", "tree": {"sha": "977d40f5a0889e0ef7341bbc99d13d3820817fba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/977d40f5a0889e0ef7341bbc99d13d3820817fba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fcb8dd06506d2a371ef12eec6db855d18f32e17", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fcb8dd06506d2a371ef12eec6db855d18f32e17", "html_url": "https://github.com/rust-lang/rust/commit/8fcb8dd06506d2a371ef12eec6db855d18f32e17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fcb8dd06506d2a371ef12eec6db855d18f32e17/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "891eab94a31739d6b0c330ebb7d4415529cfe1ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/891eab94a31739d6b0c330ebb7d4415529cfe1ee", "html_url": "https://github.com/rust-lang/rust/commit/891eab94a31739d6b0c330ebb7d4415529cfe1ee"}], "stats": {"total": 190, "additions": 170, "deletions": 20}, "files": [{"sha": "b498572f26e52fa744277ac74bbae59c5eaea473", "filename": "src/libstd/option.rs", "status": "modified", "additions": 170, "deletions": 20, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/8fcb8dd06506d2a371ef12eec6db855d18f32e17/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fcb8dd06506d2a371ef12eec6db855d18f32e17/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=8fcb8dd06506d2a371ef12eec6db855d18f32e17", "patch": "@@ -8,21 +8,86 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Optionally nullable values (`Option` type)\n+//! Optional values\n //!\n-//! Type `Option` represents an optional value.\n+//! Type `Option` represents an optional value: every `Option`\n+//! is either `Some` and contains a value, or `None`, and\n+//! does not. `Option` types are very common in Rust code, as\n+//! they have a number of uses:\n //!\n-//! Every `Option<T>` value can either be `Some(T)` or `None`. Where in other\n-//! languages you might use a nullable type, in Rust you would use an option\n-//! type.\n+//! * Initial values\n+//! * Return values for functions that are not defined\n+//!   over their entire input range (partial functions)\n+//! * Return value for otherwise reporting simple errors, where `None` is\n+//!   returned on error\n+//! * Optional struct fields\n+//! * Struct fields that can be loaned or \"taken\"\n+//! * Optional function arguments\n+//! * Nullable pointers\n+//! * Swapping things out of difficult situations\n //!\n-//! Options are most commonly used with pattern matching to query the presence\n+//! Options are commonly paired with pattern matching to query the presence\n //! of a value and take action, always accounting for the `None` case.\n //!\n-//! # Example\n+//! ```\n+//! # // FIXME This is not the greatest first example\n+//! // cow_says contains the word \"moo\"\n+//! let cow_says = Some(\"moo\");\n+//! // dog_says does not contain a value\n+//! let dog_says: Option<&str> = None;\n+//!\n+//! // Pattern match to retrieve the value\n+//! match (cow_says, dog_says) {\n+//!     (Some(cow_words), Some(dog_words)) => {\n+//!         println!(\"Cow says {} and dog says {}!\", cow_words, dog_words);\n+//!     }\n+//!     (Some(cow_words), None) => println!(\"Cow says {}\", cow_words),\n+//!     (None, Some(dog_words)) => println!(\"Dog says {}\", dog_words),\n+//!     (None, None) => println!(\"Cow and dog are suspiciously silent\")\n+//! }\n+//! ```\n+//!\n+//\n+// FIXME: Show how `Option` is used in practice, with lots of methods\n+//\n+//! # Options and pointers (\"nullable\" pointers)\n+//!\n+//! Rust's pointer types must always point to a valid location; there are\n+//! no \"null\" pointers. Instead, Rust has *optional* pointers, like\n+//! the optional owned box, `Option<~T>`.\n+//!\n+//! The following example uses `Option` to create an optional box of\n+//! `int`. Notice that in order to use the inner `int` value first the\n+//! `check_optional` function needs to use pattern matching to\n+//! determine whether the box has a value (i.e. it is `Some(...)`) or\n+//! not (`None`).\n //!\n //! ```\n-//! let msg = Some(~\"howdy\");\n+//! let optional: Option<~int> = None;\n+//! check_optional(&optional);\n+//!\n+//! let optional: Option<~int> = Some(~9000);\n+//! check_optional(&optional);\n+//!\n+//! fn check_optional(optional: &Option<~int>) {\n+//!     match *optional {\n+//!         Some(ref p) => println!(\"have value {}\", p),\n+//!         None => println!(\"have no value\")\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! This usage of `Option` to create safe nullable pointers is so\n+//! common that Rust does special optimizations to make the\n+//! representation of `Option<~T>` a single pointer. Optional pointers\n+//! in Rust are stored as efficiently as any other pointer type.\n+//!\n+//! # Examples\n+//!\n+//! Basic pattern matching on `Option`:\n+//!\n+//! ```\n+//! let msg = Some(\"howdy\");\n //!\n //! // Take a reference to the contained string\n //! match msg {\n@@ -33,9 +98,45 @@\n //! // Remove the contained string, destroying the Option\n //! let unwrapped_msg = match msg {\n //!     Some(m) => m,\n-//!     None => ~\"default message\"\n+//!     None => \"default message\"\n //! };\n //! ```\n+//!\n+//! Initialize a result to `None` before a loop:\n+//!\n+//! ```\n+//! enum Kingdom { Plant(uint, &'static str), Animal(uint, &'static str) }\n+//!\n+//! // A list of data to search through.\n+//! let all_the_big_things = [\n+//!     Plant(250, \"redwood\"),\n+//!     Plant(230, \"noble fir\"),\n+//!     Plant(229, \"sugar pine\"),\n+//!     Animal(25, \"blue whale\"),\n+//!     Animal(19, \"fin whale\"),\n+//!     Animal(15, \"north pacific right whale\"),\n+//! ];\n+//!\n+//! // We're going to search for the name of the biggest animal,\n+//! // but to start with we've just got `None`.\n+//! let mut name_of_biggest_animal = None;\n+//! let mut size_of_biggest_animal = 0;\n+//! for big_thing in all_the_big_things.iter() {\n+//!     match *big_thing {\n+//!         Animal(size, name) if size > size_of_biggest_animal => {\n+//!             // Now we've found the name of some big animal\n+//!             size_of_biggest_animal = size;\n+//!             name_of_biggest_animal = Some(name);\n+//!         }\n+//!         Animal(..) | Plant(..) => ()\n+//!     }\n+//! }\n+//!\n+//! match name_of_biggest_animal {\n+//!     Some(name) => println!(\"the biggest animal is {}\", name),\n+//!     None => println!(\"there are no animals :(\")\n+//! }\n+//! ```\n \n use any::Any;\n use clone::Clone;\n@@ -46,7 +147,7 @@ use kinds::Send;\n use mem;\n use vec;\n \n-/// The option type\n+/// The `Option`\n #[deriving(Clone, Eq, Ord, TotalEq, TotalOrd, Show)]\n pub enum Option<T> {\n     /// No value\n@@ -64,7 +165,7 @@ impl<T> Option<T> {\n     // Querying the contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Returns true if the option contains a `Some` value\n+    /// Returns `true` if the option is a `Some` value\n     #[inline]\n     pub fn is_some(&self) -> bool {\n         match *self {\n@@ -73,7 +174,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Returns true if the option equals `None`\n+    /// Returns `true` if the option is a `None` value\n     #[inline]\n     pub fn is_none(&self) -> bool {\n         !self.is_some()\n@@ -84,6 +185,21 @@ impl<T> Option<T> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Convert from `Option<T>` to `Option<&T>`\n+    ///\n+    /// # Example\n+    ///\n+    /// Convert an `Option<~str>` into an `Option<int>`, preserving the original.\n+    /// The `map` method takes the `self` argument by value, consuming the original,\n+    /// so this technique uses `as_ref` to first take an `Option` to a reference\n+    /// to the value inside the original.\n+    ///\n+    /// ```\n+    /// let num_as_str: Option<~str> = Some(~\"10\");\n+    /// // First, cast `Option<~str>` to `Option<&~str>` with `as_ref`,\n+    /// // then consume *that* with `map`, leaving `num_as_str` on the stack.\n+    /// let num_as_int: Option<uint> = num_as_str.as_ref().map(|n| n.len());\n+    /// println!(\"still can print num_as_str: {}\", num_as_str);\n+    /// ```\n     #[inline]\n     pub fn as_ref<'r>(&'r self) -> Option<&'r T> {\n         match *self { Some(ref x) => Some(x), None => None }\n@@ -118,6 +234,9 @@ impl<T> Option<T> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Unwraps an option, yielding the content of a `Some`\n+    ///\n+    /// # Failure\n+    ///\n     /// Fails if the value is a `None` with a custom failure message provided by `msg`.\n     #[inline]\n     pub fn expect<M: Any + Send>(self, msg: M) -> T {\n@@ -127,14 +246,11 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Moves a value out of an option type and returns it.\n-    ///\n-    /// Useful primarily for getting strings, vectors and unique pointers out\n-    /// of option types without copying them.\n+    /// Moves a value out of an option type and returns it, consuming the `Option`.\n     ///\n     /// # Failure\n     ///\n-    /// Fails if the value equals `None`.\n+    /// Fails if the self value equals `None`.\n     ///\n     /// # Safety note\n     ///\n@@ -171,7 +287,17 @@ impl<T> Option<T> {\n     // Transforming contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n+    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value\n+    ///\n+    /// # Example\n+    ///\n+    /// Convert an `Option<~str>` into an `Option<uint>`, consuming the original:\n+    ///\n+    /// ```\n+    /// let num_as_str: Option<~str> = Some(~\"10\");\n+    /// // `Option::map` takes self *by value*, consuming `num_as_str`\n+    /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n+    /// ```\n     #[inline]\n     pub fn map<U>(self, f: |T| -> U) -> Option<U> {\n         match self { Some(x) => Some(f(x)), None => None }\n@@ -359,7 +485,28 @@ impl<T> Option<T> {\n }\n \n impl<T: Default> Option<T> {\n-    /// Returns the contained value or default (for this type)\n+    /// Returns the contained value or a default\n+    ///\n+    /// Consumes the `self` argument then, if `Some`, returns the contained\n+    /// value, otherwise if `None`, returns the default value for that\n+    /// type.\n+    ///\n+    /// # Example\n+    ///\n+    /// Convert a string to an integer, turning poorly-formed strings\n+    /// into 0 (the default value for integers). `from_str` converts\n+    /// a string to any other type that implements `FromStr`, returning\n+    /// `None` on error.\n+    ///\n+    /// ```\n+    /// let good_year_from_input = \"1909\";\n+    /// let bad_year_from_input = \"190blarg\";\n+    /// let good_year = from_str(good_year_from_input).unwrap_or_default();\n+    /// let bad_year = from_str(bad_year_from_input).unwrap_or_default();\n+    ///\n+    /// assert_eq!(1909, good_year);\n+    /// assert_eq!(0, bad_year);\n+    /// ```\n     #[inline]\n     pub fn unwrap_or_default(self) -> T {\n         match self {\n@@ -382,7 +529,10 @@ impl<T> Default for Option<T> {\n // The Option Iterator\n /////////////////////////////////////////////////////////////////////////////\n \n-/// An iterator that yields either one or zero elements\n+/// An `Option` iterator that yields either one or zero elements\n+///\n+/// The `Item` iterator is returned by the `iter`, `mut_iter` and `move_iter`\n+/// methods on `Option`.\n #[deriving(Clone)]\n pub struct Item<A> {\n     priv opt: Option<A>"}]}