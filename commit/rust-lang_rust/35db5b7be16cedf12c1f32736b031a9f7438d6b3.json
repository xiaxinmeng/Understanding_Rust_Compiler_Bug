{"sha": "35db5b7be16cedf12c1f32736b031a9f7438d6b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZGI1YjdiZTE2Y2VkZjEyYzFmMzI3MzZiMDMxYTlmNzQzOGQ2YjM=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-09T00:05:31Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-09T00:05:31Z"}, "message": "Merge pull request #3153 from jruderman/sconv\n\nAdd spawn_conversation", "tree": {"sha": "8cb00f5703e0ef045dbae2a47c330e4fa2e58754", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cb00f5703e0ef045dbae2a47c330e4fa2e58754"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35db5b7be16cedf12c1f32736b031a9f7438d6b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35db5b7be16cedf12c1f32736b031a9f7438d6b3", "html_url": "https://github.com/rust-lang/rust/commit/35db5b7be16cedf12c1f32736b031a9f7438d6b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35db5b7be16cedf12c1f32736b031a9f7438d6b3/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "904a74e99cd18d4e02501a675e6d7071bc7c7783", "url": "https://api.github.com/repos/rust-lang/rust/commits/904a74e99cd18d4e02501a675e6d7071bc7c7783", "html_url": "https://github.com/rust-lang/rust/commit/904a74e99cd18d4e02501a675e6d7071bc7c7783"}, {"sha": "a76e4334b39a2287b039f858c3bd3d5f5d6e2449", "url": "https://api.github.com/repos/rust-lang/rust/commits/a76e4334b39a2287b039f858c3bd3d5f5d6e2449", "html_url": "https://github.com/rust-lang/rust/commit/a76e4334b39a2287b039f858c3bd3d5f5d6e2449"}], "stats": {"total": 118, "additions": 67, "deletions": 51}, "files": [{"sha": "f299ecccc90c3c8b41a162d6ee3b26b6ad83efaf", "filename": "doc/tutorial.md", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/35db5b7be16cedf12c1f32736b031a9f7438d6b3/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/35db5b7be16cedf12c1f32736b031a9f7438d6b3/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=35db5b7be16cedf12c1f32736b031a9f7438d6b3", "patch": "@@ -196,7 +196,7 @@ When complete, `make install` will place the following programs into\n `/usr/local/bin`:\n \n   * `rustc`, the Rust compiler\n-  * `rustdoc`, the API-documentation tool \n+  * `rustdoc`, the API-documentation tool\n   * `cargo`, the Rust package manager\n \n [wiki-get-started]: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\n@@ -2960,7 +2960,11 @@ do spawn {\n ~~~~\n \n This child will perform the expensive computation send the result\n-over the channel.  Finally, the parent continues by performing\n+over the channel.  (Under the hood, `chan` was captured by the\n+closure that forms the body of the child task.  This capture is\n+allowed because channels are sendable.)\n+\n+Finally, the parent continues by performing\n some other expensive computation and then waiting for the child's result\n to arrive on the port:\n \n@@ -2978,10 +2982,10 @@ let result = port.recv();\n \n A very common thing to do is to spawn a child task where the parent\n and child both need to exchange messages with each\n-other. The function `task::spawn_listener()` supports this pattern. We'll look\n-briefly at how it is used.\n+other. The function `task::spawn_conversation()` supports this pattern.\n+We'll look briefly at how it is used.\n \n-To see how `spawn_listener()` works, we will create a child task\n+To see how `spawn_conversation()` works, we will create a child task\n that receives `uint` messages, converts them to a string, and sends\n the string in response.  The child terminates when `0` is received.\n Here is the function that implements the child task:\n@@ -3006,11 +3010,11 @@ loops, reading from the `from_parent` port and then sending its\n response to the `to_parent` channel.  The actual response itself is\n simply the strified version of the received value,\n `uint::to_str(value)`.\n- \n+\n Here is the code for the parent task:\n \n ~~~~\n-# import task::{spawn_listener};\n+# import task::{spawn_conversation};\n # import comm::{chan, port, methods};\n # fn stringifier(from_parent: comm::port<uint>,\n #                to_parent: comm::chan<~str>) {\n@@ -3020,32 +3024,30 @@ Here is the code for the parent task:\n # }\n # fn main() {\n \n-let from_child = port();\n-let to_parent = from_child.chan();\n-let to_child = do spawn_listener |from_parent| {\n+let (from_child, to_child) = do spawn_conversation |from_parent, to_parent| {\n     stringifier(from_parent, to_parent);\n };\n \n to_child.send(22u);\n assert from_child.recv() == ~\"22\";\n \n to_child.send(23u);\n-assert from_child.recv() == ~\"23\";\n-\n to_child.send(0u);\n+\n+assert from_child.recv() == ~\"23\";\n assert from_child.recv() == ~\"0\";\n \n # }\n ~~~~\n \n-The parent first sets up a port to receive data from and a channel\n-that the child can use to send data to that port. The call to\n-`spawn_listener()` will spawn the child task, providing it with a port\n-on which to receive data from its parent, and returning to the parent\n-the associated channel. Finally, the closure passed to\n-`spawn_listener()` that forms the body of the child task captures the\n-`to_parent` channel in its environment, so both parent and child\n-can send and receive data to and from the other.\n+The parent task calls `spawn_conversation` with a function that takes\n+a `from_parent` port and a `to_parent` channel.  In return, it gets a\n+`from_child` channel and a `to_child` port.  As a result, both parent\n+and child can send and receive data to and from the other.\n+\n+`spawn_conversation`\n+will create two port/channel pairs, passing one set to the child task\n+and returning the other set to the caller.\n \n # Testing\n "}, {"sha": "2ec12b6c849fd795f49c8b83a03150f6b9674eda", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35db5b7be16cedf12c1f32736b031a9f7438d6b3/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35db5b7be16cedf12c1f32736b031a9f7438d6b3/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=35db5b7be16cedf12c1f32736b031a9f7438d6b3", "patch": "@@ -40,9 +40,8 @@ unsafe fn chan_from_global_ptr<T: send>(\n         log(debug,~\"is probably zero...\");\n         // There's no global channel. We must make it\n \n-        let setup_po = comm::port();\n-        let setup_ch = comm::chan(setup_po);\n-        let setup_ch = do task_fn().spawn_listener |setup_po| {\n+        let (setup_po, setup_ch) = do task_fn().spawn_conversation\n+            |setup_po, setup_ch| {\n             let po = comm::port::<T>();\n             let ch = comm::chan(po);\n             comm::send(setup_ch, ch);"}, {"sha": "282f692d2d665f4df1fc5af7ab5e65e4225efdc6", "filename": "src/libcore/task.rs", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/35db5b7be16cedf12c1f32736b031a9f7438d6b3/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35db5b7be16cedf12c1f32736b031a9f7438d6b3/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=35db5b7be16cedf12c1f32736b031a9f7438d6b3", "patch": "@@ -52,6 +52,7 @@ export spawn_unlinked;\n export spawn_supervised;\n export spawn_with;\n export spawn_listener;\n+export spawn_conversation;\n export spawn_sched;\n export try;\n \n@@ -376,6 +377,20 @@ impl task_builder for task_builder {\n         comm::recv(setup_po)\n     }\n \n+    /**\n+     * Runs a new task, setting up communication in both directions\n+     */\n+    fn spawn_conversation<A: send, B: send>\n+        (+f: fn~(comm::port<A>, comm::chan<B>))\n+        -> (comm::port<B>, comm::chan<A>) {\n+        let from_child = comm::port();\n+        let to_parent = comm::chan(from_child);\n+        let to_child = do self.spawn_listener |from_parent| {\n+            f(from_parent, to_parent)\n+        };\n+        (from_child, to_child)\n+    }\n+\n     /**\n      * Execute a function in another task and return either the return value\n      * of the function or result::err.\n@@ -474,31 +489,24 @@ fn spawn_listener<A:send>(+f: fn~(comm::port<A>)) -> comm::chan<A> {\n     /*!\n      * Runs a new task while providing a channel from the parent to the child\n      *\n-     * Sets up a communication channel from the current task to the new\n-     * child task, passes the port to child's body, and returns a channel\n-     * linked to the port to the parent.\n-     *\n-     * This encapsulates some boilerplate handshaking logic that would\n-     * otherwise be required to establish communication from the parent\n-     * to the child.\n-     *\n-     * The simplest way to establish bidirectional communication between\n-     * a parent in child is as follows:\n-     *\n-     *     let po = comm::port();\n-     *     let ch = comm::chan(po);\n-     *     let ch = do spawn_listener |po| {\n-     *         // Now the child has a port called 'po' to read from and\n-     *         // an environment-captured channel called 'ch'.\n-     *     };\n-     *     // Likewise, the parent has both a 'po' and 'ch'\n-     *\n      * This function is equivalent to `task().spawn_listener(f)`.\n      */\n \n     task().spawn_listener(f)\n }\n \n+fn spawn_conversation<A: send, B: send>\n+    (+f: fn~(comm::port<A>, comm::chan<B>))\n+    -> (comm::port<B>, comm::chan<A>) {\n+    /*!\n+     * Runs a new task, setting up communication in both directions\n+     *\n+     * This function is equivalent to `task().spawn_conversation(f)`.\n+     */\n+\n+    task().spawn_conversation(f)\n+}\n+\n fn spawn_sched(mode: sched_mode, +f: fn~()) {\n     /*!\n      * Creates a new scheduler and executes a task on it\n@@ -1716,6 +1724,17 @@ fn test_spawn_listiner_bidi() {\n     assert res == ~\"pong\";\n }\n \n+#[test]\n+fn test_spawn_conversation() {\n+    let (recv_str, send_int) = do spawn_conversation |recv_int, send_str| {\n+        let input = comm::recv(recv_int);\n+        let output = int::str(input);\n+        comm::send(send_str, output);\n+    };\n+    comm::send(send_int, 1);\n+    assert comm::recv(recv_str) == ~\"1\";\n+}\n+\n #[test]\n fn test_try_success() {\n     match do try {"}, {"sha": "592f8e0019020a3374e5da92e38223e2f6aef491", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35db5b7be16cedf12c1f32736b031a9f7438d6b3/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35db5b7be16cedf12c1f32736b031a9f7438d6b3/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=35db5b7be16cedf12c1f32736b031a9f7438d6b3", "patch": "@@ -29,9 +29,8 @@ fn run(\n         return doc;\n     }\n \n-    let result_port = comm::port();\n-    let result_chan = comm::chan(result_port);\n-    let page_chan = do task::spawn_listener |page_port| {\n+    let (result_port, page_chan) = do task::spawn_conversation\n+        |page_port, result_chan| {\n         comm::send(result_chan, make_doc_from_pages(page_port));\n     };\n "}, {"sha": "3bf89e43035ad4eea01310df36b2eed8e8fa4450", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35db5b7be16cedf12c1f32736b031a9f7438d6b3/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35db5b7be16cedf12c1f32736b031a9f7438d6b3/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=35db5b7be16cedf12c1f32736b031a9f7438d6b3", "patch": "@@ -28,15 +28,12 @@ fn server(requests: comm::port<request>, responses: comm::chan<uint>) {\n }\n \n fn run(args: ~[~str]) {\n-    let from_child = comm::port();\n-    let to_parent = comm::chan(from_child);\n-    let to_child = do task::spawn_listener |po| {\n-        server(po, to_parent);\n+    let (from_child, to_child) = do task::spawn_conversation |po, ch| {\n+        server(po, ch);\n     };\n     let size = option::get(uint::from_str(args[1]));\n     let workers = option::get(uint::from_str(args[2]));\n     let start = std::time::precise_time_s();\n-    let to_child = to_child;\n     let mut worker_results = ~[];\n     for uint::range(0u, workers) |_i| {\n         do task::task().future_result(|+r| {\n@@ -65,7 +62,7 @@ fn main(args: ~[~str]) {\n         ~[~\"\", ~\"10000\", ~\"4\"]\n     } else {\n         args\n-    };        \n+    };\n \n     debug!{\"%?\", args};\n     run(args);"}]}