{"sha": "b2ab5d7658435f8710acc0b0a99ce858af36bd9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYWI1ZDc2NTg0MzVmODcxMGFjYzBiMGE5OWNlODU4YWYzNmJkOWE=", "commit": {"author": {"name": "ville-h", "email": "ville3.14159@gmail.com", "date": "2015-01-03T23:58:35Z"}, "committer": {"name": "ville-h", "email": "ville3.14159@gmail.com", "date": "2015-01-03T23:58:35Z"}, "message": "fix code and comments referencing RwLock", "tree": {"sha": "cd6235f444f8ee2614e301844d194a59ecb9bcc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd6235f444f8ee2614e301844d194a59ecb9bcc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2ab5d7658435f8710acc0b0a99ce858af36bd9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2ab5d7658435f8710acc0b0a99ce858af36bd9a", "html_url": "https://github.com/rust-lang/rust/commit/b2ab5d7658435f8710acc0b0a99ce858af36bd9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2ab5d7658435f8710acc0b0a99ce858af36bd9a/comments", "author": {"login": "ville-h", "id": 8824715, "node_id": "MDQ6VXNlcjg4MjQ3MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8824715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ville-h", "html_url": "https://github.com/ville-h", "followers_url": "https://api.github.com/users/ville-h/followers", "following_url": "https://api.github.com/users/ville-h/following{/other_user}", "gists_url": "https://api.github.com/users/ville-h/gists{/gist_id}", "starred_url": "https://api.github.com/users/ville-h/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ville-h/subscriptions", "organizations_url": "https://api.github.com/users/ville-h/orgs", "repos_url": "https://api.github.com/users/ville-h/repos", "events_url": "https://api.github.com/users/ville-h/events{/privacy}", "received_events_url": "https://api.github.com/users/ville-h/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ville-h", "id": 8824715, "node_id": "MDQ6VXNlcjg4MjQ3MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8824715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ville-h", "html_url": "https://github.com/ville-h", "followers_url": "https://api.github.com/users/ville-h/followers", "following_url": "https://api.github.com/users/ville-h/following{/other_user}", "gists_url": "https://api.github.com/users/ville-h/gists{/gist_id}", "starred_url": "https://api.github.com/users/ville-h/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ville-h/subscriptions", "organizations_url": "https://api.github.com/users/ville-h/orgs", "repos_url": "https://api.github.com/users/ville-h/repos", "events_url": "https://api.github.com/users/ville-h/events{/privacy}", "received_events_url": "https://api.github.com/users/ville-h/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2c2cb942ebb443bfbc864a4606cc2784c850882", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2c2cb942ebb443bfbc864a4606cc2784c850882", "html_url": "https://github.com/rust-lang/rust/commit/a2c2cb942ebb443bfbc864a4606cc2784c850882"}], "stats": {"total": 64, "additions": 32, "deletions": 32}, "files": [{"sha": "3410976a6e4519011512faeffa21137ed9ef6879", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2ab5d7658435f8710acc0b0a99ce858af36bd9a/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ab5d7658435f8710acc0b0a99ce858af36bd9a/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=b2ab5d7658435f8710acc0b0a99ce858af36bd9a", "patch": "@@ -21,7 +21,7 @@ pub use alloc::arc::{Arc, Weak};\n \n pub use self::mutex::{Mutex, MutexGuard, StaticMutex};\n pub use self::mutex::MUTEX_INIT;\n-pub use self::rwlock::{RWLock, StaticRWLock, RWLOCK_INIT};\n+pub use self::rwlock::{RwLock, StaticRWLock, RWLOCK_INIT};\n pub use self::rwlock::{RWLockReadGuard, RWLockWriteGuard};\n pub use self::condvar::{Condvar, StaticCondvar, CONDVAR_INIT};\n pub use self::once::{Once, ONCE_INIT};"}, {"sha": "087281d6ce6d6c632b8d231ec7421e6235cd833d", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b2ab5d7658435f8710acc0b0a99ce858af36bd9a/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ab5d7658435f8710acc0b0a99ce858af36bd9a/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=b2ab5d7658435f8710acc0b0a99ce858af36bd9a", "patch": "@@ -31,17 +31,17 @@ use sys_common::rwlock as sys;\n ///\n /// # Poisoning\n ///\n-/// RWLocks, like Mutexes, will become poisoned on panics. Note, however, that\n-/// an RWLock may only be poisoned if a panic occurs while it is locked\n+/// RwLocks, like Mutexes, will become poisoned on panics. Note, however, that\n+/// an RwLock may only be poisoned if a panic occurs while it is locked\n /// exclusively (write mode). If a panic occurs in any reader, then the lock\n /// will not be poisoned.\n ///\n /// # Examples\n ///\n /// ```\n-/// use std::sync::RWLock;\n+/// use std::sync::RwLock;\n ///\n-/// let lock = RWLock::new(5i);\n+/// let lock = RwLock::new(5i);\n ///\n /// // many reader locks can be held at once\n /// {\n@@ -67,11 +67,11 @@ pub struct RwLock<T> {\n unsafe impl<T:'static+Send> Send for RwLock<T> {}\n unsafe impl<T> Sync for RwLock<T> {}\n \n-/// Structure representing a statically allocated RWLock.\n+/// Structure representing a statically allocated RwLock.\n ///\n /// This structure is intended to be used inside of a `static` and will provide\n /// automatic global access as well as lazy initialization. The internal\n-/// resources of this RWLock, however, must be manually deallocated.\n+/// resources of this RwLock, however, must be manually deallocated.\n ///\n /// # Example\n ///\n@@ -90,7 +90,7 @@ unsafe impl<T> Sync for RwLock<T> {}\n /// }\n /// unsafe { LOCK.destroy() } // free all resources\n /// ```\n-#[unstable = \"may be merged with RWLock in the future\"]\n+#[unstable = \"may be merged with RwLock in the future\"]\n pub struct StaticRWLock {\n     lock: sys::RWLock,\n     poison: poison::Flag,\n@@ -100,7 +100,7 @@ unsafe impl Send for StaticRWLock {}\n unsafe impl Sync for StaticRWLock {}\n \n /// Constant initialization for a statically-initialized rwlock.\n-#[unstable = \"may be merged with RWLock in the future\"]\n+#[unstable = \"may be merged with RwLock in the future\"]\n pub const RWLOCK_INIT: StaticRWLock = StaticRWLock {\n     lock: sys::RWLOCK_INIT,\n     poison: poison::FLAG_INIT,\n@@ -128,7 +128,7 @@ pub struct RWLockWriteGuard<'a, T: 'a> {\n }\n \n impl<T: Send + Sync> RwLock<T> {\n-    /// Creates a new instance of an RWLock which is unlocked and read to go.\n+    /// Creates a new instance of an RwLock which is unlocked and read to go.\n     #[stable]\n     pub fn new(t: T) -> RwLock<T> {\n         RwLock { inner: box RWLOCK_INIT, data: UnsafeCell::new(t) }\n@@ -148,7 +148,7 @@ impl<T: Send + Sync> RwLock<T> {\n     ///\n     /// # Failure\n     ///\n-    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// This function will return an error if the RwLock is poisoned. An RwLock\n     /// is poisoned whenever a writer panics while holding an exclusive lock.\n     /// The failure will occur immediately after the lock has been acquired.\n     #[inline]\n@@ -169,7 +169,7 @@ impl<T: Send + Sync> RwLock<T> {\n     ///\n     /// # Failure\n     ///\n-    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// This function will return an error if the RwLock is poisoned. An RwLock\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n@@ -194,7 +194,7 @@ impl<T: Send + Sync> RwLock<T> {\n     ///\n     /// # Failure\n     ///\n-    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// This function will return an error if the RwLock is poisoned. An RwLock\n     /// is poisoned whenever a writer panics while holding an exclusive lock.\n     /// An error will be returned when the lock is acquired.\n     #[inline]\n@@ -212,7 +212,7 @@ impl<T: Send + Sync> RwLock<T> {\n     ///\n     /// # Failure\n     ///\n-    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// This function will return an error if the RwLock is poisoned. An RwLock\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n@@ -242,19 +242,19 @@ impl StaticRWLock {\n     /// Locks this rwlock with shared read access, blocking the current thread\n     /// until it can be acquired.\n     ///\n-    /// See `RWLock::read`.\n+    /// See `RwLock::read`.\n     #[inline]\n-    #[unstable = \"may be merged with RWLock in the future\"]\n+    #[unstable = \"may be merged with RwLock in the future\"]\n     pub fn read(&'static self) -> LockResult<RWLockReadGuard<'static, ()>> {\n         unsafe { self.lock.read() }\n         RWLockReadGuard::new(self, &DUMMY.0)\n     }\n \n     /// Attempt to acquire this lock with shared read access.\n     ///\n-    /// See `RWLock::try_read`.\n+    /// See `RwLock::try_read`.\n     #[inline]\n-    #[unstable = \"may be merged with RWLock in the future\"]\n+    #[unstable = \"may be merged with RwLock in the future\"]\n     pub fn try_read(&'static self)\n                     -> TryLockResult<RWLockReadGuard<'static, ()>> {\n         if unsafe { self.lock.try_read() } {\n@@ -267,19 +267,19 @@ impl StaticRWLock {\n     /// Lock this rwlock with exclusive write access, blocking the current\n     /// thread until it can be acquired.\n     ///\n-    /// See `RWLock::write`.\n+    /// See `RwLock::write`.\n     #[inline]\n-    #[unstable = \"may be merged with RWLock in the future\"]\n+    #[unstable = \"may be merged with RwLock in the future\"]\n     pub fn write(&'static self) -> LockResult<RWLockWriteGuard<'static, ()>> {\n         unsafe { self.lock.write() }\n         RWLockWriteGuard::new(self, &DUMMY.0)\n     }\n \n     /// Attempt to lock this rwlock with exclusive write access.\n     ///\n-    /// See `RWLock::try_write`.\n+    /// See `RwLock::try_write`.\n     #[inline]\n-    #[unstable = \"may be merged with RWLock in the future\"]\n+    #[unstable = \"may be merged with RwLock in the future\"]\n     pub fn try_write(&'static self)\n                      -> TryLockResult<RWLockWriteGuard<'static, ()>> {\n         if unsafe { self.lock.try_write() } {\n@@ -295,7 +295,7 @@ impl StaticRWLock {\n     /// active users of the lock, and this also doesn't prevent any future users\n     /// of this lock. This method is required to be called to not leak memory on\n     /// all platforms.\n-    #[unstable = \"may be merged with RWLock in the future\"]\n+    #[unstable = \"may be merged with RwLock in the future\"]\n     pub unsafe fn destroy(&'static self) {\n         self.lock.destroy()\n     }\n@@ -365,11 +365,11 @@ mod tests {\n     use rand::{mod, Rng};\n     use sync::mpsc::channel;\n     use thread::Thread;\n-    use sync::{Arc, RWLock, StaticRWLock, RWLOCK_INIT};\n+    use sync::{Arc, RwLock, StaticRWLock, RWLOCK_INIT};\n \n     #[test]\n     fn smoke() {\n-        let l = RWLock::new(());\n+        let l = RwLock::new(());\n         drop(l.read().unwrap());\n         drop(l.write().unwrap());\n         drop((l.read().unwrap(), l.read().unwrap()));\n@@ -414,7 +414,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc_poison_wr() {\n-        let arc = Arc::new(RWLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1i));\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::spawn(move|| {\n             let _lock = arc2.write().unwrap();\n@@ -425,7 +425,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc_poison_ww() {\n-        let arc = Arc::new(RWLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1i));\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::spawn(move|| {\n             let _lock = arc2.write().unwrap();\n@@ -436,7 +436,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc_no_poison_rr() {\n-        let arc = Arc::new(RWLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1i));\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::spawn(move|| {\n             let _lock = arc2.read().unwrap();\n@@ -447,7 +447,7 @@ mod tests {\n     }\n     #[test]\n     fn test_rw_arc_no_poison_rw() {\n-        let arc = Arc::new(RWLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1i));\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::spawn(move|| {\n             let _lock = arc2.read().unwrap();\n@@ -459,7 +459,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc() {\n-        let arc = Arc::new(RWLock::new(0i));\n+        let arc = Arc::new(RwLock::new(0i));\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n@@ -497,11 +497,11 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc_access_in_unwind() {\n-        let arc = Arc::new(RWLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1i));\n         let arc2 = arc.clone();\n         let _ = Thread::spawn(move|| -> () {\n             struct Unwinder {\n-                i: Arc<RWLock<int>>,\n+                i: Arc<RwLock<int>>,\n             }\n             impl Drop for Unwinder {\n                 fn drop(&mut self) {"}]}