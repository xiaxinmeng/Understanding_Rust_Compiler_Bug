{"sha": "15dd4170ff05f561964da4679f8958ce2172889d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZGQ0MTcwZmYwNWY1NjE5NjRkYTQ2NzlmODk1OGNlMjE3Mjg4OWQ=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-11-05T21:28:49Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-11-05T21:28:49Z"}, "message": "Rollup merge of #29613 - steveklabnik:29506, r=alexcrichton\n\nin favor of just expect()\n\nFixes #29506", "tree": {"sha": "43ae10171f75d409bed8fe853f02692eb5932798", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43ae10171f75d409bed8fe853f02692eb5932798"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15dd4170ff05f561964da4679f8958ce2172889d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15dd4170ff05f561964da4679f8958ce2172889d", "html_url": "https://github.com/rust-lang/rust/commit/15dd4170ff05f561964da4679f8958ce2172889d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15dd4170ff05f561964da4679f8958ce2172889d/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdccd942691ac9d7a213cad6d9c23e385794e818", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdccd942691ac9d7a213cad6d9c23e385794e818", "html_url": "https://github.com/rust-lang/rust/commit/fdccd942691ac9d7a213cad6d9c23e385794e818"}, {"sha": "6d9502d35b4b0bc41bee1bd3acc0d75bf2cfd835", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d9502d35b4b0bc41bee1bd3acc0d75bf2cfd835", "html_url": "https://github.com/rust-lang/rust/commit/6d9502d35b4b0bc41bee1bd3acc0d75bf2cfd835"}], "stats": {"total": 76, "additions": 27, "deletions": 49}, "files": [{"sha": "6a513fb2c5963dc84743e2011ebb2953ee341a07", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 27, "deletions": 49, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/15dd4170ff05f561964da4679f8958ce2172889d/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/15dd4170ff05f561964da4679f8958ce2172889d/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=15dd4170ff05f561964da4679f8958ce2172889d", "patch": "@@ -83,7 +83,6 @@ fn main() {\n     let mut guess = String::new();\n \n     io::stdin().read_line(&mut guess)\n-        .ok()\n         .expect(\"Failed to read line\");\n \n     println!(\"You guessed: {}\", guess);\n@@ -189,7 +188,6 @@ Let\u2019s move forward:\n \n ```rust,ignore\n     io::stdin().read_line(&mut guess)\n-        .ok()\n         .expect(\"Failed to read line\");\n ```\n \n@@ -245,7 +243,6 @@ a single line of text, it\u2019s only the first part of the single logical line of\n code:\n \n ```rust,ignore\n-        .ok()\n         .expect(\"Failed to read line\");\n ```\n \n@@ -254,33 +251,27 @@ and other whitespace. This helps you split up long lines. We _could_ have\n done:\n \n ```rust,ignore\n-    io::stdin().read_line(&mut guess).ok().expect(\"failed to read line\");\n+    io::stdin().read_line(&mut guess).expect(\"failed to read line\");\n ```\n \n-But that gets hard to read. So we\u2019ve split it up, three lines for three\n-method calls. We already talked about `read_line()`, but what about `ok()`\n-and `expect()`? Well, we already mentioned that `read_line()` puts what\n-the user types into the `&mut String` we pass it. But it also returns\n-a value: in this case, an [`io::Result`][ioresult]. Rust has a number of\n-types named `Result` in its standard library: a generic [`Result`][result],\n-and then specific versions for sub-libraries, like `io::Result`.\n+But that gets hard to read. So we\u2019ve split it up, three lines for three method\n+calls. We already talked about `read_line()`, but what about `expect()`? Well,\n+we already mentioned that `read_line()` puts what the user types into the `&mut\n+String` we pass it. But it also returns a value: in this case, an\n+[`io::Result`][ioresult]. Rust has a number of types named `Result` in its\n+standard library: a generic [`Result`][result], and then specific versions for\n+sub-libraries, like `io::Result`.\n \n [ioresult]: ../std/io/type.Result.html\n [result]: ../std/result/enum.Result.html\n \n The purpose of these `Result` types is to encode error handling information.\n Values of the `Result` type, like any type, have methods defined on them. In\n-this case, `io::Result` has an `ok()` method, which says \u2018we want to assume\n-this value is a successful one. If not, just throw away the error\n-information\u2019. Why throw it away? Well, for a basic program, we just want to\n-print a generic error, as basically any issue means we can\u2019t continue. The\n-[`ok()` method][ok] returns a value which has another method defined on it:\n-`expect()`. The [`expect()` method][expect] takes a value it\u2019s called on, and\n-if it isn\u2019t a successful one, [`panic!`][panic]s with a message you\n-passed it. A `panic!` like this will cause our program to crash, displaying\n-the message.\n-\n-[ok]: ../std/result/enum.Result.html#method.ok\n+this case, `io::Result` has an [`expect()` method][expect] that takes a value\n+it\u2019s called on, and if it isn\u2019t a successful one, [`panic!`][panic]s with a\n+message you passed it. A `panic!` like this will cause our program to crash,\n+displaying the message.\n+\n [expect]: ../std/option/enum.Option.html#method.expect\n [panic]: error-handling.html\n \n@@ -468,7 +459,6 @@ fn main() {\n     let mut guess = String::new();\n \n     io::stdin().read_line(&mut guess)\n-        .ok()\n         .expect(\"failed to read line\");\n \n     println!(\"You guessed: {}\", guess);\n@@ -557,7 +547,6 @@ fn main() {\n     let mut guess = String::new();\n \n     io::stdin().read_line(&mut guess)\n-        .ok()\n         .expect(\"failed to read line\");\n \n     println!(\"You guessed: {}\", guess);\n@@ -668,11 +657,9 @@ fn main() {\n     let mut guess = String::new();\n \n     io::stdin().read_line(&mut guess)\n-        .ok()\n         .expect(\"failed to read line\");\n \n     let guess: u32 = guess.trim().parse()\n-        .ok()\n         .expect(\"Please type a number!\");\n \n     println!(\"You guessed: {}\", guess);\n@@ -689,7 +676,6 @@ The new three lines:\n \n ```rust,ignore\n     let guess: u32 = guess.trim().parse()\n-        .ok()\n         .expect(\"Please type a number!\");\n ```\n \n@@ -706,27 +692,26 @@ We bind `guess` to an expression that looks like something we wrote earlier:\n guess.trim().parse()\n ```\n \n-Followed by an `ok().expect()` invocation. Here, `guess` refers to the old\n-`guess`, the one that was a `String` with our input in it. The `trim()`\n-method on `String`s will eliminate any white space at the beginning and end of\n-our string. This is important, as we had to press the \u2018return\u2019 key to satisfy\n-`read_line()`. This means that if we type `5` and hit return, `guess` looks\n-like this: `5\\n`. The `\\n` represents \u2018newline\u2019, the enter key. `trim()` gets\n-rid of this, leaving our string with just the `5`. The [`parse()` method on\n-strings][parse] parses a string into some kind of number. Since it can parse a\n-variety of numbers, we need to give Rust a hint as to the exact type of number\n-we want. Hence, `let guess: u32`. The colon (`:`) after `guess` tells Rust\n-we\u2019re going to annotate its type. `u32` is an unsigned, thirty-two bit\n-integer. Rust has [a number of built-in number types][number], but we\u2019ve\n-chosen `u32`. It\u2019s a good default choice for a small positive number.\n+Here, `guess` refers to the old `guess`, the one that was a `String` with our\n+input in it. The `trim()` method on `String`s will eliminate any white space at\n+the beginning and end of our string. This is important, as we had to press the\n+\u2018return\u2019 key to satisfy `read_line()`. This means that if we type `5` and hit\n+return, `guess` looks like this: `5\\n`. The `\\n` represents \u2018newline\u2019, the\n+enter key. `trim()` gets rid of this, leaving our string with just the `5`. The\n+[`parse()` method on strings][parse] parses a string into some kind of number.\n+Since it can parse a variety of numbers, we need to give Rust a hint as to the\n+exact type of number we want. Hence, `let guess: u32`. The colon (`:`) after\n+`guess` tells Rust we\u2019re going to annotate its type. `u32` is an unsigned,\n+thirty-two bit integer. Rust has [a number of built-in number types][number],\n+but we\u2019ve chosen `u32`. It\u2019s a good default choice for a small positive number.\n \n [parse]: ../std/primitive.str.html#method.parse\n [number]: primitive-types.html#numeric-types\n \n Just like `read_line()`, our call to `parse()` could cause an error. What if\n our string contained `A\ud83d\udc4d%`? There\u2019d be no way to convert that to a number. As\n-such, we\u2019ll do the same thing we did with `read_line()`: use the `ok()` and\n-`expect()` methods to crash if there\u2019s an error.\n+such, we\u2019ll do the same thing we did with `read_line()`: use the `expect()`\n+method to crash if there\u2019s an error.\n \n Let\u2019s try our program out!\n \n@@ -773,11 +758,9 @@ fn main() {\n         let mut guess = String::new();\n \n         io::stdin().read_line(&mut guess)\n-            .ok()\n             .expect(\"failed to read line\");\n \n         let guess: u32 = guess.trim().parse()\n-            .ok()\n             .expect(\"Please type a number!\");\n \n         println!(\"You guessed: {}\", guess);\n@@ -841,11 +824,9 @@ fn main() {\n         let mut guess = String::new();\n \n         io::stdin().read_line(&mut guess)\n-            .ok()\n             .expect(\"failed to read line\");\n \n         let guess: u32 = guess.trim().parse()\n-            .ok()\n             .expect(\"Please type a number!\");\n \n         println!(\"You guessed: {}\", guess);\n@@ -888,7 +869,6 @@ fn main() {\n         let mut guess = String::new();\n \n         io::stdin().read_line(&mut guess)\n-            .ok()\n             .expect(\"failed to read line\");\n \n         let guess: u32 = match guess.trim().parse() {\n@@ -920,7 +900,6 @@ let guess: u32 = match guess.trim().parse() {\n ```\n \n This is how you generally move from \u2018crash on error\u2019 to \u2018actually handle the\n-error\u2019, by switching from `ok().expect()` to a `match` statement. The `Result`\n returned by `parse()` is an `enum` just like `Ordering`, but in this case, each\n variant has some data associated with it: `Ok` is a success, and `Err` is a\n failure. Each contains more information: the successfully parsed integer, or an\n@@ -977,7 +956,6 @@ fn main() {\n         let mut guess = String::new();\n \n         io::stdin().read_line(&mut guess)\n-            .ok()\n             .expect(\"failed to read line\");\n \n         let guess: u32 = match guess.trim().parse() {"}]}