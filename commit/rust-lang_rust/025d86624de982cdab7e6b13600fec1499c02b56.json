{"sha": "025d86624de982cdab7e6b13600fec1499c02b56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNWQ4NjYyNGRlOTgyY2RhYjdlNmIxMzYwMGZlYzE0OTljMDJiNTY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-04T02:59:04Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-06T05:08:09Z"}, "message": "Switch alts to use arrows", "tree": {"sha": "96ba196f8a420c52e6034acd14f323d3d2239e29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96ba196f8a420c52e6034acd14f323d3d2239e29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/025d86624de982cdab7e6b13600fec1499c02b56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/025d86624de982cdab7e6b13600fec1499c02b56", "html_url": "https://github.com/rust-lang/rust/commit/025d86624de982cdab7e6b13600fec1499c02b56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/025d86624de982cdab7e6b13600fec1499c02b56/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9d27693796fe4ced8568e11aa465750f743097b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9d27693796fe4ced8568e11aa465750f743097b", "html_url": "https://github.com/rust-lang/rust/commit/c9d27693796fe4ced8568e11aa465750f743097b"}], "stats": {"total": 16522, "additions": 8097, "deletions": 8425}, "files": [{"sha": "33482679920d8b976b1a437e62cf6351ce61bbd6", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 166, "deletions": 174, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -129,22 +129,22 @@ fn is_uuid(id: ~str) -> bool {\n             }\n \n             alt i {\n-                0u {\n+                0u => {\n                     if str::len(part) == 8u {\n                         correct += 1u;\n                     }\n                 }\n-                1u | 2u | 3u {\n+                1u | 2u | 3u => {\n                     if str::len(part) == 4u {\n                         correct += 1u;\n                     }\n                 }\n-                4u {\n+                4u => {\n                     if str::len(part) == 12u {\n                         correct += 1u;\n                     }\n                 }\n-                _ { }\n+                _ => { }\n             }\n         }\n         if correct >= 5u {\n@@ -193,8 +193,8 @@ fn is_archive_url(u: ~str) -> bool {\n     // url parsing, we wouldn't need it\n \n     alt str::find_str(u, ~\"://\") {\n-        option::some(i) { has_archive_extension(u) }\n-        _ { false }\n+        option::some(i) => has_archive_extension(u),\n+        _ => false\n     }\n }\n \n@@ -224,15 +224,15 @@ fn load_link(mis: ~[@ast::meta_item]) -> (option<~str>,\n     let mut uuid = none;\n     for mis.each |a| {\n         alt a.node {\n-            ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) {\n+            ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) => {\n                 alt *v {\n-                    ~\"name\" { name = some(*s); }\n-                    ~\"vers\" { vers = some(*s); }\n-                    ~\"uuid\" { uuid = some(*s); }\n-                    _ { }\n+                    ~\"name\" => name = some(*s),\n+                    ~\"vers\" => vers = some(*s),\n+                    ~\"uuid\" => uuid = some(*s),\n+                    _ => { }\n                 }\n             }\n-            _ { fail ~\"load_link: meta items must be name-values\"; }\n+            _ => fail ~\"load_link: meta items must be name-values\"\n         }\n     }\n     (name, vers, uuid)\n@@ -251,23 +251,23 @@ fn load_crate(filename: ~str) -> option<crate> {\n \n     for c.node.attrs.each |a| {\n         alt a.node.value.node {\n-            ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) {\n+            ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) => {\n                 alt *v {\n-                    ~\"desc\" { desc = some(*v); }\n-                    ~\"sigs\" { sigs = some(*v); }\n-                    ~\"crate_type\" { crate_type = some(*v); }\n-                    _ { }\n+                    ~\"desc\" => desc = some(*v),\n+                    ~\"sigs\" => sigs = some(*v),\n+                    ~\"crate_type\" => crate_type = some(*v),\n+                    _ => { }\n                 }\n             }\n-            ast::meta_list(v, mis) {\n+            ast::meta_list(v, mis) => {\n                 if *v == ~\"link\" {\n                     let (n, v, u) = load_link(mis);\n                     name = n;\n                     vers = v;\n                     uuid = u;\n                 }\n             }\n-            _ {\n+            _ => {\n                 fail ~\"crate attributes may not contain \" +\n                      ~\"meta_words\";\n             }\n@@ -280,7 +280,7 @@ fn load_crate(filename: ~str) -> option<crate> {\n \n     fn goto_view_item(e: env, i: @ast::view_item) {\n         alt i.node {\n-            ast::view_item_use(ident, metas, id) {\n+            ast::view_item_use(ident, metas, id) => {\n                 let name_items =\n                     attr::find_meta_items_by_name(metas, ~\"name\");\n                 let m = if name_items.is_empty() {\n@@ -294,16 +294,16 @@ fn load_crate(filename: ~str) -> option<crate> {\n \n               for m.each |item| {\n                     alt attr::get_meta_item_value_str(item) {\n-                        some(value) {\n+                        some(value) => {\n                             let name = attr::get_meta_item_name(item);\n \n                             alt *name {\n-                                ~\"vers\" { attr_vers = *value; }\n-                                ~\"from\" { attr_from = *value; }\n-                                _ {}\n+                                ~\"vers\" => attr_vers = *value,\n+                                ~\"from\" => attr_from = *value,\n+                                _ => ()\n                             }\n                         }\n-                        none {}\n+                        none => ()\n                     }\n                 }\n \n@@ -316,11 +316,11 @@ fn load_crate(filename: ~str) -> option<crate> {\n                 };\n \n                 alt *attr_name {\n-                    ~\"std\" | ~\"core\" { }\n-                    _ { vec::push(e.deps, query); }\n+                    ~\"std\" | ~\"core\" => (),\n+                    _ => vec::push(e.deps, query)\n                 }\n             }\n-            _ { }\n+            _ => ()\n         }\n     }\n     fn goto_item(_e: env, _i: @ast::item) {\n@@ -340,7 +340,7 @@ fn load_crate(filename: ~str) -> option<crate> {\n     let deps = copy e.deps;\n \n     alt (name, vers, uuid) {\n-        (some(name0), some(vers0), some(uuid0)) {\n+        (some(name0), some(vers0), some(uuid0)) => {\n             some({\n                 name: name0,\n                 vers: vers0,\n@@ -350,7 +350,7 @@ fn load_crate(filename: ~str) -> option<crate> {\n                 crate_type: crate_type,\n                 deps: deps })\n         }\n-        _ { return none; }\n+        _ => return none\n     }\n }\n \n@@ -391,30 +391,22 @@ fn parse_source(name: ~str, j: json::json) -> source {\n     }\n \n     alt j {\n-        json::dict(j) {\n+        json::dict(j) => {\n             let mut url = alt j.find(~\"url\") {\n-                some(json::string(u)) {\n-                    *u\n-                }\n-                _ { fail ~\"needed 'url' field in source\"; }\n+                some(json::string(u)) => *u,\n+                _ => fail ~\"needed 'url' field in source\"\n             };\n             let method = alt j.find(~\"method\") {\n-                some(json::string(u)) {\n-                    *u\n-                }\n-                _ { assume_source_method(url) }\n+                some(json::string(u)) => *u,\n+                _ => assume_source_method(url)\n             };\n             let key = alt j.find(~\"key\") {\n-                some(json::string(u)) {\n-                    some(*u)\n-                }\n-                _ { none }\n+                some(json::string(u)) => some(*u),\n+                _ => none\n             };\n             let keyfp = alt j.find(~\"keyfp\") {\n-                some(json::string(u)) {\n-                    some(*u)\n-                }\n-                _ { none }\n+                some(json::string(u)) => some(*u),\n+                _ => none\n             };\n             if method == ~\"file\" {\n                 url = os::make_absolute(url);\n@@ -427,28 +419,28 @@ fn parse_source(name: ~str, j: json::json) -> source {\n                 mut keyfp: keyfp,\n                 mut packages: ~[mut] };\n         }\n-        _ { fail ~\"needed dict value in source\"; }\n+        _ => fail ~\"needed dict value in source\"\n     };\n }\n \n fn try_parse_sources(filename: ~str, sources: map::hashmap<~str, source>) {\n     if !os::path_exists(filename)  { return; }\n     let c = io::read_whole_file_str(filename);\n     alt json::from_str(result::get(c)) {\n-        ok(json::dict(j)) {\n+        ok(json::dict(j)) => {\n           for j.each |k, v| {\n                 sources.insert(k, parse_source(k, v));\n                 debug!{\"source: %s\", k};\n             }\n         }\n-        ok(_) { fail ~\"malformed sources.json\"; }\n-        err(e) { fail fmt!{\"%s:%s\", filename, e.to_str()}; }\n+        ok(_) => fail ~\"malformed sources.json\",\n+        err(e) => fail fmt!{\"%s:%s\", filename, e.to_str()}\n     }\n }\n \n fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n     let name = alt p.find(~\"name\") {\n-        some(json::string(n)) {\n+        some(json::string(n)) => {\n             if !valid_pkg_name(*n) {\n                 warn(~\"malformed source json: \"\n                      + src.name + ~\", '\" + *n + ~\"'\"+\n@@ -458,14 +450,14 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n             }\n             *n\n         }\n-        _ {\n+        _ => {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing name)\");\n             return;\n         }\n     };\n \n     let uuid = alt p.find(~\"uuid\") {\n-        some(json::string(n)) {\n+        some(json::string(n)) => {\n             if !is_uuid(*n) {\n                 warn(~\"malformed source json: \"\n                      + src.name + ~\", '\" + *n + ~\"'\"+\n@@ -474,50 +466,50 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n             }\n             *n\n         }\n-        _ {\n+        _ => {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing uuid)\");\n             return;\n         }\n     };\n \n     let url = alt p.find(~\"url\") {\n-        some(json::string(n)) { *n }\n-        _ {\n+        some(json::string(n)) => *n,\n+        _ => {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing url)\");\n             return;\n         }\n     };\n \n     let method = alt p.find(~\"method\") {\n-        some(json::string(n)) { *n }\n-        _ {\n+        some(json::string(n)) => *n,\n+        _ => {\n             warn(~\"malformed source json: \"\n                  + src.name + ~\" (missing method)\");\n             return;\n         }\n     };\n \n     let reference = alt p.find(~\"ref\") {\n-        some(json::string(n)) { some(*n) }\n-        _ { none }\n+        some(json::string(n)) => some(*n),\n+        _ => none\n     };\n \n     let mut tags = ~[];\n     alt p.find(~\"tags\") {\n-        some(json::list(js)) {\n+        some(json::list(js)) => {\n           for (*js).each |j| {\n                 alt j {\n-                    json::string(j) { vec::grow(tags, 1u, *j); }\n-                    _ { }\n+                    json::string(j) => vec::grow(tags, 1u, *j),\n+                    _ => ()\n                 }\n             }\n         }\n-        _ { }\n+        _ => ()\n     }\n \n     let description = alt p.find(~\"description\") {\n-        some(json::string(n)) { *n }\n-        _ {\n+        some(json::string(n)) => *n,\n+        _ => {\n             warn(~\"malformed source json: \" + src.name\n                  + ~\" (missing description)\");\n             return;\n@@ -536,11 +528,11 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n     };\n \n     alt vec::position(src.packages, |pkg| pkg.uuid == uuid) {\n-      some(idx) {\n+      some(idx) => {\n         src.packages[idx] = newpkg;\n         log(debug, ~\"  updated package: \" + src.name + ~\"/\" + name);\n       }\n-      none {\n+      none => {\n         vec::grow(src.packages, 1u, newpkg);\n       }\n     }\n@@ -554,17 +546,17 @@ fn load_source_info(c: cargo, src: source) {\n     if !os::path_exists(srcfile) { return; }\n     let srcstr = io::read_whole_file_str(srcfile);\n     alt json::from_str(result::get(srcstr)) {\n-        ok(json::dict(s)) {\n+        ok(json::dict(s)) => {\n             let o = parse_source(src.name, json::dict(s));\n \n             src.key = o.key;\n             src.keyfp = o.keyfp;\n         }\n-        ok(_) {\n+        ok(_) => {\n             warn(~\"malformed source.json: \" + src.name +\n                  ~\"(source info is not a dict)\");\n         }\n-        err(e) {\n+        err(e) => {\n             warn(fmt!{\"%s:%s\", src.name, e.to_str()});\n         }\n     };\n@@ -576,33 +568,33 @@ fn load_source_packages(c: cargo, src: source) {\n     if !os::path_exists(pkgfile) { return; }\n     let pkgstr = io::read_whole_file_str(pkgfile);\n     alt json::from_str(result::get(pkgstr)) {\n-        ok(json::list(js)) {\n+        ok(json::list(js)) => {\n           for (*js).each |j| {\n                 alt j {\n-                    json::dict(p) {\n+                    json::dict(p) => {\n                         load_one_source_package(src, p);\n                     }\n-                    _ {\n+                    _ => {\n                         warn(~\"malformed source json: \" + src.name +\n                              ~\" (non-dict pkg)\");\n                     }\n                 }\n             }\n         }\n-        ok(_) {\n+        ok(_) => {\n             warn(~\"malformed packages.json: \" + src.name +\n                  ~\"(packages is not a list)\");\n         }\n-        err(e) {\n+        err(e) => {\n             warn(fmt!{\"%s:%s\", src.name, e.to_str()});\n         }\n     };\n }\n \n fn build_cargo_options(argv: ~[~str]) -> options {\n     let matches = alt getopts::getopts(argv, opts()) {\n-        result::ok(m) { m }\n-        result::err(f) {\n+        result::ok(m) => m,\n+        result::err(f) => {\n             fail fmt!{\"%s\", getopts::fail_str(f)};\n         }\n     };\n@@ -632,14 +624,14 @@ fn build_cargo_options(argv: ~[~str]) -> options {\n \n fn configure(opts: options) -> cargo {\n     let home = alt get_cargo_root() {\n-        ok(home) { home }\n-        err(_err) { result::get(get_cargo_sysroot()) }\n+        ok(home) => home,\n+        err(_err) => result::get(get_cargo_sysroot())\n     };\n \n     let get_cargo_dir = alt opts.mode {\n-        system_mode { get_cargo_sysroot }\n-        user_mode { get_cargo_root }\n-        local_mode { get_cargo_root_nearest }\n+        system_mode => get_cargo_sysroot,\n+        user_mode => get_cargo_root,\n+        local_mode => get_cargo_root_nearest\n     };\n \n     let p = result::get(get_cargo_dir());\n@@ -726,17 +718,17 @@ fn run_in_buildpath(what: ~str, path: ~str, subdir: ~str, cf: ~str,\n fn test_one_crate(_c: cargo, path: ~str, cf: ~str) {\n   let buildpath = alt run_in_buildpath(~\"testing\", path, ~\"/test\", cf,\n                                        ~[ ~\"--test\"]) {\n-      none { return; }\n-      some(bp) { bp }\n+      none => return,\n+      some(bp) => bp\n   };\n   run_programs(buildpath);\n }\n \n fn install_one_crate(c: cargo, path: ~str, cf: ~str) {\n     let buildpath = alt run_in_buildpath(~\"installing\", path,\n                                          ~\"/build\", cf, ~[]) {\n-      none { return; }\n-      some(bp) { bp }\n+      none => return,\n+      some(bp) => bp\n     };\n     let newv = os::list_dir_path(buildpath);\n     let exec_suffix = os::exe_suffix();\n@@ -761,13 +753,13 @@ fn install_one_crate(c: cargo, path: ~str, cf: ~str) {\n \n fn rustc_sysroot() -> ~str {\n     alt os::self_exe_path() {\n-        some(path) {\n+        some(path) => {\n             let path = ~[path, ~\"..\", ~\"bin\", ~\"rustc\"];\n             let rustc = path::normalize(path::connect_many(path));\n             debug!{\"  rustc: %s\", rustc};\n             rustc\n         }\n-        none { ~\"rustc\" }\n+        none => ~\"rustc\"\n     }\n }\n \n@@ -788,17 +780,17 @@ fn install_source(c: cargo, path: ~str) {\n \n     for cratefiles.each |cf| {\n         alt load_crate(cf) {\n-            none { again; }\n-            some(crate) {\n+            none => again,\n+            some(crate) => {\n               for crate.deps.each |query| {\n                     // FIXME (#1356): handle cyclic dependencies\n                     // (n.b. #1356 says \"Cyclic dependency is an error\n                     // condition\")\n \n                     let wd_base = c.workdir + path::path_sep();\n                     let wd = alt tempfile::mkdtemp(wd_base, ~\"\") {\n-                        some(wd) { wd }\n-                        none { fail fmt!{\"needed temp dir: %s\", wd_base}; }\n+                        some(wd) => wd,\n+                        none => fail fmt!{\"needed temp dir: %s\", wd_base}\n                     };\n \n                     install_query(c, wd, query);\n@@ -847,18 +839,18 @@ fn install_file(c: cargo, wd: ~str, path: ~str) {\n fn install_package(c: cargo, src: ~str, wd: ~str, pkg: package) {\n     let url = copy pkg.url;\n     let method = alt pkg.method {\n-        ~\"git\" { ~\"git\" }\n-        ~\"file\" { ~\"file\" }\n-        _ { ~\"curl\" }\n+        ~\"git\" => ~\"git\",\n+        ~\"file\" => ~\"file\",\n+        _ => ~\"curl\"\n     };\n \n     info(fmt!{\"installing %s/%s via %s...\", src, pkg.name, method});\n \n     alt method {\n-        ~\"git\" { install_git(c, wd, url, copy pkg.reference); }\n-        ~\"file\" { install_file(c, wd, url); }\n-        ~\"curl\" { install_curl(c, wd, copy url); }\n-        _ {}\n+        ~\"git\" => install_git(c, wd, url, copy pkg.reference),\n+        ~\"file\" => install_file(c, wd, url),\n+        ~\"curl\" => install_curl(c, wd, copy url),\n+        _ => ()\n     }\n }\n \n@@ -922,7 +914,7 @@ fn install_named(c: cargo, wd: ~str, name: ~str) {\n \n fn install_uuid_specific(c: cargo, wd: ~str, src: ~str, uuid: ~str) {\n     alt c.sources.find(src) {\n-      some(s) {\n+      some(s) => {\n         let packages = copy s.packages;\n         if vec::any(packages, |p| {\n             if p.uuid == uuid {\n@@ -931,14 +923,14 @@ fn install_uuid_specific(c: cargo, wd: ~str, src: ~str, uuid: ~str) {\n             } else { false }\n         }) { return; }\n       }\n-      _ { }\n+      _ => ()\n     }\n     error(~\"can't find package: \" + src + ~\"/\" + uuid);\n }\n \n fn install_named_specific(c: cargo, wd: ~str, src: ~str, name: ~str) {\n     alt c.sources.find(src) {\n-        some(s) {\n+        some(s) => {\n           let packages = copy s.packages;\n           if vec::any(packages, |p| {\n                 if p.name == name {\n@@ -947,7 +939,7 @@ fn install_named_specific(c: cargo, wd: ~str, src: ~str, name: ~str) {\n                 } else { false }\n             }) { return; }\n         }\n-        _ { }\n+        _ => ()\n     }\n     error(~\"can't find package: \" + src + ~\"/\" + name);\n }\n@@ -969,7 +961,7 @@ fn cmd_uninstall(c: cargo) {\n     if is_uuid(target) {\n         for os::list_dir(lib).each |file| {\n             alt str::find_str(file, ~\"-\" + target + ~\"-\") {\n-                some(idx) {\n+                some(idx) => {\n                     let full = path::normalize(path::connect(lib, file));\n                     if os::remove_file(full) {\n                         info(~\"uninstalled: '\" + full + ~\"'\");\n@@ -978,15 +970,15 @@ fn cmd_uninstall(c: cargo) {\n                     }\n                     return;\n                 }\n-                none { again; }\n+                none => again\n             }\n         }\n \n         error(~\"can't find package with uuid: \" + target);\n     } else {\n         for os::list_dir(lib).each |file| {\n             alt str::find_str(file, ~\"lib\" + target + ~\"-\") {\n-                some(idx) {\n+                some(idx) => {\n                     let full = path::normalize(path::connect(lib,\n                                file));\n                     if os::remove_file(full) {\n@@ -996,12 +988,12 @@ fn cmd_uninstall(c: cargo) {\n                     }\n                     return;\n                 }\n-                none { again; }\n+                none => again\n             }\n         }\n         for os::list_dir(bin).each |file| {\n             alt str::find_str(file, target) {\n-                some(idx) {\n+                some(idx) => {\n                     let full = path::normalize(path::connect(bin, file));\n                     if os::remove_file(full) {\n                         info(~\"uninstalled: '\" + full + ~\"'\");\n@@ -1010,7 +1002,7 @@ fn cmd_uninstall(c: cargo) {\n                     }\n                     return;\n                 }\n-                none { again; }\n+                none => again\n             }\n         }\n \n@@ -1020,12 +1012,12 @@ fn cmd_uninstall(c: cargo) {\n \n fn install_query(c: cargo, wd: ~str, target: ~str) {\n     alt c.dep_cache.find(target) {\n-        some(inst) {\n+        some(inst) => {\n             if inst {\n                 return;\n             }\n         }\n-        none {}\n+        none => ()\n     }\n \n     c.dep_cache.insert(target, true);\n@@ -1047,7 +1039,7 @@ fn install_query(c: cargo, wd: ~str, target: ~str) {\n         let mut ps = copy target;\n \n         alt str::find_char(ps, '/') {\n-            option::some(idx) {\n+            option::some(idx) => {\n                 let source = str::slice(ps, 0u, idx);\n                 ps = str::slice(ps, idx + 1u, str::len(ps));\n                 if is_uuid(ps) {\n@@ -1056,7 +1048,7 @@ fn install_query(c: cargo, wd: ~str, target: ~str) {\n                     install_named_specific(c, wd, source, ps);\n                 }\n             }\n-            option::none {\n+            option::none => {\n                 if is_uuid(ps) {\n                     install_uuid(c, wd, ps);\n                 } else {\n@@ -1081,8 +1073,8 @@ fn install_query(c: cargo, wd: ~str, target: ~str) {\n fn cmd_install(c: cargo) unsafe {\n     let wd_base = c.workdir + path::path_sep();\n     let wd = alt tempfile::mkdtemp(wd_base, ~\"\") {\n-        some(wd) { wd }\n-        none { fail fmt!{\"needed temp dir: %s\", wd_base}; }\n+        some(wd) => wd,\n+        none => fail fmt!{\"needed temp dir: %s\", wd_base}\n     };\n \n     if vec::len(c.opts.free) == 2u {\n@@ -1138,7 +1130,7 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n     os::copy_file(path::connect(url, ~\"packages.json.sig\"), sigfile);\n \n     alt copy src.key {\n-        some(u) {\n+        some(u) => {\n             let p = run::program_output(~\"curl\",\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n             if p.status != 0 {\n@@ -1147,10 +1139,10 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n             }\n             pgp::add(c.root, keyfile);\n         }\n-        _ { }\n+        _ => ()\n     }\n     alt (src.key, src.keyfp) {\n-        (some(_), some(f)) {\n+        (some(_), some(f)) => {\n             let r = pgp::verify(c.root, pkgfile, sigfile, f);\n \n             if !r {\n@@ -1169,7 +1161,7 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n                 }\n             }\n         }\n-        _ {}\n+        _ => ()\n     }\n \n     copy_warn(pkgfile, destpkgfile);\n@@ -1247,7 +1239,7 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n     let has_src_file = os::path_exists(srcfile);\n \n     alt copy src.key {\n-        some(u) {\n+        some(u) => {\n             let p = run::program_output(~\"curl\",\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n             if p.status != 0 {\n@@ -1257,10 +1249,10 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n             }\n             pgp::add(c.root, keyfile);\n         }\n-        _ { }\n+        _ => ()\n     }\n     alt (src.key, src.keyfp) {\n-        (some(_), some(f)) {\n+        (some(_), some(f)) => {\n             let r = pgp::verify(c.root, pkgfile, sigfile, f);\n \n             if !r {\n@@ -1281,7 +1273,7 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n                 }\n             }\n         }\n-        _ {}\n+        _ => ()\n     }\n \n     os::remove_file(keyfile);\n@@ -1327,7 +1319,7 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n     }\n \n     alt copy src.key {\n-        some(u) {\n+        some(u) => {\n             let p = run::program_output(~\"curl\",\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n             if p.status != 0 {\n@@ -1336,10 +1328,10 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n             }\n             pgp::add(c.root, keyfile);\n         }\n-        _ { }\n+        _ => ()\n     }\n     alt (src.key, src.keyfp) {\n-        (some(_), some(f)) {\n+        (some(_), some(f)) => {\n             if smart {\n                 url = src.url + ~\"/packages.json.sig\";\n             }\n@@ -1383,7 +1375,7 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n                 }\n             }\n         }\n-        _ {}\n+        _ => ()\n     }\n \n     copy_warn(pkgfile, destpkgfile);\n@@ -1412,9 +1404,9 @@ fn sync_one(c: cargo, src: source) {\n     need_dir(dir);\n \n     let result = alt src.method {\n-        ~\"git\" { sync_one_git(c, dir, src) }\n-        ~\"file\" { sync_one_file(c, dir, src) }\n-        _ { sync_one_curl(c, dir, src) }\n+        ~\"git\" => sync_one_git(c, dir, src),\n+        ~\"file\" => sync_one_file(c, dir, src),\n+        _ => sync_one_curl(c, dir, src)\n     };\n \n     if result {\n@@ -1499,10 +1491,10 @@ fn cmd_list(c: cargo) {\n                 error(fmt!{\"'%s' is an invalid source name\", name});\n             } else {\n                 alt c.sources.find(name) {\n-                    some(source) {\n+                    some(source) => {\n                         print_source(source);\n                     }\n-                    none {\n+                    none => {\n                         error(fmt!{\"no such source: %s\", name});\n                     }\n                 }\n@@ -1571,7 +1563,7 @@ fn dump_sources(c: cargo) {\n     }\n \n     alt io::buffered_file_writer(out) {\n-        result::ok(writer) {\n+        result::ok(writer) => {\n             let hash = map::str_hash();\n             let root = json::dict(hash);\n \n@@ -1583,24 +1575,24 @@ fn dump_sources(c: cargo) {\n                 chash.insert(~\"method\", json::string(@v.method));\n \n                 alt copy v.key {\n-                    some(key) {\n+                    some(key) => {\n                         chash.insert(~\"key\", json::string(@key));\n                     }\n-                    _ {}\n+                    _ => ()\n                 }\n                 alt copy v.keyfp {\n-                    some(keyfp) {\n+                    some(keyfp) => {\n                         chash.insert(~\"keyfp\", json::string(@keyfp));\n                     }\n-                    _ {}\n+                    _ => ()\n                 }\n \n                 hash.insert(k, child);\n             }\n \n             writer.write_str(json::to_str(root));\n         }\n-        result::err(e) {\n+        result::err(e) => {\n             error(fmt!{\"could not dump sources: %s\", e});\n         }\n     }\n@@ -1624,14 +1616,14 @@ fn cmd_sources(c: cargo) {\n     let action = c.opts.free[2u];\n \n     alt action {\n-        ~\"clear\" {\n+        ~\"clear\" => {\n           for c.sources.each_key |k| {\n                 c.sources.remove(k);\n             }\n \n             info(~\"cleared sources\");\n         }\n-        ~\"add\" {\n+        ~\"add\" => {\n             if vec::len(c.opts.free) < 5u {\n                 cmd_usage();\n                 return;\n@@ -1646,10 +1638,10 @@ fn cmd_sources(c: cargo) {\n             }\n \n             alt c.sources.find(name) {\n-                some(source) {\n+                some(source) => {\n                     error(fmt!{\"source already exists: %s\", name});\n                 }\n-                none {\n+                none => {\n                     c.sources.insert(name, @{\n                         name: name,\n                         mut url: url,\n@@ -1662,7 +1654,7 @@ fn cmd_sources(c: cargo) {\n                 }\n             }\n         }\n-        ~\"remove\" {\n+        ~\"remove\" => {\n             if vec::len(c.opts.free) < 4u {\n                 cmd_usage();\n                 return;\n@@ -1676,16 +1668,16 @@ fn cmd_sources(c: cargo) {\n             }\n \n             alt c.sources.find(name) {\n-                some(source) {\n+                some(source) => {\n                     c.sources.remove(name);\n                     info(fmt!{\"removed source: %s\", name});\n                 }\n-                none {\n+                none => {\n                     error(fmt!{\"no such source: %s\", name});\n                 }\n             }\n         }\n-        ~\"set-url\" {\n+        ~\"set-url\" => {\n             if vec::len(c.opts.free) < 5u {\n                 cmd_usage();\n                 return;\n@@ -1700,7 +1692,7 @@ fn cmd_sources(c: cargo) {\n             }\n \n             alt c.sources.find(name) {\n-                some(source) {\n+                some(source) => {\n                     let old = copy source.url;\n                     let method = assume_source_method(url);\n \n@@ -1711,12 +1703,12 @@ fn cmd_sources(c: cargo) {\n \n                     info(fmt!{\"changed source url: '%s' to '%s'\", old, url});\n                 }\n-                none {\n+                none => {\n                     error(fmt!{\"no such source: %s\", name});\n                 }\n             }\n         }\n-        ~\"set-method\" {\n+        ~\"set-method\" => {\n             if vec::len(c.opts.free) < 5u {\n                 cmd_usage();\n                 return;\n@@ -1731,26 +1723,26 @@ fn cmd_sources(c: cargo) {\n             }\n \n             alt c.sources.find(name) {\n-                some(source) {\n+                some(source) => {\n                     let old = copy source.method;\n \n                     source.method = alt method {\n-                        ~\"git\" { ~\"git\" }\n-                        ~\"file\" { ~\"file\" }\n-                        _ { ~\"curl\" }\n+                        ~\"git\" => ~\"git\",\n+                        ~\"file\" => ~\"file\",\n+                        _ => ~\"curl\"\n                     };\n \n                     c.sources.insert(name, source);\n \n                     info(fmt!{\"changed source method: '%s' to '%s'\", old,\n                          method});\n                 }\n-                none {\n+                none => {\n                     error(fmt!{\"no such source: %s\", name});\n                 }\n             }\n         }\n-        ~\"rename\" {\n+        ~\"rename\" => {\n             if vec::len(c.opts.free) < 5u {\n                 cmd_usage();\n                 return;\n@@ -1769,17 +1761,17 @@ fn cmd_sources(c: cargo) {\n             }\n \n             alt c.sources.find(name) {\n-                some(source) {\n+                some(source) => {\n                     c.sources.remove(name);\n                     c.sources.insert(newn, source);\n                     info(fmt!{\"renamed source: %s to %s\", name, newn});\n                 }\n-                none {\n+                none => {\n                     error(fmt!{\"no such source: %s\", name});\n                 }\n             }\n         }\n-        _ { cmd_usage(); }\n+        _ => cmd_usage()\n     }\n }\n \n@@ -1883,13 +1875,13 @@ fn main(argv: ~[~str]) {\n     }\n     if o.help {\n         alt o.free[1] {\n-            ~\"init\" { cmd_usage_init(); }\n-            ~\"install\" { cmd_usage_install(); }\n-            ~\"uninstall\" { cmd_usage_uninstall(); }\n-            ~\"list\" { cmd_usage_list(); }\n-            ~\"search\" { cmd_usage_search(); }\n-            ~\"sources\" { cmd_usage_sources(); }\n-            _ { cmd_usage(); }\n+            ~\"init\" => cmd_usage_init(),\n+            ~\"install\" => cmd_usage_install(),\n+            ~\"uninstall\" => cmd_usage_uninstall(),\n+            ~\"list\" => cmd_usage_list(),\n+            ~\"search\" => cmd_usage_search(),\n+            ~\"sources\" => cmd_usage_sources(),\n+            _ => cmd_usage()\n         }\n         return;\n     }\n@@ -1910,13 +1902,13 @@ fn main(argv: ~[~str]) {\n     }\n \n     alt o.free[1] {\n-        ~\"init\" { cmd_init(c); }\n-        ~\"install\" { cmd_install(c); }\n-        ~\"uninstall\" { cmd_uninstall(c); }\n-        ~\"list\" { cmd_list(c); }\n-        ~\"search\" { cmd_search(c); }\n-        ~\"sources\" { cmd_sources(c); }\n-        _ { cmd_usage(); }\n+        ~\"init\" => cmd_init(c),\n+        ~\"install\" => cmd_install(c),\n+        ~\"uninstall\" => cmd_uninstall(c),\n+        ~\"list\" => cmd_list(c),\n+        ~\"search\" => cmd_search(c),\n+        ~\"sources\" => cmd_sources(c),\n+        _ => cmd_usage()\n     }\n \n     dump_cache(c);"}, {"sha": "39c4f0f81d0976e375c4e69b927c562aae975714", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -43,8 +43,8 @@ fn parse_config(args: ~[~str]) -> config {\n     let args_ = vec::tail(args);\n     let matches =\n         alt getopts::getopts(args_, opts) {\n-          ok(m) { m }\n-          err(f) { fail getopts::fail_str(f) }\n+          ok(m) => m,\n+          err(f) => fail getopts::fail_str(f)\n         };\n \n     return {compile_lib_path: getopts::opt_str(matches, ~\"compile-lib-path\"),\n@@ -85,7 +85,7 @@ fn log_config(config: config) {\n }\n \n fn opt_str(maybestr: option<~str>) -> ~str {\n-    alt maybestr { option::some(s) { s } option::none { ~\"(none)\" } }\n+    alt maybestr { option::some(s) => s, option::none => ~\"(none)\" }\n }\n \n fn str_opt(maybestr: ~str) -> option<~str> {\n@@ -94,20 +94,20 @@ fn str_opt(maybestr: ~str) -> option<~str> {\n \n fn str_mode(s: ~str) -> mode {\n     alt s {\n-      ~\"compile-fail\" { mode_compile_fail }\n-      ~\"run-fail\" { mode_run_fail }\n-      ~\"run-pass\" { mode_run_pass }\n-      ~\"pretty\" { mode_pretty }\n-      _ { fail ~\"invalid mode\" }\n+      ~\"compile-fail\" => mode_compile_fail,\n+      ~\"run-fail\" => mode_run_fail,\n+      ~\"run-pass\" => mode_run_pass,\n+      ~\"pretty\" => mode_pretty,\n+      _ => fail ~\"invalid mode\"\n     }\n }\n \n fn mode_str(mode: mode) -> ~str {\n     alt mode {\n-      mode_compile_fail { ~\"compile-fail\" }\n-      mode_run_fail { ~\"run-fail\" }\n-      mode_run_pass { ~\"run-pass\" }\n-      mode_pretty { ~\"pretty\" }\n+      mode_compile_fail => ~\"compile-fail\",\n+      mode_run_fail => ~\"run-fail\",\n+      mode_run_pass => ~\"run-pass\",\n+      mode_pretty => ~\"pretty\"\n     }\n }\n \n@@ -121,14 +121,14 @@ fn run_tests(config: config) {\n fn test_opts(config: config) -> test::test_opts {\n     {filter:\n          alt config.filter {\n-           option::some(s) { option::some(s) }\n-           option::none { option::none }\n+           option::some(s) => option::some(s),\n+           option::none => option::none\n          },\n      run_ignored: config.run_ignored,\n      logfile:\n          alt config.logfile {\n-           option::some(s) { option::some(s) }\n-           option::none { option::none }\n+           option::some(s) => option::some(s),\n+           option::none => option::none\n          }\n     }\n }\n@@ -149,7 +149,10 @@ fn make_tests(config: config) -> ~[test::test_desc] {\n fn is_test(config: config, testfile: ~str) -> bool {\n     // Pretty-printer does not work with .rc files yet\n     let valid_extensions =\n-        alt config.mode { mode_pretty { ~[~\".rs\"] } _ { ~[~\".rc\", ~\".rs\"] } };\n+        alt config.mode {\n+          mode_pretty => ~[~\".rs\"],\n+          _ => ~[~\".rc\", ~\".rs\"]\n+        };\n     let invalid_prefixes = ~[~\".\", ~\"#\", ~\"~\"];\n     let name = path::basename(testfile);\n "}, {"sha": "8a550e94c78a2f064e2752e1d6a37e8b898a2531", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -24,8 +24,8 @@ fn parse_expected(line_num: uint, line: ~str) -> ~[expected_error] unsafe {\n     let error_tag = ~\"//~\";\n     let mut idx;\n     alt str::find_str(line, error_tag) {\n-         option::none { return ~[]; }\n-         option::some(nn) { idx = (nn as uint) + str::len(error_tag); }\n+      option::none => return ~[],\n+      option::some(nn) => { idx = (nn as uint) + str::len(error_tag); }\n     }\n \n     // \"//~^^^ kind msg\" denotes a message expected"}, {"sha": "731e874ddcc77480d3ed9deb0f0a05c4f2d02ee2", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -31,8 +31,8 @@ fn load_props(testfile: ~str) -> test_props {\n     let mut pp_exact = option::none;\n     for iter_header(testfile) |ln| {\n         alt parse_error_pattern(ln) {\n-          option::some(ep) { vec::push(error_patterns, ep) }\n-          option::none { }\n+          option::some(ep) => vec::push(error_patterns, ep),\n+          option::none => ()\n         };\n \n         if option::is_none(compile_flags) {\n@@ -108,17 +108,17 @@ fn parse_exec_env(line: ~str) -> option<(~str, ~str)> {\n         // nv is either FOO or FOO=BAR\n         let strs = str::splitn_char(nv, '=', 1u);\n         alt strs.len() {\n-          1u { (strs[0], ~\"\") }\n-          2u { (strs[0], strs[1]) }\n-          n { fail fmt!{\"Expected 1 or 2 strings, not %u\", n}; }\n+          1u => (strs[0], ~\"\"),\n+          2u => (strs[0], strs[1]),\n+          n => fail fmt!{\"Expected 1 or 2 strings, not %u\", n}\n         }\n     }\n }\n \n fn parse_pp_exact(line: ~str, testfile: ~str) -> option<~str> {\n     alt parse_name_value_directive(line, ~\"pp-exact\") {\n-      option::some(s) { option::some(s) }\n-      option::none {\n+      option::some(s) => option::some(s),\n+      option::none => {\n         if parse_name_directive(line, ~\"pp-exact\") {\n             option::some(path::basename(testfile))\n         } else {\n@@ -136,12 +136,12 @@ fn parse_name_value_directive(line: ~str,\n                               directive: ~str) -> option<~str> unsafe {\n     let keycolon = directive + ~\":\";\n     alt str::find_str(line, keycolon) {\n-        option::some(colon) {\n+        option::some(colon) => {\n             let value = str::slice(line, colon + str::len(keycolon),\n                                    str::len(line));\n             debug!{\"%s: %s\", directive,  value};\n             option::some(value)\n         }\n-        option::none { option::none }\n+        option::none => option::none\n     }\n }"}, {"sha": "bb9080becffe65527bdd83ce7aac9731f8b094e1", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -75,10 +75,10 @@ fn run(lib_path: ~str,\n     while count > 0 {\n         let stream = comm::recv(p);\n         alt check stream {\n-            (1, s) {\n+            (1, s) => {\n                 outs = s;\n             }\n-            (2, s) {\n+            (2, s) => {\n                 errs = s;\n             }\n         };"}, {"sha": "79b7e6f08d461cc9709132bad37f019916de6ca1", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -19,10 +19,10 @@ fn run(config: config, testfile: ~str) {\n     debug!{\"running %s\", testfile};\n     let props = load_props(testfile);\n     alt config.mode {\n-      mode_compile_fail { run_cfail_test(config, props, testfile); }\n-      mode_run_fail { run_rfail_test(config, props, testfile); }\n-      mode_run_pass { run_rpass_test(config, props, testfile); }\n-      mode_pretty { run_pretty_test(config, props, testfile); }\n+      mode_compile_fail => run_cfail_test(config, props, testfile),\n+      mode_run_fail => run_rfail_test(config, props, testfile),\n+      mode_run_pass => run_rpass_test(config, props, testfile),\n+      mode_pretty => run_pretty_test(config, props, testfile)\n     }\n }\n \n@@ -90,7 +90,7 @@ fn run_pretty_test(config: config, props: test_props, testfile: ~str) {\n     } else { logv(config, ~\"testing for converging pretty-printing\"); }\n \n     let rounds =\n-        alt props.pp_exact { option::some(_) { 1 } option::none { 2 } };\n+        alt props.pp_exact { option::some(_) => 1, option::none => 2 };\n \n     let mut srcs = ~[result::get(io::read_whole_file_str(testfile))];\n \n@@ -110,11 +110,11 @@ fn run_pretty_test(config: config, props: test_props, testfile: ~str) {\n \n     let mut expected =\n         alt props.pp_exact {\n-          option::some(file) {\n+          option::some(file) => {\n             let filepath = path::connect(path::dirname(testfile), file);\n             result::get(io::read_whole_file_str(filepath))\n           }\n-          option::none { srcs[vec::len(srcs) - 2u] }\n+          option::none => { srcs[vec::len(srcs) - 2u] }\n         };\n     let mut actual = srcs[vec::len(srcs) - 1u];\n \n@@ -384,8 +384,8 @@ fn make_run_args(config: config, _props: test_props, testfile: ~str) ->\n             // then split apart its command\n             let runtool =\n                 alt config.runtool {\n-                  option::some(s) { option::some(s) }\n-                  option::none { option::none }\n+                  option::some(s) => option::some(s),\n+                  option::none => option::none\n                 };\n             split_maybe_args(runtool)\n         };\n@@ -403,8 +403,8 @@ fn split_maybe_args(argstr: option<~str>) -> ~[~str] {\n     }\n \n     alt argstr {\n-      option::some(s) { rm_whitespace(str::split_char(s, ' ')) }\n-      option::none { ~[] }\n+      option::some(s) => rm_whitespace(str::split_char(s, ' ')),\n+      option::none => ~[]\n     }\n }\n "}, {"sha": "027d247ebb8f8b019e36688ef49fb8cbbe246e7d", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -8,10 +8,10 @@ fn make_new_path(path: ~str) -> ~str {\n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n     alt getenv(lib_path_env_var()) {\n-      option::some(curr) {\n+      option::some(curr) => {\n         fmt!{\"%s%s%s\", path, path_div(), curr}\n       }\n-      option::none { path }\n+      option::none => path\n     }\n }\n "}, {"sha": "1cc0c08eb5c9b00e3803bd5b7b6dd94100025584", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -63,39 +63,39 @@ pure fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n \n pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n     alt tm {\n-      tm_converge {\n+      tm_converge => {\n         alt e.node {\n           // If the fuzzer moves a block-ending-in-semicolon into callee\n           // position, the pretty-printer can't preserve this even by\n           // parenthesizing!!  See email to marijn.\n-          ast::expr_if(_, _, _) { false }\n-          ast::expr_block(_) { false }\n-          ast::expr_alt(_, _, _) { false }\n-          ast::expr_while(_, _) { false }\n+          ast::expr_if(_, _, _) => { false }\n+          ast::expr_block(_) => { false }\n+          ast::expr_alt(_, _, _) => { false }\n+          ast::expr_while(_, _) => { false }\n \n           // https://github.com/mozilla/rust/issues/929\n-          ast::expr_cast(_, _) { false }\n-          ast::expr_assert(_) { false }\n-          ast::expr_binary(_, _, _) { false }\n-          ast::expr_assign(_, _) { false }\n-          ast::expr_assign_op(_, _, _) { false }\n+          ast::expr_cast(_, _) => { false }\n+          ast::expr_assert(_) => { false }\n+          ast::expr_binary(_, _, _) => { false }\n+          ast::expr_assign(_, _) => { false }\n+          ast::expr_assign_op(_, _, _) => { false }\n \n-          ast::expr_fail(option::none) { false }\n-          ast::expr_ret(option::none) { false }\n+          ast::expr_fail(option::none) => { false }\n+          ast::expr_ret(option::none) => { false }\n \n           // https://github.com/mozilla/rust/issues/953\n-          ast::expr_fail(option::some(_)) { false }\n+          ast::expr_fail(option::some(_)) => { false }\n \n           // https://github.com/mozilla/rust/issues/928\n           //ast::expr_cast(_, _) { false }\n \n           // https://github.com/mozilla/rust/issues/1458\n-          ast::expr_call(_, _, _) { false }\n+          ast::expr_call(_, _, _) => { false }\n \n-          _ { true }\n+          _ => { true }\n         }\n       }\n-      tm_run { true }\n+      tm_run => { true }\n     }\n }\n \n@@ -141,23 +141,23 @@ fn steal(crate: ast::crate, tm: test_mode) -> stolen_stuff {\n fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n     alt e {\n       // https://github.com/mozilla/rust/issues/652\n-      ast::expr_if(*) { false }\n-      ast::expr_block(_) { false }\n+      ast::expr_if(*) => { false }\n+      ast::expr_block(_) => { false }\n \n       // expr_call is also missing a constraint\n-      ast::expr_fn_block(*) { false }\n+      ast::expr_fn_block(*) => { false }\n \n-      _ { true }\n+      _ => { true }\n     }\n }\n \n fn safe_to_replace_ty(t: ast::ty_, _tm: test_mode) -> bool {\n     alt t {\n-      ast::ty_infer { false } // always implicit, always top level\n-      ast::ty_bot { false }   // in source, can only appear\n+      ast::ty_infer => { false } // always implicit, always top level\n+      ast::ty_bot => { false }   // in source, can only appear\n                               // as the out type of a function\n-      ast::ty_mac(_) { false }\n-      _ { true }\n+      ast::ty_mac(_) => { false }\n+      _ => { true }\n     }\n }\n \n@@ -273,10 +273,10 @@ fn check_variants_T<T: copy>(\n                         pprust::no_ann(),\n                         false));\n                 alt cx.mode {\n-                  tm_converge {\n+                  tm_converge => {\n                     check_roundtrip_convergence(str3, 1u);\n                   }\n-                  tm_run {\n+                  tm_run => {\n                     let file_label = fmt!{\"rusttmp/%s_%s_%u_%u\",\n                                           last_part(filename),\n                                           thing_label, i, j};\n@@ -315,17 +315,17 @@ fn check_whole_compiler(code: ~str, suggested_filename_prefix: ~str,\n     let compile_result = check_compiling(filename);\n \n     let run_result = alt (compile_result, allow_running) {\n-      (passed, true) { check_running(suggested_filename_prefix) }\n-      (h, _) { h }\n+      (passed, true) => { check_running(suggested_filename_prefix) }\n+      (h, _) => { h }\n     };\n \n     alt run_result {\n-      passed | cleanly_rejected(_) | known_bug(_) {\n+      passed | cleanly_rejected(_) | known_bug(_) => {\n         removeIfExists(suggested_filename_prefix);\n         removeIfExists(suggested_filename_prefix + ~\".rs\");\n         removeDirIfExists(suggested_filename_prefix + ~\".dSYM\");\n       }\n-      failed(s) {\n+      failed(s) => {\n         log(error, ~\"check_whole_compiler failure: \" + s);\n         log(error, ~\"Saved as: \" + filename);\n       }\n@@ -365,17 +365,17 @@ fn check_running(exe_filename: ~str) -> happiness {\n         failed(~\"Mentioned malloc\")\n     } else {\n         alt p.status {\n-            0         { passed }\n-            100       { cleanly_rejected(~\"running: explicit fail\") }\n-            101 | 247 { cleanly_rejected(~\"running: timed out\") }\n-            245 | 246 | 138 | 252 {\n+            0         => { passed }\n+            100       => { cleanly_rejected(~\"running: explicit fail\") }\n+            101 | 247 => { cleanly_rejected(~\"running: timed out\") }\n+            245 | 246 | 138 | 252 => {\n               known_bug(~\"https://github.com/mozilla/rust/issues/1466\")\n             }\n-            136 | 248 {\n+            136 | 248 => {\n               known_bug(\n                   ~\"SIGFPE - https://github.com/mozilla/rust/issues/944\")\n             }\n-            rc {\n+            rc => {\n               failed(~\"Rust program ran but exited with status \" +\n                      int::str(rc))\n             }\n@@ -442,8 +442,8 @@ fn has_raw_pointers(c: ast::crate) -> bool {\n     let has_rp = @mut false;\n     fn visit_ty(flag: @mut bool, t: @ast::ty) {\n         alt t.node {\n-          ast::ty_ptr(_) { *flag = true; }\n-          _ { }\n+          ast::ty_ptr(_) => { *flag = true; }\n+          _ => { }\n         }\n     }\n     let v ="}, {"sha": "91b268bc70371a2c2bab1803aa912ea2794275f1", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -40,9 +40,9 @@ pure fn is_false(v: bool) -> bool { !v }\n /// Parse logic value from `s`\n pure fn from_str(s: ~str) -> option<bool> {\n     alt check s {\n-      ~\"true\" { some(true) }\n-      ~\"false\" { some(false) }\n-      _ { none }\n+      ~\"true\" => some(true),\n+      ~\"false\" => some(false),\n+      _ => none\n     }\n }\n "}, {"sha": "97a484b491f7ccf3cbc8b774a81f40370ab47472", "filename": "src/libcore/char.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -114,10 +114,10 @@ pure fn is_digit(c: char) -> bool {\n  */\n pure fn to_digit(c: char, radix: uint) -> option<uint> {\n     let val = alt c {\n-      '0' to '9' { c as uint - ('0' as uint) }\n-      'a' to 'z' { c as uint + 10u - ('a' as uint) }\n-      'A' to 'Z' { c as uint + 10u - ('A' as uint) }\n-      _ { return none; }\n+      '0' to '9' => c as uint - ('0' as uint),\n+      'a' to 'z' => c as uint + 10u - ('a' as uint),\n+      'A' to 'Z' => c as uint + 10u - ('A' as uint),\n+      _ => return none\n     };\n     if val < radix { some(val) }\n     else { none }\n@@ -159,14 +159,14 @@ fn escape_unicode(c: char) -> ~str {\n  */\n fn escape_default(c: char) -> ~str {\n     alt c {\n-      '\\t' { ~\"\\\\t\" }\n-      '\\r' { ~\"\\\\r\" }\n-      '\\n' { ~\"\\\\n\" }\n-      '\\\\' { ~\"\\\\\\\\\" }\n-      '\\'' { ~\"\\\\'\" }\n-      '\"' { ~\"\\\\\\\"\" }\n-      '\\x20' to '\\x7e' { str::from_char(c) }\n-      _ { escape_unicode(c) }\n+      '\\t' => ~\"\\\\t\",\n+      '\\r' => ~\"\\\\r\",\n+      '\\n' => ~\"\\\\n\",\n+      '\\\\' => ~\"\\\\\\\\\",\n+      '\\'' => ~\"\\\\'\",\n+      '\"'  => ~\"\\\\\\\"\",\n+      '\\x20' to '\\x7e' => str::from_char(c),\n+      _ => escape_unicode(c)\n     }\n }\n "}, {"sha": "86bcfad89ddae59d902e9ec5e66aac9521b8bbb6", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -410,8 +410,8 @@ fn test_select2_stress() {\n     let mut bs = 0;\n     for iter::repeat(msgs * times * 2u) {\n         alt check select2(po_a, po_b) {\n-          either::left(~\"a\") { as += 1 }\n-          either::right(~\"b\") { bs += 1 }\n+          either::left(~\"a\") => as += 1,\n+          either::right(~\"b\") => bs += 1\n         }\n     }\n "}, {"sha": "7b9d4432e5447604249f9d7df7451038d59f12fd", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -27,30 +27,22 @@ enum dlist<T> = @{\n impl private_methods<T> for dlist_node<T> {\n     pure fn assert_links() {\n         alt self.next {\n-            some(neighbour) {\n-                alt neighbour.prev {\n-                    some(me) {\n-                        if !box::ptr_eq(*self, *me) {\n-                            fail ~\"Asymmetric next-link in dlist node.\"\n-                        }\n-                    }\n-                    none { fail ~\"One-way next-link in dlist node.\" }\n-                }\n+            some(neighbour) => alt neighbour.prev {\n+              some(me) => if !box::ptr_eq(*self, *me) {\n+                  fail ~\"Asymmetric next-link in dlist node.\"\n+              }\n+              none => fail ~\"One-way next-link in dlist node.\"\n             }\n-            none { }\n+            none => ()\n         }\n         alt self.prev {\n-            some(neighbour) {\n-                alt neighbour.next {\n-                    some(me) {\n-                        if !box::ptr_eq(*me, *self) {\n-                            fail ~\"Asymmetric prev-link in dlist node.\"\n-                        }\n-                    }\n-                    none { fail ~\"One-way prev-link in dlist node.\" }\n-                }\n+            some(neighbour) => alt neighbour.next {\n+              some(me) => if !box::ptr_eq(*me, *self) {\n+                  fail ~\"Asymmetric prev-link in dlist node.\"\n+              }\n+              none => fail ~\"One-way prev-link in dlist node.\"\n             }\n-            none { }\n+            none => ()\n         }\n     }\n }\n@@ -64,8 +56,8 @@ impl extensions<T> for dlist_node<T> {\n     /// Get the next node in the list, failing if there isn't one.\n     pure fn next_node() -> dlist_node<T> {\n         alt self.next_link() {\n-            some(nobe) { nobe }\n-            none       { fail ~\"This dlist node has no next neighbour.\" }\n+            some(nobe) => nobe,\n+            none       => fail ~\"This dlist node has no next neighbour.\"\n         }\n     }\n     /// Get the previous node in the list, if there is one.\n@@ -76,8 +68,8 @@ impl extensions<T> for dlist_node<T> {\n     /// Get the previous node in the list, failing if there isn't one.\n     pure fn prev_node() -> dlist_node<T> {\n         alt self.prev_link() {\n-            some(nobe) { nobe }\n-            none       { fail ~\"This dlist node has no previous neighbour.\" }\n+            some(nobe) => nobe,\n+            none       => fail ~\"This dlist node has no previous neighbour.\"\n         }\n     }\n }\n@@ -147,12 +139,12 @@ impl private_methods<T> for dlist<T> {\n     #[inline(always)]\n     fn link(+before: dlist_link<T>, +after: dlist_link<T>) {\n         alt before {\n-            some(neighbour) { neighbour.next = after; }\n-            none            { self.hd        = after; }\n+            some(neighbour) => neighbour.next = after,\n+            none            => self.hd        = after\n         }\n         alt after {\n-            some(neighbour) { neighbour.prev = before; }\n-            none            { self.tl        = before; }\n+            some(neighbour) => neighbour.prev = before,\n+            none            => self.tl        = before\n         }\n     }\n     // Remove a node from the list.\n@@ -295,19 +287,15 @@ impl extensions<T> for dlist<T> {\n     /// Get the node at the list's head, failing if empty. O(1).\n     pure fn head_n() -> dlist_node<T> {\n         alt self.hd {\n-            some(nobe) { nobe }\n-            none       {\n-              fail ~\"Attempted to get the head of an empty dlist.\"\n-            }\n+            some(nobe) => nobe,\n+            none       => fail ~\"Attempted to get the head of an empty dlist.\"\n         }\n     }\n     /// Get the node at the list's tail, failing if empty. O(1).\n     pure fn tail_n() -> dlist_node<T> {\n         alt self.tl {\n-            some(nobe) { nobe }\n-            none       {\n-              fail ~\"Attempted to get the tail of an empty dlist.\"\n-            }\n+            some(nobe) => nobe,\n+            none       => fail ~\"Attempted to get the tail of an empty dlist.\"\n         }\n     }\n "}, {"sha": "d07b126bb5d646e3c071cccd4a0a4a65f3e342e4", "filename": "src/libcore/either.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -18,15 +18,21 @@ fn either<T, U, V>(f_left: fn(T) -> V,\n      * result is returned.\n      */\n \n-    alt value { left(l) { f_left(l) } right(r) { f_right(r) } }\n+    alt value {\n+      left(l) => f_left(l),\n+      right(r) => f_right(r)\n+    }\n }\n \n fn lefts<T: copy, U>(eithers: ~[either<T, U>]) -> ~[T] {\n     //! Extracts from a vector of either all the left values\n \n     let mut result: ~[T] = ~[];\n     for vec::each(eithers) |elt| {\n-        alt elt { left(l) { vec::push(result, l); } _ {/* fallthrough */ } }\n+        alt elt {\n+          left(l) => vec::push(result, l),\n+          _ => { /* fallthrough */ }\n+        }\n     }\n     return result;\n }\n@@ -36,7 +42,10 @@ fn rights<T, U: copy>(eithers: ~[either<T, U>]) -> ~[U] {\n \n     let mut result: ~[U] = ~[];\n     for vec::each(eithers) |elt| {\n-        alt elt { right(r) { vec::push(result, r); } _ {/* fallthrough */ } }\n+        alt elt {\n+          right(r) => vec::push(result, r),\n+          _ => { /* fallthrough */ }\n+        }\n     }\n     return result;\n }\n@@ -54,8 +63,8 @@ fn partition<T: copy, U: copy>(eithers: ~[either<T, U>])\n     let mut rights: ~[U] = ~[];\n     for vec::each(eithers) |elt| {\n         alt elt {\n-          left(l) { vec::push(lefts, l); }\n-          right(r) { vec::push(rights, r); }\n+          left(l) => vec::push(lefts, l),\n+          right(r) => vec::push(rights, r)\n         }\n     }\n     return {lefts: lefts, rights: rights};\n@@ -65,8 +74,8 @@ pure fn flip<T: copy, U: copy>(eith: either<T, U>) -> either<U, T> {\n     //! Flips between left and right of a given either\n \n     alt eith {\n-      right(r) { left(r) }\n-      left(l) { right(l) }\n+      right(r) => left(r),\n+      left(l) => right(l)\n     }\n }\n \n@@ -80,21 +89,21 @@ pure fn to_result<T: copy, U: copy>(\n      */\n \n     alt eith {\n-      right(r) { result::ok(r) }\n-      left(l) { result::err(l) }\n+      right(r) => result::ok(r),\n+      left(l) => result::err(l)\n     }\n }\n \n pure fn is_left<T, U>(eith: either<T, U>) -> bool {\n     //! Checks whether the given value is a left\n \n-    alt eith { left(_) { true } _ { false } }\n+    alt eith { left(_) => true, _ => false }\n }\n \n pure fn is_right<T, U>(eith: either<T, U>) -> bool {\n     //! Checks whether the given value is a right\n \n-    alt eith { right(_) { true } _ { false } }\n+    alt eith { right(_) => true, _ => false }\n }\n \n #[test]"}, {"sha": "251bc2d18e19d69f7fa8f35278e66e053c269710", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -123,8 +123,8 @@ mod ct {\n         if !('0' as u8 <= c && c <= '9' as u8) { return option::none; }\n         let n = (c - ('0' as u8)) as uint;\n         return alt peek_num(s, i + 1u, lim) {\n-              none { some({num: n, next: i + 1u}) }\n-              some(next) {\n+              none => some({num: n, next: i + 1u}),\n+              some(next) => {\n                 let m = next.num;\n                 let j = next.next;\n                 some({num: n * 10u + m, next: j})\n@@ -151,8 +151,8 @@ mod ct {\n         if i >= lim { return {param: none, next: i}; }\n         let num = peek_num(s, i, lim);\n         return alt num {\n-              none { {param: none, next: i} }\n-              some(t) {\n+              none => {param: none, next: i},\n+              some(t) => {\n                 let n = t.num;\n                 let j = t.next;\n                 if j < lim && s[j] == '$' as u8 {\n@@ -196,15 +196,16 @@ mod ct {\n                 let param = parse_parameter(s, i + 1u, lim);\n                 let j = param.next;\n                 alt param.param {\n-                  none { {count: count_is_next_param, next: j} }\n-                  some(n) { {count: count_is_param(n), next: j} }\n+                  none => {count: count_is_next_param, next: j},\n+                  some(n) => {count: count_is_param(n), next: j}\n                 }\n             } else {\n                 let num = peek_num(s, i, lim);\n                 alt num {\n-                  none { {count: count_implied, next: i} }\n-                  some(num) {\n-                    {count: count_is(num.num as int), next: num.next}\n+                  none => {count: count_implied, next: i},\n+                  some(num) => {\n+                    count: count_is(num.num as int),\n+                    next: num.next\n                   }\n                 }\n             };\n@@ -220,8 +221,8 @@ mod ct {\n                 // If there were no digits specified, i.e. the precision\n                 // was \".\", then the precision is 0\n                 alt count.count {\n-                  count_implied { {count: count_is(0), next: count.next} }\n-                  _ { count }\n+                  count_implied => {count: count_is(0), next: count.next},\n+                  _ => count\n                 }\n             } else { {count: count_implied, next: i} };\n     }\n@@ -294,11 +295,11 @@ mod rt {\n         let prec = get_int_precision(cv);\n         let mut rs =\n             alt cv.ty {\n-              ty_default { uint_to_str_prec(u, 10u, prec) }\n-              ty_hex_lower { uint_to_str_prec(u, 16u, prec) }\n-              ty_hex_upper { str::to_upper(uint_to_str_prec(u, 16u, prec)) }\n-              ty_bits { uint_to_str_prec(u, 2u, prec) }\n-              ty_octal { uint_to_str_prec(u, 8u, prec) }\n+              ty_default => uint_to_str_prec(u, 10u, prec),\n+              ty_hex_lower => uint_to_str_prec(u, 16u, prec),\n+              ty_hex_upper => str::to_upper(uint_to_str_prec(u, 16u, prec)),\n+              ty_bits => uint_to_str_prec(u, 2u, prec),\n+              ty_octal => uint_to_str_prec(u, 8u, prec)\n             };\n         return unchecked { pad(cv, rs, pad_unsigned) };\n     }\n@@ -316,19 +317,19 @@ mod rt {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = alt cv.precision {\n-          count_implied { s.to_unique() }\n-          count_is(max) {\n-            if max as uint < str::char_len(s) {\n-                str::substr(s, 0u, max as uint)\n-            } else { s.to_unique() }\n+          count_implied => s.to_unique(),\n+          count_is(max) => if max as uint < str::char_len(s) {\n+            str::substr(s, 0u, max as uint)\n+          } else {\n+            s.to_unique()\n           }\n         };\n         return unchecked { pad(cv, unpadded, pad_nozero) };\n     }\n     pure fn conv_float(cv: conv, f: float) -> ~str {\n         let (to_str, digits) = alt cv.precision {\n-              count_is(c) { (float::to_str_exact, c as uint) }\n-              count_implied { (float::to_str, 6u) }\n+              count_is(c) => (float::to_str_exact, c as uint),\n+              count_implied => (float::to_str, 6u)\n         };\n         let mut s = unchecked { to_str(f, digits) };\n         if 0.0 <= f {\n@@ -371,15 +372,15 @@ mod rt {\n     }\n     pure fn get_int_precision(cv: conv) -> uint {\n         return alt cv.precision {\n-              count_is(c) { c as uint }\n-              count_implied { 1u }\n+              count_is(c) => c as uint,\n+              count_implied => 1u\n             };\n     }\n     enum pad_mode { pad_signed, pad_unsigned, pad_nozero, pad_float }\n     fn pad(cv: conv, &s: ~str, mode: pad_mode) -> ~str {\n         let uwidth : uint = alt cv.width {\n-          count_implied { return s; }\n-          count_is(width) {\n+          count_implied => return s,\n+          count_is(width) => {\n               // FIXME: width should probably be uint (see Issue #1996)\n               width as uint\n           }\n@@ -393,13 +394,13 @@ mod rt {\n             return s + padstr;\n         }\n         let {might_zero_pad, signed} = alt mode {\n-          pad_nozero {   {might_zero_pad:false, signed:false} }\n-          pad_signed {   {might_zero_pad:true,  signed:true } }\n-          pad_float {   {might_zero_pad:true,  signed:true } }\n-          pad_unsigned { {might_zero_pad:true,  signed:false} }\n+          pad_nozero => {might_zero_pad:false, signed:false},\n+          pad_signed => {might_zero_pad:true,  signed:true },\n+          pad_float => {might_zero_pad:true,  signed:true},\n+          pad_unsigned => {might_zero_pad:true,  signed:false}\n         };\n         pure fn have_precision(cv: conv) -> bool {\n-            return alt cv.precision { count_implied { false } _ { true } };\n+            return alt cv.precision { count_implied => false, _ => true };\n         }\n         let zero_padding = {\n             if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&"}, {"sha": "02133205be9178289096da996d992d77c8c93a4c", "filename": "src/libcore/float.rs", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -257,21 +257,21 @@ fn from_str(num: ~str) -> option<float> {\n \n    //The string must start with one of the following characters.\n    alt str::char_at(num, 0u) {\n-      '-' | '+' | '0' to '9' | '.' {}\n-      _ { return none; }\n+      '-' | '+' | '0' to '9' | '.' => (),\n+      _ => return none\n    }\n \n    //Determine if first char is '-'/'+'. Set [pos] and [neg] accordingly.\n    let mut neg = false;               //Sign of the result\n    alt str::char_at(num, 0u) {\n-      '-' {\n+      '-' => {\n           neg = true;\n           pos = 1u;\n       }\n-      '+' {\n+      '+' => {\n           pos = 1u;\n       }\n-      _ {}\n+      _ => ()\n    }\n \n    //Examine the following chars until '.', 'e', 'E'\n@@ -280,16 +280,12 @@ fn from_str(num: ~str) -> option<float> {\n        c   = char_range.ch;\n        pos = char_range.next;\n        alt c {\n-         '0' to '9' {\n+         '0' to '9' => {\n            total = total * 10f;\n            total += ((c as int) - ('0' as int)) as float;\n          }\n-         '.' | 'e' | 'E' {\n-           break;\n-         }\n-         _ {\n-           return none;\n-         }\n+         '.' | 'e' | 'E' => break,\n+         _ => return none\n        }\n    }\n \n@@ -300,16 +296,12 @@ fn from_str(num: ~str) -> option<float> {\n          c = char_range.ch;\n          pos = char_range.next;\n          alt c {\n-            '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9'  {\n+            '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9'  => {\n                  decimal /= 10f;\n                  total += (((c as int) - ('0' as int)) as float)*decimal;\n              }\n-             'e' | 'E' {\n-                 break;\n-             }\n-             _ {\n-                 return none;\n-             }\n+             'e' | 'E' => break,\n+             _ => return none\n          }\n       }\n    }\n@@ -321,26 +313,24 @@ fn from_str(num: ~str) -> option<float> {\n           let char_range = str::char_range_at(num, pos);\n           c   = char_range.ch;\n           alt c  {\n-             '+' {\n+             '+' => {\n                 pos = char_range.next;\n              }\n-             '-' {\n+             '-' => {\n                 pos = char_range.next;\n                 neg_exponent = true;\n              }\n-             _ {}\n+             _ => ()\n           }\n           while(pos < len) {\n              let char_range = str::char_range_at(num, pos);\n              c = char_range.ch;\n              alt c {\n-                 '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9' {\n+                 '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9' => {\n                      exponent *= 10u;\n                      exponent += ((c as uint) - ('0' as uint));\n                  }\n-                 _ {\n-                     break;\n-                 }\n+                 _ => break\n              }\n              pos = char_range.next;\n           }\n@@ -458,8 +448,8 @@ fn test_from_str() {\n    assert from_str(~\"-inf\") == some(neg_infinity);\n    // note: NaN != NaN, hence this slightly complex test\n    alt from_str(~\"NaN\") {\n-       some(f) { assert is_NaN(f); }\n-       none { fail; }\n+       some(f) => assert is_NaN(f),\n+       none => fail\n    }\n \n    assert from_str(~\"\") == none;"}, {"sha": "1f6b259c46702e012f998287f30e5f2a36aebdac", "filename": "src/libcore/future.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -78,7 +78,7 @@ fn from_port<A:send>(-port: future_pipe::client::waiting<A>) -> future<A> {\n         port_ <-> *port;\n         let port = option::unwrap(port_);\n         alt recv(port) {\n-          future_pipe::completed(data) { move_it!{data} }\n+          future_pipe::completed(data) => move_it!{data}\n         }\n     }\n }\n@@ -120,8 +120,8 @@ fn with<A,B>(future: future<A>, blk: fn(A) -> B) -> B {\n     //! Work with the value without copying it\n \n     let v = alt copy future.v {\n-      either::left(v) { v }\n-      either::right(f) {\n+      either::left(v) => v,\n+      either::right(f) => {\n         let v = @f();\n         future.v = either::left(v);\n         v"}, {"sha": "02ef14c5366771f96c42a50e5297866254459371", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -145,8 +145,8 @@ fn parse_buf(buf: ~[u8], radix: uint) -> option<T> {\n     let mut n = 0 as T;\n     loop {\n         alt char::to_digit(buf[i] as char, radix) {\n-          some(d) { n += (d as T) * power; }\n-          none { return none; }\n+          some(d) => n += (d as T) * power,\n+          none => return none\n         }\n         power *= radix as T;\n         if i <= start { return some(n); }"}, {"sha": "cf2c51625d86829c73bf681d999a9fb684e892ee", "filename": "src/libcore/io.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -197,9 +197,9 @@ impl reader_util for reader {\n \n fn convert_whence(whence: seek_style) -> i32 {\n     return alt whence {\n-      seek_set { 0i32 }\n-      seek_cur { 1i32 }\n-      seek_end { 2i32 }\n+      seek_set => 0i32,\n+      seek_cur => 1i32,\n+      seek_end => 2i32\n     };\n }\n \n@@ -441,10 +441,10 @@ fn mk_file_writer(path: ~str, flags: ~[fileflag])\n     let mut fflags: c_int = wb();\n     for vec::each(flags) |f| {\n         alt f {\n-          append { fflags |= O_APPEND as c_int; }\n-          create { fflags |= O_CREAT as c_int; }\n-          truncate { fflags |= O_TRUNC as c_int; }\n-          no_flag { }\n+          append => fflags |= O_APPEND as c_int,\n+          create => fflags |= O_CREAT as c_int,\n+          truncate => fflags |= O_TRUNC as c_int,\n+          no_flag => ()\n         }\n     }\n     let fd = do os::as_c_charp(path) |pathbuf| {\n@@ -461,22 +461,22 @@ fn mk_file_writer(path: ~str, flags: ~[fileflag])\n fn u64_to_le_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n     assert size <= 8u;\n     alt size {\n-      1u { f(&[n as u8]) }\n-      2u { f(&[n as u8,\n-              (n >> 8) as u8]) }\n-      4u { f(&[n as u8,\n+      1u => f(&[n as u8]),\n+      2u => f(&[n as u8,\n+              (n >> 8) as u8]),\n+      4u => f(&[n as u8,\n               (n >> 8) as u8,\n               (n >> 16) as u8,\n-              (n >> 24) as u8]) }\n-      8u { f(&[n as u8,\n+              (n >> 24) as u8]),\n+      8u => f(&[n as u8,\n               (n >> 8) as u8,\n               (n >> 16) as u8,\n               (n >> 24) as u8,\n               (n >> 32) as u8,\n               (n >> 40) as u8,\n               (n >> 48) as u8,\n-              (n >> 56) as u8]) }\n-      _ {\n+              (n >> 56) as u8]),\n+      _ => {\n \n         let mut bytes: ~[u8] = ~[], i = size, n = n;\n         while i > 0u {\n@@ -492,22 +492,22 @@ fn u64_to_le_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n fn u64_to_be_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n     assert size <= 8u;\n     alt size {\n-      1u { f(&[n as u8]) }\n-      2u { f(&[(n >> 8) as u8,\n-              n as u8]) }\n-      4u { f(&[(n >> 24) as u8,\n+      1u => f(&[n as u8]),\n+      2u => f(&[(n >> 8) as u8,\n+              n as u8]),\n+      4u => f(&[(n >> 24) as u8,\n               (n >> 16) as u8,\n               (n >> 8) as u8,\n-              n as u8]) }\n-      8u { f(&[(n >> 56) as u8,\n+              n as u8]),\n+      8u => f(&[(n >> 56) as u8,\n               (n >> 48) as u8,\n               (n >> 40) as u8,\n               (n >> 32) as u8,\n               (n >> 24) as u8,\n               (n >> 16) as u8,\n               (n >> 8) as u8,\n-              n as u8]) }\n-      _ {\n+              n as u8]),\n+      _ => {\n         let mut bytes: ~[u8] = ~[];\n         let mut i = size;\n         while i > 0u {\n@@ -718,9 +718,9 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n     let mut bpos = pos as int;\n     let blen = len as int;\n     alt whence {\n-      seek_set { bpos = offset; }\n-      seek_cur { bpos += offset; }\n-      seek_end { bpos = blen + offset; }\n+      seek_set => bpos = offset,\n+      seek_cur => bpos += offset,\n+      seek_end => bpos = blen + offset\n     }\n     if bpos < 0 { bpos = 0; } else if bpos > blen { bpos = blen; }\n     return bpos as uint;\n@@ -768,8 +768,8 @@ mod fsync {\n         new(-arg: arg<t>) { self.arg <- arg; }\n         drop {\n           alt self.arg.opt_level {\n-            option::none { }\n-            option::some(level) {\n+            option::none => (),\n+            option::some(level) => {\n               // fail hard if not succesful\n               assert(self.arg.fsync_fn(self.arg.val, level) != -1);\n             }\n@@ -892,30 +892,30 @@ mod tests {\n     #[test]\n     fn file_reader_not_exist() {\n         alt io::file_reader(~\"not a file\") {\n-          result::err(e) {\n+          result::err(e) => {\n             assert e == ~\"error opening not a file\";\n           }\n-          result::ok(_) { fail; }\n+          result::ok(_) => fail\n         }\n     }\n \n     #[test]\n     fn file_writer_bad_name() {\n         alt io::file_writer(~\"?/?\", ~[]) {\n-          result::err(e) {\n+          result::err(e) => {\n             assert str::starts_with(e, ~\"error opening ?/?\");\n           }\n-          result::ok(_) { fail; }\n+          result::ok(_) => fail\n         }\n     }\n \n     #[test]\n     fn buffered_file_writer_bad_name() {\n         alt io::buffered_file_writer(~\"?/?\") {\n-          result::err(e) {\n+          result::err(e) => {\n             assert e == ~\"error opening ?/?\";\n           }\n-          result::ok(_) { fail; }\n+          result::ok(_) => fail\n         }\n     }\n "}, {"sha": "a150afa36e1bc477615acf2f7810f593bdf2bab6", "filename": "src/libcore/iter-trait/option.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fiter-trait%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fiter-trait%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Foption.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -2,14 +2,14 @@ type IMPL_T<A> = option<A>;\n \n pure fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n     alt self {\n-      none { }\n-      some(a) { f(a); }\n+      none => (),\n+      some(a) => { f(a); }\n     }\n }\n \n fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {\n     alt self {\n-      none { some(0u) }\n-      some(_) { some(1u) }\n+      none => some(0u),\n+      some(_) => some(1u)\n     }\n }"}, {"sha": "541c19aa3a527153624e1729ad45ac7b7e782fcc", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -136,32 +136,32 @@ fn repeat(times: uint, blk: fn() -> bool) {\n fn min<A:copy,IA:base_iter<A>>(self: IA) -> A {\n     alt do foldl::<A,option<A>,IA>(self, none) |a, b| {\n         alt a {\n-          some(a_) if a_ < b {\n+          some(a_) if a_ < b => {\n             // FIXME (#2005): Not sure if this is successfully optimized to\n             // a move\n             a\n           }\n-          _ { some(b) }\n+          _ => some(b)\n         }\n     } {\n-        some(val) { val }\n-        none { fail ~\"min called on empty iterator\" }\n+        some(val) => val,\n+        none => fail ~\"min called on empty iterator\"\n     }\n }\n \n fn max<A:copy,IA:base_iter<A>>(self: IA) -> A {\n     alt do foldl::<A,option<A>,IA>(self, none) |a, b| {\n         alt a {\n-          some(a_) if a_ > b {\n+          some(a_) if a_ > b => {\n             // FIXME (#2005): Not sure if this is successfully optimized to\n             // a move.\n             a\n           }\n-          _ { some(b) }\n+          _ => some(b)\n         }\n     } {\n-        some(val) { val }\n-        none { fail ~\"max called on empty iterator\" }\n+        some(val) => val,\n+        none => fail ~\"max called on empty iterator\"\n     }\n }\n "}, {"sha": "b2ae670ec0552609ea5b11d1c627a1cd6d9e37c4", "filename": "src/libcore/option.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -23,7 +23,10 @@ pure fn get<T: copy>(opt: option<T>) -> T {\n      * Fails if the value equals `none`\n      */\n \n-    alt opt { some(x) { return x; } none { fail ~\"option::get none\"; } }\n+    alt opt {\n+      some(x) => return x,\n+      none => fail ~\"option::get none\"\n+    }\n }\n \n pure fn expect<T: copy>(opt: option<T>, reason: ~str) -> T {\n@@ -34,13 +37,13 @@ pure fn expect<T: copy>(opt: option<T>, reason: ~str) -> T {\n \n     Fails if the value equals `none`\n     \"];\n-    alt opt { some(x) { x } none { fail reason; } }\n+    alt opt { some(x) => x, none => fail reason }\n }\n \n pure fn map<T, U>(opt: option<T>, f: fn(T) -> U) -> option<U> {\n     //! Maps a `some` value from one type to another\n \n-    alt opt { some(x) { some(f(x)) } none { none } }\n+    alt opt { some(x) => some(f(x)), none => none }\n }\n \n pure fn map_consume<T, U>(-opt: option<T>, f: fn(-T) -> U) -> option<U> {\n@@ -57,7 +60,7 @@ pure fn chain<T, U>(opt: option<T>, f: fn(T) -> option<U>) -> option<U> {\n      * function that returns an option.\n      */\n \n-    alt opt { some(x) { f(x) } none { none } }\n+    alt opt { some(x) => f(x), none => none }\n }\n \n #[inline(always)]\n@@ -73,7 +76,7 @@ pure fn while_some<T>(+x: option<T>, blk: fn(+T) -> option<T>) {\n pure fn is_none<T>(opt: option<T>) -> bool {\n     //! Returns true if the option equals `none`\n \n-    alt opt { none { true } some(_) { false } }\n+    alt opt { none => true, some(_) => false }\n }\n \n pure fn is_some<T>(opt: option<T>) -> bool {\n@@ -85,19 +88,19 @@ pure fn is_some<T>(opt: option<T>) -> bool {\n pure fn get_default<T: copy>(opt: option<T>, def: T) -> T {\n     //! Returns the contained value or a default\n \n-    alt opt { some(x) { x } none { def } }\n+    alt opt { some(x) => x, none => def }\n }\n \n pure fn map_default<T, U>(opt: option<T>, +def: U, f: fn(T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n-    alt opt { none { def } some(t) { f(t) } }\n+    alt opt { none => def, some(t) => f(t) }\n }\n \n pure fn iter<T>(opt: option<T>, f: fn(T)) {\n     //! Performs an operation on the contained value or does nothing\n \n-    alt opt { none { } some(t) { f(t); } }\n+    alt opt { none => (), some(t) => f(t) }\n }\n \n #[inline(always)]\n@@ -111,8 +114,8 @@ pure fn unwrap<T>(-opt: option<T>) -> T {\n \n     unsafe {\n         let addr = alt opt {\n-          some(x) { ptr::addr_of(x) }\n-          none { fail ~\"option::unwrap none\" }\n+          some(x) => ptr::addr_of(x),\n+          none => fail ~\"option::unwrap none\"\n         };\n         let liberated_value = unsafe::reinterpret_cast(*addr);\n         unsafe::forget(opt);"}, {"sha": "fba4e7acac5d464891b34277cc301ff2cda3d548", "filename": "src/libcore/os.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -179,18 +179,16 @@ mod global_env {\n             do priv::weaken_task |weak_po| {\n                 loop {\n                     alt comm::select2(msg_po, weak_po) {\n-                      either::left(msg_getenv(n, resp_ch)) {\n+                      either::left(msg_getenv(n, resp_ch)) => {\n                         comm::send(resp_ch, impl::getenv(n))\n                       }\n-                      either::left(msg_setenv(n, v, resp_ch)) {\n+                      either::left(msg_setenv(n, v, resp_ch)) => {\n                         comm::send(resp_ch, impl::setenv(n, v))\n                       }\n-                      either::left(msg_env(resp_ch)) {\n+                      either::left(msg_env(resp_ch)) => {\n                         comm::send(resp_ch, impl::env())\n                       }\n-                      either::right(_) {\n-                        break;\n-                      }\n+                      either::right(_) => break\n                     }\n                 }\n             }\n@@ -286,8 +284,8 @@ fn fsync_fd(fd: c_int, level: io::fsync::level) -> c_int {\n     import libc::funcs::posix01::unistd::*;\n     alt level {\n       io::fsync::fsync\n-      | io::fsync::fullfsync { return fsync(fd); }\n-      io::fsync::fdatasync { return fdatasync(fd); }\n+      | io::fsync::fullfsync => return fsync(fd),\n+      io::fsync::fdatasync => return fdatasync(fd)\n     }\n }\n \n@@ -297,8 +295,8 @@ fn fsync_fd(fd: c_int, level: io::fsync::level) -> c_int {\n     import libc::funcs::posix88::fcntl::*;\n     import libc::funcs::posix01::unistd::*;\n     alt level {\n-      io::fsync::fsync { return fsync(fd); }\n-      _ {\n+      io::fsync::fsync => return fsync(fd),\n+      _ => {\n         // According to man fnctl, the ok retval is only specified to be !=-1\n         if (fcntl(F_FULLFSYNC as c_int, fd) == -1 as c_int)\n             { return -1 as c_int; }\n@@ -443,16 +441,12 @@ fn self_exe_path() -> option<path> {\n  */\n fn homedir() -> option<path> {\n     return alt getenv(~\"HOME\") {\n-        some(p) {\n-            if !str::is_empty(p) {\n-                some(p)\n-            } else {\n-                secondary()\n-            }\n-        }\n-        none {\n-            secondary()\n+        some(p) => if !str::is_empty(p) {\n+          some(p)\n+        } else {\n+          secondary()\n         }\n+        none => secondary()\n     };\n \n     #[cfg(unix)]"}, {"sha": "dc541b14a4bbf3042e7213d699c4935b580c69f1", "filename": "src/libcore/path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -64,11 +64,11 @@ fn split_dirname_basename (pp: path) -> {dirname: ~str, basename: ~str} {\n     alt str::rfind(pp, |ch|\n         ch == consts::path_sep || ch == consts::alt_path_sep\n     ) {\n-      some(i) {\n-        {dirname: str::slice(pp, 0u, i),\n-         basename: str::slice(pp, i + 1u, str::len(pp))}\n-      }\n-      none { {dirname: ~\".\", basename: pp} }\n+      some(i) => {\n+        dirname: str::slice(pp, 0u, i),\n+        basename: str::slice(pp, i + 1u, str::len(pp))\n+      },\n+      none => {dirname: ~\".\", basename: pp}\n     }\n }\n "}, {"sha": "f13ee96768a2e6c9a0cbd9ca65c205101a0e3b39", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 66, "deletions": 84, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -120,9 +120,9 @@ struct packet_header {\n         assert self.state != blocked || self.blocked_task != none;\n         self.blocked_task = none;\n         alt swap_state_acq(self.state, empty) {\n-          empty | blocked { }\n-          terminated { self.state = terminated; }\n-          full { self.state = full; }\n+          empty | blocked => (),\n+          terminated => self.state = terminated,\n+          full => self.state = full\n         }\n     }\n \n@@ -310,27 +310,25 @@ fn send<T: send, Tbuffer: send>(-p: send_packet_buffered<T, Tbuffer>,\n     p.payload <- some(payload);\n     let old_state = swap_state_rel(p.header.state, full);\n     alt old_state {\n-      empty {\n+      empty => {\n         // Yay, fastpath.\n \n         // The receiver will eventually clean this up.\n         //unsafe { forget(p); }\n       }\n-      full { fail ~\"duplicate send\" }\n-      blocked {\n+      full => fail ~\"duplicate send\",\n+      blocked => {\n         debug!{\"waking up task for %?\", p_};\n         alt p.header.blocked_task {\n-          some(task) {\n-            rustrt::task_signal_event(\n-                task, ptr::addr_of(p.header) as *libc::c_void);\n-          }\n-          none { debug!{\"just kidding!\"} }\n+          some(task) => rustrt::task_signal_event(\n+              task, ptr::addr_of(p.header) as *libc::c_void),\n+          none => debug!{\"just kidding!\"}\n         }\n \n         // The receiver will eventually clean this up.\n         //unsafe { forget(p); }\n       }\n-      terminated {\n+      terminated => {\n         // The receiver will never receive this. Rely on drop_glue\n         // to clean everything up.\n       }\n@@ -367,7 +365,7 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n         let old_state = swap_state_acq(p.header.state,\n                                        blocked);\n         alt old_state {\n-          empty {\n+          empty => {\n             debug!{\"no data available on %?, going to sleep.\", p_};\n             if count == 0 {\n                 wait_event(this);\n@@ -383,19 +381,17 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n             }\n             debug!{\"woke up, p.state = %?\", copy p.header.state};\n           }\n-          blocked {\n-            if first {\n-                fail ~\"blocking on already blocked packet\"\n-            }\n+          blocked => if first {\n+            fail ~\"blocking on already blocked packet\"\n           }\n-          full {\n+          full => {\n             let mut payload = none;\n             payload <-> p.payload;\n             p.header.blocked_task = none;\n             p.header.state = empty;\n             return some(option::unwrap(payload))\n           }\n-          terminated {\n+          terminated => {\n             // This assert detects when we've accidentally unsafely\n             // casted too big of a number to a state.\n             assert old_state == terminated;\n@@ -409,9 +405,9 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n /// Returns true if messages are available.\n pure fn peek<T: send, Tb: send>(p: recv_packet_buffered<T, Tb>) -> bool {\n     alt unsafe {(*p.header()).state} {\n-      empty { false }\n-      blocked { fail ~\"peeking on blocked packet\" }\n-      full | terminated { true }\n+      empty => false,\n+      blocked => fail ~\"peeking on blocked packet\",\n+      full | terminated => true\n     }\n }\n \n@@ -425,11 +421,11 @@ impl peek<T: send, Tb: send> for recv_packet_buffered<T, Tb> {\n fn sender_terminate<T: send>(p: *packet<T>) {\n     let p = unsafe { &*p };\n     alt swap_state_rel(p.header.state, terminated) {\n-      empty {\n+      empty => {\n         // The receiver will eventually clean up.\n         //unsafe { forget(p) }\n       }\n-      blocked {\n+      blocked => {\n         // wake up the target\n         alt p.header.blocked_task {\n           some(target) =>\n@@ -441,11 +437,11 @@ fn sender_terminate<T: send>(p: *packet<T>) {\n         // The receiver will eventually clean up.\n         //unsafe { forget(p) }\n       }\n-      full {\n+      full => {\n         // This is impossible\n         fail ~\"you dun goofed\"\n       }\n-      terminated {\n+      terminated => {\n         // I have to clean up, use drop_glue\n       }\n     }\n@@ -456,15 +452,15 @@ fn receiver_terminate<T: send>(p: *packet<T>) {\n     let p = unsafe { &*p };\n     assert p.header.blocked_task == none;\n     alt swap_state_rel(p.header.state, terminated) {\n-      empty {\n+      empty => {\n         // the sender will clean up\n         //unsafe { forget(p) }\n       }\n-      blocked {\n+      blocked => {\n         // this shouldn't happen.\n         fail ~\"terminating a blocked packet\"\n       }\n-      terminated | full {\n+      terminated | full => {\n         // I have to clean up, use drop_glue\n       }\n     }\n@@ -490,14 +486,14 @@ fn wait_many(pkts: &[*packet_header]) -> uint {\n         let p = unsafe { &*p };\n         let old = p.mark_blocked(this);\n         alt old {\n-          full | terminated {\n+          full | terminated => {\n             data_avail = true;\n             ready_packet = i;\n             (*p).state = old;\n             break;\n           }\n-          blocked { fail ~\"blocking on blocked packet\" }\n-          empty { }\n+          blocked => fail ~\"blocking on blocked packet\",\n+          empty => ()\n         }\n     }\n \n@@ -507,13 +503,11 @@ fn wait_many(pkts: &[*packet_header]) -> uint {\n         let pos = vec::position(pkts, |p| p == event);\n \n         alt pos {\n-          some(i) {\n+          some(i) => {\n             ready_packet = i;\n             data_avail = true;\n           }\n-          none {\n-            debug!{\"ignoring spurious event, %?\", event};\n-          }\n+          none => debug!{\"ignoring spurious event, %?\", event}\n         }\n     }\n \n@@ -569,9 +563,9 @@ fn select2<A: send, Ab: send, B: send, Bb: send>(\n \n     unsafe {\n         alt i {\n-          0 { left((try_recv(a), b)) }\n-          1 { right((a, try_recv(b))) }\n-          _ { fail ~\"select2 return an invalid packet\" }\n+          0 => left((try_recv(a), b)),\n+          1 => right((a, try_recv(b))),\n+          _ => fail ~\"select2 return an invalid packet\"\n         }\n     }\n }\n@@ -586,9 +580,9 @@ fn selecti<T: selectable>(endpoints: &[T]) -> uint {\n \n fn select2i<A: selectable, B: selectable>(a: A, b: B) -> either<(), ()> {\n     alt wait_many([a.header(), b.header()]/_) {\n-      0 { left(()) }\n-      1 { right(()) }\n-      _ { fail ~\"wait returned unexpected index\" }\n+      0 => left(()),\n+      1 => right(()),\n+      _ => fail ~\"wait returned unexpected index\"\n     }\n }\n \n@@ -655,15 +649,13 @@ struct send_packet_buffered<T: send, Tbuffer: send> {\n \n     pure fn header() -> *packet_header {\n         alt self.p {\n-          some(packet) {\n-            unsafe {\n-                let packet = &*packet;\n-                let header = ptr::addr_of(packet.header);\n-                //forget(packet);\n-                header\n-            }\n+          some(packet) => unsafe {\n+            let packet = &*packet;\n+            let header = ptr::addr_of(packet.header);\n+            //forget(packet);\n+            header\n           }\n-          none { fail ~\"packet already consumed\" }\n+          none => fail ~\"packet already consumed\"\n         }\n     }\n \n@@ -718,15 +710,13 @@ struct recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n \n     pure fn header() -> *packet_header {\n         alt self.p {\n-          some(packet) {\n-            unsafe {\n-                let packet = &*packet;\n-                let header = ptr::addr_of(packet.header);\n-                //forget(packet);\n-                header\n-            }\n+          some(packet) => unsafe {\n+            let packet = &*packet;\n+            let header = ptr::addr_of(packet.header);\n+            //forget(packet);\n+            header\n           }\n-          none { fail ~\"packet already consumed\" }\n+          none => fail ~\"packet already consumed\"\n         }\n     }\n \n@@ -847,22 +837,20 @@ impl port<T: send> of recv<T> for port<T> {\n         let mut endp = none;\n         endp <-> self.endp;\n         alt move pipes::try_recv(unwrap(endp)) {\n-          some(streamp::data(x, endp)) {\n+          some(streamp::data(x, endp)) => {\n             self.endp = some(move_it!{endp});\n             some(move_it!{x})\n           }\n-          none { none }\n+          none => none\n         }\n     }\n \n     pure fn peek() -> bool unchecked {\n         let mut endp = none;\n         endp <-> self.endp;\n         let peek = alt endp {\n-          some(endp) {\n-            pipes::peek(endp)\n-          }\n-          none { fail ~\"peeking empty stream\" }\n+          some(endp) => pipes::peek(endp),\n+          none => fail ~\"peeking empty stream\"\n         };\n         self.endp <-> endp;\n         peek\n@@ -894,10 +882,10 @@ struct port_set<T: send> : recv<T> {\n         while result == none && ports.len() > 0 {\n             let i = wait_many(ports.map(|p| p.header()));\n             alt move ports[i].try_recv() {\n-                some(copy m) {\n+                some(copy m) => {\n                     result = some(move m);\n                 }\n-                none {\n+                none => {\n                     // Remove this port.\n                     let mut ports_ = ~[];\n                     ports <-> ports_;\n@@ -914,8 +902,8 @@ struct port_set<T: send> : recv<T> {\n \n     fn recv() -> T {\n         match move self.try_recv() {\n-            some(copy x) { move x }\n-            none { fail ~\"port_set: endpoints closed\" }\n+            some(copy x) => move x,\n+            none => fail ~\"port_set: endpoints closed\"\n         }\n     }\n \n@@ -932,10 +920,8 @@ struct port_set<T: send> : recv<T> {\n impl<T: send> of selectable for port<T> {\n     pure fn header() -> *packet_header unchecked {\n         alt self.endp {\n-          some(endp) {\n-            endp.header()\n-          }\n-          none { fail ~\"peeking empty stream\" }\n+          some(endp) => endp.header(),\n+          none => fail ~\"peeking empty stream\"\n         }\n     }\n }\n@@ -968,22 +954,18 @@ impl<T: send, U: send, Left: selectable recv<T>, Right: selectable recv<U>>\n \n     fn select() -> either<T, U> {\n         alt self {\n-          (lp, rp) {\n-            alt select2i(lp, rp) {\n-              left(())  { left (lp.recv()) }\n-              right(()) { right(rp.recv()) }\n-            }\n+          (lp, rp) => alt select2i(lp, rp) {\n+            left(()) => left (lp.recv()),\n+            right(()) => right(rp.recv())\n           }\n         }\n     }\n \n     fn try_select() -> either<option<T>, option<U>> {\n         alt self {\n-          (lp, rp) {\n-            alt select2i(lp, rp) {\n-              left(())  { left (lp.try_recv()) }\n-              right(()) { right(rp.try_recv()) }\n-            }\n+          (lp, rp) => alt select2i(lp, rp) {\n+            left(()) => left (lp.try_recv()),\n+            right(()) => right(rp.try_recv())\n           }\n         }\n     }\n@@ -999,8 +981,8 @@ mod test {\n         c1.send(~\"abc\");\n \n         alt (p1, p2).select() {\n-          right(_) { fail }\n-          _ { }\n+          right(_) => fail,\n+          _ => ()\n         }\n \n         c2.send(123);"}, {"sha": "5d7123f1bba85bc3435975705a0b39feaf833750", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -50,8 +50,8 @@ unsafe fn chan_from_global_ptr<T: send>(\n             // Wait to hear if we are the official instance of\n             // this global task\n             alt comm::recv::<msg>(setup_po) {\n-              proceed { f(po); }\n-              abort { }\n+              proceed => f(po),\n+              abort => ()\n             }\n         };\n "}, {"sha": "a74ac589b931e4f140f3ffb7c169d9a3f24a149d", "filename": "src/libcore/result.rs", "status": "modified", "additions": 41, "deletions": 45, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -19,9 +19,9 @@ enum result<T, U> {\n  */\n pure fn get<T: copy, U>(res: result<T, U>) -> T {\n     alt res {\n-      ok(t) { t }\n-      err(the_err) {\n-        unchecked{ fail fmt!{\"get called on error result: %?\", the_err}; }\n+      ok(t) => t,\n+      err(the_err) => unchecked {\n+        fail fmt!{\"get called on error result: %?\", the_err}\n       }\n     }\n }\n@@ -35,18 +35,16 @@ pure fn get<T: copy, U>(res: result<T, U>) -> T {\n  */\n pure fn get_err<T, U: copy>(res: result<T, U>) -> U {\n     alt res {\n-      err(u) { u }\n-      ok(_) {\n-        fail ~\"get_error called on ok result\";\n-      }\n+      err(u) => u,\n+      ok(_) => fail ~\"get_error called on ok result\"\n     }\n }\n \n /// Returns true if the result is `ok`\n pure fn is_ok<T, U>(res: result<T, U>) -> bool {\n     alt res {\n-      ok(_) { true }\n-      err(_) { false }\n+      ok(_) => true,\n+      err(_) => false\n     }\n }\n \n@@ -63,8 +61,8 @@ pure fn is_err<T, U>(res: result<T, U>) -> bool {\n  */\n pure fn to_either<T: copy, U: copy>(res: result<U, T>) -> either<T, U> {\n     alt res {\n-      ok(res) { either::right(res) }\n-      err(fail_) { either::left(fail_) }\n+      ok(res) => either::right(res),\n+      err(fail_) => either::left(fail_)\n     }\n }\n \n@@ -85,8 +83,8 @@ pure fn to_either<T: copy, U: copy>(res: result<U, T>) -> either<T, U> {\n fn chain<T, U: copy, V: copy>(res: result<T, V>, op: fn(T) -> result<U, V>)\n     -> result<U, V> {\n     alt res {\n-      ok(t) { op(t) }\n-      err(e) { err(e) }\n+      ok(t) => op(t),\n+      err(e) => err(e)\n     }\n }\n \n@@ -103,8 +101,8 @@ fn chain_err<T: copy, U: copy, V: copy>(\n     op: fn(V) -> result<T, U>)\n     -> result<T, U> {\n     alt res {\n-      ok(t) { ok(t) }\n-      err(v) { op(v) }\n+      ok(t) => ok(t),\n+      err(v) => op(v)\n     }\n }\n \n@@ -124,8 +122,8 @@ fn chain_err<T: copy, U: copy, V: copy>(\n  */\n fn iter<T, E>(res: result<T, E>, f: fn(T)) {\n     alt res {\n-      ok(t) { f(t) }\n-      err(_) { }\n+      ok(t) => f(t),\n+      err(_) => ()\n     }\n }\n \n@@ -139,8 +137,8 @@ fn iter<T, E>(res: result<T, E>, f: fn(T)) {\n  */\n fn iter_err<T, E>(res: result<T, E>, f: fn(E)) {\n     alt res {\n-      ok(_) { }\n-      err(e) { f(e) }\n+      ok(_) => (),\n+      err(e) => f(e)\n     }\n }\n \n@@ -161,8 +159,8 @@ fn iter_err<T, E>(res: result<T, E>, f: fn(E)) {\n fn map<T, E: copy, U: copy>(res: result<T, E>, op: fn(T) -> U)\n   -> result<U, E> {\n     alt res {\n-      ok(t) { ok(op(t)) }\n-      err(e) { err(e) }\n+      ok(t) => ok(op(t)),\n+      err(e) => err(e)\n     }\n }\n \n@@ -177,8 +175,8 @@ fn map<T, E: copy, U: copy>(res: result<T, E>, op: fn(T) -> U)\n fn map_err<T: copy, E, F: copy>(res: result<T, E>, op: fn(E) -> F)\n   -> result<T, F> {\n     alt res {\n-      ok(t) { ok(t) }\n-      err(e) { err(op(e)) }\n+      ok(t) => ok(t),\n+      err(e) => err(op(e))\n     }\n }\n \n@@ -189,15 +187,15 @@ impl extensions<T, E> for result<T, E> {\n \n     fn iter(f: fn(T)) {\n         alt self {\n-          ok(t) { f(t) }\n-          err(_) { }\n+          ok(t) => f(t),\n+          err(_) => ()\n         }\n     }\n \n     fn iter_err(f: fn(E)) {\n         alt self {\n-          ok(_) { }\n-          err(e) { f(e) }\n+          ok(_) => (),\n+          err(e) => f(e)\n         }\n     }\n }\n@@ -207,8 +205,8 @@ impl extensions<T:copy, E> for result<T, E> {\n \n     fn map_err<F:copy>(op: fn(E) -> F) -> result<T,F> {\n         alt self {\n-          ok(t) { ok(t) }\n-          err(e) { err(op(e)) }\n+          ok(t) => ok(t),\n+          err(e) => err(op(e))\n         }\n     }\n }\n@@ -218,8 +216,8 @@ impl extensions<T, E:copy> for result<T, E> {\n \n     fn map<U:copy>(op: fn(T) -> U) -> result<U,E> {\n         alt self {\n-          ok(t) { ok(op(t)) }\n-          err(e) { err(e) }\n+          ok(t) => ok(op(t)),\n+          err(e) => err(e)\n         }\n     }\n }\n@@ -258,8 +256,8 @@ fn map_vec<T,U:copy,V:copy>(\n     vec::reserve(vs, vec::len(ts));\n     for vec::each(ts) |t| {\n         alt op(t) {\n-          ok(v) { vec::push(vs, v); }\n-          err(u) { return err(u); }\n+          ok(v) => vec::push(vs, v),\n+          err(u) => return err(u)\n         }\n     }\n     return ok(vs);\n@@ -269,12 +267,10 @@ fn map_opt<T,U:copy,V:copy>(\n     o_t: option<T>, op: fn(T) -> result<V,U>) -> result<option<V>,U> {\n \n     alt o_t {\n-      none { ok(none) }\n-      some(t) {\n-        alt op(t) {\n-          ok(v) { ok(some(v)) }\n-          err(e) { err(e) }\n-        }\n+      none => ok(none),\n+      some(t) => alt op(t) {\n+        ok(v) => ok(some(v)),\n+        err(e) => err(e)\n       }\n     }\n }\n@@ -298,8 +294,8 @@ fn map_vec2<S,T,U:copy,V:copy>(ss: ~[S], ts: ~[T],\n     let mut i = 0u;\n     while i < n {\n         alt op(ss[i],ts[i]) {\n-          ok(v) { vec::push(vs, v); }\n-          err(u) { return err(u); }\n+          ok(v) => vec::push(vs, v),\n+          err(u) => return err(u)\n         }\n         i += 1u;\n     }\n@@ -319,8 +315,8 @@ fn iter_vec2<S,T,U:copy>(ss: ~[S], ts: ~[T],\n     let mut i = 0u;\n     while i < n {\n         alt op(ss[i],ts[i]) {\n-          ok(()) { }\n-          err(u) { return err(u); }\n+          ok(()) => (),\n+          err(u) => return err(u)\n         }\n         i += 1u;\n     }\n@@ -331,8 +327,8 @@ fn iter_vec2<S,T,U:copy>(ss: ~[S], ts: ~[T],\n fn unwrap<T, U>(-res: result<T, U>) -> T {\n     unsafe {\n         let addr = alt res {\n-          ok(x) { ptr::addr_of(x) }\n-          err(_) { fail ~\"error result\" }\n+          ok(x) => ptr::addr_of(x),\n+          err(_) => fail ~\"error result\"\n         };\n         let liberated_value = unsafe::reinterpret_cast(*addr);\n         unsafe::forget(res);"}, {"sha": "60527e786bdb27fad5b58688b7033c89f5c00bd5", "filename": "src/libcore/run.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -97,7 +97,7 @@ fn with_envp<T>(env: option<~[(~str,~str)]>,\n     // On posixy systems we can pass a char** for envp, which is\n     // a null-terminated array of \"k=v\\n\" strings.\n     alt env {\n-      some(es) if !vec::is_empty(es) {\n+      some(es) if !vec::is_empty(es) => {\n         let mut tmps = ~[];\n         let mut ptrs = ~[];\n \n@@ -112,9 +112,7 @@ fn with_envp<T>(env: option<~[(~str,~str)]>,\n             unsafe { cb(::unsafe::reinterpret_cast(p)) }\n         )\n       }\n-      _ {\n-        cb(ptr::null())\n-      }\n+      _ => cb(ptr::null())\n     }\n }\n \n@@ -126,7 +124,7 @@ fn with_envp<T>(env: option<~[(~str,~str)]>,\n     // \\0 to terminate.\n     unsafe {\n         alt env {\n-          some(es) if !vec::is_empty(es) {\n+          some(es) if !vec::is_empty(es) => {\n             let mut blk : ~[u8] = ~[];\n             for vec::each(es) |e| {\n                 let (k,v) = e;\n@@ -138,18 +136,16 @@ fn with_envp<T>(env: option<~[(~str,~str)]>,\n             blk += ~[0_u8];\n             vec::as_buf(blk, |p, _len| cb(::unsafe::reinterpret_cast(p)))\n           }\n-          _ {\n-            cb(ptr::null())\n-          }\n+          _ => cb(ptr::null())\n         }\n     }\n }\n \n fn with_dirp<T>(d: option<~str>,\n                 cb: fn(*libc::c_char) -> T) -> T {\n     alt d {\n-      some(dir) { str::as_c_str(dir, cb) }\n-      none { cb(ptr::null()) }\n+      some(dir) => str::as_c_str(dir, cb),\n+      none => cb(ptr::null())\n     }\n }\n \n@@ -314,10 +310,10 @@ fn program_output(prog: ~str, args: ~[~str]) ->\n     while count > 0 {\n         let stream = comm::recv(p);\n         alt check stream {\n-            (1, s) {\n+            (1, s) => {\n                 outs = s;\n             }\n-            (2, s) {\n+            (2, s) => {\n                 errs = s;\n             }\n         };"}, {"sha": "a242587a21c38246a02517090134a1df098f4a81", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -116,14 +116,10 @@ mod linear {\n \n             let _ = for self.bucket_sequence(hash) |i| {\n                 alt buckets[i] {\n-                  some(bkt) {\n-                    if bkt.hash == hash && self.eqfn(k, &bkt.key) {\n-                        return found_entry(i);\n-                    }\n-                  }\n-                  none => {\n-                    return found_hole(i);\n+                  some(bkt) => if bkt.hash == hash && self.eqfn(k, &bkt.key) {\n+                    return found_entry(i);\n                   }\n+                  none => return found_hole(i)\n                 }\n             };\n             return table_full;\n@@ -162,7 +158,7 @@ mod linear {\n             alt self.bucket_for_key_with_hash(self.buckets, hash,\n                                               unsafe{borrow(k)}) {\n               table_full => {fail ~\"Internal logic error\";}\n-              found_hole(idx) {\n+              found_hole(idx) => {\n                 debug!{\"insert fresh (%?->%?) at idx %?, hash %?\",\n                        k, v, idx, hash};\n                 self.buckets[idx] = some({hash: hash, key: k, value: v});"}, {"sha": "cec8ec52ee47fc4591f6bc19eb8e3b4c5f4462e3", "filename": "src/libcore/str.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -342,18 +342,16 @@ fn unshift_char(&s: ~str, ch: char) { s = from_char(ch) + s; }\n /// Returns a string with leading whitespace removed\n pure fn trim_left(s: &str) -> ~str {\n     alt find(s, |c| !char::is_whitespace(c)) {\n-      none { ~\"\" }\n-      some(first) {\n-        unsafe { unsafe::slice_bytes(s, first, len(s)) }\n-      }\n+      none => ~\"\",\n+      some(first) => unsafe { unsafe::slice_bytes(s, first, len(s)) }\n     }\n }\n \n /// Returns a string with trailing whitespace removed\n pure fn trim_right(s: &str) -> ~str {\n     alt rfind(s, |c| !char::is_whitespace(c)) {\n-      none { ~\"\" }\n-      some(last) {\n+      none => ~\"\",\n+      some(last) => {\n         let {next, _} = char_range_at(s, last);\n         unsafe { unsafe::slice_bytes(s, 0u, next) }\n       }\n@@ -2779,9 +2777,9 @@ mod tests {\n         let mut i = 0;\n         do chars_iter(~\"x\\u03c0y\") |ch| {\n             alt check i {\n-              0 { assert ch == 'x'; }\n-              1 { assert ch == '\\u03c0'; }\n-              2 { assert ch == 'y'; }\n+              0 => assert ch == 'x',\n+              1 => assert ch == '\\u03c0',\n+              2 => assert ch == 'y'\n             }\n             i += 1;\n         }\n@@ -2795,9 +2793,9 @@ mod tests {\n \n         do bytes_iter(~\"xyz\") |bb| {\n             alt check i {\n-              0 { assert bb == 'x' as u8; }\n-              1 { assert bb == 'y' as u8; }\n-              2 { assert bb == 'z' as u8; }\n+              0 => assert bb == 'x' as u8,\n+              1 => assert bb == 'y' as u8,\n+              2 => assert bb == 'z' as u8\n             }\n             i += 1;\n         }\n@@ -2813,11 +2811,11 @@ mod tests {\n \n         do split_char_iter(data, ' ') |xx| {\n             alt ii {\n-              0 { assert ~\"\\nMary\" == xx; }\n-              1 { assert ~\"had\"    == xx; }\n-              2 { assert ~\"a\"      == xx; }\n-              3 { assert ~\"little\" == xx; }\n-              _ { () }\n+              0 => assert ~\"\\nMary\" == xx,\n+              1 => assert ~\"had\"    == xx,\n+              2 => assert ~\"a\"      == xx,\n+              3 => assert ~\"little\" == xx,\n+              _ => ()\n             }\n             ii += 1;\n         }\n@@ -2831,10 +2829,10 @@ mod tests {\n \n         do splitn_char_iter(data, ' ', 2u) |xx| {\n             alt ii {\n-              0 { assert ~\"\\nMary\" == xx; }\n-              1 { assert ~\"had\"    == xx; }\n-              2 { assert ~\"a little lamb\\nLittle lamb\\n\" == xx; }\n-              _ { () }\n+              0 => assert ~\"\\nMary\" == xx,\n+              1 => assert ~\"had\"    == xx,\n+              2 => assert ~\"a little lamb\\nLittle lamb\\n\" == xx,\n+              _ => ()\n             }\n             ii += 1;\n         }\n@@ -2848,11 +2846,11 @@ mod tests {\n \n         do words_iter(data) |ww| {\n             alt ii {\n-              0 { assert ~\"Mary\"   == ww; }\n-              1 { assert ~\"had\"    == ww; }\n-              2 { assert ~\"a\"      == ww; }\n-              3 { assert ~\"little\" == ww; }\n-              _ { () }\n+              0 => assert ~\"Mary\"   == ww,\n+              1 => assert ~\"had\"    == ww,\n+              2 => assert ~\"a\"      == ww,\n+              3 => assert ~\"little\" == ww,\n+              _ => ()\n             }\n             ii += 1;\n         }\n@@ -2868,11 +2866,11 @@ mod tests {\n \n         do lines_iter(lf) |x| {\n             alt ii {\n-                0 { assert ~\"\" == x; }\n-                1 { assert ~\"Mary had a little lamb\" == x; }\n-                2 { assert ~\"Little lamb\" == x; }\n-                3 { assert ~\"\" == x; }\n-                _ { () }\n+                0 => assert ~\"\" == x,\n+                1 => assert ~\"Mary had a little lamb\" == x,\n+                2 => assert ~\"Little lamb\" == x,\n+                3 => assert ~\"\" == x,\n+                _ => ()\n             }\n             ii += 1;\n         }"}, {"sha": "da25eb308abed1b46d113d8db3ee4b29f362420c", "filename": "src/libcore/task.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -280,7 +280,7 @@ impl task_builder for task_builder {\n \n         blk(do future::from_fn {\n             alt comm::recv(po) {\n-              exit(_, result) { result }\n+              exit(_, result) => result\n             }\n         });\n \n@@ -503,8 +503,8 @@ fn try<T:send>(+f: fn~() -> T) -> result<T,()> {\n         comm::send(ch, f());\n     }\n     alt future::get(option::unwrap(result)) {\n-      success { result::ok(comm::recv(po)) }\n-      failure { result::err(()) }\n+      success => result::ok(comm::recv(po)),\n+      failure => result::err(())\n     }\n }\n \n@@ -992,7 +992,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n      * Step 1. Get spawner's taskgroup info.\n      *######################################################################*/\n     let spawner_group = alt unsafe { local_get(spawner, taskgroup_key()) } {\n-        none {\n+        none => {\n             // Main task, doing first spawn ever. Lazily initialise here.\n             let mut members = new_taskset();\n             taskset_insert(&mut members, spawner);\n@@ -1005,7 +1005,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             unsafe { local_set(spawner, taskgroup_key(), group); }\n             group\n         }\n-        some(group) { group }\n+        some(group) => group\n     };\n     /*######################################################################*\n      * Step 2. Process spawn options for child.\n@@ -1029,8 +1029,8 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             // it should be enabled only in debug builds.\n             let new_generation =\n                 alt *old_ancestors {\n-                    some(arc) { access_ancestors(arc, |a| a.generation+1) }\n-                    none      { 0 } // the actual value doesn't really matter.\n+                    some(arc) => access_ancestors(arc, |a| a.generation+1),\n+                    none      => 0 // the actual value doesn't really matter.\n                 };\n             assert new_generation < uint::max_value;\n             // Build a new node in the ancestor list.\n@@ -1074,8 +1074,8 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n             let (child_tg, ancestors, f) = option::swap_unwrap(child_data);\n             // Create child task.\n             let new_task = alt opts.sched {\n-              none             { rustrt::new_task() }\n-              some(sched_opts) { new_task_in_new_sched(sched_opts) }\n+              none             => rustrt::new_task(),\n+              some(sched_opts) => new_task_in_new_sched(sched_opts)\n             };\n             assert !new_task.is_null();\n             // Getting killed after here would leak the task.\n@@ -1163,20 +1163,20 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n         }\n \n         let num_threads = alt opts.mode {\n-          single_threaded { 1u }\n-          thread_per_core {\n+          single_threaded => 1u,\n+          thread_per_core => {\n             fail ~\"thread_per_core scheduling mode unimplemented\"\n           }\n-          thread_per_task {\n+          thread_per_task => {\n             fail ~\"thread_per_task scheduling mode unimplemented\"\n           }\n-          manual_threads(threads) {\n+          manual_threads(threads) => {\n             if threads == 0u {\n                 fail ~\"can not create a scheduler with no threads\";\n             }\n             threads\n           }\n-          osmain { 0u /* Won't be used */ }\n+          osmain => 0u /* Won't be used */\n         };\n \n         let sched_id = if opts.mode != osmain {\n@@ -1273,7 +1273,10 @@ unsafe fn local_data_lookup<T: owned>(\n \n     let key_value = key_to_key_value(key);\n     let map_pos = (*map).position(|entry|\n-        alt entry { some((k,_,_)) { k == key_value } none { false } }\n+        alt entry {\n+            some((k,_,_)) => k == key_value,\n+            none => false\n+        }\n     );\n     do map_pos.map |index| {\n         // .get() is guaranteed because of \"none { false }\" above.\n@@ -1334,20 +1337,16 @@ unsafe fn local_set<T: owned>(\n     let new_entry = some((keyval, data_ptr, data_box));\n     // Find a place to put it.\n     alt local_data_lookup(map, key) {\n-        some((index, _old_data_ptr)) {\n+        some((index, _old_data_ptr)) => {\n             // Key already had a value set, _old_data_ptr, whose reference\n             // will get dropped when the local_data box is overwritten.\n             (*map).set_elt(index, new_entry);\n         }\n-        none {\n+        none => {\n             // Find an empty slot. If not, grow the vector.\n             alt (*map).position(|x| x == none) {\n-                some(empty_index) {\n-                    (*map).set_elt(empty_index, new_entry);\n-                }\n-                none {\n-                    (*map).push(new_entry);\n-                }\n+                some(empty_index) => (*map).set_elt(empty_index, new_entry),\n+                none => (*map).push(new_entry)\n             }\n         }\n     }\n@@ -1698,8 +1697,8 @@ fn test_try_success() {\n     alt do try {\n         ~\"Success!\"\n     } {\n-        result::ok(~\"Success!\") { }\n-        _ { fail; }\n+        result::ok(~\"Success!\") => (),\n+        _ => fail\n     }\n }\n \n@@ -1709,8 +1708,8 @@ fn test_try_fail() {\n     alt do try {\n         fail\n     } {\n-        result::err(()) { }\n-        result::ok(()) { fail; }\n+        result::err(()) => (),\n+        result::ok(()) => fail\n     }\n }\n \n@@ -2054,15 +2053,15 @@ fn test_tls_modify() unsafe {\n     fn my_key(+_x: @~str) { }\n     local_data_modify(my_key, |data| {\n         alt data {\n-            some(@val) { fail ~\"unwelcome value: \" + val }\n-            none       { some(@~\"first data\") }\n+            some(@val) => fail ~\"unwelcome value: \" + val,\n+            none       => some(@~\"first data\")\n         }\n     });\n     local_data_modify(my_key, |data| {\n         alt data {\n-            some(@~\"first data\") { some(@~\"next data\") }\n-            some(@val)          { fail ~\"wrong value: \" + val }\n-            none                { fail ~\"missing value\" }\n+            some(@~\"first data\") => some(@~\"next data\"),\n+            some(@val)           => fail ~\"wrong value: \" + val,\n+            none                 => fail ~\"missing value\"\n         }\n     });\n     assert *(local_data_pop(my_key).get()) == ~\"next data\";"}, {"sha": "d3b0e8cea2461ddd723a14f962b731c7745fa48d", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -128,8 +128,8 @@ fn parse_buf(buf: ~[u8], radix: uint) -> option<T> {\n     let mut n = 0u as T;\n     loop {\n         alt char::to_digit(buf[i] as char, radix) {\n-          some(d) { n += d as T * power; }\n-          none { return none; }\n+          some(d) => n += d as T * power,\n+          none => return none\n         }\n         power *= radix as T;\n         if i == 0u { return some(n); }\n@@ -147,8 +147,8 @@ fn from_str_radix(buf: ~str, radix: u64) -> option<u64> {\n     let mut power = 1u64, n = 0u64;\n     loop {\n         alt char::to_digit(buf[i] as char, radix as uint) {\n-          some(d) { n += d as u64 * power; }\n-          none { return none; }\n+          some(d) => n += d as u64 * power,\n+          none => return none\n         }\n         power *= radix;\n         if i == 0u { return some(n); }"}, {"sha": "343bf7954e6781b4509e8e6b255df82bc0a440e4", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 64, "deletions": 70, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -2,9 +2,8 @@ mod general_category {\n     pure fn Cc(c: char) -> bool {\n         return alt c {\n               '\\x00' to '\\x1f'\n-            | '\\x7f' to '\\x9f'\n-              { true }\n-            _ { false }\n+            | '\\x7f' to '\\x9f' => true,\n+            _ => false\n         };\n     }\n \n@@ -22,25 +21,22 @@ mod general_category {\n             | '\\ufff9' to '\\ufffb'\n             | '\\U000110bd'\n             | '\\U0001d173' to '\\U0001d17a'\n-            | '\\U000e0001' to '\\U000e007f'\n-              { true }\n-            _ { false }\n+            | '\\U000e0001' to '\\U000e007f' => true,\n+            _ => false\n         };\n     }\n \n     pure fn Co(c: char) -> bool {\n         return alt c {\n-              '\\ue000' to '\\uf8ff'\n-              { true }\n-            _ { false }\n+          '\\ue000' to '\\uf8ff' => true,\n+          _ => false\n         };\n     }\n \n     pure fn Cs(c: char) -> bool {\n         return alt c {\n-              '\\ud800' to '\\udfff'\n-              { true }\n-            _ { false }\n+              '\\ud800' to '\\udfff' => true,\n+            _ => false\n         };\n     }\n \n@@ -644,8 +640,8 @@ mod general_category {\n             | '\\U0001d7aa' to '\\U0001d7c2'\n             | '\\U0001d7c4' to '\\U0001d7c9'\n             | '\\U0001d7cb'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -700,8 +696,8 @@ mod general_category {\n             | '\\uaadd'\n             | '\\uff70'\n             | '\\uff9e' to '\\uff9f'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -886,8 +882,8 @@ mod general_category {\n             | '\\U00012000' to '\\U0001236e'\n             | '\\U00013000' to '\\U0001b001'\n             | '\\U00020000' to '\\U0002fa1d'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -903,8 +899,8 @@ mod general_category {\n             | '\\u1fbc'\n             | '\\u1fcc'\n             | '\\u1ffc'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -1495,8 +1491,8 @@ mod general_category {\n             | '\\U0001d756' to '\\U0001d76e'\n             | '\\U0001d790' to '\\U0001d7a8'\n             | '\\U0001d7ca'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -1606,8 +1602,8 @@ mod general_category {\n             | '\\U000110b7' to '\\U000110b8'\n             | '\\U0001d165' to '\\U0001d166'\n             | '\\U0001d16d' to '\\U0001d172'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -1617,8 +1613,8 @@ mod general_category {\n             | '\\u20dd' to '\\u20e0'\n             | '\\u20e2' to '\\u20e4'\n             | '\\ua670' to '\\ua672'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -1810,8 +1806,8 @@ mod general_category {\n             | '\\U0001d1aa' to '\\U0001d1ad'\n             | '\\U0001d242' to '\\U0001d244'\n             | '\\U000e0100' to '\\U000e01ef'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -1854,8 +1850,8 @@ mod general_category {\n             | '\\U000104a0' to '\\U000104a9'\n             | '\\U00011066' to '\\U0001106f'\n             | '\\U0001d7ce' to '\\U0001d7ff'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -1873,8 +1869,8 @@ mod general_category {\n             | '\\U0001034a'\n             | '\\U000103d1' to '\\U000103d5'\n             | '\\U00012400' to '\\U00012462'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -1921,8 +1917,8 @@ mod general_category {\n             | '\\U00011052' to '\\U00011065'\n             | '\\U0001d360' to '\\U0001d371'\n             | '\\U0001f100' to '\\U0001f10a'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -1934,8 +1930,8 @@ mod general_category {\n             | '\\ufe33' to '\\ufe34'\n             | '\\ufe4d' to '\\ufe4f'\n             | '\\uff3f'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -1956,8 +1952,8 @@ mod general_category {\n             | '\\ufe58'\n             | '\\ufe63'\n             | '\\uff0d'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -2033,8 +2029,8 @@ mod general_category {\n             | '\\uff5d'\n             | '\\uff60'\n             | '\\uff63'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -2050,8 +2046,8 @@ mod general_category {\n             | '\\u2e0d'\n             | '\\u2e1d'\n             | '\\u2e21'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -2068,8 +2064,8 @@ mod general_category {\n             | '\\u2e0c'\n             | '\\u2e1c'\n             | '\\u2e20'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -2201,8 +2197,8 @@ mod general_category {\n             | '\\U000110bb' to '\\U000110bc'\n             | '\\U000110be' to '\\U000110c1'\n             | '\\U00012470' to '\\U00012473'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -2280,8 +2276,8 @@ mod general_category {\n             | '\\uff5b'\n             | '\\uff5f'\n             | '\\uff62'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -2303,8 +2299,8 @@ mod general_category {\n             | '\\uff04'\n             | '\\uffe0' to '\\uffe1'\n             | '\\uffe5' to '\\uffe6'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -2337,8 +2333,8 @@ mod general_category {\n             | '\\uff3e'\n             | '\\uff40'\n             | '\\uffe3'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -2408,8 +2404,8 @@ mod general_category {\n             | '\\U0001d789'\n             | '\\U0001d7a9'\n             | '\\U0001d7c3'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -2527,24 +2523,22 @@ mod general_category {\n             | '\\U0001d245' to '\\U0001d356'\n             | '\\U0001f000' to '\\U0001f0df'\n             | '\\U0001f110' to '\\U0001f773'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n     pure fn Zl(c: char) -> bool {\n         return alt c {\n-              '\\u2028'\n-              { true }\n-            _ { false }\n+          '\\u2028' => true,\n+          _ => false\n         };\n     }\n \n     pure fn Zp(c: char) -> bool {\n         return alt c {\n-              '\\u2029'\n-              { true }\n-            _ { false }\n+          '\\u2029' => true,\n+          _ => false\n         };\n     }\n \n@@ -2558,8 +2552,8 @@ mod general_category {\n             | '\\u202f'\n             | '\\u205f'\n             | '\\u3000'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -3299,8 +3293,8 @@ mod derived_property {\n             | '\\U0002a700' to '\\U0002b734'\n             | '\\U0002b740' to '\\U0002b81d'\n             | '\\U0002f800' to '\\U0002fa1d'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -4170,8 +4164,8 @@ mod derived_property {\n             | '\\U0002b740' to '\\U0002b81d'\n             | '\\U0002f800' to '\\U0002fa1d'\n             | '\\U000e0100' to '\\U000e01ef'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n \n@@ -4676,8 +4670,8 @@ mod derived_property {\n             | '\\U0002a700' to '\\U0002b734'\n             | '\\U0002b740' to '\\U0002b81d'\n             | '\\U0002f800' to '\\U0002fa1d'\n-              { true }\n-            _ { false }\n+          => true,\n+          _ => false\n         };\n     }\n "}, {"sha": "93bdd53d90d732885eaae79f9b3a386f17557f25", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -357,8 +357,8 @@ fn split<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     let mut result = ~[];\n     while start < ln {\n         alt position_between(v, start, ln, f) {\n-          none { break }\n-          some(i) {\n+          none => break,\n+          some(i) => {\n             push(result, slice(v, start, i));\n             start = i + 1u;\n           }\n@@ -381,8 +381,8 @@ fn splitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     let mut result = ~[];\n     while start < ln && count > 0u {\n         alt position_between(v, start, ln, f) {\n-          none { break }\n-          some(i) {\n+          none => break,\n+          some(i) => {\n             push(result, slice(v, start, i));\n             // Make sure to skip the separator.\n             start = i + 1u;\n@@ -406,8 +406,8 @@ fn rsplit<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     let mut result = ~[];\n     while end > 0u {\n         alt rposition_between(v, 0u, end, f) {\n-          none { break }\n-          some(i) {\n+          none => break,\n+          some(i) => {\n             push(result, slice(v, i + 1u, end));\n             end = i;\n           }\n@@ -430,8 +430,8 @@ fn rsplitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     let mut result = ~[];\n     while end > 0u && count > 0u {\n         alt rposition_between(v, 0u, end, f) {\n-          none { break }\n-          some(i) {\n+          none => break,\n+          some(i) => {\n             push(result, slice(v, i + 1u, end));\n             // Make sure to skip the separator.\n             end = i;\n@@ -714,8 +714,8 @@ pure fn filter_map<T, U: copy>(v: &[T], f: fn(T) -> option<U>)\n     let mut result = ~[];\n     for each(v) |elem| {\n         alt f(elem) {\n-          none {/* no-op */ }\n-          some(result_elem) { unsafe { push(result, result_elem); } }\n+          none => {/* no-op */ }\n+          some(result_elem) => unsafe { push(result, result_elem); }\n         }\n     }\n     return result;"}, {"sha": "e76d3093c17cec5266f7b82e12a053de44bbc213", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -31,15 +31,15 @@ impl of to_base64 for ~[u8] {\n         }\n \n         alt check len % 3u {\n-          0u { }\n-          1u {\n+          0u => (),\n+          1u => {\n             let n = (self[i] as uint) << 16u;\n             str::push_char(s, chars[(n >> 18u) & 63u]);\n             str::push_char(s, chars[(n >> 12u) & 63u]);\n             str::push_char(s, '=');\n             str::push_char(s, '=');\n           }\n-          2u {\n+          2u => {\n             let n = (self[i] as uint) << 16u | (self[i + 1u] as uint) << 8u;\n             str::push_char(s, chars[(n >> 18u) & 63u]);\n             str::push_char(s, chars[(n >> 12u) & 63u]);\n@@ -97,18 +97,16 @@ impl of from_base64 for ~[u8] {\n                     n |= 0x3Fu;\n                 } else if ch == '=' {\n                     alt len - i {\n-                      1u {\n+                      1u => {\n                         vec::push(r, ((n >> 16u) & 0xFFu) as u8);\n                         vec::push(r, ((n >> 8u ) & 0xFFu) as u8);\n                         return copy r;\n                       }\n-                      2u {\n+                      2u => {\n                         vec::push(r, ((n >> 10u) & 0xFFu) as u8);\n                         return copy r;\n                       }\n-                      _ {\n-                        fail ~\"invalid base64 padding\";\n-                      }\n+                      _ => fail ~\"invalid base64 padding\"\n                     }\n                 } else {\n                     fail ~\"invalid base64 character\";"}, {"sha": "de51e2b7f51074cffa99b7d47ca8a8fe12f6230d", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 38, "deletions": 60, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -180,35 +180,25 @@ class bitv {\n                 self.die();\n             }\n             alt self.rep {\n-              small(s) {\n-                alt other.rep {\n-                  small(s1) {\n-                    alt op {\n-                      union      { s.union(s1) }\n-                      intersect  { s.intersect(s1) }\n-                      assign     { s.become(s1) }\n-                      difference { s.difference(s1) }\n-                    }\n-                  }\n-                 big(s1) {\n-                     self.die();\n-                 }\n+              small(s) => alt other.rep {\n+                small(s1) => alt op {\n+                  union      => s.union(s1),\n+                  intersect  => s.intersect(s1),\n+                  assign     => s.become(s1),\n+                  difference => s.difference(s1)\n+                }\n+                big(s1) => self.die()\n               }\n-            }\n-            big(s) {\n-                alt other.rep {\n-                  small(_) { self.die(); }\n-                  big(s1) {\n-                    alt op {\n-                      union      { s.union(s1) }\n-                      intersect  { s.intersect(s1) }\n-                      assign     { s.become(s1) }\n-                      difference { s.difference(s1) }\n-                    }\n-                  }\n+              big(s) => alt other.rep {\n+                small(_) => self.die(),\n+                big(s1) => alt op {\n+                  union      => s.union(s1),\n+                  intersect  => s.intersect(s1),\n+                  assign     => s.become(s1),\n+                  difference => s.difference(s1)\n                 }\n+              }\n             }\n-          }\n         }\n     }\n \n@@ -243,10 +233,10 @@ class bitv {\n     #[inline(always)]\n     fn clone() -> ~bitv {\n         ~alt self.rep {\n-          small(b) {\n+          small(b) => {\n             bitv{nbits: self.nbits, rep: small(~small_bitv{bits: b.bits})}\n           }\n-          big(b) {\n+          big(b) => {\n             let st = to_mut(from_elem(self.nbits / uint_bits + 1, 0));\n             let len = st.len();\n             for uint::range(0, len) |i| { st[i] = b.storage[i]; };\n@@ -260,8 +250,8 @@ class bitv {\n     pure fn get(i: uint) -> bool {\n        assert (i < self.nbits);\n        alt self.rep {\n-         big(b)   { b.get(i) }\n-         small(s) { s.get(i) }\n+         big(b)   => b.get(i),\n+         small(s) => s.get(i)\n        }\n     }\n \n@@ -274,8 +264,8 @@ class bitv {\n     fn set(i: uint, x: bool) {\n       assert (i < self.nbits);\n       alt self.rep {\n-        big(b) { b.set(i, x); }\n-        small(s) { s.set(i, x); }\n+        big(b)   => b.set(i, x),\n+        small(s) => s.set(i, x)\n       }\n     }\n \n@@ -289,19 +279,13 @@ class bitv {\n     fn equal(v1: bitv) -> bool {\n       if self.nbits != v1.nbits { return false; }\n       alt self.rep {\n-        small(b) {\n-          alt v1.rep {\n-            small(b1) { b.equals(b1) }\n-            _ { false }\n-          }\n+        small(b) => alt v1.rep {\n+          small(b1) => b.equals(b1),\n+          _ => false\n         }\n-        big(s) {\n-          alt v1.rep {\n-            big(s1) {\n-              s.equals(s1)\n-            }\n-            small(_) { return false; }\n-          }\n+        big(s) => alt v1.rep {\n+          big(s1) => s.equals(s1),\n+          small(_) => return false\n         }\n       }\n     }\n@@ -310,31 +294,25 @@ class bitv {\n     #[inline(always)]\n     fn clear() {\n         alt self.rep {\n-          small(b) { b.clear(); }\n-          big(s) {\n-            for s.each_storage() |w| { w = 0u }\n-          }\n+          small(b) => b.clear(),\n+          big(s) => for s.each_storage() |w| { w = 0u }\n         }\n     }\n \n     /// Set all bits to 1\n     #[inline(always)]\n     fn set_all() {\n       alt self.rep {\n-        small(b) { b.set_all(); }\n-        big(s) {\n-          for s.each_storage() |w| { w = !0u } }\n-      }\n+        small(b) => b.set_all(),\n+        big(s) => for s.each_storage() |w| { w = !0u } }\n     }\n \n     /// Invert all bits\n     #[inline(always)]\n     fn invert() {\n       alt self.rep {\n-        small(b) { b.invert(); }\n-        big(s) {\n-          for s.each_storage() |w| { w = !w } }\n-      }\n+        small(b) => b.invert(),\n+        big(s) => for s.each_storage() |w| { w = !w } }\n     }\n \n /**\n@@ -352,8 +330,8 @@ class bitv {\n     #[inline(always)]\n     fn is_true() -> bool {\n       alt self.rep {\n-        small(b) { b.is_true() }\n-        _ {\n+        small(b) => b.is_true(),\n+        _ => {\n           for self.each() |i| { if !i { return false; } }\n           true\n         }\n@@ -373,8 +351,8 @@ class bitv {\n \n     fn is_false() -> bool {\n       alt self.rep {\n-        small(b) { b.is_false() }\n-        big(_) {\n+        small(b) => b.is_false(),\n+        big(_) => {\n           for self.each() |i| { if i { return false; } }\n           true\n         }"}, {"sha": "e00ee13949b9bfe63fbc3c66d140b62d845c1a56", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -47,8 +47,8 @@ class dtor_res {\n   new(dtor: option<fn@()>) { self.dtor = dtor; }\n   drop {\n     alt self.dtor {\n-      option::none { }\n-      option::some(f) { f(); }\n+      option::none => (),\n+      option::some(f) => f()\n     }\n   }\n }"}, {"sha": "5e98f3c705475c418dd53db203faa31b225f0b81", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -41,7 +41,7 @@ fn create<T: copy>() -> t<T> {\n         return rv;\n     }\n     fn get<T: copy>(elts: dvec<cell<T>>, i: uint) -> T {\n-        alt elts.get_elt(i) { some(t) { t } _ { fail } }\n+        alt elts.get_elt(i) { some(t) => t, _ => fail }\n     }\n \n     type repr<T> = {mut nelts: uint,\n@@ -239,45 +239,35 @@ mod tests {\n         fn intboxeq(&&a: @int, &&b: @int) -> bool { return a == b; }\n         fn taggyeq(a: taggy, b: taggy) -> bool {\n             alt a {\n-              one(a1) {\n-                alt b { one(b1) {return a1 == b1; } _ { return false; } }\n+              one(a1) => alt b {\n+                one(b1) => return a1 == b1,\n+                _ => return false\n               }\n-              two(a1, a2) {\n-                alt b {\n-                  two(b1, b2) { return a1 == b1 && a2 == b2; }\n-                  _ { return false; }\n-                }\n+              two(a1, a2) => alt b {\n+                two(b1, b2) => return a1 == b1 && a2 == b2,\n+                _ => return false\n               }\n-              three(a1, a2, a3) {\n-                alt b {\n-                  three(b1, b2, b3) {\n-                    return a1 == b1 && a2 == b2 && a3 == b3;\n-                  }\n-                  _ { return false; }\n-                }\n+              three(a1, a2, a3) => alt b {\n+                three(b1, b2, b3) => return a1 == b1 && a2 == b2 && a3 == b3,\n+                _ => return false\n               }\n             }\n         }\n         fn taggypareq<T>(a: taggypar<T>, b: taggypar<T>) -> bool {\n             alt a {\n-              onepar::<T>(a1) {\n-                alt b {\n-                  onepar::<T>(b1) { return a1 == b1; } _ { return false; }\n-                }\n+              onepar::<T>(a1) => alt b {\n+                onepar::<T>(b1) => return a1 == b1,\n+                _ => return false\n               }\n-              twopar::<T>(a1, a2) {\n-                alt b {\n-                  twopar::<T>(b1, b2) { return a1 == b1 && a2 == b2; }\n-                  _ { return false; }\n-                }\n+              twopar::<T>(a1, a2) => alt b {\n+                twopar::<T>(b1, b2) => return a1 == b1 && a2 == b2,\n+                _ => return false\n               }\n-              threepar::<T>(a1, a2, a3) {\n-                alt b {\n-                  threepar::<T>(b1, b2, b3) {\n-                    return a1 == b1 && a2 == b2 && a3 == b3;\n-                  }\n-                  _ { return false; }\n+              threepar::<T>(a1, a2, a3) => alt b {\n+                threepar::<T>(b1, b2, b3) => {\n+                    return a1 == b1 && a2 == b2 && a3 == b3\n                 }\n+                _ => return false\n               }\n             }\n         }"}, {"sha": "78ec45659ccfe99d596f916a4b39e5aa343ff9f1", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -114,8 +114,8 @@ fn maybe_get_doc(d: doc, tg: uint) -> option<doc> {\n \n fn get_doc(d: doc, tg: uint) -> doc {\n     alt maybe_get_doc(d, tg) {\n-      some(d) { return d; }\n-      none {\n+      some(d) => return d,\n+      none => {\n         error!{\"failed to find block with tag %u\", tg};\n         fail;\n       }\n@@ -190,21 +190,13 @@ enum writer {\n \n fn write_sized_vuint(w: io::writer, n: uint, size: uint) {\n     alt size {\n-      1u {\n-        w.write(&[0x80u8 | (n as u8)]);\n-      }\n-      2u {\n-        w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]);\n-      }\n-      3u {\n-        w.write(&[0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n-                 n as u8]);\n-      }\n-      4u {\n-        w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n-                 (n >> 8_u) as u8, n as u8]);\n-      }\n-      _ { fail fmt!{\"vint to write too big: %?\", n}; }\n+      1u => w.write(&[0x80u8 | (n as u8)]),\n+      2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n+      3u => w.write(&[0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n+                      n as u8]),\n+      4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n+                      (n >> 8_u) as u8, n as u8]),\n+      _ => fail fmt!{\"vint to write too big: %?\", n}\n     };\n }\n \n@@ -602,10 +594,9 @@ fn test_option_int() {\n     fn serialize_0<S: serialization::serializer>(s: S, v: option<int>) {\n         do s.emit_enum(~\"core::option::t\") {\n             alt v {\n-              none {\n-                s.emit_enum_variant(~\"core::option::none\", 0u, 0u, || { } );\n-              }\n-              some(v0) {\n+              none => s.emit_enum_variant(\n+                  ~\"core::option::none\", 0u, 0u, || { } ),\n+              some(v0) => {\n                 do s.emit_enum_variant(~\"core::option::some\", 1u, 1u) {\n                     s.emit_enum_variant_arg(0u, || serialize_1(s, v0));\n                 }\n@@ -622,8 +613,8 @@ fn test_option_int() {\n         do s.read_enum(~\"core::option::t\") {\n             do s.read_enum_variant |i| {\n                 alt check i {\n-                  0u { none }\n-                  1u {\n+                  0u => none,\n+                  1u => {\n                     let v0 = do s.read_enum_variant_arg(0u) {\n                         deserialize_1(s)\n                     };"}, {"sha": "e849d77ded6dcdffce26b9300655f05847e2e919", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -31,8 +31,8 @@ fn init<K, V>() -> treemap<K, V> { @empty }\n /// Insert a value into the map\n fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n     @alt m {\n-       @empty { node(@k, @v, @empty, @empty) }\n-       @node(@kk, vv, left, right) {\n+       @empty => node(@k, @v, @empty, @empty),\n+       @node(@kk, vv, left, right) => {\n          if k < kk {\n              node(@kk, vv, insert(left, k, v), right)\n          } else if k == kk {\n@@ -45,8 +45,8 @@ fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n /// Find a value based on the key\n fn find<K, V: copy>(m: treemap<K, V>, k: K) -> option<V> {\n     alt *m {\n-      empty { none }\n-      node(@kk, @v, left, right) {\n+      empty => none,\n+      node(@kk, @v, left, right) => {\n         if k == kk {\n             some(v)\n         } else if k < kk { find(left, k) } else { find(right, k) }\n@@ -57,13 +57,13 @@ fn find<K, V: copy>(m: treemap<K, V>, k: K) -> option<V> {\n /// Visit all pairs in the map in order.\n fn traverse<K, V: copy>(m: treemap<K, V>, f: fn(K, V)) {\n     alt *m {\n-      empty { }\n+      empty => (),\n       /*\n         Previously, this had what looked like redundant\n         matches to me, so I changed it. but that may be a\n         de-optimization -- tjc\n        */\n-      node(@k, @v, left, right) {\n+      node(@k, @v, left, right) => {\n         // copy v to make aliases work out\n         let v1 = v;\n         traverse(left, f);"}, {"sha": "c05c685daa8f5877587e5beb5d135b60cfe8a56a", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 113, "deletions": 113, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -140,7 +140,10 @@ fn is_arg(arg: ~str) -> bool {\n }\n \n fn name_str(nm: name) -> ~str {\n-    return alt nm { short(ch) { str::from_char(ch) } long(s) { s } };\n+    return alt nm {\n+      short(ch) => str::from_char(ch),\n+      long(s) => s\n+    };\n }\n \n fn find_opt(opts: ~[opt], nm: name) -> option<uint> {\n@@ -162,18 +165,14 @@ enum fail_ {\n /// Convert a `fail_` enum into an error string\n fn fail_str(f: fail_) -> ~str {\n     return alt f {\n-          argument_missing(nm) {\n-            ~\"Argument to option '\" + nm + ~\"' missing.\"\n-          }\n-          unrecognized_option(nm) { ~\"Unrecognized option: '\" + nm + ~\"'.\" }\n-          option_missing(nm) { ~\"Required option '\" + nm + ~\"' missing.\" }\n-          option_duplicated(nm) {\n-            ~\"Option '\" + nm + ~\"' given more than once.\"\n-          }\n-          unexpected_argument(nm) {\n-            ~\"Option \" + nm + ~\" does not take an argument.\"\n-          }\n-        };\n+      argument_missing(nm) => ~\"Argument to option '\" + nm + ~\"' missing.\",\n+      unrecognized_option(nm) => ~\"Unrecognized option: '\" + nm + ~\"'.\",\n+      option_missing(nm) => ~\"Required option '\" + nm + ~\"' missing.\",\n+      option_duplicated(nm) => ~\"Option '\" + nm + ~\"' given more than once.\",\n+      unexpected_argument(nm) => {\n+        ~\"Option \" + nm + ~\" does not take an argument.\"\n+      }\n+    };\n }\n \n /**\n@@ -235,15 +234,13 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n                     */\n \n                     alt find_opt(opts, opt) {\n-                      some(id) {\n-                        last_valid_opt_id = option::some(id);\n-                      }\n-                      none {\n+                      some(id) => last_valid_opt_id = option::some(id),\n+                      none => {\n                         let arg_follows =\n                             option::is_some(last_valid_opt_id) &&\n                             alt opts[option::get(last_valid_opt_id)].hasarg {\n-                              yes | maybe { true }\n-                              no { false }\n+                              yes | maybe => true,\n+                              no => false\n                             };\n                         if arg_follows && j + 1 < curlen {\n                             i_arg = option::some(str::slice(cur, j, curlen));\n@@ -261,25 +258,25 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n             for vec::each(names) |nm| {\n                 name_pos += 1u;\n                 let optid = alt find_opt(opts, nm) {\n-                  some(id) { id }\n-                  none { return err(unrecognized_option(name_str(nm))); }\n+                  some(id) => id,\n+                  none => return err(unrecognized_option(name_str(nm)))\n                 };\n                 alt opts[optid].hasarg {\n-                  no {\n+                  no => {\n                     if !option::is_none::<~str>(i_arg) {\n                         return err(unexpected_argument(name_str(nm)));\n                     }\n                     vec::push(vals[optid], given);\n                   }\n-                  maybe {\n+                  maybe => {\n                     if !option::is_none::<~str>(i_arg) {\n                         vec::push(vals[optid], val(option::get(i_arg)));\n                     } else if name_pos < vec::len::<name>(names) ||\n                                   i + 1u == l || is_arg(args[i + 1u]) {\n                         vec::push(vals[optid], given);\n                     } else { i += 1u; vec::push(vals[optid], val(args[i])); }\n                   }\n-                  yes {\n+                  yes => {\n                     if !option::is_none::<~str>(i_arg) {\n                         vec::push(vals[optid],\n                                   val(option::get::<~str>(i_arg)));\n@@ -313,9 +310,12 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n \n fn opt_vals(m: matches, nm: ~str) -> ~[optval] {\n     return alt find_opt(m.opts, mkname(nm)) {\n-          some(id) { m.vals[id] }\n-          none { error!{\"No option '%s' defined\", nm}; fail }\n-        };\n+      some(id) => m.vals[id],\n+      none => {\n+        error!{\"No option '%s' defined\", nm};\n+        fail\n+      }\n+    };\n }\n \n fn opt_val(m: matches, nm: ~str) -> optval { return opt_vals(m, nm)[0]; }\n@@ -329,8 +329,8 @@ fn opt_present(m: matches, nm: ~str) -> bool {\n fn opts_present(m: matches, names: ~[~str]) -> bool {\n     for vec::each(names) |nm| {\n         alt find_opt(m.opts, mkname(nm)) {\n-          some(_) { return true; }\n-          _ { }\n+          some(_) => return true,\n+          _ => ()\n         }\n     }\n     return false;\n@@ -344,7 +344,7 @@ fn opts_present(m: matches, names: ~[~str]) -> bool {\n  * argument\n  */\n fn opt_str(m: matches, nm: ~str) -> ~str {\n-    return alt opt_val(m, nm) { val(s) { s } _ { fail } };\n+    return alt opt_val(m, nm) { val(s) => s, _ => fail };\n }\n \n /**\n@@ -356,8 +356,8 @@ fn opt_str(m: matches, nm: ~str) -> ~str {\n fn opts_str(m: matches, names: ~[~str]) -> ~str {\n     for vec::each(names) |nm| {\n         alt opt_val(m, nm) {\n-          val(s) { return s }\n-          _ {  }\n+          val(s) => return s,\n+          _ => ()\n         }\n     }\n     fail;\n@@ -373,7 +373,7 @@ fn opts_str(m: matches, names: ~[~str]) -> ~str {\n fn opt_strs(m: matches, nm: ~str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n     for vec::each(opt_vals(m, nm)) |v| {\n-        alt v { val(s) { vec::push(acc, s); } _ { } }\n+        alt v { val(s) => vec::push(acc, s), _ => () }\n     }\n     return acc;\n }\n@@ -382,7 +382,7 @@ fn opt_strs(m: matches, nm: ~str) -> ~[~str] {\n fn opt_maybe_str(m: matches, nm: ~str) -> option<~str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { return none::<~str>; }\n-    return alt vals[0] { val(s) { some::<~str>(s) } _ { none::<~str> } };\n+    return alt vals[0] { val(s) => some::<~str>(s), _ => none::<~str> };\n }\n \n \n@@ -396,7 +396,7 @@ fn opt_maybe_str(m: matches, nm: ~str) -> option<~str> {\n fn opt_default(m: matches, nm: ~str, def: ~str) -> option<~str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { return none::<~str>; }\n-    return alt vals[0] { val(s) { some::<~str>(s) } _ { some::<~str>(def) } }\n+    return alt vals[0] { val(s) => some::<~str>(s), _ => some::<~str>(def) }\n }\n \n #[cfg(test)]\n@@ -414,11 +414,11 @@ mod tests {\n \n     fn check_fail_type(f: fail_, ft: fail_type) {\n         alt f {\n-          argument_missing(_) { assert (ft == argument_missing_); }\n-          unrecognized_option(_) { assert (ft == unrecognized_option_); }\n-          option_missing(_) { assert (ft == option_missing_); }\n-          option_duplicated(_) { assert (ft == option_duplicated_); }\n-          unexpected_argument(_) { assert (ft == unexpected_argument_); }\n+          argument_missing(_) => assert ft == argument_missing_,\n+          unrecognized_option(_) => assert ft == unrecognized_option_,\n+          option_missing(_) => assert ft == option_missing_,\n+          option_duplicated(_) => assert ft == option_duplicated_,\n+          unexpected_argument(_) => assert ft == unexpected_argument_\n         }\n     }\n \n@@ -430,7 +430,7 @@ mod tests {\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n         alt check rs {\n-          ok(m) {\n+          ok(m) => {\n             assert (opt_present(m, ~\"test\"));\n             assert (opt_str(m, ~\"test\") == ~\"20\");\n           }\n@@ -443,8 +443,8 @@ mod tests {\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) { check_fail_type(f, option_missing_); }\n-          _ { fail; }\n+          err(f) => check_fail_type(f, option_missing_),\n+          _ => fail\n         }\n     }\n \n@@ -454,8 +454,8 @@ mod tests {\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) { check_fail_type(f, argument_missing_); }\n-          _ { fail; }\n+          err(f) => check_fail_type(f, argument_missing_),\n+          _ => fail\n         }\n     }\n \n@@ -465,8 +465,8 @@ mod tests {\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) { check_fail_type(f, option_duplicated_); }\n-          _ { fail; }\n+          err(f) => check_fail_type(f, option_duplicated_),\n+          _ => fail\n         }\n     }\n \n@@ -476,11 +476,11 @@ mod tests {\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) {\n+          ok(m) => {\n             assert (opt_present(m, ~\"t\"));\n             assert (opt_str(m, ~\"t\") == ~\"20\");\n           }\n-          _ { fail; }\n+          _ => fail\n         }\n     }\n \n@@ -490,8 +490,8 @@ mod tests {\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) { check_fail_type(f, option_missing_); }\n-          _ { fail; }\n+          err(f) => check_fail_type(f, option_missing_),\n+          _ => fail\n         }\n     }\n \n@@ -501,8 +501,8 @@ mod tests {\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) { check_fail_type(f, argument_missing_); }\n-          _ { fail; }\n+          err(f) => check_fail_type(f, argument_missing_),\n+          _ => fail\n         }\n     }\n \n@@ -512,8 +512,8 @@ mod tests {\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) { check_fail_type(f, option_duplicated_); }\n-          _ { fail; }\n+          err(f) => check_fail_type(f, option_duplicated_),\n+          _ => fail\n         }\n     }\n \n@@ -525,11 +525,11 @@ mod tests {\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) {\n+          ok(m) => {\n             assert (opt_present(m, ~\"test\"));\n             assert (opt_str(m, ~\"test\") == ~\"20\");\n           }\n-          _ { fail; }\n+          _ => fail\n         }\n     }\n \n@@ -539,8 +539,8 @@ mod tests {\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) { assert (!opt_present(m, ~\"test\")); }\n-          _ { fail; }\n+          ok(m) => assert (!opt_present(m, ~\"test\")),\n+          _ => fail\n         }\n     }\n \n@@ -550,8 +550,8 @@ mod tests {\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) { check_fail_type(f, argument_missing_); }\n-          _ { fail; }\n+          err(f) => check_fail_type(f, argument_missing_),\n+          _ => fail\n         }\n     }\n \n@@ -561,8 +561,8 @@ mod tests {\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) { check_fail_type(f, option_duplicated_); }\n-          _ { fail; }\n+          err(f) => check_fail_type(f, option_duplicated_),\n+          _ => fail\n         }\n     }\n \n@@ -572,11 +572,11 @@ mod tests {\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) {\n+          ok(m) => {\n             assert (opt_present(m, ~\"t\"));\n             assert (opt_str(m, ~\"t\") == ~\"20\");\n           }\n-          _ { fail; }\n+          _ => fail\n         }\n     }\n \n@@ -586,8 +586,8 @@ mod tests {\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) { assert (!opt_present(m, ~\"t\")); }\n-          _ { fail; }\n+          ok(m) => assert (!opt_present(m, ~\"t\")),\n+          _ => fail\n         }\n     }\n \n@@ -597,8 +597,8 @@ mod tests {\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) { check_fail_type(f, argument_missing_); }\n-          _ { fail; }\n+          err(f) => check_fail_type(f, argument_missing_),\n+          _ => fail\n         }\n     }\n \n@@ -608,8 +608,8 @@ mod tests {\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) { check_fail_type(f, option_duplicated_); }\n-          _ { fail; }\n+          err(f) => check_fail_type(f, option_duplicated_),\n+          _ => fail\n         }\n     }\n \n@@ -621,8 +621,8 @@ mod tests {\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) { assert (opt_present(m, ~\"test\")); }\n-          _ { fail; }\n+          ok(m) => assert (opt_present(m, ~\"test\")),\n+          _ => fail\n         }\n     }\n \n@@ -632,8 +632,8 @@ mod tests {\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) { assert (!opt_present(m, ~\"test\")); }\n-          _ { fail; }\n+          ok(m) => assert (!opt_present(m, ~\"test\")),\n+          _ => fail\n         }\n     }\n \n@@ -643,11 +643,11 @@ mod tests {\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) {\n+          err(f) => {\n             log(error, fail_str(f));\n             check_fail_type(f, unexpected_argument_);\n           }\n-          _ { fail; }\n+          _ => fail\n         }\n     }\n \n@@ -657,8 +657,8 @@ mod tests {\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) { check_fail_type(f, option_duplicated_); }\n-          _ { fail; }\n+          err(f) => check_fail_type(f, option_duplicated_),\n+          _ => fail\n         }\n     }\n \n@@ -668,8 +668,8 @@ mod tests {\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) { assert (opt_present(m, ~\"t\")); }\n-          _ { fail; }\n+          ok(m) => assert (opt_present(m, ~\"t\")),\n+          _ => fail\n         }\n     }\n \n@@ -679,8 +679,8 @@ mod tests {\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) { assert (!opt_present(m, ~\"t\")); }\n-          _ { fail; }\n+          ok(m) => assert (!opt_present(m, ~\"t\")),\n+          _ => fail\n         }\n     }\n \n@@ -690,12 +690,12 @@ mod tests {\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) {\n+          ok(m) => {\n             // The next variable after the flag is just a free argument\n \n             assert (m.free[0] == ~\"20\");\n           }\n-          _ { fail; }\n+          _ => fail\n         }\n     }\n \n@@ -705,8 +705,8 @@ mod tests {\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) { check_fail_type(f, option_duplicated_); }\n-          _ { fail; }\n+          err(f) => check_fail_type(f, option_duplicated_),\n+          _ => fail\n         }\n     }\n \n@@ -718,11 +718,11 @@ mod tests {\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) {\n+          ok(m) => {\n             assert (opt_present(m, ~\"test\"));\n             assert (opt_str(m, ~\"test\") == ~\"20\");\n           }\n-          _ { fail; }\n+          _ => fail\n         }\n     }\n \n@@ -732,8 +732,8 @@ mod tests {\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) { assert (!opt_present(m, ~\"test\")); }\n-          _ { fail; }\n+          ok(m) => assert (!opt_present(m, ~\"test\")),\n+          _ => fail\n         }\n     }\n \n@@ -743,8 +743,8 @@ mod tests {\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) { check_fail_type(f, argument_missing_); }\n-          _ { fail; }\n+          err(f) => check_fail_type(f, argument_missing_),\n+          _ => fail\n         }\n     }\n \n@@ -754,13 +754,13 @@ mod tests {\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) {\n+          ok(m) => {\n             assert (opt_present(m, ~\"test\"));\n             assert (opt_str(m, ~\"test\") == ~\"20\");\n             assert (opt_strs(m, ~\"test\")[0] == ~\"20\");\n             assert (opt_strs(m, ~\"test\")[1] == ~\"30\");\n           }\n-          _ { fail; }\n+          _ => fail\n         }\n     }\n \n@@ -770,11 +770,11 @@ mod tests {\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) {\n+          ok(m) => {\n             assert (opt_present(m, ~\"t\"));\n             assert (opt_str(m, ~\"t\") == ~\"20\");\n           }\n-          _ { fail; }\n+          _ => fail\n         }\n     }\n \n@@ -784,8 +784,8 @@ mod tests {\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) { assert (!opt_present(m, ~\"t\")); }\n-          _ { fail; }\n+          ok(m) => assert (!opt_present(m, ~\"t\")),\n+          _ => fail\n         }\n     }\n \n@@ -795,8 +795,8 @@ mod tests {\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) { check_fail_type(f, argument_missing_); }\n-          _ { fail; }\n+          err(f) => check_fail_type(f, argument_missing_),\n+          _ => fail\n         }\n     }\n \n@@ -806,13 +806,13 @@ mod tests {\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) {\n+          ok(m) => {\n             assert (opt_present(m, ~\"t\"));\n             assert (opt_str(m, ~\"t\") == ~\"20\");\n             assert (opt_strs(m, ~\"t\")[0] == ~\"20\");\n             assert (opt_strs(m, ~\"t\")[1] == ~\"30\");\n           }\n-          _ { fail; }\n+          _ => fail\n         }\n     }\n \n@@ -822,8 +822,8 @@ mod tests {\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) { check_fail_type(f, unrecognized_option_); }\n-          _ { fail; }\n+          err(f) => check_fail_type(f, unrecognized_option_),\n+          _ => fail\n         }\n     }\n \n@@ -833,8 +833,8 @@ mod tests {\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          err(f) { check_fail_type(f, unrecognized_option_); }\n-          _ { fail; }\n+          err(f) => check_fail_type(f, unrecognized_option_),\n+          _ => fail\n         }\n     }\n \n@@ -850,7 +850,7 @@ mod tests {\n              optopt(~\"notpresent\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) {\n+          ok(m) => {\n             assert (m.free[0] == ~\"prog\");\n             assert (m.free[1] == ~\"free1\");\n             assert (opt_str(m, ~\"s\") == ~\"20\");\n@@ -864,7 +864,7 @@ mod tests {\n             assert (opt_strs(m, ~\"n\")[1] == ~\"-60 70\");\n             assert (!opt_present(m, ~\"notpresent\"));\n           }\n-          _ { fail; }\n+          _ => fail\n         }\n     }\n \n@@ -873,8 +873,8 @@ mod tests {\n         let args = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n         let opts = ~[optopt(~\"e\"), optopt(~\"encrypt\")];\n         let matches = alt getopts(args, opts) {\n-          result::ok(m) { m }\n-          result::err(f) { fail; }\n+          result::ok(m) => m,\n+          result::err(f) => fail\n         };\n         assert opts_present(matches, ~[~\"e\"]);\n         assert opts_present(matches, ~[~\"encrypt\"]);\n@@ -894,8 +894,8 @@ mod tests {\n         let args = ~[~\"-Lfoo\"];\n         let opts = ~[optmulti(~\"L\")];\n         let matches = alt getopts(args, opts) {\n-          result::ok(m) { m }\n-          result::err(f) { fail; }\n+          result::ok(m) => m,\n+          result::err(f) => fail\n         };\n         assert opts_present(matches, ~[~\"L\"]);\n         assert opts_str(matches, ~[~\"L\"]) == ~\"foo\";"}, {"sha": "82a0f7d80845b32b4d204e42254156bb5e36dc99", "filename": "src/libstd/json.rs", "status": "modified", "additions": 85, "deletions": 94, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -46,14 +46,10 @@ type error = {\n /// Serializes a json value into a io::writer\n fn to_writer(wr: io::writer, j: json) {\n     alt j {\n-      num(n) { wr.write_str(float::to_str(n, 6u)); }\n-      string(s) {\n-        wr.write_str(escape_str(*s));\n-      }\n-      boolean(b) {\n-        wr.write_str(if b { ~\"true\" } else { ~\"false\" });\n-      }\n-      list(v) {\n+      num(n) => wr.write_str(float::to_str(n, 6u)),\n+      string(s) => wr.write_str(escape_str(*s)),\n+      boolean(b) => wr.write_str(if b { ~\"true\" } else { ~\"false\" }),\n+      list(v) => {\n         wr.write_char('[');\n         let mut first = true;\n         for (*v).each |item| {\n@@ -65,7 +61,7 @@ fn to_writer(wr: io::writer, j: json) {\n         };\n         wr.write_char(']');\n       }\n-      dict(d) {\n+      dict(d) => {\n         if d.size() == 0u {\n             wr.write_str(~\"{}\");\n             return;\n@@ -84,24 +80,22 @@ fn to_writer(wr: io::writer, j: json) {\n         };\n         wr.write_str(~\" }\");\n       }\n-      null {\n-        wr.write_str(~\"null\");\n-      }\n+      null => wr.write_str(~\"null\")\n     }\n }\n \n fn escape_str(s: ~str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n     do str::chars_iter(s) |c| {\n         alt c {\n-          '\"' { escaped += ~\"\\\\\\\"\"; }\n-          '\\\\' { escaped += ~\"\\\\\\\\\"; }\n-          '\\x08' { escaped += ~\"\\\\b\"; }\n-          '\\x0c' { escaped += ~\"\\\\f\"; }\n-          '\\n' { escaped += ~\"\\\\n\"; }\n-          '\\r' { escaped += ~\"\\\\r\"; }\n-          '\\t' { escaped += ~\"\\\\t\"; }\n-          _ { escaped += str::from_char(c); }\n+          '\"' => escaped += ~\"\\\\\\\"\",\n+          '\\\\' => escaped += ~\"\\\\\\\\\",\n+          '\\x08' => escaped += ~\"\\\\b\",\n+          '\\x0c' => escaped += ~\"\\\\f\",\n+          '\\n' => escaped += ~\"\\\\n\",\n+          '\\r' => escaped += ~\"\\\\r\",\n+          '\\t' => escaped += ~\"\\\\t\",\n+          _ => escaped += str::from_char(c)\n         }\n     };\n \n@@ -151,7 +145,7 @@ impl parser for parser {\n \n     fn parse() -> result<json, error> {\n         alt self.parse_value() {\n-          ok(value) {\n+          ok(value) => {\n             // Skip trailing whitespaces.\n             self.parse_whitespace();\n             // Make sure there is no trailing characters.\n@@ -161,7 +155,7 @@ impl parser for parser {\n                 self.error(~\"trailing characters\")\n             }\n           }\n-          e { e }\n+          e => e\n         }\n     }\n \n@@ -171,19 +165,17 @@ impl parser for parser {\n         if self.eof() { return self.error(~\"EOF while parsing value\"); }\n \n         alt self.ch {\n-          'n' { self.parse_ident(~\"ull\", null) }\n-          't' { self.parse_ident(~\"rue\", boolean(true)) }\n-          'f' { self.parse_ident(~\"alse\", boolean(false)) }\n-          '0' to '9' | '-' { self.parse_number() }\n-          '\"' {\n-              alt self.parse_str() {\n-                ok(s) { ok(string(s)) }\n-                err(e) { err(e) }\n-              }\n+          'n' => self.parse_ident(~\"ull\", null),\n+          't' => self.parse_ident(~\"rue\", boolean(true)),\n+          'f' => self.parse_ident(~\"alse\", boolean(false)),\n+          '0' to '9' | '-' => self.parse_number(),\n+          '\"' => alt self.parse_str() {\n+            ok(s) => ok(string(s)),\n+            err(e) => err(e)\n           }\n-          '[' { self.parse_list() }\n-          '{' { self.parse_object() }\n-          _ { self.error(~\"invalid syntax\") }\n+          '[' => self.parse_list(),\n+          '{' => self.parse_object(),\n+          _ => self.error(~\"invalid syntax\")\n         }\n     }\n \n@@ -209,21 +201,21 @@ impl parser for parser {\n         }\n \n         let mut res = alt self.parse_integer() {\n-          ok(res) { res }\n-          err(e) { return err(e); }\n+          ok(res) => res,\n+          err(e) => return err(e)\n         };\n \n         if self.ch == '.' {\n             alt self.parse_decimal(res) {\n-              ok(r) { res = r; }\n-              err(e) { return err(e); }\n+              ok(r) => res = r,\n+              err(e) => return err(e)\n             }\n         }\n \n         if self.ch == 'e' || self.ch == 'E' {\n             alt self.parse_exponent(res) {\n-              ok(r) { res = r; }\n-              err(e) { return err(e); }\n+              ok(r) => res = r,\n+              err(e) => return err(e)\n             }\n         }\n \n@@ -234,29 +226,29 @@ impl parser for parser {\n         let mut res = 0f;\n \n         alt self.ch {\n-          '0' {\n+          '0' => {\n             self.bump();\n \n             // There can be only one leading '0'.\n             alt self.ch {\n-              '0' to '9' { return self.error(~\"invalid number\"); }\n-              _ {}\n+              '0' to '9' => return self.error(~\"invalid number\"),\n+              _ => ()\n             }\n           }\n-          '1' to '9' {\n+          '1' to '9' => {\n             while !self.eof() {\n                 alt self.ch {\n-                  '0' to '9' {\n+                  '0' to '9' => {\n                     res *= 10f;\n                     res += ((self.ch as int) - ('0' as int)) as float;\n \n                     self.bump();\n                   }\n-                  _ { break; }\n+                  _ => break\n                 }\n             }\n           }\n-          _ { return self.error(~\"invalid number\"); }\n+          _ => return self.error(~\"invalid number\")\n         }\n \n         ok(res)\n@@ -267,21 +259,21 @@ impl parser for parser {\n \n         // Make sure a digit follows the decimal place.\n         alt self.ch {\n-          '0' to '9' {}\n-          _ { return self.error(~\"invalid number\"); }\n+          '0' to '9' => (),\n+          _ => return self.error(~\"invalid number\")\n         }\n \n         let mut res = res;\n         let mut dec = 1f;\n         while !self.eof() {\n             alt self.ch {\n-              '0' to '9' {\n+              '0' to '9' => {\n                 dec /= 10f;\n                 res += (((self.ch as int) - ('0' as int)) as float) * dec;\n \n                 self.bump();\n               }\n-              _ { break; }\n+              _ => break\n             }\n         }\n \n@@ -296,26 +288,26 @@ impl parser for parser {\n         let mut neg_exp = false;\n \n         alt self.ch {\n-          '+' { self.bump(); }\n-          '-' { self.bump(); neg_exp = true; }\n-          _ {}\n+          '+' => self.bump(),\n+          '-' => { self.bump(); neg_exp = true; }\n+          _ => ()\n         }\n \n         // Make sure a digit follows the exponent place.\n         alt self.ch {\n-          '0' to '9' {}\n-          _ { return self.error(~\"invalid number\"); }\n+          '0' to '9' => (),\n+          _ => return self.error(~\"invalid number\")\n         }\n \n         while !self.eof() {\n             alt self.ch {\n-              '0' to '9' {\n+              '0' to '9' => {\n                 exp *= 10u;\n                 exp += (self.ch as uint) - ('0' as uint);\n \n                 self.bump();\n               }\n-              _ { break; }\n+              _ => break\n             }\n         }\n \n@@ -338,25 +330,25 @@ impl parser for parser {\n \n             if (escape) {\n                 alt self.ch {\n-                  '\"' { str::push_char(res, '\"'); }\n-                  '\\\\' { str::push_char(res, '\\\\'); }\n-                  '/' { str::push_char(res, '/'); }\n-                  'b' { str::push_char(res, '\\x08'); }\n-                  'f' { str::push_char(res, '\\x0c'); }\n-                  'n' { str::push_char(res, '\\n'); }\n-                  'r' { str::push_char(res, '\\r'); }\n-                  't' { str::push_char(res, '\\t'); }\n-                  'u' {\n+                  '\"' => str::push_char(res, '\"'),\n+                  '\\\\' => str::push_char(res, '\\\\'),\n+                  '/' => str::push_char(res, '/'),\n+                  'b' => str::push_char(res, '\\x08'),\n+                  'f' => str::push_char(res, '\\x0c'),\n+                  'n' => str::push_char(res, '\\n'),\n+                  'r' => str::push_char(res, '\\r'),\n+                  't' => str::push_char(res, '\\t'),\n+                  'u' => {\n                       // Parse \\u1234.\n                       let mut i = 0u;\n                       let mut n = 0u;\n                       while i < 4u {\n                           alt self.next_char() {\n-                            '0' to '9' {\n+                            '0' to '9' => {\n                               n = n * 10u +\n                                   (self.ch as uint) - ('0' as uint);\n                             }\n-                            _ { return self.error(~\"invalid \\\\u escape\"); }\n+                            _ => return self.error(~\"invalid \\\\u escape\")\n                           }\n                           i += 1u;\n                       }\n@@ -368,7 +360,7 @@ impl parser for parser {\n \n                       str::push_char(res, n as char);\n                   }\n-                  _ { return self.error(~\"invalid escape\"); }\n+                  _ => return self.error(~\"invalid escape\")\n                 }\n                 escape = false;\n             } else if self.ch == '\\\\' {\n@@ -398,8 +390,8 @@ impl parser for parser {\n \n         loop {\n             alt self.parse_value() {\n-              ok(v) { vec::push(values, v); }\n-              e { return e; }\n+              ok(v) => vec::push(values, v),\n+              e => return e\n             }\n \n             self.parse_whitespace();\n@@ -408,9 +400,9 @@ impl parser for parser {\n             }\n \n             alt self.ch {\n-              ',' { self.bump(); }\n-              ']' { self.bump(); return ok(list(@values)); }\n-              _ { return self.error(~\"expected `,` or `]`\"); }\n+              ',' => self.bump(),\n+              ']' => { self.bump(); return ok(list(@values)); }\n+              _ => return self.error(~\"expected `,` or `]`\")\n             }\n         };\n     }\n@@ -434,8 +426,8 @@ impl parser for parser {\n             }\n \n             let key = alt self.parse_str() {\n-              ok(key) { key }\n-              err(e) { return err(e); }\n+              ok(key) => key,\n+              err(e) => return err(e)\n             };\n \n             self.parse_whitespace();\n@@ -447,15 +439,15 @@ impl parser for parser {\n             self.bump();\n \n             alt self.parse_value() {\n-              ok(value) { values.insert(copy *key, value); }\n-              e { return e; }\n+              ok(value) => { values.insert(copy *key, value); }\n+              e => return e\n             }\n             self.parse_whitespace();\n \n             alt self.ch {\n-              ',' { self.bump(); }\n-              '}' { self.bump(); return ok(dict(values)); }\n-              _ {\n+              ',' => self.bump(),\n+              '}' => { self.bump(); return ok(dict(values)); }\n+              _ => {\n                   if self.eof() { break; }\n                   return self.error(~\"expected `,` or `}`\");\n               }\n@@ -486,27 +478,26 @@ fn from_str(s: ~str) -> result<json, error> {\n /// Test if two json values are equal\n fn eq(value0: json, value1: json) -> bool {\n     alt (value0, value1) {\n-      (num(f0), num(f1)) { f0 == f1 }\n-      (string(s0), string(s1)) { s0 == s1 }\n-      (boolean(b0), boolean(b1)) { b0 == b1 }\n-      (list(l0), list(l1)) { vec::all2(*l0, *l1, eq) }\n-      (dict(d0), dict(d1)) {\n+      (num(f0), num(f1)) => f0 == f1,\n+      (string(s0), string(s1)) => s0 == s1,\n+      (boolean(b0), boolean(b1)) => b0 == b1,\n+      (list(l0), list(l1)) => vec::all2(*l0, *l1, eq),\n+      (dict(d0), dict(d1)) => {\n           if d0.size() == d1.size() {\n               let mut equal = true;\n               for d0.each |k, v0| {\n                   alt d1.find(k) {\n-                    some(v1) {\n-                        if !eq(v0, v1) { equal = false; } }\n-                    none { equal = false; }\n+                    some(v1) => if !eq(v0, v1) { equal = false },\n+                    none => equal = false\n                   }\n               };\n               equal\n           } else {\n               false\n           }\n       }\n-      (null, null) { true }\n-      _ { false }\n+      (null, null) => true,\n+      _ => false\n     }\n }\n \n@@ -626,8 +617,8 @@ impl <A: to_json copy> of to_json for hashmap<~str, A> {\n impl <A: to_json> of to_json for option<A> {\n     fn to_json() -> json {\n         alt self {\n-          none { null }\n-          some(value) { value.to_json() }\n+          none => null,\n+          some(value) => value.to_json()\n         }\n     }\n }"}, {"sha": "3538929e7283edd0f009759085ff80a8024fd4ed", "filename": "src/libstd/list.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -44,11 +44,11 @@ fn find<T: copy>(ls: @list<T>, f: fn(T) -> bool) -> option<T> {\n     let mut ls = ls;\n     loop {\n         ls = alt *ls {\n-          cons(hd, tl) {\n+          cons(hd, tl) => {\n             if f(hd) { return some(hd); }\n             tl\n           }\n-          nil { return none; }\n+          nil => return none\n         }\n     };\n }\n@@ -64,8 +64,8 @@ fn has<T: copy>(ls: @list<T>, elt: T) -> bool {\n /// Returns true if the list is empty\n pure fn is_empty<T: copy>(ls: @list<T>) -> bool {\n     alt *ls {\n-        nil { true }\n-        _ { false }\n+        nil => true,\n+        _ => false\n     }\n }\n \n@@ -84,21 +84,24 @@ fn len<T>(ls: @list<T>) -> uint {\n /// Returns all but the first element of a list\n pure fn tail<T: copy>(ls: @list<T>) -> @list<T> {\n     alt *ls {\n-        cons(_, tl) { return tl; }\n-        nil { fail ~\"list empty\" }\n+        cons(_, tl) => return tl,\n+        nil => fail ~\"list empty\"\n     }\n }\n \n /// Returns the first element of a list\n pure fn head<T: copy>(ls: @list<T>) -> T {\n-    alt check *ls { cons(hd, _) { hd } }\n+    alt check *ls { cons(hd, _) => hd }\n }\n \n /// Appends one list to another\n pure fn append<T: copy>(l: @list<T>, m: @list<T>) -> @list<T> {\n     alt *l {\n-      nil { return m; }\n-      cons(x, xs) { let rest = append(xs, m); return @cons(x, rest); }\n+      nil => return m,\n+      cons(x, xs) => {\n+        let rest = append(xs, m);\n+        return @cons(x, rest);\n+      }\n     }\n }\n \n@@ -112,11 +115,11 @@ fn iter<T>(l: @list<T>, f: fn(T)) {\n     let mut cur = l;\n     loop {\n         cur = alt *cur {\n-          cons(hd, tl) {\n+          cons(hd, tl) => {\n             f(hd);\n             tl\n           }\n-          nil { break; }\n+          nil => break\n         }\n     }\n }\n@@ -126,11 +129,11 @@ fn each<T>(l: @list<T>, f: fn(T) -> bool) {\n     let mut cur = l;\n     loop {\n         cur = alt *cur {\n-          cons(hd, tl) {\n+          cons(hd, tl) => {\n             if !f(hd) { return; }\n             tl\n           }\n-          nil { break; }\n+          nil => break\n         }\n     }\n }"}, {"sha": "2b99c4cb8aa4c3a10e720a27e5400e8d1f99df6b", "filename": "src/libstd/map.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -134,12 +134,12 @@ mod chained {\n             let mut comp = 1u;   // for logging\n             loop {\n                 alt copy e0.next {\n-                  none {\n+                  none => {\n                     debug!{\"search_tbl: absent, comp %u, hash %u, idx %u\",\n                            comp, h, idx};\n                     return not_found;\n                   }\n-                  some(e1) {\n+                  some(e1) => {\n                     comp += 1u;\n                     if e1.hash == h && self.eqer(&e1.key, k) {\n                         debug!{\"search_tbl: present, comp %u, \\\n@@ -157,12 +157,12 @@ mod chained {\n         fn search_tbl(k: &K, h: uint) -> search_result<K,V> {\n             let idx = h % vec::len(self.chains);\n             alt copy self.chains[idx] {\n-              none {\n+              none => {\n                 debug!{\"search_tbl: none, comp %u, hash %u, idx %u\",\n                        0u, h, idx};\n                 return not_found;\n               }\n-              some(e) {\n+              some(e) => {\n                 if e.hash == h && self.eqer(&e.key, k) {\n                     debug!{\"search_tbl: present, comp %u, hash %u, idx %u\",\n                            1u, h, idx};\n@@ -194,8 +194,8 @@ mod chained {\n                 let mut chain = self.chains[i];\n                 loop {\n                     chain = alt chain {\n-                      none { break; }\n-                      some(entry) {\n+                      none => break,\n+                      some(entry) => {\n                         let next = entry.next;\n                         if !blk(entry) { return; }\n                         next\n@@ -217,15 +217,15 @@ mod chained {\n         fn contains_key_ref(k: &K) -> bool {\n             let hash = self.hasher(k);\n             alt self.search_tbl(k, hash) {\n-              not_found {false}\n-              found_first(*) | found_after(*) {true}\n+              not_found => false,\n+              found_first(*) | found_after(*) => true\n             }\n         }\n \n         fn insert(+k: K, +v: V) -> bool {\n             let hash = self.hasher(&k);\n             alt self.search_tbl(&k, hash) {\n-              not_found {\n+              not_found => {\n                 self.count += 1u;\n                 let idx = hash % vec::len(self.chains);\n                 let old_chain = self.chains[idx];\n@@ -245,15 +245,15 @@ mod chained {\n \n                 return true;\n               }\n-              found_first(idx, entry) {\n+              found_first(idx, entry) => {\n                 self.chains[idx] = some(@entry {\n                     hash: hash,\n                     key: k,\n                     value: v,\n                     next: entry.next});\n                 return false;\n               }\n-              found_after(prev, entry) {\n+              found_after(prev, entry) => {\n                 prev.next = some(@entry {\n                     hash: hash,\n                     key: k,\n@@ -266,9 +266,9 @@ mod chained {\n \n         fn find(+k: K) -> option<V> {\n             alt self.search_tbl(&k, self.hasher(&k)) {\n-              not_found {none}\n-              found_first(_, entry) {some(entry.value)}\n-              found_after(_, entry) {some(entry.value)}\n+              not_found => none,\n+              found_first(_, entry) => some(entry.value),\n+              found_after(_, entry) => some(entry.value)\n             }\n         }\n \n@@ -282,13 +282,13 @@ mod chained {\n \n         fn remove(+k: K) -> option<V> {\n             alt self.search_tbl(&k, self.hasher(&k)) {\n-              not_found {none}\n-              found_first(idx, entry) {\n+              not_found => none,\n+              found_first(idx, entry) => {\n                 self.count -= 1u;\n                 self.chains[idx] = entry.next;\n                 some(entry.value)\n               }\n-              found_after(eprev, entry) {\n+              found_after(eprev, entry) => {\n                 self.count -= 1u;\n                 eprev.next = entry.next;\n                 some(entry.value)\n@@ -639,8 +639,8 @@ mod tests {\n         while i < num_to_insert {\n             let v = hm.remove(i);\n             alt v {\n-              option::some(u) { assert (u == i * i); }\n-              option::none { fail; }\n+              option::some(u) => assert (u == i * i),\n+              option::none => fail\n             }\n             i += 2u;\n         }"}, {"sha": "1cc8dd3bed929fd99c89439770e602daa7ceacb4", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -48,23 +48,19 @@ type parse_addr_err = {\n  */\n fn format_addr(ip: ip_addr) -> ~str {\n     alt ip {\n-      ipv4(addr) {\n-        unsafe {\n-            let result = uv_ip4_name(&addr);\n-            if result == ~\"\" {\n-                fail ~\"failed to convert inner sockaddr_in address to str\"\n-            }\n-            result\n+      ipv4(addr) =>  unsafe {\n+        let result = uv_ip4_name(&addr);\n+        if result == ~\"\" {\n+            fail ~\"failed to convert inner sockaddr_in address to str\"\n         }\n+        result\n       }\n-      ipv6(addr) {\n-        unsafe {\n-            let result = uv_ip6_name(&addr);\n-            if result == ~\"\" {\n-                fail ~\"failed to convert inner sockaddr_in address to str\"\n-            }\n-            result\n+      ipv6(addr) => unsafe {\n+        let result = uv_ip6_name(&addr);\n+        if result == ~\"\" {\n+            fail ~\"failed to convert inner sockaddr_in address to str\"\n         }\n+        result\n       }\n     }\n }\n@@ -108,10 +104,10 @@ fn get_addr(++node: ~str, iotask: iotask)\n                     ptr::null(),\n                     ptr::null());\n                 alt result {\n-                  0i32 {\n+                  0i32 => {\n                     set_data_for_req(handle_ptr, handle_data_ptr);\n                   }\n-                  _ {\n+                  _ => {\n                     output_ch.send(result::err(get_addr_unknown_error));\n                   }\n                 }\n@@ -139,10 +135,8 @@ mod v4 {\n      */\n     fn parse_addr(ip: ~str) -> ip_addr {\n         alt try_parse_addr(ip) {\n-          result::ok(addr) { copy(addr) }\n-          result::err(err_data) {\n-            fail err_data.err_msg\n-          }\n+          result::ok(addr) => copy(addr),\n+          result::err(err_data) => fail err_data.err_msg\n         }\n     }\n     // the simple, old style numberic representation of\n@@ -162,8 +156,8 @@ mod v4 {\n     fn parse_to_ipv4_rep(ip: ~str) -> result::result<ipv4_rep, ~str> {\n         let parts = vec::map(str::split_char(ip, '.'), |s| {\n             alt uint::from_str(s) {\n-              some(n) if n <= 255u { n }\n-              _ { 256u }\n+              some(n) if n <= 255u => n,\n+              _ => 256u\n             }\n         });\n         if vec::len(parts) != 4u {\n@@ -227,10 +221,8 @@ mod v6 {\n      */\n     fn parse_addr(ip: ~str) -> ip_addr {\n         alt try_parse_addr(ip) {\n-          result::ok(addr) { copy(addr) }\n-          result::err(err_data) {\n-            fail err_data.err_msg\n-          }\n+          result::ok(addr) => copy(addr),\n+          result::err(err_data) => fail err_data.err_msg\n         }\n     }\n     fn try_parse_addr(ip: ~str) -> result::result<ip_addr,parse_addr_err> {\n@@ -335,11 +327,11 @@ mod test {\n     #[test]\n     fn test_ip_ipv4_bad_parse() {\n         alt v4::try_parse_addr(~\"b4df00d\") {\n-          result::err(err_info) {\n+          result::err(err_info) => {\n             log(debug, fmt!{\"got error as expected %?\", err_info});\n             assert true;\n           }\n-          result::ok(addr) {\n+          result::ok(addr) => {\n             fail fmt!{\"Expected failure, but got addr %?\", addr};\n           }\n         }\n@@ -348,11 +340,11 @@ mod test {\n     #[ignore(target_os=\"win32\")]\n     fn test_ip_ipv6_bad_parse() {\n         alt v6::try_parse_addr(~\"::,~2234k;\") {\n-          result::err(err_info) {\n+          result::err(err_info) => {\n             log(debug, fmt!{\"got error as expected %?\", err_info});\n             assert true;\n           }\n-          result::ok(addr) {\n+          result::ok(addr) => {\n             fail fmt!{\"Expected failure, but got addr %?\", addr};\n           }\n         }\n@@ -373,12 +365,8 @@ mod test {\n                         localhost_name, vec::len(results)});\n         for vec::each(results) |r| {\n             let ipv_prefix = alt r {\n-              ipv4(_) {\n-                ~\"IPv4\"\n-              }\n-              ipv6(_) {\n-                ~\"IPv6\"\n-              }\n+              ipv4(_) => ~\"IPv4\",\n+              ipv6(_) => ~\"IPv6\"\n             };\n             log(debug, fmt!{\"test_get_addr: result %s: '%s'\",\n                             ipv_prefix, format_addr(r)});"}, {"sha": "2ce47a641c182a6d9f62267f2522888fe32e505a", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 67, "deletions": 90, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -152,16 +152,16 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n         log(debug, fmt!{\"stream_handle_ptr in interact %?\",\n             stream_handle_ptr});\n         alt uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n-          0i32 {\n+          0i32 => {\n             log(debug, ~\"tcp_init successful\");\n             alt input_ip {\n-              ipv4 {\n+              ipv4 => {\n                 log(debug, ~\"dealing w/ ipv4 connection..\");\n                 let connect_req_ptr =\n                     ptr::addr_of((*socket_data_ptr).connect_req);\n                 let addr_str = ip::format_addr(input_ip);\n                 let connect_result = alt input_ip {\n-                  ip::ipv4(addr) {\n+                  ip::ipv4(addr) => {\n                     // have to \"recreate\" the sockaddr_in/6\n                     // since the ip_addr discards the port\n                     // info.. should probably add an additional\n@@ -175,7 +175,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n                         ptr::addr_of(in_addr),\n                         tcp_connect_on_connect_cb)\n                   }\n-                  ip::ipv6(addr) {\n+                  ip::ipv6(addr) => {\n                     log(debug, fmt!{\"addr: %?\", addr});\n                     let in_addr = uv::ll::ip6_addr(addr_str, port as int);\n                     uv::ll::tcp_connect6(\n@@ -186,7 +186,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n                   }\n                 };\n                 alt connect_result {\n-                  0i32 {\n+                  0i32 => {\n                     log(debug, ~\"tcp_connect successful\");\n                     // reusable data that we'll have for the\n                     // duration..\n@@ -201,7 +201,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n                     // let tcp_connect_on_connect_cb send on\n                     // the result_ch, now..\n                   }\n-                  _ {\n+                  _ => {\n                     // immediate connect failure.. probably a garbage\n                     // ip or somesuch\n                     let err_data = uv::ll::get_last_err_data(loop_ptr);\n@@ -215,7 +215,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n               }\n             }\n         }\n-          _ {\n+          _ => {\n             // failure to create a tcp handle\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n             comm::send((*conn_data_ptr).result_ch,\n@@ -224,19 +224,19 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n         }\n     };\n     alt comm::recv(result_po) {\n-      conn_success {\n+      conn_success => {\n         log(debug, ~\"tcp::connect - received success on result_po\");\n         result::ok(tcp_socket(socket_data))\n       }\n-      conn_failure(err_data) {\n+      conn_failure(err_data) => {\n         comm::recv(closed_signal_po);\n         log(debug, ~\"tcp::connect - received failure on result_po\");\n         // still have to free the malloc'd stream handle..\n         rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n                                            as *libc::c_void);\n         let tcp_conn_err = alt err_data.err_name {\n-          ~\"ECONNREFUSED\" { connection_refused }\n-          _ { generic_connect_err(err_data.err_name, err_data.err_msg) }\n+          ~\"ECONNREFUSED\" => connection_refused,\n+          _ => generic_connect_err(err_data.err_name, err_data.err_msg)\n         };\n         result::err(tcp_conn_err)\n       }\n@@ -470,7 +470,7 @@ fn accept(new_conn: tcp_new_connection)\n     -> result::result<tcp_socket, tcp_err_data> unsafe {\n \n     alt new_conn{\n-      new_tcp_conn(server_handle_ptr) {\n+      new_tcp_conn(server_handle_ptr) => {\n         let server_data_ptr = uv::ll::get_data_for_uv_handle(\n             server_handle_ptr) as *tcp_listen_fc_data;\n         let reader_po = comm::port::<result::result<~[u8], tcp_err_data>>();\n@@ -502,39 +502,35 @@ fn accept(new_conn: tcp_new_connection)\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(\n             server_handle_ptr);\n         alt uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n-          0i32 {\n+          0i32 => {\n             log(debug, ~\"uv_tcp_init successful for client stream\");\n             alt uv::ll::accept(\n                 server_handle_ptr as *libc::c_void,\n                 client_stream_handle_ptr as *libc::c_void) {\n-              0i32 {\n+              0i32 => {\n                 log(debug, ~\"successfully accepted client connection\");\n                 uv::ll::set_data_for_uv_handle(client_stream_handle_ptr,\n                                                client_socket_data_ptr\n                                                    as *libc::c_void);\n                 comm::send(result_ch, none);\n               }\n-              _ {\n+              _ => {\n                 log(debug, ~\"failed to accept client conn\");\n                 comm::send(result_ch, some(\n                     uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n               }\n             }\n           }\n-          _ {\n+          _ => {\n             log(debug, ~\"failed to init client stream\");\n             comm::send(result_ch, some(\n                 uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n           }\n         }\n         // UNSAFE LIBUV INTERACTION END\n         alt comm::recv(result_po) {\n-          some(err_data) {\n-            result::err(err_data)\n-          }\n-          none {\n-            result::ok(tcp_socket(client_socket_data))\n-          }\n+          some(err_data) => result::err(err_data),\n+          none => result::ok(tcp_socket(client_socket_data))\n         }\n       }\n     }\n@@ -615,48 +611,46 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n         let loc_ip = copy(host_ip);\n         do iotask::interact(iotask) |loop_ptr| {\n             alt uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n-              0i32 {\n+              0i32 => {\n                 uv::ll::set_data_for_uv_handle(\n                     server_stream_ptr,\n                     server_data_ptr);\n                 let addr_str = ip::format_addr(loc_ip);\n                 let bind_result = alt loc_ip {\n-                  ip::ipv4(addr) {\n+                  ip::ipv4(addr) => {\n                     log(debug, fmt!{\"addr: %?\", addr});\n                     let in_addr = uv::ll::ip4_addr(addr_str, port as int);\n                     uv::ll::tcp_bind(server_stream_ptr,\n                                      ptr::addr_of(in_addr))\n                   }\n-                  ip::ipv6(addr) {\n+                  ip::ipv6(addr) => {\n                     log(debug, fmt!{\"addr: %?\", addr});\n                     let in_addr = uv::ll::ip6_addr(addr_str, port as int);\n                     uv::ll::tcp_bind6(server_stream_ptr,\n                                      ptr::addr_of(in_addr))\n                   }\n                 };\n                 alt bind_result {\n-                  0i32 {\n+                  0i32 => {\n                     alt uv::ll::listen(server_stream_ptr,\n                                        backlog as libc::c_int,\n                                        tcp_lfc_on_connection_cb) {\n-                      0i32 {\n-                        comm::send(setup_ch, none);\n-                      }\n-                      _ {\n+                      0i32 => comm::send(setup_ch, none),\n+                      _ => {\n                         log(debug, ~\"failure to uv_listen()\");\n                         let err_data = uv::ll::get_last_err_data(loop_ptr);\n                         comm::send(setup_ch, some(err_data));\n                       }\n                     }\n                   }\n-                  _ {\n+                  _ => {\n                     log(debug, ~\"failure to uv_tcp_bind\");\n                     let err_data = uv::ll::get_last_err_data(loop_ptr);\n                     comm::send(setup_ch, some(err_data));\n                   }\n                 }\n               }\n-              _ {\n+              _ => {\n                 log(debug, ~\"failure to uv_tcp_init\");\n                 let err_data = uv::ll::get_last_err_data(loop_ptr);\n                 comm::send(setup_ch, some(err_data));\n@@ -666,7 +660,7 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n         setup_ch.recv()\n     };\n     alt setup_result {\n-      some(err_data) {\n+      some(err_data) => {\n         do iotask::interact(iotask) |loop_ptr| {\n             log(debug, fmt!{\"tcp::listen post-kill recv hl interact %?\",\n                             loop_ptr});\n@@ -675,23 +669,23 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n         };\n         stream_closed_po.recv();\n         alt err_data.err_name {\n-          ~\"EACCES\" {\n+          ~\"EACCES\" => {\n             log(debug, ~\"Got EACCES error\");\n             result::err(access_denied)\n           }\n-          ~\"EADDRINUSE\" {\n+          ~\"EADDRINUSE\" => {\n             log(debug, ~\"Got EADDRINUSE error\");\n             result::err(address_in_use)\n           }\n-          _ {\n+          _ => {\n             log(debug, fmt!{\"Got '%s' '%s' libuv error\",\n                             err_data.err_name, err_data.err_msg});\n             result::err(\n                 generic_listen_err(err_data.err_name, err_data.err_msg))\n           }\n         }\n       }\n-      none {\n+      none => {\n         on_establish_cb(kill_ch);\n         let kill_result = comm::recv(kill_po);\n         do iotask::interact(iotask) |loop_ptr| {\n@@ -703,14 +697,10 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n         stream_closed_po.recv();\n         alt kill_result {\n           // some failure post bind/listen\n-          some(err_data) {\n-            result::err(generic_listen_err(err_data.err_name,\n-                                            err_data.err_msg))\n-          }\n+          some(err_data) => result::err(generic_listen_err(err_data.err_name,\n+                                                           err_data.err_msg)),\n           // clean exit\n-          none {\n-            result::ok(())\n-          }\n+          none => result::ok(())\n         }\n       }\n     }\n@@ -889,7 +879,7 @@ fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n         };\n         log(debug, ~\"tcp::read after recv_timeout\");\n         alt read_result {\n-          none {\n+          none => {\n             log(debug, ~\"tcp::read: timed out..\");\n             let err_data = {\n                 err_name: ~\"TIMEOUT\",\n@@ -898,7 +888,7 @@ fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n             read_stop_common_impl(socket_data);\n             result::err(err_data)\n           }\n-          some(data_result) {\n+          some(data_result) => {\n             log(debug, ~\"tcp::read got data\");\n             read_stop_common_impl(socket_data);\n             data_result\n@@ -916,24 +906,20 @@ fn read_stop_common_impl(socket_data: *tcp_socket_data) ->\n     do iotask::interact((*socket_data).iotask) |loop_ptr| {\n         log(debug, ~\"in interact cb for tcp::read_stop\");\n         alt uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n-          0i32 {\n+          0i32 => {\n             log(debug, ~\"successfully called uv_read_stop\");\n             comm::send(stop_ch, none);\n           }\n-          _ {\n+          _ => {\n             log(debug, ~\"failure in calling uv_read_stop\");\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n             comm::send(stop_ch, some(err_data.to_tcp_err()));\n           }\n         }\n     };\n     alt comm::recv(stop_po) {\n-      some(err_data) {\n-        result::err(err_data.to_tcp_err())\n-      }\n-      none {\n-        result::ok(())\n-      }\n+      some(err_data) => result::err(err_data.to_tcp_err()),\n+      none => result::ok(())\n     }\n }\n \n@@ -950,24 +936,20 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n         alt uv::ll::read_start(stream_handle_ptr as *uv::ll::uv_stream_t,\n                                on_alloc_cb,\n                                on_tcp_read_cb) {\n-          0i32 {\n+          0i32 => {\n             log(debug, ~\"success doing uv_read_start\");\n             comm::send(start_ch, none);\n           }\n-          _ {\n+          _ => {\n             log(debug, ~\"error attempting uv_read_start\");\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n             comm::send(start_ch, some(err_data));\n           }\n         }\n     };\n     alt comm::recv(start_po) {\n-      some(err_data) {\n-        result::err(err_data.to_tcp_err())\n-      }\n-      none {\n-        result::ok((*socket_data).reader_po)\n-      }\n+      some(err_data) => result::err(err_data.to_tcp_err()),\n+      none => result::ok((*socket_data).reader_po)\n     }\n }\n \n@@ -995,11 +977,11 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n                           stream_handle_ptr,\n                           write_buf_vec_ptr,\n                           tcp_write_complete_cb) {\n-          0i32 {\n+          0i32 => {\n             log(debug, ~\"uv_write() invoked successfully\");\n             uv::ll::set_data_for_req(write_req_ptr, write_data_ptr);\n           }\n-          _ {\n+          _ => {\n             log(debug, ~\"error invoking uv_write()\");\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n             comm::send((*write_data_ptr).result_ch,\n@@ -1012,8 +994,8 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n     // ownership of everything to the I/O task and let it deal with the\n     // aftermath, so we don't have to sit here blocking.\n     alt comm::recv(result_po) {\n-      tcp_write_success { result::ok(()) }\n-      tcp_write_error(err_data) { result::err(err_data.to_tcp_err()) }\n+      tcp_write_success => result::ok(()),\n+      tcp_write_error(err_data) => result::err(err_data.to_tcp_err())\n     }\n }\n \n@@ -1043,10 +1025,8 @@ extern fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n     let kill_ch = (*server_data_ptr).kill_ch;\n     if (*server_data_ptr).active {\n         alt status {\n-          0i32 {\n-            (*server_data_ptr).on_connect_cb(handle);\n-          }\n-          _ {\n+          0i32 => (*server_data_ptr).on_connect_cb(handle),\n+          _ => {\n             let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n             comm::send(kill_ch,\n                        some(uv::ll::get_last_err_data(loop_ptr)\n@@ -1103,17 +1083,17 @@ extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n         as *tcp_socket_data;\n     alt nread as int {\n       // incoming err.. probably eof\n-      -1 {\n+      -1 => {\n         let err_data = uv::ll::get_last_err_data(loop_ptr).to_tcp_err();\n         log(debug, fmt!{\"on_tcp_read_cb: incoming err.. name %? msg %?\",\n                         err_data.err_name, err_data.err_msg});\n         let reader_ch = (*socket_data_ptr).reader_ch;\n         comm::send(reader_ch, result::err(err_data));\n       }\n       // do nothing .. unneeded buf\n-      0 {}\n+      0 => (),\n       // have data\n-      _ {\n+      _ => {\n         // we have data\n         log(debug, fmt!{\"tcp on_read_cb nread: %d\", nread as int});\n         let reader_ch = (*socket_data_ptr).reader_ch;\n@@ -1196,11 +1176,11 @@ extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,\n     let tcp_stream_ptr =\n         uv::ll::get_stream_handle_from_connect_req(connect_req_ptr);\n     alt status {\n-      0i32 {\n+      0i32 => {\n         log(debug, ~\"successful tcp connection!\");\n         comm::send(result_ch, conn_success);\n       }\n-      _ {\n+      _ => {\n         log(debug, ~\"error in tcp_connect_on_connect_cb\");\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(tcp_stream_ptr);\n         let err_data = uv::ll::get_last_err_data(loop_ptr);\n@@ -1357,11 +1337,8 @@ mod test {\n                 hl_loop)\n         };\n         alt actual_resp_result.get_err() {\n-          connection_refused {\n-          }\n-          _ {\n-            fail ~\"unknown error.. expected connection_refused\"\n-          }\n+          connection_refused => (),\n+          _ => fail ~\"unknown error.. expected connection_refused\"\n         }\n     }\n     fn impl_gl_tcp_ipv4_server_address_in_use() {\n@@ -1406,12 +1383,12 @@ mod test {\n                 hl_loop)\n         };\n         alt listen_err {\n-          address_in_use {\n+          address_in_use => {\n             assert true;\n           }\n-          _ {\n+          _ => {\n             fail ~\"expected address_in_use listen error,\"+\n-                      ~\"but got a different error varient. check logs.\";\n+                ~\"but got a different error varient. check logs.\";\n           }\n         }\n     }\n@@ -1425,10 +1402,10 @@ mod test {\n                             server_port,\n                             hl_loop);\n         alt listen_err {\n-          access_denied {\n+          access_denied => {\n             assert true;\n           }\n-          _ {\n+          _ => {\n             fail ~\"expected address_in_use listen error,\"+\n                       ~\"but got a different error varient. check logs.\";\n           }\n@@ -1539,7 +1516,7 @@ mod test {\n                             ~\"connection!\");\n                         let received_req_bytes = read(sock, 0u);\n                         alt received_req_bytes {\n-                          result::ok(data) {\n+                          result::ok(data) => {\n                             log(debug, ~\"SERVER: got REQ str::from_bytes..\");\n                             log(debug, fmt!{\"SERVER: REQ data len: %?\",\n                                             vec::len(data)});\n@@ -1550,7 +1527,7 @@ mod test {\n                             log(debug, ~\"SERVER: after write.. die\");\n                             comm::send(kill_ch, none);\n                           }\n-                          result::err(err_data) {\n+                          result::err(err_data) => {\n                             log(debug, fmt!{\"SERVER: error recvd: %s %s\",\n                                 err_data.err_name, err_data.err_msg});\n                             comm::send(kill_ch, some(err_data));\n@@ -1568,14 +1545,14 @@ mod test {\n         // err check on listen_result\n         if result::is_err(listen_result) {\n             alt result::get_err(listen_result) {\n-              generic_listen_err(name, msg) {\n+              generic_listen_err(name, msg) => {\n                 fail fmt!{\"SERVER: exited abnormally name %s msg %s\",\n                                 name, msg};\n               }\n-              access_denied {\n+              access_denied => {\n                 fail ~\"SERVER: exited abnormally, got access denied..\";\n               }\n-              address_in_use {\n+              address_in_use => {\n                 fail ~\"SERVER: exited abnormally, got address in use...\";\n               }\n             }"}, {"sha": "d43a8add1cc3476c5ce4a18bf3ecbe748cb9fdfe", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -52,22 +52,22 @@ fn encode_inner(s: ~str, full_url: bool) -> ~str {\n               'A' to 'Z' |\n               'a' to 'z' |\n               '0' to '9' |\n-              '-' | '.' | '_' | '~' {\n+              '-' | '.' | '_' | '~' => {\n                 str::push_char(out, ch);\n               }\n-              _ {\n-                if full_url {\n+              _ => {\n+                  if full_url {\n                     match ch {\n                       // gen-delims:\n                       ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n \n                       // sub-delims:\n                       '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n-                      '+' | ',' | ';' | '=' {\n+                      '+' | ',' | ';' | '=' => {\n                         str::push_char(out, ch);\n                       }\n \n-                      _ { out += #fmt(\"%%%X\", ch as uint); }\n+                      _ => out += #fmt(\"%%%X\", ch as uint)\n                     }\n                 } else {\n                     out += #fmt(\"%%%X\", ch as uint);\n@@ -106,7 +106,7 @@ fn decode_inner(s: ~str, full_url: bool) -> ~str {\n \n         while !rdr.eof() {\n             match rdr.read_char() {\n-              '%' {\n+              '%' => {\n                 let bytes = rdr.read_bytes(2u);\n                 let ch = uint::parse_buf(bytes, 16u).get() as char;\n \n@@ -118,19 +118,19 @@ fn decode_inner(s: ~str, full_url: bool) -> ~str {\n \n                       // sub-delims:\n                       '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n-                      '+' | ',' | ';' | '=' {\n+                      '+' | ',' | ';' | '=' => {\n                         str::push_char(out, '%');\n                         str::push_char(out, bytes[0u] as char);\n                         str::push_char(out, bytes[1u] as char);\n                       }\n \n-                      ch { str::push_char(out, ch); }\n+                      ch => str::push_char(out, ch)\n                     }\n                 } else {\n                       str::push_char(out, ch);\n                 }\n               }\n-              ch { str::push_char(out, ch); }\n+              ch => str::push_char(out, ch)\n             }\n         }\n \n@@ -161,11 +161,11 @@ fn encode_plus(s: ~str) -> ~str {\n         while !rdr.eof() {\n             let ch = rdr.read_byte() as char;\n             match ch {\n-              'A' to 'Z' | 'a' to 'z' | '0' to '9' | '_' | '.' | '-' {\n+              'A' to 'Z' | 'a' to 'z' | '0' to '9' | '_' | '.' | '-' => {\n                 str::push_char(out, ch);\n               }\n-              ' ' { str::push_char(out, '+'); }\n-              _ { out += #fmt(\"%%%X\", ch as uint); }\n+              ' ' => str::push_char(out, '+'),\n+              _ => out += #fmt(\"%%%X\", ch as uint)\n             }\n         }\n \n@@ -212,11 +212,11 @@ fn decode_form_urlencoded(s: ~[u8]) ->\n \n         while !rdr.eof() {\n             match rdr.read_char() {\n-              '&' | ';' {\n+              '&' | ';' => {\n                 if key != ~\"\" && value != ~\"\" {\n                     let values = match m.find(key) {\n-                      some(values) { values }\n-                      none {\n+                      some(values) => values,\n+                      none => {\n                         let values = @dvec();\n                         m.insert(key, values);\n                         values\n@@ -229,14 +229,14 @@ fn decode_form_urlencoded(s: ~[u8]) ->\n                 key = ~\"\";\n                 value = ~\"\";\n               }\n-              '=' { parsing_key = false; }\n-              ch {\n+              '=' => parsing_key = false,\n+              ch => {\n                 let ch = match ch {\n-                  '%' {\n+                  '%' => {\n                     uint::parse_buf(rdr.read_bytes(2u), 16u).get() as char\n                   }\n-                  '+' { ' ' }\n-                  ch { ch }\n+                  '+' => ' ',\n+                  ch => ch\n                 };\n \n                 if parsing_key {\n@@ -250,8 +250,8 @@ fn decode_form_urlencoded(s: ~[u8]) ->\n \n         if key != ~\"\" && value != ~\"\" {\n             let values = match m.find(key) {\n-              some(values) { values }\n-              none {\n+              some(values) => values,\n+              none => {\n                 let values = @dvec();\n                 m.insert(key, values);\n                 values\n@@ -333,22 +333,22 @@ fn query_to_str(query: query) -> ~str {\n fn get_scheme(rawurl: ~str) -> result::result<(~str, ~str), @~str> {\n     for str::each_chari(rawurl) |i,c| {\n         match c {\n-          'A' to 'Z' | 'a' to 'z' { again; }\n-          '0' to '9' | '+' | '-' | '.' {\n+          'A' to 'Z' | 'a' to 'z' => again,\n+          '0' to '9' | '+' | '-' | '.' => {\n             if i == 0 {\n                 return result::err(@~\"url: Scheme must begin with a letter.\");\n             }\n             again;\n           }\n-          ':' {\n+          ':' => {\n             if i == 0 {\n                 return result::err(@~\"url: Scheme cannot be empty.\");\n             } else {\n                 return result::ok((rawurl.slice(0,i),\n                                 rawurl.slice(i+1,str::len(rawurl))));\n             }\n           }\n-          _  {\n+          _ => {\n             return result::err(@~\"url: Invalid character in scheme.\");\n           }\n         }\n@@ -393,98 +393,98 @@ fn get_authority(rawurl: ~str) ->\n \n         // deal with input class first\n         match c {\n-          '0' to '9' { }\n-          'A' to 'F' | 'a' to 'f' {\n+          '0' to '9' => (),\n+          'A' to 'F' | 'a' to 'f' => {\n             if in == digit {\n                 in = hex;\n             }\n           }\n           'G' to 'Z' | 'g' to 'z' | '-' | '.' | '_' | '~' | '%' |\n-          '&' |'\\'' | '(' | ')' | '+' | '!' | '*' | ',' | ';' | '=' {\n+          '&' |'\\'' | '(' | ')' | '+' | '!' | '*' | ',' | ';' | '=' => {\n             in = unreserved;\n           }\n-          ':' | '@' | '?' | '#' | '/' {\n+          ':' | '@' | '?' | '#' | '/' => {\n             // separators, don't change anything\n           }\n-          _ {\n+          _ => {\n             return result::err(@~\"Illegal character in authority\");\n           }\n         }\n \n         // now process states\n         match c {\n-          ':' {\n+          ':' => {\n             colon_count += 1;\n             match st {\n-              start {\n+              start => {\n                 pos = i;\n                 st = pass_host_port;\n               }\n-              pass_host_port {\n+              pass_host_port => {\n                 // multiple colons means ipv6 address.\n                 if in == unreserved {\n                     return result::err(\n                         @~\"Illegal characters in IPv6 address.\");\n                 }\n                 st = ip6_host;\n               }\n-              in_host {\n+              in_host => {\n                 pos = i;\n                 // can't be sure whether this is an ipv6 address or a port\n                 if in == unreserved {\n                     return result::err(@~\"Illegal characters in authority.\");\n                 }\n                 st = ip6_port;\n               }\n-              ip6_port {\n+              ip6_port => {\n                 if in == unreserved {\n                     return result::err(@~\"Illegal characters in authority.\");\n                 }\n                 st = ip6_host;\n               }\n-              ip6_host {\n+              ip6_host => {\n                 if colon_count > 7 {\n                     host = str::slice(rawurl, begin, i);\n                     pos = i;\n                     st = in_port;\n                 }\n               }\n-              _ {\n+              _ => {\n                 return result::err(@~\"Invalid ':' in authority.\");\n               }\n             }\n             in = digit; // reset input class\n           }\n \n-          '@' {\n+          '@' => {\n             in = digit; // reset input class\n             colon_count = 0; // reset count\n             match st {\n-              start {\n+              start => {\n                 let user = str::slice(rawurl, begin, i);\n                 userinfo = option::some({user : user,\n                                          pass: option::none});\n                 st = in_host;\n               }\n-              pass_host_port {\n+              pass_host_port => {\n                 let user = str::slice(rawurl, begin, pos);\n                 let pass = str::slice(rawurl, pos+1, i);\n                 userinfo = option::some({user: user,\n                                          pass: option::some(pass)});\n                 st = in_host;\n               }\n-              _ {\n+              _ => {\n                 return result::err(@~\"Invalid '@' in authority.\");\n               }\n             }\n             begin = i+1;\n           }\n \n-          '?' | '#' | '/' {\n+          '?' | '#' | '/' => {\n             end = i;\n             break;\n           }\n-          _ { }\n+          _ => ()\n         }\n         end = i;\n     }\n@@ -498,24 +498,24 @@ fn get_authority(rawurl: ~str) ->\n \n     // finish up\n     match st {\n-      start {\n+      start => {\n         if host_is_end_plus_one() {\n             host = str::slice(rawurl, begin, end+1);\n         } else {\n             host = str::slice(rawurl, begin, end);\n         }\n       }\n-      pass_host_port | ip6_port {\n+      pass_host_port | ip6_port => {\n         if in != digit {\n             return result::err(@~\"Non-digit characters in port.\");\n         }\n         host = str::slice(rawurl, begin, pos);\n         port = option::some(str::slice(rawurl, pos+1, end));\n       }\n-      ip6_host | in_host {\n+      ip6_host | in_host => {\n         host = str::slice(rawurl, begin, end);\n       }\n-      in_port {\n+      in_port => {\n         if in != digit {\n             return result::err(@~\"Non-digit characters in port.\");\n         }\n@@ -537,14 +537,14 @@ fn get_path(rawurl: ~str, authority : bool) ->\n     for str::each_chari(rawurl) |i,c| {\n         match c {\n           'A' to 'Z' | 'a' to 'z' | '0' to '9' | '&' |'\\'' | '(' | ')' | '.'\n-          | '@' | ':' | '%' | '/' | '+' | '!' | '*' | ',' | ';' | '=' {\n+          | '@' | ':' | '%' | '/' | '+' | '!' | '*' | ',' | ';' | '=' => {\n             again;\n           }\n-          '?' | '#' {\n+          '?' | '#' => {\n             end = i;\n             break;\n           }\n-          _ { return result::err(@~\"Invalid character in path.\") }\n+          _ => return result::err(@~\"Invalid character in path.\")\n         }\n     }\n "}, {"sha": "5c779e37507f1c647f12cc68d2fb536a45a372a4", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 86, "deletions": 104, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -134,13 +134,13 @@ fn prepend_str(rope: rope, str: @~str) -> rope {\n /// Concatenate two ropes\n fn append_rope(left: rope, right: rope) -> rope {\n    alt(left) {\n-     node::empty { return right; }\n-     node::content(left_content) {\n+     node::empty => return right,\n+     node::content(left_content) => {\n        alt(right) {\n-         node::empty { return left; }\n-     node::content(right_content) {\n+         node::empty => return left,\n+         node::content(right_content) => {\n            return node::content(node::concat2(left_content, right_content));\n-     }\n+         }\n        }\n      }\n    }\n@@ -198,12 +198,10 @@ Section: Keeping ropes healthy\n  */\n fn bal(rope:rope) -> rope {\n     alt(rope) {\n-      node::empty { return rope }\n-      node::content(x) {\n-        alt(node::bal(x)) {\n-          option::none   { rope }\n-          option::some(y) { node::content(y) }\n-        }\n+      node::empty => return rope,\n+      node::content(x) => alt(node::bal(x)) {\n+        option::none    => rope,\n+        option::some(y) => node::content(y)\n       }\n     }\n }\n@@ -229,12 +227,11 @@ Section: Transforming ropes\n fn sub_chars(rope: rope, char_offset: uint, char_len: uint) -> rope {\n     if char_len == 0u { return node::empty; }\n     alt(rope) {\n-      node::empty { fail }\n-      node::content(node) {\n-        if char_len > node::char_len(node) { fail }\n-        else {\n-            return node::content(node::sub_chars(node, char_offset, char_len))\n-        }\n+      node::empty => fail,\n+      node::content(node) => if char_len > node::char_len(node) {\n+        fail\n+      } else {\n+        return node::content(node::sub_chars(node, char_offset, char_len))\n       }\n     }\n }\n@@ -255,12 +252,11 @@ fn sub_chars(rope: rope, char_offset: uint, char_len: uint) -> rope {\n fn sub_bytes(rope: rope, byte_offset: uint, byte_len: uint) -> rope {\n     if byte_len == 0u { return node::empty; }\n     alt(rope) {\n-      node::empty { fail }\n-      node::content(node) {\n-        if byte_len > node::byte_len(node) { fail }\n-        else {\n-            return node::content(node::sub_bytes(node, byte_offset, byte_len))\n-        }\n+      node::empty => fail,\n+      node::content(node) =>if byte_len > node::byte_len(node) {\n+        fail\n+      } else {\n+        return node::content(node::sub_bytes(node, byte_offset, byte_len))\n       }\n     }\n }\n@@ -281,10 +277,10 @@ Section: Comparing ropes\n  */\n fn cmp(left: rope, right: rope) -> int {\n     alt((left, right)) {\n-      (node::empty, node::empty) { return 0; }\n-      (node::empty, _)     { return -1;}\n-      (_, node::empty)     { return  1;}\n-      (node::content(a), node::content(b)) {\n+      (node::empty, node::empty) => return 0,\n+      (node::empty, _)     => return -1,\n+      (_, node::empty)     => return  1,\n+      (node::content(a), node::content(b)) => {\n         return node::cmp(a, b);\n       }\n     }\n@@ -384,8 +380,8 @@ Section: Iterating\n  */\n fn loop_chars(rope: rope, it: fn(char) -> bool) -> bool {\n    alt(rope) {\n-      node::empty { return true }\n-      node::content(x) { return node::loop_chars(x, it) }\n+      node::empty => return true,\n+      node::content(x) => return node::loop_chars(x, it)\n    }\n }\n \n@@ -427,17 +423,17 @@ fn iter_chars(rope: rope, it: fn(char)) {\n  */\n fn loop_leaves(rope: rope, it: fn(node::leaf) -> bool) -> bool{\n    alt(rope) {\n-      node::empty { return true }\n-      node::content(x) {return node::loop_leaves(x, it)}\n+      node::empty => return true,\n+      node::content(x) => return node::loop_leaves(x, it)\n    }\n }\n \n mod iterator {\n     mod leaf {\n         fn start(rope: rope) -> node::leaf_iterator::t {\n             alt(rope) {\n-              node::empty     { return node::leaf_iterator::empty() }\n-              node::content(x) { return node::leaf_iterator::start(x) }\n+              node::empty      => return node::leaf_iterator::empty(),\n+              node::content(x) => return node::leaf_iterator::start(x)\n             }\n         }\n         fn next(it: node::leaf_iterator::t) -> option<node::leaf> {\n@@ -447,8 +443,8 @@ mod iterator {\n     mod char {\n         fn start(rope: rope) -> node::char_iterator::t {\n             alt(rope) {\n-              node::empty   { return node::char_iterator::empty() }\n-              node::content(x) { return node::char_iterator::start(x) }\n+              node::empty      => return node::char_iterator::empty(),\n+              node::content(x) => return node::char_iterator::start(x)\n             }\n         }\n         fn next(it: node::char_iterator::t) -> option<char> {\n@@ -474,8 +470,8 @@ mod iterator {\n  */\n fn height(rope: rope) -> uint {\n    alt(rope) {\n-      node::empty    { return 0u; }\n-      node::content(x) { return node::height(x); }\n+      node::empty      => return 0u,\n+      node::content(x) => return node::height(x)\n    }\n }\n \n@@ -490,8 +486,8 @@ fn height(rope: rope) -> uint {\n  */\n pure fn char_len(rope: rope) -> uint {\n    alt(rope) {\n-     node::empty           { return 0u; }\n-     node::content(x)       { return node::char_len(x) }\n+     node::empty            => return 0u,\n+     node::content(x)       => return node::char_len(x)\n    }\n }\n \n@@ -504,8 +500,8 @@ pure fn char_len(rope: rope) -> uint {\n  */\n pure fn byte_len(rope: rope) -> uint {\n    alt(rope) {\n-     node::empty           { return 0u; }\n-     node::content(x)       { return node::byte_len(x) }\n+     node::empty            => return 0u,\n+     node::content(x)       => return node::byte_len(x)\n    }\n }\n \n@@ -527,8 +523,8 @@ pure fn byte_len(rope: rope) -> uint {\n  */\n fn char_at(rope: rope, pos: uint) -> char {\n    alt(rope) {\n-      node::empty { fail }\n-      node::content(x) { return node::char_at(x, pos) }\n+      node::empty => fail,\n+      node::content(x) => return node::char_at(x, pos)\n    }\n }\n \n@@ -735,15 +731,15 @@ mod node {\n     pure fn byte_len(node: @node) -> uint {\n         //FIXME (#2744): Could we do this without the pattern-matching?\n         alt(*node) {\n-          leaf(y)  { return y.byte_len; }\n-          concat(y){ return y.byte_len; }\n+          leaf(y)   => return y.byte_len,\n+          concat(y) => return y.byte_len\n         }\n     }\n \n     pure fn char_len(node: @node) -> uint {\n         alt(*node) {\n-          leaf(y)   { return y.char_len; }\n-          concat(y) { return y.char_len; }\n+          leaf(y)   => return y.char_len,\n+          concat(y) => return y.char_len\n         }\n     }\n \n@@ -805,8 +801,8 @@ mod node {\n         let it = leaf_iterator::start(node);\n         loop {\n             alt(leaf_iterator::next(it)) {\n-              option::none { break; }\n-              option::some(x) {\n+              option::none => break,\n+              option::some(x) => {\n                 //FIXME (#2744): Replace with memcpy or something similar\n                 let mut local_buf: ~[u8] =\n                     unsafe::reinterpret_cast(*x.content);\n@@ -832,8 +828,8 @@ mod node {\n      */\n     fn flatten(node: @node) -> @node unsafe {\n         alt(*node) {\n-          leaf(_) { return node }\n-          concat(x) {\n+          leaf(_) => return node,\n+          concat(x) => {\n             return @leaf({\n                 byte_offset: 0u,\n                 byte_len:    x.byte_len,\n@@ -866,8 +862,8 @@ mod node {\n         let it = leaf_iterator::start(node);\n         loop {\n             alt (leaf_iterator::next(it)) {\n-              option::none   { break; }\n-              option::some(x) { vec::push(forest, @leaf(x)); }\n+              option::none    => break,\n+              option::some(x) => vec::push(forest, @leaf(x))\n             }\n         }\n         //2. Rebuild tree from forest\n@@ -903,15 +899,15 @@ mod node {\n                 return node;\n             }\n             alt(*node) {\n-              node::leaf(x) {\n+              node::leaf(x) => {\n                 let char_len =\n                     str::count_chars(*x.content, byte_offset, byte_len);\n                 return @leaf({byte_offset: byte_offset,\n                                 byte_len:    byte_len,\n                                 char_len:    char_len,\n                                 content:     x.content});\n               }\n-              node::concat(x) {\n+              node::concat(x) => {\n                 let left_len: uint = node::byte_len(x.left);\n                 if byte_offset <= left_len {\n                     if byte_offset + byte_len <= left_len {\n@@ -961,7 +957,7 @@ mod node {\n         let mut char_offset = char_offset;\n         loop {\n             alt(*node) {\n-              node::leaf(x) {\n+              node::leaf(x) => {\n                 if char_offset == 0u && char_len == x.char_len {\n                     return node;\n                 }\n@@ -974,7 +970,7 @@ mod node {\n                            char_len:    char_len,\n                            content:     x.content});\n               }\n-              node::concat(x) {\n+              node::concat(x) => {\n                 if char_offset == 0u && char_len == x.char_len {return node;}\n                 let left_len : uint = node::char_len(x.left);\n                 if char_offset <= left_len {\n@@ -1012,8 +1008,8 @@ mod node {\n \n     fn height(node: @node) -> uint {\n         alt(*node) {\n-          leaf(_)   { return 0u; }\n-          concat(x) { return x.height; }\n+          leaf(_)   => return 0u,\n+          concat(x) => return x.height\n         }\n     }\n \n@@ -1023,16 +1019,14 @@ mod node {\n         let mut result = 0;\n         while result == 0 {\n             alt((char_iterator::next(ita), char_iterator::next(itb))) {\n-              (option::none, option::none) {\n-                break;\n-              }\n-              (option::some(chara), option::some(charb)) {\n+              (option::none, option::none) => break,\n+              (option::some(chara), option::some(charb)) => {\n                 result = char::cmp(chara, charb);\n               }\n-              (option::some(_), _)         {\n+              (option::some(_), _) => {\n                 result = 1;\n               }\n-              (_, option::some(_))         {\n+              (_, option::some(_)) => {\n                 result = -1;\n               }\n             }\n@@ -1066,15 +1060,11 @@ mod node {\n         let mut current = node;\n         loop {\n             alt(*current) {\n-              leaf(x) {\n-                return it(x);\n-              }\n-              concat(x) {\n-                if loop_leaves(x.left, it) { //non tail call\n-                    current = x.right;       //tail call\n-                } else {\n-                    return false;\n-                }\n+              leaf(x) => return it(x),\n+              concat(x) => if loop_leaves(x.left, it) { //non tail call\n+                current = x.right;       //tail call\n+              } else {\n+                return false;\n               }\n             }\n         };\n@@ -1102,10 +1092,8 @@ mod node {\n         let mut pos     = pos;\n         loop {\n             alt *node {\n-              leaf(x) {\n-                return str::char_at(*x.content, pos);\n-              }\n-              concat({left, right, _}) {\n+              leaf(x) => return str::char_at(*x.content, pos),\n+              concat({left, right, _}) => {\n                 let left_len = char_len(left);\n                 node = if left_len > pos { left }\n                        else { pos -= left_len; right };\n@@ -1139,15 +1127,13 @@ mod node {\n                 let current = it.stack[it.stackpos];\n                 it.stackpos -= 1;\n                 alt(*current) {\n-                  concat(x) {\n+                  concat(x) => {\n                     it.stackpos += 1;\n                     it.stack[it.stackpos] = x.right;\n                     it.stackpos += 1;\n                     it.stack[it.stackpos] = x.left;\n                   }\n-                  leaf(x) {\n-                    return option::some(x);\n-                  }\n+                  leaf(x) => return option::some(x)\n                 }\n             };\n         }\n@@ -1179,16 +1165,12 @@ mod node {\n         fn next(it: t) -> option<char> {\n             loop {\n                 alt(get_current_or_next_leaf(it)) {\n-                  option::none { return option::none; }\n-                  option::some(_) {\n+                  option::none => return option::none,\n+                  option::some(_) => {\n                     let next_char = get_next_char_in_leaf(it);\n                     alt(next_char) {\n-                      option::none {\n-                        again;\n-                      }\n-                      option::some(_) {\n-                        return next_char;\n-                      }\n+                      option::none => again,\n+                      option::some(_) => return next_char\n                     }\n                   }\n                 }\n@@ -1197,12 +1179,12 @@ mod node {\n \n         fn get_current_or_next_leaf(it: t) -> option<leaf> {\n             alt(it.leaf) {\n-              option::some(_) { return it.leaf }\n-              option::none {\n+              option::some(_) => return it.leaf,\n+              option::none => {\n                 let next = leaf_iterator::next(it.leaf_iterator);\n                 alt(next) {\n-                  option::none { return option::none }\n-                  option::some(_) {\n+                  option::none => return option::none,\n+                  option::some(_) => {\n                     it.leaf          = next;\n                     it.leaf_byte_pos = 0u;\n                     return next;\n@@ -1214,8 +1196,8 @@ mod node {\n \n         fn get_next_char_in_leaf(it: t) -> option<char> {\n             alt copy it.leaf {\n-              option::none { return option::none }\n-              option::some(aleaf) {\n+              option::none => return option::none,\n+              option::some(aleaf) => {\n                 if it.leaf_byte_pos >= aleaf.byte_len {\n                     //We are actually past the end of the leaf\n                     it.leaf = option::none;\n@@ -1239,17 +1221,17 @@ mod tests {\n     //Utility function, used for sanity check\n     fn rope_to_string(r: rope) -> ~str {\n         alt(r) {\n-          node::empty { return ~\"\" }\n-          node::content(x) {\n+          node::empty => return ~\"\",\n+          node::content(x) => {\n             let str = @mut ~\"\";\n             fn aux(str: @mut ~str, node: @node::node) unsafe {\n                 alt(*node) {\n-                  node::leaf(x) {\n+                  node::leaf(x) => {\n                     *str += str::slice(\n                         *x.content, x.byte_offset,\n                         x.byte_offset + x.byte_len);\n                   }\n-                  node::concat(x) {\n+                  node::concat(x) => {\n                     aux(str, x.left);\n                     aux(str, x.right);\n                   }\n@@ -1293,11 +1275,11 @@ mod tests {\n         let mut equal   = true;\n         while equal {\n             alt(node::char_iterator::next(rope_iter)) {\n-              option::none {\n+              option::none => {\n                 if string_iter < string_len {\n                     equal = false;\n                 } break; }\n-              option::some(c) {\n+              option::some(c) => {\n                 let {ch, next} = str::char_range_at(*sample, string_iter);\n                 string_iter = next;\n                 if ch != c { equal = false; break; }\n@@ -1320,8 +1302,8 @@ mod tests {\n         let it  = iterator::char::start(r);\n         loop {\n             alt(node::char_iterator::next(it)) {\n-              option::none { break; }\n-              option::some(_) { len += 1u; }\n+              option::none => break,\n+              option::some(_) => len += 1u\n             }\n         }\n "}, {"sha": "622d31c00b926028f7b0e3cd3f112abe7dbe0cb8", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -244,16 +244,12 @@ fn deserialize_bool<D: deserializer>(d: D) -> bool {\n fn serialize_option<S: serializer,T>(s: S, v: option<T>, st: fn(T)) {\n     do s.emit_enum(~\"option\") {\n         alt v {\n-          none {\n-            do s.emit_enum_variant(~\"none\", 0u, 0u) {\n-            }\n+          none => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n           }\n \n-          some(v) {\n-            do s.emit_enum_variant(~\"some\", 1u, 1u) {\n-                do s.emit_enum_variant_arg(0u) {\n-                    st(v)\n-                }\n+          some(v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n+            do s.emit_enum_variant_arg(0u) {\n+                st(v)\n             }\n           }\n         }\n@@ -265,14 +261,8 @@ fn deserialize_option<D: deserializer,T: copy>(d: D, st: fn() -> T)\n     do d.read_enum(~\"option\") {\n         do d.read_enum_variant |i| {\n             alt check i {\n-              0u { // none\n-                none\n-              }\n-              1u { // some(v)\n-                some(d.read_enum_variant_arg(0u, || {\n-                    st()\n-                }))\n-              }\n+              0u => none,\n+              1u => some(d.read_enum_variant_arg(0u, || st() ))\n             }\n         }\n     }"}, {"sha": "2fe09f75d56c714b9e2326d8a4412568966ad7be", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -49,8 +49,11 @@ pure fn find<T: copy>(self: smallintmap<T>, key: uint) -> option<T> {\n  */\n pure fn get<T: copy>(self: smallintmap<T>, key: uint) -> T {\n     alt find(self, key) {\n-      none { error!{\"smallintmap::get(): key not present\"}; fail; }\n-      some(v) { return v; }\n+      none => {\n+        error!{\"smallintmap::get(): key not present\"};\n+        fail;\n+      }\n+      some(v) => return v\n     }\n }\n \n@@ -64,7 +67,10 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n     fn size() -> uint {\n         let mut sz = 0u;\n         for self.v.each |item| {\n-            alt item { some(_) { sz += 1u; } _ {} }\n+            alt item {\n+              some(_) => sz += 1u,\n+              _ => ()\n+            }\n         }\n         sz\n     }\n@@ -98,10 +104,8 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n         let mut idx = 0u, l = self.v.len();\n         while idx < l {\n             alt self.v.get_elt(idx) {\n-              some(elt) {\n-                if !it(idx, elt) { break; }\n-              }\n-              none { }\n+              some(elt) => if !it(idx, elt) { break }\n+              none => ()\n             }\n             idx += 1u;\n         }\n@@ -116,10 +120,8 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n         let mut idx = 0u, l = self.v.len();\n         while idx < l {\n             alt self.v.get_elt(idx) {\n-              some(elt) {\n-                if !it(&idx, &elt) { break; }\n-              }\n-              none { }\n+              some(elt) => if !it(&idx, &elt) { break }\n+              none => ()\n             }\n             idx += 1u;\n         }"}, {"sha": "a67164ee1076420a62c053dbab9763e155357775", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -22,10 +22,10 @@ fn mkdtemp(prefix: ~str, suffix: ~str) -> option<~str> {\n fn test_mkdtemp() {\n     let r = mkdtemp(~\"./\", ~\"foobar\");\n     alt r {\n-        some(p) {\n+        some(p) => {\n             os::remove_dir(p);\n             assert(str::ends_with(p, ~\"foobar\"));\n         }\n-        _ { assert(false); }\n+        _ => assert(false)\n     }\n }"}, {"sha": "1d2ae7bca5dd451504fe5dfcccdd7a82932ff8f7", "filename": "src/libstd/term.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -36,13 +36,13 @@ fn color_supported() -> bool {\n     let supported_terms = ~[~\"xterm-color\", ~\"xterm\",\n                            ~\"screen-bce\", ~\"xterm-256color\"];\n     return alt os::getenv(~\"TERM\") {\n-          option::some(env) {\n+          option::some(env) => {\n             for vec::each(supported_terms) |term| {\n                 if term == env { return true; }\n             }\n             false\n           }\n-          option::none { false }\n+          option::none => false\n         };\n }\n "}, {"sha": "890bddb3519fe9079453f96a62ebdbb309c06cd7", "filename": "src/libstd/test.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -53,8 +53,8 @@ type test_desc = {\n fn test_main(args: ~[~str], tests: ~[test_desc]) {\n     let opts =\n         alt parse_opts(args) {\n-          either::left(o) { o }\n-          either::right(m) { fail m }\n+          either::left(o) => o,\n+          either::right(m) => fail m\n         };\n     if !run_tests_console(opts, tests) { fail ~\"Some tests failed\"; }\n }\n@@ -70,8 +70,8 @@ fn parse_opts(args: ~[~str]) -> opt_res {\n     let opts = ~[getopts::optflag(~\"ignored\"), getopts::optopt(~\"logfile\")];\n     let matches =\n         alt getopts::getopts(args_, opts) {\n-          ok(m) { m }\n-          err(f) { return either::right(getopts::fail_str(f)) }\n+          ok(m) => m,\n+          err(f) => return either::right(getopts::fail_str(f))\n         };\n \n     let filter =\n@@ -106,32 +106,30 @@ fn run_tests_console(opts: test_opts,\n \n     fn callback(event: testevent, st: console_test_state) {\n         alt event {\n-          te_filtered(filtered_tests) {\n+          te_filtered(filtered_tests) => {\n             st.total = vec::len(filtered_tests);\n             let noun = if st.total != 1u { ~\"tests\" } else { ~\"test\" };\n             st.out.write_line(fmt!{\"\\nrunning %u %s\", st.total, noun});\n           }\n-          te_wait(test) { st.out.write_str(fmt!{\"test %s ... \", test.name}); }\n-          te_result(test, result) {\n+          te_wait(test) => st.out.write_str(fmt!{\"test %s ... \", test.name}),\n+          te_result(test, result) => {\n             alt st.log_out {\n-                some(f) {\n-                    write_log(f, result, test);\n-                }\n-                none {}\n+                some(f) => write_log(f, result, test),\n+                none => ()\n             }\n             alt result {\n-              tr_ok {\n+              tr_ok => {\n                 st.passed += 1u;\n                 write_ok(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n               }\n-              tr_failed {\n+              tr_failed => {\n                 st.failed += 1u;\n                 write_failed(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n                 vec::push(st.failures, copy test);\n               }\n-              tr_ignored {\n+              tr_ignored => {\n                 st.ignored += 1u;\n                 write_ignored(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n@@ -142,15 +140,13 @@ fn run_tests_console(opts: test_opts,\n     }\n \n     let log_out = alt opts.logfile {\n-        some(path) {\n-            alt io::file_writer(path, ~[io::create, io::truncate]) {\n-                result::ok(w) { some(w) }\n-                result::err(s) {\n-                    fail(fmt!{\"can't open output file: %s\", s})\n-                }\n-            }\n+        some(path) => alt io::file_writer(path, ~[io::create, io::truncate]) {\n+          result::ok(w) => some(w),\n+          result::err(s) => {\n+              fail(fmt!{\"can't open output file: %s\", s})\n+          }\n         }\n-        none { none }\n+        none => none\n     };\n \n     let st =\n@@ -185,9 +181,9 @@ fn run_tests_console(opts: test_opts,\n     fn write_log(out: io::writer, result: test_result, test: test_desc) {\n         out.write_line(fmt!{\"%s %s\",\n                     alt result {\n-                        tr_ok { ~\"ok\" }\n-                        tr_failed { ~\"failed\" }\n-                        tr_ignored { ~\"ignored\" }\n+                        tr_ok => ~\"ok\",\n+                        tr_failed => ~\"failed\",\n+                        tr_ignored => ~\"ignored\"\n                     }, test.name});\n     }\n \n@@ -339,8 +335,8 @@ fn filter_tests(opts: test_opts,\n     } else {\n         let filter_str =\n             alt opts.filter {\n-          option::some(f) { f }\n-          option::none { ~\"\" }\n+          option::some(f) => f,\n+          option::none => ~\"\"\n         };\n \n         fn filter_fn(test: test_desc, filter_str: ~str) ->\n@@ -483,16 +479,20 @@ mod tests {\n     #[test]\n     fn first_free_arg_should_be_a_filter() {\n         let args = ~[~\"progname\", ~\"filter\"];\n-        let opts = alt parse_opts(args) { either::left(o) { o }\n-          _ { fail ~\"Malformed arg in first_free_arg_should_be_a_filter\"; } };\n+        let opts = alt parse_opts(args) {\n+          either::left(o) => o,\n+          _ => fail ~\"Malformed arg in first_free_arg_should_be_a_filter\"\n+        };\n         assert ~\"filter\" == option::get(opts.filter);\n     }\n \n     #[test]\n     fn parse_ignored_flag() {\n         let args = ~[~\"progname\", ~\"filter\", ~\"--ignored\"];\n-        let opts = alt parse_opts(args) { either::left(o) { o }\n-          _ { fail ~\"Malformed arg in parse_ignored_flag\"; } };\n+        let opts = alt parse_opts(args) {\n+          either::left(o) => o,\n+          _ => fail ~\"Malformed arg in parse_ignored_flag\"\n+        };\n         assert (opts.run_ignored);\n     }\n "}, {"sha": "23b6bf222762448442efdb4248d493e0e81ad7da", "filename": "src/libstd/time.rs", "status": "modified", "additions": 209, "deletions": 237, "changes": 446, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -182,11 +182,11 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n             pos = next;\n \n             alt ch {\n-              '0' to '9' {\n+              '0' to '9' => {\n                 value = value * 10_i32 + (ch as i32 - '0' as i32);\n               }\n-              ' ' if ws { }\n-              _ { return none; }\n+              ' ' if ws => (),\n+              _ => return none\n             }\n             i += 1u;\n         }\n@@ -209,83 +209,73 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n     fn parse_type(s: ~str, pos: uint, ch: char, tm: tm_mut)\n       -> result<uint, ~str> {\n         alt ch {\n-          'A' {\n-            alt match_strs(s, pos, ~[\n-                (~\"Sunday\", 0_i32),\n-                (~\"Monday\", 1_i32),\n-                (~\"Tuesday\", 2_i32),\n-                (~\"Wednesday\", 3_i32),\n-                (~\"Thursday\", 4_i32),\n-                (~\"Friday\", 5_i32),\n-                (~\"Saturday\", 6_i32)\n-            ]) {\n-              some(item) { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n-              none { err(~\"Invalid day\") }\n-            }\n+          'A' => alt match_strs(s, pos, ~[\n+              (~\"Sunday\", 0_i32),\n+              (~\"Monday\", 1_i32),\n+              (~\"Tuesday\", 2_i32),\n+              (~\"Wednesday\", 3_i32),\n+              (~\"Thursday\", 4_i32),\n+              (~\"Friday\", 5_i32),\n+              (~\"Saturday\", 6_i32)\n+          ]) {\n+            some(item) => { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n+            none => err(~\"Invalid day\")\n           }\n-          'a' {\n-            alt match_strs(s, pos, ~[\n-                (~\"Sun\", 0_i32),\n-                (~\"Mon\", 1_i32),\n-                (~\"Tue\", 2_i32),\n-                (~\"Wed\", 3_i32),\n-                (~\"Thu\", 4_i32),\n-                (~\"Fri\", 5_i32),\n-                (~\"Sat\", 6_i32)\n-            ]) {\n-              some(item) { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n-              none { err(~\"Invalid day\") }\n-            }\n+          'a' => alt match_strs(s, pos, ~[\n+              (~\"Sun\", 0_i32),\n+              (~\"Mon\", 1_i32),\n+              (~\"Tue\", 2_i32),\n+              (~\"Wed\", 3_i32),\n+              (~\"Thu\", 4_i32),\n+              (~\"Fri\", 5_i32),\n+              (~\"Sat\", 6_i32)\n+          ]) {\n+            some(item) => { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n+            none => err(~\"Invalid day\")\n           }\n-          'B' {\n-            alt match_strs(s, pos, ~[\n-                (~\"January\", 0_i32),\n-                (~\"February\", 1_i32),\n-                (~\"March\", 2_i32),\n-                (~\"April\", 3_i32),\n-                (~\"May\", 4_i32),\n-                (~\"June\", 5_i32),\n-                (~\"July\", 6_i32),\n-                (~\"August\", 7_i32),\n-                (~\"September\", 8_i32),\n-                (~\"October\", 9_i32),\n-                (~\"November\", 10_i32),\n-                (~\"December\", 11_i32)\n-            ]) {\n-              some(item) { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n-              none { err(~\"Invalid month\") }\n-            }\n+          'B' => alt match_strs(s, pos, ~[\n+              (~\"January\", 0_i32),\n+              (~\"February\", 1_i32),\n+              (~\"March\", 2_i32),\n+              (~\"April\", 3_i32),\n+              (~\"May\", 4_i32),\n+              (~\"June\", 5_i32),\n+              (~\"July\", 6_i32),\n+              (~\"August\", 7_i32),\n+              (~\"September\", 8_i32),\n+              (~\"October\", 9_i32),\n+              (~\"November\", 10_i32),\n+              (~\"December\", 11_i32)\n+          ]) {\n+            some(item) => { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n+            none => err(~\"Invalid month\")\n           }\n-          'b' | 'h' {\n-            alt match_strs(s, pos, ~[\n-                (~\"Jan\", 0_i32),\n-                (~\"Feb\", 1_i32),\n-                (~\"Mar\", 2_i32),\n-                (~\"Apr\", 3_i32),\n-                (~\"May\", 4_i32),\n-                (~\"Jun\", 5_i32),\n-                (~\"Jul\", 6_i32),\n-                (~\"Aug\", 7_i32),\n-                (~\"Sep\", 8_i32),\n-                (~\"Oct\", 9_i32),\n-                (~\"Nov\", 10_i32),\n-                (~\"Dec\", 11_i32)\n-            ]) {\n-              some(item) { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n-              none { err(~\"Invalid month\") }\n-            }\n+          'b' | 'h' => alt match_strs(s, pos, ~[\n+              (~\"Jan\", 0_i32),\n+              (~\"Feb\", 1_i32),\n+              (~\"Mar\", 2_i32),\n+              (~\"Apr\", 3_i32),\n+              (~\"May\", 4_i32),\n+              (~\"Jun\", 5_i32),\n+              (~\"Jul\", 6_i32),\n+              (~\"Aug\", 7_i32),\n+              (~\"Sep\", 8_i32),\n+              (~\"Oct\", 9_i32),\n+              (~\"Nov\", 10_i32),\n+              (~\"Dec\", 11_i32)\n+          ]) {\n+            some(item) => { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n+            none => err(~\"Invalid month\")\n           }\n-          'C' {\n-            alt match_digits(s, pos, 2u, false) {\n-              some(item) {\n+          'C' => alt match_digits(s, pos, 2u, false) {\n+            some(item) => {\n                 let (v, pos) = item;\n-                tm.tm_year += (v * 100_i32) - 1900_i32;\n-                ok(pos)\n+                  tm.tm_year += (v * 100_i32) - 1900_i32;\n+                  ok(pos)\n               }\n-              none { err(~\"Invalid year\") }\n-            }\n+            none => err(~\"Invalid year\")\n           }\n-          'c' {\n+          'c' => {\n             parse_type(s, pos, 'a', tm)\n                 .chain(|pos| parse_char(s, pos, ' '))\n                 .chain(|pos| parse_type(s, pos, 'b', tm))\n@@ -296,116 +286,108 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n                 .chain(|pos| parse_char(s, pos, ' '))\n                 .chain(|pos| parse_type(s, pos, 'Y', tm))\n           }\n-          'D' | 'x' {\n+          'D' | 'x' => {\n             parse_type(s, pos, 'm', tm)\n                 .chain(|pos| parse_char(s, pos, '/'))\n                 .chain(|pos| parse_type(s, pos, 'd', tm))\n                 .chain(|pos| parse_char(s, pos, '/'))\n                 .chain(|pos| parse_type(s, pos, 'y', tm))\n           }\n-          'd' {\n-            alt match_digits(s, pos, 2u, false) {\n-              some(item) { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n-              none { err(~\"Invalid day of the month\") }\n-            }\n+          'd' => alt match_digits(s, pos, 2u, false) {\n+            some(item) => { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n+            none => err(~\"Invalid day of the month\")\n           }\n-          'e' {\n-            alt match_digits(s, pos, 2u, true) {\n-              some(item) { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n-              none { err(~\"Invalid day of the month\") }\n-            }\n+          'e' => alt match_digits(s, pos, 2u, true) {\n+            some(item) => { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n+            none => err(~\"Invalid day of the month\")\n           }\n-          'F' {\n+          'F' => {\n             parse_type(s, pos, 'Y', tm)\n                 .chain(|pos| parse_char(s, pos, '-'))\n                 .chain(|pos| parse_type(s, pos, 'm', tm))\n                 .chain(|pos| parse_char(s, pos, '-'))\n                 .chain(|pos| parse_type(s, pos, 'd', tm))\n           }\n-          'H' {\n+          'H' => {\n             // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n-              some(item) { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n-              none { err(~\"Invalid hour\") }\n+              some(item) => { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n+              none => err(~\"Invalid hour\")\n             }\n           }\n-          'I' {\n+          'I' => {\n             // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n-              some(item) {\n+              some(item) => {\n                   let (v, pos) = item;\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n                   ok(pos)\n               }\n-              none { err(~\"Invalid hour\") }\n+              none => err(~\"Invalid hour\")\n             }\n           }\n-          'j' {\n+          'j' => {\n             // FIXME (#2350): range check.\n             alt match_digits(s, pos, 3u, false) {\n-              some(item) {\n+              some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_yday = v - 1_i32;\n                 ok(pos)\n               }\n-              none { err(~\"Invalid year\") }\n+              none => err(~\"Invalid year\")\n             }\n           }\n-          'k' {\n+          'k' => {\n             // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, true) {\n-              some(item) { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n-              none { err(~\"Invalid hour\") }\n+              some(item) => { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n+              none => err(~\"Invalid hour\")\n             }\n           }\n-          'l' {\n+          'l' => {\n             // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, true) {\n-              some(item) {\n+              some(item) => {\n                   let (v, pos) = item;\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n                   ok(pos)\n               }\n-              none { err(~\"Invalid hour\") }\n+              none => err(~\"Invalid hour\")\n             }\n           }\n-          'M' {\n+          'M' => {\n             // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n-              some(item) { let (v, pos) = item; tm.tm_min = v; ok(pos) }\n-              none { err(~\"Invalid minute\") }\n+              some(item) => { let (v, pos) = item; tm.tm_min = v; ok(pos) }\n+              none => err(~\"Invalid minute\")\n             }\n           }\n-          'm' {\n+          'm' => {\n             // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n-              some(item) {\n+              some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_mon = v - 1_i32;\n                 ok(pos)\n               }\n-              none { err(~\"Invalid month\") }\n+              none => err(~\"Invalid month\")\n             }\n           }\n-          'n' { parse_char(s, pos, '\\n') }\n-          'P' {\n-            alt match_strs(s, pos, ~[(~\"am\", 0_i32), (~\"pm\", 12_i32)]) {\n-              some(item) { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n-              none { err(~\"Invalid hour\") }\n-            }\n+          'n' => parse_char(s, pos, '\\n'),\n+          'P' => alt match_strs(s, pos, ~[(~\"am\", 0_i32), (~\"pm\", 12_i32)]) {\n+            some(item) => { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n+            none => err(~\"Invalid hour\")\n           }\n-          'p' {\n-            alt match_strs(s, pos, ~[(~\"AM\", 0_i32), (~\"PM\", 12_i32)]) {\n-              some(item) { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n-              none { err(~\"Invalid hour\") }\n-            }\n+          'p' => alt match_strs(s, pos, ~[(~\"AM\", 0_i32), (~\"PM\", 12_i32)]) {\n+            some(item) => { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n+            none => err(~\"Invalid hour\")\n           }\n-          'R' {\n+          'R' => {\n             parse_type(s, pos, 'H', tm)\n                 .chain(|pos| parse_char(s, pos, ':'))\n                 .chain(|pos| parse_type(s, pos, 'M', tm))\n           }\n-          'r' {\n+          'r' => {\n             parse_type(s, pos, 'I', tm)\n                 .chain(|pos| parse_char(s, pos, ':'))\n                 .chain(|pos| parse_type(s, pos, 'M', tm))\n@@ -414,77 +396,77 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n                 .chain(|pos| parse_char(s, pos, ' '))\n                 .chain(|pos| parse_type(s, pos, 'p', tm))\n           }\n-          'S' {\n+          'S' => {\n             // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n-              some(item) {\n+              some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_sec = v;\n                 ok(pos)\n               }\n-              none { err(~\"Invalid second\") }\n+              none => err(~\"Invalid second\")\n             }\n           }\n           //'s' {}\n-          'T' | 'X' {\n+          'T' | 'X' => {\n             parse_type(s, pos, 'H', tm)\n                 .chain(|pos| parse_char(s, pos, ':'))\n                 .chain(|pos| parse_type(s, pos, 'M', tm))\n                 .chain(|pos| parse_char(s, pos, ':'))\n                 .chain(|pos| parse_type(s, pos, 'S', tm))\n           }\n-          't' { parse_char(s, pos, '\\t') }\n-          'u' {\n+          't' => parse_char(s, pos, '\\t'),\n+          'u' => {\n             // FIXME (#2350): range check.\n             alt match_digits(s, pos, 1u, false) {\n-              some(item) {\n+              some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_wday = v;\n                 ok(pos)\n               }\n-              none { err(~\"Invalid weekday\") }\n+              none => err(~\"Invalid weekday\")\n             }\n           }\n-          'v' {\n+          'v' => {\n             parse_type(s, pos, 'e', tm)\n                 .chain(|pos| parse_char(s, pos, '-'))\n                 .chain(|pos| parse_type(s, pos, 'b', tm))\n                 .chain(|pos| parse_char(s, pos, '-'))\n                 .chain(|pos| parse_type(s, pos, 'Y', tm))\n           }\n           //'W' {}\n-          'w' {\n+          'w' => {\n             // FIXME (#2350): range check.\n             alt match_digits(s, pos, 1u, false) {\n-              some(item) { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n-              none { err(~\"Invalid weekday\") }\n+              some(item) => { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n+              none => err(~\"Invalid weekday\")\n             }\n           }\n           //'X' {}\n           //'x' {}\n-          'Y' {\n+          'Y' => {\n             // FIXME (#2350): range check.\n             alt match_digits(s, pos, 4u, false) {\n-              some(item) {\n+              some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_year = v - 1900_i32;\n                 ok(pos)\n               }\n-              none { err(~\"Invalid weekday\") }\n+              none => err(~\"Invalid weekday\")\n             }\n           }\n-          'y' {\n+          'y' => {\n             // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n-              some(item) {\n+              some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_year = v - 1900_i32;\n                 ok(pos)\n               }\n-              none { err(~\"Invalid weekday\") }\n+              none => err(~\"Invalid weekday\")\n             }\n           }\n-          'Z' {\n+          'Z' => {\n             if match_str(s, pos, ~\"UTC\") || match_str(s, pos, ~\"GMT\") {\n                 tm.tm_gmtoff = 0_i32;\n                 tm.tm_zone = ~\"UTC\";\n@@ -503,12 +485,12 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n                 ok(pos)\n             }\n           }\n-          'z' {\n+          'z' => {\n             let {ch, next} = str::char_range_at(s, pos);\n \n             if ch == '+' || ch == '-' {\n                 alt match_digits(s, next, 4u, false) {\n-                  some(item) {\n+                  some(item) => {\n                     let (v, pos) = item;\n                     if v == 0_i32 {\n                         tm.tm_gmtoff = 0_i32;\n@@ -517,14 +499,14 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n \n                     ok(pos)\n                   }\n-                  none { err(~\"Invalid zone offset\") }\n+                  none => err(~\"Invalid zone offset\")\n                 }\n             } else {\n                 err(~\"Invalid zone offset\")\n             }\n           }\n-          '%' { parse_char(s, pos, '%') }\n-          ch {\n+          '%' => parse_char(s, pos, '%'),\n+          ch => {\n             err(fmt!{\"unknown formatting type: %?\", str::from_char(ch)})\n           }\n         }\n@@ -553,13 +535,11 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n             let {ch, next} = str::char_range_at(s, pos);\n \n             alt rdr.read_char() {\n-              '%' {\n-                alt parse_type(s, pos, rdr.read_char(), tm) {\n-                  ok(next) { pos = next; }\n-                  err(e) { result = err(e); break; }\n-                }\n+              '%' => alt parse_type(s, pos, rdr.read_char(), tm) {\n+                ok(next) => pos = next,\n+                  err(e) => { result = err(e); break; }\n               }\n-              c {\n+              c => {\n                 if c != ch { break }\n                 pos = next;\n               }\n@@ -589,154 +569,146 @@ fn strftime(format: ~str, tm: tm) -> ~str {\n     fn parse_type(ch: char, tm: tm) -> ~str {\n         //FIXME (#2350): Implement missing types.\n         alt check ch {\n-          'A' {\n-            alt check tm.tm_wday as int {\n-              0 { ~\"Sunday\" }\n-              1 { ~\"Monday\" }\n-              2 { ~\"Tuesday\" }\n-              3 { ~\"Wednesday\" }\n-              4 { ~\"Thursday\" }\n-              5 { ~\"Friday\" }\n-              6 { ~\"Saturday\" }\n-            }\n+          'A' => alt check tm.tm_wday as int {\n+            0 => ~\"Sunday\",\n+            1 => ~\"Monday\",\n+            2 => ~\"Tuesday\",\n+            3 => ~\"Wednesday\",\n+            4 => ~\"Thursday\",\n+            5 => ~\"Friday\",\n+            6 => ~\"Saturday\"\n           }\n-          'a' {\n-            alt check tm.tm_wday as int {\n-              0 { ~\"Sun\" }\n-              1 { ~\"Mon\" }\n-              2 { ~\"Tue\" }\n-              3 { ~\"Wed\" }\n-              4 { ~\"Thu\" }\n-              5 { ~\"Fri\" }\n-              6 { ~\"Sat\" }\n-            }\n+          'a' => alt check tm.tm_wday as int {\n+            0 => ~\"Sun\",\n+            1 => ~\"Mon\",\n+            2 => ~\"Tue\",\n+            3 => ~\"Wed\",\n+            4 => ~\"Thu\",\n+            5 => ~\"Fri\",\n+            6 => ~\"Sat\"\n           }\n-          'B' {\n-            alt check tm.tm_mon as int {\n-              0 { ~\"January\" }\n-              1 { ~\"February\" }\n-              2 { ~\"March\" }\n-              3 { ~\"April\" }\n-              4 { ~\"May\" }\n-              5 { ~\"June\" }\n-              6 { ~\"July\" }\n-              7 { ~\"August\" }\n-              8 { ~\"September\" }\n-              9 { ~\"October\" }\n-              10 { ~\"November\" }\n-              11 { ~\"December\" }\n-            }\n+          'B' => alt check tm.tm_mon as int {\n+            0 => ~\"January\",\n+            1 => ~\"February\",\n+            2 => ~\"March\",\n+            3 => ~\"April\",\n+            4 => ~\"May\",\n+            5 => ~\"June\",\n+            6 => ~\"July\",\n+            7 => ~\"August\",\n+            8 => ~\"September\",\n+            9 => ~\"October\",\n+            10 => ~\"November\",\n+            11 => ~\"December\"\n           }\n-          'b' | 'h' {\n-            alt check tm.tm_mon as int {\n-              0 { ~\"Jan\" }\n-              1 { ~\"Feb\" }\n-              2 { ~\"Mar\" }\n-              3 { ~\"Apr\" }\n-              4 { ~\"May\" }\n-              5 { ~\"Jun\" }\n-              6 { ~\"Jul\" }\n-              7 { ~\"Aug\" }\n-              8 { ~\"Sep\" }\n-              9 { ~\"Oct\" }\n-              10 { ~\"Nov\" }\n-              11 { ~\"Dec\" }\n-            }\n+          'b' | 'h' => alt check tm.tm_mon as int {\n+            0 => ~\"Jan\",\n+            1 => ~\"Feb\",\n+            2 => ~\"Mar\",\n+            3 => ~\"Apr\",\n+            4 => ~\"May\",\n+            5 => ~\"Jun\",\n+            6 => ~\"Jul\",\n+            7 => ~\"Aug\",\n+            8 => ~\"Sep\",\n+            9 => ~\"Oct\",\n+            10 => ~\"Nov\",\n+            11 => ~\"Dec\",\n           }\n-          'C' { fmt!{\"%02d\", (tm.tm_year as int + 1900) / 100} }\n-          'c' {\n+          'C' => fmt!{\"%02d\", (tm.tm_year as int + 1900) / 100},\n+          'c' => {\n             fmt!{\"%s %s %s %s %s\",\n                 parse_type('a', tm),\n                 parse_type('b', tm),\n                 parse_type('e', tm),\n                 parse_type('T', tm),\n                 parse_type('Y', tm)}\n           }\n-          'D' | 'x' {\n+          'D' | 'x' => {\n             fmt!{\"%s/%s/%s\",\n                 parse_type('m', tm),\n                 parse_type('d', tm),\n                 parse_type('y', tm)}\n           }\n-          'd' { fmt!{\"%02d\", tm.tm_mday as int} }\n-          'e' { fmt!{\"%2d\", tm.tm_mday as int} }\n-          'F' {\n+          'd' => fmt!{\"%02d\", tm.tm_mday as int},\n+          'e' => fmt!{\"%2d\", tm.tm_mday as int},\n+          'F' => {\n             fmt!{\"%s-%s-%s\",\n                 parse_type('Y', tm),\n                 parse_type('m', tm),\n                 parse_type('d', tm)}\n           }\n           //'G' {}\n           //'g' {}\n-          'H' { fmt!{\"%02d\", tm.tm_hour as int} }\n-          'I' {\n+          'H' => fmt!{\"%02d\", tm.tm_hour as int},\n+          'I' => {\n             let mut h = tm.tm_hour as int;\n             if h == 0 { h = 12 }\n             if h > 12 { h -= 12 }\n             fmt!{\"%02d\", h}\n           }\n-          'j' { fmt!{\"%03d\", tm.tm_yday as int + 1} }\n-          'k' { fmt!{\"%2d\", tm.tm_hour as int} }\n-          'l' {\n+          'j' => fmt!{\"%03d\", tm.tm_yday as int + 1},\n+          'k' => fmt!{\"%2d\", tm.tm_hour as int},\n+          'l' => {\n             let mut h = tm.tm_hour as int;\n             if h == 0 { h = 12 }\n             if h > 12 { h -= 12 }\n             fmt!{\"%2d\", h}\n           }\n-          'M' { fmt!{\"%02d\", tm.tm_min as int} }\n-          'm' { fmt!{\"%02d\", tm.tm_mon as int + 1} }\n-          'n' { ~\"\\n\" }\n-          'P' { if tm.tm_hour as int < 12 { ~\"am\" } else { ~\"pm\" } }\n-          'p' { if tm.tm_hour as int < 12 { ~\"AM\" } else { ~\"PM\" } }\n-          'R' {\n+          'M' => fmt!{\"%02d\", tm.tm_min as int},\n+          'm' => fmt!{\"%02d\", tm.tm_mon as int + 1},\n+          'n' => ~\"\\n\",\n+          'P' => if tm.tm_hour as int < 12 { ~\"am\" } else { ~\"pm\" }\n+          'p' => if tm.tm_hour as int < 12 { ~\"AM\" } else { ~\"PM\" }\n+          'R' => {\n             fmt!{\"%s:%s\",\n                 parse_type('H', tm),\n                 parse_type('M', tm)}\n           }\n-          'r' {\n+          'r' => {\n             fmt!{\"%s:%s:%s %s\",\n                 parse_type('I', tm),\n                 parse_type('M', tm),\n                 parse_type('S', tm),\n                 parse_type('p', tm)}\n           }\n-          'S' { fmt!{\"%02d\", tm.tm_sec as int} }\n-          's' { fmt!{\"%d\", tm.to_timespec().sec as int} }\n-          'T' | 'X' {\n+          'S' => fmt!{\"%02d\", tm.tm_sec as int},\n+          's' => fmt!{\"%d\", tm.to_timespec().sec as int},\n+          'T' | 'X' => {\n             fmt!{\"%s:%s:%s\",\n                 parse_type('H', tm),\n                 parse_type('M', tm),\n                 parse_type('S', tm)}\n           }\n-          't' { ~\"\\t\" }\n+          't' => ~\"\\t\",\n           //'U' {}\n-          'u' {\n+          'u' => {\n             let i = tm.tm_wday as int;\n             int::str(if i == 0 { 7 } else { i })\n           }\n           //'V' {}\n-          'v' {\n+          'v' => {\n             fmt!{\"%s-%s-%s\",\n                 parse_type('e', tm),\n                 parse_type('b', tm),\n                 parse_type('Y', tm)}\n           }\n           //'W' {}\n-          'w' { int::str(tm.tm_wday as int) }\n+          'w' => int::str(tm.tm_wday as int),\n           //'X' {}\n           //'x' {}\n-          'Y' { int::str(tm.tm_year as int + 1900) }\n-          'y' { fmt!{\"%02d\", (tm.tm_year as int + 1900) % 100} }\n-          'Z' { tm.tm_zone }\n-          'z' {\n+          'Y' => int::str(tm.tm_year as int + 1900),\n+          'y' => fmt!{\"%02d\", (tm.tm_year as int + 1900) % 100},\n+          'Z' => tm.tm_zone,\n+          'z' => {\n             let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = i32::abs(tm.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n             m -= h * 60_i32;\n             fmt!{\"%c%02d%02d\", sign, h as int, m as int}\n           }\n           //'+' {}\n-          '%' { ~\"%\" }\n+          '%' => ~\"%\"\n         }\n     }\n \n@@ -745,8 +717,8 @@ fn strftime(format: ~str, tm: tm) -> ~str {\n     do io::with_str_reader(format) |rdr| {\n         while !rdr.eof() {\n             alt rdr.read_char() {\n-                '%' { buf += parse_type(rdr.read_char(), tm); }\n-                ch { str::push_char(buf, ch); }\n+                '%' => buf += parse_type(rdr.read_char(), tm),\n+                ch => str::push_char(buf, ch)\n             }\n         }\n     }\n@@ -961,7 +933,7 @@ mod tests {\n         tzset();\n \n         alt strptime(~\"\", ~\"\") {\n-          ok(tm) {\n+          ok(tm) => {\n             assert tm.tm_sec == 0_i32;\n             assert tm.tm_min == 0_i32;\n             assert tm.tm_hour == 0_i32;\n@@ -974,7 +946,7 @@ mod tests {\n             assert tm.tm_zone == ~\"\";\n             assert tm.tm_nsec == 0_i32;\n           }\n-          err(_) {}\n+          err(_) => ()\n         }\n \n         let format = ~\"%a %b %e %T %Y\";\n@@ -983,8 +955,8 @@ mod tests {\n             == err(~\"Invalid time\");\n \n         alt strptime(~\"Fri Feb 13 15:31:30 2009\", format) {\n-          err(e) { fail e }\n-          ok(tm) {\n+          err(e) => fail e,\n+          ok(tm) => {\n             assert tm.tm_sec == 30_i32;\n             assert tm.tm_min == 31_i32;\n             assert tm.tm_hour == 15_i32;\n@@ -1002,8 +974,8 @@ mod tests {\n \n         fn test(s: ~str, format: ~str) -> bool {\n             alt strptime(s, format) {\n-              ok(tm) { tm.strftime(format) == s }\n-              err(e) { fail e }\n+              ok(tm) => tm.strftime(format) == s,\n+              err(e) => fail e\n             }\n         }\n "}, {"sha": "de629d98d6353eae64b28ff27b99ab044b947d1c", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -216,8 +216,11 @@ mod test {\n             };\n \n             alt recv_timeout(hl_loop, 10u, test_po) {\n-              some(val) { assert val == expected; successes += 1; }\n-              _ { failures += 1; }\n+              some(val) => {\n+                assert val == expected;\n+                successes += 1;\n+              }\n+              _ => failures += 1\n             };\n         }\n \n@@ -241,8 +244,8 @@ mod test {\n             };\n \n             alt recv_timeout(hl_loop, 1u, test_po) {\n-              none { successes += 1; }\n-              _ { failures += 1; }\n+              none => successes += 1,\n+              _ => failures += 1\n             };\n         }\n "}, {"sha": "ab7330fb1eecab16467c188ee01b28aa055008ef", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -31,14 +31,14 @@ fn treemap<K, V>() -> treemap<K, V> { @mut none }\n /// Insert a value into the map\n fn insert<K: copy, V: copy>(m: &mut tree_edge<K, V>, k: K, v: V) {\n     alt copy *m {\n-      none {\n+      none => {\n         *m = some(@tree_node({key: k,\n                               mut value: v,\n                               mut left: none,\n                               mut right: none}));\n         return;\n       }\n-      some(node) {\n+      some(node) => {\n         if k == node.key {\n             node.value = v;\n         } else if k < node.key {\n@@ -53,10 +53,10 @@ fn insert<K: copy, V: copy>(m: &mut tree_edge<K, V>, k: K, v: V) {\n /// Find a value based on the key\n fn find<K: copy, V: copy>(m: &const tree_edge<K, V>, k: K) -> option<V> {\n     alt copy *m {\n-      none { none }\n+      none => none,\n \n       // FIXME (#2808): was that an optimization?\n-      some(node) {\n+      some(node) => {\n         if k == node.key {\n             some(node.value)\n         } else if k < node.key {\n@@ -71,8 +71,8 @@ fn find<K: copy, V: copy>(m: &const tree_edge<K, V>, k: K) -> option<V> {\n /// Visit all pairs in the map in order.\n fn traverse<K, V: copy>(m: &const tree_edge<K, V>, f: fn(K, V)) {\n     alt copy *m {\n-      none { }\n-      some(node) {\n+      none => (),\n+      some(node) => {\n         traverse(&const node.left, f);\n         // copy of value is req'd as f() requires an immutable ptr\n         f(node.key, copy node.value);"}, {"sha": "52e4879c0b2d4435cf7c695c6873b929c7274fbd", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -57,14 +57,14 @@ fn get_monitor_task_gl() -> iotask unsafe {\n             loop {\n                 debug!{\"in outer_loop...\"};\n                 alt select2(weak_exit_po, msg_po) {\n-                  left(weak_exit) {\n+                  left(weak_exit) => {\n                     // all normal tasks have ended, tell the\n                     // libuv loop to tear_down, then exit\n                     debug!{\"weak_exit_po recv'd msg: %?\", weak_exit};\n                     iotask::exit(hl_loop);\n                     break;\n                   }\n-                  right(fetch_ch) {\n+                  right(fetch_ch) => {\n                     debug!{\"hl_loop req recv'd: %?\", fetch_ch};\n                     fetch_ch.send(hl_loop);\n                   }"}, {"sha": "5b9d3b1f2f2d106e202d1679d22a8a090bccab4c", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -145,12 +145,8 @@ extern fn wake_up_cb(async_handle: *ll::uv_async_t,\n \n     while msg_po.peek() {\n         alt msg_po.recv() {\n-          interaction(cb) {\n-            cb(loop_ptr);\n-          }\n-          teardown_loop {\n-            begin_teardown(data);\n-          }\n+          interaction(cb) => cb(loop_ptr),\n+          teardown_loop => begin_teardown(data)\n         }\n     }\n }"}, {"sha": "9d120cce7428222c02d193250fcad215184b34fb", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -849,12 +849,8 @@ unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n         let result = rustrt::rust_uv_ip6_name(src_unsafe_ptr,\n                                               dst_buf, size as libc::size_t);\n         alt result {\n-          0i32 {\n-            str::unsafe::from_buf(dst_buf)\n-          }\n-          _ {\n-            ~\"\"\n-          }\n+          0i32 => str::unsafe::from_buf(dst_buf),\n+          _ => ~\"\"\n         }\n     }\n }"}, {"sha": "1e43ae219bab1b6fd8d34962e92bdbb774a4892c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -194,8 +194,8 @@ enum vstore {\n \n pure fn is_blockish(p: ast::proto) -> bool {\n     alt p {\n-      proto_block { true }\n-      proto_bare | proto_uniq | proto_box { false }\n+      proto_block => true,\n+      proto_bare | proto_uniq | proto_box => false\n     }\n }\n "}, {"sha": "f23385f2e17a48f7822d9177b6763abf4a5454ea", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -13,8 +13,8 @@ type path = ~[path_elt];\n fn path_to_str_with_sep(p: path, sep: ~str) -> ~str {\n     let strs = do vec::map(p) |e| {\n         alt e {\n-          path_mod(s) { /* FIXME (#2543) */ copy *s }\n-          path_name(s) { /* FIXME (#2543) */ copy *s }\n+          path_mod(s) => /* FIXME (#2543) */ copy *s,\n+          path_name(s) => /* FIXME (#2543) */ copy *s\n         }\n     };\n     str::connect(strs, sep)\n@@ -105,12 +105,12 @@ fn map_decoded_item(diag: span_handler,\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now:\n     alt ii {\n-      ii_item(*) | ii_ctor(*) | ii_dtor(*) { /* fallthrough */ }\n-      ii_foreign(i) {\n+      ii_item(*) | ii_ctor(*) | ii_dtor(*) => { /* fallthrough */ }\n+      ii_foreign(i) => {\n         cx.map.insert(i.id, node_foreign_item(i, foreign_abi_rust_intrinsic,\n                                              @path));\n       }\n-      ii_method(impl_did, m) {\n+      ii_method(impl_did, m) => {\n         map_method(impl_did, @path, m, cx);\n       }\n     }\n@@ -128,7 +128,7 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n         cx.local_id += 1u;\n     }\n     alt fk {\n-      visit::fk_ctor(nm, attrs, tps, self_id, parent_id) {\n+      visit::fk_ctor(nm, attrs, tps, self_id, parent_id) => {\n           let ct = @{node: {id: id,\n                             attrs: attrs,\n                             self_id: self_id,\n@@ -140,14 +140,14 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n                                       ct, parent_id,\n                                       @/* FIXME (#2543) */ copy cx.path));\n       }\n-      visit::fk_dtor(tps, attrs, self_id, parent_id) {\n+      visit::fk_dtor(tps, attrs, self_id, parent_id) => {\n           let dt = @{node: {id: id, attrs: attrs, self_id: self_id,\n                      body: /* FIXME (#2543) */ copy body}, span: sp};\n           cx.map.insert(id, node_dtor(/* FIXME (#2543) */ copy tps, dt,\n                                       parent_id,\n                                       @/* FIXME (#2543) */ copy cx.path));\n       }\n-      _ {}\n+      _ => ()\n     }\n     visit::visit_fn(fk, decl, body, sp, id, cx, v);\n }\n@@ -160,11 +160,11 @@ fn map_block(b: blk, cx: ctx, v: vt) {\n fn number_pat(cx: ctx, pat: @pat) {\n     do ast_util::walk_pat(pat) |p| {\n         alt p.node {\n-          pat_ident(*) {\n+          pat_ident(*) => {\n             cx.map.insert(p.id, node_local(cx.local_id));\n             cx.local_id += 1u;\n           }\n-          _ {}\n+          _ => ()\n         }\n     };\n }\n@@ -190,24 +190,24 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n     let item_path = @/* FIXME (#2543) */ copy cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n     alt i.node {\n-      item_impl(_, opt_ir, _, ms) {\n+      item_impl(_, opt_ir, _, ms) => {\n         let impl_did = ast_util::local_def(i.id);\n         for ms.each |m| {\n             map_method(impl_did, extend(cx, i.ident), m,\n                        cx);\n         }\n       }\n-      item_enum(vs, _) {\n+      item_enum(vs, _) => {\n         for vs.each |v| {\n             cx.map.insert(v.node.id, node_variant(\n                 /* FIXME (#2543) */ copy v, i,\n                 extend(cx, i.ident)));\n         }\n       }\n-      item_foreign_mod(nm) {\n+      item_foreign_mod(nm) => {\n         let abi = alt attr::foreign_abi(i.attrs) {\n-          either::left(msg) { cx.diag.span_fatal(i.span, msg); }\n-          either::right(abi) { abi }\n+          either::left(msg) => cx.diag.span_fatal(i.span, msg),\n+          either::right(abi) => abi\n         };\n         for nm.items.each |nitem| {\n             cx.map.insert(nitem.id,\n@@ -216,7 +216,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n                                            extend(cx, i.ident)));\n         }\n       }\n-      item_class(tps, traits, items, ctor, dtor) {\n+      item_class(tps, traits, items, ctor, dtor) => {\n           let (_, ms) = ast_util::split_class_items(items);\n           // Map trait refs to their parent classes. This is\n           // so we can find the self_ty\n@@ -231,7 +231,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n            // only need to handle methods\n           do vec::iter(ms) |m| { map_method(d_id, p, m, cx); }\n       }\n-      item_trait(tps, traits, methods) {\n+      item_trait(tps, traits, methods) => {\n         // Map trait refs to their parent classes. This is\n         // so we can find the self_ty\n         for traits.each |p| {\n@@ -246,34 +246,32 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n             cx.map.insert(id, node_trait_method(@tm, d_id, item_path));\n         }\n       }\n-      _ { }\n+      _ => ()\n     }\n     alt i.node {\n-      item_mod(_) | item_foreign_mod(_) {\n+      item_mod(_) | item_foreign_mod(_) => {\n         vec::push(cx.path, path_mod(i.ident));\n       }\n-      _ { vec::push(cx.path, path_name(i.ident)); }\n+      _ => vec::push(cx.path, path_name(i.ident))\n     }\n     visit::visit_item(i, cx, v);\n     vec::pop(cx.path);\n }\n \n fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n     alt vi.node {\n-      view_item_export(vps) {\n-        for vps.each |vp| {\n-            let (id, name) = alt vp.node {\n-              view_path_simple(nm, _, id) {\n-                (id, /* FIXME (#2543) */ copy nm)\n-              }\n-              view_path_glob(pth, id) | view_path_list(pth, _, id) {\n-                (id, path_to_ident(pth))\n-              }\n-            };\n-            cx.map.insert(id, node_export(vp, extend(cx, name)));\n-        }\n+      view_item_export(vps) => for vps.each |vp| {\n+        let (id, name) = alt vp.node {\n+          view_path_simple(nm, _, id) => {\n+            (id, /* FIXME (#2543) */ copy nm)\n+          }\n+          view_path_glob(pth, id) | view_path_list(pth, _, id) => {\n+            (id, path_to_ident(pth))\n+          }\n+        };\n+        cx.map.insert(id, node_export(vp, extend(cx, name)));\n       }\n-      _ {}\n+      _ => ()\n     }\n }\n \n@@ -284,51 +282,51 @@ fn map_expr(ex: @expr, cx: ctx, v: vt) {\n \n fn node_id_to_str(map: map, id: node_id) -> ~str {\n     alt map.find(id) {\n-      none {\n+      none => {\n         fmt!{\"unknown node (id=%d)\", id}\n       }\n-      some(node_item(item, path)) {\n+      some(node_item(item, path)) => {\n         fmt!{\"item %s (id=%?)\", path_ident_to_str(*path, item.ident), id}\n       }\n-      some(node_foreign_item(item, abi, path)) {\n+      some(node_foreign_item(item, abi, path)) => {\n         fmt!{\"foreign item %s with abi %? (id=%?)\",\n              path_ident_to_str(*path, item.ident), abi, id}\n       }\n-      some(node_method(m, impl_did, path)) {\n+      some(node_method(m, impl_did, path)) => {\n         fmt!{\"method %s in %s (id=%?)\",\n              *m.ident, path_to_str(*path), id}\n       }\n-      some(node_trait_method(tm, impl_did, path)) {\n+      some(node_trait_method(tm, impl_did, path)) => {\n         let m = ast_util::trait_method_to_ty_method(*tm);\n         fmt!{\"method %s in %s (id=%?)\",\n              *m.ident, path_to_str(*path), id}\n       }\n-      some(node_variant(variant, def_id, path)) {\n+      some(node_variant(variant, def_id, path)) => {\n         fmt!{\"variant %s in %s (id=%?)\",\n              *variant.node.name, path_to_str(*path), id}\n       }\n-      some(node_expr(expr)) {\n+      some(node_expr(expr)) => {\n         fmt!{\"expr %s (id=%?)\",\n              pprust::expr_to_str(expr), id}\n       }\n       // FIXMEs are as per #2410\n-      some(node_export(_, path)) {\n+      some(node_export(_, path)) => {\n         fmt!{\"export %s (id=%?)\", // add more info here\n              path_to_str(*path), id}\n       }\n-      some(node_arg(_, _)) { // add more info here\n+      some(node_arg(_, _)) => { // add more info here\n         fmt!{\"arg (id=%?)\", id}\n       }\n-      some(node_local(_)) { // add more info here\n+      some(node_local(_)) => { // add more info here\n         fmt!{\"local (id=%?)\", id}\n       }\n-      some(node_ctor(*)) { // add more info here\n+      some(node_ctor(*)) => { // add more info here\n         fmt!{\"node_ctor (id=%?)\", id}\n       }\n-      some(node_dtor(*)) { // add more info here\n+      some(node_dtor(*)) => { // add more info here\n         fmt!{\"node_dtor (id=%?)\", id}\n       }\n-      some(node_block(_)) {\n+      some(node_block(_)) => {\n         fmt!{\"block\"}\n       }\n     }"}, {"sha": "cf5168fc6daf42198560020c898ebca304f74c71", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 157, "deletions": 151, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -36,134 +36,149 @@ pure fn is_local(did: ast::def_id) -> bool { did.crate == local_crate }\n \n pure fn stmt_id(s: stmt) -> node_id {\n     alt s.node {\n-      stmt_decl(_, id) { id }\n-      stmt_expr(_, id) { id }\n-      stmt_semi(_, id) { id }\n+      stmt_decl(_, id) => id,\n+      stmt_expr(_, id) => id,\n+      stmt_semi(_, id) => id\n     }\n }\n \n fn variant_def_ids(d: def) -> {enm: def_id, var: def_id} {\n-    alt d { def_variant(enum_id, var_id) {\n-            return {enm: enum_id, var: var_id}; }\n-        _ { fail ~\"non-variant in variant_def_ids\"; } }\n+    alt d {\n+      def_variant(enum_id, var_id) => {\n+        return {enm: enum_id, var: var_id}\n+      }\n+      _ => fail ~\"non-variant in variant_def_ids\"\n+    }\n }\n \n pure fn def_id_of_def(d: def) -> def_id {\n     alt d {\n       def_fn(id, _) | def_mod(id) |\n       def_foreign_mod(id) | def_const(id) |\n       def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n-      def_use(id) | def_class(id, _) { id }\n+      def_use(id) | def_class(id, _) => {\n+        id\n+      }\n       def_arg(id, _) | def_local(id, _) | def_self(id) |\n       def_upvar(id, _, _) | def_binding(id, _) | def_region(id)\n-      | def_typaram_binder(id) {\n+      | def_typaram_binder(id) => {\n         local_def(id)\n       }\n \n-      def_prim_ty(_) { fail; }\n+      def_prim_ty(_) => fail\n     }\n }\n \n pure fn binop_to_str(op: binop) -> ~str {\n     alt op {\n-      add { return ~\"+\"; }\n-      subtract { return ~\"-\"; }\n-      mul { return ~\"*\"; }\n-      div { return ~\"/\"; }\n-      rem { return ~\"%\"; }\n-      and { return ~\"&&\"; }\n-      or { return ~\"||\"; }\n-      bitxor { return ~\"^\"; }\n-      bitand { return ~\"&\"; }\n-      bitor { return ~\"|\"; }\n-      shl { return ~\"<<\"; }\n-      shr { return ~\">>\"; }\n-      eq { return ~\"==\"; }\n-      lt { return ~\"<\"; }\n-      le { return ~\"<=\"; }\n-      ne { return ~\"!=\"; }\n-      ge { return ~\">=\"; }\n-      gt { return ~\">\"; }\n+      add => return ~\"+\",\n+      subtract => return ~\"-\",\n+      mul => return ~\"*\",\n+      div => return ~\"/\",\n+      rem => return ~\"%\",\n+      and => return ~\"&&\",\n+      or => return ~\"||\",\n+      bitxor => return ~\"^\",\n+      bitand => return ~\"&\",\n+      bitor => return ~\"|\",\n+      shl => return ~\"<<\",\n+      shr => return ~\">>\",\n+      eq => return ~\"==\",\n+      lt => return ~\"<\",\n+      le => return ~\"<=\",\n+      ne => return ~\"!=\",\n+      ge => return ~\">=\",\n+      gt => return ~\">\"\n     }\n }\n \n pure fn binop_to_method_name(op: binop) -> option<~str> {\n     alt op {\n-      add { return some(~\"add\"); }\n-      subtract { return some(~\"sub\"); }\n-      mul { return some(~\"mul\"); }\n-      div { return some(~\"div\"); }\n-      rem { return some(~\"modulo\"); }\n-      bitxor { return some(~\"bitxor\"); }\n-      bitand { return some(~\"bitand\"); }\n-      bitor { return some(~\"bitor\"); }\n-      shl { return some(~\"shl\"); }\n-      shr { return some(~\"shr\"); }\n-      and | or | eq | lt | le | ne | ge | gt { return none; }\n+      add => return some(~\"add\"),\n+      subtract => return some(~\"sub\"),\n+      mul => return some(~\"mul\"),\n+      div => return some(~\"div\"),\n+      rem => return some(~\"modulo\"),\n+      bitxor => return some(~\"bitxor\"),\n+      bitand => return some(~\"bitand\"),\n+      bitor => return some(~\"bitor\"),\n+      shl => return some(~\"shl\"),\n+      shr => return some(~\"shr\"),\n+      and | or | eq | lt | le | ne | ge | gt => return none\n     }\n }\n \n pure fn lazy_binop(b: binop) -> bool {\n-    alt b { and { true } or { true } _ { false } }\n+    alt b {\n+      and => true,\n+      or => true,\n+      _ => false\n+    }\n }\n \n pure fn is_shift_binop(b: binop) -> bool {\n     alt b {\n-      shl { true }\n-      shr { true }\n-      _ { false }\n+      shl => true,\n+      shr => true,\n+      _ => false\n     }\n }\n \n pure fn unop_to_str(op: unop) -> ~str {\n     alt op {\n-      box(mt) { if mt == m_mutbl { ~\"@mut \" } else { ~\"@\" } }\n-      uniq(mt) { if mt == m_mutbl { ~\"~mut \" } else { ~\"~\" } }\n-      deref { ~\"*\" }\n-      not { ~\"!\" }\n-      neg { ~\"-\" }\n+      box(mt) => if mt == m_mutbl { ~\"@mut \" } else { ~\"@\" },\n+      uniq(mt) => if mt == m_mutbl { ~\"~mut \" } else { ~\"~\" },\n+      deref => ~\"*\",\n+      not => ~\"!\",\n+      neg => ~\"-\"\n     }\n }\n \n pure fn is_path(e: @expr) -> bool {\n-    return alt e.node { expr_path(_) { true } _ { false } };\n+    return alt e.node { expr_path(_) => true, _ => false };\n }\n \n pure fn int_ty_to_str(t: int_ty) -> ~str {\n     alt t {\n-      ty_char { ~\"u8\" } // ???\n-      ty_i { ~\"\" } ty_i8 { ~\"i8\" } ty_i16 { ~\"i16\" }\n-      ty_i32 { ~\"i32\" } ty_i64 { ~\"i64\" }\n+      ty_char => ~\"u8\", // ???\n+      ty_i => ~\"\",\n+      ty_i8 => ~\"i8\",\n+      ty_i16 => ~\"i16\",\n+      ty_i32 => ~\"i32\",\n+      ty_i64 => ~\"i64\"\n     }\n }\n \n pure fn int_ty_max(t: int_ty) -> u64 {\n     alt t {\n-      ty_i8 { 0x80u64 }\n-      ty_i16 { 0x8000u64 }\n-      ty_i | ty_char | ty_i32 { 0x80000000u64 } // actually ni about ty_i\n-      ty_i64 { 0x8000000000000000u64 }\n+      ty_i8 => 0x80u64,\n+      ty_i16 => 0x8000u64,\n+      ty_i | ty_char | ty_i32 => 0x80000000u64, // actually ni about ty_i\n+      ty_i64 => 0x8000000000000000u64\n     }\n }\n \n pure fn uint_ty_to_str(t: uint_ty) -> ~str {\n     alt t {\n-      ty_u { ~\"u\" } ty_u8 { ~\"u8\" } ty_u16 { ~\"u16\" }\n-      ty_u32 { ~\"u32\" } ty_u64 { ~\"u64\" }\n+      ty_u => ~\"u\",\n+      ty_u8 => ~\"u8\",\n+      ty_u16 => ~\"u16\",\n+      ty_u32 => ~\"u32\",\n+      ty_u64 => ~\"u64\"\n     }\n }\n \n pure fn uint_ty_max(t: uint_ty) -> u64 {\n     alt t {\n-      ty_u8 { 0xffu64 }\n-      ty_u16 { 0xffffu64 }\n-      ty_u | ty_u32 { 0xffffffffu64 } // actually ni about ty_u\n-      ty_u64 { 0xffffffffffffffffu64 }\n+      ty_u8 => 0xffu64,\n+      ty_u16 => 0xffffu64,\n+      ty_u | ty_u32 => 0xffffffffu64, // actually ni about ty_u\n+      ty_u64 => 0xffffffffffffffffu64\n     }\n }\n \n pure fn float_ty_to_str(t: float_ty) -> ~str {\n-    alt t { ty_f { ~\"f\" } ty_f32 { ~\"f32\" } ty_f64 { ~\"f64\" } }\n+    alt t { ty_f => ~\"f\", ty_f32 => ~\"f32\", ty_f64 => ~\"f64\" }\n }\n \n fn is_exported(i: ident, m: _mod) -> bool {\n@@ -172,36 +187,34 @@ fn is_exported(i: ident, m: _mod) -> bool {\n     for m.items.each |it| {\n         if it.ident == i { local = true; }\n         alt it.node {\n-          item_enum(variants, _) {\n-            for variants.each |v| {\n-                if v.node.name == i {\n-                   local = true;\n-                   parent_enum = some(/* FIXME (#2543) */ copy it.ident);\n-                }\n+          item_enum(variants, _) => for variants.each |v| {\n+            if v.node.name == i {\n+                local = true;\n+                parent_enum = some(/* FIXME (#2543) */ copy it.ident);\n             }\n           }\n-          _ { }\n+          _ => ()\n         }\n         if local { break; }\n     }\n     let mut has_explicit_exports = false;\n     for m.view_items.each |vi| {\n         alt vi.node {\n-          view_item_export(vps) {\n+          view_item_export(vps) => {\n             has_explicit_exports = true;\n             for vps.each |vp| {\n                 alt vp.node {\n-                  ast::view_path_simple(id, _, _) {\n+                  ast::view_path_simple(id, _, _) => {\n                     if id == i { return true; }\n                     alt parent_enum {\n-                      some(parent_enum_id) {\n+                      some(parent_enum_id) => {\n                         if id == parent_enum_id { return true; }\n                       }\n-                      _ {}\n+                      _ => ()\n                     }\n                   }\n \n-                  ast::view_path_list(path, ids, _) {\n+                  ast::view_path_list(path, ids, _) => {\n                     if vec::len(path.idents) == 1u {\n                         if i == path.idents[0] { return true; }\n                         for ids.each |id| {\n@@ -213,11 +226,11 @@ fn is_exported(i: ident, m: _mod) -> bool {\n                   }\n \n                   // FIXME: glob-exports aren't supported yet. (#2006)\n-                  _ {}\n+                  _ => ()\n                 }\n             }\n           }\n-          _ {}\n+          _ => ()\n         }\n     }\n     // If there are no declared exports then\n@@ -227,7 +240,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n }\n \n pure fn is_call_expr(e: @expr) -> bool {\n-    alt e.node { expr_call(_, _, _) { true } _ { false } }\n+    alt e.node { expr_call(_, _, _) => true, _ => false }\n }\n \n pure fn eq_ty(a: &@ty, b: &@ty) -> bool { box::ptr_eq(*a, *b) }\n@@ -272,8 +285,8 @@ fn ident_to_path(s: span, +i: ident) -> @path {\n \n pure fn is_unguarded(&&a: arm) -> bool {\n     alt a.guard {\n-      none { true }\n-      _    { false }\n+      none => true,\n+      _    => false\n     }\n }\n \n@@ -283,8 +296,8 @@ pure fn unguarded_pat(a: arm) -> option<~[@pat]> {\n \n pure fn class_item_ident(ci: @class_member) -> ident {\n     alt ci.node {\n-      instance_var(i,_,_,_,_) { /* FIXME (#2543) */ copy i }\n-      class_method(it) { /* FIXME (#2543) */ copy it.ident }\n+      instance_var(i,_,_,_,_) => /* FIXME (#2543) */ copy i,\n+      class_method(it) => /* FIXME (#2543) */ copy it.ident\n     }\n }\n \n@@ -294,23 +307,23 @@ type ivar = {ident: ident, ty: @ty, cm: class_mutability,\n fn public_methods(ms: ~[@method]) -> ~[@method] {\n     vec::filter(ms,\n                 |m| alt m.vis {\n-                    public { true }\n-                    _   { false }\n+                    public => true,\n+                    _   => false\n                 })\n }\n \n fn split_class_items(cs: ~[@class_member]) -> (~[ivar], ~[@method]) {\n     let mut vs = ~[], ms = ~[];\n     for cs.each |c| {\n       alt c.node {\n-        instance_var(i, t, cm, id, vis) {\n+        instance_var(i, t, cm, id, vis) => {\n           vec::push(vs, {ident: /* FIXME (#2543) */ copy i,\n                          ty: t,\n                          cm: cm,\n                          id: id,\n                          vis: vis});\n         }\n-        class_method(m) { vec::push(ms, m); }\n+        class_method(m) => vec::push(ms, m)\n       }\n     };\n     (vs, ms)\n@@ -320,8 +333,8 @@ fn split_class_items(cs: ~[@class_member]) -> (~[ivar], ~[@method]) {\n // a default, pull out the useful fields to make a ty_method\n fn trait_method_to_ty_method(method: trait_method) -> ty_method {\n     alt method {\n-      required(m) { m }\n-      provided(m) {\n+      required(m) => m,\n+      provided(m) => {\n         {ident: m.ident, attrs: m.attrs,\n          decl: m.decl, tps: m.tps, self_ty: m.self_ty,\n          id: m.id, span: m.span}\n@@ -334,17 +347,17 @@ fn split_trait_methods(trait_methods: ~[trait_method])\n     let mut reqd = ~[], provd = ~[];\n     for trait_methods.each |trt_method| {\n         alt trt_method {\n-          required(tm) { vec::push(reqd, tm); }\n-          provided(m) { vec::push(provd, m); }\n+          required(tm) => vec::push(reqd, tm),\n+          provided(m) => vec::push(provd, m)\n         }\n     };\n     (reqd, provd)\n }\n \n pure fn class_member_visibility(ci: @class_member) -> visibility {\n   alt ci.node {\n-     instance_var(_, _, _, _, vis) { vis }\n-     class_method(m) { m.vis }\n+     instance_var(_, _, _, _, vis) => vis,\n+     class_method(m) => m.vis\n   }\n }\n \n@@ -357,33 +370,33 @@ trait inlined_item_utils {\n impl inlined_item_methods of inlined_item_utils for inlined_item {\n     fn ident() -> ident {\n         alt self {\n-          ii_item(i) { /* FIXME (#2543) */ copy i.ident }\n-          ii_foreign(i) { /* FIXME (#2543) */ copy i.ident }\n-          ii_method(_, m) { /* FIXME (#2543) */ copy m.ident }\n-          ii_ctor(_, nm, _, _) { /* FIXME (#2543) */ copy nm }\n-          ii_dtor(_, nm, _, _) { /* FIXME (#2543) */ copy nm }\n+          ii_item(i) => /* FIXME (#2543) */ copy i.ident,\n+          ii_foreign(i) => /* FIXME (#2543) */ copy i.ident,\n+          ii_method(_, m) => /* FIXME (#2543) */ copy m.ident,\n+          ii_ctor(_, nm, _, _) => /* FIXME (#2543) */ copy nm,\n+          ii_dtor(_, nm, _, _) => /* FIXME (#2543) */ copy nm\n         }\n     }\n \n     fn id() -> ast::node_id {\n         alt self {\n-          ii_item(i) { i.id }\n-          ii_foreign(i) { i.id }\n-          ii_method(_, m) { m.id }\n-          ii_ctor(ctor, _, _, _) { ctor.node.id }\n-          ii_dtor(dtor, _, _, _) { dtor.node.id }\n+          ii_item(i) => i.id,\n+          ii_foreign(i) => i.id,\n+          ii_method(_, m) => m.id,\n+          ii_ctor(ctor, _, _, _) => ctor.node.id,\n+          ii_dtor(dtor, _, _, _) => dtor.node.id\n         }\n     }\n \n     fn accept<E>(e: E, v: visit::vt<E>) {\n         alt self {\n-          ii_item(i) { v.visit_item(i, e, v) }\n-          ii_foreign(i) { v.visit_foreign_item(i, e, v) }\n-          ii_method(_, m) { visit::visit_method_helper(m, e, v) }\n-          ii_ctor(ctor, nm, tps, parent_id) {\n+          ii_item(i) => v.visit_item(i, e, v),\n+          ii_foreign(i) => v.visit_foreign_item(i, e, v),\n+          ii_method(_, m) => visit::visit_method_helper(m, e, v),\n+          ii_ctor(ctor, nm, tps, parent_id) => {\n               visit::visit_class_ctor_helper(ctor, nm, tps, parent_id, e, v);\n           }\n-          ii_dtor(dtor, nm, tps, parent_id) {\n+          ii_dtor(dtor, nm, tps, parent_id) => {\n               visit::visit_class_dtor_helper(dtor, tps, parent_id, e, v);\n           }\n         }\n@@ -394,26 +407,26 @@ impl inlined_item_methods of inlined_item_utils for inlined_item {\n  referring to a def_self */\n fn is_self(d: ast::def) -> bool {\n   alt d {\n-    def_self(_)        { true }\n-    def_upvar(_, d, _) { is_self(*d) }\n-    _                  { false }\n+    def_self(_)        => true,\n+    def_upvar(_, d, _) => is_self(*d),\n+    _                  => false\n   }\n }\n \n /// Maps a binary operator to its precedence\n fn operator_prec(op: ast::binop) -> uint {\n   alt op {\n-      mul | div | rem   { 12u }\n+      mul | div | rem   => 12u,\n       // 'as' sits between here with 11\n-      add | subtract    { 10u }\n-      shl | shr         {  9u }\n-      bitand            {  8u }\n-      bitxor            {  7u }\n-      bitor             {  6u }\n-      lt | le | ge | gt {  4u }\n-      eq | ne           {  3u }\n-      and               {  2u }\n-      or                {  1u }\n+      add | subtract    => 10u,\n+      shl | shr         =>  9u,\n+      bitand            =>  8u,\n+      bitxor            =>  7u,\n+      bitor             =>  6u,\n+      lt | le | ge | gt =>  4u,\n+      eq | ne           =>  3u,\n+      and               =>  2u,\n+      or                =>  1u\n   }\n }\n \n@@ -443,13 +456,13 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n \n         visit_view_item: fn@(vi: @view_item) {\n             alt vi.node {\n-              view_item_use(_, _, id) { vfn(id) }\n-              view_item_import(vps) | view_item_export(vps) {\n+              view_item_use(_, _, id) => vfn(id),\n+              view_item_import(vps) | view_item_export(vps) => {\n                 do vec::iter(vps) |vp| {\n                     alt vp.node {\n-                      view_path_simple(_, _, id) { vfn(id) }\n-                      view_path_glob(_, id) { vfn(id) }\n-                      view_path_list(_, _, id) { vfn(id) }\n+                      view_path_simple(_, _, id) => vfn(id),\n+                      view_path_glob(_, id) => vfn(id),\n+                      view_path_list(_, _, id) => vfn(id)\n                     }\n                 }\n               }\n@@ -463,8 +476,8 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         visit_item: fn@(i: @item) {\n             vfn(i.id);\n             alt i.node {\n-              item_enum(vs, _) { for vs.each |v| { vfn(v.node.id); } }\n-              _ {}\n+              item_enum(vs, _) => for vs.each |v| { vfn(v.node.id); }\n+              _ => ()\n             }\n         },\n \n@@ -499,10 +512,8 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n \n         visit_ty: fn@(t: @ty) {\n             alt t.node {\n-              ty_path(_, id) {\n-                vfn(id)\n-              }\n-              _ { /* fall through */ }\n+              ty_path(_, id) => vfn(id),\n+              _ => { /* fall through */ }\n             }\n         },\n \n@@ -515,27 +526,27 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             vfn(id);\n \n             alt fk {\n-              visit::fk_ctor(nm, _, tps, self_id, parent_id) {\n+              visit::fk_ctor(nm, _, tps, self_id, parent_id) => {\n                 vec::iter(tps, |tp| vfn(tp.id));\n                 vfn(id);\n                 vfn(self_id);\n                 vfn(parent_id.node);\n               }\n-              visit::fk_dtor(tps, _, self_id, parent_id) {\n+              visit::fk_dtor(tps, _, self_id, parent_id) => {\n                 vec::iter(tps, |tp| vfn(tp.id));\n                 vfn(id);\n                 vfn(self_id);\n                 vfn(parent_id.node);\n               }\n-              visit::fk_item_fn(_, tps) {\n+              visit::fk_item_fn(_, tps) => {\n                 vec::iter(tps, |tp| vfn(tp.id));\n               }\n-              visit::fk_method(_, tps, m) {\n+              visit::fk_method(_, tps, m) => {\n                 vfn(m.self_id);\n                 vec::iter(tps, |tp| vfn(tp.id));\n               }\n               visit::fk_anon(_, capture_clause)\n-              | visit::fk_fn_block(capture_clause) {\n+              | visit::fk_fn_block(capture_clause) => {\n                 for vec::each(*capture_clause) |clause| {\n                     vfn(clause.id);\n                 }\n@@ -555,11 +566,8 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n \n         visit_class_item: fn@(c: @class_member) {\n             alt c.node {\n-              instance_var(_, _, _, id,_) {\n-                vfn(id)\n-              }\n-              class_method(_) {\n-              }\n+              instance_var(_, _, _, id,_) => vfn(id),\n+              class_method(_) => ()\n             }\n         }\n     })\n@@ -585,31 +593,29 @@ fn compute_id_range_for_inlined_item(item: inlined_item) -> id_range {\n \n pure fn is_item_impl(item: @ast::item) -> bool {\n     alt item.node {\n-       item_impl(*) { true }\n-       _            { false }\n+       item_impl(*) => true,\n+       _            => false\n     }\n }\n \n fn walk_pat(pat: @pat, it: fn(@pat)) {\n     it(pat);\n     alt pat.node {\n-      pat_ident(_, pth, some(p)) { walk_pat(p, it); }\n-      pat_rec(fields, _) {\n-        for fields.each |f| { walk_pat(f.pat, it); }\n-      }\n-      pat_enum(_, some(s)) | pat_tup(s) {\n-        for s.each |p| { walk_pat(p, it); }\n+      pat_ident(_, pth, some(p)) => walk_pat(p, it),\n+      pat_rec(fields, _) => for fields.each |f| { walk_pat(f.pat, it) }\n+      pat_enum(_, some(s)) | pat_tup(s) => for s.each |p| {\n+        walk_pat(p, it)\n       }\n-      pat_box(s) | pat_uniq(s) { walk_pat(s, it); }\n+      pat_box(s) | pat_uniq(s) => walk_pat(s, it),\n       pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _, _)\n-        | pat_enum(_, _) {}\n+        | pat_enum(_, _) => ()\n     }\n }\n \n fn view_path_id(p: @view_path) -> node_id {\n     alt p.node {\n       view_path_simple(_, _, id) | view_path_glob(_, id) |\n-      view_path_list(_, _, id) { id }\n+      view_path_list(_, _, id) => id\n     }\n }\n "}, {"sha": "f04a8e42ab7329e4dd4e0e3866621fbf4d4b910e", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 38, "deletions": 49, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -115,9 +115,9 @@ fn get_attr_name(attr: ast::attribute) -> ast::ident {\n // All \"bad\" FIXME copies are as per #2543\n fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n     alt meta.node {\n-      ast::meta_word(n) { /* FIXME (#2543) */ copy n }\n-      ast::meta_name_value(n, _) { /* FIXME (#2543) */ copy n }\n-      ast::meta_list(n, _) { /* FIXME (#2543) */ copy n }\n+      ast::meta_word(n) => /* FIXME (#2543) */ copy n,\n+      ast::meta_name_value(n, _) => /* FIXME (#2543) */ copy n,\n+      ast::meta_list(n, _) => /* FIXME (#2543) */ copy n\n     }\n }\n \n@@ -127,25 +127,19 @@ fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n  */\n fn get_meta_item_value_str(meta: @ast::meta_item) -> option<@~str> {\n     alt meta.node {\n-      ast::meta_name_value(_, v) {\n-        alt v.node {\n-            ast::lit_str(s) {\n-                option::some(s)\n-            }\n-            _ {\n-                option::none\n-            }\n-        }\n+      ast::meta_name_value(_, v) => alt v.node {\n+        ast::lit_str(s) => option::some(s),\n+        _ => option::none\n       }\n-      _ { option::none }\n+      _ => option::none\n     }\n }\n \n /// Gets a list of inner meta items from a list meta_item type\n fn get_meta_item_list(meta: @ast::meta_item) -> option<~[@ast::meta_item]> {\n     alt meta.node {\n-      ast::meta_list(_, l) { option::some(/* FIXME (#2543) */ copy l) }\n-      _ { option::none }\n+      ast::meta_list(_, l) => option::some(/* FIXME (#2543) */ copy l),\n+      _ => option::none\n     }\n }\n \n@@ -157,11 +151,11 @@ fn get_name_value_str_pair(\n     item: @ast::meta_item\n ) -> option<(ast::ident, @~str)> {\n     alt attr::get_meta_item_value_str(item) {\n-      some(value) {\n+      some(value) => {\n         let name = attr::get_meta_item_name(item);\n         some((name, value))\n       }\n-      none { none }\n+      none => none\n     }\n }\n \n@@ -210,16 +204,15 @@ fn contains(haystack: ~[@ast::meta_item], needle: @ast::meta_item) -> bool {\n \n fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n     return alt a.node {\n-          ast::meta_word(na) {\n-            alt b.node { ast::meta_word(nb) { na == nb } _ { false } }\n+          ast::meta_word(na) => alt b.node {\n+            ast::meta_word(nb) => na == nb,\n+            _ => false\n           }\n-          ast::meta_name_value(na, va) {\n-            alt b.node {\n-              ast::meta_name_value(nb, vb) { na == nb && va.node == vb.node }\n-              _ { false }\n-            }\n+          ast::meta_name_value(na, va) => alt b.node {\n+            ast::meta_name_value(nb, vb) => na == nb && va.node == vb.node,\n+            _ => false\n           }\n-          ast::meta_list(na, la) {\n+          ast::meta_list(na, la) => {\n \n             // ~[Fixme-sorting]\n             // FIXME (#607): Needs implementing\n@@ -261,13 +254,11 @@ fn last_meta_item_value_str_by_name(\n     +name: ~str\n ) -> option<@~str> {\n     alt last_meta_item_by_name(items, name) {\n-      some(item) {\n-        alt attr::get_meta_item_value_str(item) {\n-          some(value) { some(value) }\n-          none { none }\n-        }\n+      some(item) => alt attr::get_meta_item_value_str(item) {\n+        some(value) => some(value),\n+        none => none\n       }\n-      none { none }\n+      none => none\n     }\n }\n \n@@ -276,10 +267,8 @@ fn last_meta_item_list_by_name(\n     +name: ~str\n ) -> option<~[@ast::meta_item]> {\n     alt last_meta_item_by_name(items, name) {\n-      some(item) {\n-        attr::get_meta_item_list(item)\n-      }\n-      none { none }\n+      some(item) => attr::get_meta_item_list(item),\n+      none => none\n     }\n }\n \n@@ -292,9 +281,9 @@ fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n     pure fn lteq(ma: &@ast::meta_item, mb: &@ast::meta_item) -> bool {\n         pure fn key(m: &ast::meta_item) -> ast::ident {\n             alt m.node {\n-              ast::meta_word(name) { /* FIXME (#2543) */ copy name }\n-              ast::meta_name_value(name, _) { /* FIXME (#2543) */ copy name }\n-              ast::meta_list(name, _) { /* FIXME (#2543) */ copy name }\n+              ast::meta_word(name) => /* FIXME (#2543) */ copy name,\n+              ast::meta_name_value(name, _) => /* FIXME (#2543) */ copy name,\n+              ast::meta_list(name, _) => /* FIXME (#2543) */ copy name\n             }\n         }\n         key(*ma) <= key(*mb)\n@@ -322,8 +311,8 @@ fn find_linkage_attrs(attrs: ~[ast::attribute]) -> ~[ast::attribute] {\n     let mut found = ~[];\n     for find_attrs_by_name(attrs, ~\"link\").each |attr| {\n         alt attr.node.value.node {\n-          ast::meta_list(_, _) { vec::push(found, attr) }\n-          _ { debug!{\"ignoring link attribute that has incorrect type\"}; }\n+          ast::meta_list(_, _) => vec::push(found, attr),\n+          _ => debug!{\"ignoring link attribute that has incorrect type\"}\n         }\n     }\n     return found;\n@@ -336,26 +325,26 @@ fn find_linkage_attrs(attrs: ~[ast::attribute]) -> ~[ast::attribute] {\n fn find_linkage_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n     do find_linkage_attrs(attrs).flat_map |attr| {\n         alt check attr.node.value.node {\n-          ast::meta_list(_, items) { /* FIXME (#2543) */ copy items }\n+          ast::meta_list(_, items) => /* FIXME (#2543) */ copy items\n         }\n     }\n }\n \n fn foreign_abi(attrs: ~[ast::attribute]) -> either<~str, ast::foreign_abi> {\n     return alt attr::first_attr_value_str_by_name(attrs, ~\"abi\") {\n-      option::none {\n+      option::none => {\n         either::right(ast::foreign_abi_cdecl)\n       }\n-      option::some(@~\"rust-intrinsic\") {\n+      option::some(@~\"rust-intrinsic\") => {\n         either::right(ast::foreign_abi_rust_intrinsic)\n       }\n-      option::some(@~\"cdecl\") {\n+      option::some(@~\"cdecl\") => {\n         either::right(ast::foreign_abi_cdecl)\n       }\n-      option::some(@~\"stdcall\") {\n+      option::some(@~\"stdcall\") => {\n         either::right(ast::foreign_abi_stdcall)\n       }\n-      option::some(t) {\n+      option::some(t) => {\n         either::left(~\"unsupported abi: \" + *t)\n       }\n     };\n@@ -373,8 +362,8 @@ fn find_inline_attr(attrs: ~[ast::attribute]) -> inline_attr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline(always)]\n     do vec::foldl(ia_none, attrs) |ia,attr| {\n         alt attr.node.value.node {\n-          ast::meta_word(@~\"inline\") { ia_hint }\n-          ast::meta_list(@~\"inline\", items) {\n+          ast::meta_word(@~\"inline\") => ia_hint,\n+          ast::meta_list(@~\"inline\", items) => {\n             if !vec::is_empty(find_meta_items_by_name(items, ~\"always\")) {\n                 ia_always\n             } else if !vec::is_empty(\n@@ -384,7 +373,7 @@ fn find_inline_attr(attrs: ~[ast::attribute]) -> inline_attr {\n                 ia_hint\n             }\n           }\n-          _ { ia }\n+          _ => ia\n         }\n     }\n }"}, {"sha": "575edaa771cbef6ec57ecfcd207786295fca6087", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -125,16 +125,16 @@ fn lookup_char_pos_adj(map: codemap, pos: uint)\n {\n     let loc = lookup_char_pos(map, pos);\n     alt (loc.file.substr) {\n-      fss_none {\n+      fss_none => {\n         {filename: /* FIXME (#2543) */ copy loc.file.name,\n          line: loc.line,\n          col: loc.col,\n          file: some(loc.file)}\n       }\n-      fss_internal(sp) {\n+      fss_internal(sp) => {\n         lookup_char_pos_adj(map, sp.lo + (pos - loc.file.start_pos.ch))\n       }\n-      fss_external(eloc) {\n+      fss_external(eloc) => {\n         {filename: /* FIXME (#2543) */ copy eloc.filename,\n          line: eloc.line + loc.line - 1u,\n          col: if loc.line == 1u {eloc.col + loc.col} else {loc.col},\n@@ -147,12 +147,12 @@ fn adjust_span(map: codemap, sp: span) -> span {\n     pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n     let line = lookup_line(map, sp.lo, lookup);\n     alt (line.fm.substr) {\n-      fss_none {sp}\n-      fss_internal(s) {\n+      fss_none => sp,\n+      fss_internal(s) => {\n         adjust_span(map, {lo: s.lo + (sp.lo - line.fm.start_pos.ch),\n                           hi: s.lo + (sp.hi - line.fm.start_pos.ch),\n                           expn_info: sp.expn_info})}\n-      fss_external(_) {sp}\n+      fss_external(_) => sp\n     }\n }\n \n@@ -197,8 +197,8 @@ fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n fn get_line(fm: filemap, line: int) -> ~str unsafe {\n     let begin: uint = fm.lines[line].byte - fm.start_pos.byte;\n     let end = alt str::find_char_from(*fm.src, '\\n', begin) {\n-      some(e) { e }\n-      none { str::len(*fm.src) }\n+      some(e) => e,\n+      none => str::len(*fm.src)\n     };\n     str::slice(*fm.src, begin, end)\n }"}, {"sha": "6195849f3404fa3325256f58b182ac64fa523b04", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -88,10 +88,12 @@ impl codemap_handler of handler for handler_t {\n     fn abort_if_errors() {\n         let s;\n         alt self.err_count {\n-          0u { return; }\n-          1u { s = ~\"aborting due to previous error\"; }\n-          _  { s = fmt!{\"aborting due to %u previous errors\",\n-                        self.err_count}; }\n+          0u => return,\n+          1u => s = ~\"aborting due to previous error\",\n+          _  => {\n+            s = fmt!{\"aborting due to %u previous errors\",\n+                     self.err_count};\n+          }\n         }\n         self.fatal(s);\n     }\n@@ -121,8 +123,8 @@ fn mk_span_handler(handler: handler, cm: codemap::codemap) -> span_handler {\n fn mk_handler(emitter: option<emitter>) -> handler {\n \n     let emit = alt emitter {\n-      some(e) { e }\n-      none {\n+      some(e) => e,\n+      none => {\n         let f = fn@(cmsp: option<(codemap::codemap, span)>,\n             msg: ~str, t: level) {\n             emit(cmsp, msg, t);\n@@ -146,19 +148,19 @@ enum level {\n \n fn diagnosticstr(lvl: level) -> ~str {\n     alt lvl {\n-      fatal { ~\"error\" }\n-      error { ~\"error\" }\n-      warning { ~\"warning\" }\n-      note { ~\"note\" }\n+      fatal => ~\"error\",\n+      error => ~\"error\",\n+      warning => ~\"warning\",\n+      note => ~\"note\"\n     }\n }\n \n fn diagnosticcolor(lvl: level) -> u8 {\n     alt lvl {\n-      fatal { term::color_bright_red }\n-      error { term::color_bright_red }\n-      warning { term::color_bright_yellow }\n-      note { term::color_bright_green }\n+      fatal => term::color_bright_red,\n+      error => term::color_bright_red,\n+      warning => term::color_bright_yellow,\n+      note => term::color_bright_green\n     }\n }\n \n@@ -181,15 +183,15 @@ fn print_diagnostic(topic: ~str, lvl: level, msg: ~str) {\n fn emit(cmsp: option<(codemap::codemap, span)>,\n         msg: ~str, lvl: level) {\n     alt cmsp {\n-      some((cm, sp)) {\n+      some((cm, sp)) => {\n         let sp = codemap::adjust_span(cm,sp);\n         let ss = codemap::span_to_str(sp, cm);\n         let lines = codemap::span_to_lines(sp, cm);\n         print_diagnostic(ss, lvl, msg);\n         highlight_lines(cm, sp, lines);\n         print_macro_backtrace(cm, sp);\n       }\n-      none {\n+      none => {\n         print_diagnostic(~\"\", lvl, msg);\n       }\n     }\n@@ -265,7 +267,7 @@ fn print_macro_backtrace(cm: codemap::codemap, sp: span) {\n fn expect<T: copy>(diag: span_handler,\n                    opt: option<T>, msg: fn() -> ~str) -> T {\n     alt opt {\n-       some(t) { t }\n-       none { diag.handler().bug(msg()); }\n+       some(t) => t,\n+       none => diag.handler().bug(msg())\n     }\n }"}, {"sha": "6e9673f4bc202ca45ae5506682a251dfa4273eaf", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -102,18 +102,18 @@ fn expand(cx: ext_ctxt,\n \n     do vec::flat_map(in_items) |in_item| {\n         alt in_item.node {\n-          ast::item_ty(ty, tps) {\n+          ast::item_ty(ty, tps) => {\n             vec::append(~[filter_attrs(in_item)],\n                         ty_fns(cx, in_item.ident, ty, tps))\n           }\n \n-          ast::item_enum(variants, tps) {\n+          ast::item_enum(variants, tps) => {\n             vec::append(~[filter_attrs(in_item)],\n                         enum_fns(cx, in_item.ident,\n                                  in_item.span, variants, tps))\n           }\n \n-          _ {\n+          _ => {\n             cx.span_err(span, ~\"#[auto_serialize] can only be \\\n                                applied to type and enum \\\n                                definitions\");\n@@ -376,12 +376,12 @@ fn ser_lambda(cx: ext_ctxt, tps: ser_tps_map, ty: @ast::ty,\n \n fn is_vec_or_str(ty: @ast::ty) -> bool {\n     alt ty.node {\n-      ast::ty_vec(_) { true }\n+      ast::ty_vec(_) => true,\n       // This may be wrong if the user has shadowed (!) str\n       ast::ty_path(@{span: _, global: _, idents: ids,\n                              rp: none, types: _}, _)\n-      if ids == ~[@~\"str\"] { true }\n-      _ { false }\n+      if ids == ~[@~\"str\"] => true,\n+      _ => false\n     }\n }\n \n@@ -392,37 +392,37 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n     let ext_cx = cx; // required for #ast{}\n \n     alt ty.node {\n-      ast::ty_nil {\n+      ast::ty_nil => {\n         ~[#ast[stmt]{$(s).emit_nil()}]\n       }\n \n-      ast::ty_bot {\n+      ast::ty_bot => {\n         cx.span_err(\n             ty.span, fmt!{\"Cannot serialize bottom type\"});\n         ~[]\n       }\n \n-      ast::ty_box(mt) {\n+      ast::ty_box(mt) => {\n         let l = ser_lambda(cx, tps, mt.ty, cx.clone(s), #ast{ *$(v) });\n         ~[#ast[stmt]{$(s).emit_box($(l));}]\n       }\n \n       // For unique evecs/estrs, just pass through to underlying vec or str\n-      ast::ty_uniq(mt) if is_vec_or_str(mt.ty) {\n+      ast::ty_uniq(mt) if is_vec_or_str(mt.ty) => {\n         ser_ty(cx, tps, mt.ty, s, v)\n       }\n \n-      ast::ty_uniq(mt) {\n+      ast::ty_uniq(mt) => {\n         let l = ser_lambda(cx, tps, mt.ty, cx.clone(s), #ast{ *$(v) });\n         ~[#ast[stmt]{$(s).emit_uniq($(l));}]\n       }\n \n-      ast::ty_ptr(_) | ast::ty_rptr(_, _) {\n+      ast::ty_ptr(_) | ast::ty_rptr(_, _) => {\n         cx.span_err(ty.span, ~\"cannot serialize pointer types\");\n         ~[]\n       }\n \n-      ast::ty_rec(flds) {\n+      ast::ty_rec(flds) => {\n         let fld_stmts = do vec::from_fn(vec::len(flds)) |fidx| {\n             let fld = flds[fidx];\n             let vf = cx.expr(fld.span,\n@@ -439,12 +439,12 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n         ~[#ast[stmt]{$(s).emit_rec($(fld_lambda));}]\n       }\n \n-      ast::ty_fn(_, _) {\n+      ast::ty_fn(_, _) => {\n         cx.span_err(ty.span, ~\"cannot serialize function types\");\n         ~[]\n       }\n \n-      ast::ty_tup(tys) {\n+      ast::ty_tup(tys) => {\n         // Generate code like\n         //\n         // alt v {\n@@ -478,31 +478,31 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n         ~[cx.alt_stmt(arms, ty.span, v)]\n       }\n \n-      ast::ty_path(path, _) {\n+      ast::ty_path(path, _) => {\n         if vec::len(path.idents) == 1u &&\n             vec::is_empty(path.types) {\n             let ident = path.idents[0];\n \n             alt tps.find(*ident) {\n-              some(f) { f(v) }\n-              none { ser_path(cx, tps, path, s, v) }\n+              some(f) => f(v),\n+              none => ser_path(cx, tps, path, s, v)\n             }\n         } else {\n             ser_path(cx, tps, path, s, v)\n         }\n       }\n \n-      ast::ty_mac(_) {\n+      ast::ty_mac(_) => {\n         cx.span_err(ty.span, ~\"cannot serialize macro types\");\n         ~[]\n       }\n \n-      ast::ty_infer {\n+      ast::ty_infer => {\n         cx.span_err(ty.span, ~\"cannot serialize inferred types\");\n         ~[]\n       }\n \n-      ast::ty_vec(mt) {\n+      ast::ty_vec(mt) => {\n         let ser_e =\n             cx.expr(\n                 ty.span,\n@@ -519,7 +519,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n         }]\n       }\n \n-      ast::ty_fixed_length(_, _) {\n+      ast::ty_fixed_length(_, _) => {\n         cx.span_unimpl(ty.span, ~\"serialization for fixed length types\");\n       }\n     }\n@@ -635,34 +635,34 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n     let ext_cx = cx; // required for #ast{}\n \n     alt ty.node {\n-      ast::ty_nil {\n+      ast::ty_nil => {\n         #ast{ $(d).read_nil() }\n       }\n \n-      ast::ty_bot {\n+      ast::ty_bot => {\n         #ast{ fail }\n       }\n \n-      ast::ty_box(mt) {\n+      ast::ty_box(mt) => {\n         let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n         #ast{ @$(d).read_box($(l)) }\n       }\n \n       // For unique evecs/estrs, just pass through to underlying vec or str\n-      ast::ty_uniq(mt) if is_vec_or_str(mt.ty) {\n+      ast::ty_uniq(mt) if is_vec_or_str(mt.ty) => {\n         deser_ty(cx, tps, mt.ty, d)\n       }\n \n-      ast::ty_uniq(mt) {\n+      ast::ty_uniq(mt) => {\n         let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n         #ast{ ~$(d).read_uniq($(l)) }\n       }\n \n-      ast::ty_ptr(_) | ast::ty_rptr(_, _) {\n+      ast::ty_ptr(_) | ast::ty_rptr(_, _) => {\n         #ast{ fail }\n       }\n \n-      ast::ty_rec(flds) {\n+      ast::ty_rec(flds) => {\n         let fields = do vec::from_fn(vec::len(flds)) |fidx| {\n             let fld = flds[fidx];\n             let d = cx.clone(d);\n@@ -679,11 +679,11 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n         #ast{ $(d).read_rec($(fld_lambda)) }\n       }\n \n-      ast::ty_fn(_, _) {\n+      ast::ty_fn(_, _) => {\n         #ast{ fail }\n       }\n \n-      ast::ty_tup(tys) {\n+      ast::ty_tup(tys) => {\n         // Generate code like\n         //\n         // d.read_tup(3u) {||\n@@ -704,34 +704,34 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n         #ast{ $(d).read_tup($(sz), $(body)) }\n       }\n \n-      ast::ty_path(path, _) {\n+      ast::ty_path(path, _) => {\n         if vec::len(path.idents) == 1u &&\n             vec::is_empty(path.types) {\n             let ident = path.idents[0];\n \n             alt tps.find(*ident) {\n-              some(f) { f() }\n-              none { deser_path(cx, tps, path, d) }\n+              some(f) => f(),\n+              none => deser_path(cx, tps, path, d)\n             }\n         } else {\n             deser_path(cx, tps, path, d)\n         }\n       }\n \n-      ast::ty_mac(_) {\n+      ast::ty_mac(_) => {\n         #ast{ fail }\n       }\n \n-      ast::ty_infer {\n+      ast::ty_infer => {\n         #ast{ fail }\n       }\n \n-      ast::ty_vec(mt) {\n+      ast::ty_vec(mt) => {\n         let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n         #ast{ std::serialization::read_to_vec($(d), $(l)) }\n       }\n \n-      ast::ty_fixed_length(_, _) {\n+      ast::ty_fixed_length(_, _) => {\n         cx.span_unimpl(ty.span, ~\"deserialization for fixed length types\");\n       }\n     }"}, {"sha": "b8cce21190c13494ff823f1d0a5ea8d3ed143ac1", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 33, "deletions": 39, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -151,7 +151,7 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n         fn mod_path() -> ~[ast::ident] { return self.mod_path; }\n         fn bt_push(ei: codemap::expn_info_) {\n             alt ei {\n-              expanded_from({call_site: cs, callie: callie}) {\n+              expanded_from({call_site: cs, callie: callie}) => {\n                 self.backtrace =\n                     some(@expanded_from({\n                         call_site: {lo: cs.lo, hi: cs.hi,\n@@ -162,10 +162,10 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n         }\n         fn bt_pop() {\n             alt self.backtrace {\n-              some(@expanded_from({call_site: {expn_info: prev, _}, _})) {\n+              some(@expanded_from({call_site: {expn_info: prev, _}, _})) => {\n                 self.backtrace = prev\n               }\n-              _ { self.bug(~\"tried to pop without a push\"); }\n+              _ => self.bug(~\"tried to pop without a push\")\n             }\n         }\n         fn span_fatal(sp: span, msg: ~str) -> ! {\n@@ -207,24 +207,22 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n \n fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, error: ~str) -> ~str {\n     alt expr.node {\n-      ast::expr_lit(l) {\n-        alt l.node {\n-          ast::lit_str(s) { return *s; }\n-          _ { cx.span_fatal(l.span, error); }\n-        }\n+      ast::expr_lit(l) => alt l.node {\n+        ast::lit_str(s) => return *s,\n+        _ => cx.span_fatal(l.span, error)\n       }\n-      _ { cx.span_fatal(expr.span, error); }\n+      _ => cx.span_fatal(expr.span, error)\n     }\n }\n \n fn expr_to_ident(cx: ext_ctxt, expr: @ast::expr, error: ~str) -> ast::ident {\n     alt expr.node {\n-      ast::expr_path(p) {\n+      ast::expr_path(p) => {\n         if vec::len(p.types) > 0u || vec::len(p.idents) != 1u {\n             cx.span_fatal(expr.span, error);\n         } else { return p.idents[0]; }\n       }\n-      _ { cx.span_fatal(expr.span, error); }\n+      _ => cx.span_fatal(expr.span, error)\n     }\n }\n \n@@ -236,38 +234,36 @@ fn get_mac_args_no_max(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n fn get_mac_args(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                 min: uint, max: option<uint>, name: ~str) -> ~[@ast::expr] {\n     alt arg {\n-      some(expr) {\n-        alt expr.node {\n-          ast::expr_vec(elts, _) {\n+      some(expr) => alt expr.node {\n+        ast::expr_vec(elts, _) => {\n             let elts_len = vec::len(elts);\n-            alt max {\n-              some(max) if ! (min <= elts_len && elts_len <= max) {\n-                cx.span_fatal(sp,\n-                              fmt!{\"#%s takes between %u and %u arguments.\",\n-                                   name, min, max});\n-              }\n-              none if ! (min <= elts_len) {\n-                cx.span_fatal(sp, fmt!{\"#%s needs at least %u arguments.\",\n-                                       name, min});\n+              alt max {\n+                some(max) if ! (min <= elts_len && elts_len <= max) => {\n+                  cx.span_fatal(sp,\n+                                fmt!{\"#%s takes between %u and %u arguments.\",\n+                                     name, min, max});\n+                }\n+                none if ! (min <= elts_len) => {\n+                  cx.span_fatal(sp, fmt!{\"#%s needs at least %u arguments.\",\n+                                         name, min});\n+                }\n+                _ => return elts /* we're good */\n               }\n-              _ { return elts; /* we're good */}\n-            }\n           }\n-          _ {\n+        _ => {\n             cx.span_fatal(sp, fmt!{\"#%s: malformed invocation\", name})\n           }\n-        }\n       }\n-      none {cx.span_fatal(sp, fmt!{\"#%s: missing arguments\", name})}\n+      none => cx.span_fatal(sp, fmt!{\"#%s: missing arguments\", name})\n     }\n }\n \n fn get_mac_body(cx: ext_ctxt, sp: span, args: ast::mac_body)\n     -> ast::mac_body_\n {\n     alt (args) {\n-      some(body) {body}\n-      none {cx.span_fatal(sp, ~\"missing macro body\")}\n+      some(body) => body,\n+      none => cx.span_fatal(sp, ~\"missing macro body\")\n     }\n }\n \n@@ -295,17 +291,15 @@ fn tt_args_to_original_flavor(cx: ext_ctxt, sp: span, arg: ~[ast::token_tree])\n     let args =\n         alt parse_or_else(cx.parse_sess(), cx.cfg(), arg_reader as reader,\n                           argument_gram).get(@~\"arg\") {\n-          @matched_seq(s, _) {\n-            do s.map() |lf| {\n-                alt lf {\n-                  @matched_nonterminal(parse::token::nt_expr(arg)) {\n-                    arg /* whew! list of exprs, here we come! */\n-                  }\n-                  _ { fail ~\"badly-structured parse result\"; }\n-                }\n+          @matched_seq(s, _) => do s.map() |lf| {\n+            alt lf {\n+              @matched_nonterminal(parse::token::nt_expr(arg)) => {\n+                arg /* whew! list of exprs, here we come! */\n+              }\n+              _ => fail ~\"badly-structured parse result\"\n             }\n           }\n-          _ { fail ~\"badly-structured parse result\"; }\n+          _ => fail ~\"badly-structured parse result\"\n         };\n \n     return some(@{id: parse::next_node_id(cx.parse_sess()),"}, {"sha": "143a675fa639c5b38d39c5e125e0631a5ec2920b", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -17,8 +17,8 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n \n     let var = expr_to_str(cx, args[0], ~\"#env requires a string\");\n     alt os::getenv(var) {\n-      option::none { return mk_uniq_str(cx, sp, ~\"\"); }\n-      option::some(s) { return mk_uniq_str(cx, sp, s); }\n+      option::none => return mk_uniq_str(cx, sp, ~\"\"),\n+      option::some(s) => return mk_uniq_str(cx, sp, s)\n     }\n }\n "}, {"sha": "ee1ec62e4e2c0c409303090eb25ecfc35a884815", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 39, "deletions": 46, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -18,25 +18,25 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n     return alt e {\n       // expr_mac should really be expr_ext or something; it's the\n       // entry-point for all syntax extensions.\n-          expr_mac(mac) {\n+          expr_mac(mac) => {\n \n             // Old-style macros, for compatibility, will erase this whole\n             // block once we've transitioned.\n             alt mac.node {\n-              mac_invoc(pth, args, body) {\n+              mac_invoc(pth, args, body) => {\n                 assert (vec::len(pth.idents) > 0u);\n                 let extname = pth.idents[0];\n                 alt exts.find(*extname) {\n-                  none {\n+                  none => {\n                     cx.span_fatal(pth.span,\n                                   fmt!{\"macro undefined: '%s'\", *extname})\n                   }\n-                  some(item_decorator(_)) {\n+                  some(item_decorator(_)) => {\n                     cx.span_fatal(\n                         pth.span,\n                         fmt!{\"%s can only be used as a decorator\", *extname});\n                   }\n-                  some(normal({expander: exp, span: exp_sp})) {\n+                  some(normal({expander: exp, span: exp_sp})) => {\n                     let expanded = exp(cx, mac.span, args, body);\n \n                     cx.bt_push(expanded_from({call_site: s,\n@@ -47,17 +47,17 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n \n                     (fully_expanded, s)\n                   }\n-                  some(macro_defining(ext)) {\n+                  some(macro_defining(ext)) => {\n                     let named_extension = ext(cx, mac.span, args, body);\n                     exts.insert(*named_extension.ident, named_extension.ext);\n                     (ast::expr_rec(~[], none), s)\n                   }\n-                  some(expr_tt(_)) {\n+                  some(expr_tt(_)) => {\n                     cx.span_fatal(pth.span,\n                                   fmt!{\"this tt-style macro should be \\\n                                         invoked '%s!{...}'\", *extname})\n                   }\n-                  some(item_tt(*)) {\n+                  some(item_tt(*)) => {\n                     cx.span_fatal(pth.span,\n                                   ~\"cannot use item macros in this context\");\n                   }\n@@ -66,20 +66,20 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n \n               // Token-tree macros, these will be the only case when we're\n               // finished transitioning.\n-              mac_invoc_tt(pth, tts) {\n+              mac_invoc_tt(pth, tts) => {\n                 assert (vec::len(pth.idents) == 1u);\n                 let extname = pth.idents[0];\n                 alt exts.find(*extname) {\n-                  none {\n+                  none => {\n                     cx.span_fatal(pth.span,\n                                   fmt!{\"macro undefined: '%s'\", *extname})\n                   }\n-                  some(expr_tt({expander: exp, span: exp_sp})) {\n+                  some(expr_tt({expander: exp, span: exp_sp})) => {\n                     let expanded = alt exp(cx, mac.span, tts) {\n-                      mr_expr(e) { e }\n-                      _ { cx.span_fatal(\n+                      mr_expr(e) => e,\n+                      _ => cx.span_fatal(\n                           pth.span, fmt!{\"non-expr macro in expr pos: %s\",\n-                                         *extname}) }\n+                                         *extname})\n                     };\n \n                     cx.bt_push(expanded_from({call_site: s,\n@@ -90,7 +90,7 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n \n                     (fully_expanded, s)\n                   }\n-                  some(normal({expander: exp, span: exp_sp})) {\n+                  some(normal({expander: exp, span: exp_sp})) => {\n                     //convert the new-style invoc for the old-style macro\n                     let arg = base::tt_args_to_original_flavor(cx, pth.span,\n                                                                tts);\n@@ -104,18 +104,18 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n \n                     (fully_expanded, s)\n                   }\n-                  _ {\n+                  _ => {\n                     cx.span_fatal(pth.span,\n                                   fmt!{\"'%s' is not a tt-style macro\",\n                                        *extname})\n                   }\n \n                 }\n               }\n-              _ { cx.span_bug(mac.span, ~\"naked syntactic bit\") }\n+              _ => cx.span_bug(mac.span, ~\"naked syntactic bit\")\n             }\n           }\n-          _ { orig(e, s, fld) }\n+          _ => orig(e, s, fld)\n         };\n }\n \n@@ -142,17 +142,14 @@ fn expand_mod_items(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n     let new_items = do vec::flat_map(module_.items) |item| {\n         do vec::foldr(item.attrs, ~[item]) |attr, items| {\n             let mname = alt attr.node.value.node {\n-              ast::meta_word(n) { n }\n-              ast::meta_name_value(n, _) { n }\n-              ast::meta_list(n, _) { n }\n+              ast::meta_word(n) => n,\n+              ast::meta_name_value(n, _) => n,\n+              ast::meta_list(n, _) => n\n             };\n             alt exts.find(*mname) {\n               none | some(normal(_)) | some(macro_defining(_))\n-              | some(expr_tt(_)) | some(item_tt(*)) {\n-                items\n-              }\n-\n-              some(item_decorator(dec_fn)) {\n+              | some(expr_tt(_)) | some(item_tt(*)) => items,\n+              some(item_decorator(dec_fn)) => {\n                 dec_fn(cx, attr.span, attr.node.value, items)\n               }\n             }\n@@ -170,24 +167,22 @@ fn expand_item(exts: hashmap<~str, syntax_extension>,\n     -> option<@ast::item>\n {\n     let is_mod = alt it.node {\n-      ast::item_mod(_) | ast::item_foreign_mod(_) {true}\n-      _ {false}\n+      ast::item_mod(_) | ast::item_foreign_mod(_) => true,\n+      _ => false\n     };\n     let maybe_it = alt it.node {\n-      ast::item_mac(*) {\n-        expand_item_mac(exts, cx, it, fld)\n-      }\n-      _ { some(it) }\n+      ast::item_mac(*) => expand_item_mac(exts, cx, it, fld),\n+      _ => some(it)\n     };\n \n     alt maybe_it {\n-      some(it) {\n+      some(it) => {\n         if is_mod { cx.mod_push(it.ident); }\n         let ret_val = orig(it, fld);\n         if is_mod { cx.mod_pop(); }\n         return ret_val;\n       }\n-      none { return none; }\n+      none => return none\n     }\n }\n \n@@ -198,38 +193,36 @@ fn expand_item_mac(exts: hashmap<~str, syntax_extension>,\n                    cx: ext_ctxt, &&it: @ast::item,\n                    fld: ast_fold) -> option<@ast::item> {\n     alt it.node {\n-      item_mac({node: mac_invoc_tt(pth, tts), span}) {\n+      item_mac({node: mac_invoc_tt(pth, tts), span}) => {\n         let extname = pth.idents[0];\n         alt exts.find(*extname) {\n-          none {\n+          none => {\n             cx.span_fatal(pth.span,\n                           fmt!{\"macro undefined: '%s'\", *extname})\n           }\n-          some(item_tt(expand)) {\n+          some(item_tt(expand)) => {\n             let expanded = expand.expander(cx, it.span, it.ident, tts);\n             cx.bt_push(expanded_from({call_site: it.span,\n                                       callie: {name: *extname,\n                                                span: expand.span}}));\n             let maybe_it = alt expanded {\n-              mr_item(it) { fld.fold_item(it) }\n-              mr_expr(e) { cx.span_fatal(pth.span,\n+              mr_item(it) => fld.fold_item(it),\n+              mr_expr(e) => cx.span_fatal(pth.span,\n                                          ~\"expr macro in item position: \" +\n-                                         *extname) }\n-              mr_def(mdef) {\n+                                         *extname),\n+              mr_def(mdef) => {\n                 exts.insert(*mdef.ident, mdef.ext);\n                 none\n               }\n             };\n             cx.bt_pop();\n             return maybe_it\n           }\n-          _ { cx.span_fatal(it.span,\n-                            fmt!{\"%s is not a legal here\", *extname}) }\n+          _ => cx.span_fatal(it.span,\n+                            fmt!{\"%s is not a legal here\", *extname})\n         }\n       }\n-      _ {\n-        cx.span_bug(it.span, ~\"invalid item macro invocation\");\n-      }\n+      _ => cx.span_bug(it.span, ~\"invalid item macro invocation\")\n     }\n }\n "}, {"sha": "d1acf622c1f614b238752d1c2f45bbe9cc89bb84", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 79, "deletions": 92, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -53,11 +53,11 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n             let mut tmp_expr = make_rt_path_expr(cx, sp, @~\"flag_none\");\n             for flags.each |f| {\n                 let fstr = alt f {\n-                  flag_left_justify { ~\"flag_left_justify\" }\n-                  flag_left_zero_pad { ~\"flag_left_zero_pad\" }\n-                  flag_space_for_sign { ~\"flag_space_for_sign\" }\n-                  flag_sign_always { ~\"flag_sign_always\" }\n-                  flag_alternate { ~\"flag_alternate\" }\n+                  flag_left_justify => ~\"flag_left_justify\",\n+                  flag_left_zero_pad => ~\"flag_left_zero_pad\",\n+                  flag_space_for_sign => ~\"flag_space_for_sign\",\n+                  flag_sign_always => ~\"flag_sign_always\",\n+                  flag_alternate => ~\"flag_alternate\"\n                 };\n                 tmp_expr = mk_binary(cx, sp, ast::bitor, tmp_expr,\n                                      make_rt_path_expr(cx, sp, @fstr));\n@@ -66,30 +66,28 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         }\n         fn make_count(cx: ext_ctxt, sp: span, cnt: count) -> @ast::expr {\n             alt cnt {\n-              count_implied {\n+              count_implied => {\n                 return make_rt_path_expr(cx, sp, @~\"count_implied\");\n               }\n-              count_is(c) {\n+              count_is(c) => {\n                 let count_lit = mk_int(cx, sp, c);\n                 let count_is_path = make_path_vec(cx, @~\"count_is\");\n                 let count_is_args = ~[count_lit];\n                 return mk_call(cx, sp, count_is_path, count_is_args);\n               }\n-              _ { cx.span_unimpl(sp, ~\"unimplemented #fmt conversion\"); }\n+              _ => cx.span_unimpl(sp, ~\"unimplemented #fmt conversion\")\n             }\n         }\n         fn make_ty(cx: ext_ctxt, sp: span, t: ty) -> @ast::expr {\n             let mut rt_type;\n             alt t {\n-              ty_hex(c) {\n-                alt c {\n-                  case_upper { rt_type = ~\"ty_hex_upper\"; }\n-                  case_lower { rt_type = ~\"ty_hex_lower\"; }\n-                }\n+              ty_hex(c) => alt c {\n+                case_upper => rt_type = ~\"ty_hex_upper\",\n+                case_lower => rt_type = ~\"ty_hex_lower\"\n               }\n-              ty_bits { rt_type = ~\"ty_bits\"; }\n-              ty_octal { rt_type = ~\"ty_octal\"; }\n-              _ { rt_type = ~\"ty_default\"; }\n+              ty_bits => rt_type = ~\"ty_bits\",\n+              ty_octal => rt_type = ~\"ty_octal\",\n+              _ => rt_type = ~\"ty_default\"\n             }\n             return make_rt_path_expr(cx, sp, @rt_type);\n         }\n@@ -124,128 +122,117 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n \n         fn is_signed_type(cnv: conv) -> bool {\n             alt cnv.ty {\n-              ty_int(s) {\n-                alt s { signed { return true; } unsigned { return false; } }\n+              ty_int(s) => alt s {\n+                signed => return true,\n+                unsigned => return false\n               }\n-              ty_float { return true; }\n-              _ { return false; }\n+              ty_float => return true,\n+              _ => return false\n             }\n         }\n         let unsupported = ~\"conversion not supported in #fmt string\";\n         alt cnv.param {\n-          option::none { }\n-          _ { cx.span_unimpl(sp, unsupported); }\n+          option::none => (),\n+          _ => cx.span_unimpl(sp, unsupported)\n         }\n         for cnv.flags.each |f| {\n             alt f {\n-              flag_left_justify { }\n-              flag_sign_always {\n+              flag_left_justify => (),\n+              flag_sign_always => {\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n                                   ~\"+ flag only valid in \" +\n                                       ~\"signed #fmt conversion\");\n                 }\n               }\n-              flag_space_for_sign {\n+              flag_space_for_sign => {\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n                                   ~\"space flag only valid in \" +\n                                       ~\"signed #fmt conversions\");\n                 }\n               }\n-              flag_left_zero_pad { }\n-              _ { cx.span_unimpl(sp, unsupported); }\n+              flag_left_zero_pad => (),\n+              _ => cx.span_unimpl(sp, unsupported)\n             }\n         }\n         alt cnv.width {\n-          count_implied { }\n-          count_is(_) { }\n-          _ { cx.span_unimpl(sp, unsupported); }\n+          count_implied => (),\n+          count_is(_) => (),\n+          _ => cx.span_unimpl(sp, unsupported)\n         }\n         alt cnv.precision {\n-          count_implied { }\n-          count_is(_) { }\n-          _ { cx.span_unimpl(sp, unsupported); }\n+          count_implied => (),\n+          count_is(_) => (),\n+          _ => cx.span_unimpl(sp, unsupported)\n         }\n         alt cnv.ty {\n-          ty_str { return make_conv_call(cx, arg.span, ~\"str\", cnv, arg); }\n-          ty_int(sign) {\n-            alt sign {\n-              signed {\n-                return make_conv_call(cx, arg.span, ~\"int\", cnv, arg);\n-              }\n-              unsigned {\n-                return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg);\n-              }\n+          ty_str => return make_conv_call(cx, arg.span, ~\"str\", cnv, arg),\n+          ty_int(sign) => alt sign {\n+            signed => return make_conv_call(cx, arg.span, ~\"int\", cnv, arg),\n+            unsigned => {\n+                return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg)\n             }\n           }\n-          ty_bool { return make_conv_call(cx, arg.span, ~\"bool\", cnv, arg); }\n-          ty_char { return make_conv_call(cx, arg.span, ~\"char\", cnv, arg); }\n-          ty_hex(_) {\n+          ty_bool => return make_conv_call(cx, arg.span, ~\"bool\", cnv, arg),\n+          ty_char => return make_conv_call(cx, arg.span, ~\"char\", cnv, arg),\n+          ty_hex(_) => {\n             return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg);\n           }\n-          ty_bits { return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n-          ty_octal { return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n-          ty_float {\n+          ty_bits => return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg),\n+          ty_octal => return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg),\n+          ty_float => {\n             return make_conv_call(cx, arg.span, ~\"float\", cnv, arg);\n           }\n-          ty_poly { return make_conv_call(cx, arg.span, ~\"poly\", cnv, arg); }\n+          ty_poly => return make_conv_call(cx, arg.span, ~\"poly\", cnv, arg)\n         }\n     }\n     fn log_conv(c: conv) {\n         alt c.param {\n-          some(p) { log(debug, ~\"param: \" + int::to_str(p, 10u)); }\n-          _ { debug!{\"param: none\"}; }\n+          some(p) => { log(debug, ~\"param: \" + int::to_str(p, 10u)); }\n+          _ => debug!{\"param: none\"}\n         }\n         for c.flags.each |f| {\n             alt f {\n-              flag_left_justify { debug!{\"flag: left justify\"}; }\n-              flag_left_zero_pad { debug!{\"flag: left zero pad\"}; }\n-              flag_space_for_sign { debug!{\"flag: left space pad\"}; }\n-              flag_sign_always { debug!{\"flag: sign always\"}; }\n-              flag_alternate { debug!{\"flag: alternate\"}; }\n+              flag_left_justify => debug!{\"flag: left justify\"},\n+              flag_left_zero_pad => debug!{\"flag: left zero pad\"},\n+              flag_space_for_sign => debug!{\"flag: left space pad\"},\n+              flag_sign_always => debug!{\"flag: sign always\"},\n+              flag_alternate => debug!{\"flag: alternate\"}\n             }\n         }\n         alt c.width {\n-          count_is(i) { log(debug,\n-                                 ~\"width: count is \" + int::to_str(i, 10u)); }\n-          count_is_param(i) {\n-            log(debug,\n-                     ~\"width: count is param \" + int::to_str(i, 10u));\n-          }\n-          count_is_next_param { debug!{\"width: count is next param\"}; }\n-          count_implied { debug!{\"width: count is implied\"}; }\n+          count_is(i) => log(\n+              debug, ~\"width: count is \" + int::to_str(i, 10u)),\n+          count_is_param(i) => log(\n+              debug, ~\"width: count is param \" + int::to_str(i, 10u)),\n+          count_is_next_param => debug!{\"width: count is next param\"},\n+          count_implied => debug!{\"width: count is implied\"}\n         }\n         alt c.precision {\n-          count_is(i) { log(debug,\n-                                 ~\"prec: count is \" + int::to_str(i, 10u)); }\n-          count_is_param(i) {\n-            log(debug,\n-                     ~\"prec: count is param \" + int::to_str(i, 10u));\n-          }\n-          count_is_next_param { debug!{\"prec: count is next param\"}; }\n-          count_implied { debug!{\"prec: count is implied\"}; }\n+          count_is(i) => log(\n+              debug, ~\"prec: count is \" + int::to_str(i, 10u)),\n+          count_is_param(i) => log(\n+              debug, ~\"prec: count is param \" + int::to_str(i, 10u)),\n+          count_is_next_param => debug!{\"prec: count is next param\"},\n+          count_implied => debug!{\"prec: count is implied\"}\n         }\n         alt c.ty {\n-          ty_bool { debug!{\"type: bool\"}; }\n-          ty_str { debug!{\"type: str\"}; }\n-          ty_char { debug!{\"type: char\"}; }\n-          ty_int(s) {\n-            alt s {\n-              signed { debug!{\"type: signed\"}; }\n-              unsigned { debug!{\"type: unsigned\"}; }\n-            }\n+          ty_bool => debug!{\"type: bool\"},\n+          ty_str => debug!{\"type: str\"},\n+          ty_char => debug!{\"type: char\"},\n+          ty_int(s) => alt s {\n+            signed => debug!{\"type: signed\"},\n+            unsigned => debug!{\"type: unsigned\"}\n           }\n-          ty_bits { debug!{\"type: bits\"}; }\n-          ty_hex(cs) {\n-            alt cs {\n-              case_upper { debug!{\"type: uhex\"}; }\n-              case_lower { debug!{\"type: lhex\"}; }\n-            }\n+          ty_bits => debug!{\"type: bits\"},\n+          ty_hex(cs) => alt cs {\n+            case_upper => debug!{\"type: uhex\"},\n+            case_lower => debug!{\"type: lhex\"},\n           }\n-          ty_octal { debug!{\"type: octal\"}; }\n-          ty_float { debug!{\"type: float\"}; }\n-          ty_poly { debug!{\"type: poly\"}; }\n+          ty_octal => debug!{\"type: octal\"},\n+          ty_float => debug!{\"type: float\"},\n+          ty_poly => debug!{\"type: poly\"}\n         }\n     }\n     let fmt_sp = args[0].span;\n@@ -254,10 +241,10 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     let nargs = args.len();\n     for pieces.each |pc| {\n         alt pc {\n-          piece_string(s) {\n-            vec::push(piece_exprs, mk_uniq_str(cx, fmt_sp, s));\n+          piece_string(s) => {\n+            vec::push(piece_exprs, mk_uniq_str(cx, fmt_sp, s))\n           }\n-          piece_conv(conv) {\n+          piece_conv(conv) => {\n             n += 1u;\n             if n >= nargs {\n                 cx.span_fatal(sp,"}, {"sha": "59687eda96d5d6f4b66e68bde758dd695a142e3e", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -45,7 +45,7 @@ impl proto_check of proto::visitor<(), (), ()>  for ext_ctxt {\n     fn visit_message(name: ident, _span: span, _tys: &[@ast::ty],\n                      this: state, next: next_state) {\n         alt next {\n-          some({state: next, tys: next_tys}) {\n+          some({state: next, tys: next_tys}) => {\n             let proto = this.proto;\n             if !proto.has_state(next) {\n                 // This should be a span fatal, but then we need to\n@@ -69,7 +69,7 @@ impl proto_check of proto::visitor<(), (), ()>  for ext_ctxt {\n                 }\n             }\n           }\n-          none { }\n+          none => ()\n         }\n     }\n }\n\\ No newline at end of file"}, {"sha": "678f5b36c45bfc5df0ba40ffa4f4ee004bfec777", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -26,16 +26,14 @@ impl proto_parser of proto_parser for parser {\n         let id = self.parse_ident();\n         self.expect(token::COLON);\n         let dir = alt copy self.token {\n-          token::IDENT(n, _) {\n-            self.get_str(n)\n-          }\n-          _ { fail }\n+          token::IDENT(n, _) => self.get_str(n),\n+          _ => fail\n         };\n         self.bump();\n         let dir = alt dir {\n-          @~\"send\" { send }\n-          @~\"recv\" { recv }\n-          _ { fail }\n+          @~\"send\" => send,\n+          @~\"recv\" => recv,\n+          _ => fail\n         };\n \n         let typarms = if self.token == token::LT {\n@@ -67,7 +65,7 @@ impl proto_parser of proto_parser for parser {\n         self.expect(token::RARROW);\n \n         let next = alt copy self.token {\n-          token::IDENT(_, _) {\n+          token::IDENT(_, _) => {\n             let name = self.parse_ident();\n             let ntys = if self.token == token::LT {\n                 self.parse_unspanned_seq(token::LT,\n@@ -79,12 +77,12 @@ impl proto_parser of proto_parser for parser {\n             else { ~[] };\n             some({state: name, tys: ntys})\n           }\n-          token::NOT {\n+          token::NOT => {\n             // -> !\n             self.bump();\n             none\n           }\n-          _ { self.fatal(~\"invalid next state\") }\n+          _ => self.fatal(~\"invalid next state\")\n         };\n \n         state.add_message(mname, copy self.span, args, next);"}, {"sha": "f61601a2aa035848d0f8b995afd97cd4b683ef5b", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -48,7 +48,8 @@ impl compile of gen_send for message {\n     fn gen_send(cx: ext_ctxt) -> @ast::item {\n         debug!{\"pipec: gen_send\"};\n         alt self {\n-          message(id, span, tys, this, some({state: next, tys: next_tys})) {\n+          message(id, span, tys, this,\n+                  some({state: next, tys: next_tys})) => {\n             debug!{\"pipec: next state exists\"};\n             let next = this.proto.get_state(next);\n             assert next_tys.len() == next.ty_params.len();\n@@ -71,10 +72,10 @@ impl compile of gen_send for message {\n \n             if this.proto.is_bounded() {\n                 let (sp, rp) = alt (this.dir, next.dir) {\n-                  (send, send) { (~\"c\", ~\"s\") }\n-                  (send, recv) { (~\"s\", ~\"c\") }\n-                  (recv, send) { (~\"s\", ~\"c\") }\n-                  (recv, recv) { (~\"c\", ~\"s\") }\n+                  (send, send) => (~\"c\", ~\"s\"),\n+                  (send, recv) => (~\"s\", ~\"c\"),\n+                  (recv, send) => (~\"s\", ~\"c\"),\n+                  (recv, recv) => (~\"c\", ~\"s\")\n                 };\n \n                 body += ~\"let b = pipe.reuse_buffer();\\n\";\n@@ -87,10 +88,10 @@ impl compile of gen_send for message {\n             }\n             else {\n                 let pat = alt (this.dir, next.dir) {\n-                  (send, send) { ~\"(c, s)\" }\n-                  (send, recv) { ~\"(s, c)\" }\n-                  (recv, send) { ~\"(s, c)\" }\n-                  (recv, recv) { ~\"(c, s)\" }\n+                  (send, send) => ~\"(c, s)\",\n+                  (send, recv) => ~\"(s, c)\",\n+                  (recv, send) => ~\"(s, c)\",\n+                  (recv, recv) => ~\"(c, s)\"\n                 };\n \n                 body += fmt!{\"let %s = pipes::entangle();\\n\", pat};\n@@ -116,7 +117,7 @@ impl compile of gen_send for message {\n                             cx.expr_block(body))\n           }\n \n-          message(id, span, tys, this, none) {\n+          message(id, span, tys, this, none) => {\n             debug!{\"pipec: no next state\"};\n             let arg_names = tys.mapi(|i, _ty| @(~\"x_\" + i.to_str()));\n \n@@ -181,20 +182,20 @@ impl compile of to_type_decls for state {\n             let message(name, _span, tys, this, next) = m;\n \n             let tys = alt next {\n-              some({state: next, tys: next_tys}) {\n+              some({state: next, tys: next_tys}) => {\n                 let next = this.proto.get_state(next);\n                 let next_name = next.data_name();\n \n                 let dir = alt this.dir {\n-                  send { @~\"server\" }\n-                  recv { @~\"client\" }\n+                  send => @~\"server\",\n+                  recv => @~\"client\"\n                 };\n \n                 vec::append_one(tys,\n                                 cx.ty_path_ast_builder((dir + next_name)\n                                            .add_tys(next_tys)))\n               }\n-              none { tys }\n+              none => tys\n             };\n \n             let v = cx.variant(name, tys);\n@@ -208,8 +209,8 @@ impl compile of to_type_decls for state {\n     fn to_endpoint_decls(cx: ext_ctxt, dir: direction) -> ~[@ast::item] {\n         debug!{\"pipec: to_endpoint_decls\"};\n         let dir = alt dir {\n-          send { (*self).dir }\n-          recv { (*self).dir.reverse() }\n+          send => (*self).dir,\n+          recv => (*self).dir.reverse()\n         };\n         let mut items = ~[];\n         for self.messages.each |m| {\n@@ -255,8 +256,8 @@ impl compile of gen_init for protocol {\n \n         let body = if !self.is_bounded() {\n             alt start_state.dir {\n-              send { #ast { pipes::entangle() } }\n-              recv {\n+              send => #ast { pipes::entangle() },\n+              recv => {\n                 #ast {{\n                     let (s, c) = pipes::entangle();\n                     (c, s)\n@@ -267,8 +268,8 @@ impl compile of gen_init for protocol {\n         else {\n             let body = self.gen_init_bounded(ext_cx);\n             alt start_state.dir {\n-              send { body }\n-              recv {\n+              send => body,\n+              recv => {\n                 #ast {{\n                     let (s, c) = $(body);\n                     (c, s)\n@@ -322,8 +323,8 @@ impl compile of gen_init for protocol {\n         for (copy self.states).each |s| {\n             for s.ty_params.each |tp| {\n                 alt params.find(|tpp| *tp.ident == *tpp.ident) {\n-                  none { vec::push(params, tp) }\n-                  _ { }\n+                  none => vec::push(params, tp),\n+                  _ => ()\n                 }\n             }\n         }\n@@ -338,8 +339,8 @@ impl compile of gen_init for protocol {\n         let fields = do (copy self.states).map_to_vec |s| {\n             for s.ty_params.each |tp| {\n                 alt params.find(|tpp| *tp.ident == *tpp.ident) {\n-                  none { vec::push(params, tp) }\n-                  _ { }\n+                  none => vec::push(params, tp),\n+                  _ => ()\n                 }\n             }\n             let ty = s.to_ty(cx);\n@@ -439,8 +440,8 @@ impl parse_utils of ext_ctxt_parse_utils for ext_ctxt {\n             ~[],\n             self.parse_sess());\n         alt res {\n-          some(ast) { ast }\n-          none {\n+          some(ast) => ast,\n+          none => {\n             error!{\"Parse error with ```\\n%s\\n```\", s};\n             fail\n           }"}, {"sha": "bd9ea96ee33ef7564de825e51f7b965aac69fef5", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -12,17 +12,17 @@ enum direction {\n impl of to_str for direction {\n     fn to_str() -> ~str {\n         alt self {\n-          send { ~\"send\" }\n-          recv { ~\"recv\" }\n+          send => ~\"send\",\n+          recv => ~\"recv\"\n         }\n     }\n }\n \n impl methods for direction {\n     fn reverse() -> direction {\n         alt self {\n-          send { recv }\n-          recv { send }\n+          send => recv,\n+          recv => send\n         }\n     }\n }\n@@ -37,26 +37,20 @@ enum message {\n impl methods for message {\n     fn name() -> ident {\n         alt self {\n-          message(id, _, _, _, _) {\n-            id\n-          }\n+          message(id, _, _, _, _) => id\n         }\n     }\n \n     fn span() -> span {\n         alt self {\n-          message(_, span, _, _, _) {\n-            span\n-          }\n+          message(_, span, _, _, _) => span\n         }\n     }\n \n     /// Return the type parameters actually used by this message\n     fn get_params() -> ~[ast::ty_param] {\n         alt self {\n-          message(_, _, _, this, _) {\n-            this.ty_params\n-          }\n+          message(_, _, _, this, _) => this.ty_params\n         }\n     }\n }\n@@ -99,11 +93,11 @@ impl methods for state {\n     fn reachable(f: fn(state) -> bool) {\n         for self.messages.each |m| {\n             alt m {\n-              message(_, _, _, _, some({state: id, _})) {\n+              message(_, _, _, _, some({state: id, _})) => {\n                 let state = self.proto.get_state(id);\n                 if !f(state) { break }\n               }\n-              _ { }\n+              _ => ()\n             }\n         }\n     }"}, {"sha": "21ba9599240ccf801d19e568363474a7199a2dda", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -49,8 +49,8 @@ impl of qq_helper for @ast::expr {\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_expr(self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {\n         alt (self.node) {\n-          ast::expr_mac({node: mac, _}) {some(mac)}\n-          _ {none}\n+          ast::expr_mac({node: mac, _}) => some(mac),\n+          _ => none\n         }\n     }\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n@@ -64,8 +64,8 @@ impl of qq_helper for @ast::ty {\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_ty(self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {\n         alt (self.node) {\n-          ast::ty_mac({node: mac, _}) {some(mac)}\n-          _ {none}\n+          ast::ty_mac({node: mac, _}) => some(mac),\n+          _ => none\n         }\n     }\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n@@ -125,14 +125,14 @@ fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n fn visit_aq<T:qq_helper>(node: T, constr: ~str, &&cx: aq_ctxt, v: vt<aq_ctxt>)\n {\n     alt (node.extract_mac()) {\n-      some(mac_aq(sp, e)) {\n+      some(mac_aq(sp, e)) => {\n         cx.gather.push(gather_item {\n             lo: sp.lo - cx.lo,\n             hi: sp.hi - cx.lo,\n             e: e,\n             constr: constr});\n       }\n-      _ {node.visit(cx, v);}\n+      _ => node.visit(cx, v)\n     }\n }\n \n@@ -148,8 +148,8 @@ fn expand_ast(ecx: ext_ctxt, _sp: span,\n     do option::iter(arg) |arg| {\n         let args: ~[@ast::expr] =\n             alt arg.node {\n-              ast::expr_vec(elts, _) { elts }\n-              _ {\n+              ast::expr_vec(elts, _) => elts,\n+              _ => {\n                 ecx.span_fatal\n                     (_sp, ~\"#ast requires arguments of the form `~[...]`.\")\n               }\n@@ -159,20 +159,20 @@ fn expand_ast(ecx: ext_ctxt, _sp: span,\n         }\n         alt (args[0].node) {\n           ast::expr_path(@{idents: id, _}) if vec::len(id) == 1u\n-              {what = *id[0]}\n-          _ {ecx.span_fatal(args[0].span, ~\"expected an identifier\");}\n+          => what = *id[0],\n+          _ => ecx.span_fatal(args[0].span, ~\"expected an identifier\")\n         }\n     }\n     let body = get_mac_body(ecx,_sp,body);\n \n     return alt what {\n-      ~\"crate\" {finish(ecx, body, parse_crate)}\n-      ~\"expr\" {finish(ecx, body, parse_expr)}\n-      ~\"ty\" {finish(ecx, body, parse_ty)}\n-      ~\"item\" {finish(ecx, body, parse_item)}\n-      ~\"stmt\" {finish(ecx, body, parse_stmt)}\n-      ~\"pat\" {finish(ecx, body, parse_pat)}\n-      _ {ecx.span_fatal(_sp, ~\"unsupported ast type\")}\n+      ~\"crate\" => finish(ecx, body, parse_crate),\n+      ~\"expr\" => finish(ecx, body, parse_expr),\n+      ~\"ty\" => finish(ecx, body, parse_ty),\n+      ~\"item\" => finish(ecx, body, parse_item),\n+      ~\"stmt\" => finish(ecx, body, parse_stmt),\n+      ~\"pat\" => finish(ecx, body, parse_pat),\n+      _ => ecx.span_fatal(_sp, ~\"unsupported ast type\")\n     };\n }\n \n@@ -184,8 +184,8 @@ fn parse_pat(p: parser) -> @ast::pat { p.parse_pat(true) }\n \n fn parse_item(p: parser) -> @ast::item {\n     alt p.parse_item(~[]) {\n-      some(item) { item }\n-      none       { fail ~\"parse_item: parsing an item failed\"; }\n+      some(item) => item,\n+      none       => fail ~\"parse_item: parsing an item failed\"\n     }\n }\n \n@@ -226,11 +226,11 @@ fn finish<T: qq_helper>\n             str2 += repl;\n         }\n         alt copy state {\n-          active {str::push_char(str2, ch);}\n-          skip(1u) {state = blank;}\n-          skip(sk) {state = skip (sk-1u);}\n-          blank if is_space(ch) {str::push_char(str2, ch);}\n-          blank {str::push_char(str2, ' ');}\n+          active => str::push_char(str2, ch),\n+          skip(1u) => state = blank,\n+          skip(sk) => state = skip (sk-1u),\n+          blank if is_space(ch) => str::push_char(str2, ch),\n+          blank => str::push_char(str2, ' ')\n         }\n         i += 1u;\n         if (j < g_len && i == cx.gather[j].hi) {\n@@ -309,11 +309,11 @@ fn replace_expr(repls: ~[fragment],\n     -> (ast::expr_, span)\n {\n     alt e {\n-      ast::expr_mac({node: mac_var(i), _}) {\n-        alt (repls[i]) {\n-          from_expr(r) {(r.node, r.span)}\n-          _ {fail /* fixme error message */}}}\n-      _ {orig(e,s,fld)}\n+      ast::expr_mac({node: mac_var(i), _}) => alt (repls[i]) {\n+        from_expr(r) => (r.node, r.span),\n+        _ => fail /* fixme error message */\n+      }\n+      _ => orig(e,s,fld)\n     }\n }\n \n@@ -323,11 +323,11 @@ fn replace_ty(repls: ~[fragment],\n     -> (ast::ty_, span)\n {\n     alt e {\n-      ast::ty_mac({node: mac_var(i), _}) {\n-        alt (repls[i]) {\n-          from_ty(r) {(r.node, r.span)}\n-          _ {fail /* fixme error message */}}}\n-      _ {orig(e,s,fld)}\n+      ast::ty_mac({node: mac_var(i), _}) => alt (repls[i]) {\n+        from_ty(r) => (r.node, r.span),\n+        _ => fail /* fixme error message */\n+      }\n+      _ => orig(e,s,fld)\n     }\n }\n "}, {"sha": "79b609113abb557307726b0eac678ef13e7b5225", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 141, "deletions": 166, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -37,27 +37,17 @@ enum matchable {\n /* for when given an incompatible bit of AST */\n fn match_error(cx: ext_ctxt, m: matchable, expected: ~str) -> ! {\n     alt m {\n-      match_expr(x) {\n-        cx.span_fatal(x.span,\n-                      ~\"this argument is an expr, expected \" + expected);\n-      }\n-      match_path(x) {\n-        cx.span_fatal(x.span,\n-                      ~\"this argument is a path, expected \" + expected);\n-      }\n-      match_ident(x) {\n-        cx.span_fatal(x.span,\n-                      ~\"this argument is an ident, expected \" + expected);\n-      }\n-      match_ty(x) {\n-        cx.span_fatal(x.span,\n-                      ~\"this argument is a type, expected \" + expected);\n-      }\n-      match_block(x) {\n-        cx.span_fatal(x.span,\n-                      ~\"this argument is a block, expected \" + expected);\n-      }\n-      match_exact { cx.bug(~\"what is a match_exact doing in a bindings?\"); }\n+      match_expr(x) => cx.span_fatal(\n+          x.span, ~\"this argument is an expr, expected \" + expected),\n+      match_path(x) => cx.span_fatal(\n+          x.span, ~\"this argument is a path, expected \" + expected),\n+      match_ident(x) => cx.span_fatal(\n+          x.span, ~\"this argument is an ident, expected \" + expected),\n+      match_ty(x) => cx.span_fatal(\n+          x.span, ~\"this argument is a type, expected \" + expected),\n+      match_block(x) => cx.span_fatal(\n+          x.span, ~\"this argument is a block, expected \" + expected),\n+      match_exact => cx.bug(~\"what is a match_exact doing in a bindings?\")\n     }\n }\n \n@@ -76,56 +66,55 @@ fn elts_to_ell(cx: ext_ctxt, elts: ~[@expr]) ->\n     let mut res = none;\n     for elts.each |elt| {\n         alt elt.node {\n-          expr_mac(m) {\n-            alt m.node {\n-              ast::mac_ellipsis {\n+          expr_mac(m) => alt m.node {\n+            ast::mac_ellipsis => {\n                 if res != none {\n                     cx.span_fatal(m.span, ~\"only one ellipsis allowed\");\n                 }\n                 res =\n                     some({pre: vec::slice(elts, 0u, idx - 1u),\n                           rep: some(elts[idx - 1u]),\n                           post: vec::slice(elts, idx + 1u, vec::len(elts))});\n-              }\n-              _ { }\n             }\n+            _ => ()\n           }\n-          _ { }\n+          _ => ()\n         }\n         idx += 1u;\n     }\n     return alt res {\n-          some(val) { val }\n-          none { {pre: elts, rep: none, post: ~[]} }\n-        }\n+          some(val) => val,\n+          none => {pre: elts, rep: none, post: ~[]}\n+    }\n }\n \n fn option_flatten_map<T: copy, U: copy>(f: fn@(T) -> option<U>, v: ~[T]) ->\n    option<~[U]> {\n     let mut res = ~[];\n     for v.each |elem| {\n-        alt f(elem) { none { return none; } some(fv) { vec::push(res, fv); } }\n+        alt f(elem) {\n+          none => return none,\n+          some(fv) => vec::push(res, fv)\n+        }\n     }\n     return some(res);\n }\n \n fn a_d_map(ad: arb_depth<matchable>, f: selector) -> match_result {\n     alt ad {\n-      leaf(x) { return f(x); }\n-      seq(ads, span) {\n-        alt option_flatten_map(|x| a_d_map(x, f), *ads) {\n-          none { return none; }\n-          some(ts) { return some(seq(@ts, span)); }\n-        }\n+      leaf(x) => return f(x),\n+      seq(ads, span) => alt option_flatten_map(|x| a_d_map(x, f), *ads) {\n+        none => return none,\n+        some(ts) => return some(seq(@ts, span))\n       }\n     }\n }\n \n fn compose_sels(s1: selector, s2: selector) -> selector {\n     fn scomp(s1: selector, s2: selector, m: matchable) -> match_result {\n         return alt s1(m) {\n-              none { none }\n-              some(matches) { a_d_map(matches, s2) }\n+              none => none,\n+              some(matches) => a_d_map(matches, s2)\n             }\n     }\n     return { |x| scomp(s1, s2, x) };\n@@ -167,13 +156,13 @@ fn use_selectors_to_bind(b: binders, e: @expr) -> option<bindings> {\n     let res = box_str_hash::<arb_depth<matchable>>();\n     //need to do this first, to check vec lengths.\n     for b.literal_ast_matchers.each |sel| {\n-        alt sel(match_expr(e)) { none { return none; } _ { } }\n+        alt sel(match_expr(e)) { none => return none, _ => () }\n     }\n     let mut never_mind: bool = false;\n     for b.real_binders.each |key, val| {\n         alt val(match_expr(e)) {\n-          none { never_mind = true; }\n-          some(mtc) { res.insert(key, mtc); }\n+          none => never_mind = true,\n+          some(mtc) => { res.insert(key, mtc); }\n         }\n     };\n     //HACK: `ret` doesn't work in `for each`\n@@ -221,8 +210,8 @@ fn follow(m: arb_depth<matchable>, idx_path: @mut ~[uint]) ->\n     let mut res: arb_depth<matchable> = m;\n     for vec::each(*idx_path) |idx| {\n         res = alt res {\n-          leaf(_) { return res;/* end of the line */ }\n-          seq(new_ms, _) { new_ms[idx] }\n+          leaf(_) => return res,/* end of the line */\n+          seq(new_ms, _) => new_ms[idx]\n         }\n     }\n     return res;\n@@ -231,15 +220,15 @@ fn follow(m: arb_depth<matchable>, idx_path: @mut ~[uint]) ->\n fn follow_for_trans(cx: ext_ctxt, mmaybe: option<arb_depth<matchable>>,\n                     idx_path: @mut ~[uint]) -> option<matchable> {\n     alt mmaybe {\n-      none { return none }\n-      some(m) {\n+      none => return none,\n+      some(m) => {\n         return alt follow(m, idx_path) {\n-              seq(_, sp) {\n+              seq(_, sp) => {\n                 cx.span_fatal(sp,\n                               ~\"syntax matched under ... but not \" +\n                                   ~\"used that way.\")\n               }\n-              leaf(m) { return some(m) }\n+              leaf(m) => return some(m)\n             }\n       }\n     }\n@@ -270,24 +259,24 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                     recur: fn@(&&@expr) -> @expr,\n                     exprs: ~[@expr]) -> ~[@expr] {\n     alt elts_to_ell(cx, exprs) {\n-      {pre: pre, rep: repeat_me_maybe, post: post} {\n+      {pre: pre, rep: repeat_me_maybe, post: post} => {\n         let mut res = vec::map(pre, recur);\n         alt repeat_me_maybe {\n-          none { }\n-          some(repeat_me) {\n+          none => (),\n+          some(repeat_me) => {\n             let mut repeat: option<{rep_count: uint, name: ident}> = none;\n             /* we need to walk over all the free vars in lockstep, except for\n             the leaves, which are just duplicated */\n             do free_vars(b, repeat_me) |fv| {\n                 let cur_pos = follow(b.get(fv), idx_path);\n                 alt cur_pos {\n-                  leaf(_) { }\n-                  seq(ms, _) {\n+                  leaf(_) => (),\n+                  seq(ms, _) => {\n                     alt repeat {\n-                      none {\n+                      none => {\n                         repeat = some({rep_count: vec::len(*ms), name: fv});\n                       }\n-                      some({rep_count: old_len, name: old_name}) {\n+                      some({rep_count: old_len, name: old_name}) => {\n                         let len = vec::len(*ms);\n                         if old_len != len {\n                             let msg =\n@@ -302,12 +291,12 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                 }\n             };\n             alt repeat {\n-              none {\n+              none => {\n                 cx.span_fatal(repeat_me.span,\n                               ~\"'...' surrounds an expression without any\" +\n                                   ~\" repeating syntax variables\");\n               }\n-              some({rep_count: rc, _}) {\n+              some({rep_count: rc, _}) => {\n                 /* Whew, we now know how how many times to repeat */\n                 let mut idx: uint = 0u;\n                 while idx < rc {\n@@ -332,9 +321,9 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                     &&i: ident, _fld: ast_fold) -> ident {\n     return alt follow_for_trans(cx, b.find(i), idx_path) {\n-          some(match_ident(a_id)) { a_id.node }\n-          some(m) { match_error(cx, m, ~\"an identifier\") }\n-          none { i }\n+          some(match_ident(a_id)) => a_id.node,\n+          some(m) => match_error(cx, m, ~\"an identifier\"),\n+          none => i\n         }\n }\n \n@@ -344,13 +333,13 @@ fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n     // Don't substitute into qualified names.\n     if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { return p; }\n     alt follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n-      some(match_ident(id)) {\n+      some(match_ident(id)) => {\n         {span: id.span, global: false, idents: ~[id.node],\n          rp: none, types: ~[]}\n       }\n-      some(match_path(a_pth)) { *a_pth }\n-      some(m) { match_error(cx, m, ~\"a path\") }\n-      none { p }\n+      some(match_path(a_pth)) => *a_pth,\n+      some(m) => match_error(cx, m, ~\"a path\"),\n+      none => p\n     }\n }\n \n@@ -361,26 +350,26 @@ fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n     -> (ast::expr_, span)\n {\n     return alt e {\n-          expr_path(p) {\n+          expr_path(p) => {\n             // Don't substitute into qualified names.\n             if vec::len(p.types) > 0u || vec::len(p.idents) != 1u {\n                 (e, s);\n             }\n             alt follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n-              some(match_ident(id)) {\n+              some(match_ident(id)) => {\n                 (expr_path(@{span: id.span,\n                              global: false,\n                              idents: ~[id.node],\n                              rp: none,\n                              types: ~[]}), id.span)\n               }\n-              some(match_path(a_pth)) { (expr_path(a_pth), s) }\n-              some(match_expr(a_exp)) { (a_exp.node, a_exp.span) }\n-              some(m) { match_error(cx, m, ~\"an expression\") }\n-              none { orig(e, s, fld) }\n+              some(match_path(a_pth)) => (expr_path(a_pth), s),\n+              some(match_expr(a_exp)) => (a_exp.node, a_exp.span),\n+              some(m) => match_error(cx, m, ~\"an expression\"),\n+              none => orig(e, s, fld)\n             }\n           }\n-          _ { orig(e, s, fld) }\n+          _ => orig(e, s, fld)\n         }\n }\n \n@@ -390,19 +379,19 @@ fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n     -> (ast::ty_, span)\n {\n     return alt t {\n-          ast::ty_path(pth, _) {\n+          ast::ty_path(pth, _) => {\n             alt path_to_ident(pth) {\n-              some(id) {\n+              some(id) => {\n                 alt follow_for_trans(cx, b.find(id), idx_path) {\n-                  some(match_ty(ty)) { (ty.node, ty.span) }\n-                  some(m) { match_error(cx, m, ~\"a type\") }\n-                  none { orig(t, s, fld) }\n+                  some(match_ty(ty)) => (ty.node, ty.span),\n+                  some(m) => match_error(cx, m, ~\"a type\"),\n+                  none => orig(t, s, fld)\n                 }\n               }\n-              none { orig(t, s, fld) }\n+              none => orig(t, s, fld)\n             }\n           }\n-          _ { orig(t, s, fld) }\n+          _ => orig(t, s, fld)\n         }\n }\n \n@@ -416,22 +405,16 @@ fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n     -> (blk_, span)\n {\n     return alt block_to_ident(blk) {\n-          some(id) {\n+          some(id) => {\n             alt follow_for_trans(cx, b.find(id), idx_path) {\n-              some(match_block(new_blk)) { (new_blk.node, new_blk.span) }\n-\n-\n-\n-\n+              some(match_block(new_blk)) => (new_blk.node, new_blk.span),\n \n               // possibly allow promotion of ident/path/expr to blocks?\n-              some(m) {\n-                match_error(cx, m, ~\"a block\")\n-              }\n-              none { orig(blk, s, fld) }\n+              some(m) => match_error(cx, m, ~\"a block\"),\n+              none => orig(blk, s, fld)\n             }\n           }\n-          none { orig(blk, s, fld) }\n+          none => orig(blk, s, fld)\n         }\n }\n \n@@ -442,12 +425,12 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n \n     //it might be possible to traverse only exprs, not matchables\n     alt m {\n-      match_expr(e) {\n+      match_expr(e) => {\n         alt e.node {\n-          expr_path(p_pth) { p_t_s_r_path(cx, p_pth, s, b); }\n-          expr_vec(p_elts, _) {\n+          expr_path(p_pth) => p_t_s_r_path(cx, p_pth, s, b),\n+          expr_vec(p_elts, _) => {\n             alt elts_to_ell(cx, p_elts) {\n-              {pre: pre, rep: some(repeat_me), post: post} {\n+              {pre: pre, rep: some(repeat_me), post: post} => {\n                 p_t_s_r_length(cx, vec::len(pre) + vec::len(post), true, s,\n                                b);\n                 if vec::len(pre) > 0u {\n@@ -460,7 +443,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n                                    ~\"matching after `...` not yet supported\");\n                 }\n               }\n-              {pre: pre, rep: none, post: post} {\n+              {pre: pre, rep: none, post: post} => {\n                 if post != ~[] {\n                     cx.bug(~\"elts_to_ell provided an invalid result\");\n                 }\n@@ -470,96 +453,96 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n             }\n           }\n           /* FIXME (#2251): handle embedded types and blocks, at least */\n-          expr_mac(mac) {\n+          expr_mac(mac) => {\n             p_t_s_r_mac(cx, mac, s, b);\n           }\n-          _ {\n+          _ => {\n             fn select(cx: ext_ctxt, m: matchable, pat: @expr) ->\n                match_result {\n                 return alt m {\n-                      match_expr(e) {\n+                      match_expr(e) => {\n                         if e == pat { some(leaf(match_exact)) } else { none }\n                       }\n-                      _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n+                      _ => cx.bug(~\"broken traversal in p_t_s_r\")\n                     }\n             }\n             b.literal_ast_matchers.push(|x| select(cx, x, e));\n           }\n         }\n       }\n-      _ {\n-          cx.bug(~\"undocumented invariant in p_t_s_rec\");\n-      }\n+      _ => cx.bug(~\"undocumented invariant in p_t_s_rec\")\n     }\n }\n \n \n /* make a match more precise */\n fn specialize_match(m: matchable) -> matchable {\n     return alt m {\n-          match_expr(e) {\n+          match_expr(e) => {\n             alt e.node {\n-              expr_path(pth) {\n+              expr_path(pth) => {\n                 alt path_to_ident(pth) {\n-                  some(id) { match_ident(respan(pth.span, id)) }\n-                  none { match_path(pth) }\n+                  some(id) => match_ident(respan(pth.span, id)),\n+                  none => match_path(pth)\n                 }\n               }\n-              _ { m }\n+              _ => m\n             }\n           }\n-          _ { m }\n+          _ => m\n         }\n }\n \n /* pattern_to_selectors helper functions */\n fn p_t_s_r_path(cx: ext_ctxt, p: @path, s: selector, b: binders) {\n     alt path_to_ident(p) {\n-      some(p_id) {\n+      some(p_id) => {\n         fn select(cx: ext_ctxt, m: matchable) -> match_result {\n             return alt m {\n-                  match_expr(e) { some(leaf(specialize_match(m))) }\n-                  _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n+                  match_expr(e) => some(leaf(specialize_match(m))),\n+                  _ => cx.bug(~\"broken traversal in p_t_s_r\")\n                 }\n         }\n         if b.real_binders.contains_key(p_id) {\n             cx.span_fatal(p.span, ~\"duplicate binding identifier\");\n         }\n         b.real_binders.insert(p_id, compose_sels(s, |x| select(cx, x)));\n       }\n-      none { }\n+      none => ()\n     }\n }\n \n fn block_to_ident(blk: blk_) -> option<ident> {\n     if vec::len(blk.stmts) != 0u { return none; }\n     return alt blk.expr {\n-          some(expr) {\n-            alt expr.node { expr_path(pth) { path_to_ident(pth) } _ { none } }\n+          some(expr) => alt expr.node {\n+            expr_path(pth) => path_to_ident(pth),\n+            _ => none\n           }\n-          none { none }\n+          none => none\n         }\n }\n \n fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, _s: selector, _b: binders) {\n     fn select_pt_1(cx: ext_ctxt, m: matchable,\n                    fn_m: fn(ast::mac) -> match_result) -> match_result {\n         return alt m {\n-              match_expr(e) {\n-                alt e.node { expr_mac(mac) { fn_m(mac) } _ { none } }\n+              match_expr(e) => alt e.node {\n+                expr_mac(mac) => fn_m(mac),\n+                _ => none\n               }\n-              _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n+              _ => cx.bug(~\"broken traversal in p_t_s_r\")\n             }\n     }\n     fn no_des(cx: ext_ctxt, sp: span, syn: ~str) -> ! {\n         cx.span_fatal(sp, ~\"destructuring \" + syn + ~\" is not yet supported\");\n     }\n     alt mac.node {\n-      ast::mac_ellipsis { cx.span_fatal(mac.span, ~\"misused `...`\"); }\n-      ast::mac_invoc(_, _, _) { no_des(cx, mac.span, ~\"macro calls\"); }\n-      ast::mac_invoc_tt(_, _) { no_des(cx, mac.span, ~\"macro calls\"); }\n-      ast::mac_aq(_,_) { no_des(cx, mac.span, ~\"antiquotes\"); }\n-      ast::mac_var(_) { no_des(cx, mac.span, ~\"antiquote variables\"); }\n+      ast::mac_ellipsis => cx.span_fatal(mac.span, ~\"misused `...`\"),\n+      ast::mac_invoc(_, _, _) => no_des(cx, mac.span, ~\"macro calls\"),\n+      ast::mac_invoc_tt(_, _) => no_des(cx, mac.span, ~\"macro calls\"),\n+      ast::mac_aq(_,_) => no_des(cx, mac.span, ~\"antiquotes\"),\n+      ast::mac_var(_) => no_des(cx, mac.span, ~\"antiquote variables\")\n     }\n }\n \n@@ -568,9 +551,9 @@ fn p_t_s_r_ellipses(cx: ext_ctxt, repeat_me: @expr, offset: uint, s: selector,\n     fn select(cx: ext_ctxt, repeat_me: @expr, offset: uint, m: matchable) ->\n        match_result {\n         return alt m {\n-              match_expr(e) {\n+              match_expr(e) => {\n                 alt e.node {\n-                  expr_vec(arg_elts, _) {\n+                  expr_vec(arg_elts, _) => {\n                     let mut elts = ~[];\n                     let mut idx = offset;\n                     while idx < vec::len(arg_elts) {\n@@ -582,10 +565,10 @@ fn p_t_s_r_ellipses(cx: ext_ctxt, repeat_me: @expr, offset: uint, s: selector,\n                     // error we want to report is one in the macro def\n                     some(seq(@elts, repeat_me.span))\n                   }\n-                  _ { none }\n+                  _ => none\n                 }\n               }\n-              _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n+              _ => cx.bug(~\"broken traversal in p_t_s_r\")\n             }\n     }\n     p_t_s_rec(cx, match_expr(repeat_me),\n@@ -598,18 +581,18 @@ fn p_t_s_r_length(cx: ext_ctxt, len: uint, at_least: bool, s: selector,\n     fn len_select(_cx: ext_ctxt, m: matchable, at_least: bool, len: uint) ->\n        match_result {\n         return alt m {\n-              match_expr(e) {\n+              match_expr(e) => {\n                 alt e.node {\n-                  expr_vec(arg_elts, _) {\n+                  expr_vec(arg_elts, _) => {\n                     let actual_len = vec::len(arg_elts);\n                     if at_least && actual_len >= len || actual_len == len {\n                         some(leaf(match_exact))\n                     } else { none }\n                   }\n-                  _ { none }\n+                  _ => none\n                 }\n               }\n-              _ { none }\n+              _ => none\n             }\n     }\n     b.literal_ast_matchers.push(\n@@ -622,15 +605,15 @@ fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: ~[@expr], _repeat_after: bool,\n     while idx < vec::len(elts) {\n         fn select(cx: ext_ctxt, m: matchable, idx: uint) -> match_result {\n             return alt m {\n-                  match_expr(e) {\n+                  match_expr(e) => {\n                     alt e.node {\n-                      expr_vec(arg_elts, _) {\n+                      expr_vec(arg_elts, _) => {\n                         some(leaf(match_expr(arg_elts[idx])))\n                       }\n-                      _ { none }\n+                      _ => none\n                     }\n                   }\n-                  _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n+                  _ => cx.bug(~\"broken traversal in p_t_s_r\")\n                 }\n         }\n         p_t_s_rec(cx, match_expr(elts[idx]),\n@@ -647,7 +630,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n     let mut clauses: ~[@clause] = ~[];\n     for args.each |arg| {\n         alt arg.node {\n-          expr_vec(elts, mutbl) {\n+          expr_vec(elts, mutbl) => {\n             if vec::len(elts) != 2u {\n                 cx.span_fatal((*arg).span,\n                               ~\"extension clause must consist of ~[\" +\n@@ -656,31 +639,25 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n \n \n             alt elts[0u].node {\n-              expr_mac(mac) {\n+              expr_mac(mac) => {\n                 alt mac.node {\n-                  mac_invoc(pth, invoc_arg, body) {\n+                  mac_invoc(pth, invoc_arg, body) => {\n                     alt path_to_ident(pth) {\n-                      some(id) {\n-                        alt macro_name {\n-                          none { macro_name = some(id); }\n-                          some(other_id) {\n-                            if id != other_id {\n-                                cx.span_fatal(pth.span,\n-                                              ~\"macro name must be \" +\n-                                                  ~\"consistent\");\n-                            }\n-                          }\n+                      some(id) => alt macro_name {\n+                        none => macro_name = some(id),\n+                        some(other_id) => if id != other_id {\n+                            cx.span_fatal(pth.span,\n+                                          ~\"macro name must be \" +\n+                                          ~\"consistent\");\n                         }\n                       }\n-                      none {\n-                        cx.span_fatal(pth.span,\n-                                      ~\"macro name must not be a path\");\n-                      }\n+                      none => cx.span_fatal(pth.span,\n+                                            ~\"macro name must not be a path\")\n                     }\n                     let arg = alt invoc_arg {\n-                      some(arg) { arg }\n-                      none { cx.span_fatal(mac.span,\n-                                           ~\"macro must have arguments\")}\n+                      some(arg) => arg,\n+                      none => cx.span_fatal(mac.span,\n+                                           ~\"macro must have arguments\")\n                     };\n                     vec::push(clauses,\n                               @{params: pattern_to_selectors(cx, arg),\n@@ -689,20 +666,20 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                     // FIXME (#2251): check duplicates (or just simplify\n                     // the macro arg situation)\n                   }\n-                  _ {\n+                  _ => {\n                       cx.span_bug(mac.span, ~\"undocumented invariant in \\\n                          add_extension\");\n                   }\n                 }\n               }\n-              _ {\n+              _ => {\n                 cx.span_fatal(elts[0u].span,\n                               ~\"extension clause must\" +\n                                   ~\" start with a macro invocation.\");\n               }\n             }\n           }\n-          _ {\n+          _ => {\n             cx.span_fatal((*arg).span,\n                           ~\"extension must be ~[clause, \" + ~\" ...]\");\n           }\n@@ -713,25 +690,23 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n \n     return {ident:\n              alt macro_name {\n-               some(id) { id }\n-               none {\n-                 cx.span_fatal(sp, ~\"macro definition must have \" +\n-                               ~\"at least one clause\")\n-               }\n+               some(id) => id,\n+               none => cx.span_fatal(sp, ~\"macro definition must have \" +\n+                                     ~\"at least one clause\")\n              },\n          ext: normal({expander: ext, span: some(option::get(arg).span)})};\n \n     fn generic_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                          _body: ast::mac_body,\n                          clauses: ~[@clause]) -> @expr {\n         let arg = alt arg {\n-          some(arg) { arg }\n-          none { cx.span_fatal(sp, ~\"macro must have arguments\")}\n+          some(arg) => arg,\n+          none => cx.span_fatal(sp, ~\"macro must have arguments\")\n         };\n         for clauses.each |c| {\n             alt use_selectors_to_bind(c.params, arg) {\n-              some(bindings) { return transcribe(cx, bindings, c.body); }\n-              none { again; }\n+              some(bindings) => return transcribe(cx, bindings, c.body),\n+              none => again\n             }\n         }\n         cx.span_fatal(sp, ~\"no clauses match macro invocation\");"}, {"sha": "c55f1e67be23d1b793c7b0aa70da3775667f7ae7", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -71,8 +71,8 @@ fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n \n     let res = io::read_whole_file_str(res_rel_file(cx, sp, file));\n     alt res {\n-      result::ok(_) { /* Continue. */ }\n-      result::err(e) {\n+      result::ok(_) => { /* Continue. */ }\n+      result::err(e) => {\n         cx.parse_sess().span_diagnostic.handler().fatal(e);\n       }\n     }\n@@ -87,13 +87,13 @@ fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     let file = expr_to_str(cx, args[0], ~\"#include_bin requires a string\");\n \n     alt io::read_whole_file(res_rel_file(cx, sp, file)) {\n-      result::ok(src) {\n+      result::ok(src) => {\n         let u8_exprs = vec::map(src, |char: u8| {\n             mk_u8(cx, sp, char)\n         });\n         return mk_uniq_vec_e(cx, sp, u8_exprs);\n       }\n-      result::err(e) {\n+      result::err(e) => {\n         cx.parse_sess().span_diagnostic.handler().fatal(e)\n       }\n     }"}, {"sha": "6a801f33aa61e7e1ab6f5278dd0473af98f138aa", "filename": "src/libsyntax/ext/tt/earley_parser.rs", "status": "modified", "additions": 43, "deletions": 44, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -32,8 +32,8 @@ enum matcher_pos_up { /* to break a circularity */\n \n fn is_some(&&mpu: matcher_pos_up) -> bool {\n     alt mpu {\n-      matcher_pos_up(none) { false }\n-      _ { true }\n+      matcher_pos_up(none) => false,\n+      _ => true\n     }\n }\n \n@@ -49,17 +49,17 @@ type matcher_pos = ~{\n \n fn copy_up(&& mpu: matcher_pos_up) -> matcher_pos {\n     alt mpu {\n-      matcher_pos_up(some(mp)) { copy mp }\n-      _ { fail }\n+      matcher_pos_up(some(mp)) => copy mp,\n+      _ => fail\n     }\n }\n \n fn count_names(ms: &[matcher]) -> uint {\n     vec::foldl(0u, ms, |ct, m| {\n         ct + alt m.node {\n-          match_tok(_) { 0u }\n-          match_seq(more_ms, _, _, _, _) { count_names(more_ms) }\n-          match_nonterminal(_,_,_) { 1u }\n+          match_tok(_) => 0u,\n+          match_seq(more_ms, _, _, _, _) => count_names(more_ms),\n+          match_nonterminal(_,_,_) => 1u\n         }})\n }\n \n@@ -69,11 +69,11 @@ fn initial_matcher_pos(ms: ~[matcher], sep: option<token>, lo: uint)\n     let mut match_idx_hi = 0u;\n     for ms.each() |elt| {\n         alt elt.node {\n-          match_tok(_) {}\n-          match_seq(_,_,_,_,hi) {\n+          match_tok(_) => (),\n+          match_seq(_,_,_,_,hi) => {\n             match_idx_hi = hi;       // it is monotonic...\n           }\n-          match_nonterminal(_,_,pos) {\n+          match_nonterminal(_,_,pos) => {\n             match_idx_hi = pos+1u;  // ...so latest is highest\n           }\n         }\n@@ -114,11 +114,11 @@ fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@named_match])\n     fn n_rec(p_s: parse_sess, m: matcher, res: ~[@named_match],\n              ret_val: hashmap<ident, @named_match>) {\n         alt m {\n-          {node: match_tok(_), span: _} { }\n-          {node: match_seq(more_ms, _, _, _, _), span: _} {\n+          {node: match_tok(_), span: _} => (),\n+          {node: match_seq(more_ms, _, _, _, _), span: _} => {\n             for more_ms.each() |next_m| { n_rec(p_s, next_m, res, ret_val) };\n           }\n-          {node: match_nonterminal(bind_name, _, idx), span: sp} {\n+          {node: match_nonterminal(bind_name, _, idx), span: sp} => {\n             if ret_val.contains_key(bind_name) {\n                 p_s.span_diagnostic.span_fatal(sp, ~\"Duplicated bind name: \"\n                                                + *bind_name)\n@@ -140,10 +140,8 @@ enum parse_result {\n fn parse_or_else(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader,\n                  ms: ~[matcher]) -> hashmap<ident, @named_match> {\n     alt parse(sess, cfg, rdr, ms) {\n-      success(m) { m }\n-      failure(sp, str) {\n-        sess.span_diagnostic.span_fatal(sp, str);\n-      }\n+      success(m) => m,\n+      failure(sp, str) => sess.span_diagnostic.span_fatal(sp, str)\n     }\n }\n \n@@ -205,14 +203,14 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n \n                     // the *_t vars are workarounds for the lack of unary move\n                     alt copy ei.sep {\n-                      some(t) if idx == len { // we need a separator\n+                      some(t) if idx == len => { // we need a separator\n                         if tok == t { //pass the separator\n                             let ei_t <- ei;\n                             ei_t.idx += 1u;\n                             vec::push(next_eis, ei_t);\n                         }\n                       }\n-                      _ { // we don't need a separator\n+                      _ => { // we don't need a separator\n                         let ei_t <- ei;\n                         ei_t.idx = 0u;\n                         vec::push(cur_eis, ei_t);\n@@ -225,7 +223,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                 alt copy ei.elts[idx].node {\n                   /* need to descend into sequence */\n                   match_seq(matchers, sep, zero_ok,\n-                            match_idx_lo, match_idx_hi){\n+                            match_idx_lo, match_idx_hi) => {\n                     if zero_ok {\n                         let new_ei = copy ei;\n                         new_ei.idx += 1u;\n@@ -248,8 +246,8 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                         sp_lo: sp.lo\n                     });\n                   }\n-                  match_nonterminal(_,_,_) { vec::push(bb_eis, ei) }\n-                  match_tok(t) {\n+                  match_nonterminal(_,_,_) => { vec::push(bb_eis, ei) }\n+                  match_tok(t) => {\n                     let ei_t <- ei;\n                     if t == tok { ei_t.idx += 1u; vec::push(next_eis, ei_t)}\n                   }\n@@ -273,10 +271,11 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                 || bb_eis.len() > 1u {\n                 let nts = str::connect(vec::map(bb_eis, |ei| {\n                     alt ei.elts[ei.idx].node {\n-                      match_nonterminal(bind,name,_) {\n+                      match_nonterminal(bind,name,_) => {\n                         fmt!{\"%s ('%s')\", *name, *bind}\n                       }\n-                      _ { fail; } } }), ~\" or \");\n+                      _ => fail\n+                    } }), ~\" or \");\n                 return failure(sp, fmt!{\n                     \"Local ambiguity: multiple parsing options: \\\n                      built-in NTs %s or %u other options.\",\n@@ -295,12 +294,12 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n \n                 let ei = vec::pop(bb_eis);\n                 alt ei.elts[ei.idx].node {\n-                  match_nonterminal(_, name, idx) {\n+                  match_nonterminal(_, name, idx) => {\n                     ei.matches[idx].push(@matched_nonterminal(\n                         parse_nt(rust_parser, *name)));\n                     ei.idx += 1u;\n                   }\n-                  _ { fail; }\n+                  _ => fail\n                 }\n                 vec::push(cur_eis,ei);\n \n@@ -320,30 +319,30 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n \n fn parse_nt(p: parser, name: ~str) -> nonterminal {\n     alt name {\n-      ~\"item\" { alt p.parse_item(~[]) {\n-        some(i) { token::nt_item(i) }\n-        none { p.fatal(~\"expected an item keyword\") }\n-      }}\n-      ~\"block\" { token::nt_block(p.parse_block()) }\n-      ~\"stmt\" { token::nt_stmt(p.parse_stmt(~[])) }\n-      ~\"pat\" { token::nt_pat(p.parse_pat(true)) }\n-      ~\"expr\" { token::nt_expr(p.parse_expr()) }\n-      ~\"ty\" { token::nt_ty(p.parse_ty(false /* no need to disambiguate*/)) }\n+      ~\"item\" => alt p.parse_item(~[]) {\n+        some(i) => token::nt_item(i),\n+        none => p.fatal(~\"expected an item keyword\")\n+      }\n+      ~\"block\" => token::nt_block(p.parse_block()),\n+      ~\"stmt\" => token::nt_stmt(p.parse_stmt(~[])),\n+      ~\"pat\" => token::nt_pat(p.parse_pat(true)),\n+      ~\"expr\" => token::nt_expr(p.parse_expr()),\n+      ~\"ty\" => token::nt_ty(p.parse_ty(false /* no need to disambiguate*/)),\n       // this could be handled like a token, since it is one\n-      ~\"ident\" { alt copy p.token {\n-          token::IDENT(sn,b) { p.bump(); token::nt_ident(sn,b) }\n-          _ { p.fatal(~\"expected ident, found \"\n-                      + token::to_str(*p.reader.interner(), copy p.token)) }\n-      } }\n-      ~\"path\" { token::nt_path(p.parse_path_with_tps(false)) }\n-      ~\"tt\" {\n+      ~\"ident\" => alt copy p.token {\n+        token::IDENT(sn,b) => { p.bump(); token::nt_ident(sn,b) }\n+        _ => p.fatal(~\"expected ident, found \"\n+                     + token::to_str(*p.reader.interner(), copy p.token))\n+      }\n+      ~\"path\" => token::nt_path(p.parse_path_with_tps(false)),\n+      ~\"tt\" => {\n         p.quote_depth += 1u; //but in theory, non-quoted tts might be useful\n         let res = token::nt_tt(@p.parse_token_tree());\n         p.quote_depth -= 1u;\n         res\n       }\n-      ~\"matchers\" { token::nt_matchers(p.parse_matchers()) }\n-      _ { p.fatal(~\"Unsupported builtin nonterminal parser: \" + name)}\n+      ~\"matchers\" => token::nt_matchers(p.parse_matchers()),\n+      _ => p.fatal(~\"Unsupported builtin nonterminal parser: \" + name)\n     }\n }\n "}, {"sha": "7655d7c970c868f6ebe85d3a37fb367bf2bc2a7d", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -38,12 +38,12 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n \n     // Extract the arguments:\n     let lhses:~[@named_match] = alt argument_map.get(@~\"lhs\") {\n-      @matched_seq(s, sp) { s }\n-      _ { cx.span_bug(sp, ~\"wrong-structured lhs\") }\n+      @matched_seq(s, sp) => s,\n+      _ => cx.span_bug(sp, ~\"wrong-structured lhs\")\n     };\n     let rhses:~[@named_match] = alt argument_map.get(@~\"rhs\") {\n-      @matched_seq(s, sp) { s }\n-      _ { cx.span_bug(sp, ~\"wrong-structured rhs\") }\n+      @matched_seq(s, sp) => s,\n+      _ => cx.span_bug(sp, ~\"wrong-structured rhs\")\n     };\n \n     // Given `lhses` and `rhses`, this is the new macro we create\n@@ -59,14 +59,14 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n \n         for lhses.eachi() |i, lhs| { // try each arm's matchers\n             alt lhs {\n-              @matched_nonterminal(nt_matchers(mtcs)) {\n+              @matched_nonterminal(nt_matchers(mtcs)) => {\n                 // `none` is because we're not interpolating\n                 let arg_rdr = new_tt_reader(s_d, itr, none, arg) as reader;\n                 alt parse(cx.parse_sess(), cx.cfg(), arg_rdr, mtcs) {\n-                  success(named_matches) {\n+                  success(named_matches) => {\n                     let rhs = alt rhses[i] { // okay, what's your transcriber?\n-                      @matched_nonterminal(nt_tt(@tt)) { tt }\n-                      _ { cx.span_bug(sp, ~\"bad thing in rhs\") }\n+                      @matched_nonterminal(nt_tt(@tt)) => tt,\n+                      _ => cx.span_bug(sp, ~\"bad thing in rhs\")\n                     };\n                     // rhs has holes ( `$id` and `$(...)` that need filled)\n                     let trncbr = new_tt_reader(s_d, itr, some(named_matches),\n@@ -75,14 +75,13 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                                    trncbr as reader, SOURCE_FILE);\n                     return mr_expr(p.parse_expr());\n                   }\n-                  failure(sp, msg) {\n-                    if sp.lo >= best_fail_spot.lo {\n-                        best_fail_spot = sp; best_fail_msg = msg;\n-                    }\n+                  failure(sp, msg) => if sp.lo >= best_fail_spot.lo {\n+                    best_fail_spot = sp;\n+                    best_fail_msg = msg;\n                   }\n                 }\n               }\n-              _ { cx.bug(~\"non-matcher found in parsed lhses\"); }\n+              _ => cx.bug(~\"non-matcher found in parsed lhses\")\n             }\n         }\n         cx.span_fatal(best_fail_spot, best_fail_msg);"}, {"sha": "c704fd351ecc6f5521f0c4aba28148d89259ec76", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -47,8 +47,8 @@ fn new_tt_reader(sp_diag: span_handler, itr: @interner<@~str>,\n               mut cur: @{readme: src, mut idx: 0u, dotdotdoted: false,\n                          sep: none, up: tt_frame_up(option::none)},\n               interpolations: alt interp { /* just a convienience */\n-                none { std::map::box_str_hash::<@named_match>() }\n-                some(x) { x }\n+                none => std::map::box_str_hash::<@named_match>(),\n+                some(x) => x\n               },\n               mut repeat_idx: ~[mut], mut repeat_len: ~[],\n               /* dummy values, never read: */\n@@ -62,10 +62,10 @@ fn new_tt_reader(sp_diag: span_handler, itr: @interner<@~str>,\n pure fn dup_tt_frame(&&f: tt_frame) -> tt_frame {\n     @{readme: f.readme, mut idx: f.idx, dotdotdoted: f.dotdotdoted,\n       sep: f.sep, up: alt f.up {\n-        tt_frame_up(some(up_frame)) {\n+        tt_frame_up(some(up_frame)) => {\n           tt_frame_up(some(dup_tt_frame(up_frame)))\n         }\n-        tt_frame_up(none) { tt_frame_up(none) }\n+        tt_frame_up(none) => tt_frame_up(none)\n       }\n      }\n }\n@@ -83,11 +83,11 @@ pure fn lookup_cur_matched_by_matched(r: tt_reader,\n                                       start: @named_match) -> @named_match {\n     pure fn red(&&ad: @named_match, &&idx: uint) -> @named_match {\n         alt *ad {\n-          matched_nonterminal(_) {\n+          matched_nonterminal(_) => {\n             // end of the line; duplicate henceforth\n             ad\n           }\n-          matched_seq(ads, _) { ads[idx] }\n+          matched_seq(ads, _) => ads[idx]\n         }\n     }\n     vec::foldl(start, r.repeat_idx, red)\n@@ -103,33 +103,29 @@ enum lis {\n fn lockstep_iter_size(&&t: token_tree, &&r: tt_reader) -> lis {\n     fn lis_merge(lhs: lis, rhs: lis) -> lis {\n         alt lhs {\n-          lis_unconstrained { rhs }\n-          lis_contradiction(_) { lhs }\n-          lis_constraint(l_len, l_id) {\n-            alt rhs {\n-              lis_unconstrained { lhs }\n-              lis_contradiction(_) { rhs }\n-              lis_constraint(r_len, _) if l_len == r_len { lhs }\n-              lis_constraint(r_len, r_id) {\n+          lis_unconstrained => rhs,\n+          lis_contradiction(_) => lhs,\n+          lis_constraint(l_len, l_id) => alt rhs {\n+            lis_unconstrained => lhs,\n+            lis_contradiction(_) => rhs,\n+            lis_constraint(r_len, _) if l_len == r_len => lhs,\n+            lis_constraint(r_len, r_id) => {\n                 lis_contradiction(fmt!{\"Inconsistent lockstep iteration: \\\n-                                        '%s' has %u items, but '%s' has %u\",\n-                                       *l_id, l_len, *r_id, r_len})\n-              }\n+                                       '%s' has %u items, but '%s' has %u\",\n+                                        *l_id, l_len, *r_id, r_len})\n             }\n           }\n         }\n     }\n     alt t {\n-      tt_delim(tts) | tt_seq(_, tts, _, _) {\n+      tt_delim(tts) | tt_seq(_, tts, _, _) => {\n         vec::foldl(lis_unconstrained, tts, {|lis, tt|\n             lis_merge(lis, lockstep_iter_size(tt, r)) })\n       }\n-      tt_tok(*) { lis_unconstrained }\n-      tt_nonterminal(_, name) {\n-        alt *lookup_cur_matched(r, name) {\n-          matched_nonterminal(_) { lis_unconstrained }\n-          matched_seq(ads, _) { lis_constraint(ads.len(), name) }\n-        }\n+      tt_tok(*) => lis_unconstrained,\n+      tt_nonterminal(_, name) => alt *lookup_cur_matched(r, name) {\n+        matched_nonterminal(_) => lis_unconstrained,\n+        matched_seq(ads, _) => lis_constraint(ads.len(), name)\n       }\n     }\n }\n@@ -143,11 +139,11 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n             || r.repeat_idx.last() == r.repeat_len.last() - 1 {\n \n             alt r.cur.up {\n-              tt_frame_up(none) {\n+              tt_frame_up(none) => {\n                 r.cur_tok = EOF;\n                 return ret_val;\n               }\n-              tt_frame_up(some(tt_f)) {\n+              tt_frame_up(some(tt_f)) => {\n                 if r.cur.dotdotdoted {\n                     vec::pop(r.repeat_idx); vec::pop(r.repeat_len);\n                 }\n@@ -161,40 +157,40 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n             r.cur.idx = 0u;\n             r.repeat_idx[r.repeat_idx.len() - 1u] += 1u;\n             alt r.cur.sep {\n-              some(tk) {\n+              some(tk) => {\n                 r.cur_tok = tk; /* repeat same span, I guess */\n                 return ret_val;\n               }\n-              none {}\n+              none => ()\n             }\n         }\n     }\n     loop { /* because it's easiest, this handles `tt_delim` not starting\n     with a `tt_tok`, even though it won't happen */\n         alt r.cur.readme[r.cur.idx] {\n-          tt_delim(tts) {\n+          tt_delim(tts) => {\n             r.cur = @{readme: tts, mut idx: 0u, dotdotdoted: false,\n                       sep: none, up: tt_frame_up(option::some(r.cur)) };\n             // if this could be 0-length, we'd need to potentially recur here\n           }\n-          tt_tok(sp, tok) {\n+          tt_tok(sp, tok) => {\n             r.cur_span = sp; r.cur_tok = tok;\n             r.cur.idx += 1u;\n             return ret_val;\n           }\n-          tt_seq(sp, tts, sep, zerok) {\n+          tt_seq(sp, tts, sep, zerok) => {\n             alt lockstep_iter_size(tt_seq(sp, tts, sep, zerok), r) {\n-              lis_unconstrained {\n+              lis_unconstrained => {\n                 r.sp_diag.span_fatal(\n                     sp, /* blame macro writer */\n                     ~\"attempted to repeat an expression containing no syntax \\\n                      variables matched as repeating at this depth\");\n               }\n-              lis_contradiction(msg) { /* FIXME #2887 blame macro invoker\n+              lis_contradiction(msg) => { /* FIXME #2887 blame macro invoker\n                                           instead*/\n                 r.sp_diag.span_fatal(sp, msg);\n               }\n-              lis_constraint(len, _) {\n+              lis_constraint(len, _) => {\n                 if len == 0 {\n                     if !zerok {\n                         r.sp_diag.span_fatal(sp, /* FIXME #2887 blame invoker\n@@ -215,22 +211,22 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n             }\n           }\n           // FIXME #2887: think about span stuff here\n-          tt_nonterminal(sp, ident) {\n+          tt_nonterminal(sp, ident) => {\n             alt *lookup_cur_matched(r, ident) {\n               /* sidestep the interpolation tricks for ident because\n               (a) idents can be in lots of places, so it'd be a pain\n               (b) we actually can, since it's a token. */\n-              matched_nonterminal(nt_ident(sn,b)) {\n+              matched_nonterminal(nt_ident(sn,b)) => {\n                 r.cur_span = sp; r.cur_tok = IDENT(sn,b);\n                 r.cur.idx += 1u;\n                 return ret_val;\n               }\n-              matched_nonterminal(other_whole_nt) {\n+              matched_nonterminal(other_whole_nt) => {\n                 r.cur_span = sp; r.cur_tok = INTERPOLATED(other_whole_nt);\n                 r.cur.idx += 1u;\n                 return ret_val;\n               }\n-              matched_seq(*) {\n+              matched_seq(*) => {\n                 r.sp_diag.span_fatal(\n                     copy r.cur_span, /* blame the macro writer */\n                     fmt!{\"variable '%s' is still repeating at this depth\","}, {"sha": "ec6d7010aa1589fe63e608fbbe7eaf4edc8626ae", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 98, "deletions": 100, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -81,13 +81,13 @@ type ast_fold_precursor = @{\n fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n     return @{node:\n               alt mi.node {\n-                meta_word(id) { meta_word(fld.fold_ident(id)) }\n-                meta_list(id, mis) {\n+                meta_word(id) => meta_word(fld.fold_ident(id)),\n+                meta_list(id, mis) => {\n                   let fold_meta_item = |x|fold_meta_item_(x, fld);\n                   meta_list(/* FIXME: (#2543) */ copy id,\n                             vec::map(mis, fold_meta_item))\n                 }\n-                meta_name_value(id, s) {\n+                meta_name_value(id, s) => {\n                   meta_name_value(fld.fold_ident(id),\n                                   /* FIXME (#2543) */ copy s)\n                 }\n@@ -113,14 +113,14 @@ fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n     return {node:\n              alt m.node {\n-               mac_invoc(pth, arg, body) {\n+               mac_invoc(pth, arg, body) => {\n                  mac_invoc(fld.fold_path(pth),\n                            option::map(arg, |x| fld.fold_expr(x)), body)\n                }\n-               mac_invoc_tt(pth, tt) { m.node }\n-               mac_ellipsis { mac_ellipsis }\n-               mac_aq(_,_) { /* FIXME (#2543) */ copy m.node }\n-               mac_var(_) { /* FIXME (#2543) */ copy m.node }\n+               mac_invoc_tt(pth, tt) => m.node,\n+               mac_ellipsis => mac_ellipsis,\n+               mac_aq(_,_) => /* FIXME (#2543) */ copy m.node,\n+               mac_var(_) => /* FIXME (#2543) */ copy m.node,\n              },\n          span: fld.new_span(m.span)};\n }\n@@ -134,8 +134,8 @@ fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n \n fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n     alt tpb {\n-      bound_copy | bound_send | bound_const | bound_owned { tpb }\n-      bound_trait(ty) { bound_trait(fld.fold_ty(ty)) }\n+      bound_copy | bound_send | bound_const | bound_owned => tpb,\n+      bound_trait(ty) => bound_trait(fld.fold_ty(ty))\n     }\n }\n \n@@ -164,16 +164,16 @@ fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n    crate_directive_ {\n     return alt cd {\n-          cdir_src_mod(id, attrs) {\n+          cdir_src_mod(id, attrs) => {\n             cdir_src_mod(fld.fold_ident(id), /* FIXME (#2543) */ copy attrs)\n           }\n-          cdir_dir_mod(id, cds, attrs) {\n+          cdir_dir_mod(id, cds, attrs) => {\n             cdir_dir_mod(fld.fold_ident(id),\n                          vec::map(cds, |x| fld.fold_crate_directive(x)),\n                          /* FIXME (#2543) */ copy attrs)\n           }\n-          cdir_view_item(vi) { cdir_view_item(fld.fold_view_item(vi)) }\n-          cdir_syntax(_) { copy cd }\n+          cdir_view_item(vi) => cdir_view_item(fld.fold_view_item(vi)),\n+          cdir_syntax(_) => copy cd\n         }\n }\n \n@@ -191,7 +191,7 @@ fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n           attrs: vec::map(ni.attrs, fold_attribute),\n           node:\n               alt ni.node {\n-                foreign_item_fn(fdec, typms) {\n+                foreign_item_fn(fdec, typms) => {\n                   foreign_item_fn({inputs: vec::map(fdec.inputs, fold_arg),\n                                   output: fld.fold_ty(fdec.output),\n                                   purity: fdec.purity,\n@@ -217,32 +217,32 @@ fn noop_fold_item(&&i: @item, fld: ast_fold) -> option<@item> {\n fn noop_fold_class_item(&&ci: @class_member, fld: ast_fold)\n     -> @class_member {\n     @{node: alt ci.node {\n-        instance_var(ident, t, cm, id, p) {\n+        instance_var(ident, t, cm, id, p) => {\n            instance_var(/* FIXME (#2543) */ copy ident,\n                         fld.fold_ty(t), cm, id, p)\n         }\n-        class_method(m) { class_method(fld.fold_method(m)) }\n+        class_method(m) => class_method(fld.fold_method(m))\n       },\n       span: ci.span}\n }\n \n fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n     return alt i {\n-          item_const(t, e) { item_const(fld.fold_ty(t), fld.fold_expr(e)) }\n-          item_fn(decl, typms, body) {\n+          item_const(t, e) => item_const(fld.fold_ty(t), fld.fold_expr(e)),\n+          item_fn(decl, typms, body) => {\n               item_fn(fold_fn_decl(decl, fld),\n                       fold_ty_params(typms, fld),\n                       fld.fold_block(body))\n           }\n-          item_mod(m) { item_mod(fld.fold_mod(m)) }\n-          item_foreign_mod(nm) { item_foreign_mod(fld.fold_foreign_mod(nm)) }\n-          item_ty(t, typms) { item_ty(fld.fold_ty(t),\n-                                      fold_ty_params(typms, fld)) }\n-          item_enum(variants, typms) {\n+          item_mod(m) => item_mod(fld.fold_mod(m)),\n+          item_foreign_mod(nm) => item_foreign_mod(fld.fold_foreign_mod(nm)),\n+          item_ty(t, typms) => item_ty(fld.fold_ty(t),\n+                                       fold_ty_params(typms, fld)),\n+          item_enum(variants, typms) => {\n             item_enum(vec::map(variants, |x| fld.fold_variant(x)),\n                       fold_ty_params(typms, fld))\n           }\n-          item_class(typms, traits, items, m_ctor, m_dtor) {\n+          item_class(typms, traits, items, m_ctor, m_dtor) => {\n             let resulting_optional_constructor;\n             alt m_ctor {\n                 none => {\n@@ -273,18 +273,18 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                   resulting_optional_constructor,\n                   dtor)\n           }\n-          item_impl(tps, ifce, ty, methods) {\n+          item_impl(tps, ifce, ty, methods) => {\n               item_impl(fold_ty_params(tps, fld),\n                         ifce.map(|p| fold_trait_ref(p, fld)),\n                         fld.fold_ty(ty),\n                         vec::map(methods, |x| fld.fold_method(x)))\n           }\n-          item_trait(tps, traits, methods) {\n+          item_trait(tps, traits, methods) => {\n             item_trait(fold_ty_params(tps, fld),\n                        vec::map(traits, |p| fold_trait_ref(p, fld)),\n                        /* FIXME (#2543) */ copy methods)\n           }\n-      item_mac(m) {\n+      item_mac(m) => {\n         // FIXME #2888: we might actually want to do something here.\n         item_mac(m)\n       }\n@@ -320,9 +320,9 @@ fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n \n fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n     return alt s {\n-      stmt_decl(d, nid) { stmt_decl(fld.fold_decl(d), fld.new_id(nid)) }\n-      stmt_expr(e, nid) { stmt_expr(fld.fold_expr(e), fld.new_id(nid)) }\n-      stmt_semi(e, nid) { stmt_semi(fld.fold_expr(e), fld.new_id(nid)) }\n+      stmt_decl(d, nid) => stmt_decl(fld.fold_decl(d), fld.new_id(nid)),\n+      stmt_expr(e, nid) => stmt_expr(fld.fold_expr(e), fld.new_id(nid)),\n+      stmt_semi(e, nid) => stmt_semi(fld.fold_expr(e), fld.new_id(nid))\n     };\n }\n \n@@ -334,18 +334,18 @@ fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n \n fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n     return alt p {\n-          pat_wild { pat_wild }\n-          pat_ident(binding_mode, pth, sub) {\n+          pat_wild => pat_wild,\n+          pat_ident(binding_mode, pth, sub) => {\n             pat_ident(binding_mode,\n                       fld.fold_path(pth),\n                       option::map(sub, |x| fld.fold_pat(x)))\n           }\n-          pat_lit(e) { pat_lit(fld.fold_expr(e)) }\n-          pat_enum(pth, pats) {\n+          pat_lit(e) => pat_lit(fld.fold_expr(e)),\n+          pat_enum(pth, pats) => {\n               pat_enum(fld.fold_path(pth), option::map(pats,\n                        |pats| vec::map(pats, |x| fld.fold_pat(x))))\n           }\n-          pat_rec(fields, etc) {\n+          pat_rec(fields, etc) => {\n             let mut fs = ~[];\n             for fields.each |f| {\n                 vec::push(fs,\n@@ -354,23 +354,21 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n             }\n             pat_rec(fs, etc)\n           }\n-          pat_tup(elts) { pat_tup(vec::map(elts, |x| fld.fold_pat(x))) }\n-          pat_box(inner) { pat_box(fld.fold_pat(inner)) }\n-          pat_uniq(inner) { pat_uniq(fld.fold_pat(inner)) }\n-          pat_range(e1, e2) {\n+          pat_tup(elts) => pat_tup(vec::map(elts, |x| fld.fold_pat(x))),\n+          pat_box(inner) => pat_box(fld.fold_pat(inner)),\n+          pat_uniq(inner) => pat_uniq(fld.fold_pat(inner)),\n+          pat_range(e1, e2) => {\n             pat_range(fld.fold_expr(e1), fld.fold_expr(e2))\n           }\n         };\n }\n \n fn noop_fold_decl(d: decl_, fld: ast_fold) -> decl_ {\n     alt d {\n-      decl_local(ls) { decl_local(vec::map(ls, |x| fld.fold_local(x))) }\n-      decl_item(it) {\n-        alt fld.fold_item(it) {\n-          some(it_folded) { decl_item(it_folded) }\n-          none { decl_local(~[]) }\n-        }\n+      decl_local(ls) => decl_local(vec::map(ls, |x| fld.fold_local(x))),\n+      decl_item(it) => alt fld.fold_item(it) {\n+        some(it_folded) => decl_item(it_folded),\n+        none => decl_local(~[])\n       }\n     }\n }\n@@ -396,91 +394,91 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n     let fold_mac = |x| fold_mac_(x, fld);\n \n     return alt e {\n-          expr_vstore(e, v) {\n+          expr_vstore(e, v) => {\n             expr_vstore(fld.fold_expr(e), v)\n           }\n-          expr_vec(exprs, mutt) {\n+          expr_vec(exprs, mutt) => {\n             expr_vec(fld.map_exprs(|x| fld.fold_expr(x), exprs), mutt)\n           }\n           expr_repeat(expr, count, mutt) =>\n             expr_repeat(fld.fold_expr(expr), fld.fold_expr(count), mutt),\n-          expr_rec(fields, maybe_expr) {\n+          expr_rec(fields, maybe_expr) => {\n             expr_rec(vec::map(fields, fold_field),\n                      option::map(maybe_expr, |x| fld.fold_expr(x)))\n           }\n-          expr_tup(elts) { expr_tup(vec::map(elts, |x| fld.fold_expr(x))) }\n-          expr_call(f, args, blk) {\n+          expr_tup(elts) => expr_tup(vec::map(elts, |x| fld.fold_expr(x))),\n+          expr_call(f, args, blk) => {\n             expr_call(fld.fold_expr(f),\n                       fld.map_exprs(|x| fld.fold_expr(x), args),\n                       blk)\n           }\n-          expr_binary(binop, lhs, rhs) {\n+          expr_binary(binop, lhs, rhs) => {\n             expr_binary(binop, fld.fold_expr(lhs), fld.fold_expr(rhs))\n           }\n-          expr_unary(binop, ohs) { expr_unary(binop, fld.fold_expr(ohs)) }\n-          expr_loop_body(f) { expr_loop_body(fld.fold_expr(f)) }\n-          expr_do_body(f) { expr_do_body(fld.fold_expr(f)) }\n-          expr_lit(_) { copy e }\n-          expr_cast(expr, ty) { expr_cast(fld.fold_expr(expr), ty) }\n-          expr_addr_of(m, ohs) { expr_addr_of(m, fld.fold_expr(ohs)) }\n-          expr_if(cond, tr, fl) {\n+          expr_unary(binop, ohs) => expr_unary(binop, fld.fold_expr(ohs)),\n+          expr_loop_body(f) => expr_loop_body(fld.fold_expr(f)),\n+          expr_do_body(f) => expr_do_body(fld.fold_expr(f)),\n+          expr_lit(_) => copy e,\n+          expr_cast(expr, ty) => expr_cast(fld.fold_expr(expr), ty),\n+          expr_addr_of(m, ohs) => expr_addr_of(m, fld.fold_expr(ohs)),\n+          expr_if(cond, tr, fl) => {\n             expr_if(fld.fold_expr(cond), fld.fold_block(tr),\n                     option::map(fl, |x| fld.fold_expr(x)))\n           }\n-          expr_while(cond, body) {\n+          expr_while(cond, body) => {\n             expr_while(fld.fold_expr(cond), fld.fold_block(body))\n           }\n-          expr_loop(body) {\n+          expr_loop(body) => {\n               expr_loop(fld.fold_block(body))\n           }\n-          expr_alt(expr, arms, mode) {\n+          expr_alt(expr, arms, mode) => {\n             expr_alt(fld.fold_expr(expr),\n                      vec::map(arms, |x| fld.fold_arm(x)), mode)\n           }\n-          expr_fn(proto, decl, body, captures) {\n+          expr_fn(proto, decl, body, captures) => {\n             expr_fn(proto, fold_fn_decl(decl, fld),\n                     fld.fold_block(body),\n                     @((*captures).map(|cap_item| {\n                         @({id: fld.new_id((*cap_item).id)\n                            with *cap_item})})))\n           }\n-          expr_fn_block(decl, body, captures) {\n+          expr_fn_block(decl, body, captures) => {\n             expr_fn_block(fold_fn_decl(decl, fld), fld.fold_block(body),\n                           @((*captures).map(|cap_item| {\n                               @({id: fld.new_id((*cap_item).id)\n                                  with *cap_item})})))\n           }\n-          expr_block(blk) { expr_block(fld.fold_block(blk)) }\n-          expr_move(el, er) {\n+          expr_block(blk) => expr_block(fld.fold_block(blk)),\n+          expr_move(el, er) => {\n             expr_move(fld.fold_expr(el), fld.fold_expr(er))\n           }\n-          expr_copy(e) { expr_copy(fld.fold_expr(e)) }\n-          expr_unary_move(e) { expr_unary_move(fld.fold_expr(e)) }\n-          expr_assign(el, er) {\n+          expr_copy(e) => expr_copy(fld.fold_expr(e)),\n+          expr_unary_move(e) => expr_unary_move(fld.fold_expr(e)),\n+          expr_assign(el, er) => {\n             expr_assign(fld.fold_expr(el), fld.fold_expr(er))\n           }\n-          expr_swap(el, er) {\n+          expr_swap(el, er) => {\n             expr_swap(fld.fold_expr(el), fld.fold_expr(er))\n           }\n-          expr_assign_op(op, el, er) {\n+          expr_assign_op(op, el, er) => {\n             expr_assign_op(op, fld.fold_expr(el), fld.fold_expr(er))\n           }\n-          expr_field(el, id, tys) {\n+          expr_field(el, id, tys) => {\n             expr_field(fld.fold_expr(el), fld.fold_ident(id),\n                        vec::map(tys, |x| fld.fold_ty(x)))\n           }\n-          expr_index(el, er) {\n+          expr_index(el, er) => {\n             expr_index(fld.fold_expr(el), fld.fold_expr(er))\n           }\n-          expr_path(pth) { expr_path(fld.fold_path(pth)) }\n-          expr_fail(e) { expr_fail(option::map(e, |x| fld.fold_expr(x))) }\n-          expr_break | expr_again { copy e }\n-          expr_ret(e) { expr_ret(option::map(e, |x| fld.fold_expr(x))) }\n-          expr_log(i, lv, e) { expr_log(i, fld.fold_expr(lv),\n-                                        fld.fold_expr(e)) }\n-          expr_assert(e) { expr_assert(fld.fold_expr(e)) }\n-          expr_mac(mac) { expr_mac(fold_mac(mac)) }\n-          expr_struct(path, fields) {\n+          expr_path(pth) => expr_path(fld.fold_path(pth)),\n+          expr_fail(e) => expr_fail(option::map(e, |x| fld.fold_expr(x))),\n+          expr_break | expr_again => copy e,\n+          expr_ret(e) => expr_ret(option::map(e, |x| fld.fold_expr(x))),\n+          expr_log(i, lv, e) => expr_log(i, fld.fold_expr(lv),\n+                                         fld.fold_expr(e)),\n+          expr_assert(e) => expr_assert(fld.fold_expr(e)),\n+          expr_mac(mac) => expr_mac(fold_mac(mac)),\n+          expr_struct(path, fields) => {\n             expr_struct(fld.fold_path(path), vec::map(fields, fold_field))\n           }\n         }\n@@ -497,18 +495,18 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n          span: fld.new_span(f.span)}\n     }\n     alt t {\n-      ty_nil | ty_bot | ty_infer {copy t}\n-      ty_box(mt) {ty_box(fold_mt(mt, fld))}\n-      ty_uniq(mt) {ty_uniq(fold_mt(mt, fld))}\n-      ty_vec(mt) {ty_vec(fold_mt(mt, fld))}\n-      ty_ptr(mt) {ty_ptr(fold_mt(mt, fld))}\n-      ty_rptr(region, mt) {ty_rptr(region, fold_mt(mt, fld))}\n-      ty_rec(fields) {ty_rec(vec::map(fields, |f| fold_field(f, fld)))}\n-      ty_fn(proto, decl) {ty_fn(proto, fold_fn_decl(decl, fld))}\n-      ty_tup(tys) {ty_tup(vec::map(tys, |ty| fld.fold_ty(ty)))}\n-      ty_path(path, id) {ty_path(fld.fold_path(path), fld.new_id(id))}\n-      ty_fixed_length(t, vs) {ty_fixed_length(fld.fold_ty(t), vs)}\n-      ty_mac(mac) {ty_mac(fold_mac(mac))}\n+      ty_nil | ty_bot | ty_infer => copy t,\n+      ty_box(mt) => ty_box(fold_mt(mt, fld)),\n+      ty_uniq(mt) => ty_uniq(fold_mt(mt, fld)),\n+      ty_vec(mt) => ty_vec(fold_mt(mt, fld)),\n+      ty_ptr(mt) => ty_ptr(fold_mt(mt, fld)),\n+      ty_rptr(region, mt) => ty_rptr(region, fold_mt(mt, fld)),\n+      ty_rec(fields) => ty_rec(vec::map(fields, |f| fold_field(f, fld))),\n+      ty_fn(proto, decl) => ty_fn(proto, fold_fn_decl(decl, fld)),\n+      ty_tup(tys) => ty_tup(vec::map(tys, |ty| fld.fold_ty(ty))),\n+      ty_path(path, id) => ty_path(fld.fold_path(path), fld.new_id(id)),\n+      ty_fixed_length(t, vs) => ty_fixed_length(fld.fold_ty(t), vs),\n+      ty_mac(mac) => ty_mac(fold_mac(mac))\n     }\n }\n \n@@ -534,8 +532,8 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     let attrs = vec::map(v.attrs, fold_attribute);\n \n     let de = alt v.disr_expr {\n-      some(e) {some(fld.fold_expr(e))}\n-      none {none}\n+      some(e) => some(fld.fold_expr(e)),\n+      none => none\n     };\n     return {name: /* FIXME (#2543) */ copy v.name,\n          attrs: attrs,\n@@ -561,8 +559,8 @@ fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n          pat: fld.fold_pat(l.pat),\n          init:\n              alt l.init {\n-               option::none::<initializer> { l.init }\n-               option::some::<initializer>(init) {\n+               option::none::<initializer> => l.init,\n+               option::some::<initializer>(init) => {\n                  option::some::<initializer>({op: init.op,\n                                               expr: fld.fold_expr(init.expr)})\n                }\n@@ -636,11 +634,11 @@ impl of ast_fold for ast_fold_precursor {\n     }\n     fn fold_class_item(&&ci: @class_member) -> @class_member {\n         @{node: alt ci.node {\n-           instance_var(nm, t, mt, id, p) {\n+           instance_var(nm, t, mt, id, p) => {\n                instance_var(/* FIXME (#2543) */ copy nm,\n                             (self as ast_fold).fold_ty(t), mt, id, p)\n            }\n-           class_method(m) {\n+           class_method(m) => {\n                class_method(self.fold_method(m, self as ast_fold))\n            }\n           }, span: self.new_span(ci.span)}"}, {"sha": "71e7c4a04e54a9cf577873824655e187fde66a02", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -190,8 +190,8 @@ fn new_parser_etc_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n    (parser, string_reader) {\n     let res = io::read_whole_file_str(path);\n     alt res {\n-      result::ok(_) { /* Continue. */ }\n-      result::err(e) { sess.span_diagnostic.handler().fatal(e); }\n+      result::ok(_) => { /* Continue. */ }\n+      result::err(e) => sess.span_diagnostic.handler().fatal(e)\n     }\n     let src = @result::unwrap(res);\n     let filemap = codemap::new_filemap(path, src, sess.chpos, sess.byte_pos);"}, {"sha": "006bd3909d825336b15a60261f1c2f71549a04d4", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -30,7 +30,7 @@ impl parser_attr of parser_attr for parser {\n     {\n         let expect_item_next = vec::is_not_empty(first_item_attrs);\n         alt self.token {\n-          token::POUND {\n+          token::POUND => {\n             let lo = self.span.lo;\n             if self.look_ahead(1u) == token::LBRACKET {\n                 self.bump();\n@@ -46,12 +46,10 @@ impl parser_attr of parser_attr for parser {\n                 return some(right(self.parse_syntax_ext_naked(lo)));\n             } else { return none; }\n         }\n-        token::DOC_COMMENT(_) {\n+        token::DOC_COMMENT(_) => {\n           return some(left(self.parse_outer_attributes()));\n         }\n-        _ {\n-          return none;\n-        }\n+        _ => return none\n       }\n     }\n \n@@ -60,13 +58,13 @@ impl parser_attr of parser_attr for parser {\n         let mut attrs: ~[ast::attribute] = ~[];\n         loop {\n             alt copy self.token {\n-              token::POUND {\n+              token::POUND => {\n                 if self.look_ahead(1u) != token::LBRACKET {\n                     break;\n                 }\n                 attrs += ~[self.parse_attribute(ast::attr_outer)];\n               }\n-              token::DOC_COMMENT(s) {\n+              token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n                         *self.get_str(s), self.span.lo, self.span.hi);\n                 if attr.node.style != ast::attr_outer {\n@@ -75,9 +73,7 @@ impl parser_attr of parser_attr for parser {\n                 attrs += ~[attr];\n                 self.bump();\n               }\n-              _ {\n-                break;\n-              }\n+              _ => break\n             }\n         }\n         return attrs;\n@@ -111,7 +107,7 @@ impl parser_attr of parser_attr for parser {\n         let mut next_outer_attrs: ~[ast::attribute] = ~[];\n         loop {\n             alt copy self.token {\n-              token::POUND {\n+              token::POUND => {\n                 if self.look_ahead(1u) != token::LBRACKET {\n                     // This is an extension\n                     break;\n@@ -130,7 +126,7 @@ impl parser_attr of parser_attr for parser {\n                     break;\n                 }\n               }\n-              token::DOC_COMMENT(s) {\n+              token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n                         *self.get_str(s), self.span.lo, self.span.hi);\n                 self.bump();\n@@ -141,9 +137,7 @@ impl parser_attr of parser_attr for parser {\n                   break;\n                 }\n               }\n-              _ {\n-                break;\n-              }\n+              _ => break\n             }\n         }\n         return {inner: inner_attrs, next: next_outer_attrs};\n@@ -153,18 +147,18 @@ impl parser_attr of parser_attr for parser {\n         let lo = self.span.lo;\n         let ident = self.parse_ident();\n         alt self.token {\n-          token::EQ {\n+          token::EQ => {\n             self.bump();\n             let lit = self.parse_lit();\n             let mut hi = self.span.hi;\n             return @spanned(lo, hi, ast::meta_name_value(ident, lit));\n           }\n-          token::LPAREN {\n+          token::LPAREN => {\n             let inner_items = self.parse_meta_seq();\n             let mut hi = self.span.hi;\n             return @spanned(lo, hi, ast::meta_list(ident, inner_items));\n           }\n-          _ {\n+          _ => {\n             let mut hi = self.span.hi;\n             return @spanned(lo, hi, ast::meta_word(ident));\n           }\n@@ -178,8 +172,10 @@ impl parser_attr of parser_attr for parser {\n     }\n \n     fn parse_optional_meta() -> ~[@ast::meta_item] {\n-        alt self.token { token::LPAREN { return self.parse_meta_seq(); }\n-                         _ { return ~[]; } }\n+        alt self.token {\n+          token::LPAREN => return self.parse_meta_seq(),\n+          _ => return ~[]\n+        }\n     }\n }\n "}, {"sha": "8450ce0038dd1d11f9816c87956c63d59282ba7b", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -8,69 +8,62 @@ fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n     alt e.node {\n       ast::expr_if(_, _, _) | ast::expr_alt(_, _, _) | ast::expr_block(_)\n       | ast::expr_while(_, _) | ast::expr_loop(_)\n-      | ast::expr_call(_, _, true) {\n-        false\n-      }\n-      _ { true }\n+      | ast::expr_call(_, _, true) => false,\n+      _ => true\n     }\n }\n \n fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n     alt stmt.node {\n-      ast::stmt_decl(d, _) {\n+      ast::stmt_decl(d, _) => {\n         return alt d.node {\n-              ast::decl_local(_) { true }\n-              ast::decl_item(_) { false }\n+              ast::decl_local(_) => true,\n+              ast::decl_item(_) => false\n             }\n       }\n-      ast::stmt_expr(e, _) {\n+      ast::stmt_expr(e, _) => {\n         return expr_requires_semi_to_be_stmt(e);\n       }\n-      ast::stmt_semi(e, _) {\n+      ast::stmt_semi(e, _) => {\n         return false;\n       }\n     }\n }\n \n fn need_parens(expr: @ast::expr, outer_prec: uint) -> bool {\n     alt expr.node {\n-      ast::expr_binary(op, _, _) { operator_prec(op) < outer_prec }\n-      ast::expr_cast(_, _) { parse::prec::as_prec < outer_prec }\n+      ast::expr_binary(op, _, _) => operator_prec(op) < outer_prec,\n+      ast::expr_cast(_, _) => parse::prec::as_prec < outer_prec,\n       // This may be too conservative in some cases\n-      ast::expr_assign(_, _) { true }\n-      ast::expr_move(_, _) { true }\n-      ast::expr_swap(_, _) { true }\n-      ast::expr_assign_op(_, _, _) { true }\n-      ast::expr_ret(_) { true }\n-      ast::expr_assert(_) { true }\n-      ast::expr_log(_, _, _) { true }\n-      _ { !parse::classify::expr_requires_semi_to_be_stmt(expr) }\n+      ast::expr_assign(_, _) => true,\n+      ast::expr_move(_, _) => true,\n+      ast::expr_swap(_, _) => true,\n+      ast::expr_assign_op(_, _, _) => true,\n+      ast::expr_ret(_) => true,\n+      ast::expr_assert(_) => true,\n+      ast::expr_log(_, _, _) => true,\n+      _ => !parse::classify::expr_requires_semi_to_be_stmt(expr)\n     }\n }\n \n fn ends_in_lit_int(ex: @ast::expr) -> bool {\n     alt ex.node {\n-      ast::expr_lit(node) {\n-        alt node {\n-          @{node: ast::lit_int(_, ast::ty_i), _} |\n-          @{node: ast::lit_int_unsuffixed(_), _}\n-          { true }\n-          _ { false }\n-        }\n+      ast::expr_lit(node) => alt node {\n+        @{node: ast::lit_int(_, ast::ty_i), _}\n+        | @{node: ast::lit_int_unsuffixed(_), _} => true,\n+        _ => false\n       }\n       ast::expr_binary(_, _, sub) | ast::expr_unary(_, sub) |\n       ast::expr_move(_, sub) | ast::expr_copy(sub) |\n       ast::expr_assign(_, sub) |\n       ast::expr_assign_op(_, _, sub) | ast::expr_swap(_, sub) |\n-      ast::expr_log(_, _, sub) | ast::expr_assert(sub) {\n+      ast::expr_log(_, _, sub) | ast::expr_assert(sub) => {\n         ends_in_lit_int(sub)\n       }\n-      ast::expr_fail(osub) | ast::expr_ret(osub) {\n-        alt osub {\n-          some(ex) { ends_in_lit_int(ex) }\n-          _ { false }\n-        }\n+      ast::expr_fail(osub) | ast::expr_ret(osub) => alt osub {\n+        some(ex) => ends_in_lit_int(ex),\n+        _ => false\n       }\n-      _ { false }\n+      _ => false\n     }\n }"}, {"sha": "6b31b53eaa5c7d86582a2bf7ab86368f7d8d136f", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -85,10 +85,10 @@ impl parser_common of parser_common for parser {\n \n     fn parse_ident() -> ast::ident {\n         alt copy self.token {\n-          token::IDENT(i, _) { self.bump(); return self.get_str(i); }\n-          token::INTERPOLATED(token::nt_ident(*)) { self.bug(\n+          token::IDENT(i, _) => { self.bump(); return self.get_str(i); }\n+          token::INTERPOLATED(token::nt_ident(*)) => { self.bug(\n               ~\"ident interpolation not converted to real token\"); }\n-          _ { self.fatal(~\"expected ident, found `\"\n+          _ => { self.fatal(~\"expected ident, found `\"\n                          + token_to_str(self.reader, self.token)\n                          + ~\"`\"); }\n         }\n@@ -135,10 +135,10 @@ impl parser_common of parser_common for parser {\n \n     fn is_any_keyword(tok: token::token) -> bool {\n         alt tok {\n-          token::IDENT(sid, false) {\n+          token::IDENT(sid, false) => {\n             self.keywords.contains_key_ref(self.get_str(sid))\n           }\n-          _ { false }\n+          _ => false\n         }\n     }\n \n@@ -147,13 +147,13 @@ impl parser_common of parser_common for parser {\n \n         let mut bump = false;\n         let val = alt self.token {\n-          token::IDENT(sid, false) {\n+          token::IDENT(sid, false) => {\n             if word == *self.get_str(sid) {\n                 bump = true;\n                 true\n             } else { false }\n           }\n-          _ { false }\n+          _ => false\n         };\n         if bump { self.bump() }\n         val\n@@ -174,11 +174,11 @@ impl parser_common of parser_common for parser {\n \n     fn check_restricted_keywords() {\n         alt self.token {\n-          token::IDENT(_, false) {\n+          token::IDENT(_, false) => {\n             let w = token_to_str(self.reader, self.token);\n             self.check_restricted_keywords_(w);\n           }\n-          _ { }\n+          _ => ()\n         }\n     }\n \n@@ -210,9 +210,11 @@ impl parser_common of parser_common for parser {\n         while self.token != token::GT\n             && self.token != token::BINOP(token::SHR) {\n             alt sep {\n-              some(t) { if first { first = false; }\n-                       else { self.expect(t); } }\n-              _ { }\n+              some(t) => {\n+                if first { first = false; }\n+                else { self.expect(t); }\n+              }\n+              _ => ()\n             }\n             vec::push(v, f(self));\n         }\n@@ -252,9 +254,11 @@ impl parser_common of parser_common for parser {\n         let mut v: ~[T] = ~[];\n         while self.token != ket {\n             alt sep.sep {\n-              some(t) { if first { first = false; }\n-                        else { self.expect(t); } }\n-              _ { }\n+              some(t) => {\n+                if first { first = false; }\n+                else { self.expect(t); }\n+              }\n+              _ => ()\n             }\n             if sep.trailing_sep_allowed && self.token == ket { break; }\n             vec::push(v, f(self));"}, {"sha": "154e653e8908c86a28d3a669d4b055b744d2d3c3", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -48,17 +48,17 @@ fn parse_companion_mod(cx: ctx, prefix: ~str, suffix: option<~str>)\n \n     fn companion_file(+prefix: ~str, suffix: option<~str>) -> ~str {\n         return alt suffix {\n-          option::some(s) { path::connect(prefix, s) }\n-          option::none { prefix }\n+          option::some(s) => path::connect(prefix, s),\n+          option::none => prefix\n         } + ~\".rs\";\n     }\n \n     fn file_exists(path: ~str) -> bool {\n         // Crude, but there's no lib function for this and I'm not\n         // up to writing it just now\n         alt io::file_reader(path) {\n-          result::ok(_) { true }\n-          result::err(_) { false }\n+          result::ok(_) => true,\n+          result::err(_) => false\n         }\n     }\n \n@@ -80,18 +80,16 @@ fn parse_companion_mod(cx: ctx, prefix: ~str, suffix: option<~str>)\n \n fn cdir_path_opt(id: ast::ident, attrs: ~[ast::attribute]) -> @~str {\n     alt ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n-      some(d) {\n-        return d;\n-      }\n-      none { return id; }\n+      some(d) => return d,\n+      none => return id\n     }\n }\n \n fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: ~str,\n                         &view_items: ~[@ast::view_item],\n                         &items: ~[@ast::item]) {\n     alt cdir.node {\n-      ast::cdir_src_mod(id, attrs) {\n+      ast::cdir_src_mod(id, attrs) => {\n         let file_path = cdir_path_opt(@(*id + ~\".rs\"), attrs);\n         let full_path =\n             if path::path_is_absolute(*file_path) {\n@@ -112,7 +110,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: ~str,\n         cx.sess.byte_pos = cx.sess.byte_pos + r0.pos;\n         vec::push(items, i);\n       }\n-      ast::cdir_dir_mod(id, cdirs, attrs) {\n+      ast::cdir_dir_mod(id, cdirs, attrs) => {\n         let path = cdir_path_opt(id, attrs);\n         let full_path =\n             if path::path_is_absolute(*path) {\n@@ -130,8 +128,8 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: ~str,\n         cx.sess.next_id += 1;\n         vec::push(items, i);\n       }\n-      ast::cdir_view_item(vi) { vec::push(view_items, vi); }\n-      ast::cdir_syntax(pth) { }\n+      ast::cdir_view_item(vi) => vec::push(view_items, vi),\n+      ast::cdir_syntax(pth) => ()\n     }\n }\n //"}, {"sha": "bc5aba5283cfaf07de82b45e469304eef1c43993", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -207,7 +207,7 @@ fn consume_any_line_comment(rdr: string_reader)\n                                 -> option<{tok: token::token, sp: span}> {\n     if rdr.curr == '/' {\n         alt nextch(rdr) {\n-          '/' {\n+          '/' => {\n             bump(rdr);\n             bump(rdr);\n             // line comments starting with \"///\" or \"//!\" are doc-comments\n@@ -228,8 +228,8 @@ fn consume_any_line_comment(rdr: string_reader)\n                 return consume_whitespace_and_comments(rdr);\n             }\n           }\n-          '*' { bump(rdr); bump(rdr); return consume_block_comment(rdr); }\n-          _ {}\n+          '*' => { bump(rdr); bump(rdr); return consume_block_comment(rdr); }\n+          _ => ()\n         }\n     } else if rdr.curr == '#' {\n         if nextch(rdr) == '!' {\n@@ -314,11 +314,11 @@ fn scan_digits(rdr: string_reader, radix: uint) -> ~str {\n         let c = rdr.curr;\n         if c == '_' { bump(rdr); again; }\n         alt char::to_digit(c, radix) {\n-          some(d) {\n+          some(d) => {\n             str::push_char(rslt, c);\n             bump(rdr);\n           }\n-          _ { return rslt; }\n+          _ => return rslt\n         }\n     };\n }\n@@ -372,8 +372,8 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n         }\n         let parsed = option::get(u64::from_str_radix(num_str, base as u64));\n         alt tp {\n-          either::left(t) { return token::LIT_INT(parsed as i64, t); }\n-          either::right(t) { return token::LIT_UINT(parsed, t); }\n+          either::left(t) => return token::LIT_INT(parsed as i64, t),\n+          either::right(t) => return token::LIT_UINT(parsed, t)\n         }\n     }\n     let mut is_float = false;\n@@ -384,11 +384,11 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n         num_str += ~\".\" + dec_part;\n     }\n     alt scan_exponent(rdr) {\n-      some(s) {\n+      some(s) => {\n         is_float = true;\n         num_str += s;\n       }\n-      none {}\n+      none => ()\n     }\n     if rdr.curr == 'f' {\n         bump(rdr);\n@@ -479,9 +479,9 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n \n \n       // One-byte tokens.\n-      ';' { bump(rdr); return token::SEMI; }\n-      ',' { bump(rdr); return token::COMMA; }\n-      '.' {\n+      ';' => { bump(rdr); return token::SEMI; }\n+      ',' => { bump(rdr); return token::COMMA; }\n+      '.' => {\n         bump(rdr);\n         if rdr.curr == '.' && nextch(rdr) != '.' {\n             bump(rdr);\n@@ -494,31 +494,31 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n         }\n         return token::DOT;\n       }\n-      '(' { bump(rdr); return token::LPAREN; }\n-      ')' { bump(rdr); return token::RPAREN; }\n-      '{' { bump(rdr); return token::LBRACE; }\n-      '}' { bump(rdr); return token::RBRACE; }\n-      '[' { bump(rdr); return token::LBRACKET; }\n-      ']' { bump(rdr); return token::RBRACKET; }\n-      '@' { bump(rdr); return token::AT; }\n-      '#' { bump(rdr); return token::POUND; }\n-      '~' { bump(rdr); return token::TILDE; }\n-      ':' {\n+      '(' => { bump(rdr); return token::LPAREN; }\n+      ')' => { bump(rdr); return token::RPAREN; }\n+      '{' => { bump(rdr); return token::LBRACE; }\n+      '}' => { bump(rdr); return token::RBRACE; }\n+      '[' => { bump(rdr); return token::LBRACKET; }\n+      ']' => { bump(rdr); return token::RBRACKET; }\n+      '@' => { bump(rdr); return token::AT; }\n+      '#' => { bump(rdr); return token::POUND; }\n+      '~' => { bump(rdr); return token::TILDE; }\n+      ':' => {\n         bump(rdr);\n         if rdr.curr == ':' {\n             bump(rdr);\n             return token::MOD_SEP;\n         } else { return token::COLON; }\n       }\n \n-      '$' { bump(rdr); return token::DOLLAR; }\n+      '$' => { bump(rdr); return token::DOLLAR; }\n \n \n \n \n \n       // Multi-byte tokens.\n-      '=' {\n+      '=' => {\n         bump(rdr);\n         if rdr.curr == '=' {\n             bump(rdr);\n@@ -530,54 +530,54 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n             return token::EQ;\n         }\n       }\n-      '!' {\n+      '!' => {\n         bump(rdr);\n         if rdr.curr == '=' {\n             bump(rdr);\n             return token::NE;\n         } else { return token::NOT; }\n       }\n-      '<' {\n+      '<' => {\n         bump(rdr);\n         alt rdr.curr {\n-          '=' { bump(rdr); return token::LE; }\n-          '<' { return binop(rdr, token::SHL); }\n-          '-' {\n+          '=' => { bump(rdr); return token::LE; }\n+          '<' => { return binop(rdr, token::SHL); }\n+          '-' => {\n             bump(rdr);\n             alt rdr.curr {\n-              '>' { bump(rdr); return token::DARROW; }\n-              _ { return token::LARROW; }\n+              '>' => { bump(rdr); return token::DARROW; }\n+              _ => { return token::LARROW; }\n             }\n           }\n-          _ { return token::LT; }\n+          _ => { return token::LT; }\n         }\n       }\n-      '>' {\n+      '>' => {\n         bump(rdr);\n         alt rdr.curr {\n-          '=' { bump(rdr); return token::GE; }\n-          '>' { return binop(rdr, token::SHR); }\n-          _ { return token::GT; }\n+          '=' => { bump(rdr); return token::GE; }\n+          '>' => { return binop(rdr, token::SHR); }\n+          _ => { return token::GT; }\n         }\n       }\n-      '\\'' {\n+      '\\'' => {\n         bump(rdr);\n         let mut c2 = rdr.curr;\n         bump(rdr);\n         if c2 == '\\\\' {\n             let escaped = rdr.curr;\n             bump(rdr);\n             alt escaped {\n-              'n' { c2 = '\\n'; }\n-              'r' { c2 = '\\r'; }\n-              't' { c2 = '\\t'; }\n-              '\\\\' { c2 = '\\\\'; }\n-              '\\'' { c2 = '\\''; }\n-              '\"' { c2 = '\"'; }\n-              'x' { c2 = scan_numeric_escape(rdr, 2u); }\n-              'u' { c2 = scan_numeric_escape(rdr, 4u); }\n-              'U' { c2 = scan_numeric_escape(rdr, 8u); }\n-              c2 {\n+              'n' => { c2 = '\\n'; }\n+              'r' => { c2 = '\\r'; }\n+              't' => { c2 = '\\t'; }\n+              '\\\\' => { c2 = '\\\\'; }\n+              '\\'' => { c2 = '\\''; }\n+              '\"' => { c2 = '\"'; }\n+              'x' => { c2 = scan_numeric_escape(rdr, 2u); }\n+              'u' => { c2 = scan_numeric_escape(rdr, 4u); }\n+              'U' => { c2 = scan_numeric_escape(rdr, 8u); }\n+              c2 => {\n                 rdr.fatal(fmt!{\"unknown character escape: %d\", c2 as int});\n               }\n             }\n@@ -588,7 +588,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n         bump(rdr); // advance curr past token\n         return token::LIT_INT(c2 as i64, ast::ty_char);\n       }\n-      '\"' {\n+      '\"' => {\n         let n = rdr.chpos;\n         bump(rdr);\n         while rdr.curr != '\"' {\n@@ -600,63 +600,63 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n             let ch = rdr.curr;\n             bump(rdr);\n             alt ch {\n-              '\\\\' {\n+              '\\\\' => {\n                 let escaped = rdr.curr;\n                 bump(rdr);\n                 alt escaped {\n-                  'n' { str::push_char(accum_str, '\\n'); }\n-                  'r' { str::push_char(accum_str, '\\r'); }\n-                  't' { str::push_char(accum_str, '\\t'); }\n-                  '\\\\' { str::push_char(accum_str, '\\\\'); }\n-                  '\\'' { str::push_char(accum_str, '\\''); }\n-                  '\"' { str::push_char(accum_str, '\"'); }\n-                  '\\n' { consume_whitespace(rdr); }\n-                  'x' {\n+                  'n' => str::push_char(accum_str, '\\n'),\n+                  'r' => str::push_char(accum_str, '\\r'),\n+                  't' => str::push_char(accum_str, '\\t'),\n+                  '\\\\' => str::push_char(accum_str, '\\\\'),\n+                  '\\'' => str::push_char(accum_str, '\\''),\n+                  '\"' => str::push_char(accum_str, '\"'),\n+                  '\\n' => consume_whitespace(rdr),\n+                  'x' => {\n                     str::push_char(accum_str, scan_numeric_escape(rdr, 2u));\n                   }\n-                  'u' {\n+                  'u' => {\n                     str::push_char(accum_str, scan_numeric_escape(rdr, 4u));\n                   }\n-                  'U' {\n+                  'U' => {\n                     str::push_char(accum_str, scan_numeric_escape(rdr, 8u));\n                   }\n-                  c2 {\n+                  c2 => {\n                     rdr.fatal(fmt!{\"unknown string escape: %d\", c2 as int});\n                   }\n                 }\n               }\n-              _ { str::push_char(accum_str, ch); }\n+              _ => str::push_char(accum_str, ch)\n             }\n         }\n         bump(rdr);\n         return token::LIT_STR((*rdr.interner).intern(@accum_str));\n       }\n-      '-' {\n+      '-' => {\n         if nextch(rdr) == '>' {\n             bump(rdr);\n             bump(rdr);\n             return token::RARROW;\n         } else { return binop(rdr, token::MINUS); }\n       }\n-      '&' {\n+      '&' => {\n         if nextch(rdr) == '&' {\n             bump(rdr);\n             bump(rdr);\n             return token::ANDAND;\n         } else { return binop(rdr, token::AND); }\n       }\n-      '|' {\n+      '|' => {\n         alt nextch(rdr) {\n-          '|' { bump(rdr); bump(rdr); return token::OROR; }\n-          _ { return binop(rdr, token::OR); }\n+          '|' => { bump(rdr); bump(rdr); return token::OROR; }\n+          _ => { return binop(rdr, token::OR); }\n         }\n       }\n-      '+' { return binop(rdr, token::PLUS); }\n-      '*' { return binop(rdr, token::STAR); }\n-      '/' { return binop(rdr, token::SLASH); }\n-      '^' { return binop(rdr, token::CARET); }\n-      '%' { return binop(rdr, token::PERCENT); }\n-      c { rdr.fatal(fmt!{\"unknown start of token: %d\", c as int}); }\n+      '+' => { return binop(rdr, token::PLUS); }\n+      '*' => { return binop(rdr, token::STAR); }\n+      '/' => { return binop(rdr, token::SLASH); }\n+      '^' => { return binop(rdr, token::CARET); }\n+      '%' => { return binop(rdr, token::PERCENT); }\n+      c => { rdr.fatal(fmt!{\"unknown start of token: %d\", c as int}); }\n     }\n }\n "}, {"sha": "5eacf75e529883dd8f93f7ba3fa98f0351ccb80c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 181, "deletions": 193, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -107,35 +107,35 @@ The important thing is to make sure that lookahead doesn't balk\n at INTERPOLATED tokens */\n macro_rules! maybe_whole_expr {\n     {$p:expr} => { alt copy $p.token {\n-      INTERPOLATED(token::nt_expr(e)) {\n+      INTERPOLATED(token::nt_expr(e)) => {\n         $p.bump();\n         return pexpr(e);\n       }\n-      INTERPOLATED(token::nt_path(pt)) {\n+      INTERPOLATED(token::nt_path(pt)) => {\n         $p.bump();\n         return $p.mk_pexpr($p.span.lo, $p.span.lo,\n                        expr_path(pt));\n       }\n-      _ {}\n+      _ => ()\n     }}\n }\n \n macro_rules! maybe_whole {\n     {$p:expr, $constructor:ident} => { alt copy $p.token {\n-      INTERPOLATED(token::$constructor(x)) { $p.bump(); return x; }\n-      _ {}\n+      INTERPOLATED(token::$constructor(x)) => { $p.bump(); return x; }\n+      _ => ()\n     }} ;\n     {deref $p:expr, $constructor:ident} => { alt copy $p.token {\n-      INTERPOLATED(token::$constructor(x)) { $p.bump(); return *x; }\n-      _ {}\n+      INTERPOLATED(token::$constructor(x)) => { $p.bump(); return *x; }\n+      _ => ()\n     }} ;\n     {some $p:expr, $constructor:ident} => { alt copy $p.token {\n-      INTERPOLATED(token::$constructor(x)) { $p.bump(); return some(x); }\n-      _ {}\n+      INTERPOLATED(token::$constructor(x)) => { $p.bump(); return some(x); }\n+      _ => ()\n     }} ;\n     {pair_empty $p:expr, $constructor:ident} => { alt copy $p.token {\n-      INTERPOLATED(token::$constructor(x)) { $p.bump(); return (~[], x); }\n-      _ {}\n+      INTERPOLATED(token::$constructor(x)) => { $p.bump(); return (~[], x); }\n+      _ => ()\n     }}\n \n }\n@@ -284,7 +284,7 @@ class parser {\n                     `%s`\",\n                    token_to_str(p.reader, p.token)};\n             alt p.token {\n-              token::SEMI {\n+              token::SEMI => {\n                 p.bump();\n                 debug!{\"parse_trait_methods(): parsing required method\"};\n                 // NB: at the moment, visibility annotations on required\n@@ -294,7 +294,7 @@ class parser {\n                           self_ty: self_ty,\n                           id: p.get_id(), span: mk_sp(lo, hi)})\n               }\n-              token::LBRACE {\n+              token::LBRACE => {\n                 debug!{\"parse_trait_methods(): parsing provided method\"};\n                 let (inner_attrs, body) =\n                     p.parse_inner_attrs_and_block(true);\n@@ -311,7 +311,7 @@ class parser {\n                            vis: vis})\n               }\n \n-              _ { p.fatal(~\"expected `;` or `}` but found `\" +\n+              _ => { p.fatal(~\"expected `;` or `}` but found `\" +\n                           token_to_str(p.reader, p.token) + ~\"`\");\n                 }\n             }\n@@ -356,8 +356,8 @@ class parser {\n \n     fn region_from_name(s: option<@~str>) -> @region {\n         let r = alt s {\n-          some (string) { re_named(string) }\n-          none { re_anon }\n+          some (string) => re_named(string),\n+          none => re_anon\n         };\n \n         @{id: self.get_id(), node: r}\n@@ -368,12 +368,12 @@ class parser {\n         self.expect(token::BINOP(token::AND));\n \n         alt copy self.token {\n-          token::IDENT(sid, _) {\n+          token::IDENT(sid, _) => {\n             self.bump();\n             let n = self.get_str(sid);\n             self.region_from_name(some(n))\n           }\n-          _ {\n+          _ => {\n             self.region_from_name(none)\n           }\n         }\n@@ -402,12 +402,12 @@ class parser {\n         let lo = self.span.lo;\n \n         alt self.maybe_parse_dollar_mac() {\n-          some(e) {\n+          some(e) => {\n             return @{id: self.get_id(),\n                   node: ty_mac(spanned(lo, self.span.hi, e)),\n                   span: mk_sp(lo, self.span.hi)};\n           }\n-          none {}\n+          none => ()\n         }\n \n         let t = if self.token == token::LPAREN {\n@@ -472,8 +472,8 @@ class parser {\n         return @{id: self.get_id(),\n               node: alt self.maybe_parse_fixed_vstore() {\n                 // Consider a fixed vstore suffix (/N or /_)\n-                none { t }\n-                some(v) {\n+                none => t,\n+                some(v) => {\n                   ty_fixed_length(@{id: self.get_id(), node:t, span: sp}, v)\n                 } },\n               span: sp}\n@@ -542,43 +542,41 @@ class parser {\n \n     fn maybe_parse_dollar_mac() -> option<mac_> {\n         alt copy self.token {\n-          token::DOLLAR {\n+          token::DOLLAR => {\n             let lo = self.span.lo;\n             self.bump();\n             alt copy self.token {\n-              token::LIT_INT_UNSUFFIXED(num) {\n+              token::LIT_INT_UNSUFFIXED(num) => {\n                 self.bump();\n                 some(mac_var(num as uint))\n               }\n-              token::LPAREN {\n+              token::LPAREN => {\n                 self.bump();\n                 let e = self.parse_expr();\n                 self.expect(token::RPAREN);\n                 let hi = self.last_span.hi;\n                 some(mac_aq(mk_sp(lo,hi), e))\n               }\n-              _ {\n+              _ => {\n                 self.fatal(~\"expected `(` or unsuffixed integer literal\");\n               }\n             }\n           }\n-          _ {none}\n+          _ => none\n         }\n     }\n \n     fn maybe_parse_fixed_vstore() -> option<option<uint>> {\n         if self.token == token::BINOP(token::SLASH) {\n             self.bump();\n             alt copy self.token {\n-              token::UNDERSCORE {\n+              token::UNDERSCORE => {\n                 self.bump(); some(none)\n               }\n-              token::LIT_INT_UNSUFFIXED(i) if i >= 0i64 {\n+              token::LIT_INT_UNSUFFIXED(i) if i >= 0i64 => {\n                 self.bump(); some(some(i as uint))\n               }\n-              _ {\n-                none\n-              }\n+              _ => none\n             }\n         } else {\n             none\n@@ -587,13 +585,13 @@ class parser {\n \n     fn lit_from_token(tok: token::token) -> lit_ {\n         alt tok {\n-          token::LIT_INT(i, it) { lit_int(i, it) }\n-          token::LIT_UINT(u, ut) { lit_uint(u, ut) }\n-          token::LIT_INT_UNSUFFIXED(i) { lit_int_unsuffixed(i) }\n-          token::LIT_FLOAT(s, ft) { lit_float(self.get_str(s), ft) }\n-          token::LIT_STR(s) { lit_str(self.get_str(s)) }\n-          token::LPAREN { self.expect(token::RPAREN); lit_nil }\n-          _ { self.unexpected_last(tok); }\n+          token::LIT_INT(i, it) => lit_int(i, it),\n+          token::LIT_UINT(u, ut) => lit_uint(u, ut),\n+          token::LIT_INT_UNSUFFIXED(i) => lit_int_unsuffixed(i),\n+          token::LIT_FLOAT(s, ft) => lit_float(self.get_str(s), ft),\n+          token::LIT_STR(s) => lit_str(self.get_str(s)),\n+          token::LPAREN => { self.expect(token::RPAREN); lit_nil }\n+          _ => self.unexpected_last(tok)\n         }\n     }\n \n@@ -735,8 +733,8 @@ class parser {\n \n     fn to_expr(e: pexpr) -> @expr {\n         alt e.node {\n-          expr_tup(es) if vec::len(es) == 1u { es[0u] }\n-          _ { *e }\n+          expr_tup(es) if vec::len(es) == 1u => es[0u],\n+          _ => *e\n         }\n     }\n \n@@ -748,8 +746,8 @@ class parser {\n         let mut ex: expr_;\n \n         alt self.maybe_parse_dollar_mac() {\n-          some(x) {return pexpr(self.mk_mac_expr(lo, self.span.hi, x));}\n-          _ {}\n+          some(x) => return pexpr(self.mk_mac_expr(lo, self.span.hi, x)),\n+          _ => ()\n         }\n \n         if self.token == token::LPAREN {\n@@ -800,8 +798,8 @@ class parser {\n         } else if self.eat_keyword(~\"fn\") {\n             let proto = self.parse_fn_ty_proto();\n             alt proto {\n-              proto_bare { self.fatal(~\"fn expr are deprecated, use fn@\"); }\n-              _ { /* fallthrough */ }\n+              proto_bare => self.fatal(~\"fn expr are deprecated, use fn@\"),\n+              _ => { /* fallthrough */ }\n             }\n             return pexpr(self.parse_fn_expr(proto));\n         } else if self.eat_keyword(~\"unchecked\") {\n@@ -895,13 +893,13 @@ class parser {\n             if self.token == token::NOT {\n                 self.bump();\n                 let tts = alt self.token {\n-                  token::LPAREN | token::LBRACE | token::LBRACKET {\n+                  token::LPAREN | token::LBRACE | token::LBRACKET => {\n                     let ket = token::flip_delimiter(self.token);\n                     self.parse_unspanned_seq(copy self.token, ket,\n                                              seq_sep_none(),\n                                              |p| p.parse_token_tree())\n                   }\n-                  _ { self.fatal(~\"expected open delimiter\"); }\n+                  _ => self.fatal(~\"expected open delimiter\")\n                 };\n                 let hi = self.span.hi;\n \n@@ -942,16 +940,14 @@ class parser {\n         // only.\n         alt ex {\n           expr_lit(@{node: lit_str(_), span: _}) |\n-          expr_vec(_, _)  {\n-            alt self.maybe_parse_fixed_vstore() {\n-              none { }\n-              some(v) {\n+          expr_vec(_, _)  => alt self.maybe_parse_fixed_vstore() {\n+            none => (),\n+            some(v) => {\n                 hi = self.span.hi;\n                 ex = expr_vstore(self.mk_expr(lo, hi, ex), vstore_fixed(v));\n-              }\n             }\n           }\n-          _ { }\n+          _ => ()\n         }\n \n         return self.mk_pexpr(lo, hi, ex);\n@@ -971,8 +967,8 @@ class parser {\n \n     fn parse_syntax_ext_naked(lo: uint) -> @expr {\n         alt self.token {\n-          token::IDENT(_, _) {}\n-          _ { self.fatal(~\"expected a syntax expander name\"); }\n+          token::IDENT(_, _) => (),\n+          _ => self.fatal(~\"expected a syntax expander name\")\n         }\n         let pth = self.parse_path_without_tps();\n         //temporary for a backwards-compatible cycle:\n@@ -998,10 +994,10 @@ class parser {\n             let mut depth = 1u;\n             while (depth > 0u) {\n                 alt (self.token) {\n-                  token::LBRACE {depth += 1u;}\n-                  token::RBRACE {depth -= 1u;}\n-                  token::EOF {self.fatal(~\"unexpected EOF in macro body\");}\n-                  _ {}\n+                  token::LBRACE => depth += 1u,\n+                  token::RBRACE => depth -= 1u,\n+                  token::EOF => self.fatal(~\"unexpected EOF in macro body\"),\n+                  _ => ()\n                 }\n                 self.bump();\n             }\n@@ -1028,7 +1024,7 @@ class parser {\n             // expr.f\n             if self.eat(token::DOT) {\n                 alt copy self.token {\n-                  token::IDENT(i, _) {\n+                  token::IDENT(i, _) => {\n                     hi = self.span.hi;\n                     self.bump();\n                     let tys = if self.eat(token::MOD_SEP) {\n@@ -1040,14 +1036,14 @@ class parser {\n                                                          self.get_str(i),\n                                                          tys));\n                   }\n-                  _ { self.unexpected(); }\n+                  _ => self.unexpected()\n                 }\n                 again;\n             }\n             if self.expr_is_complete(e) { break; }\n             alt copy self.token {\n               // expr(...)\n-              token::LPAREN if self.permits_call() {\n+              token::LPAREN if self.permits_call() => {\n                 let es = self.parse_unspanned_seq(\n                     token::LPAREN, token::RPAREN,\n                     seq_sep_trailing_disallowed(token::COMMA),\n@@ -1059,15 +1055,15 @@ class parser {\n               }\n \n               // expr[...]\n-              token::LBRACKET {\n+              token::LBRACKET => {\n                 self.bump();\n                 let ix = self.parse_expr();\n                 hi = ix.span.hi;\n                 self.expect(token::RBRACKET);\n                 e = self.mk_pexpr(lo, hi, expr_index(self.to_expr(e), ix));\n               }\n \n-              _ { return e; }\n+              _ => return e\n             }\n         }\n         return e;\n@@ -1099,15 +1095,15 @@ class parser {\n         fn parse_tt_tok(p: parser, delim_ok: bool) -> token_tree {\n             alt p.token {\n               token::RPAREN | token::RBRACE | token::RBRACKET\n-              if !delim_ok {\n+              if !delim_ok => {\n                 p.fatal(~\"incorrect close delimiter: `\"\n                            + token_to_str(p.reader, p.token) + ~\"`\");\n               }\n-              token::EOF {\n+              token::EOF => {\n                 p.fatal(~\"file ended in the middle of a macro invocation\");\n               }\n               /* we ought to allow different depths of unquotation */\n-              token::DOLLAR if p.quote_depth > 0u {\n+              token::DOLLAR if p.quote_depth > 0u => {\n                 p.bump();\n                 let sp = p.span;\n \n@@ -1121,15 +1117,15 @@ class parser {\n                     return tt_nonterminal(sp, p.parse_ident());\n                 }\n               }\n-              _ { /* ok */ }\n+              _ => { /* ok */ }\n             }\n             let res = tt_tok(p.span, p.token);\n             p.bump();\n             return res;\n         }\n \n         return alt self.token {\n-          token::LPAREN | token::LBRACE | token::LBRACKET {\n+          token::LPAREN | token::LBRACE | token::LBRACKET => {\n             let ket = token::flip_delimiter(self.token);\n             tt_delim(vec::append(\n                 ~[parse_tt_tok(self, true)],\n@@ -1139,7 +1135,7 @@ class parser {\n                         |p| p.parse_token_tree()),\n                     ~[parse_tt_tok(self, true)])))\n           }\n-          _ { parse_tt_tok(self, false) }\n+          _ => parse_tt_tok(self, false)\n         };\n     }\n \n@@ -1149,11 +1145,11 @@ class parser {\n         maybe_whole!{self, nt_matchers};\n         let name_idx = @mut 0u;\n         return alt self.token {\n-          token::LBRACE | token::LPAREN | token::LBRACKET {\n+          token::LBRACE | token::LPAREN | token::LBRACKET => {\n             self.parse_matcher_subseq(name_idx, copy self.token,\n                                       token::flip_delimiter(self.token))\n           }\n-          _ { self.fatal(~\"expected open delimiter\"); }\n+          _ => self.fatal(~\"expected open delimiter\")\n         }\n     }\n \n@@ -1217,70 +1213,70 @@ class parser {\n \n         let mut ex;\n         alt copy self.token {\n-          token::NOT {\n+          token::NOT => {\n             self.bump();\n             let e = self.to_expr(self.parse_prefix_expr());\n             hi = e.span.hi;\n             self.get_id(); // see ast_util::op_expr_callee_id\n             ex = expr_unary(not, e);\n           }\n-          token::BINOP(b) {\n+          token::BINOP(b) => {\n             alt b {\n-              token::MINUS {\n+              token::MINUS => {\n                 self.bump();\n                 let e = self.to_expr(self.parse_prefix_expr());\n                 hi = e.span.hi;\n                 self.get_id(); // see ast_util::op_expr_callee_id\n                 ex = expr_unary(neg, e);\n               }\n-              token::STAR {\n+              token::STAR => {\n                 self.bump();\n                 let e = self.to_expr(self.parse_prefix_expr());\n                 hi = e.span.hi;\n                 ex = expr_unary(deref, e);\n               }\n-              token::AND {\n+              token::AND => {\n                 self.bump();\n                 let m = self.parse_mutability();\n                 let e = self.to_expr(self.parse_prefix_expr());\n                 hi = e.span.hi;\n                 // HACK: turn &[...] into a &-evec\n                 ex = alt e.node {\n                   expr_vec(*) | expr_lit(@{node: lit_str(_), span: _})\n-                  if m == m_imm {\n+                  if m == m_imm => {\n                     expr_vstore(e, vstore_slice(self.region_from_name(none)))\n                   }\n-                  _ { expr_addr_of(m, e) }\n+                  _ => expr_addr_of(m, e)\n                 };\n               }\n-              _ { return self.parse_dot_or_call_expr(); }\n+              _ => return self.parse_dot_or_call_expr()\n             }\n           }\n-          token::AT {\n+          token::AT => {\n             self.bump();\n             let m = self.parse_mutability();\n             let e = self.to_expr(self.parse_prefix_expr());\n             hi = e.span.hi;\n             // HACK: turn @[...] into a @-evec\n             ex = alt e.node {\n               expr_vec(*) | expr_lit(@{node: lit_str(_), span: _})\n-              if m == m_imm { expr_vstore(e, vstore_box) }\n-              _ { expr_unary(box(m), e) }\n+              if m == m_imm => expr_vstore(e, vstore_box),\n+              _ => expr_unary(box(m), e)\n             };\n           }\n-          token::TILDE {\n+          token::TILDE => {\n             self.bump();\n             let m = self.parse_mutability();\n             let e = self.to_expr(self.parse_prefix_expr());\n             hi = e.span.hi;\n             // HACK: turn ~[...] into a ~-evec\n             ex = alt e.node {\n               expr_vec(*) | expr_lit(@{node: lit_str(_), span: _})\n-              if m == m_imm { expr_vstore(e, vstore_uniq) }\n-              _ { expr_unary(uniq(m), e) }\n+              if m == m_imm => expr_vstore(e, vstore_uniq),\n+              _ => expr_unary(uniq(m), e)\n             };\n           }\n-          _ { return self.parse_dot_or_call_expr(); }\n+          _ => return self.parse_dot_or_call_expr()\n         }\n         return self.mk_pexpr(lo, hi, ex);\n     }\n@@ -1306,7 +1302,7 @@ class parser {\n         }\n         let cur_opt   = token_to_binop(peeked);\n         alt cur_opt {\n-          some(cur_op) {\n+          some(cur_op) => {\n             let cur_prec = operator_prec(cur_op);\n             if cur_prec > min_prec {\n                 self.bump();\n@@ -1318,7 +1314,7 @@ class parser {\n                 return self.parse_more_binops(bin, min_prec);\n             }\n           }\n-          _ {}\n+          _ => ()\n         }\n         if as_prec > min_prec && self.eat_keyword(~\"as\") {\n             let rhs = self.parse_ty(true);\n@@ -1333,42 +1329,42 @@ class parser {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n         alt copy self.token {\n-          token::EQ {\n+          token::EQ => {\n             self.bump();\n             let rhs = self.parse_expr();\n             return self.mk_expr(lo, rhs.span.hi, expr_assign(lhs, rhs));\n           }\n-          token::BINOPEQ(op) {\n+          token::BINOPEQ(op) => {\n             self.bump();\n             let rhs = self.parse_expr();\n             let mut aop;\n             alt op {\n-              token::PLUS { aop = add; }\n-              token::MINUS { aop = subtract; }\n-              token::STAR { aop = mul; }\n-              token::SLASH { aop = div; }\n-              token::PERCENT { aop = rem; }\n-              token::CARET { aop = bitxor; }\n-              token::AND { aop = bitand; }\n-              token::OR { aop = bitor; }\n-              token::SHL { aop = shl; }\n-              token::SHR { aop = shr; }\n+              token::PLUS => aop = add,\n+              token::MINUS => aop = subtract,\n+              token::STAR => aop = mul,\n+              token::SLASH => aop = div,\n+              token::PERCENT => aop = rem,\n+              token::CARET => aop = bitxor,\n+              token::AND => aop = bitand,\n+              token::OR => aop = bitor,\n+              token::SHL => aop = shl,\n+              token::SHR => aop = shr\n             }\n             self.get_id(); // see ast_util::op_expr_callee_id\n             return self.mk_expr(lo, rhs.span.hi,\n                                 expr_assign_op(aop, lhs, rhs));\n           }\n-          token::LARROW {\n+          token::LARROW => {\n             self.bump();\n             let rhs = self.parse_expr();\n             return self.mk_expr(lo, rhs.span.hi, expr_move(lhs, rhs));\n           }\n-          token::DARROW {\n+          token::DARROW => {\n             self.bump();\n             let rhs = self.parse_expr();\n             return self.mk_expr(lo, rhs.span.hi, expr_swap(lhs, rhs));\n           }\n-          _ {/* fall through */ }\n+          _ => {/* fall through */ }\n         }\n         return lhs;\n     }\n@@ -1407,10 +1403,10 @@ class parser {\n         self.parse_lambda_expr_(\n             || {\n                 alt self.token {\n-                  token::BINOP(token::OR) | token::OROR {\n+                  token::BINOP(token::OR) | token::OROR => {\n                     self.parse_fn_block_decl()\n                   }\n-                  _ {\n+                  _ => {\n                     // No argument list - `do foo {`\n                     ({\n                         {\n@@ -1476,22 +1472,22 @@ class parser {\n         // them as the lambda arguments\n         let e = self.parse_expr_res(RESTRICT_NO_BAR_OR_DOUBLEBAR_OP);\n         alt e.node {\n-          expr_call(f, args, false) {\n+          expr_call(f, args, false) => {\n             let block = self.parse_lambda_block_expr();\n             let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                     ctor(block));\n             let args = vec::append(args, ~[last_arg]);\n             @{node: expr_call(f, args, true)\n               with *e}\n           }\n-          expr_path(*) | expr_field(*) | expr_call(*) {\n+          expr_path(*) | expr_field(*) | expr_call(*) => {\n             let block = self.parse_lambda_block_expr();\n             let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                     ctor(block));\n             self.mk_expr(lo.lo, last_arg.span.hi,\n                          expr_call(e, ~[last_arg], true))\n           }\n-          _ {\n+          _ => {\n             // There may be other types of expressions that can\n             // represent the callee in `for` and `do` expressions\n             // but they aren't represented by tests\n@@ -1607,11 +1603,11 @@ class parser {\n \n     fn parse_initializer() -> option<initializer> {\n         alt self.token {\n-          token::EQ {\n+          token::EQ => {\n             self.bump();\n             return some({op: init_assign, expr: self.parse_expr()});\n           }\n-          token::LARROW {\n+          token::LARROW => {\n             self.bump();\n             return some({op: init_move, expr: self.parse_expr()});\n           }\n@@ -1622,7 +1618,7 @@ class parser {\n           //     return some(rec(op = init_recv,\n           //                  expr = self.parse_expr()));\n           // }\n-          _ {\n+          _ => {\n             return none;\n           }\n         }\n@@ -1644,39 +1640,43 @@ class parser {\n         let mut hi = self.span.hi;\n         let mut pat;\n         alt self.token {\n-          token::UNDERSCORE { self.bump(); pat = pat_wild; }\n-          token::AT {\n+          token::UNDERSCORE => { self.bump(); pat = pat_wild; }\n+          token::AT => {\n             self.bump();\n             let sub = self.parse_pat(refutable);\n             hi = sub.span.hi;\n             // HACK: parse @\"...\" as a literal of a vstore @str\n             pat = alt sub.node {\n-              pat_lit(e@@{node: expr_lit(@{node: lit_str(_), span: _}), _}) {\n+              pat_lit(e@@{\n+                node: expr_lit(@{node: lit_str(_), span: _}), _\n+              }) => {\n                 let vst = @{id: self.get_id(), callee_id: self.get_id(),\n                             node: expr_vstore(e, vstore_box),\n                             span: mk_sp(lo, hi)};\n                 pat_lit(vst)\n               }\n-              _ { pat_box(sub) }\n+              _ => pat_box(sub)\n             };\n           }\n-          token::TILDE {\n+          token::TILDE => {\n             self.bump();\n             let sub = self.parse_pat(refutable);\n             hi = sub.span.hi;\n             // HACK: parse ~\"...\" as a literal of a vstore ~str\n             pat = alt sub.node {\n-              pat_lit(e@@{node: expr_lit(@{node: lit_str(_), span: _}), _}) {\n+              pat_lit(e@@{\n+                node: expr_lit(@{node: lit_str(_), span: _}), _\n+              }) => {\n                 let vst = @{id: self.get_id(), callee_id: self.get_id(),\n                             node: expr_vstore(e, vstore_uniq),\n                             span: mk_sp(lo, hi)};\n                 pat_lit(vst)\n               }\n-              _ { pat_uniq(sub) }\n+              _ => pat_uniq(sub)\n             };\n \n           }\n-          token::LBRACE {\n+          token::LBRACE => {\n             self.bump();\n             let mut fields = ~[];\n             let mut etc = false;\n@@ -1722,7 +1722,7 @@ class parser {\n             self.bump();\n             pat = pat_rec(fields, etc);\n           }\n-          token::LPAREN {\n+          token::LPAREN => {\n             self.bump();\n             if self.token == token::RPAREN {\n                 hi = self.span.hi;\n@@ -1742,7 +1742,7 @@ class parser {\n                 pat = pat_tup(fields);\n             }\n           }\n-          tok {\n+          tok => {\n             if !is_ident(tok) ||\n                     self.is_keyword(~\"true\") || self.is_keyword(~\"false\") {\n                 let val = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n@@ -1789,24 +1789,22 @@ class parser {\n                     let mut args: ~[@pat] = ~[];\n                     let mut star_pat = false;\n                     alt self.token {\n-                      token::LPAREN {\n-                        alt self.look_ahead(1u) {\n-                          token::BINOP(token::STAR) {\n+                      token::LPAREN => alt self.look_ahead(1u) {\n+                        token::BINOP(token::STAR) => {\n                             // This is a \"top constructor only\" pat\n-                            self.bump(); self.bump();\n-                            star_pat = true;\n-                            self.expect(token::RPAREN);\n+                              self.bump(); self.bump();\n+                              star_pat = true;\n+                              self.expect(token::RPAREN);\n                           }\n-                          _ {\n+                        _ => {\n                             args = self.parse_unspanned_seq(\n                                 token::LPAREN, token::RPAREN,\n                                 seq_sep_trailing_disallowed(token::COMMA),\n                                 |p| p.parse_pat(refutable));\n-                            hi = self.span.hi;\n+                              hi = self.span.hi;\n                           }\n-                        }\n                       }\n-                      _ { }\n+                      _ => ()\n                     }\n                     // at this point, we're not sure whether it's a enum or a\n                     // bind\n@@ -1887,9 +1885,9 @@ class parser {\n         } else {\n             let mut item_attrs;\n             alt self.parse_outer_attrs_or_ext(first_item_attrs) {\n-              none { item_attrs = ~[]; }\n-              some(left(attrs)) { item_attrs = attrs; }\n-              some(right(ext)) {\n+              none => item_attrs = ~[],\n+              some(left(attrs)) => item_attrs = attrs,\n+              some(right(ext)) => {\n                 return @spanned(lo, ext.span.hi,\n                                 stmt_expr(ext, self.get_id()));\n               }\n@@ -1898,12 +1896,12 @@ class parser {\n             let item_attrs = vec::append(first_item_attrs, item_attrs);\n \n             alt self.parse_item(item_attrs) {\n-              some(i) {\n+              some(i) => {\n                 let mut hi = i.span.hi;\n                 let decl = @spanned(lo, hi, decl_item(i));\n                 return @spanned(lo, hi, stmt_decl(decl, self.get_id()));\n               }\n-              none() { /* fallthrough */ }\n+              none() => { /* fallthrough */ }\n             }\n \n             check_expected_item(self, item_attrs);\n@@ -1990,24 +1988,24 @@ class parser {\n \n         while self.token != token::RBRACE {\n             alt self.token {\n-              token::SEMI {\n+              token::SEMI => {\n                 self.bump(); // empty\n               }\n-              _ {\n+              _ => {\n                 let stmt = self.parse_stmt(initial_attrs);\n                 initial_attrs = ~[];\n                 alt stmt.node {\n-                  stmt_expr(e, stmt_id) { // Expression without semicolon:\n+                  stmt_expr(e, stmt_id) => { // Expression without semicolon:\n                     alt self.token {\n-                      token::SEMI {\n+                      token::SEMI => {\n                         self.bump();\n                         push(stmts,\n                              @{node: stmt_semi(e, stmt_id) with *stmt});\n                       }\n-                      token::RBRACE {\n+                      token::RBRACE => {\n                         expr = some(e);\n                       }\n-                      t {\n+                      t => {\n                         if classify::stmt_ends_with_semi(*stmt) {\n                             self.fatal(~\"expected `;` or `}` after \\\n                                          expression but found `\"\n@@ -2018,7 +2016,7 @@ class parser {\n                     }\n                   }\n \n-                  _ { // All other kinds of statements:\n+                  _ => { // All other kinds of statements:\n                     vec::push(stmts, stmt);\n \n                     if classify::stmt_ends_with_semi(*stmt) {\n@@ -2083,12 +2081,8 @@ class parser {\n \n     fn is_self_ident() -> bool {\n         alt self.token {\n-            token::IDENT(sid, false) if ~\"self\" == *self.get_str(sid) {\n-                true\n-            }\n-            _ => {\n-                false\n-            }\n+            token::IDENT(sid, false) if ~\"self\" == *self.get_str(sid) => true,\n+            _ => false\n         }\n     }\n \n@@ -2266,14 +2260,14 @@ class parser {\n \n     fn parse_method_name() -> ident {\n         alt copy self.token {\n-          token::BINOP(op) { self.bump(); @token::binop_to_str(op) }\n-          token::NOT { self.bump(); @~\"!\" }\n-          token::LBRACKET {\n+          token::BINOP(op) => { self.bump(); @token::binop_to_str(op) }\n+          token::NOT => { self.bump(); @~\"!\" }\n+          token::LBRACKET => {\n             self.bump();\n             self.expect(token::RBRACKET);\n             @~\"[]\"\n           }\n-          _ {\n+          _ => {\n             let id = self.parse_value_ident();\n             if id == @~\"unary\" && self.eat(token::BINOP(token::MINUS)) {\n                 @~\"unary-\"\n@@ -2388,8 +2382,8 @@ class parser {\n                 traits = ~[];\n             };\n             ident = alt ident_old {\n-              some(name) { name }\n-              none { self.expect_keyword(~\"of\"); fail; }\n+              some(name) => name,\n+              none => { self.expect_keyword(~\"of\"); fail; }\n             };\n             self.expect_keyword(~\"for\");\n             ty = self.parse_ty(false);\n@@ -2446,13 +2440,13 @@ class parser {\n         let mut the_dtor : option<(blk, ~[attribute], codemap::span)> = none;\n         while self.token != token::RBRACE {\n             alt self.parse_class_item(class_path) {\n-              ctor_decl(a_fn_decl, attrs, blk, s) {\n+              ctor_decl(a_fn_decl, attrs, blk, s) => {\n                 the_ctor = some((a_fn_decl, attrs, blk, s));\n               }\n-              dtor_decl(blk, attrs, s) {\n+              dtor_decl(blk, attrs, s) => {\n                 the_dtor = some((blk, attrs, s));\n               }\n-              members(mms) { ms = vec::append(ms, mms); }\n+              members(mms) => { ms = vec::append(ms, mms); }\n             }\n         }\n         let actual_dtor = do option::map(the_dtor) |dtor| {\n@@ -2464,7 +2458,7 @@ class parser {\n              span: d_s}};\n         self.bump();\n         alt the_ctor {\n-          some((ct_d, ct_attrs, ct_b, ct_s)) {\n+          some((ct_d, ct_attrs, ct_b, ct_s)) => {\n             (class_name,\n              item_class(ty_params, traits, ms, some({\n                  node: {id: ctor_id,\n@@ -2478,7 +2472,7 @@ class parser {\n           /*\n           Is it strange for the parser to check this?\n           */\n-          none {\n+          none => {\n             (class_name,\n              item_class(ty_params, traits, ms, none, actual_dtor),\n              none)\n@@ -2488,8 +2482,8 @@ class parser {\n \n     fn token_is_pound_or_doc_comment(++tok: token::token) -> bool {\n         alt tok {\n-            token::POUND | token::DOC_COMMENT(_) { true }\n-            _ { false }\n+            token::POUND | token::DOC_COMMENT(_) => true,\n+            _ => false\n         }\n     }\n \n@@ -2583,8 +2577,8 @@ class parser {\n             }\n             debug!{\"parse_mod_items: parse_item(attrs=%?)\", attrs};\n             alt self.parse_item(attrs) {\n-              some(i) { vec::push(items, i); }\n-              _ {\n+              some(i) => vec::push(items, i),\n+              _ => {\n                 self.fatal(~\"expected item but found `\" +\n                            token_to_str(self.reader, self.token) + ~\"`\");\n               }\n@@ -2765,32 +2759,28 @@ class parser {\n \n     fn parse_fn_ty_proto() -> proto {\n         alt self.token {\n-          token::AT {\n+          token::AT => {\n             self.bump();\n             proto_box\n           }\n-          token::TILDE {\n+          token::TILDE => {\n             self.bump();\n             proto_uniq\n           }\n-          token::BINOP(token::AND) {\n+          token::BINOP(token::AND) => {\n             self.bump();\n             proto_block\n           }\n-          _ {\n+          _ => {\n             proto_block\n           }\n         }\n     }\n \n     fn fn_expr_lookahead(tok: token::token) -> bool {\n         alt tok {\n-          token::LPAREN | token::AT | token::TILDE | token::BINOP(_) {\n-            true\n-          }\n-          _ {\n-            false\n-          }\n+          token::LPAREN | token::AT | token::TILDE | token::BINOP(_) => true,\n+          _ => false\n         }\n     }\n \n@@ -2851,13 +2841,13 @@ class parser {\n             self.expect(token::NOT);\n             let id = self.parse_ident();\n             let tts = alt self.token {\n-              token::LPAREN | token::LBRACE | token::LBRACKET {\n+              token::LPAREN | token::LBRACE | token::LBRACKET => {\n                 let ket = token::flip_delimiter(self.token);\n                 self.parse_unspanned_seq(copy self.token, ket,\n                                          seq_sep_none(),\n                                          |p| p.parse_token_tree())\n               }\n-              _ { self.fatal(~\"expected open delimiter\"); }\n+              _ => self.fatal(~\"expected open delimiter\")\n             };\n             let m = ast::mac_invoc_tt(pth, tts);\n             let m: ast::mac = {node: m,\n@@ -2868,8 +2858,8 @@ class parser {\n         } else { return none; };\n         some(self.mk_item(lo, self.last_span.hi, ident, item_, visibility,\n                           alt extra_attrs {\n-                              some(as) { vec::append(attrs, as) }\n-                              none { attrs }\n+                              some(as) => vec::append(attrs, as),\n+                              none => attrs\n                           }))\n     }\n \n@@ -2885,7 +2875,7 @@ class parser {\n         let mut path = ~[first_ident];\n         debug!{\"parsed view_path: %s\", *first_ident};\n         alt self.token {\n-          token::EQ {\n+          token::EQ => {\n             // x = foo::bar\n             self.bump();\n             path = ~[self.parse_ident()];\n@@ -2900,20 +2890,20 @@ class parser {\n                          view_path_simple(first_ident, path, self.get_id()));\n           }\n \n-          token::MOD_SEP {\n+          token::MOD_SEP => {\n             // foo::bar or foo::{a,b,c} or foo::*\n             while self.token == token::MOD_SEP {\n                 self.bump();\n \n                 alt copy self.token {\n \n-                  token::IDENT(i, _) {\n+                  token::IDENT(i, _) => {\n                     self.bump();\n                     vec::push(path, self.get_str(i));\n                   }\n \n                   // foo::bar::{a,b,c}\n-                  token::LBRACE {\n+                  token::LBRACE => {\n                     let idents = self.parse_unspanned_seq(\n                         token::LBRACE, token::RBRACE,\n                         seq_sep_trailing_allowed(token::COMMA),\n@@ -2926,7 +2916,7 @@ class parser {\n                   }\n \n                   // foo::bar::*\n-                  token::BINOP(token::STAR) {\n+                  token::BINOP(token::STAR) => {\n                     self.bump();\n                     let path = @{span: mk_sp(lo, self.span.hi),\n                                  global: false, idents: path,\n@@ -2935,11 +2925,11 @@ class parser {\n                                  view_path_glob(path, self.get_id()));\n                   }\n \n-                  _ { break; }\n+                  _ => break\n                 }\n             }\n           }\n-          _ { }\n+          _ => ()\n         }\n         let last = path[vec::len(path) - 1u];\n         let path = @{span: mk_sp(lo, self.span.hi), global: false,\n@@ -3009,10 +2999,8 @@ class parser {\n \n     fn parse_str() -> @~str {\n         alt copy self.token {\n-          token::LIT_STR(s) { self.bump(); self.get_str(s) }\n-          _ {\n-            self.fatal(~\"expected string literal\")\n-          }\n+          token::LIT_STR(s) => { self.bump(); self.get_str(s) }\n+          _ => self.fatal(~\"expected string literal\")\n         }\n     }\n \n@@ -3043,13 +3031,13 @@ class parser {\n             let id = self.parse_ident();\n             alt self.token {\n               // mod x = \"foo.rs\";\n-              token::SEMI {\n+              token::SEMI => {\n                 let mut hi = self.span.hi;\n                 self.bump();\n                 return spanned(lo, hi, cdir_src_mod(id, outer_attrs));\n               }\n               // mod x = \"foo_dir\" { ...directives... }\n-              token::LBRACE {\n+              token::LBRACE => {\n                 self.bump();\n                 let inner_attrs = self.parse_inner_attrs_and_next();\n                 let mod_attrs = vec::append(outer_attrs, inner_attrs.inner);\n@@ -3061,7 +3049,7 @@ class parser {\n                 return spanned(lo, hi,\n                             cdir_dir_mod(id, cdirs, mod_attrs));\n               }\n-              _ { self.unexpected(); }\n+              _ => self.unexpected()\n             }\n         } else if self.is_view_item() {\n             let vi = self.parse_view_item(outer_attrs);"}, {"sha": "45bbe3b8e3b7c7234c3922aa6158a0944eff69e8", "filename": "src/libsyntax/parse/prec.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse%2Fprec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse%2Fprec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fprec.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -21,25 +21,25 @@ const as_prec: uint = 11u;\n  */\n fn token_to_binop(tok: token) -> option<ast::binop> {\n   alt tok {\n-      BINOP(STAR)    { some(mul) }\n-      BINOP(SLASH)   { some(div) }\n-      BINOP(PERCENT) { some(rem) }\n+      BINOP(STAR)    => some(mul),\n+      BINOP(SLASH)   => some(div),\n+      BINOP(PERCENT) => some(rem),\n       // 'as' sits between here with 11\n-      BINOP(PLUS)    { some(add) }\n-      BINOP(MINUS)   { some(subtract) }\n-      BINOP(SHL)     { some(shl) }\n-      BINOP(SHR)     { some(shr) }\n-      BINOP(AND)     { some(bitand) }\n-      BINOP(CARET)   { some(bitxor) }\n-      BINOP(OR)      { some(bitor) }\n-      LT             { some(lt) }\n-      LE             { some(le) }\n-      GE             { some(ge) }\n-      GT             { some(gt) }\n-      EQEQ           { some(eq) }\n-      NE             { some(ne) }\n-      ANDAND         { some(and) }\n-      OROR           { some(or) }\n-      _              { none }\n+      BINOP(PLUS)    => some(add),\n+      BINOP(MINUS)   => some(subtract),\n+      BINOP(SHL)     => some(shl),\n+      BINOP(SHR)     => some(shr),\n+      BINOP(AND)     => some(bitand),\n+      BINOP(CARET)   => some(bitxor),\n+      BINOP(OR)      => some(bitor),\n+      LT             => some(lt),\n+      LE             => some(le),\n+      GE             => some(ge),\n+      GT             => some(gt),\n+      EQEQ           => some(eq),\n+      NE             => some(ne),\n+      ANDAND         => some(and),\n+      OROR           => some(or),\n+      _              => none\n   }\n }"}, {"sha": "d69ff7f16683f4213cb9d7ff929eea47a5877769", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 102, "deletions": 97, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -103,166 +103,171 @@ enum nonterminal {\n \n fn binop_to_str(o: binop) -> ~str {\n     alt o {\n-      PLUS { ~\"+\" }\n-      MINUS { ~\"-\" }\n-      STAR { ~\"*\" }\n-      SLASH { ~\"/\" }\n-      PERCENT { ~\"%\" }\n-      CARET { ~\"^\" }\n-      AND { ~\"&\" }\n-      OR { ~\"|\" }\n-      SHL { ~\"<<\" }\n-      SHR { ~\">>\" }\n+      PLUS => ~\"+\",\n+      MINUS => ~\"-\",\n+      STAR => ~\"*\",\n+      SLASH => ~\"/\",\n+      PERCENT => ~\"%\",\n+      CARET => ~\"^\",\n+      AND => ~\"&\",\n+      OR => ~\"|\",\n+      SHL => ~\"<<\",\n+      SHR => ~\">>\"\n     }\n }\n \n fn to_str(in: interner<@~str>, t: token) -> ~str {\n     alt t {\n-      EQ { ~\"=\" }\n-      LT { ~\"<\" }\n-      LE { ~\"<=\" }\n-      EQEQ { ~\"==\" }\n-      NE { ~\"!=\" }\n-      GE { ~\">=\" }\n-      GT { ~\">\" }\n-      NOT { ~\"!\" }\n-      TILDE { ~\"~\" }\n-      OROR { ~\"||\" }\n-      ANDAND { ~\"&&\" }\n-      BINOP(op) { binop_to_str(op) }\n-      BINOPEQ(op) { binop_to_str(op) + ~\"=\" }\n+      EQ => ~\"=\",\n+      LT => ~\"<\",\n+      LE => ~\"<=\",\n+      EQEQ => ~\"==\",\n+      NE => ~\"!=\",\n+      GE => ~\">=\",\n+      GT => ~\">\",\n+      NOT => ~\"!\",\n+      TILDE => ~\"~\",\n+      OROR => ~\"||\",\n+      ANDAND => ~\"&&\",\n+      BINOP(op) => binop_to_str(op),\n+      BINOPEQ(op) => binop_to_str(op) + ~\"=\",\n \n       /* Structural symbols */\n-      AT { ~\"@\" }\n-      DOT { ~\".\" }\n-      DOTDOT { ~\"..\" }\n-      ELLIPSIS { ~\"...\" }\n-      COMMA { ~\",\" }\n-      SEMI { ~\";\" }\n-      COLON { ~\":\" }\n-      MOD_SEP { ~\"::\" }\n-      RARROW { ~\"->\" }\n-      LARROW { ~\"<-\" }\n-      DARROW { ~\"<->\" }\n-      FAT_ARROW { ~\"=>\" }\n-      LPAREN { ~\"(\" }\n-      RPAREN { ~\")\" }\n-      LBRACKET { ~\"[\" }\n-      RBRACKET { ~\"]\" }\n-      LBRACE { ~\"{\" }\n-      RBRACE { ~\"}\" }\n-      POUND { ~\"#\" }\n-      DOLLAR { ~\"$\" }\n+      AT => ~\"@\",\n+      DOT => ~\".\",\n+      DOTDOT => ~\"..\",\n+      ELLIPSIS => ~\"...\",\n+      COMMA => ~\",\",\n+      SEMI => ~\";\",\n+      COLON => ~\":\",\n+      MOD_SEP => ~\"::\",\n+      RARROW => ~\"->\",\n+      LARROW => ~\"<-\",\n+      DARROW => ~\"<->\",\n+      FAT_ARROW => ~\"=>\",\n+      LPAREN => ~\"(\",\n+      RPAREN => ~\")\",\n+      LBRACKET => ~\"[\",\n+      RBRACKET => ~\"]\",\n+      LBRACE => ~\"{\",\n+      RBRACE => ~\"}\",\n+      POUND => ~\"#\",\n+      DOLLAR => ~\"$\",\n \n       /* Literals */\n-      LIT_INT(c, ast::ty_char) {\n+      LIT_INT(c, ast::ty_char) => {\n         ~\"'\" + char::escape_default(c as char) + ~\"'\"\n       }\n-      LIT_INT(i, t) {\n+      LIT_INT(i, t) => {\n         int::to_str(i as int, 10u) + ast_util::int_ty_to_str(t)\n       }\n-      LIT_UINT(u, t) {\n+      LIT_UINT(u, t) => {\n         uint::to_str(u as uint, 10u) + ast_util::uint_ty_to_str(t)\n       }\n-      LIT_INT_UNSUFFIXED(i) {\n+      LIT_INT_UNSUFFIXED(i) => {\n         int::to_str(i as int, 10u)\n       }\n-      LIT_FLOAT(s, t) {\n+      LIT_FLOAT(s, t) => {\n         let mut body = *in.get(s);\n         if body.ends_with(~\".\") {\n             body = body + ~\"0\";  // `10.f` is not a float literal\n         }\n         body + ast_util::float_ty_to_str(t)\n       }\n-      LIT_STR(s) { ~\"\\\"\" + str::escape_default( *in.get(s)) + ~\"\\\"\" }\n+      LIT_STR(s) => { ~\"\\\"\" + str::escape_default( *in.get(s)) + ~\"\\\"\" }\n \n       /* Name components */\n-      IDENT(s, _) { *in.get(s) }\n+      IDENT(s, _) => *in.get(s),\n \n-      UNDERSCORE { ~\"_\" }\n+      UNDERSCORE => ~\"_\",\n \n       /* Other */\n-      DOC_COMMENT(s) { *in.get(s) }\n-      EOF { ~\"<eof>\" }\n-      INTERPOLATED(nt) {\n+      DOC_COMMENT(s) => *in.get(s),\n+      EOF => ~\"<eof>\",\n+      INTERPOLATED(nt) => {\n         ~\"an interpolated \" +\n             alt nt {\n-              nt_item(*) { ~\"item\" } nt_block(*) { ~\"block\" }\n-              nt_stmt(*) { ~\"statement\" } nt_pat(*) { ~\"pattern\" }\n-              nt_expr(*) { ~\"expression\" } nt_ty(*) { ~\"type\" }\n-              nt_ident(*) { ~\"identifier\" } nt_path(*) { ~\"path\" }\n-              nt_tt(*) { ~\"tt\" } nt_matchers(*) { ~\"matcher sequence\" }\n+              nt_item(*) => ~\"item\",\n+              nt_block(*) => ~\"block\",\n+              nt_stmt(*) => ~\"statement\",\n+              nt_pat(*) => ~\"pattern\",\n+              nt_expr(*) => ~\"expression\",\n+              nt_ty(*) => ~\"type\",\n+              nt_ident(*) => ~\"identifier\",\n+              nt_path(*) => ~\"path\",\n+              nt_tt(*) => ~\"tt\",\n+              nt_matchers(*) => ~\"matcher sequence\"\n             }\n       }\n     }\n }\n \n pure fn can_begin_expr(t: token) -> bool {\n     alt t {\n-      LPAREN { true }\n-      LBRACE { true }\n-      LBRACKET { true }\n-      IDENT(_, _) { true }\n-      UNDERSCORE { true }\n-      TILDE { true }\n-      LIT_INT(_, _) { true }\n-      LIT_UINT(_, _) { true }\n-      LIT_INT_UNSUFFIXED(_) { true }\n-      LIT_FLOAT(_, _) { true }\n-      LIT_STR(_) { true }\n-      POUND { true }\n-      AT { true }\n-      NOT { true }\n-      BINOP(MINUS) { true }\n-      BINOP(STAR) { true }\n-      BINOP(AND) { true }\n-      BINOP(OR) { true } // in lambda syntax\n-      OROR { true } // in lambda syntax\n-      MOD_SEP { true }\n+      LPAREN => true,\n+      LBRACE => true,\n+      LBRACKET => true,\n+      IDENT(_, _) => true,\n+      UNDERSCORE => true,\n+      TILDE => true,\n+      LIT_INT(_, _) => true,\n+      LIT_UINT(_, _) => true,\n+      LIT_INT_UNSUFFIXED(_) => true,\n+      LIT_FLOAT(_, _) => true,\n+      LIT_STR(_) => true,\n+      POUND => true,\n+      AT => true,\n+      NOT => true,\n+      BINOP(MINUS) => true,\n+      BINOP(STAR) => true,\n+      BINOP(AND) => true,\n+      BINOP(OR) => true, // in lambda syntax\n+      OROR => true, // in lambda syntax\n+      MOD_SEP => true,\n       INTERPOLATED(nt_expr(*))\n       | INTERPOLATED(nt_ident(*))\n       | INTERPOLATED(nt_block(*))\n-      | INTERPOLATED(nt_path(*)) { true }\n-      _ { false }\n+      | INTERPOLATED(nt_path(*)) => true,\n+      _ => false\n     }\n }\n \n /// what's the opposite delimiter?\n fn flip_delimiter(&t: token::token) -> token::token {\n     alt t {\n-      token::LPAREN { token::RPAREN }\n-      token::LBRACE { token::RBRACE }\n-      token::LBRACKET { token::RBRACKET }\n-      token::RPAREN { token::LPAREN }\n-      token::RBRACE { token::LBRACE }\n-      token::RBRACKET { token::LBRACKET }\n-      _ { fail }\n+      token::LPAREN => token::RPAREN,\n+      token::LBRACE => token::RBRACE,\n+      token::LBRACKET => token::RBRACKET,\n+      token::RPAREN => token::LPAREN,\n+      token::RBRACE => token::LBRACE,\n+      token::RBRACKET => token::LBRACKET,\n+      _ => fail\n     }\n }\n \n \n \n fn is_lit(t: token) -> bool {\n     alt t {\n-      LIT_INT(_, _) { true }\n-      LIT_UINT(_, _) { true }\n-      LIT_INT_UNSUFFIXED(_) { true }\n-      LIT_FLOAT(_, _) { true }\n-      LIT_STR(_) { true }\n-      _ { false }\n+      LIT_INT(_, _) => true,\n+      LIT_UINT(_, _) => true,\n+      LIT_INT_UNSUFFIXED(_) => true,\n+      LIT_FLOAT(_, _) => true,\n+      LIT_STR(_) => true,\n+      _ => false\n     }\n }\n \n pure fn is_ident(t: token) -> bool {\n-    alt t { IDENT(_, _) { true } _ { false } }\n+    alt t { IDENT(_, _) => true, _ => false }\n }\n \n pure fn is_plain_ident(t: token) -> bool {\n-    alt t { IDENT(_, false) { true } _ { false } }\n+    alt t { IDENT(_, false) => true, _ => false }\n }\n \n pure fn is_bar(t: token) -> bool {\n-    alt t { BINOP(OR) | OROR { true } _ { false } }\n+    alt t { BINOP(OR) | OROR => true, _ => false }\n }\n \n /**"}, {"sha": "12ef7149f6be98b9971276e14fd3fa7bf0a70676", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -63,11 +63,11 @@ enum token { STRING(@~str, int), BREAK(break_t), BEGIN(begin_t), END, EOF, }\n \n fn tok_str(++t: token) -> ~str {\n     alt t {\n-      STRING(s, len) { return fmt!{\"STR(%s,%d)\", *s, len}; }\n-      BREAK(_) { return ~\"BREAK\"; }\n-      BEGIN(_) { return ~\"BEGIN\"; }\n-      END { return ~\"END\"; }\n-      EOF { return ~\"EOF\"; }\n+      STRING(s, len) => return fmt!{\"STR(%s,%d)\", *s, len},\n+      BREAK(_) => return ~\"BREAK\",\n+      BEGIN(_) => return ~\"BEGIN\",\n+      END => return ~\"END\",\n+      EOF => return ~\"EOF\"\n     }\n }\n \n@@ -239,15 +239,15 @@ impl printer for printer {\n     fn pretty_print(t: token) {\n         debug!{\"pp ~[%u,%u]\", self.left, self.right};\n         alt t {\n-          EOF {\n+          EOF => {\n             if !self.scan_stack_empty {\n                 self.check_stack(0);\n                 self.advance_left(self.token[self.left],\n                                   self.size[self.left]);\n             }\n             self.indent(0);\n           }\n-          BEGIN(b) {\n+          BEGIN(b) => {\n             if self.scan_stack_empty {\n                 self.left_total = 1;\n                 self.right_total = 1;\n@@ -259,7 +259,7 @@ impl printer for printer {\n             self.size[self.right] = -self.right_total;\n             self.scan_push(self.right);\n           }\n-          END {\n+          END => {\n             if self.scan_stack_empty {\n                 debug!{\"pp END/print ~[%u,%u]\", self.left, self.right};\n                 self.print(t, 0);\n@@ -271,7 +271,7 @@ impl printer for printer {\n                 self.scan_push(self.right);\n             }\n           }\n-          BREAK(b) {\n+          BREAK(b) => {\n             if self.scan_stack_empty {\n                 self.left_total = 1;\n                 self.right_total = 1;\n@@ -285,7 +285,7 @@ impl printer for printer {\n             self.size[self.right] = -self.right_total;\n             self.right_total += b.blank_space;\n           }\n-          STRING(s, len) {\n+          STRING(s, len) => {\n             if self.scan_stack_empty {\n                 debug!{\"pp STRING/print ~[%u,%u]\", self.left, self.right};\n                 self.print(t, len);\n@@ -358,9 +358,9 @@ impl printer for printer {\n         if L >= 0 {\n             self.print(x, L);\n             alt x {\n-              BREAK(b) { self.left_total += b.blank_space; }\n-              STRING(_, len) { assert (len == L); self.left_total += len; }\n-              _ { }\n+              BREAK(b) => self.left_total += b.blank_space,\n+              STRING(_, len) => { assert (len == L); self.left_total += len; }\n+              _ => ()\n             }\n             if self.left != self.right {\n                 self.left += 1u;\n@@ -374,19 +374,19 @@ impl printer for printer {\n         if !self.scan_stack_empty {\n             let x = self.scan_top();\n             alt copy self.token[x] {\n-              BEGIN(b) {\n+              BEGIN(b) => {\n                 if k > 0 {\n                     self.size[self.scan_pop()] = self.size[x] +\n                         self.right_total;\n                     self.check_stack(k - 1);\n                 }\n               }\n-              END {\n+              END => {\n                 // paper says + not =, but that makes no sense.\n                 self.size[self.scan_pop()] = 1;\n                 self.check_stack(k + 1);\n               }\n-              _ {\n+              _ => {\n                 self.size[self.scan_pop()] = self.size[x] + self.right_total;\n                 if k > 0 { self.check_stack(k); }\n               }\n@@ -423,7 +423,7 @@ impl printer for printer {\n                self.space};\n         log(debug, buf_str(self.token, self.size, self.left, self.right, 6u));\n         alt x {\n-          BEGIN(b) {\n+          BEGIN(b) => {\n             if L > self.space {\n                 let col = self.margin - self.space + b.offset;\n                 debug!{\"print BEGIN -> push broken block at col %d\", col};\n@@ -435,25 +435,25 @@ impl printer for printer {\n                                        pbreak: fits});\n             }\n           }\n-          END {\n+          END => {\n             debug!{\"print END -> pop END\"};\n             assert (self.print_stack.len() != 0u);\n             self.print_stack.pop();\n           }\n-          BREAK(b) {\n+          BREAK(b) => {\n             let top = self.get_top();\n             alt top.pbreak {\n-              fits {\n+              fits => {\n                 debug!{\"print BREAK in fitting block\"};\n                 self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n               }\n-              broken(consistent) {\n+              broken(consistent) => {\n                 debug!{\"print BREAK in consistent block\"};\n                 self.print_newline(top.offset + b.offset);\n                 self.space = self.margin - (top.offset + b.offset);\n               }\n-              broken(inconsistent) {\n+              broken(inconsistent) => {\n                 if L > self.space {\n                     debug!{\"print BREAK w/ newline in inconsistent\"};\n                     self.print_newline(top.offset + b.offset);\n@@ -466,14 +466,14 @@ impl printer for printer {\n               }\n             }\n           }\n-          STRING(s, len) {\n+          STRING(s, len) => {\n             debug!{\"print STRING\"};\n             assert (L == len);\n             // assert L <= space;\n             self.space -= len;\n             self.print_str(*s);\n           }\n-          EOF {\n+          EOF => {\n             // EOF should never get here.\n             fail;\n           }"}, {"sha": "c81b8b5335f1214e41ce154020cda0b275b7715c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 245, "deletions": 249, "changes": 494, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -222,11 +222,11 @@ fn bclose_(s: ps, span: codemap::span, indented: uint) {\n fn bclose(s: ps, span: codemap::span) { bclose_(s, span, indent_unit); }\n \n fn is_begin(s: ps) -> bool {\n-    alt s.s.last_token() { pp::BEGIN(_) { true } _ { false } }\n+    alt s.s.last_token() { pp::BEGIN(_) => true, _ => false }\n }\n \n fn is_end(s: ps) -> bool {\n-    alt s.s.last_token() { pp::END { true } _ { false } }\n+    alt s.s.last_token() { pp::END => true, _ => false }\n }\n \n fn is_bol(s: ps) -> bool {\n@@ -319,8 +319,8 @@ fn print_foreign_mod(s: ps, nmod: ast::foreign_mod,\n \n fn print_region(s: ps, region: @ast::region) {\n     alt region.node {\n-      ast::re_anon { word_space(s, ~\"&\"); }\n-      ast::re_named(name) {\n+      ast::re_anon => word_space(s, ~\"&\"),\n+      ast::re_named(name) => {\n         word(s.s, ~\"&\");\n         word(s.s, *name);\n       }\n@@ -335,29 +335,29 @@ fn print_type_ex(s: ps, &&ty: @ast::ty, print_colons: bool) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     alt ty.node {\n-      ast::ty_nil { word(s.s, ~\"()\"); }\n-      ast::ty_bot { word(s.s, ~\"!\"); }\n-      ast::ty_box(mt) { word(s.s, ~\"@\"); print_mt(s, mt); }\n-      ast::ty_uniq(mt) { word(s.s, ~\"~\"); print_mt(s, mt); }\n-      ast::ty_vec(mt) {\n+      ast::ty_nil => word(s.s, ~\"()\"),\n+      ast::ty_bot => word(s.s, ~\"!\"),\n+      ast::ty_box(mt) => { word(s.s, ~\"@\"); print_mt(s, mt); }\n+      ast::ty_uniq(mt) => { word(s.s, ~\"~\"); print_mt(s, mt); }\n+      ast::ty_vec(mt) => {\n         word(s.s, ~\"[\");\n         alt mt.mutbl {\n-          ast::m_mutbl { word_space(s, ~\"mut\"); }\n-          ast::m_const { word_space(s, ~\"const\"); }\n-          ast::m_imm { }\n+          ast::m_mutbl => word_space(s, ~\"mut\"),\n+          ast::m_const => word_space(s, ~\"const\"),\n+          ast::m_imm => ()\n         }\n         print_type(s, mt.ty);\n         word(s.s, ~\"]\");\n       }\n-      ast::ty_ptr(mt) { word(s.s, ~\"*\"); print_mt(s, mt); }\n-      ast::ty_rptr(region, mt) {\n+      ast::ty_ptr(mt) => { word(s.s, ~\"*\"); print_mt(s, mt); }\n+      ast::ty_rptr(region, mt) => {\n         alt region.node {\n-          ast::re_anon { word(s.s, ~\"&\"); }\n-          _ { print_region(s, region); word(s.s, ~\"/\"); }\n+          ast::re_anon => word(s.s, ~\"&\"),\n+          _ => { print_region(s, region); word(s.s, ~\"/\"); }\n         }\n         print_mt(s, mt);\n       }\n-      ast::ty_rec(fields) {\n+      ast::ty_rec(fields) => {\n         word(s.s, ~\"{\");\n         fn print_field(s: ps, f: ast::ty_field) {\n             cbox(s, indent_unit);\n@@ -371,24 +371,24 @@ fn print_type_ex(s: ps, &&ty: @ast::ty, print_colons: bool) {\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         word(s.s, ~\",}\");\n       }\n-      ast::ty_tup(elts) {\n+      ast::ty_tup(elts) => {\n         popen(s);\n         commasep(s, inconsistent, elts, print_type);\n         pclose(s);\n       }\n-      ast::ty_fn(proto, d) {\n+      ast::ty_fn(proto, d) => {\n         print_ty_fn(s, some(proto), d, none, none);\n       }\n-      ast::ty_path(path, _) { print_path(s, path, print_colons); }\n-      ast::ty_fixed_length(t, v) {\n+      ast::ty_path(path, _) => print_path(s, path, print_colons),\n+      ast::ty_fixed_length(t, v) => {\n         print_type(s, t);\n         word(s.s, ~\"/\");\n         print_vstore(s, ast::vstore_fixed(v));\n       }\n-      ast::ty_mac(_) {\n+      ast::ty_mac(_) => {\n           fail ~\"print_type doesn't know how to print a ty_mac\";\n       }\n-      ast::ty_infer {\n+      ast::ty_infer => {\n           fail ~\"print_type shouldn't see a ty_infer\";\n       }\n \n@@ -401,7 +401,7 @@ fn print_foreign_item(s: ps, item: @ast::foreign_item) {\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n     alt item.node {\n-      ast::foreign_item_fn(decl, typarams) {\n+      ast::foreign_item_fn(decl, typarams) => {\n         print_fn(s, decl, item.ident, typarams);\n         end(s); // end head-ibox\n         word(s.s, ~\";\");\n@@ -417,7 +417,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n     let ann_node = node_item(s, item);\n     s.ann.pre(ann_node);\n     alt item.node {\n-      ast::item_const(ty, expr) {\n+      ast::item_const(ty, expr) => {\n         head(s, ~\"const\");\n         word_space(s, *item.ident + ~\":\");\n         print_type(s, ty);\n@@ -430,27 +430,27 @@ fn print_item(s: ps, &&item: @ast::item) {\n         end(s); // end the outer cbox\n \n       }\n-      ast::item_fn(decl, typarams, body) {\n+      ast::item_fn(decl, typarams, body) => {\n         print_fn(s, decl, item.ident, typarams);\n         word(s.s, ~\" \");\n         print_block_with_attrs(s, body, item.attrs);\n       }\n-      ast::item_mod(_mod) {\n+      ast::item_mod(_mod) => {\n         head(s, ~\"mod\");\n         word_nbsp(s, *item.ident);\n         bopen(s);\n         print_mod(s, _mod, item.attrs);\n         bclose(s, item.span);\n       }\n-      ast::item_foreign_mod(nmod) {\n+      ast::item_foreign_mod(nmod) => {\n         head(s, ~\"extern\");\n         word_nbsp(s, ~\"mod\");\n         word_nbsp(s, *item.ident);\n         bopen(s);\n         print_foreign_mod(s, nmod, item.attrs);\n         bclose(s, item.span);\n       }\n-      ast::item_ty(ty, params) {\n+      ast::item_ty(ty, params) => {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n         word_nbsp(s, ~\"type\");\n@@ -464,7 +464,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         word(s.s, ~\";\");\n         end(s); // end the outer ibox\n       }\n-      ast::item_enum(variants, params) {\n+      ast::item_enum(variants, params) => {\n         let newtype =\n             vec::len(variants) == 1u &&\n                 str::eq(item.ident, variants[0].node.name) &&\n@@ -497,7 +497,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n             bclose(s, item.span);\n         }\n       }\n-      ast::item_class(tps, traits, items, m_ctor, m_dtor) {\n+      ast::item_class(tps, traits, items, m_ctor, m_dtor) => {\n           head(s, ~\"class\");\n           word_nbsp(s, *item.ident);\n           print_type_params(s, tps);\n@@ -539,37 +539,37 @@ fn print_item(s: ps, &&item: @ast::item) {\n              maybe_print_comment(s, ci.span.lo);\n              let pr = ast_util::class_member_visibility(ci);\n              alt pr {\n-                ast::private {\n+                ast::private => {\n                     head(s, ~\"priv\");\n                     bopen(s);\n                     hardbreak_if_not_bol(s);\n                 }\n-                _ {}\n+                _ => ()\n              }\n              alt ci.node {\n-                ast::instance_var(nm, t, mt, _,_) {\n+                ast::instance_var(nm, t, mt, _,_) => {\n                     word_nbsp(s, ~\"let\");\n                     alt mt {\n-                      ast::class_mutable { word_nbsp(s, ~\"mut\"); }\n-                      _ {}\n+                      ast::class_mutable => word_nbsp(s, ~\"mut\"),\n+                      _ => ()\n                     }\n                     word(s.s, *nm);\n                     word_nbsp(s, ~\":\");\n                     print_type(s, t);\n                     word(s.s, ~\";\");\n                 }\n-                ast::class_method(m) {\n+                ast::class_method(m) => {\n                     print_method(s, m);\n                 }\n              }\n              alt pr {\n-                 ast::private { bclose(s, ci.span); }\n-                 _ {}\n+                 ast::private => bclose(s, ci.span),\n+                 _ => ()\n              }\n           }\n           bclose(s, item.span);\n        }\n-      ast::item_impl(tps, traits, ty, methods) {\n+      ast::item_impl(tps, traits, ty, methods) => {\n         head(s, ~\"impl\");\n         word(s.s, *item.ident);\n         print_type_params(s, tps);\n@@ -590,7 +590,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         }\n         bclose(s, item.span);\n       }\n-      ast::item_trait(tps, traits, methods) {\n+      ast::item_trait(tps, traits, methods) => {\n         head(s, ~\"trait\");\n         word(s.s, *item.ident);\n         print_type_params(s, tps);\n@@ -604,13 +604,13 @@ fn print_item(s: ps, &&item: @ast::item) {\n         for methods.each |meth| { print_trait_method(s, meth); }\n         bclose(s, item.span);\n       }\n-      ast::item_mac({node: ast::mac_invoc_tt(pth, tts), _}) {\n+      ast::item_mac({node: ast::mac_invoc_tt(pth, tts), _}) => {\n         head(s, path_to_str(pth) + ~\"! \" + *item.ident);\n         bopen(s);\n         for tts.each |tt| { print_tt(s, tt);  }\n         bclose(s, item.span);\n       }\n-      ast::item_mac(_) {\n+      ast::item_mac(_) => {\n         fail ~\"invalid item-position syntax bit\"\n       }\n     }\n@@ -626,31 +626,29 @@ fn print_item(s: ps, &&item: @ast::item) {\n /// expression arguments as expressions). It can be done! I think.\n fn print_tt(s: ps, tt: ast::token_tree) {\n     alt tt {\n-      ast::tt_delim(tts) {\n-        for tts.each() |tt_elt| { print_tt(s, tt_elt); }\n-      }\n-      ast::tt_tok(_, tk) {\n+      ast::tt_delim(tts) => for tts.each() |tt_elt| { print_tt(s, tt_elt); }\n+      ast::tt_tok(_, tk) => {\n         alt tk {\n-          parse::token::IDENT(*) { // don't let idents run together\n+          parse::token::IDENT(*) => { // don't let idents run together\n             if s.s.token_tree_last_was_ident { word(s.s, ~\" \") }\n             s.s.token_tree_last_was_ident = true;\n           }\n-          _ { s.s.token_tree_last_was_ident = false; }\n+          _ => { s.s.token_tree_last_was_ident = false; }\n         }\n         word(s.s, parse::token::to_str(*s.intr, tk));\n       }\n-      ast::tt_seq(_, tts, sep, zerok) {\n+      ast::tt_seq(_, tts, sep, zerok) => {\n         word(s.s, ~\"$(\");\n         for tts.each() |tt_elt| { print_tt(s, tt_elt); }\n         word(s.s, ~\")\");\n         alt sep {\n-          some(tk) { word(s.s, parse::token::to_str(*s.intr, tk)); }\n-          none {}\n+          some(tk) => word(s.s, parse::token::to_str(*s.intr, tk)),\n+          none => ()\n         }\n         word(s.s, if zerok { ~\"*\" } else { ~\"+\" });\n         s.s.token_tree_last_was_ident = false;\n       }\n-      ast::tt_nonterminal(_, name) {\n+      ast::tt_nonterminal(_, name) => {\n         word(s.s, ~\"$\" + *name);\n         s.s.token_tree_last_was_ident = true;\n       }\n@@ -668,12 +666,12 @@ fn print_variant(s: ps, v: ast::variant) {\n         pclose(s);\n     }\n     alt v.node.disr_expr {\n-      some(d) {\n+      some(d) => {\n         space(s.s);\n         word_space(s, ~\"=\");\n         print_expr(s, d);\n       }\n-      _ {}\n+      _ => ()\n     }\n }\n \n@@ -687,8 +685,8 @@ fn print_ty_method(s: ps, m: ast::ty_method) {\n \n fn print_trait_method(s: ps, m: ast::trait_method) {\n     alt m {\n-      required(ty_m) { print_ty_method(s, ty_m) }\n-      provided(m)    { print_method(s, m) }\n+      required(ty_m) => print_ty_method(s, ty_m),\n+      provided(m)    => print_method(s, m)\n     }\n }\n \n@@ -705,8 +703,8 @@ fn print_outer_attributes(s: ps, attrs: ~[ast::attribute]) {\n     let mut count = 0;\n     for attrs.each |attr| {\n         alt attr.node.style {\n-          ast::attr_outer { print_attribute(s, attr); count += 1; }\n-          _ {/* fallthrough */ }\n+          ast::attr_outer => { print_attribute(s, attr); count += 1; }\n+          _ => {/* fallthrough */ }\n         }\n     }\n     if count > 0 { hardbreak_if_not_bol(s); }\n@@ -716,14 +714,14 @@ fn print_inner_attributes(s: ps, attrs: ~[ast::attribute]) {\n     let mut count = 0;\n     for attrs.each |attr| {\n         alt attr.node.style {\n-          ast::attr_inner {\n+          ast::attr_inner => {\n             print_attribute(s, attr);\n             if !attr.node.is_sugared_doc {\n                 word(s.s, ~\";\");\n             }\n             count += 1;\n           }\n-          _ {/* fallthrough */ }\n+          _ => {/* fallthrough */ }\n         }\n     }\n     if count > 0 { hardbreak_if_not_bol(s); }\n@@ -747,14 +745,14 @@ fn print_attribute(s: ps, attr: ast::attribute) {\n fn print_stmt(s: ps, st: ast::stmt) {\n     maybe_print_comment(s, st.span.lo);\n     alt st.node {\n-      ast::stmt_decl(decl, _) {\n+      ast::stmt_decl(decl, _) => {\n         print_decl(s, decl);\n       }\n-      ast::stmt_expr(expr, _) {\n+      ast::stmt_expr(expr, _) => {\n         space_if_not_bol(s);\n         print_expr(s, expr);\n       }\n-      ast::stmt_semi(expr, _) {\n+      ast::stmt_semi(expr, _) => {\n         space_if_not_bol(s);\n         print_expr(s, expr);\n         word(s.s, ~\";\");\n@@ -783,16 +781,16 @@ fn print_possibly_embedded_block(s: ps, blk: ast::blk, embedded: embed_type,\n fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n                                   indented: uint, attrs: ~[ast::attribute]) {\n     alt blk.node.rules {\n-      ast::unchecked_blk { word(s.s, ~\"unchecked\"); }\n-      ast::unsafe_blk { word(s.s, ~\"unsafe\"); }\n-      ast::default_blk { }\n+      ast::unchecked_blk => word(s.s, ~\"unchecked\"),\n+      ast::unsafe_blk => word(s.s, ~\"unsafe\"),\n+      ast::default_blk => ()\n     }\n     maybe_print_comment(s, blk.span.lo);\n     let ann_node = node_block(s, blk);\n     s.ann.pre(ann_node);\n     alt embedded {\n-      block_block_fn { end(s); }\n-      block_normal { bopen(s); }\n+      block_block_fn => end(s),\n+      block_normal => bopen(s)\n     }\n \n     print_inner_attributes(s, attrs);\n@@ -802,12 +800,12 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n         print_stmt(s, *st);\n     }\n     alt blk.node.expr {\n-      some(expr) {\n+      some(expr) => {\n         space_if_not_bol(s);\n         print_expr(s, expr);\n         maybe_print_trailing_comment(s, expr.span, some(blk.span.hi));\n       }\n-      _ { }\n+      _ => ()\n     }\n     bclose_(s, blk.span, indented);\n     s.ann.post(ann_node);\n@@ -817,8 +815,8 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n // alt, do, & while unambiguously without being parenthesized\n fn print_maybe_parens_discrim(s: ps, e: @ast::expr) {\n     let disambig = alt e.node {\n-      ast::expr_ret(none) | ast::expr_fail(none) { true }\n-      _ { false }\n+      ast::expr_ret(none) | ast::expr_fail(none) => true,\n+      _ => false\n     };\n     if disambig { popen(s); }\n     print_expr(s, e);\n@@ -834,10 +832,10 @@ fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n     print_block(s, blk);\n     fn do_else(s: ps, els: option<@ast::expr>) {\n         alt els {\n-          some(_else) {\n+          some(_else) => {\n             alt _else.node {\n               // \"another else-if\"\n-              ast::expr_if(i, t, e) {\n+              ast::expr_if(i, t, e) => {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n                 word(s.s, ~\" else if \");\n@@ -847,65 +845,63 @@ fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n                 do_else(s, e);\n               }\n               // \"final else\"\n-              ast::expr_block(b) {\n+              ast::expr_block(b) => {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n                 word(s.s, ~\" else \");\n                 print_block(s, b);\n               }\n               // BLEAH, constraints would be great here\n-              _ {\n+              _ => {\n                   fail ~\"print_if saw if with weird alternative\";\n               }\n             }\n           }\n-          _ {/* fall through */ }\n+          _ => {/* fall through */ }\n         }\n     }\n     do_else(s, elseopt);\n }\n \n fn print_mac(s: ps, m: ast::mac) {\n     alt m.node {\n-      ast::mac_invoc(path, arg, body) {\n+      ast::mac_invoc(path, arg, body) => {\n         word(s.s, ~\"#\");\n         print_path(s, path, false);\n         alt arg {\n-          some(@{node: ast::expr_vec(_, _), _}) { }\n-          _ { word(s.s, ~\" \"); }\n+          some(@{node: ast::expr_vec(_, _), _}) => (),\n+          _ => word(s.s, ~\" \")\n         }\n         option::iter(arg, |a| print_expr(s, a));\n         // FIXME: extension 'body' (#2339)\n       }\n-      ast::mac_invoc_tt(pth, tts) {\n+      ast::mac_invoc_tt(pth, tts) => {\n         head(s, path_to_str(pth) + ~\"!\");\n         bopen(s);\n         for tts.each() |tt| { print_tt(s, tt); }\n         bclose(s, m.span);\n       }\n-      ast::mac_ellipsis { word(s.s, ~\"...\"); }\n-      ast::mac_var(v) { word(s.s, fmt!{\"$%u\", v}); }\n-      _ { /* fixme */ }\n+      ast::mac_ellipsis => word(s.s, ~\"...\"),\n+      ast::mac_var(v) => word(s.s, fmt!{\"$%u\", v}),\n+      _ => { /* fixme */ }\n     }\n }\n \n fn print_vstore(s: ps, t: ast::vstore) {\n     alt t {\n-      ast::vstore_fixed(some(i)) { word(s.s, fmt!{\"%u\", i}); }\n-      ast::vstore_fixed(none) { word(s.s, ~\"_\"); }\n-      ast::vstore_uniq { word(s.s, ~\"~\"); }\n-      ast::vstore_box { word(s.s, ~\"@\"); }\n-      ast::vstore_slice(r) {\n-          alt r.node {\n-            ast::re_anon { word(s.s, ~\"&\"); }\n-            ast::re_named(name) {\n-                word(s.s, ~\"&\");\n-                word(s.s, *name);\n-                word(s.s, ~\".\");\n-            }\n-          }\n+      ast::vstore_fixed(some(i)) => word(s.s, fmt!{\"%u\", i}),\n+      ast::vstore_fixed(none) => word(s.s, ~\"_\"),\n+      ast::vstore_uniq => word(s.s, ~\"~\"),\n+      ast::vstore_box => word(s.s, ~\"@\"),\n+      ast::vstore_slice(r) => alt r.node {\n+        ast::re_anon => word(s.s, ~\"&\"),\n+        ast::re_named(name) => {\n+            word(s.s, ~\"&\");\n+            word(s.s, *name);\n+            word(s.s, ~\".\");\n+        }\n       }\n-   }\n+    }\n }\n \n fn print_expr(s: ps, &&expr: @ast::expr) {\n@@ -924,20 +920,18 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n     let ann_node = node_expr(s, expr);\n     s.ann.pre(ann_node);\n     alt expr.node {\n-      ast::expr_vstore(e, v) {\n-        alt v {\n-          ast::vstore_fixed(_) {\n+      ast::expr_vstore(e, v) => alt v {\n+        ast::vstore_fixed(_) => {\n             print_expr(s, e);\n-            word(s.s, ~\"/\");\n-            print_vstore(s, v);\n+              word(s.s, ~\"/\");\n+              print_vstore(s, v);\n           }\n-          _ {\n+        _ => {\n             print_vstore(s, v);\n-            print_expr(s, e);\n+              print_expr(s, e);\n           }\n-        }\n       }\n-      ast::expr_vec(exprs, mutbl) {\n+      ast::expr_vec(exprs, mutbl) => {\n         ibox(s, indent_unit);\n         word(s.s, ~\"[\");\n         if mutbl == ast::m_mutbl {\n@@ -964,41 +958,41 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         end(s);\n       }\n \n-      ast::expr_rec(fields, wth) {\n+      ast::expr_rec(fields, wth) => {\n         word(s.s, ~\"{\");\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         alt wth {\n-          some(expr) {\n+          some(expr) => {\n             if vec::len(fields) > 0u { space(s.s); }\n             ibox(s, indent_unit);\n             word_space(s, ~\"with\");\n             print_expr(s, expr);\n             end(s);\n           }\n-          _ { word(s.s, ~\",\"); }\n+          _ => word(s.s, ~\",\")\n         }\n         word(s.s, ~\"}\");\n       }\n-      ast::expr_struct(path, fields) {\n+      ast::expr_struct(path, fields) => {\n         print_path(s, path, true);\n         word(s.s, ~\"{\");\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         word(s.s, ~\",\");\n         word(s.s, ~\"}\");\n       }\n-      ast::expr_tup(exprs) {\n+      ast::expr_tup(exprs) => {\n         popen(s);\n         commasep_exprs(s, inconsistent, exprs);\n         pclose(s);\n       }\n-      ast::expr_call(func, args, has_block) {\n+      ast::expr_call(func, args, has_block) => {\n         let mut base_args = args;\n         let blk = if has_block {\n             let blk_arg = vec::pop(base_args);\n             alt blk_arg.node {\n-              ast::expr_loop_body(_) { word_nbsp(s, ~\"for\"); }\n-              ast::expr_do_body(_) { word_nbsp(s, ~\"do\"); }\n-              _ {}\n+              ast::expr_loop_body(_) => word_nbsp(s, ~\"for\"),\n+              ast::expr_do_body(_) => word_nbsp(s, ~\"do\"),\n+              _ => ()\n             }\n             some(blk_arg)\n         } else { none };\n@@ -1013,44 +1007,44 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n             print_expr(s, option::get(blk));\n         }\n       }\n-      ast::expr_binary(op, lhs, rhs) {\n+      ast::expr_binary(op, lhs, rhs) => {\n         let prec = operator_prec(op);\n         print_op_maybe_parens(s, lhs, prec);\n         space(s.s);\n         word_space(s, ast_util::binop_to_str(op));\n         print_op_maybe_parens(s, rhs, prec + 1u);\n       }\n-      ast::expr_unary(op, expr) {\n+      ast::expr_unary(op, expr) => {\n         word(s.s, ast_util::unop_to_str(op));\n         print_op_maybe_parens(s, expr, parse::prec::unop_prec);\n       }\n-      ast::expr_addr_of(m, expr) {\n+      ast::expr_addr_of(m, expr) => {\n         word(s.s, ~\"&\");\n         print_mutability(s, m);\n         print_expr(s, expr);\n       }\n-      ast::expr_lit(lit) { print_literal(s, lit); }\n-      ast::expr_cast(expr, ty) {\n+      ast::expr_lit(lit) => print_literal(s, lit),\n+      ast::expr_cast(expr, ty) => {\n         print_op_maybe_parens(s, expr, parse::prec::as_prec);\n         space(s.s);\n         word_space(s, ~\"as\");\n         print_type_ex(s, ty, true);\n       }\n-      ast::expr_if(test, blk, elseopt) {\n+      ast::expr_if(test, blk, elseopt) => {\n         print_if(s, test, blk, elseopt, false);\n       }\n-      ast::expr_while(test, blk) {\n+      ast::expr_while(test, blk) => {\n         head(s, ~\"while\");\n         print_maybe_parens_discrim(s, test);\n         space(s.s);\n         print_block(s, blk);\n       }\n-      ast::expr_loop(blk) {\n+      ast::expr_loop(blk) => {\n         head(s, ~\"loop\");\n         space(s.s);\n         print_block(s, blk);\n       }\n-      ast::expr_alt(expr, arms, mode) {\n+      ast::expr_alt(expr, arms, mode) => {\n         cbox(s, alt_indent_unit);\n         ibox(s, 4u);\n         word_nbsp(s, ~\"alt\");\n@@ -1072,8 +1066,12 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n             }\n             space(s.s);\n             alt arm.guard {\n-              some(e) { word_space(s, ~\"if\"); print_expr(s, e); space(s.s); }\n-              none { }\n+              some(e) => {\n+                word_space(s, ~\"if\");\n+                print_expr(s, e);\n+                space(s.s);\n+              }\n+              none => ()\n             }\n             word_space(s, ~\"=>\");\n             // Extract the expression from the extra block the parser adds\n@@ -1095,7 +1093,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         }\n         bclose_(s, expr.span, alt_indent_unit);\n       }\n-      ast::expr_fn(proto, decl, body, cap_clause) {\n+      ast::expr_fn(proto, decl, body, cap_clause) => {\n         // containing cbox, will be closed by print-block at }\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block at start\n@@ -1106,55 +1104,55 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         space(s.s);\n         print_block(s, body);\n       }\n-      ast::expr_fn_block(decl, body, cap_clause) {\n+      ast::expr_fn_block(decl, body, cap_clause) => {\n         print_fn_block_args(s, decl, *cap_clause);\n         // The parser always adds an extra implicit block around lambdas\n         assert body.node.stmts.is_empty();\n         assert body.node.expr.is_some();\n         space(s.s);\n         print_expr(s, body.node.expr.get());\n       }\n-      ast::expr_loop_body(body) {\n+      ast::expr_loop_body(body) => {\n         print_expr(s, body);\n       }\n-      ast::expr_do_body(body) {\n+      ast::expr_do_body(body) => {\n         print_expr(s, body);\n       }\n-      ast::expr_block(blk) {\n+      ast::expr_block(blk) => {\n         // containing cbox, will be closed by print-block at }\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block after {\n         ibox(s, 0u);\n         print_block(s, blk);\n       }\n-      ast::expr_copy(e) { word_space(s, ~\"copy\"); print_expr(s, e); }\n-      ast::expr_unary_move(e) { word_space(s, ~\"move\"); print_expr(s, e); }\n-      ast::expr_move(lhs, rhs) {\n+      ast::expr_copy(e) => { word_space(s, ~\"copy\"); print_expr(s, e); }\n+      ast::expr_unary_move(e) => { word_space(s, ~\"move\"); print_expr(s, e); }\n+      ast::expr_move(lhs, rhs) => {\n         print_expr(s, lhs);\n         space(s.s);\n         word_space(s, ~\"<-\");\n         print_expr(s, rhs);\n       }\n-      ast::expr_assign(lhs, rhs) {\n+      ast::expr_assign(lhs, rhs) => {\n         print_expr(s, lhs);\n         space(s.s);\n         word_space(s, ~\"=\");\n         print_expr(s, rhs);\n       }\n-      ast::expr_swap(lhs, rhs) {\n+      ast::expr_swap(lhs, rhs) => {\n         print_expr(s, lhs);\n         space(s.s);\n         word_space(s, ~\"<->\");\n         print_expr(s, rhs);\n       }\n-      ast::expr_assign_op(op, lhs, rhs) {\n+      ast::expr_assign_op(op, lhs, rhs) => {\n         print_expr(s, lhs);\n         space(s.s);\n         word(s.s, ast_util::binop_to_str(op));\n         word_space(s, ~\"=\");\n         print_expr(s, rhs);\n       }\n-      ast::expr_field(expr, id, tys) {\n+      ast::expr_field(expr, id, tys) => {\n         // Deal with '10.x'\n         if ends_in_lit_int(expr) {\n             popen(s); print_expr(s, expr); pclose(s);\n@@ -1169,34 +1167,34 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n             word(s.s, ~\">\");\n         }\n       }\n-      ast::expr_index(expr, index) {\n+      ast::expr_index(expr, index) => {\n         print_expr_parens_if_not_bot(s, expr);\n         word(s.s, ~\"[\");\n         print_expr(s, index);\n         word(s.s, ~\"]\");\n       }\n-      ast::expr_path(path) { print_path(s, path, true); }\n-      ast::expr_fail(maybe_fail_val) {\n+      ast::expr_path(path) => print_path(s, path, true),\n+      ast::expr_fail(maybe_fail_val) => {\n         word(s.s, ~\"fail\");\n         alt maybe_fail_val {\n-          some(expr) { word(s.s, ~\" \"); print_expr(s, expr); }\n-          _ { }\n+          some(expr) => { word(s.s, ~\" \"); print_expr(s, expr); }\n+          _ => ()\n         }\n       }\n-      ast::expr_break { word(s.s, ~\"break\"); }\n-      ast::expr_again { word(s.s, ~\"again\"); }\n-      ast::expr_ret(result) {\n+      ast::expr_break => word(s.s, ~\"break\"),\n+      ast::expr_again => word(s.s, ~\"again\"),\n+      ast::expr_ret(result) => {\n         word(s.s, ~\"return\");\n         alt result {\n-          some(expr) { word(s.s, ~\" \"); print_expr(s, expr); }\n-          _ { }\n+          some(expr) => { word(s.s, ~\" \"); print_expr(s, expr); }\n+          _ => ()\n         }\n       }\n-      ast::expr_log(lvl, lexp, expr) {\n+      ast::expr_log(lvl, lexp, expr) => {\n         alt check lvl {\n-          1 { word_nbsp(s, ~\"log\"); print_expr(s, expr); }\n-          0 { word_nbsp(s, ~\"log_err\"); print_expr(s, expr); }\n-          2 {\n+          1 => { word_nbsp(s, ~\"log\"); print_expr(s, expr); }\n+          0 => { word_nbsp(s, ~\"log_err\"); print_expr(s, expr); }\n+          2 => {\n             word_nbsp(s, ~\"log\");\n             popen(s);\n             print_expr(s, lexp);\n@@ -1207,11 +1205,11 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n           }\n         }\n       }\n-      ast::expr_assert(expr) {\n+      ast::expr_assert(expr) => {\n         word_nbsp(s, ~\"assert\");\n         print_expr(s, expr);\n       }\n-      ast::expr_mac(m) { print_mac(s, m); }\n+      ast::expr_mac(m) => print_mac(s, m),\n     }\n     s.ann.post(ann_node);\n     end(s);\n@@ -1226,8 +1224,8 @@ fn print_expr_parens_if_not_bot(s: ps, ex: @ast::expr) {\n       ast::expr_assign_op(_, _, _) | ast::expr_swap(_, _) |\n       ast::expr_log(_, _, _) | ast::expr_assert(_) |\n       ast::expr_call(_, _, true) |\n-      ast::expr_vstore(_, _) { true }\n-      _ { false }\n+      ast::expr_vstore(_, _) => true,\n+      _ => false\n     };\n     if parens { popen(s); }\n     print_expr(s, ex);\n@@ -1237,15 +1235,15 @@ fn print_expr_parens_if_not_bot(s: ps, ex: @ast::expr) {\n fn print_local_decl(s: ps, loc: @ast::local) {\n     print_pat(s, loc.node.pat);\n     alt loc.node.ty.node {\n-      ast::ty_infer { }\n-      _ { word_space(s, ~\":\"); print_type(s, loc.node.ty); }\n+      ast::ty_infer => (),\n+      _ => { word_space(s, ~\":\"); print_type(s, loc.node.ty); }\n     }\n }\n \n fn print_decl(s: ps, decl: @ast::decl) {\n     maybe_print_comment(s, decl.span.lo);\n     alt decl.node {\n-      ast::decl_local(locs) {\n+      ast::decl_local(locs) => {\n         space_if_not_bol(s);\n         ibox(s, indent_unit);\n         word_nbsp(s, ~\"let\");\n@@ -1261,21 +1259,21 @@ fn print_decl(s: ps, decl: @ast::decl) {\n             print_local_decl(s, loc);\n             end(s);\n             alt loc.node.init {\n-              some(init) {\n+              some(init) => {\n                 nbsp(s);\n                 alt init.op {\n-                  ast::init_assign { word_space(s, ~\"=\"); }\n-                  ast::init_move { word_space(s, ~\"<-\"); }\n+                  ast::init_assign => word_space(s, ~\"=\"),\n+                  ast::init_move => word_space(s, ~\"<-\")\n                 }\n                 print_expr(s, init.expr);\n               }\n-              _ { }\n+              _ => ()\n             }\n         }\n         commasep(s, consistent, locs, print_local);\n         end(s);\n       }\n-      ast::decl_item(item) { print_item(s, item); }\n+      ast::decl_item(item) => print_item(s, item)\n     }\n }\n \n@@ -1300,8 +1298,8 @@ fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n         if colons_before_params { word(s.s, ~\"::\"); }\n \n         alt path.rp {\n-          none { /* ok */ }\n-          some(r) {\n+          none => { /* ok */ }\n+          some(r) => {\n             word(s.s, ~\"/\");\n             print_region(s, r);\n           }\n@@ -1322,23 +1320,23 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n     /* Pat isn't normalized, but the beauty of it\n      is that it doesn't matter */\n     alt pat.node {\n-      ast::pat_wild { word(s.s, ~\"_\"); }\n-      ast::pat_ident(binding_mode, path, sub) {\n+      ast::pat_wild => word(s.s, ~\"_\"),\n+      ast::pat_ident(binding_mode, path, sub) => {\n         alt binding_mode {\n-          ast::bind_by_ref => { word_space(s, ~\"ref\"); }\n-          ast::bind_by_value => {}\n+          ast::bind_by_ref => word_space(s, ~\"ref\"),\n+          ast::bind_by_value => ()\n         }\n         print_path(s, path, true);\n         alt sub {\n           some(p) => { word(s.s, ~\"@\"); print_pat(s, p); }\n-          none => {}\n+          none => ()\n         }\n       }\n-      ast::pat_enum(path, args_) {\n+      ast::pat_enum(path, args_) => {\n         print_path(s, path, true);\n         alt args_ {\n-          none { word(s.s, ~\"(*)\"); }\n-          some(args) {\n+          none => word(s.s, ~\"(*)\"),\n+          some(args) => {\n             if vec::len(args) > 0u {\n               popen(s);\n               commasep(s, inconsistent, args, print_pat);\n@@ -1347,7 +1345,7 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n           }\n         }\n       }\n-      ast::pat_rec(fields, etc) {\n+      ast::pat_rec(fields, etc) => {\n         word(s.s, ~\"{\");\n         fn print_field(s: ps, f: ast::field_pat) {\n             cbox(s, indent_unit);\n@@ -1364,15 +1362,15 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n         }\n         word(s.s, ~\"}\");\n       }\n-      ast::pat_tup(elts) {\n+      ast::pat_tup(elts) => {\n         popen(s);\n         commasep(s, inconsistent, elts, print_pat);\n         pclose(s);\n       }\n-      ast::pat_box(inner) { word(s.s, ~\"@\"); print_pat(s, inner); }\n-      ast::pat_uniq(inner) { word(s.s, ~\"~\"); print_pat(s, inner); }\n-      ast::pat_lit(e) { print_expr(s, e); }\n-      ast::pat_range(begin, end) {\n+      ast::pat_box(inner) => { word(s.s, ~\"@\"); print_pat(s, inner); }\n+      ast::pat_uniq(inner) => { word(s.s, ~\"~\"); print_pat(s, inner); }\n+      ast::pat_lit(e) => print_expr(s, e),\n+      ast::pat_range(begin, end) => {\n         print_expr(s, begin);\n         space(s.s);\n         word_space(s, ~\"to\");\n@@ -1385,8 +1383,8 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n fn print_fn(s: ps, decl: ast::fn_decl, name: ast::ident,\n             typarams: ~[ast::ty_param]) {\n     alt decl.purity {\n-      ast::impure_fn { head(s, ~\"fn\") }\n-      _ { head(s, purity_to_str(decl.purity) + ~\" fn\") }\n+      ast::impure_fn => head(s, ~\"fn\"),\n+      _ => head(s, purity_to_str(decl.purity) + ~\" fn\")\n     }\n     word(s.s, *name);\n     print_type_params(s, typarams);\n@@ -1436,12 +1434,12 @@ fn print_fn_block_args(s: ps, decl: ast::fn_decl,\n \n fn mode_to_str(m: ast::mode) -> ~str {\n     alt m {\n-      ast::expl(ast::by_mutbl_ref) { ~\"&\" }\n-      ast::expl(ast::by_move) { ~\"-\" }\n-      ast::expl(ast::by_ref) { ~\"&&\" }\n-      ast::expl(ast::by_val) { ~\"++\" }\n-      ast::expl(ast::by_copy) { ~\"+\" }\n-      ast::infer(_) { ~\"\" }\n+      ast::expl(ast::by_mutbl_ref) => ~\"&\",\n+      ast::expl(ast::by_move) => ~\"-\",\n+      ast::expl(ast::by_ref) => ~\"&&\",\n+      ast::expl(ast::by_val) => ~\"++\",\n+      ast::expl(ast::by_copy) => ~\"+\",\n+      ast::infer(_) => ~\"\"\n     }\n }\n \n@@ -1456,11 +1454,11 @@ fn print_bounds(s: ps, bounds: @~[ast::ty_param_bound]) {\n         for vec::each(*bounds) |bound| {\n             nbsp(s);\n             alt bound {\n-              ast::bound_copy { word(s.s, ~\"copy\"); }\n-              ast::bound_send { word(s.s, ~\"send\"); }\n-              ast::bound_const { word(s.s, ~\"const\"); }\n-              ast::bound_owned { word(s.s, ~\"owned\"); }\n-              ast::bound_trait(t) { print_type(s, t); }\n+              ast::bound_copy => word(s.s, ~\"copy\"),\n+              ast::bound_send => word(s.s, ~\"send\"),\n+              ast::bound_const => word(s.s, ~\"const\"),\n+              ast::bound_owned => word(s.s, ~\"owned\"),\n+              ast::bound_trait(t) => print_type(s, t)\n             }\n         }\n     }\n@@ -1481,13 +1479,13 @@ fn print_type_params(s: ps, &&params: ~[ast::ty_param]) {\n fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n     ibox(s, indent_unit);\n     alt item.node {\n-      ast::meta_word(name) { word(s.s, *name); }\n-      ast::meta_name_value(name, value) {\n+      ast::meta_word(name) => word(s.s, *name),\n+      ast::meta_name_value(name, value) => {\n         word_space(s, *name);\n         word_space(s, ~\"=\");\n         print_literal(s, @value);\n       }\n-      ast::meta_list(name, items) {\n+      ast::meta_list(name, items) => {\n         word(s.s, *name);\n         popen(s);\n         commasep(s, consistent, items, print_meta_item);\n@@ -1499,20 +1497,20 @@ fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n \n fn print_view_path(s: ps, &&vp: @ast::view_path) {\n     alt vp.node {\n-      ast::view_path_simple(ident, path, _) {\n+      ast::view_path_simple(ident, path, _) => {\n         if path.idents[vec::len(path.idents)-1u] != ident {\n             word_space(s, *ident);\n             word_space(s, ~\"=\");\n         }\n         print_path(s, path, false);\n       }\n \n-      ast::view_path_glob(path, _) {\n+      ast::view_path_glob(path, _) => {\n         print_path(s, path, false);\n         word(s.s, ~\"::*\");\n       }\n \n-      ast::view_path_list(path, idents, _) {\n+      ast::view_path_list(path, idents, _) => {\n         print_path(s, path, false);\n         word(s.s, ~\"::{\");\n         do commasep(s, inconsistent, idents) |s, w| {\n@@ -1532,7 +1530,7 @@ fn print_view_item(s: ps, item: @ast::view_item) {\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n     alt item.node {\n-      ast::view_item_use(id, mta, _) {\n+      ast::view_item_use(id, mta, _) => {\n         head(s, ~\"use\");\n         word(s.s, *id);\n         if vec::len(mta) > 0u {\n@@ -1542,12 +1540,12 @@ fn print_view_item(s: ps, item: @ast::view_item) {\n         }\n       }\n \n-      ast::view_item_import(vps) {\n+      ast::view_item_import(vps) => {\n         head(s, ~\"import\");\n         print_view_paths(s, vps);\n       }\n \n-      ast::view_item_export(vps) {\n+      ast::view_item_export(vps) => {\n         head(s, ~\"export\");\n         print_view_paths(s, vps);\n       }\n@@ -1566,9 +1564,9 @@ fn print_op_maybe_parens(s: ps, expr: @ast::expr, outer_prec: uint) {\n \n fn print_mutability(s: ps, mutbl: ast::mutability) {\n     alt mutbl {\n-      ast::m_mutbl { word_nbsp(s, ~\"mut\"); }\n-      ast::m_const { word_nbsp(s, ~\"const\"); }\n-      ast::m_imm {/* nothing */ }\n+      ast::m_mutbl => word_nbsp(s, ~\"mut\"),\n+      ast::m_const => word_nbsp(s, ~\"const\"),\n+      ast::m_imm => {/* nothing */ }\n     }\n }\n \n@@ -1581,10 +1579,8 @@ fn print_arg(s: ps, input: ast::arg) {\n     ibox(s, indent_unit);\n     print_arg_mode(s, input.mode);\n     alt input.ty.node {\n-      ast::ty_infer {\n-        word(s.s, *input.ident);\n-      }\n-      _ {\n+      ast::ty_infer => word(s.s, *input.ident),\n+      _ => {\n         if str::len(*input.ident) > 0u {\n             word_space(s, *input.ident + ~\":\");\n         }\n@@ -1599,8 +1595,8 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n                tps: option<~[ast::ty_param]>) {\n     ibox(s, indent_unit);\n     word(s.s, opt_proto_to_str(opt_proto));\n-    alt id { some(id) { word(s.s, ~\" \"); word(s.s, *id); } _ { } }\n-    alt tps { some(tps) { print_type_params(s, tps); } _ { } }\n+    alt id { some(id) => { word(s.s, ~\" \"); word(s.s, *id); } _ => () }\n+    alt tps { some(tps) => print_type_params(s, tps), _ => () }\n     zerobreak(s.s);\n     popen(s);\n     commasep(s, inconsistent, decl.inputs, print_arg);\n@@ -1620,21 +1616,21 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n                                 next_pos: option<uint>) {\n     let mut cm;\n-    alt s.cm { some(ccm) { cm = ccm; } _ { return; } }\n+    alt s.cm { some(ccm) => cm = ccm, _ => return }\n     alt next_comment(s) {\n-      some(cmnt) {\n+      some(cmnt) => {\n         if cmnt.style != comments::trailing { return; }\n         let span_line = codemap::lookup_char_pos(cm, span.hi);\n         let comment_line = codemap::lookup_char_pos(cm, cmnt.pos);\n         let mut next = cmnt.pos + 1u;\n-        alt next_pos { none { } some(p) { next = p; } }\n+        alt next_pos { none => (), some(p) => next = p }\n         if span.hi < cmnt.pos && cmnt.pos < next &&\n                span_line.line == comment_line.line {\n             print_comment(s, cmnt);\n             s.cur_cmnt += 1u;\n         }\n       }\n-      _ { }\n+      _ => ()\n     }\n }\n \n@@ -1644,27 +1640,27 @@ fn print_remaining_comments(s: ps) {\n     if option::is_none(next_comment(s)) { hardbreak(s.s); }\n     loop {\n         alt next_comment(s) {\n-          some(cmnt) { print_comment(s, cmnt); s.cur_cmnt += 1u; }\n-          _ { break; }\n+          some(cmnt) => { print_comment(s, cmnt); s.cur_cmnt += 1u; }\n+          _ => break\n         }\n     }\n }\n \n fn print_literal(s: ps, &&lit: @ast::lit) {\n     maybe_print_comment(s, lit.span.lo);\n     alt next_lit(s, lit.span.lo) {\n-      some(ltrl) {\n+      some(ltrl) => {\n         word(s.s, ltrl.lit);\n         return;\n       }\n-      _ {}\n+      _ => ()\n     }\n     alt lit.node {\n-      ast::lit_str(st) { print_string(s, *st); }\n-      ast::lit_int(ch, ast::ty_char) {\n+      ast::lit_str(st) => print_string(s, *st),\n+      ast::lit_int(ch, ast::ty_char) => {\n         word(s.s, ~\"'\" + char::escape_default(ch as char) + ~\"'\");\n       }\n-      ast::lit_int(i, t) {\n+      ast::lit_int(i, t) => {\n         if i < 0_i64 {\n             word(s.s,\n                  ~\"-\" + u64::to_str(-i as u64, 10u)\n@@ -1675,23 +1671,23 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n                  + ast_util::int_ty_to_str(t));\n         }\n       }\n-      ast::lit_uint(u, t) {\n+      ast::lit_uint(u, t) => {\n         word(s.s,\n              u64::to_str(u, 10u)\n              + ast_util::uint_ty_to_str(t));\n       }\n-      ast::lit_int_unsuffixed(i) {\n+      ast::lit_int_unsuffixed(i) => {\n         if i < 0_i64 {\n             word(s.s, ~\"-\" + u64::to_str(-i as u64, 10u));\n         } else {\n             word(s.s, u64::to_str(i as u64, 10u));\n         }\n       }\n-      ast::lit_float(f, t) {\n+      ast::lit_float(f, t) => {\n         word(s.s, *f + ast_util::float_ty_to_str(t));\n       }\n-      ast::lit_nil { word(s.s, ~\"()\"); }\n-      ast::lit_bool(val) {\n+      ast::lit_nil => word(s.s, ~\"()\"),\n+      ast::lit_bool(val) => {\n         if val { word(s.s, ~\"true\"); } else { word(s.s, ~\"false\"); }\n       }\n     }\n@@ -1701,7 +1697,7 @@ fn lit_to_str(l: @ast::lit) -> ~str { return to_str(l, print_literal); }\n \n fn next_lit(s: ps, pos: uint) -> option<comments::lit> {\n     alt s.literals {\n-      some(lits) {\n+      some(lits) => {\n         while s.cur_lit < vec::len(lits) {\n             let ltrl = lits[s.cur_lit];\n             if ltrl.pos > pos { return none; }\n@@ -1710,33 +1706,33 @@ fn next_lit(s: ps, pos: uint) -> option<comments::lit> {\n         }\n         return none;\n       }\n-      _ { return none; }\n+      _ => return none\n     }\n }\n \n fn maybe_print_comment(s: ps, pos: uint) {\n     loop {\n         alt next_comment(s) {\n-          some(cmnt) {\n+          some(cmnt) => {\n             if cmnt.pos < pos {\n                 print_comment(s, cmnt);\n                 s.cur_cmnt += 1u;\n             } else { break; }\n           }\n-          _ { break; }\n+          _ => break\n         }\n     }\n }\n \n fn print_comment(s: ps, cmnt: comments::cmnt) {\n     alt cmnt.style {\n-      comments::mixed {\n+      comments::mixed => {\n         assert (vec::len(cmnt.lines) == 1u);\n         zerobreak(s.s);\n         word(s.s, cmnt.lines[0]);\n         zerobreak(s.s);\n       }\n-      comments::isolated {\n+      comments::isolated => {\n         pprust::hardbreak_if_not_bol(s);\n         for cmnt.lines.each |line| {\n             // Don't print empty lines because they will end up as trailing\n@@ -1745,7 +1741,7 @@ fn print_comment(s: ps, cmnt: comments::cmnt) {\n             hardbreak(s.s);\n         }\n       }\n-      comments::trailing {\n+      comments::trailing => {\n         word(s.s, ~\" \");\n         if vec::len(cmnt.lines) == 1u {\n             word(s.s, cmnt.lines[0]);\n@@ -1759,12 +1755,12 @@ fn print_comment(s: ps, cmnt: comments::cmnt) {\n             end(s);\n         }\n       }\n-      comments::blank_line {\n+      comments::blank_line => {\n         // We need to do at least one, possibly two hardbreaks.\n         let is_semi =\n             alt s.s.last_token() {\n-              pp::STRING(s, _) { *s == ~\";\" }\n-              _ { false }\n+              pp::STRING(s, _) => *s == ~\";\",\n+              _ => false\n             };\n         if is_semi || is_begin(s) || is_end(s) { hardbreak(s.s); }\n         hardbreak(s.s);\n@@ -1788,19 +1784,19 @@ fn to_str<T>(t: T, f: fn@(ps, T)) -> ~str {\n \n fn next_comment(s: ps) -> option<comments::cmnt> {\n     alt s.comments {\n-      some(cmnts) {\n+      some(cmnts) => {\n         if s.cur_cmnt < vec::len(cmnts) {\n             return some(cmnts[s.cur_cmnt]);\n         } else { return none::<comments::cmnt>; }\n       }\n-      _ { return none::<comments::cmnt>; }\n+      _ => return none::<comments::cmnt>\n     }\n }\n \n fn opt_proto_to_str(opt_p: option<ast::proto>) -> ~str {\n     alt opt_p {\n-      none { ~\"fn\" }\n-      some(p) { proto_to_str(p) }\n+      none => ~\"fn\",\n+      some(p) => proto_to_str(p)\n     }\n }\n \n@@ -1815,17 +1811,17 @@ pure fn purity_to_str(p: ast::purity) -> ~str {\n \n fn print_purity(s: ps, p: ast::purity) {\n     alt p {\n-      ast::impure_fn {}\n-      _ { word_nbsp(s, purity_to_str(p)) }\n+      ast::impure_fn => (),\n+      _ => word_nbsp(s, purity_to_str(p))\n     }\n }\n \n fn proto_to_str(p: ast::proto) -> ~str {\n     return alt p {\n-      ast::proto_bare { ~\"extern fn\" }\n-      ast::proto_block { ~\"fn&\" }\n-      ast::proto_uniq { ~\"fn~\" }\n-      ast::proto_box { ~\"fn@\" }\n+      ast::proto_bare => ~\"extern fn\",\n+      ast::proto_block => ~\"fn&\",\n+      ast::proto_uniq => ~\"fn~\",\n+      ast::proto_box => ~\"fn@\"\n     };\n }\n "}, {"sha": "80bd9e3a6d130586cc2cdeb42c968b4cbed19933", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -28,8 +28,8 @@ trait interner<T: const copy> {\n impl <T: const copy> of interner<T> for hash_interner<T> {\n     fn intern(val: T) -> uint {\n         alt self.map.find(val) {\n-          some(idx) { return idx; }\n-          none {\n+          some(idx) => return idx,\n+          none => {\n             let new_idx = self.vect.len();\n             self.map.insert(val, new_idx);\n             self.vect.push(val);"}, {"sha": "8d80f9663a31d52082eefbab61042e029a8a1918", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 97, "deletions": 103, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -27,19 +27,19 @@ enum fn_kind {\n fn name_of_fn(fk: fn_kind) -> ident {\n     alt fk {\n       fk_item_fn(name, _) | fk_method(name, _, _)\n-          | fk_ctor(name, _, _, _, _) { /* FIXME (#2543) */ copy name }\n-      fk_anon(*) | fk_fn_block(*) { @~\"anon\" }\n-      fk_dtor(*)                  { @~\"drop\" }\n+          | fk_ctor(name, _, _, _, _) => /* FIXME (#2543) */ copy name,\n+      fk_anon(*) | fk_fn_block(*) => @~\"anon\",\n+      fk_dtor(*)                  => @~\"drop\"\n     }\n }\n \n fn tps_of_fn(fk: fn_kind) -> ~[ty_param] {\n     alt fk {\n       fk_item_fn(_, tps) | fk_method(_, tps, _)\n-          | fk_ctor(_, _, tps, _, _) | fk_dtor(tps, _, _, _) {\n+          | fk_ctor(_, _, tps, _, _) | fk_dtor(tps, _, _, _) => {\n           /* FIXME (#2543) */ copy tps\n       }\n-      fk_anon(*) | fk_fn_block(*) { ~[] }\n+      fk_anon(*) | fk_fn_block(*) => ~[]\n     }\n }\n \n@@ -90,14 +90,12 @@ fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n \n fn visit_crate_directive<E>(cd: @crate_directive, e: E, v: vt<E>) {\n     alt cd.node {\n-      cdir_src_mod(_, _) { }\n-      cdir_dir_mod(_, cdirs, _) {\n-        for cdirs.each |cdir| {\n-            visit_crate_directive(cdir, e, v);\n-        }\n+      cdir_src_mod(_, _) => (),\n+      cdir_dir_mod(_, cdirs, _) => for cdirs.each |cdir| {\n+        visit_crate_directive(cdir, e, v);\n       }\n-      cdir_view_item(vi) { v.visit_view_item(vi, e, v); }\n-      cdir_syntax(_) { }\n+      cdir_view_item(vi) => v.visit_view_item(vi, e, v),\n+      cdir_syntax(_) => ()\n     }\n }\n \n@@ -111,33 +109,36 @@ fn visit_view_item<E>(_vi: @view_item, _e: E, _v: vt<E>) { }\n fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n     v.visit_pat(loc.node.pat, e, v);\n     v.visit_ty(loc.node.ty, e, v);\n-    alt loc.node.init { none { } some(i) { v.visit_expr(i.expr, e, v); } }\n+    alt loc.node.init {\n+      none => (),\n+      some(i) => v.visit_expr(i.expr, e, v)\n+    }\n }\n \n fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     alt i.node {\n-      item_const(t, ex) { v.visit_ty(t, e, v); v.visit_expr(ex, e, v); }\n-      item_fn(decl, tp, body) {\n+      item_const(t, ex) => { v.visit_ty(t, e, v); v.visit_expr(ex, e, v); }\n+      item_fn(decl, tp, body) => {\n         v.visit_fn(fk_item_fn(/* FIXME (#2543) */ copy i.ident,\n                               /* FIXME (#2543) */ copy tp), decl, body,\n                    i.span, i.id, e, v);\n       }\n-      item_mod(m) { v.visit_mod(m, i.span, i.id, e, v); }\n-      item_foreign_mod(nm) {\n+      item_mod(m) => v.visit_mod(m, i.span, i.id, e, v),\n+      item_foreign_mod(nm) => {\n         for nm.view_items.each |vi| { v.visit_view_item(vi, e, v); }\n         for nm.items.each |ni| { v.visit_foreign_item(ni, e, v); }\n       }\n-      item_ty(t, tps) {\n+      item_ty(t, tps) => {\n         v.visit_ty(t, e, v);\n         v.visit_ty_params(tps, e, v);\n       }\n-      item_enum(variants, tps) {\n+      item_enum(variants, tps) => {\n         v.visit_ty_params(tps, e, v);\n         for variants.each |vr| {\n             for vr.node.args.each |va| { v.visit_ty(va.ty, e, v); }\n         }\n       }\n-      item_impl(tps, traits, ty, methods) {\n+      item_impl(tps, traits, ty, methods) => {\n         v.visit_ty_params(tps, e, v);\n         for traits.each |p| {\n             visit_path(p.path, e, v);\n@@ -147,7 +148,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n             visit_method_helper(m, e, v)\n         }\n       }\n-      item_class(tps, traits, members, m_ctor, m_dtor) {\n+      item_class(tps, traits, members, m_ctor, m_dtor) => {\n           v.visit_ty_params(tps, e, v);\n           for members.each |m| {\n              v.visit_class_item(m, e, v);\n@@ -162,25 +163,21 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n                                     ast_util::local_def(i.id), e, v)\n           };\n       }\n-      item_trait(tps, traits, methods) {\n+      item_trait(tps, traits, methods) => {\n         v.visit_ty_params(tps, e, v);\n         for traits.each |p| { visit_path(p.path, e, v); }\n         for methods.each |m| {\n             v.visit_trait_method(m, e, v);\n         }\n       }\n-      item_mac(m) { visit_mac(m, e, v) }\n+      item_mac(m) => visit_mac(m, e, v)\n     }\n }\n \n fn visit_class_item<E>(cm: @class_member, e:E, v:vt<E>) {\n     alt cm.node {\n-        instance_var(_, t, _, _, _) {\n-            v.visit_ty(t, e, v);\n-        }\n-        class_method(m) {\n-            visit_method_helper(m, e, v);\n-        }\n+      instance_var(_, t, _, _, _) => v.visit_ty(t, e, v),\n+      class_method(m) => visit_method_helper(m, e, v)\n     }\n }\n \n@@ -189,26 +186,25 @@ fn skip_ty<E>(_t: @ty, _e: E, _v: vt<E>) {}\n fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n     alt t.node {\n       ty_box(mt) | ty_uniq(mt) |\n-      ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) {\n+      ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n         v.visit_ty(mt.ty, e, v);\n       }\n-      ty_rec(flds) {\n-        for flds.each |f| { v.visit_ty(f.node.mt.ty, e, v); }\n+      ty_rec(flds) => for flds.each |f| {\n+        v.visit_ty(f.node.mt.ty, e, v);\n+      }\n+      ty_tup(ts) => for ts.each |tt| {\n+        v.visit_ty(tt, e, v);\n       }\n-      ty_tup(ts) { for ts.each |tt| { v.visit_ty(tt, e, v); } }\n-      ty_fn(_, decl) {\n+      ty_fn(_, decl) => {\n         for decl.inputs.each |a| { v.visit_ty(a.ty, e, v); }\n         v.visit_ty(decl.output, e, v);\n       }\n-      ty_path(p, _) { visit_path(p, e, v); }\n-      ty_fixed_length(t, _) {\n-        v.visit_ty(t, e, v);\n-      }\n+      ty_path(p, _) => visit_path(p, e, v),\n+      ty_fixed_length(t, _) => v.visit_ty(t, e, v),\n       ty_nil |\n       ty_bot |\n       ty_mac(_) |\n-      ty_infer {\n-      }\n+      ty_infer => ()\n     }\n }\n \n@@ -218,31 +214,31 @@ fn visit_path<E>(p: @path, e: E, v: vt<E>) {\n \n fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     alt p.node {\n-      pat_enum(path, children) {\n+      pat_enum(path, children) => {\n         visit_path(path, e, v);\n         do option::iter(children) |children| {\n             for children.each |child| { v.visit_pat(child, e, v); }}\n       }\n-      pat_rec(fields, _) {\n-          for fields.each |f| { v.visit_pat(f.pat, e, v); }\n+      pat_rec(fields, _) => for fields.each |f| {\n+        v.visit_pat(f.pat, e, v)\n       }\n-      pat_tup(elts) { for elts.each |elt| { v.visit_pat(elt, e, v); } }\n-      pat_box(inner) | pat_uniq(inner) {\n-        v.visit_pat(inner, e, v);\n+      pat_tup(elts) => for elts.each |elt| {\n+        v.visit_pat(elt, e, v)\n       }\n-      pat_ident(_, path, inner) {\n+      pat_box(inner) | pat_uniq(inner) => v.visit_pat(inner, e, v),\n+      pat_ident(_, path, inner) => {\n           visit_path(path, e, v);\n           do option::iter(inner) |subpat| { v.visit_pat(subpat, e, v)};\n       }\n-      pat_lit(ex) { v.visit_expr(ex, e, v); }\n-      pat_range(e1, e2) { v.visit_expr(e1, e, v); v.visit_expr(e2, e, v); }\n-      pat_wild {}\n+      pat_lit(ex) => v.visit_expr(ex, e, v),\n+      pat_range(e1, e2) => { v.visit_expr(e1, e, v); v.visit_expr(e2, e, v); }\n+      pat_wild => ()\n     }\n }\n \n fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n     alt ni.node {\n-      foreign_item_fn(fd, tps) {\n+      foreign_item_fn(fd, tps) => {\n         v.visit_ty_params(tps, e, v);\n         visit_fn_decl(fd, e, v);\n       }\n@@ -253,8 +249,8 @@ fn visit_ty_params<E>(tps: ~[ty_param], e: E, v: vt<E>) {\n     for tps.each |tp| {\n         for vec::each(*tp.bounds) |bound| {\n             alt bound {\n-              bound_trait(t) { v.visit_ty(t, e, v); }\n-              bound_copy | bound_send | bound_const | bound_owned { }\n+              bound_trait(t) => v.visit_ty(t, e, v),\n+              bound_copy | bound_send | bound_const | bound_owned => ()\n             }\n         }\n     }\n@@ -309,12 +305,8 @@ fn visit_ty_method<E>(m: ty_method, e: E, v: vt<E>) {\n \n fn visit_trait_method<E>(m: trait_method, e: E, v: vt<E>) {\n     alt m {\n-      required(ty_m) {\n-        v.visit_ty_method(ty_m, e, v)\n-      }\n-      provided(m) {\n-        visit_method_helper(m, e, v)\n-      }\n+      required(ty_m) => v.visit_ty_method(ty_m, e, v),\n+      provided(m) => visit_method_helper(m, e, v)\n     }\n }\n \n@@ -326,23 +318,23 @@ fn visit_block<E>(b: ast::blk, e: E, v: vt<E>) {\n \n fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n     alt s.node {\n-      stmt_decl(d, _) { v.visit_decl(d, e, v); }\n-      stmt_expr(ex, _) { v.visit_expr(ex, e, v); }\n-      stmt_semi(ex, _) { v.visit_expr(ex, e, v); }\n+      stmt_decl(d, _) => v.visit_decl(d, e, v),\n+      stmt_expr(ex, _) => v.visit_expr(ex, e, v),\n+      stmt_semi(ex, _) => v.visit_expr(ex, e, v)\n     }\n }\n \n fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n     alt d.node {\n-      decl_local(locs) {\n-        for locs.each |loc| { v.visit_local(loc, e, v); }\n+      decl_local(locs) => for locs.each |loc| {\n+        v.visit_local(loc, e, v)\n       }\n-      decl_item(it) { v.visit_item(it, e, v); }\n+      decl_item(it) => v.visit_item(it, e, v)\n     }\n }\n \n fn visit_expr_opt<E>(eo: option<@expr>, e: E, v: vt<E>) {\n-    alt eo { none { } some(ex) { v.visit_expr(ex, e, v); } }\n+    alt eo { none => (), some(ex) => v.visit_expr(ex, e, v) }\n }\n \n fn visit_exprs<E>(exprs: ~[@expr], e: E, v: vt<E>) {\n@@ -351,86 +343,88 @@ fn visit_exprs<E>(exprs: ~[@expr], e: E, v: vt<E>) {\n \n fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n     alt m.node {\n-      ast::mac_invoc(pth, arg, body) {\n+      ast::mac_invoc(pth, arg, body) => {\n         option::map(arg, |arg| v.visit_expr(arg, e, v)); }\n-      ast::mac_invoc_tt(pth, tt) { /* no user-serviceable parts inside */ }\n-      ast::mac_ellipsis { }\n-      ast::mac_aq(_, e) { /* FIXME: maybe visit (Issue #2340) */ }\n-      ast::mac_var(_) { }\n+      ast::mac_invoc_tt(pth, tt) => { /* no user-serviceable parts inside */ }\n+      ast::mac_ellipsis => (),\n+      ast::mac_aq(_, e) => { /* FIXME: maybe visit (Issue #2340) */ }\n+      ast::mac_var(_) => ()\n     }\n }\n \n fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n     alt ex.node {\n-      expr_vstore(x, _) { v.visit_expr(x, e, v); }\n-      expr_vec(es, _) { visit_exprs(es, e, v); }\n+      expr_vstore(x, _) => v.visit_expr(x, e, v),\n+      expr_vec(es, _) => visit_exprs(es, e, v),\n       expr_repeat(element, count, _) => {\n         v.visit_expr(element, e, v);\n         v.visit_expr(count, e, v);\n       }\n-      expr_rec(flds, base) {\n+      expr_rec(flds, base) => {\n         for flds.each |f| { v.visit_expr(f.node.expr, e, v); }\n         visit_expr_opt(base, e, v);\n       }\n-      expr_struct(p, flds) {\n+      expr_struct(p, flds) => {\n         visit_path(p, e, v);\n         for flds.each |f| { v.visit_expr(f.node.expr, e, v); }\n       }\n-      expr_tup(elts) { for elts.each |el| { v.visit_expr(el, e, v); } }\n-      expr_call(callee, args, _) {\n+      expr_tup(elts) => for elts.each |el| { v.visit_expr(el, e, v); }\n+      expr_call(callee, args, _) => {\n         visit_exprs(args, e, v);\n         v.visit_expr(callee, e, v);\n       }\n-      expr_binary(_, a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n+      expr_binary(_, a, b) => {\n+        v.visit_expr(a, e, v); v.visit_expr(b, e, v);\n+      }\n       expr_addr_of(_, x) | expr_unary(_, x) |\n       expr_loop_body(x) | expr_do_body(x) |\n-      expr_assert(x) { v.visit_expr(x, e, v); }\n-      expr_lit(_) { }\n-      expr_cast(x, t) { v.visit_expr(x, e, v); v.visit_ty(t, e, v); }\n-      expr_if(x, b, eo) {\n+      expr_assert(x) => v.visit_expr(x, e, v),\n+      expr_lit(_) => (),\n+      expr_cast(x, t) => { v.visit_expr(x, e, v); v.visit_ty(t, e, v); }\n+      expr_if(x, b, eo) => {\n         v.visit_expr(x, e, v);\n         v.visit_block(b, e, v);\n         visit_expr_opt(eo, e, v);\n       }\n-      expr_while(x, b) { v.visit_expr(x, e, v); v.visit_block(b, e, v); }\n-      expr_loop(b) { v.visit_block(b, e, v); }\n-      expr_alt(x, arms, _) {\n+      expr_while(x, b) => { v.visit_expr(x, e, v); v.visit_block(b, e, v); }\n+      expr_loop(b) => v.visit_block(b, e, v),\n+      expr_alt(x, arms, _) => {\n         v.visit_expr(x, e, v);\n         for arms.each |a| { v.visit_arm(a, e, v); }\n       }\n-      expr_fn(proto, decl, body, cap_clause) {\n+      expr_fn(proto, decl, body, cap_clause) => {\n         v.visit_fn(fk_anon(proto, cap_clause), decl, body,\n                    ex.span, ex.id, e, v);\n       }\n-      expr_fn_block(decl, body, cap_clause) {\n+      expr_fn_block(decl, body, cap_clause) => {\n         v.visit_fn(fk_fn_block(cap_clause), decl, body,\n                    ex.span, ex.id, e, v);\n       }\n-      expr_block(b) { v.visit_block(b, e, v); }\n-      expr_assign(a, b) { v.visit_expr(b, e, v); v.visit_expr(a, e, v); }\n-      expr_copy(a) { v.visit_expr(a, e, v); }\n-      expr_unary_move(a) { v.visit_expr(a, e, v); }\n-      expr_move(a, b) { v.visit_expr(b, e, v); v.visit_expr(a, e, v); }\n-      expr_swap(a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n-      expr_assign_op(_, a, b) {\n+      expr_block(b) => v.visit_block(b, e, v),\n+      expr_assign(a, b) => { v.visit_expr(b, e, v); v.visit_expr(a, e, v); }\n+      expr_copy(a) => v.visit_expr(a, e, v),\n+      expr_unary_move(a) => v.visit_expr(a, e, v),\n+      expr_move(a, b) => { v.visit_expr(b, e, v); v.visit_expr(a, e, v); }\n+      expr_swap(a, b) => { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n+      expr_assign_op(_, a, b) => {\n         v.visit_expr(b, e, v);\n         v.visit_expr(a, e, v);\n       }\n-      expr_field(x, _, tys) {\n+      expr_field(x, _, tys) => {\n         v.visit_expr(x, e, v);\n         for tys.each |tp| { v.visit_ty(tp, e, v); }\n       }\n-      expr_index(a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n-      expr_path(p) { visit_path(p, e, v); }\n-      expr_fail(eo) { visit_expr_opt(eo, e, v); }\n-      expr_break { }\n-      expr_again { }\n-      expr_ret(eo) { visit_expr_opt(eo, e, v); }\n-      expr_log(_, lv, x) {\n+      expr_index(a, b) => { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n+      expr_path(p) => visit_path(p, e, v),\n+      expr_fail(eo) => visit_expr_opt(eo, e, v),\n+      expr_break => (),\n+      expr_again => (),\n+      expr_ret(eo) => visit_expr_opt(eo, e, v),\n+      expr_log(_, lv, x) => {\n         v.visit_expr(lv, e, v);\n         v.visit_expr(x, e, v);\n       }\n-      expr_mac(mac) { visit_mac(mac, e, v); }\n+      expr_mac(mac) => visit_mac(mac, e, v),\n     }\n     v.visit_expr_post(ex, e, v);\n }"}, {"sha": "c4dc6efe7b2c9023fda52660f360a944aeccb375", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -62,8 +62,8 @@ mod write {\n     fn mk_intermediate_name(output_path: ~str, extension: ~str) ->\n         ~str unsafe {\n         let stem = alt str::find_char(output_path, '.') {\n-          some(dot_pos) { str::slice(output_path, 0u, dot_pos) }\n-          none { output_path }\n+          some(dot_pos) => str::slice(output_path, 0u, dot_pos),\n+          none => output_path\n         };\n         return stem + ~\".\" + extension;\n     }\n@@ -83,15 +83,15 @@ mod write {\n \n         if opts.save_temps {\n             alt opts.output_type {\n-              output_type_bitcode {\n+              output_type_bitcode => {\n                 if opts.optimize != 0u {\n                     let filename = mk_intermediate_name(output, ~\"no-opt.bc\");\n                     str::as_c_str(filename, |buf| {\n                         llvm::LLVMWriteBitcodeToFile(llmod, buf)\n                     });\n                 }\n               }\n-              _ {\n+              _ => {\n                 let filename = mk_intermediate_name(output, ~\"bc\");\n                 str::as_c_str(filename, |buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf)\n@@ -146,13 +146,12 @@ mod write {\n             let LLVMOptDefault    = 2 as c_int; // -O2, -Os\n             let LLVMOptAggressive = 3 as c_int; // -O3\n \n-            let mut CodeGenOptLevel;\n-            alt check opts.optimize {\n-              0u { CodeGenOptLevel = LLVMOptNone; }\n-              1u { CodeGenOptLevel = LLVMOptLess; }\n-              2u { CodeGenOptLevel = LLVMOptDefault; }\n-              3u { CodeGenOptLevel = LLVMOptAggressive; }\n-            }\n+            let mut CodeGenOptLevel = alt check opts.optimize {\n+              0u => LLVMOptNone,\n+              1u => LLVMOptLess,\n+              2u => LLVMOptDefault,\n+              3u => LLVMOptAggressive\n+            };\n \n             let mut FileType;\n             if opts.output_type == output_type_object ||\n@@ -325,13 +324,13 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n         for linkage_metas.each |meta| {\n             if *attr::get_meta_item_name(meta) == ~\"name\" {\n                 alt attr::get_meta_item_value_str(meta) {\n-                  some(v) { name = some(v); }\n-                  none { vec::push(cmh_items, meta); }\n+                  some(v) => { name = some(v); }\n+                  none => vec::push(cmh_items, meta)\n                 }\n             } else if *attr::get_meta_item_name(meta) == ~\"vers\" {\n                 alt attr::get_meta_item_value_str(meta) {\n-                  some(v) { vers = some(v); }\n-                  none { vec::push(cmh_items, meta); }\n+                  some(v) => { vers = some(v); }\n+                  none => vec::push(cmh_items, meta)\n                 }\n             } else { vec::push(cmh_items, meta); }\n         }\n@@ -357,14 +356,14 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n         for cmh_items.each |m_| {\n             let m = m_;\n             alt m.node {\n-              ast::meta_name_value(key, value) {\n+              ast::meta_name_value(key, value) => {\n                 symbol_hasher.write_str(len_and_str(*key));\n                 symbol_hasher.write_str(len_and_str_lit(value));\n               }\n-              ast::meta_word(name) {\n+              ast::meta_word(name) => {\n                 symbol_hasher.write_str(len_and_str(*name));\n               }\n-              ast::meta_list(_, _) {\n+              ast::meta_list(_, _) => {\n                 // FIXME (#607): Implement this\n                 fail ~\"unimplemented meta_item variant\";\n               }\n@@ -387,8 +386,8 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n     fn crate_meta_name(sess: session, _crate: ast::crate,\n                        output: ~str, metas: provided_metas) -> @~str {\n         return alt metas.name {\n-              some(v) { v }\n-              none {\n+              some(v) => v,\n+              none => {\n                 let name =\n                     {\n                         let mut os =\n@@ -409,8 +408,8 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n     fn crate_meta_vers(sess: session, _crate: ast::crate,\n                        metas: provided_metas) -> @~str {\n         return alt metas.vers {\n-              some(v) { v }\n-              none {\n+              some(v) => v,\n+              none => {\n                 let vers = ~\"0.0\";\n                 warn_missing(sess, ~\"vers\", vers);\n                 @vers\n@@ -453,8 +452,8 @@ fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n \n fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> ~str {\n     alt ccx.type_hashcodes.find(t) {\n-      some(h) { return h; }\n-      none {\n+      some(h) => return h,\n+      none => {\n         let hash = symbol_hash(ccx.tcx, ccx.symbol_hasher, t, ccx.link_meta);\n         ccx.type_hashcodes.insert(t, hash);\n         return hash;\n@@ -469,18 +468,18 @@ fn sanitize(s: ~str) -> ~str {\n     let mut result = ~\"\";\n     do str::chars_iter(s) |c| {\n         alt c {\n-          '@' { result += ~\"_sbox_\"; }\n-          '~' { result += ~\"_ubox_\"; }\n-          '*' { result += ~\"_ptr_\"; }\n-          '&' { result += ~\"_ref_\"; }\n-          ',' { result += ~\"_\"; }\n+          '@' => result += ~\"_sbox_\",\n+          '~' => result += ~\"_ubox_\",\n+          '*' => result += ~\"_ptr_\",\n+          '&' => result += ~\"_ref_\",\n+          ',' => result += ~\"_\",\n \n-          '{' | '(' { result += ~\"_of_\"; }\n+          '{' | '(' => result += ~\"_of_\",\n           'a' to 'z'\n           | 'A' to 'Z'\n           | '0' to '9'\n-          | '_' { str::push_char(result,c); }\n-          _ {\n+          | '_' => str::push_char(result,c),\n+          _ => {\n             if c > 'z' && char::is_XID_continue(c) {\n                 str::push_char(result,c);\n             }\n@@ -504,7 +503,7 @@ fn mangle(ss: path) -> ~str {\n     let mut n = ~\"_ZN\"; // Begin name-sequence.\n \n     for ss.each |s| {\n-        alt s { path_name(s) | path_mod(s) {\n+        alt s { path_name(s) | path_mod(s) => {\n           let sani = sanitize(*s);\n           n += fmt!{\"%u%s\", str::len(sani), sani};\n         } }\n@@ -568,10 +567,10 @@ fn link_binary(sess: session,\n             return str::connect(parts, ~\".\");\n         }\n         return alt config.os {\n-              session::os_macos { rmext(rmlib(filename)) }\n-              session::os_linux { rmext(rmlib(filename)) }\n-              session::os_freebsd { rmext(rmlib(filename)) }\n-              _ { rmext(filename) }\n+              session::os_macos => rmext(rmlib(filename)),\n+              session::os_linux => rmext(rmlib(filename)),\n+              session::os_freebsd => rmext(rmlib(filename)),\n+              _ => rmext(filename)\n             };\n     }\n "}, {"sha": "f74ffe8f067edf660268925451577639fd895524", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -8,8 +8,8 @@ export get_rpath_flags;\n \n pure fn not_win32(os: session::os) -> bool {\n   alt os {\n-      session::os_win32 { false }\n-      _ { true }\n+      session::os_win32 => false,\n+      _ => true\n   }\n }\n \n@@ -109,10 +109,10 @@ fn get_rpath_relative_to_output(os: session::os,\n \n     // Mac doesn't appear to support $ORIGIN\n     let prefix = alt os {\n-        session::os_linux { ~\"$ORIGIN\" + path::path_sep() }\n-        session::os_freebsd { ~\"$ORIGIN\" + path::path_sep() }\n-        session::os_macos { ~\"@executable_path\" + path::path_sep() }\n-        session::os_win32 { core::unreachable(); }\n+        session::os_linux => ~\"$ORIGIN\" + path::path_sep(),\n+        session::os_freebsd => ~\"$ORIGIN\" + path::path_sep(),\n+        session::os_macos => ~\"@executable_path\" + path::path_sep(),\n+        session::os_win32 => core::unreachable()\n     };\n \n     prefix + get_relative_to("}, {"sha": "045a90de4955cfe9d8e2365d1b5ee12ae45e0c4e", "filename": "src/rustc/back/x86.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fx86.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -9,31 +9,31 @@ fn get_target_strs(target_os: session::os) -> target_strs::t {\n         meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)),\n \n         data_layout: alt target_os {\n-          session::os_macos {\n+          session::os_macos => {\n             ~\"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\" +\n                 ~\"-i32:32:32-i64:32:64\" +\n                 ~\"-f32:32:32-f64:32:64-v64:64:64\" +\n                 ~\"-v128:128:128-a0:0:64-f80:128:128\" + ~\"-n8:16:32\"\n           }\n \n-          session::os_win32 {\n+          session::os_win32 => {\n             ~\"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\"\n           }\n \n-          session::os_linux {\n+          session::os_linux => {\n             ~\"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\"\n           }\n \n-          session::os_freebsd {\n+          session::os_freebsd => {\n             ~\"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\"\n           }\n         },\n \n         target_triple: alt target_os {\n-          session::os_macos { ~\"i686-apple-darwin\" }\n-          session::os_win32 { ~\"i686-pc-mingw32\" }\n-          session::os_linux { ~\"i686-unknown-linux-gnu\" }\n-          session::os_freebsd { ~\"i686-unknown-freebsd\" }\n+          session::os_macos => ~\"i686-apple-darwin\",\n+          session::os_win32 => ~\"i686-pc-mingw32\",\n+          session::os_linux => ~\"i686-unknown-linux-gnu\",\n+          session::os_freebsd => ~\"i686-unknown-freebsd\"\n         },\n \n         cc_args: ~[~\"-m32\"]"}, {"sha": "70a35eb328910494b02fcfa2209aadc021628e4b", "filename": "src/rustc/back/x86_64.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fx86_64.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -9,37 +9,37 @@ fn get_target_strs(target_os: session::os) -> target_strs::t {\n         meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)),\n \n         data_layout: alt target_os {\n-          session::os_macos {\n+          session::os_macos => {\n             ~\"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n                 ~\"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 ~\"s0:64:64-f80:128:128-n8:16:32:64\"\n           }\n \n-          session::os_win32 {\n+          session::os_win32 => {\n             // FIXME: Test this. Copied from linux (#2398)\n             ~\"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n                 ~\"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 ~\"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n           }\n \n-          session::os_linux {\n+          session::os_linux => {\n             ~\"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n                 ~\"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 ~\"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n           }\n \n-          session::os_freebsd {\n+          session::os_freebsd => {\n             ~\"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n                 ~\"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 ~\"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n           }\n         },\n \n         target_triple: alt target_os {\n-          session::os_macos { ~\"x86_64-apple-darwin\" }\n-          session::os_win32 { ~\"x86_64-pc-mingw32\" }\n-          session::os_linux { ~\"x86_64-unknown-linux-gnu\" }\n-          session::os_freebsd { ~\"x86_64-unknown-freebsd\" }\n+          session::os_macos => ~\"x86_64-apple-darwin\",\n+          session::os_win32 => ~\"x86_64-pc-mingw32\",\n+          session::os_linux => ~\"x86_64-unknown-linux-gnu\",\n+          session::os_freebsd => ~\"x86_64-unknown-freebsd\",\n         },\n \n         cc_args: ~[~\"-m64\"]"}, {"sha": "5a07c8f411cdf20920985b583a383e7d64146dc0", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 67, "deletions": 74, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -27,27 +27,27 @@ fn anon_src() -> ~str { ~\"<anon>\" }\n \n fn source_name(input: input) -> ~str {\n     alt input {\n-      file_input(ifile) { ifile }\n-      str_input(_) { anon_src() }\n+      file_input(ifile) => ifile,\n+      str_input(_) => anon_src()\n     }\n }\n \n fn default_configuration(sess: session, argv0: ~str, input: input) ->\n    ast::crate_cfg {\n     let libc = alt sess.targ_cfg.os {\n-      session::os_win32 { ~\"msvcrt.dll\" }\n-      session::os_macos { ~\"libc.dylib\" }\n-      session::os_linux { ~\"libc.so.6\" }\n-      session::os_freebsd { ~\"libc.so.7\" }\n+      session::os_win32 => ~\"msvcrt.dll\",\n+      session::os_macos => ~\"libc.dylib\",\n+      session::os_linux => ~\"libc.so.6\",\n+      session::os_freebsd => ~\"libc.so.7\"\n       // _ { \"libc.so\" }\n     };\n \n     let mk = attr::mk_name_value_item_str;\n \n     let (arch,wordsz) = alt sess.targ_cfg.arch {\n-      session::arch_x86 { (~\"x86\",~\"32\") }\n-      session::arch_x86_64 { (~\"x86_64\",~\"64\") }\n-      session::arch_arm { (~\"arm\",~\"32\") }\n+      session::arch_x86 => (~\"x86\",~\"32\"),\n+      session::arch_x86_64 => (~\"x86_64\",~\"64\"),\n+      session::arch_arm => (~\"arm\",~\"32\")\n     };\n \n     return ~[ // Target bindings.\n@@ -100,10 +100,10 @@ enum input {\n fn parse_input(sess: session, cfg: ast::crate_cfg, input: input)\n     -> @ast::crate {\n     alt input {\n-      file_input(file) {\n+      file_input(file) => {\n         parse::parse_crate_from_file(file, cfg, sess.parse_sess)\n       }\n-      str_input(src) {\n+      str_input(src) => {\n         // FIXME (#2319): Don't really want to box the source string\n         parse::parse_crate_from_source_str(\n             anon_src(), @src, cfg, sess.parse_sess)\n@@ -270,37 +270,40 @@ fn compile_input(sess: session, cfg: ast::crate_cfg, input: input,\n fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: input,\n                       ppm: pp_mode) {\n     fn ann_paren_for_expr(node: pprust::ann_node) {\n-        alt node { pprust::node_expr(s, expr) { pprust::popen(s); } _ { } }\n+        alt node {\n+          pprust::node_expr(s, expr) => pprust::popen(s),\n+          _ => ()\n+        }\n     }\n     fn ann_typed_post(tcx: ty::ctxt, node: pprust::ann_node) {\n         alt node {\n-          pprust::node_expr(s, expr) {\n+          pprust::node_expr(s, expr) => {\n             pp::space(s.s);\n             pp::word(s.s, ~\"as\");\n             pp::space(s.s);\n             pp::word(s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n             pprust::pclose(s);\n           }\n-          _ { }\n+          _ => ()\n         }\n     }\n     fn ann_identified_post(node: pprust::ann_node) {\n         alt node {\n-          pprust::node_item(s, item) {\n+          pprust::node_item(s, item) => {\n             pp::space(s.s);\n             pprust::synth_comment(s, int::to_str(item.id, 10u));\n           }\n-          pprust::node_block(s, blk) {\n+          pprust::node_block(s, blk) => {\n             pp::space(s.s);\n             pprust::synth_comment(s,\n                                   ~\"block \" + int::to_str(blk.node.id, 10u));\n           }\n-          pprust::node_expr(s, expr) {\n+          pprust::node_expr(s, expr) => {\n             pp::space(s.s);\n             pprust::synth_comment(s, int::to_str(expr.id, 10u));\n             pprust::pclose(s);\n           }\n-          pprust::node_pat(s, pat) {\n+          pprust::node_pat(s, pat) => {\n             pp::space(s.s);\n             pprust::synth_comment(s, ~\"pat \" + int::to_str(pat.id, 10u));\n           }\n@@ -312,21 +315,21 @@ fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: input,\n     // from stdin, we're going to just suck the source into a string\n     // so both the parser and pretty-printer can use it.\n     let upto = alt ppm {\n-      ppm_expanded | ppm_expanded_identified { cu_expand }\n-      ppm_typed { cu_typeck }\n-      _ { cu_parse }\n+      ppm_expanded | ppm_expanded_identified => cu_expand,\n+      ppm_typed => cu_typeck,\n+      _ => cu_parse\n     };\n     let {crate, tcx} = compile_upto(sess, cfg, input, upto, none);\n \n     let ann = alt ppm {\n-      ppm_typed {\n+      ppm_typed => {\n         {pre: ann_paren_for_expr,\n          post: |a| ann_typed_post(option::get(tcx), a) }\n       }\n-      ppm_identified | ppm_expanded_identified {\n+      ppm_identified | ppm_expanded_identified => {\n         {pre: ann_paren_for_expr, post: ann_identified_post}\n       }\n-      ppm_expanded | ppm_normal { pprust::no_ann() }\n+      ppm_expanded | ppm_normal => pprust::no_ann()\n     };\n     let is_expanded = upto != cu_parse;\n     let src = codemap::get_filemap(sess.codemap, source_name(input)).src;\n@@ -369,23 +372,23 @@ fn get_arch(triple: ~str) -> option<session::arch> {\n fn build_target_config(sopts: @session::options,\n                        demitter: diagnostic::emitter) -> @session::config {\n     let os = alt get_os(sopts.target_triple) {\n-      some(os) { os }\n-      none { early_error(demitter, ~\"unknown operating system\") }\n+      some(os) => os,\n+      none => early_error(demitter, ~\"unknown operating system\")\n     };\n     let arch = alt get_arch(sopts.target_triple) {\n-      some(arch) { arch }\n-      none { early_error(demitter,\n-                          ~\"unknown architecture: \" + sopts.target_triple) }\n+      some(arch) => arch,\n+      none => early_error(demitter,\n+                          ~\"unknown architecture: \" + sopts.target_triple)\n     };\n     let (int_type, uint_type, float_type) = alt arch {\n-      session::arch_x86 {(ast::ty_i32, ast::ty_u32, ast::ty_f64)}\n-      session::arch_x86_64 {(ast::ty_i64, ast::ty_u64, ast::ty_f64)}\n-      session::arch_arm {(ast::ty_i32, ast::ty_u32, ast::ty_f64)}\n+      session::arch_x86 => (ast::ty_i32, ast::ty_u32, ast::ty_f64),\n+      session::arch_x86_64 => (ast::ty_i64, ast::ty_u64, ast::ty_f64),\n+      session::arch_arm => (ast::ty_i32, ast::ty_u32, ast::ty_f64)\n     };\n     let target_strs = alt arch {\n-      session::arch_x86 {x86::get_target_strs(os)}\n-      session::arch_x86_64 {x86_64::get_target_strs(os)}\n-      session::arch_arm {x86::get_target_strs(os)}\n+      session::arch_x86 => x86::get_target_strs(os),\n+      session::arch_x86_64 => x86_64::get_target_strs(os),\n+      session::arch_arm => x86::get_target_strs(os)\n     };\n     let target_cfg: @session::config =\n         @{os: os, arch: arch, target_strs: target_strs, int_type: int_type,\n@@ -436,11 +439,11 @@ fn build_session_options(matches: getopts::matches,\n         for flags.each |lint_name| {\n             let lint_name = str::replace(lint_name, ~\"-\", ~\"_\");\n             alt lint_dict.find(lint_name) {\n-              none {\n+              none => {\n                 early_error(demitter, fmt!{\"unknown %s flag: %s\",\n                                            level_name, lint_name});\n               }\n-              some(lint) {\n+              some(lint) => {\n                 vec::push(lint_opts, (lint.lint, level));\n               }\n             }\n@@ -485,8 +488,8 @@ fn build_session_options(matches: getopts::matches,\n     let save_temps = getopts::opt_present(matches, ~\"save-temps\");\n     alt output_type {\n       // unless we're emitting huamn-readable assembly, omit comments.\n-      link::output_type_llvm_assembly | link::output_type_assembly {}\n-      _ { debugging_opts |= session::no_asm_comments; }\n+      link::output_type_llvm_assembly | link::output_type_assembly => (),\n+      _ => debugging_opts |= session::no_asm_comments\n     }\n     let opt_level: uint =\n         if opt_present(matches, ~\"O\") {\n@@ -496,20 +499,20 @@ fn build_session_options(matches: getopts::matches,\n             2u\n         } else if opt_present(matches, ~\"opt-level\") {\n             alt getopts::opt_str(matches, ~\"opt-level\") {\n-              ~\"0\" { 0u }\n-              ~\"1\" { 1u }\n-              ~\"2\" { 2u }\n-              ~\"3\" { 3u }\n-              _ {\n+              ~\"0\" => 0u,\n+              ~\"1\" => 1u,\n+              ~\"2\" => 2u,\n+              ~\"3\" => 3u,\n+              _ => {\n                 early_error(demitter, ~\"optimization level needs \" +\n                             ~\"to be between 0-3\")\n               }\n             }\n         } else { 0u };\n     let target =\n         alt target_opt {\n-            none { host_triple() }\n-            some(s) { s }\n+            none => host_triple(),\n+            some(s) => s\n         };\n \n     let addl_lib_search_paths = getopts::opt_strs(matches, ~\"L\");\n@@ -626,43 +629,33 @@ fn build_output_filenames(input: input,\n \n     let obj_suffix =\n         alt sopts.output_type {\n-          link::output_type_none { ~\"none\" }\n-          link::output_type_bitcode { ~\"bc\" }\n-          link::output_type_assembly { ~\"s\" }\n-          link::output_type_llvm_assembly { ~\"ll\" }\n+          link::output_type_none => ~\"none\",\n+          link::output_type_bitcode => ~\"bc\",\n+          link::output_type_assembly => ~\"s\",\n+          link::output_type_llvm_assembly => ~\"ll\",\n           // Object and exe output both use the '.o' extension here\n-          link::output_type_object | link::output_type_exe {\n-            ~\"o\"\n-          }\n+          link::output_type_object | link::output_type_exe => ~\"o\"\n         };\n \n     alt ofile {\n-      none {\n+      none => {\n         // \"-\" as input file will cause the parser to read from stdin so we\n         // have to make up a name\n         // We want to toss everything after the final '.'\n         let dirname = alt odir {\n-          some(d) { d }\n-          none {\n-            alt input {\n-              str_input(_) {\n-                os::getcwd()\n-              }\n-              file_input(ifile) {\n-                path::dirname(ifile)\n-              }\n-            }\n+          some(d) => d,\n+          none => alt input {\n+            str_input(_) => os::getcwd(),\n+            file_input(ifile) => path::dirname(ifile)\n           }\n         };\n \n         let base_filename = alt input {\n-          file_input(ifile) {\n+          file_input(ifile) => {\n             let (path, _) = path::splitext(ifile);\n             path::basename(path)\n           }\n-          str_input(_) {\n-            ~\"rust_out\"\n-          }\n+          str_input(_) => ~\"rust_out\"\n         };\n         let base_path = path::connect(dirname, base_filename);\n \n@@ -678,7 +671,7 @@ fn build_output_filenames(input: input,\n         }\n       }\n \n-      some(out_file) {\n+      some(out_file) => {\n         out_path = out_file;\n         obj_path = if stop_after_codegen {\n             out_file\n@@ -722,9 +715,9 @@ mod test {\n     fn test_switch_implies_cfg_test() {\n         let matches =\n             alt getopts::getopts(~[~\"--test\"], opts()) {\n-              ok(m) { m }\n-              err(f) { fail ~\"test_switch_implies_cfg_test: \" +\n-                       getopts::fail_str(f); }\n+              ok(m) => m,\n+              err(f) => fail ~\"test_switch_implies_cfg_test: \" +\n+                             getopts::fail_str(f)\n             };\n         let sessopts = build_session_options(matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n@@ -738,8 +731,8 @@ mod test {\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n             alt getopts::getopts(~[~\"--test\", ~\"--cfg=test\"], opts()) {\n-              ok(m) { m }\n-              err(f) {\n+              ok(m) => m,\n+              err(f) => {\n                 fail ~\"test_switch_implies_cfg_test_unless_cfg_test: \" +\n                     getopts::fail_str(f);\n               }"}, {"sha": "483e1ca5808404615944e282ef87c5da102c20a0", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -96,10 +96,10 @@ fn describe_warnings() {\n         io::println(fmt!{\"    %s  %7.7s  %s\",\n                          padded(max_key, k),\n                          alt v.default {\n-                             lint::allow { ~\"allow\" }\n-                             lint::warn { ~\"warn\" }\n-                             lint::deny { ~\"deny\" }\n-                             lint::forbid { ~\"forbid\" }\n+                             lint::allow => ~\"allow\",\n+                             lint::warn => ~\"warn\",\n+                             lint::deny => ~\"deny\",\n+                             lint::forbid => ~\"forbid\"\n                          },\n                          v.desc});\n     }\n@@ -125,8 +125,8 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n \n     let matches =\n         alt getopts::getopts(args, opts()) {\n-          ok(m) { m }\n-          err(f) {\n+          ok(m) => m,\n+          err(f) => {\n             early_error(demitter, getopts::fail_str(f))\n           }\n         };\n@@ -153,8 +153,8 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n         return;\n     }\n     let input = alt vec::len(matches.free) {\n-      0u { early_error(demitter, ~\"no input filename given\") }\n-      1u {\n+      0u => early_error(demitter, ~\"no input filename given\"),\n+      1u => {\n         let ifile = matches.free[0];\n         if ifile == ~\"-\" {\n             let src = str::from_bytes(io::stdin().read_whole_stream());\n@@ -163,7 +163,7 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n             file_input(ifile)\n         }\n       }\n-      _ { early_error(demitter, ~\"multiple input filenames provided\") }\n+      _ => early_error(demitter, ~\"multiple input filenames provided\")\n     };\n \n     let sopts = build_session_options(matches, demitter);\n@@ -176,19 +176,19 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n                                          ~\"normal\"),\n                     |a| parse_pretty(sess, a) );\n     alt pretty {\n-      some::<pp_mode>(ppm) {\n+      some::<pp_mode>(ppm) => {\n         pretty_print_input(sess, cfg, input, ppm);\n         return;\n       }\n-      none::<pp_mode> {/* continue */ }\n+      none::<pp_mode> => {/* continue */ }\n     }\n     let ls = opt_present(matches, ~\"ls\");\n     if ls {\n         alt input {\n-          file_input(ifile) {\n+          file_input(ifile) => {\n             list_metadata(sess, ifile, io::stdout());\n           }\n-          str_input(_) {\n+          str_input(_) => {\n             early_error(demitter, ~\"can not list metadata for stdin\");\n           }\n         }\n@@ -241,8 +241,8 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n \n         f(demitter)\n     } {\n-        result::ok(_) { /* fallthrough */ }\n-        result::err(_) {\n+        result::ok(_) => { /* fallthrough */ }\n+        result::err(_) => {\n             // Task failed without emitting a fatal diagnostic\n             if comm::recv(p) == done {\n                 diagnostic::emit("}, {"sha": "200dd1b00d73cec034b326f958be5979563fbaf4", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -153,9 +153,9 @@ impl session for session {\n     fn span_lint_level(level: lint::level,\n                        sp: span, msg: ~str) {\n         alt level {\n-          lint::allow { }\n-          lint::warn { self.span_warn(sp, msg); }\n-          lint::deny | lint::forbid {\n+          lint::allow => { },\n+          lint::warn => self.span_warn(sp, msg),\n+          lint::deny | lint::forbid => {\n             self.span_err(sp, msg);\n           }\n         }\n@@ -220,17 +220,17 @@ fn expect<T: copy>(sess: session, opt: option<T>, msg: fn() -> ~str) -> T {\n fn building_library(req_crate_type: crate_type, crate: @ast::crate,\n                     testing: bool) -> bool {\n     alt req_crate_type {\n-      bin_crate { false }\n-      lib_crate { true }\n-      unknown_crate {\n+      bin_crate => false,\n+      lib_crate => true,\n+      unknown_crate => {\n         if testing {\n             false\n         } else {\n             alt syntax::attr::first_attr_value_str_by_name(\n                 crate.node.attrs,\n                 ~\"crate_type\") {\n-              option::some(@~\"lib\") { true }\n-              _ { false }\n+              option::some(@~\"lib\") => true,\n+              _ => false\n             }\n         }\n       }\n@@ -241,10 +241,10 @@ fn sess_os_to_meta_os(os: os) -> metadata::loader::os {\n     import metadata::loader;\n \n     alt os {\n-      os_win32 { loader::os_win32 }\n-      os_linux { loader::os_linux }\n-      os_macos { loader::os_macos }\n-      os_freebsd { loader::os_freebsd }\n+      os_win32 => loader::os_win32,\n+      os_linux => loader::os_linux,\n+      os_macos => loader::os_macos,\n+      os_freebsd => loader::os_freebsd\n     }\n }\n "}, {"sha": "92035856ddf5a2009e769d3537cfb0b77fa53a06", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -83,17 +83,17 @@ fn fold_foreign_mod(cx: ctxt, nm: ast::foreign_mod,\n fn filter_stmt(cx: ctxt, &&stmt: @ast::stmt) ->\n    option<@ast::stmt> {\n     alt stmt.node {\n-      ast::stmt_decl(decl, _) {\n+      ast::stmt_decl(decl, _) => {\n         alt decl.node {\n-          ast::decl_item(item) {\n+          ast::decl_item(item) => {\n             if item_in_cfg(cx, item) {\n                 option::some(stmt)\n             } else { option::none }\n           }\n-          _ { option::some(stmt) }\n+          _ => option::some(stmt)\n         }\n       }\n-      _ { option::some(stmt) }\n+      _ => option::some(stmt)\n     }\n }\n "}, {"sha": "cc80a524f31ab372dc78c438eb3a25ee8c9deea5", "filename": "src/rustc/front/intrinsic_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic_inject.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -16,8 +16,8 @@ fn inject_intrinsic(sess: session,\n                                                  sess.parse_sess);\n     let item =\n         alt item {\n-          some(i) { i }\n-          none {\n+          some(i) => i,\n+          none => {\n             sess.fatal(~\"no item found in intrinsic module\");\n           }\n         };"}, {"sha": "66e430f27cd1e6bff39b164b89e0eee2b6877942", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -71,12 +71,12 @@ fn fold_mod(_cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     // indicate to the translation pass which function we want to be main.\n     fn nomain(&&item: @ast::item) -> option<@ast::item> {\n         alt item.node {\n-          ast::item_fn(_, _, _) {\n+          ast::item_fn(_, _, _) => {\n             if *item.ident == ~\"main\" {\n                 option::none\n             } else { option::some(item) }\n           }\n-          _ { option::some(item) }\n+          _ => option::some(item)\n         }\n     }\n \n@@ -103,12 +103,12 @@ fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n \n     if is_test_fn(i) {\n         alt i.node {\n-          ast::item_fn(decl, _, _) if decl.purity == ast::unsafe_fn {\n+          ast::item_fn(decl, _, _) if decl.purity == ast::unsafe_fn => {\n             cx.sess.span_fatal(\n                 i.span,\n                 ~\"unsafe functions cannot be used for tests\");\n           }\n-          _ {\n+          _ => {\n             debug!{\"this is a test function\"};\n             let test = {span: i.span,\n                         path: cx.path, ignore: is_ignored(cx, i),\n@@ -130,13 +130,13 @@ fn is_test_fn(i: @ast::item) -> bool {\n \n     fn has_test_signature(i: @ast::item) -> bool {\n         alt i.node {\n-          ast::item_fn(decl, tps, _) {\n+          ast::item_fn(decl, tps, _) => {\n             let input_cnt = vec::len(decl.inputs);\n             let no_output = decl.output.node == ast::ty_nil;\n             let tparm_cnt = vec::len(tps);\n             input_cnt == 0u && no_output && tparm_cnt == 0u\n           }\n-          _ { false }\n+          _ => false\n         }\n     }\n \n@@ -247,8 +247,8 @@ fn mk_path(cx: test_ctxt, path: ~[ast::ident]) -> ~[ast::ident] {\n     let is_std = {\n         let items = attr::find_linkage_metas(cx.crate.node.attrs);\n         alt attr::last_meta_item_value_str_by_name(items, ~\"name\") {\n-          some(@~\"std\") { true }\n-          _ { false }\n+          some(@~\"std\") => true,\n+          _ => false\n         }\n     };\n     if is_std { path }"}, {"sha": "1effed07f13e48f0835049134446fc743940a869", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -1016,8 +1016,8 @@ fn type_to_str(names: type_names, ty: TypeRef) -> ~str {\n fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n    ~str {\n     alt type_has_name(names, ty) {\n-      option::some(n) { return n; }\n-      _ {}\n+      option::some(n) => return n,\n+      _ => {}\n     }\n \n     let outer = vec::append_one(outer0, ty);\n@@ -1036,18 +1036,18 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n     }\n \n     alt kind {\n-      Void { return ~\"Void\"; }\n-      Half { return ~\"Half\"; }\n-      Float { return ~\"Float\"; }\n-      Double { return ~\"Double\"; }\n-      X86_FP80 { return ~\"X86_FP80\"; }\n-      FP128 { return ~\"FP128\"; }\n-      PPC_FP128 { return ~\"PPC_FP128\"; }\n-      Label { return ~\"Label\"; }\n-      Integer {\n+      Void => return ~\"Void\",\n+      Half => return ~\"Half\",\n+      Float => return ~\"Float\",\n+      Double => return ~\"Double\",\n+      X86_FP80 => return ~\"X86_FP80\",\n+      FP128 => return ~\"FP128\",\n+      PPC_FP128 => return ~\"PPC_FP128\",\n+      Label => return ~\"Label\",\n+      Integer => {\n         return ~\"i\" + int::str(llvm::LLVMGetIntTypeWidth(ty) as int);\n       }\n-      Function {\n+      Function => {\n         let mut s = ~\"fn(\";\n         let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n         let n_args = llvm::LLVMCountParamTypes(ty) as uint;\n@@ -1060,7 +1060,7 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n         s += type_to_str_inner(names, outer, out_ty);\n         return s;\n       }\n-      Struct {\n+      Struct => {\n         let mut s: ~str = ~\"{\";\n         let n_elts = llvm::LLVMCountStructElementTypes(ty) as uint;\n         let elts = vec::from_elem(n_elts, 0 as TypeRef);\n@@ -1071,12 +1071,12 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n         s += ~\"}\";\n         return s;\n       }\n-      Array {\n+      Array => {\n         let el_ty = llvm::LLVMGetElementType(ty);\n         return ~\"[\" + type_to_str_inner(names, outer, el_ty) + ~\" x \" +\n             uint::str(llvm::LLVMGetArrayLength(ty) as uint) + ~\"]\";\n       }\n-      Pointer {\n+      Pointer => {\n         let mut i: uint = 0u;\n         for outer0.each |tout| {\n             i += 1u;\n@@ -1096,19 +1096,19 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n         return addrstr + ~\"*\" +\n                 type_to_str_inner(names, outer, llvm::LLVMGetElementType(ty));\n       }\n-      Vector { return ~\"Vector\"; }\n-      Metadata { return ~\"Metadata\"; }\n-      X86_MMX { return ~\"X86_MMAX\"; }\n+      Vector => return ~\"Vector\",\n+      Metadata => return ~\"Metadata\",\n+      X86_MMX => return ~\"X86_MMAX\"\n     }\n }\n \n fn float_width(llt: TypeRef) -> uint {\n     return alt llvm::LLVMGetTypeKind(llt) as int {\n-          1 { 32u }\n-          2 { 64u }\n-          3 { 80u }\n-          4 | 5 { 128u }\n-          _ { fail ~\"llvm_float_width called on a non-float type\" }\n+          1 => 32u,\n+          2 => 64u,\n+          3 => 80u,\n+          4 | 5 => 128u,\n+          _ => fail ~\"llvm_float_width called on a non-float type\"\n         };\n }\n "}, {"sha": "03dd9c389dde2cb7e4b13aec69e3401527d4f7c8", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -101,38 +101,38 @@ type env = @{diag: span_handler,\n \n fn visit_view_item(e: env, i: @ast::view_item) {\n     alt i.node {\n-      ast::view_item_use(ident, meta_items, id) {\n+      ast::view_item_use(ident, meta_items, id) => {\n         debug!{\"resolving use stmt. ident: %?, meta: %?\", ident, meta_items};\n         let cnum = resolve_crate(e, ident, meta_items, ~\"\", i.span);\n         cstore::add_use_stmt_cnum(e.cstore, id, cnum);\n       }\n-      _ { }\n+      _ => ()\n     }\n }\n \n fn visit_item(e: env, i: @ast::item) {\n     alt i.node {\n-      ast::item_foreign_mod(m) {\n+      ast::item_foreign_mod(m) => {\n         alt attr::foreign_abi(i.attrs) {\n-          either::right(abi) {\n+          either::right(abi) => {\n             if abi != ast::foreign_abi_cdecl &&\n                abi != ast::foreign_abi_stdcall { return; }\n           }\n-          either::left(msg) { e.diag.span_fatal(i.span, msg); }\n+          either::left(msg) => e.diag.span_fatal(i.span, msg)\n         }\n \n         let cstore = e.cstore;\n         let foreign_name =\n             alt attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n-              some(nn) {\n+              some(nn) => {\n                 if *nn == ~\"\" {\n                     e.diag.span_fatal(\n                         i.span,\n                         ~\"empty #[link_name] not allowed; use #[nolink].\");\n                 }\n                 nn\n               }\n-              none { i.ident }\n+              none => i.ident\n             };\n         let mut already_added = false;\n         if vec::len(attr::find_attrs_by_name(i.attrs, ~\"nolink\")) == 0u {\n@@ -145,14 +145,14 @@ fn visit_item(e: env, i: @ast::item) {\n         }\n         for link_args.each |a| {\n             alt attr::get_meta_item_value_str(attr::attr_meta(a)) {\n-              some(linkarg) {\n+              some(linkarg) => {\n                 cstore::add_used_link_args(cstore, *linkarg);\n               }\n-              none {/* fallthrough */ }\n+              none => {/* fallthrough */ }\n             }\n         }\n       }\n-      _ { }\n+      _ => { }\n     }\n }\n \n@@ -188,7 +188,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n     let metas = metas_with_ident(ident, metas);\n \n     alt existing_match(e, metas, hash) {\n-      none {\n+      none => {\n         let load_ctxt: loader::ctxt = {\n             diag: e.diag,\n             filesearch: e.filesearch,\n@@ -219,8 +219,8 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n \n         let cname =\n             alt attr::last_meta_item_value_str_by_name(metas, ~\"name\") {\n-              option::some(v) { v }\n-              option::none { ident }\n+              option::some(v) => v,\n+              option::none => ident\n             };\n         let cmeta = @{name: *cname, data: cdata,\n                       cnum_map: cnum_map, cnum: cnum};\n@@ -230,7 +230,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n         cstore::add_used_crate_file(cstore, cfilename);\n         return cnum;\n       }\n-      some(cnum) {\n+      some(cnum) => {\n         return cnum;\n       }\n     }\n@@ -249,12 +249,12 @@ fn resolve_crate_deps(e: env, cdata: @~[u8]) -> cstore::cnum_map {\n         debug!{\"resolving dep crate %s ver: %s hash: %s\",\n                *dep.name, *dep.vers, *dep.hash};\n         alt existing_match(e, metas_with_ident(cname, cmetas), *dep.hash) {\n-          some(local_cnum) {\n+          some(local_cnum) => {\n             debug!{\"already have it\"};\n             // We've already seen this crate\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }\n-          none {\n+          none => {\n             debug!{\"need to load it\"};\n             // This is a new one so we've got to load it\n             // FIXME (#2404): Need better error reporting than just a bogus"}, {"sha": "1a536ca1bdd2df7f8e453ae4bc0c125b63bec345", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -58,7 +58,7 @@ fn lookup_method_purity(cstore: cstore::cstore, did: ast::def_id)\n     -> ast::purity {\n     let cdata = cstore::get_crate_data(cstore, did.crate).data;\n     alt check decoder::lookup_def(did.crate, cdata, did) {\n-      ast::def_fn(_, p) { p }\n+      ast::def_fn(_, p) => p\n     }\n }\n "}, {"sha": "a177b264e5bf44648a7c8a98e681530ae8e55b73", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -64,7 +64,7 @@ type use_crate_map = map::hashmap<ast::node_id, ast::crate_num>;\n \n // Internal method to retrieve the data from the cstore\n pure fn p(cstore: cstore) -> cstore_private {\n-    alt cstore { private(p) { p } }\n+    alt cstore { private(p) => p }\n }\n \n fn mk_cstore() -> cstore {"}, {"sha": "2e4a670c84117f64d68a40019f4938254aa5e7f6", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 84, "deletions": 82, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -100,8 +100,8 @@ fn find_item(item_id: int, items: ebml::doc) -> ebml::doc {\n fn lookup_item(item_id: int, data: @~[u8]) -> ebml::doc {\n     let items = ebml::get_doc(ebml::doc(data), tag_items);\n     alt maybe_find_item(item_id, items) {\n-       none { fail(fmt!{\"lookup_item: id not found: %d\", item_id}); }\n-       some(d) { d }\n+       none => fail(fmt!{\"lookup_item: id not found: %d\", item_id}),\n+       some(d) => d\n     }\n }\n \n@@ -136,8 +136,8 @@ fn field_mutability(d: ebml::doc) -> ast::class_mutability {\n         ast::class_immutable,\n         |d| {\n             alt ebml::doc_as_u8(d) as char {\n-              'm' { ast::class_mutable }\n-              _   { ast::class_immutable }\n+              'm' => ast::class_mutable,\n+              _   => ast::class_immutable\n             }\n         })\n }\n@@ -185,8 +185,8 @@ fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n \n fn item_ty_region_param(item: ebml::doc) -> bool {\n     alt ebml::maybe_get_doc(item, tag_region_param) {\n-      some(_) { true }\n-      none { false }\n+      some(_) => true,\n+      none => false\n     }\n }\n \n@@ -276,26 +276,26 @@ fn item_to_def_like(item: ebml::doc, did: ast::def_id, cnum: ast::crate_num)\n         -> def_like {\n     let fam_ch = item_family(item);\n     alt fam_ch {\n-      'c' { dl_def(ast::def_const(did)) }\n-      'C' { dl_def(ast::def_class(did, true)) }\n-      'S' { dl_def(ast::def_class(did, false)) }\n-      'u' { dl_def(ast::def_fn(did, ast::unsafe_fn)) }\n-      'f' { dl_def(ast::def_fn(did, ast::impure_fn)) }\n-      'p' { dl_def(ast::def_fn(did, ast::pure_fn)) }\n-      'F' { dl_def(ast::def_fn(did, ast::extern_fn)) }\n-      'y' { dl_def(ast::def_ty(did)) }\n-      't' { dl_def(ast::def_ty(did)) }\n-      'm' { dl_def(ast::def_mod(did)) }\n-      'n' { dl_def(ast::def_foreign_mod(did)) }\n-      'v' {\n+      'c' => dl_def(ast::def_const(did)),\n+      'C' => dl_def(ast::def_class(did, true)),\n+      'S' => dl_def(ast::def_class(did, false)),\n+      'u' => dl_def(ast::def_fn(did, ast::unsafe_fn)),\n+      'f' => dl_def(ast::def_fn(did, ast::impure_fn)),\n+      'p' => dl_def(ast::def_fn(did, ast::pure_fn)),\n+      'F' => dl_def(ast::def_fn(did, ast::extern_fn)),\n+      'y' => dl_def(ast::def_ty(did)),\n+      't' => dl_def(ast::def_ty(did)),\n+      'm' => dl_def(ast::def_mod(did)),\n+      'n' => dl_def(ast::def_foreign_mod(did)),\n+      'v' => {\n         let mut tid = option::get(item_parent_item(item));\n         tid = {crate: cnum, node: tid.node};\n         dl_def(ast::def_variant(tid, did))\n       }\n-      'I' { dl_def(ast::def_ty(did)) }\n-      'i' { dl_impl(did) }\n-      'g' | 'j' | 'N' => { dl_field }\n-      ch { fail fmt!{\"unexpected family code: '%c'\", ch} }\n+      'I' => dl_def(ast::def_ty(did)),\n+      'i' => dl_impl(did),\n+      'g' | 'j' | 'N' => dl_field,\n+      ch => fail fmt!{\"unexpected family code: '%c'\", ch}\n     }\n }\n \n@@ -350,28 +350,29 @@ fn get_class_method(cdata: cmd, id: ast::node_id,\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n     let mut found = none;\n     let cls_items = alt maybe_find_item(id, items) {\n-            some(it) { it }\n-            none { fail (fmt!{\"get_class_method: class id not found \\\n-             when looking up method %s\", *name}) }};\n+      some(it) => it,\n+      none => fail (fmt!{\"get_class_method: class id not found \\\n+                              when looking up method %s\", *name})\n+    };\n     for ebml::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n         let m_did = class_member_id(mid, cdata);\n         if item_name(mid) == name {\n             found = some(m_did);\n         }\n     }\n     alt found {\n-      some(found) { found }\n-      none { fail (fmt!{\"get_class_method: no method named %s\", *name}) }\n+      some(found) => found,\n+      none => fail (fmt!{\"get_class_method: no method named %s\", *name})\n     }\n }\n \n fn class_dtor(cdata: cmd, id: ast::node_id) -> option<ast::def_id> {\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n     let mut found = none;\n     let cls_items = alt maybe_find_item(id, items) {\n-            some(it) { it }\n-            none     { fail (fmt!{\"class_dtor: class id not found \\\n-              when looking up dtor for %d\", id}); }\n+            some(it) => it,\n+            none     => fail (fmt!{\"class_dtor: class id not found \\\n+              when looking up dtor for %d\", id})\n     };\n     for ebml::tagged_docs(cls_items, tag_item_dtor) |doc| {\n          let doc1 = ebml::get_doc(doc, tag_def_id);\n@@ -394,9 +395,9 @@ enum def_like {\n \n fn def_like_to_def(def_like: def_like) -> ast::def {\n     alt def_like {\n-        dl_def(def) { return def; }\n-        dl_impl(*) { fail ~\"found impl in def_like_to_def\"; }\n-        dl_field { fail ~\"found field in def_like_to_def\"; }\n+        dl_def(def) => return def,\n+        dl_impl(*) => fail ~\"found impl in def_like_to_def\",\n+        dl_field => fail ~\"found field in def_like_to_def\"\n     }\n }\n \n@@ -467,11 +468,11 @@ fn each_path(cdata: cmd, f: fn(path_entry) -> bool) {\n \n             // Get the item.\n             alt maybe_find_item(def_id.node, items) {\n-                none {\n+                none => {\n                     debug!{\"(each_path) ignoring implicit item: %s\",\n                             *path};\n                 }\n-                some(item_doc) {\n+                some(item_doc) => {\n                     // Construct the def for this item.\n                     let def_like = item_to_def_like(item_doc, def_id,\n                                                     cdata.cnum);\n@@ -515,19 +516,19 @@ fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n     let item_doc = lookup_item(id, cdata.data);\n     let path = vec::init(item_path(item_doc));\n     alt decode_inlined_item(cdata, tcx, path, item_doc) {\n-      some(ii) { csearch::found(ii) }\n-      none {\n+      some(ii) => csearch::found(ii),\n+      none => {\n         alt item_parent_item(item_doc) {\n-          some(did) {\n+          some(did) => {\n             let did = translate_def_id(cdata, did);\n             let parent_item = lookup_item(did.node, cdata.data);\n             alt decode_inlined_item(cdata, tcx, path,\n                                                parent_item) {\n-              some(ii) { csearch::found_parent(did, ii) }\n-              none { csearch::not_found }\n+              some(ii) => csearch::found_parent(did, ii),\n+              none => csearch::not_found\n             }\n           }\n-          none { csearch::not_found }\n+          none => csearch::not_found\n         }\n       }\n     }\n@@ -548,14 +549,14 @@ fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n         let name = item_name(item);\n         let mut arg_tys: ~[ty::t] = ~[];\n         alt ty::get(ctor_ty).struct {\n-          ty::ty_fn(f) {\n+          ty::ty_fn(f) => {\n             for f.inputs.each |a| { vec::push(arg_tys, a.ty); }\n           }\n-          _ { /* Nullary enum variant. */ }\n+          _ => { /* Nullary enum variant. */ }\n         }\n         alt variant_disr_val(item) {\n-          some(val) { disr_val = val; }\n-          _         { /* empty */ }\n+          some(val) => { disr_val = val; }\n+          _         => { /* empty */ }\n         }\n         vec::push(infos, @{args: arg_tys, ctor_ty: ctor_ty, name: name,\n                            id: did, disr_val: disr_val});\n@@ -653,7 +654,7 @@ fn get_impls_for_mod(cdata: cmd,\n         let impl_data = impl_cdata.data;\n         let item = lookup_item(local_did.node, impl_data);\n         let nm = item_name(item);\n-        if alt name { some(n) { n == nm } none { true } } {\n+        if alt name { some(n) => { n == nm } none => { true } } {\n            let base_tps = item_ty_param_count(item);\n            vec::push(result, @{\n                 did: local_did, ident: nm,\n@@ -674,18 +675,19 @@ fn get_trait_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(mth);\n         let ty = doc_type(mth, tcx, cdata);\n-        let fty = alt ty::get(ty).struct { ty::ty_fn(f) { f }\n-          _ {\n+        let fty = alt ty::get(ty).struct {\n+          ty::ty_fn(f) => f,\n+          _ => {\n             tcx.diag.handler().bug(\n                 ~\"get_trait_methods: id has non-function type\");\n         } };\n         let self_ty = get_self_ty(mth);\n         vec::push(result, {ident: name, tps: bounds, fty: fty,\n                     self_ty: self_ty,\n                     purity: alt check item_family(mth) {\n-                      'u' { ast::unsafe_fn }\n-                      'f' { ast::impure_fn }\n-                      'p' { ast::pure_fn }\n+                      'u' => ast::unsafe_fn,\n+                      'f' => ast::impure_fn,\n+                      'p' => ast::pure_fn\n                     }, vis: ast::public});\n     }\n     @result\n@@ -755,15 +757,15 @@ fn get_class_fields(cdata: cmd, id: ast::node_id) -> ~[ty::field_ty] {\n \n fn family_has_type_params(fam_ch: char) -> bool {\n     alt check fam_ch {\n-      'c' | 'T' | 'm' | 'n' | 'g' | 'h' | 'j' { false }\n+      'c' | 'T' | 'm' | 'n' | 'g' | 'h' | 'j' => false,\n       'f' | 'u' | 'p' | 'F' | 'U' | 'P' | 'y' | 't' | 'v' | 'i' | 'I' | 'C'\n           | 'a' | 'S'\n-          { true }\n+          => true\n     }\n }\n \n fn family_names_type(fam_ch: char) -> bool {\n-    alt fam_ch { 'y' | 't' | 'I' { true } _ { false } }\n+    alt fam_ch { 'y' | 't' | 'I' => true, _ => false }\n }\n \n fn read_path(d: ebml::doc) -> {path: ~str, pos: uint} {\n@@ -777,34 +779,34 @@ fn read_path(d: ebml::doc) -> {path: ~str, pos: uint} {\n fn describe_def(items: ebml::doc, id: ast::def_id) -> ~str {\n     if id.crate != ast::local_crate { return ~\"external\"; }\n     let it = alt maybe_find_item(id.node, items) {\n-        some(it) { it }\n-        none { fail (fmt!{\"describe_def: item not found %?\", id}); }\n+        some(it) => it,\n+        none => fail (fmt!{\"describe_def: item not found %?\", id})\n     };\n     return item_family_to_str(item_family(it));\n }\n \n fn item_family_to_str(fam: char) -> ~str {\n     alt check fam {\n-      'c' { return ~\"const\"; }\n-      'f' { return ~\"fn\"; }\n-      'u' { return ~\"unsafe fn\"; }\n-      'p' { return ~\"pure fn\"; }\n-      'F' { return ~\"foreign fn\"; }\n-      'U' { return ~\"unsafe foreign fn\"; }\n-      'P' { return ~\"pure foreign fn\"; }\n-      'y' { return ~\"type\"; }\n-      'T' { return ~\"foreign type\"; }\n-      't' { return ~\"type\"; }\n-      'm' { return ~\"mod\"; }\n-      'n' { return ~\"foreign mod\"; }\n-      'v' { return ~\"enum\"; }\n-      'i' { return ~\"impl\"; }\n-      'I' { return ~\"trait\"; }\n-      'C' { return ~\"class\"; }\n-      'S' { return ~\"struct\"; }\n-      'g' { return ~\"public field\"; }\n-      'j' { return ~\"private field\"; }\n-      'N' { return ~\"inherited field\"; }\n+      'c' => return ~\"const\",\n+      'f' => return ~\"fn\",\n+      'u' => return ~\"unsafe fn\",\n+      'p' => return ~\"pure fn\",\n+      'F' => return ~\"foreign fn\",\n+      'U' => return ~\"unsafe foreign fn\",\n+      'P' => return ~\"pure foreign fn\",\n+      'y' => return ~\"type\",\n+      'T' => return ~\"foreign type\",\n+      't' => return ~\"type\",\n+      'm' => return ~\"mod\",\n+      'n' => return ~\"foreign mod\",\n+      'v' => return ~\"enum\",\n+      'i' => return ~\"impl\",\n+      'I' => return ~\"trait\",\n+      'C' => return ~\"class\",\n+      'S' => return ~\"struct\",\n+      'g' => return ~\"public field\",\n+      'j' => return ~\"private field\",\n+      'N' => return ~\"inherited field\"\n     }\n }\n \n@@ -836,7 +838,7 @@ fn get_meta_items(md: ebml::doc) -> ~[@ast::meta_item] {\n fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n     let mut attrs: ~[ast::attribute] = ~[];\n     alt ebml::maybe_get_doc(md, tag_attributes) {\n-      option::some(attrs_d) {\n+      option::some(attrs_d) => {\n         for ebml::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n@@ -849,7 +851,7 @@ fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n                        span: ast_util::dummy_sp()});\n         };\n       }\n-      option::none { }\n+      option::none => ()\n     }\n     return attrs;\n }\n@@ -916,8 +918,8 @@ fn get_crate_vers(data: @~[u8]) -> @~str {\n     let attrs = decoder::get_crate_attributes(data);\n     return alt attr::last_meta_item_value_str_by_name(\n         attr::find_linkage_metas(attrs), ~\"vers\") {\n-      some(ver) { ver }\n-      none { @~\"0.0\" }\n+      some(ver) => ver,\n+      none => @~\"0.0\"\n     };\n }\n \n@@ -996,8 +998,8 @@ fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n     }\n \n     alt cdata.cnum_map.find(did.crate) {\n-      option::some(n) { return {crate: n, node: did.node}; }\n-      option::none { fail ~\"didn't find a crate in the cnum_map\"; }\n+      option::some(n) => return {crate: n, node: did.node},\n+      option::none => fail ~\"didn't find a crate in the cnum_map\"\n     }\n }\n "}, {"sha": "fc23c8b351cfe0cdfaddc6e579c9a1f43f96aba3", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 73, "deletions": 75, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -101,9 +101,12 @@ fn encode_named_def_id(ebml_w: ebml::writer, name: ident, id: def_id) {\n \n fn encode_mutability(ebml_w: ebml::writer, mt: class_mutability) {\n     do ebml_w.wr_tag(tag_class_mut) {\n-        ebml_w.writer.write(&[alt mt { class_immutable { 'i' }\n-                class_mutable { 'm' } } as u8]);\n-        }\n+        let val = alt mt {\n+          class_immutable => 'i',\n+          class_mutable => 'm'\n+        };\n+        ebml_w.writer.write(&[val as u8]);\n+    }\n }\n \n type entry<T> = {val: T, pos: uint};\n@@ -143,11 +146,11 @@ fn encode_class_item_paths(ebml_w: ebml::writer,\n      items: ~[@class_member], path: ~[ident], &index: ~[entry<~str>]) {\n     for items.each |it| {\n      alt ast_util::class_member_visibility(it) {\n-          private { again; }\n-          public | inherited {\n+          private => again,\n+          public | inherited => {\n               let (id, ident) = alt it.node {\n-                 instance_var(v, _, _, vid, _) { (vid, v) }\n-                 class_method(it) { (it.id, it.ident) }\n+                 instance_var(v, _, _, vid, _) => (vid, v),\n+                 class_method(it) => (it.id, it.ident)\n               };\n               add_to_index(ebml_w, path, index, ident);\n               encode_named_def_id(ebml_w, ident, local_def(id));\n@@ -166,34 +169,34 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n             add_to_index(ebml_w, path, index, it.ident);\n         }\n         alt it.node {\n-          item_const(_, _) {\n+          item_const(_, _) => {\n             encode_named_def_id(ebml_w, it.ident, local_def(it.id));\n           }\n-          item_fn(_, tps, _) {\n+          item_fn(_, tps, _) => {\n             encode_named_def_id(ebml_w, it.ident, local_def(it.id));\n           }\n-          item_mod(_mod) {\n+          item_mod(_mod) => {\n             do ebml_w.wr_tag(tag_paths_data_mod) {\n                encode_name_and_def_id(ebml_w, it.ident, it.id);\n                encode_module_item_paths(ebml_w, ecx, _mod,\n                                         vec::append_one(path, it.ident),\n                                         index);\n             }\n           }\n-          item_foreign_mod(nmod) {\n+          item_foreign_mod(nmod) => {\n             do ebml_w.wr_tag(tag_paths_data_mod) {\n               encode_name_and_def_id(ebml_w, it.ident, it.id);\n               encode_foreign_module_item_paths(\n                   ebml_w, nmod,\n                   vec::append_one(path, it.ident), index);\n             }\n           }\n-          item_ty(_, tps) {\n+          item_ty(_, tps) => {\n             do ebml_w.wr_tag(tag_paths_data_item) {\n               encode_name_and_def_id(ebml_w, it.ident, it.id);\n             }\n           }\n-          item_class(_, _, items, m_ctor, m_dtor) {\n+          item_class(_, _, items, m_ctor, m_dtor) => {\n             do ebml_w.wr_tag(tag_paths_data_item) {\n                 encode_name_and_def_id(ebml_w, it.ident, it.id);\n             }\n@@ -206,7 +209,7 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                     none => {\n                         // Nothing to do.\n                     }\n-                    some(ctor) {\n+                    some(ctor) => {\n                         encode_named_def_id(ebml_w, it.ident,\n                                             local_def(ctor.node.id));\n                     }\n@@ -217,19 +220,19 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                                         index);\n             }\n           }\n-          item_enum(variants, _) {\n+          item_enum(variants, _) => {\n             do ebml_w.wr_tag(tag_paths_data_item) {\n                   encode_name_and_def_id(ebml_w, it.ident, it.id);\n               }\n               encode_enum_variant_paths(ebml_w, variants, path, index);\n           }\n-          item_trait(*) {\n+          item_trait(*) => {\n             do ebml_w.wr_tag(tag_paths_data_item) {\n                   encode_name_and_def_id(ebml_w, it.ident, it.id);\n               }\n           }\n-          item_impl(*) {}\n-          item_mac(*) { fail ~\"item macros unimplemented\" }\n+          item_impl(*) => {}\n+          item_mac(*) => fail ~\"item macros unimplemented\"\n         }\n     }\n }\n@@ -315,8 +318,8 @@ fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     let sym = alt ecx.item_symbols.find(id) {\n-      some(x) { x }\n-      none {\n+      some(x) => x,\n+      none => {\n         ecx.diag.handler().bug(\n             fmt!{\"encode_symbol: id not found %d\", id});\n       }\n@@ -380,8 +383,8 @@ fn encode_path(ebml_w: ebml::writer,\n                name: ast_map::path_elt) {\n     fn encode_path_elt(ebml_w: ebml::writer, elt: ast_map::path_elt) {\n         let (tag, name) = alt elt {\n-          ast_map::path_mod(name) { (tag_path_elt_mod, name) }\n-          ast_map::path_name(name) { (tag_path_elt_name, name) }\n+          ast_map::path_mod(name) => (tag_path_elt_mod, name),\n+          ast_map::path_name(name) => (tag_path_elt_name, name)\n         };\n \n         ebml_w.wr_tagged_str(tag, *name);\n@@ -414,12 +417,12 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n \n         ebml_w.start_tag(tag_mod_impl);\n         alt ecx.tcx.items.find(did.node) {\n-          some(ast_map::node_item(it@@{node: cl@item_class(*),_},_)) {\n+          some(ast_map::node_item(it@@{node: cl@item_class(*),_},_)) => {\n         /* If did stands for a trait\n         ref, we need to map it to its parent class */\n             ebml_w.wr_str(def_to_str(local_def(it.id)));\n           }\n-          _ {\n+          _ => {\n             // Must be a re-export, then!\n             // ...or a trait ref\n             ebml_w.wr_str(def_to_str(did));\n@@ -434,7 +437,9 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n \n fn encode_visibility(ebml_w: ebml::writer, visibility: visibility) {\n     encode_family(ebml_w, alt visibility {\n-        public { 'g' } private { 'j' } inherited { 'N' }\n+        public => 'g',\n+        private => 'j',\n+        inherited => 'N'\n     });\n }\n \n@@ -504,7 +509,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n       alt ci.node {\n-        instance_var(nm, _, mt, id, vis) {\n+        instance_var(nm, _, mt, id, vis) => {\n           vec::push(*index, {val: id, pos: ebml_w.writer.tell()});\n           vec::push(*global_index, {val: id, pos: ebml_w.writer.tell()});\n           ebml_w.start_tag(tag_items_data_item);\n@@ -517,9 +522,9 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n           encode_def_id(ebml_w, local_def(id));\n           ebml_w.end_tag();\n         }\n-        class_method(m) {\n+        class_method(m) => {\n            alt m.vis {\n-              public | inherited {\n+              public | inherited => {\n                 vec::push(*index, {val: m.id, pos: ebml_w.writer.tell()});\n                 vec::push(*global_index,\n                           {val: m.id, pos: ebml_w.writer.tell()});\n@@ -530,7 +535,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                                        should_inline(m.attrs), id, m,\n                                        vec::append(class_tps, m.tps));\n             }\n-            _ { /* don't encode private methods */ }\n+            _ => { /* don't encode private methods */ }\n           }\n         }\n       }\n@@ -553,10 +558,10 @@ fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_type(ecx, ebml_w, its_ty);\n         encode_path(ebml_w, path, ast_map::path_name(ident));\n         alt item {\n-           some(it) {\n+           some(it) => {\n              ecx.encode_inlined_item(ecx, ebml_w, path, it);\n            }\n-           none {\n+           none => {\n              encode_symbol(ecx, ebml_w, id);\n            }\n         }\n@@ -588,18 +593,18 @@ fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml::writer,\n \n fn purity_fn_family(p: purity) -> char {\n     alt p {\n-      unsafe_fn { 'u' }\n-      pure_fn { 'p' }\n-      impure_fn { 'f' }\n-      extern_fn { 'F' }\n+      unsafe_fn => 'u',\n+      pure_fn => 'p',\n+      impure_fn => 'f',\n+      extern_fn => 'F'\n     }\n }\n \n \n fn should_inline(attrs: ~[attribute]) -> bool {\n     alt attr::find_inline_attr(attrs) {\n-        attr::ia_none | attr::ia_never  { false }\n-        attr::ia_hint | attr::ia_always { true  }\n+        attr::ia_none | attr::ia_never  => false,\n+        attr::ia_hint | attr::ia_always => true\n     }\n }\n \n@@ -610,12 +615,9 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n     let tcx = ecx.tcx;\n     let must_write =\n         alt item.node {\n-            item_enum(_, _) | item_impl(*) | item_trait(*) | item_class(*) {\n-                true\n-            }\n-            _ {\n-                false\n-            }\n+          item_enum(_, _) | item_impl(*)\n+          | item_trait(*) | item_class(*) => true,\n+          _ => false\n         };\n     if !must_write && !reachable(ecx, item.id) { return; }\n \n@@ -626,7 +628,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n     let add_to_index = |copy ebml_w| add_to_index_(item, ebml_w, index);\n \n     alt item.node {\n-      item_const(_, _) {\n+      item_const(_, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -636,7 +638,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n-      item_fn(decl, tps, _) {\n+      item_fn(decl, tps, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -651,11 +653,11 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         }\n         ebml_w.end_tag();\n       }\n-      item_mod(m) {\n+      item_mod(m) => {\n         add_to_index();\n         encode_info_for_mod(ecx, ebml_w, m, item.id, path, item.ident);\n       }\n-      item_foreign_mod(_) {\n+      item_foreign_mod(_) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -664,7 +666,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n-      item_ty(_, tps) {\n+      item_ty(_, tps) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -676,7 +678,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_region_param(ecx, ebml_w, item);\n         ebml_w.end_tag();\n       }\n-      item_enum(variants, tps) {\n+      item_enum(variants, tps) => {\n         add_to_index();\n         do ebml_w.wr_tag(tag_items_data_item) {\n             encode_def_id(ebml_w, local_def(item.id));\n@@ -694,7 +696,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_enum_variant_info(ecx, ebml_w, item.id, variants,\n                                  path, index, tps);\n       }\n-      item_class(tps, traits, items, ctor, m_dtor) {\n+      item_class(tps, traits, items, ctor, m_dtor) => {\n         /* First, encode the fields and methods\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n@@ -718,12 +720,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_def_id(ebml_w, local_def(item.id));\n \n         alt ctor {\n-            none {\n-                encode_family(ebml_w, 'S');\n-            }\n-            some(_) {\n-                encode_family(ebml_w, 'C');\n-            }\n+            none => encode_family(ebml_w, 'S'),\n+            some(_) => encode_family(ebml_w, 'C')\n         }\n \n         encode_type_param_bounds(ebml_w, ecx, tps);\n@@ -755,8 +753,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         }\n         for ms.each |m| {\n            alt m.vis {\n-              private { /* do nothing */ }\n-              public | inherited {\n+              private => { /* do nothing */ }\n+              public | inherited => {\n                 /* Write the info that's needed when viewing this class\n                    as a trait */\n                 ebml_w.start_tag(tag_item_trait_method);\n@@ -780,7 +778,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_index(ebml_w, bkts, write_int);\n         ebml_w.end_tag();\n       }\n-      item_impl(tps, traits, _, methods) {\n+      item_impl(tps, traits, _, methods) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -813,7 +811,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                                    vec::append(tps, m.tps));\n         }\n       }\n-      item_trait(tps, traits, ms) {\n+      item_trait(tps, traits, ms) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -826,7 +824,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         let mut i = 0u;\n         for vec::each(*ty::trait_methods(tcx, local_def(item.id))) |mty| {\n             alt ms[i] {\n-              required(ty_m) {\n+              required(ty_m) => {\n                 ebml_w.start_tag(tag_item_trait_method);\n                 encode_name(ebml_w, mty.ident);\n                 encode_type_param_bounds(ebml_w, ecx, ty_m.tps);\n@@ -835,7 +833,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                 encode_self_type(ebml_w, mty.self_ty);\n                 ebml_w.end_tag();\n               }\n-              provided(m) {\n+              provided(m) => {\n                 encode_info_for_method(ecx, ebml_w, path,\n                                        should_inline(m.attrs), item.id,\n                                        m, m.tps);\n@@ -849,7 +847,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         }\n         ebml_w.end_tag();\n       }\n-      item_mac(*) { fail ~\"item macros unimplemented\" }\n+      item_mac(*) => fail ~\"item macros unimplemented\"\n     }\n }\n \n@@ -862,7 +860,7 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n \n     ebml_w.start_tag(tag_items_data_item);\n     alt nitem.node {\n-      foreign_item_fn(fn_decl, tps) {\n+      foreign_item_fn(fn_decl, tps) => {\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, purity_fn_family(fn_decl.purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n@@ -891,11 +889,11 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         visit_item: |i, cx, v, copy ebml_w| {\n             visit::visit_item(i, cx, v);\n             alt check ecx.tcx.items.get(i.id) {\n-              ast_map::node_item(_, pt) {\n+              ast_map::node_item(_, pt) => {\n                 encode_info_for_item(ecx, ebml_w, i, index, *pt);\n                 /* encode ctor, then encode items */\n                 alt i.node {\n-                   item_class(tps, _, _, some(ctor), m_dtor) {\n+                   item_class(tps, _, _, some(ctor), m_dtor) => {\n                        debug!{\"encoding info for ctor %s %d\", *i.ident,\n                               ctor.node.id};\n                        vec::push(*index, {\n@@ -908,15 +906,15 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                                               local_def(i.id))) }\n                           else { none }, tps, ctor.node.dec);\n                    }\n-                   _ {}\n+                   _ => {}\n                 }\n               }\n             }\n         },\n         visit_foreign_item: |ni, cx, v, copy ebml_w| {\n             visit::visit_foreign_item(ni, cx, v);\n             alt check ecx.tcx.items.get(ni.id) {\n-              ast_map::node_foreign_item(_, abi, pt) {\n+              ast_map::node_foreign_item(_, abi, pt) => {\n                 encode_info_for_foreign_item(ecx, ebml_w, ni,\n                                              index, *pt, abi);\n               }\n@@ -984,16 +982,16 @@ fn write_int(writer: io::writer, &&n: int) {\n \n fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n     alt mi.node {\n-      meta_word(name) {\n+      meta_word(name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n         ebml_w.start_tag(tag_meta_item_name);\n         ebml_w.writer.write(str::bytes(*name));\n         ebml_w.end_tag();\n         ebml_w.end_tag();\n       }\n-      meta_name_value(name, value) {\n+      meta_name_value(name, value) => {\n         alt value.node {\n-          lit_str(value) {\n+          lit_str(value) => {\n             ebml_w.start_tag(tag_meta_item_name_value);\n             ebml_w.start_tag(tag_meta_item_name);\n             ebml_w.writer.write(str::bytes(*name));\n@@ -1003,10 +1001,10 @@ fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n             ebml_w.end_tag();\n             ebml_w.end_tag();\n           }\n-          _ {/* FIXME (#623): encode other variants */ }\n+          _ => {/* FIXME (#623): encode other variants */ }\n         }\n       }\n-      meta_list(name, items) {\n+      meta_list(name, items) => {\n         ebml_w.start_tag(tag_meta_item_list);\n         ebml_w.start_tag(tag_meta_item_name);\n         ebml_w.writer.write(str::bytes(*name));\n@@ -1067,11 +1065,11 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n                 attr\n             } else {\n                 alt attr.node.value.node {\n-                  meta_list(n, l) {\n+                  meta_list(n, l) => {\n                     found_link_attr = true;;\n                     synthesize_link_attr(ecx, l)\n                   }\n-                  _ { attr }\n+                  _ => attr\n                 }\n             });\n     }"}, {"sha": "656aa4a0ae29cd9ad66a3c6a5ecc20c0f6e9f095", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -44,12 +44,12 @@ fn mk_filesearch(maybe_sysroot: option<path>,\n             vec::push(paths,\n                       make_target_lib_path(self.sysroot, self.target_triple));\n             alt get_cargo_lib_path_nearest() {\n-              result::ok(p) { vec::push(paths, p) }\n-              result::err(p) { }\n+              result::ok(p) => vec::push(paths, p),\n+              result::err(p) => ()\n             }\n             alt get_cargo_lib_path() {\n-              result::ok(p) { vec::push(paths, p) }\n-              result::err(p) { }\n+              result::ok(p) => vec::push(paths, p),\n+              result::err(p) => ()\n             }\n             paths\n         }\n@@ -102,17 +102,15 @@ fn make_target_lib_path(sysroot: path,\n \n fn get_default_sysroot() -> path {\n     alt os::self_exe_path() {\n-      option::some(p) { path::normalize(path::connect(p, ~\"..\")) }\n-      option::none {\n-        fail ~\"can't determine value for sysroot\";\n-      }\n+      option::some(p) => path::normalize(path::connect(p, ~\"..\")),\n+      option::none => fail ~\"can't determine value for sysroot\"\n     }\n }\n \n fn get_sysroot(maybe_sysroot: option<path>) -> path {\n     alt maybe_sysroot {\n-      option::some(sr) { sr }\n-      option::none { get_default_sysroot() }\n+      option::some(sr) => sr,\n+      option::none => get_default_sysroot()\n     }\n }\n \n@@ -123,12 +121,10 @@ fn get_cargo_sysroot() -> result<path, ~str> {\n \n fn get_cargo_root() -> result<path, ~str> {\n     alt os::getenv(~\"CARGO_ROOT\") {\n-        some(_p) { result::ok(_p) }\n-        none {\n-          alt os::homedir() {\n-            some(_q) { result::ok(path::connect(_q, ~\".cargo\")) }\n-            none { result::err(~\"no CARGO_ROOT or home directory\") }\n-          }\n+        some(_p) => result::ok(_p),\n+        none => alt os::homedir() {\n+          some(_q) => result::ok(path::connect(_q, ~\".cargo\")),\n+          none => result::err(~\"no CARGO_ROOT or home directory\")\n         }\n     }\n }"}, {"sha": "e45fdeb06b8388aa2b4c680ed17310e9a9923184", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -38,8 +38,8 @@ type ctxt = {\n \n fn load_library_crate(cx: ctxt) -> {ident: ~str, data: @~[u8]} {\n     alt find_library_crate(cx) {\n-      some(t) { return t; }\n-      none {\n+      some(t) => return t,\n+      none => {\n         cx.diag.span_fatal(\n             cx.span, fmt!{\"can't find crate for `%s`\", *cx.ident});\n       }\n@@ -54,10 +54,10 @@ fn find_library_crate(cx: ctxt) -> option<{ident: ~str, data: @~[u8]}> {\n fn libname(cx: ctxt) -> {prefix: ~str, suffix: ~str} {\n     if cx.static { return {prefix: ~\"lib\", suffix: ~\".rlib\"}; }\n     alt cx.os {\n-      os_win32 { return {prefix: ~\"\", suffix: ~\".dll\"}; }\n-      os_macos { return {prefix: ~\"lib\", suffix: ~\".dylib\"}; }\n-      os_linux { return {prefix: ~\"lib\", suffix: ~\".so\"}; }\n-      os_freebsd { return {prefix: ~\"lib\", suffix: ~\".so\"}; }\n+      os_win32 => return {prefix: ~\"\", suffix: ~\".dll\"},\n+      os_macos => return {prefix: ~\"lib\", suffix: ~\".dylib\"},\n+      os_linux => return {prefix: ~\"lib\", suffix: ~\".so\"},\n+      os_freebsd => return {prefix: ~\"lib\", suffix: ~\".so\"}\n     }\n }\n \n@@ -80,7 +80,7 @@ fn find_library_crate_aux(cx: ctxt,\n         } else {\n             debug!{\"%s is a candidate\", path};\n             alt get_metadata_section(cx.os, path) {\n-              option::some(cvec) {\n+              option::some(cvec) => {\n                 if !crate_matches(cvec, cx.metas, cx.hash) {\n                     debug!{\"skipping %s, metadata doesn't match\", path};\n                     option::none::<()>\n@@ -90,7 +90,7 @@ fn find_library_crate_aux(cx: ctxt,\n                     option::none::<()>\n                 }\n               }\n-              _ {\n+              _ => {\n                 debug!{\"could not load metadata for %s\", path};\n                 option::none::<()>\n               }\n@@ -119,15 +119,15 @@ fn find_library_crate_aux(cx: ctxt,\n fn crate_name_from_metas(metas: ~[@ast::meta_item]) -> @~str {\n     let name_items = attr::find_meta_items_by_name(metas, ~\"name\");\n     alt vec::last_opt(name_items) {\n-      some(i) {\n+      some(i) => {\n         alt attr::get_meta_item_value_str(i) {\n-          some(n) { n }\n+          some(n) => n,\n           // FIXME (#2406): Probably want a warning here since the user\n           // is using the wrong type of meta item.\n-          _ { fail }\n+          _ => fail\n         }\n       }\n-      none { fail ~\"expected to find the crate name\" }\n+      none => fail ~\"expected to find the crate name\"\n     }\n }\n \n@@ -176,8 +176,8 @@ fn get_metadata_section(os: os,\n                                    });\n     if mb as int == 0 { return option::none::<@~[u8]>; }\n     let of = alt mk_object_file(mb) {\n-        option::some(of) { of }\n-        _ { return option::none::<@~[u8]>; }\n+        option::some(of) => of,\n+        _ => return option::none::<@~[u8]>\n     };\n     let si = mk_section_iter(of.llof);\n     while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n@@ -198,18 +198,18 @@ fn get_metadata_section(os: os,\n \n fn meta_section_name(os: os) -> ~str {\n     alt os {\n-      os_macos { ~\"__DATA,__note.rustc\" }\n-      os_win32 { ~\".note.rustc\" }\n-      os_linux { ~\".note.rustc\" }\n-      os_freebsd { ~\".note.rustc\" }\n+      os_macos => ~\"__DATA,__note.rustc\",\n+      os_win32 => ~\".note.rustc\",\n+      os_linux => ~\".note.rustc\",\n+      os_freebsd => ~\".note.rustc\"\n     }\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n fn list_file_metadata(os: os, path: ~str, out: io::writer) {\n     alt get_metadata_section(os, path) {\n-      option::some(bytes) { decoder::list_crate_metadata(bytes, out); }\n-      option::none {\n+      option::some(bytes) => decoder::list_crate_metadata(bytes, out),\n+      option::none => {\n         out.write_str(~\"could not find metadata in \" + path + ~\".\\n\");\n       }\n     }"}, {"sha": "fee68f5592ddb2f6f2fa0350b5e9e33269503b7c", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 91, "deletions": 91, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -58,8 +58,8 @@ fn parse_ty_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n \n fn parse_ret_ty(st: @pstate, conv: conv_did) -> (ast::ret_style, ty::t) {\n     alt peek(st) {\n-      '!' { next(st); (ast::noreturn, ty::mk_bot(st.tcx)) }\n-      _ { (ast::return_val, parse_ty(st, conv)) }\n+      '!' => { next(st); (ast::noreturn, ty::mk_bot(st.tcx)) }\n+      _ => (ast::return_val, parse_ty(st, conv))\n     }\n }\n \n@@ -69,8 +69,8 @@ fn parse_path(st: @pstate) -> @ast::path {\n     vec::push(idents, parse_ident_(st, is_last));\n     loop {\n         alt peek(st) {\n-          ':' { next(st); next(st); }\n-          c {\n+          ':' => { next(st); next(st); }\n+          c => {\n             if c == '(' {\n                 return @{span: ast_util::dummy_sp(),\n                       global: false, idents: idents,\n@@ -87,11 +87,11 @@ fn parse_ty_rust_fn(st: @pstate, conv: conv_did) -> ty::t {\n \n fn parse_proto(c: char) -> ast::proto {\n     alt c {\n-      '~' { ast::proto_uniq }\n-      '@' { ast::proto_box }\n-      '&' { ast::proto_block }\n-      'n' { ast::proto_bare }\n-      _ { fail ~\"illegal fn type kind \" + str::from_char(c); }\n+      '~' => ast::proto_uniq,\n+      '@' => ast::proto_box,\n+      '&' => ast::proto_block,\n+      'n' => ast::proto_bare,\n+      _ => fail ~\"illegal fn type kind \" + str::from_char(c)\n     }\n }\n \n@@ -106,9 +106,9 @@ fn parse_vstore(st: @pstate) -> ty::vstore {\n     }\n \n     alt check next(st) {\n-      '~' { ty::vstore_uniq }\n-      '@' { ty::vstore_box }\n-      '&' { ty::vstore_slice(parse_region(st)) }\n+      '~' => ty::vstore_uniq,\n+      '@' => ty::vstore_box,\n+      '&' => ty::vstore_slice(parse_region(st))\n     }\n }\n \n@@ -129,10 +129,10 @@ fn parse_substs(st: @pstate, conv: conv_did) -> ty::substs {\n \n fn parse_bound_region(st: @pstate) -> ty::bound_region {\n     alt check next(st) {\n-      's' { ty::br_self }\n-      'a' { ty::br_anon }\n-      '[' { ty::br_named(@parse_str(st, ']')) }\n-      'c' {\n+      's' => ty::br_self,\n+      'a' => ty::br_anon,\n+      '[' => ty::br_named(@parse_str(st, ']')),\n+      'c' => {\n         let id = parse_int(st);\n         assert next(st) == '|';\n         ty::br_cap_avoid(id, @parse_bound_region(st))\n@@ -142,32 +142,32 @@ fn parse_bound_region(st: @pstate) -> ty::bound_region {\n \n fn parse_region(st: @pstate) -> ty::region {\n     alt check next(st) {\n-      'b' {\n+      'b' => {\n         ty::re_bound(parse_bound_region(st))\n       }\n-      'f' {\n+      'f' => {\n         assert next(st) == '[';\n         let id = parse_int(st);\n         assert next(st) == '|';\n         let br = parse_bound_region(st);\n         assert next(st) == ']';\n         ty::re_free(id, br)\n       }\n-      's' {\n+      's' => {\n         let id = parse_int(st);\n         assert next(st) == '|';\n         ty::re_scope(id)\n       }\n-      't' {\n+      't' => {\n         ty::re_static\n       }\n     }\n }\n \n fn parse_opt<T>(st: @pstate, f: fn() -> T) -> option<T> {\n     alt check next(st) {\n-      'n' { none }\n-      's' { some(f()) }\n+      'n' => none,\n+      's' => some(f())\n     }\n }\n \n@@ -182,67 +182,67 @@ fn parse_str(st: @pstate, term: char) -> ~str {\n \n fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n     alt check next(st) {\n-      'n' { return ty::mk_nil(st.tcx); }\n-      'z' { return ty::mk_bot(st.tcx); }\n-      'b' { return ty::mk_bool(st.tcx); }\n-      'i' { return ty::mk_int(st.tcx); }\n-      'u' { return ty::mk_uint(st.tcx); }\n-      'l' { return ty::mk_float(st.tcx); }\n-      'M' {\n+      'n' => return ty::mk_nil(st.tcx),\n+      'z' => return ty::mk_bot(st.tcx),\n+      'b' => return ty::mk_bool(st.tcx),\n+      'i' => return ty::mk_int(st.tcx),\n+      'u' => return ty::mk_uint(st.tcx),\n+      'l' => return ty::mk_float(st.tcx),\n+      'M' => {\n         alt check next(st) {\n-          'b' { return ty::mk_mach_uint(st.tcx, ast::ty_u8); }\n-          'w' { return ty::mk_mach_uint(st.tcx, ast::ty_u16); }\n-          'l' { return ty::mk_mach_uint(st.tcx, ast::ty_u32); }\n-          'd' { return ty::mk_mach_uint(st.tcx, ast::ty_u64); }\n-          'B' { return ty::mk_mach_int(st.tcx, ast::ty_i8); }\n-          'W' { return ty::mk_mach_int(st.tcx, ast::ty_i16); }\n-          'L' { return ty::mk_mach_int(st.tcx, ast::ty_i32); }\n-          'D' { return ty::mk_mach_int(st.tcx, ast::ty_i64); }\n-          'f' { return ty::mk_mach_float(st.tcx, ast::ty_f32); }\n-          'F' { return ty::mk_mach_float(st.tcx, ast::ty_f64); }\n+          'b' => return ty::mk_mach_uint(st.tcx, ast::ty_u8),\n+          'w' => return ty::mk_mach_uint(st.tcx, ast::ty_u16),\n+          'l' => return ty::mk_mach_uint(st.tcx, ast::ty_u32),\n+          'd' => return ty::mk_mach_uint(st.tcx, ast::ty_u64),\n+          'B' => return ty::mk_mach_int(st.tcx, ast::ty_i8),\n+          'W' => return ty::mk_mach_int(st.tcx, ast::ty_i16),\n+          'L' => return ty::mk_mach_int(st.tcx, ast::ty_i32),\n+          'D' => return ty::mk_mach_int(st.tcx, ast::ty_i64),\n+          'f' => return ty::mk_mach_float(st.tcx, ast::ty_f32),\n+          'F' => return ty::mk_mach_float(st.tcx, ast::ty_f64)\n         }\n       }\n-      'c' { return ty::mk_char(st.tcx); }\n-      't' {\n+      'c' => return ty::mk_char(st.tcx),\n+      't' => {\n         assert (next(st) == '[');\n         let def = parse_def(st, conv);\n         let substs = parse_substs(st, conv);\n         assert next(st) == ']';\n         return ty::mk_enum(st.tcx, def, substs);\n       }\n-      'x' {\n+      'x' => {\n         assert next(st) == '[';\n         let def = parse_def(st, conv);\n         let substs = parse_substs(st, conv);\n         assert next(st) == ']';\n         return ty::mk_trait(st.tcx, def, substs);\n       }\n-      'p' {\n+      'p' => {\n         let did = parse_def(st, conv);\n         return ty::mk_param(st.tcx, parse_int(st) as uint, did);\n       }\n-      's' {\n+      's' => {\n         return ty::mk_self(st.tcx);\n       }\n-      '@' { return ty::mk_box(st.tcx, parse_mt(st, conv)); }\n-      '~' { return ty::mk_uniq(st.tcx, parse_mt(st, conv)); }\n-      '*' { return ty::mk_ptr(st.tcx, parse_mt(st, conv)); }\n-      '&' {\n+      '@' => return ty::mk_box(st.tcx, parse_mt(st, conv)),\n+      '~' => return ty::mk_uniq(st.tcx, parse_mt(st, conv)),\n+      '*' => return ty::mk_ptr(st.tcx, parse_mt(st, conv)),\n+      '&' => {\n         let r = parse_region(st);\n         let mt = parse_mt(st, conv);\n         return ty::mk_rptr(st.tcx, r, mt);\n       }\n-      'U' { return ty::mk_unboxed_vec(st.tcx, parse_mt(st, conv)); }\n-      'V' {\n+      'U' => return ty::mk_unboxed_vec(st.tcx, parse_mt(st, conv)),\n+      'V' => {\n         let mt = parse_mt(st, conv);\n         let v = parse_vstore(st);\n         return ty::mk_evec(st.tcx, mt, v);\n       }\n-      'v' {\n+      'v' => {\n         let v = parse_vstore(st);\n         return ty::mk_estr(st.tcx, v);\n       }\n-      'R' {\n+      'R' => {\n         assert (next(st) == '[');\n         let mut fields: ~[ty::field] = ~[];\n         while peek(st) != ']' {\n@@ -252,50 +252,50 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         st.pos = st.pos + 1u;\n         return ty::mk_rec(st.tcx, fields);\n       }\n-      'T' {\n+      'T' => {\n         assert (next(st) == '[');\n         let mut params = ~[];\n         while peek(st) != ']' { vec::push(params, parse_ty(st, conv)); }\n         st.pos = st.pos + 1u;\n         return ty::mk_tup(st.tcx, params);\n       }\n-      'f' {\n+      'f' => {\n         parse_ty_rust_fn(st, conv)\n       }\n-      'X' {\n+      'X' => {\n         return ty::mk_var(st.tcx, ty::tv_vid(parse_int(st) as uint));\n       }\n-      'Y' { return ty::mk_type(st.tcx); }\n-      'C' {\n+      'Y' => return ty::mk_type(st.tcx),\n+      'C' => {\n         let ck = alt check next(st) {\n-          '&' { ty::ck_block }\n-          '@' { ty::ck_box }\n-          '~' { ty::ck_uniq }\n+          '&' => ty::ck_block,\n+          '@' => ty::ck_box,\n+          '~' => ty::ck_uniq\n         };\n         return ty::mk_opaque_closure_ptr(st.tcx, ck);\n       }\n-      '#' {\n+      '#' => {\n         let pos = parse_hex(st);\n         assert (next(st) == ':');\n         let len = parse_hex(st);\n         assert (next(st) == '#');\n         alt st.tcx.rcache.find({cnum: st.crate, pos: pos, len: len}) {\n-          some(tt) { return tt; }\n-          none {\n+          some(tt) => return tt,\n+          none => {\n             let ps = @{pos: pos with *st};\n             let tt = parse_ty(ps, conv);\n             st.tcx.rcache.insert({cnum: st.crate, pos: pos, len: len}, tt);\n             return tt;\n           }\n         }\n       }\n-      '\"' {\n+      '\"' => {\n         let def = parse_def(st, conv);\n         let inner = parse_ty(st, conv);\n         ty::mk_with_id(st.tcx, inner, def)\n       }\n-      'B' { ty::mk_opaque_box(st.tcx) }\n-      'a' {\n+      'B' => ty::mk_opaque_box(st.tcx),\n+      'a' => {\n           debug!{\"saw a class\"};\n           assert (next(st) == '[');\n           debug!{\"saw a [\"};\n@@ -305,16 +305,16 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n           assert (next(st) == ']');\n           return ty::mk_class(st.tcx, did, substs);\n       }\n-      c { error!{\"unexpected char in type string: %c\", c}; fail;}\n+      c => { error!{\"unexpected char in type string: %c\", c}; fail;}\n     }\n }\n \n fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n     let mut m;\n     alt peek(st) {\n-      'm' { next(st); m = ast::m_mutbl; }\n-      '?' { next(st); m = ast::m_const; }\n-      _ { m = ast::m_imm; }\n+      'm' => { next(st); m = ast::m_mutbl; }\n+      '?' => { next(st); m = ast::m_const; }\n+      _ => { m = ast::m_imm; }\n     }\n     return {ty: parse_ty(st, conv), mutbl: m};\n }\n@@ -352,10 +352,10 @@ fn parse_hex(st: @pstate) -> uint {\n \n fn parse_purity(c: char) -> purity {\n     alt check c {\n-      'u' {unsafe_fn}\n-      'p' {pure_fn}\n-      'i' {impure_fn}\n-      'c' {extern_fn}\n+      'u' => unsafe_fn,\n+      'p' => pure_fn,\n+      'i' => impure_fn,\n+      'c' => extern_fn\n     }\n }\n \n@@ -366,11 +366,11 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n     let mut inputs: ~[ty::arg] = ~[];\n     while peek(st) != ']' {\n         let mode = alt check peek(st) {\n-          '&' { ast::by_mutbl_ref }\n-          '-' { ast::by_move }\n-          '+' { ast::by_copy }\n-          '=' { ast::by_ref }\n-          '#' { ast::by_val }\n+          '&' => ast::by_mutbl_ref,\n+          '-' => ast::by_move,\n+          '+' => ast::by_copy,\n+          '=' => ast::by_ref,\n+          '#' => ast::by_val\n         };\n         st.pos += 1u;\n         vec::push(inputs, {mode: ast::expl(mode), ty: parse_ty(st, conv)});\n@@ -395,14 +395,14 @@ fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     let def_part = vec::slice(buf, colon_idx + 1u, len);\n \n     let crate_num = alt uint::parse_buf(crate_part, 10u) {\n-       some(cn) { cn as int }\n-       none { fail (fmt!{\"internal error: parse_def_id: crate number \\\n-         expected, but found %?\", crate_part}); }\n+       some(cn) => cn as int,\n+       none => fail (fmt!{\"internal error: parse_def_id: crate number \\\n+                               expected, but found %?\", crate_part})\n     };\n     let def_num = alt uint::parse_buf(def_part, 10u) {\n-       some(dn) { dn as int }\n-       none { fail (fmt!{\"internal error: parse_def_id: id expected, but \\\n-         found %?\", def_part}); }\n+       some(dn) => dn as int,\n+       none => fail (fmt!{\"internal error: parse_def_id: id expected, but \\\n+                               found %?\", def_part})\n     };\n     return {crate: crate_num, node: def_num};\n }\n@@ -418,12 +418,12 @@ fn parse_bounds(st: @pstate, conv: conv_did) -> @~[ty::param_bound] {\n     let mut bounds = ~[];\n     loop {\n         vec::push(bounds, alt check next(st) {\n-          'S' { ty::bound_send }\n-          'C' { ty::bound_copy }\n-          'K' { ty::bound_const }\n-          'O' { ty::bound_owned }\n-          'I' { ty::bound_trait(parse_ty(st, conv)) }\n-          '.' { break; }\n+          'S' => ty::bound_send,\n+          'C' => ty::bound_copy,\n+          'K' => ty::bound_const,\n+          'O' => ty::bound_owned,\n+          'I' => ty::bound_trait(parse_ty(st, conv)),\n+          '.' => break\n         });\n     }\n     @bounds"}, {"sha": "a9685dabba70c051a57d6033b694b74a1dccf7b2", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 90, "deletions": 90, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -35,17 +35,17 @@ enum abbrev_ctxt { ac_no_abbrevs, ac_use_abbrevs(hashmap<ty::t, ty_abbrev>), }\n \n fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n     alt cx.abbrevs {\n-      ac_no_abbrevs { return false; }\n-      ac_use_abbrevs(_) { return true; }\n+      ac_no_abbrevs => return false,\n+      ac_use_abbrevs(_) => return true\n     }\n }\n \n fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n     alt cx.abbrevs {\n-      ac_no_abbrevs {\n+      ac_no_abbrevs => {\n         let result_str = alt cx.tcx.short_names_cache.find(t) {\n-          some(s) { *s }\n-          none {\n+          some(s) => *s,\n+          none => {\n             let buf = io::mem_buffer();\n             enc_sty(io::mem_buffer_writer(buf), cx, ty::get(t).struct);\n             cx.tcx.short_names_cache.insert(t, @io::mem_buffer_str(buf));\n@@ -54,13 +54,13 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n         };\n         w.write_str(result_str);\n       }\n-      ac_use_abbrevs(abbrevs) {\n+      ac_use_abbrevs(abbrevs) => {\n         alt abbrevs.find(t) {\n-          some(a) { w.write_str(*a.s); return; }\n-          none {\n+          some(a) => { w.write_str(*a.s); return; }\n+          none => {\n             let pos = w.tell();\n             alt ty::type_def_id(t) {\n-              some(def_id) {\n+              some(def_id) => {\n                 // Do not emit node ids that map to unexported names.  Those\n                 // are not helpful.\n                 if def_id.crate != local_crate ||\n@@ -70,7 +70,7 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n                     w.write_char('|');\n                 }\n               }\n-              _ {}\n+              _ => {}\n             }\n             enc_sty(w, cx, ty::get(t).struct);\n             let end = w.tell();\n@@ -97,17 +97,17 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n }\n fn enc_mt(w: io::writer, cx: @ctxt, mt: ty::mt) {\n     alt mt.mutbl {\n-      m_imm { }\n-      m_mutbl { w.write_char('m'); }\n-      m_const { w.write_char('?'); }\n+      m_imm => (),\n+      m_mutbl => w.write_char('m'),\n+      m_const => w.write_char('?')\n     }\n     enc_ty(w, cx, mt.ty);\n }\n \n fn enc_opt<T>(w: io::writer, t: option<T>, enc_f: fn(T)) {\n     alt t {\n-      none { w.write_char('n') }\n-      some(v) {\n+      none => w.write_char('n'),\n+      some(v) => {\n         w.write_char('s');\n         enc_f(v);\n       }\n@@ -124,27 +124,27 @@ fn enc_substs(w: io::writer, cx: @ctxt, substs: ty::substs) {\n \n fn enc_region(w: io::writer, cx: @ctxt, r: ty::region) {\n     alt r {\n-      ty::re_bound(br) {\n+      ty::re_bound(br) => {\n         w.write_char('b');\n         enc_bound_region(w, br);\n       }\n-      ty::re_free(id, br) {\n+      ty::re_free(id, br) => {\n         w.write_char('f');\n         w.write_char('[');\n         w.write_int(id);\n         w.write_char('|');\n         enc_bound_region(w, br);\n         w.write_char(']');\n       }\n-      ty::re_scope(nid) {\n+      ty::re_scope(nid) => {\n         w.write_char('s');\n         w.write_int(nid);\n         w.write_char('|');\n       }\n-      ty::re_static {\n+      ty::re_static => {\n         w.write_char('t');\n       }\n-      ty::re_var(_) {\n+      ty::re_var(_) => {\n         // these should not crop up after typeck\n         cx.diag.handler().bug(~\"Cannot encode region variables\");\n       }\n@@ -153,14 +153,14 @@ fn enc_region(w: io::writer, cx: @ctxt, r: ty::region) {\n \n fn enc_bound_region(w: io::writer, br: ty::bound_region) {\n     alt br {\n-      ty::br_self { w.write_char('s') }\n-      ty::br_anon { w.write_char('a') }\n-      ty::br_named(s) {\n+      ty::br_self => w.write_char('s'),\n+      ty::br_anon => w.write_char('a'),\n+      ty::br_named(s) => {\n         w.write_char('[');\n         w.write_str(*s);\n         w.write_char(']')\n       }\n-      ty::br_cap_avoid(id, br) {\n+      ty::br_cap_avoid(id, br) => {\n         w.write_char('c');\n         w.write_int(id);\n         w.write_char('|');\n@@ -172,17 +172,17 @@ fn enc_bound_region(w: io::writer, br: ty::bound_region) {\n fn enc_vstore(w: io::writer, cx: @ctxt, v: ty::vstore) {\n     w.write_char('/');\n     alt v {\n-      ty::vstore_fixed(u)  {\n+      ty::vstore_fixed(u) => {\n         w.write_uint(u);\n         w.write_char('|');\n       }\n-      ty::vstore_uniq {\n+      ty::vstore_uniq => {\n         w.write_char('~');\n       }\n-      ty::vstore_box {\n+      ty::vstore_box => {\n         w.write_char('@');\n       }\n-      ty::vstore_slice(r) {\n+      ty::vstore_slice(r) => {\n         w.write_char('&');\n         enc_region(w, cx, r);\n       }\n@@ -191,73 +191,73 @@ fn enc_vstore(w: io::writer, cx: @ctxt, v: ty::vstore) {\n \n fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n     alt st {\n-      ty::ty_nil { w.write_char('n'); }\n-      ty::ty_bot { w.write_char('z'); }\n-      ty::ty_bool { w.write_char('b'); }\n-      ty::ty_int(t) {\n+      ty::ty_nil => w.write_char('n'),\n+      ty::ty_bot => w.write_char('z'),\n+      ty::ty_bool => w.write_char('b'),\n+      ty::ty_int(t) => {\n         alt t {\n-          ty_i { w.write_char('i'); }\n-          ty_char { w.write_char('c'); }\n-          ty_i8 { w.write_str(&\"MB\"); }\n-          ty_i16 { w.write_str(&\"MW\"); }\n-          ty_i32 { w.write_str(&\"ML\"); }\n-          ty_i64 { w.write_str(&\"MD\"); }\n+          ty_i => w.write_char('i'),\n+          ty_char => w.write_char('c'),\n+          ty_i8 => w.write_str(&\"MB\"),\n+          ty_i16 => w.write_str(&\"MW\"),\n+          ty_i32 => w.write_str(&\"ML\"),\n+          ty_i64 => w.write_str(&\"MD\")\n         }\n       }\n-      ty::ty_uint(t) {\n+      ty::ty_uint(t) => {\n         alt t {\n-          ty_u { w.write_char('u'); }\n-          ty_u8 { w.write_str(&\"Mb\"); }\n-          ty_u16 { w.write_str(&\"Mw\"); }\n-          ty_u32 { w.write_str(&\"Ml\"); }\n-          ty_u64 { w.write_str(&\"Md\"); }\n+          ty_u => w.write_char('u'),\n+          ty_u8 => w.write_str(&\"Mb\"),\n+          ty_u16 => w.write_str(&\"Mw\"),\n+          ty_u32 => w.write_str(&\"Ml\"),\n+          ty_u64 => w.write_str(&\"Md\")\n         }\n       }\n-      ty::ty_float(t) {\n+      ty::ty_float(t) => {\n         alt t {\n-          ty_f { w.write_char('l'); }\n-          ty_f32 { w.write_str(&\"Mf\"); }\n-          ty_f64 { w.write_str(&\"MF\"); }\n+          ty_f => w.write_char('l'),\n+          ty_f32 => w.write_str(&\"Mf\"),\n+          ty_f64 => w.write_str(&\"MF\"),\n         }\n       }\n-      ty::ty_enum(def, substs) {\n+      ty::ty_enum(def, substs) => {\n         w.write_str(&\"t[\");\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n         enc_substs(w, cx, substs);\n         w.write_char(']');\n       }\n-      ty::ty_trait(def, substs) {\n+      ty::ty_trait(def, substs) => {\n         w.write_str(&\"x[\");\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n         enc_substs(w, cx, substs);\n         w.write_char(']');\n       }\n-      ty::ty_tup(ts) {\n+      ty::ty_tup(ts) => {\n         w.write_str(&\"T[\");\n         for ts.each |t| { enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n-      ty::ty_box(mt) { w.write_char('@'); enc_mt(w, cx, mt); }\n-      ty::ty_uniq(mt) { w.write_char('~'); enc_mt(w, cx, mt); }\n-      ty::ty_ptr(mt) { w.write_char('*'); enc_mt(w, cx, mt); }\n-      ty::ty_rptr(r, mt) {\n+      ty::ty_box(mt) => { w.write_char('@'); enc_mt(w, cx, mt); }\n+      ty::ty_uniq(mt) => { w.write_char('~'); enc_mt(w, cx, mt); }\n+      ty::ty_ptr(mt) => { w.write_char('*'); enc_mt(w, cx, mt); }\n+      ty::ty_rptr(r, mt) => {\n         w.write_char('&');\n         enc_region(w, cx, r);\n         enc_mt(w, cx, mt);\n       }\n-      ty::ty_evec(mt, v) {\n+      ty::ty_evec(mt, v) => {\n         w.write_char('V');\n         enc_mt(w, cx, mt);\n         enc_vstore(w, cx, v);\n       }\n-      ty::ty_estr(v) {\n+      ty::ty_estr(v) => {\n         w.write_char('v');\n         enc_vstore(w, cx, v);\n       }\n-      ty::ty_unboxed_vec(mt) { w.write_char('U'); enc_mt(w, cx, mt); }\n-      ty::ty_rec(fields) {\n+      ty::ty_unboxed_vec(mt) => { w.write_char('U'); enc_mt(w, cx, mt); }\n+      ty::ty_rec(fields) => {\n         w.write_str(&\"R[\");\n         for fields.each |field| {\n             w.write_str(*field.ident);\n@@ -266,33 +266,33 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         }\n         w.write_char(']');\n       }\n-      ty::ty_fn(f) {\n+      ty::ty_fn(f) => {\n         enc_ty_fn(w, cx, f);\n       }\n-      ty::ty_var(id) {\n+      ty::ty_var(id) => {\n         w.write_char('X');\n         w.write_uint(id.to_uint());\n       }\n-      ty::ty_var_integral(id) {\n+      ty::ty_var_integral(id) => {\n         w.write_char('X');\n         w.write_char('I');\n         w.write_uint(id.to_uint());\n       }\n-      ty::ty_param({idx: id, def_id: did}) {\n+      ty::ty_param({idx: id, def_id: did}) => {\n         w.write_char('p');\n         w.write_str(cx.ds(did));\n         w.write_char('|');\n         w.write_str(uint::str(id));\n       }\n-      ty::ty_self {\n+      ty::ty_self => {\n         w.write_char('s');\n       }\n-      ty::ty_type { w.write_char('Y'); }\n-      ty::ty_opaque_closure_ptr(ty::ck_block) { w.write_str(&\"C&\"); }\n-      ty::ty_opaque_closure_ptr(ty::ck_box) { w.write_str(&\"C@\"); }\n-      ty::ty_opaque_closure_ptr(ty::ck_uniq) { w.write_str(&\"C~\"); }\n-      ty::ty_opaque_box { w.write_char('B'); }\n-      ty::ty_class(def, substs) {\n+      ty::ty_type => w.write_char('Y'),\n+      ty::ty_opaque_closure_ptr(ty::ck_block) => w.write_str(&\"C&\"),\n+      ty::ty_opaque_closure_ptr(ty::ck_box) => w.write_str(&\"C@\"),\n+      ty::ty_opaque_closure_ptr(ty::ck_uniq) => w.write_str(&\"C~\"),\n+      ty::ty_opaque_box => w.write_char('B'),\n+      ty::ty_class(def, substs) => {\n           debug!{\"~~~~ %s\", ~\"a[\"};\n           w.write_str(&\"a[\");\n           let s = cx.ds(def);\n@@ -308,29 +308,29 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n }\n fn enc_proto(w: io::writer, proto: proto) {\n     alt proto {\n-      proto_uniq { w.write_str(&\"f~\"); }\n-      proto_box { w.write_str(&\"f@\"); }\n-      proto_block { w.write_str(~\"f&\"); }\n-      proto_bare { w.write_str(&\"fn\"); }\n+      proto_uniq => w.write_str(&\"f~\"),\n+      proto_box => w.write_str(&\"f@\"),\n+      proto_block => w.write_str(~\"f&\"),\n+      proto_bare => w.write_str(&\"fn\")\n     }\n }\n \n fn enc_mode(w: io::writer, cx: @ctxt, m: mode) {\n     alt ty::resolved_mode(cx.tcx, m) {\n-      by_mutbl_ref { w.write_char('&'); }\n-      by_move { w.write_char('-'); }\n-      by_copy { w.write_char('+'); }\n-      by_ref { w.write_char('='); }\n-      by_val { w.write_char('#'); }\n+      by_mutbl_ref => w.write_char('&'),\n+      by_move => w.write_char('-'),\n+      by_copy => w.write_char('+'),\n+      by_ref => w.write_char('='),\n+      by_val => w.write_char('#')\n     }\n }\n \n fn enc_purity(w: io::writer, p: purity) {\n     alt p {\n-      pure_fn { w.write_char('p'); }\n-      impure_fn { w.write_char('i'); }\n-      unsafe_fn { w.write_char('u'); }\n-      extern_fn { w.write_char('c'); }\n+      pure_fn => w.write_char('p'),\n+      impure_fn => w.write_char('i'),\n+      unsafe_fn => w.write_char('u'),\n+      extern_fn => w.write_char('c')\n     }\n }\n \n@@ -344,19 +344,19 @@ fn enc_ty_fn(w: io::writer, cx: @ctxt, ft: ty::fn_ty) {\n     }\n     w.write_char(']');\n     alt ft.ret_style {\n-      noreturn { w.write_char('!'); }\n-      _ { enc_ty(w, cx, ft.output); }\n+      noreturn => w.write_char('!'),\n+      _ => enc_ty(w, cx, ft.output)\n     }\n }\n \n fn enc_bounds(w: io::writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n     for vec::each(*bs) |bound| {\n         alt bound {\n-          ty::bound_send { w.write_char('S'); }\n-          ty::bound_copy { w.write_char('C'); }\n-          ty::bound_const { w.write_char('K'); }\n-          ty::bound_owned { w.write_char('O'); }\n-          ty::bound_trait(tp) {\n+          ty::bound_send => w.write_char('S'),\n+          ty::bound_copy => w.write_char('C'),\n+          ty::bound_const => w.write_char('K'),\n+          ty::bound_owned => w.write_char('O'),\n+          ty::bound_trait(tp) => {\n             w.write_char('I');\n             enc_ty(w, cx, tp);\n           }"}, {"sha": "054c51bfe362f13878a58f733dcfeca777e22e31", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -112,8 +112,8 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n                        par_doc: ebml::doc) -> option<ast::inlined_item> {\n     let dcx = @{cdata: cdata, tcx: tcx, maps: maps};\n     alt par_doc.opt_child(c::tag_ast) {\n-      none { none }\n-      some(ast_doc) {\n+      none => none,\n+      some(ast_doc) => {\n         debug!{\"> Decoding inlined fn: %s::?\", ast_map::path_to_str(path)};\n         let ast_dsr = ebml::ebml_deserializer(ast_doc);\n         let from_id_range = ast_util::deserialize_id_range(ast_dsr);\n@@ -130,11 +130,11 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n         debug!{\"< Decoded inlined fn: %s::%s\",\n                ast_map::path_to_str(path), *ii.ident()};\n         alt ii {\n-          ast::ii_item(i) {\n+          ast::ii_item(i) => {\n             debug!{\">>> DECODED ITEM >>>\\n%s\\n<<< DECODED ITEM <<<\",\n                    syntax::print::pprust::item_to_str(i)};\n           }\n-          _ { }\n+          _ => { }\n         }\n         some(ii)\n       }\n@@ -247,8 +247,8 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n         let stmts_sans_items = do vec::filter(blk.stmts) |stmt| {\n             alt stmt.node {\n               ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |\n-              ast::stmt_decl(@{node: ast::decl_local(_), span: _}, _) { true }\n-              ast::stmt_decl(@{node: ast::decl_item(_), span: _}, _) { false }\n+              ast::stmt_decl(@{node: ast::decl_local(_), span: _}, _) => true,\n+              ast::stmt_decl(@{node: ast::decl_item(_), span: _}, _) => false\n             }\n         };\n         let blk_sans_items = { stmts: stmts_sans_items with blk };\n@@ -261,23 +261,23 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n     });\n \n     alt ii {\n-      ast::ii_item(i) {\n+      ast::ii_item(i) => {\n         ast::ii_item(fld.fold_item(i).get()) //hack: we're not dropping items\n       }\n-      ast::ii_method(d, m) {\n+      ast::ii_method(d, m) => {\n         ast::ii_method(d, fld.fold_method(m))\n       }\n-      ast::ii_foreign(i) {\n+      ast::ii_foreign(i) => {\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n-      ast::ii_ctor(ctor, nm, tps, parent_id) {\n+      ast::ii_ctor(ctor, nm, tps, parent_id) => {\n         let ctor_body = fld.fold_block(ctor.node.body);\n         let ctor_decl = fold::fold_fn_decl(ctor.node.dec, fld);\n         ast::ii_ctor({node: {body: ctor_body, dec: ctor_decl\n                               with ctor.node}\n             with ctor}, nm, tps, parent_id)\n       }\n-      ast::ii_dtor(dtor, nm, tps, parent_id) {\n+      ast::ii_dtor(dtor, nm, tps, parent_id) => {\n         let dtor_body = fld.fold_block(dtor.node.body);\n         ast::ii_dtor({node: {body: dtor_body\n                               with dtor.node}\n@@ -301,16 +301,16 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n     });\n \n     alt ii {\n-      ast::ii_item(i) {\n+      ast::ii_item(i) => {\n         ast::ii_item(fld.fold_item(i).get())\n       }\n-      ast::ii_method(d, m) {\n+      ast::ii_method(d, m) => {\n         ast::ii_method(xcx.tr_def_id(d), fld.fold_method(m))\n       }\n-      ast::ii_foreign(i) {\n+      ast::ii_foreign(i) => {\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n-      ast::ii_ctor(ctor, nm, tps, parent_id) {\n+      ast::ii_ctor(ctor, nm, tps, parent_id) => {\n         let ctor_body = fld.fold_block(ctor.node.body);\n         let ctor_attrs = fld.fold_attributes(ctor.node.attrs);\n         let ctor_decl = fold::fold_fn_decl(ctor.node.dec, fld);\n@@ -322,7 +322,7 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n                               with ctor.node}\n             with ctor}, nm, new_params, new_parent)\n       }\n-      ast::ii_dtor(dtor, nm, tps, parent_id) {\n+      ast::ii_dtor(dtor, nm, tps, parent_id) => {\n         let dtor_body = fld.fold_block(dtor.node.body);\n         let dtor_attrs = fld.fold_attributes(dtor.node.attrs);\n         let new_params = fold::fold_ty_params(tps, fld);\n@@ -353,29 +353,29 @@ fn decode_def(xcx: extended_decode_ctxt, doc: ebml::doc) -> ast::def {\n impl of tr for ast::def {\n     fn tr(xcx: extended_decode_ctxt) -> ast::def {\n         alt self {\n-          ast::def_fn(did, p) { ast::def_fn(did.tr(xcx), p) }\n-          ast::def_self(nid) { ast::def_self(xcx.tr_id(nid)) }\n-          ast::def_mod(did) { ast::def_mod(did.tr(xcx)) }\n-          ast::def_foreign_mod(did) { ast::def_foreign_mod(did.tr(xcx)) }\n-          ast::def_const(did) { ast::def_const(did.tr(xcx)) }\n-          ast::def_arg(nid, m) { ast::def_arg(xcx.tr_id(nid), m) }\n-          ast::def_local(nid, b) { ast::def_local(xcx.tr_id(nid), b) }\n-          ast::def_variant(e_did, v_did) {\n+          ast::def_fn(did, p) => ast::def_fn(did.tr(xcx), p),\n+          ast::def_self(nid) => ast::def_self(xcx.tr_id(nid)),\n+          ast::def_mod(did) => ast::def_mod(did.tr(xcx)),\n+          ast::def_foreign_mod(did) => ast::def_foreign_mod(did.tr(xcx)),\n+          ast::def_const(did) => ast::def_const(did.tr(xcx)),\n+          ast::def_arg(nid, m) => ast::def_arg(xcx.tr_id(nid), m),\n+          ast::def_local(nid, b) => ast::def_local(xcx.tr_id(nid), b),\n+          ast::def_variant(e_did, v_did) => {\n             ast::def_variant(e_did.tr(xcx), v_did.tr(xcx))\n           }\n-          ast::def_ty(did) { ast::def_ty(did.tr(xcx)) }\n-          ast::def_prim_ty(p) { ast::def_prim_ty(p) }\n-          ast::def_ty_param(did, v) { ast::def_ty_param(did.tr(xcx), v) }\n-          ast::def_binding(nid, bm) { ast::def_binding(xcx.tr_id(nid), bm) }\n-          ast::def_use(did) { ast::def_use(did.tr(xcx)) }\n-          ast::def_upvar(nid1, def, nid2) {\n+          ast::def_ty(did) => ast::def_ty(did.tr(xcx)),\n+          ast::def_prim_ty(p) => ast::def_prim_ty(p),\n+          ast::def_ty_param(did, v) => ast::def_ty_param(did.tr(xcx), v),\n+          ast::def_binding(nid, bm) => ast::def_binding(xcx.tr_id(nid), bm),\n+          ast::def_use(did) => ast::def_use(did.tr(xcx)),\n+          ast::def_upvar(nid1, def, nid2) => {\n             ast::def_upvar(xcx.tr_id(nid1), @(*def).tr(xcx), xcx.tr_id(nid2))\n           }\n-          ast::def_class(did, has_constructor) {\n+          ast::def_class(did, has_constructor) => {\n             ast::def_class(did.tr(xcx), has_constructor)\n           }\n-          ast::def_region(nid) { ast::def_region(xcx.tr_id(nid)) }\n-          ast::def_typaram_binder(nid) {\n+          ast::def_region(nid) => ast::def_region(xcx.tr_id(nid)),\n+          ast::def_typaram_binder(nid) => {\n             ast::def_typaram_binder(xcx.tr_id(nid))\n           }\n         }\n@@ -423,13 +423,13 @@ impl helper of read_method_map_entry_helper for ebml::ebml_deserializer {\n impl of tr for method_origin {\n     fn tr(xcx: extended_decode_ctxt) -> method_origin {\n         alt self {\n-          typeck::method_static(did) {\n+          typeck::method_static(did) => {\n             typeck::method_static(did.tr(xcx))\n           }\n-          typeck::method_param(mp) {\n+          typeck::method_param(mp) => {\n             typeck::method_param({trait_id:mp.trait_id.tr(xcx) with mp})\n           }\n-          typeck::method_trait(did, m) {\n+          typeck::method_trait(did, m) => {\n             typeck::method_trait(did.tr(xcx), m)\n           }\n         }\n@@ -456,7 +456,7 @@ fn encode_vtable_origin(ecx: @e::encode_ctxt,\n                       vtable_origin: typeck::vtable_origin) {\n     do ebml_w.emit_enum(~\"vtable_origin\") {\n         alt vtable_origin {\n-          typeck::vtable_static(def_id, tys, vtable_res) {\n+          typeck::vtable_static(def_id, tys, vtable_res) => {\n             do ebml_w.emit_enum_variant(~\"vtable_static\", 0u, 3u) {\n                 do ebml_w.emit_enum_variant_arg(0u) {\n                     ebml_w.emit_def_id(def_id)\n@@ -469,7 +469,7 @@ fn encode_vtable_origin(ecx: @e::encode_ctxt,\n                 }\n             }\n           }\n-          typeck::vtable_param(pn, bn) {\n+          typeck::vtable_param(pn, bn) => {\n             do ebml_w.emit_enum_variant(~\"vtable_param\", 1u, 2u) {\n                 do ebml_w.emit_enum_variant_arg(0u) {\n                     ebml_w.emit_uint(pn);\n@@ -479,7 +479,7 @@ fn encode_vtable_origin(ecx: @e::encode_ctxt,\n                 }\n             }\n           }\n-          typeck::vtable_trait(def_id, tys) {\n+          typeck::vtable_trait(def_id, tys) => {\n             do ebml_w.emit_enum_variant(~\"vtable_trait\", 1u, 3u) {\n                 do ebml_w.emit_enum_variant_arg(0u) {\n                     ebml_w.emit_def_id(def_id)\n@@ -509,7 +509,7 @@ impl helpers of vtable_deserialization_helpers for ebml::ebml_deserializer {\n         do self.read_enum(~\"vtable_origin\") {\n             do self.read_enum_variant |i| {\n                 alt check i {\n-                  0u {\n+                  0u => {\n                     typeck::vtable_static(\n                         do self.read_enum_variant_arg(0u) {\n                             self.read_def_id(xcx)\n@@ -522,7 +522,7 @@ impl helpers of vtable_deserialization_helpers for ebml::ebml_deserializer {\n                         }\n                     )\n                   }\n-                  1u {\n+                  1u => {\n                     typeck::vtable_param(\n                         do self.read_enum_variant_arg(0u) {\n                             self.read_uint()\n@@ -532,7 +532,7 @@ impl helpers of vtable_deserialization_helpers for ebml::ebml_deserializer {\n                         }\n                     )\n                   }\n-                  2u {\n+                  2u => {\n                     typeck::vtable_trait(\n                         do self.read_enum_variant_arg(0u) {\n                             self.read_def_id(xcx)\n@@ -993,9 +993,9 @@ fn test_simplification() {\n         }\n     });\n     alt (item_out, item_exp) {\n-      (ast::ii_item(item_out), ast::ii_item(item_exp)) {\n+      (ast::ii_item(item_out), ast::ii_item(item_exp)) => {\n         assert pprust::item_to_str(item_out) == pprust::item_to_str(item_exp);\n       }\n-      _ { fail; }\n+      _ => fail\n     }\n }"}, {"sha": "3f7ddd94eed17635ec5d0f9c6c046db0c386c86f", "filename": "src/rustc/middle/block_use.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fblock_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fblock_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fblock_use.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -14,17 +14,17 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) {\n fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n     if !cx.allow_block {\n         alt ty::get(ty::expr_ty(cx.tcx, ex)).struct {\n-          ty::ty_fn({proto: p, _}) if is_blockish(p) {\n+          ty::ty_fn({proto: p, _}) if is_blockish(p) => {\n             cx.tcx.sess.span_err(ex.span,\n                ~\"expressions with stack closure type \\\n                 can only appear in callee or (by-ref) argument position\");\n           }\n-          _ {}\n+          _ => {}\n         }\n     }\n     let outer = cx.allow_block;\n     alt ex.node {\n-      expr_call(f, args, _) {\n+      expr_call(f, args, _) => {\n         cx.allow_block = true;\n         v.visit_expr(f, cx, v);\n         let mut i = 0u;\n@@ -34,11 +34,11 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n             i += 1u;\n         }\n       }\n-      expr_loop_body(body) | expr_do_body(body) {\n+      expr_loop_body(body) | expr_do_body(body) => {\n         cx.allow_block = true;\n         v.visit_expr(body, cx, v);\n       }\n-      _ {\n+      _ => {\n         cx.allow_block = false;\n         visit::visit_expr(ex, cx, v);\n       }"}, {"sha": "4e9f770232f12baa0c7db993cfd0e423427cb8fc", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 59, "deletions": 65, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -457,8 +457,8 @@ impl methods of get_type_for_node for ty::ctxt {\n impl error_methods for borrowck_ctxt {\n     fn report_if_err(bres: bckres<()>) {\n         alt bres {\n-          ok(()) { }\n-          err(e) { self.report(e); }\n+          ok(()) => (),\n+          err(e) => self.report(e)\n         }\n     }\n \n@@ -479,79 +479,79 @@ impl error_methods for borrowck_ctxt {\n \n     fn add_to_mutbl_map(cmt: cmt) {\n         alt cmt.cat {\n-          cat_local(id) | cat_arg(id) {\n+          cat_local(id) | cat_arg(id) => {\n             self.mutbl_map.insert(id, ());\n           }\n-          cat_stack_upvar(cmt) {\n+          cat_stack_upvar(cmt) => {\n             self.add_to_mutbl_map(cmt);\n           }\n-          _ {}\n+          _ => ()\n         }\n     }\n }\n \n impl to_str_methods for borrowck_ctxt {\n     fn cat_to_repr(cat: categorization) -> ~str {\n         alt cat {\n-          cat_special(sk_method) { ~\"method\" }\n-          cat_special(sk_static_item) { ~\"static_item\" }\n-          cat_special(sk_self) { ~\"self\" }\n-          cat_special(sk_heap_upvar) { ~\"heap-upvar\" }\n-          cat_stack_upvar(_) { ~\"stack-upvar\" }\n-          cat_rvalue { ~\"rvalue\" }\n-          cat_local(node_id) { fmt!{\"local(%d)\", node_id} }\n-          cat_binding(node_id) { fmt!{\"binding(%d)\", node_id} }\n-          cat_arg(node_id) { fmt!{\"arg(%d)\", node_id} }\n-          cat_deref(cmt, derefs, ptr) {\n+          cat_special(sk_method) => ~\"method\",\n+          cat_special(sk_static_item) => ~\"static_item\",\n+          cat_special(sk_self) => ~\"self\",\n+          cat_special(sk_heap_upvar) => ~\"heap-upvar\",\n+          cat_stack_upvar(_) => ~\"stack-upvar\",\n+          cat_rvalue => ~\"rvalue\",\n+          cat_local(node_id) => fmt!{\"local(%d)\", node_id},\n+          cat_binding(node_id) => fmt!{\"binding(%d)\", node_id},\n+          cat_arg(node_id) => fmt!{\"arg(%d)\", node_id},\n+          cat_deref(cmt, derefs, ptr) => {\n             fmt!{\"%s->(%s, %u)\", self.cat_to_repr(cmt.cat),\n                  self.ptr_sigil(ptr), derefs}\n           }\n-          cat_comp(cmt, comp) {\n+          cat_comp(cmt, comp) => {\n             fmt!{\"%s.%s\", self.cat_to_repr(cmt.cat), self.comp_to_repr(comp)}\n           }\n-          cat_discr(cmt, _) { self.cat_to_repr(cmt.cat) }\n+          cat_discr(cmt, _) => self.cat_to_repr(cmt.cat)\n         }\n     }\n \n     fn mut_to_str(mutbl: ast::mutability) -> ~str {\n         alt mutbl {\n-          m_mutbl { ~\"mutable\" }\n-          m_const { ~\"const\" }\n-          m_imm { ~\"immutable\" }\n+          m_mutbl => ~\"mutable\",\n+          m_const => ~\"const\",\n+          m_imm => ~\"immutable\"\n         }\n     }\n \n     fn ptr_sigil(ptr: ptr_kind) -> ~str {\n         alt ptr {\n-          uniq_ptr { ~\"~\" }\n-          gc_ptr { ~\"@\" }\n-          region_ptr(_) { ~\"&\" }\n-          unsafe_ptr { ~\"*\" }\n+          uniq_ptr => ~\"~\",\n+          gc_ptr => ~\"@\",\n+          region_ptr(_) => ~\"&\",\n+          unsafe_ptr => ~\"*\"\n         }\n     }\n \n     fn comp_to_repr(comp: comp_kind) -> ~str {\n         alt comp {\n-          comp_field(fld, _) { *fld }\n-          comp_index(*) { ~\"[]\" }\n-          comp_tuple { ~\"()\" }\n-          comp_variant(_) { ~\"<enum>\" }\n+          comp_field(fld, _) => *fld,\n+          comp_index(*) => ~\"[]\",\n+          comp_tuple => ~\"()\",\n+          comp_variant(_) => ~\"<enum>\"\n         }\n     }\n \n     fn lp_to_str(lp: @loan_path) -> ~str {\n         alt *lp {\n-          lp_local(node_id) {\n+          lp_local(node_id) => {\n             fmt!{\"local(%d)\", node_id}\n           }\n-          lp_arg(node_id) {\n+          lp_arg(node_id) => {\n             fmt!{\"arg(%d)\", node_id}\n           }\n-          lp_deref(lp, ptr) {\n+          lp_deref(lp, ptr) => {\n             fmt!{\"%s->(%s)\", self.lp_to_str(lp),\n                  self.ptr_sigil(ptr)}\n           }\n-          lp_comp(lp, comp) {\n+          lp_comp(lp, comp) => {\n             fmt!{\"%s.%s\", self.lp_to_str(lp),\n                  self.comp_to_repr(comp)}\n           }\n@@ -570,68 +570,62 @@ impl to_str_methods for borrowck_ctxt {\n     fn cmt_to_str(cmt: cmt) -> ~str {\n         let mut_str = self.mut_to_str(cmt.mutbl);\n         alt cmt.cat {\n-          cat_special(sk_method) { ~\"method\" }\n-          cat_special(sk_static_item) { ~\"static item\" }\n-          cat_special(sk_self) { ~\"self reference\" }\n-          cat_special(sk_heap_upvar) {\n+          cat_special(sk_method) => ~\"method\",\n+          cat_special(sk_static_item) => ~\"static item\",\n+          cat_special(sk_self) => ~\"self reference\",\n+          cat_special(sk_heap_upvar) => {\n               ~\"captured outer variable in a heap closure\"\n           }\n-          cat_rvalue { ~\"non-lvalue\" }\n-          cat_local(_) { mut_str + ~\" local variable\" }\n-          cat_binding(_) { ~\"pattern binding\" }\n-          cat_arg(_) { ~\"argument\" }\n-          cat_deref(_, _, pk) { fmt!{\"dereference of %s %s pointer\",\n-                                     mut_str, self.ptr_sigil(pk)} }\n-          cat_stack_upvar(_) {\n+          cat_rvalue => ~\"non-lvalue\",\n+          cat_local(_) => mut_str + ~\" local variable\",\n+          cat_binding(_) => ~\"pattern binding\",\n+          cat_arg(_) => ~\"argument\",\n+          cat_deref(_, _, pk) => fmt!{\"dereference of %s %s pointer\",\n+                                      mut_str, self.ptr_sigil(pk)},\n+          cat_stack_upvar(_) => {\n             ~\"captured outer \" + mut_str + ~\" variable in a stack closure\"\n           }\n-          cat_comp(_, comp_field(*)) { mut_str + ~\" field\" }\n-          cat_comp(_, comp_tuple) { ~\"tuple content\" }\n-          cat_comp(_, comp_variant(_)) { ~\"enum content\" }\n-          cat_comp(_, comp_index(t, _)) {\n+          cat_comp(_, comp_field(*)) => mut_str + ~\" field\",\n+          cat_comp(_, comp_tuple) => ~\"tuple content\",\n+          cat_comp(_, comp_variant(_)) => ~\"enum content\",\n+          cat_comp(_, comp_index(t, _)) => {\n             alt ty::get(t).struct {\n-              ty::ty_evec(*) {\n-                mut_str + ~\" vec content\"\n-              }\n-\n-              ty::ty_estr(*) {\n-                mut_str + ~\" str content\"\n-              }\n-\n-              _ { mut_str + ~\" indexed content\" }\n+              ty::ty_evec(*) => mut_str + ~\" vec content\",\n+              ty::ty_estr(*) => mut_str + ~\" str content\",\n+              _ => mut_str + ~\" indexed content\"\n             }\n           }\n-          cat_discr(cmt, _) {\n+          cat_discr(cmt, _) => {\n             self.cmt_to_str(cmt)\n           }\n         }\n     }\n \n     fn bckerr_code_to_str(code: bckerr_code) -> ~str {\n         alt code {\n-          err_mutbl(req, act) {\n+          err_mutbl(req, act) => {\n             fmt!{\"creating %s alias to aliasable, %s memory\",\n                  self.mut_to_str(req), self.mut_to_str(act)}\n           }\n-          err_mut_uniq {\n+          err_mut_uniq => {\n             ~\"unique value in aliasable, mutable location\"\n           }\n-          err_mut_variant {\n+          err_mut_variant => {\n             ~\"enum variant in aliasable, mutable location\"\n           }\n-          err_root_not_permitted {\n+          err_root_not_permitted => {\n             // note: I don't expect users to ever see this error\n             // message, reasons are discussed in attempt_root() in\n             // preserve.rs.\n             ~\"rooting is not permitted\"\n           }\n-          err_out_of_root_scope(super_scope, sub_scope) {\n+          err_out_of_root_scope(super_scope, sub_scope) => {\n             fmt!{\"managed value would have to be rooted for lifetime %s, \\\n                   but can only be rooted for lifetime %s\",\n                  self.region_to_str(sub_scope),\n                  self.region_to_str(super_scope)}\n           }\n-          err_out_of_scope(super_scope, sub_scope) {\n+          err_out_of_scope(super_scope, sub_scope) => {\n             fmt!{\"borrowed pointer has lifetime %s, \\\n                   but the borrowed value only has lifetime %s\",\n                  self.region_to_str(sub_scope),\n@@ -651,7 +645,7 @@ impl to_str_methods for borrowck_ctxt {\n // mutable structure.\n fn inherent_mutability(ck: comp_kind) -> mutability {\n     alt ck {\n-      comp_tuple | comp_variant(_)        {m_imm}\n-      comp_field(_, m) | comp_index(_, m) {m}\n+      comp_tuple | comp_variant(_)        => m_imm,\n+      comp_field(_, m) | comp_index(_, m) => m\n     }\n }"}, {"sha": "f3d39aa91efb40ede12528055cde7d86e2f19774", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 48, "deletions": 50, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -46,48 +46,46 @@ fn opt_deref_kind(t: ty::t) -> option<deref_kind> {\n     alt ty::get(t).struct {\n       ty::ty_uniq(*) |\n       ty::ty_evec(_, ty::vstore_uniq) |\n-      ty::ty_estr(ty::vstore_uniq) {\n+      ty::ty_estr(ty::vstore_uniq) => {\n         some(deref_ptr(uniq_ptr))\n       }\n \n       ty::ty_rptr(r, _) |\n       ty::ty_evec(_, ty::vstore_slice(r)) |\n-      ty::ty_estr(ty::vstore_slice(r)) {\n+      ty::ty_estr(ty::vstore_slice(r)) => {\n         some(deref_ptr(region_ptr(r)))\n       }\n \n       ty::ty_box(*) |\n       ty::ty_evec(_, ty::vstore_box) |\n-      ty::ty_estr(ty::vstore_box) {\n+      ty::ty_estr(ty::vstore_box) => {\n         some(deref_ptr(gc_ptr))\n       }\n \n-      ty::ty_ptr(*) {\n+      ty::ty_ptr(*) => {\n         some(deref_ptr(unsafe_ptr))\n       }\n \n-      ty::ty_enum(did, _) {\n+      ty::ty_enum(did, _) => {\n         some(deref_comp(comp_variant(did)))\n       }\n \n-      ty::ty_evec(mt, ty::vstore_fixed(_)) {\n+      ty::ty_evec(mt, ty::vstore_fixed(_)) => {\n         some(deref_comp(comp_index(t, mt.mutbl)))\n       }\n \n-      ty::ty_estr(ty::vstore_fixed(_)) {\n+      ty::ty_estr(ty::vstore_fixed(_)) => {\n         some(deref_comp(comp_index(t, m_imm)))\n       }\n \n-      _ {\n-        none\n-      }\n+      _ => none\n     }\n }\n \n fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n     alt opt_deref_kind(t) {\n-      some(k) {k}\n-      none {\n+      some(k) => k,\n+      none => {\n         tcx.sess.bug(\n             fmt!{\"deref_cat() invoked on non-derefable type %s\",\n                  ty_to_str(tcx, t)});\n@@ -100,11 +98,11 @@ impl public_methods for borrowck_ctxt {\n         // a borrowed expression must be either an @, ~, or a @vec, ~vec\n         let expr_ty = ty::expr_ty(self.tcx, expr);\n         alt ty::get(expr_ty).struct {\n-          ty::ty_evec(*) | ty::ty_estr(*) {\n+          ty::ty_evec(*) | ty::ty_estr(*) => {\n             self.cat_index(expr, expr)\n           }\n \n-          ty::ty_uniq(*) | ty::ty_box(*) | ty::ty_rptr(*) {\n+          ty::ty_uniq(*) | ty::ty_box(*) | ty::ty_rptr(*) => {\n             let cmt = self.cat_expr(expr);\n             self.cat_deref(expr, cmt, 0u, true).get()\n           }\n@@ -115,7 +113,7 @@ impl public_methods for borrowck_ctxt {\n           }\n           */\n \n-          _ {\n+          _ => {\n             self.tcx.sess.span_bug(\n                 expr.span,\n                 fmt!{\"Borrowing of non-derefable type `%s`\",\n@@ -131,15 +129,15 @@ impl public_methods for borrowck_ctxt {\n         let tcx = self.tcx;\n         let expr_ty = tcx.ty(expr);\n         alt expr.node {\n-          ast::expr_unary(ast::deref, e_base) {\n+          ast::expr_unary(ast::deref, e_base) => {\n             if self.method_map.contains_key(expr.id) {\n                 return self.cat_rvalue(expr, expr_ty);\n             }\n \n             let base_cmt = self.cat_expr(e_base);\n             alt self.cat_deref(expr, base_cmt, 0u, true) {\n-              some(cmt) { return cmt; }\n-              none {\n+              some(cmt) => return cmt,\n+              none => {\n                 tcx.sess.span_bug(\n                     e_base.span,\n                     fmt!{\"Explicit deref of non-derefable type `%s`\",\n@@ -148,7 +146,7 @@ impl public_methods for borrowck_ctxt {\n             }\n           }\n \n-          ast::expr_field(base, f_name, _) {\n+          ast::expr_field(base, f_name, _) => {\n             if self.method_map.contains_key(expr.id) {\n                 return self.cat_method_ref(expr, expr_ty);\n             }\n@@ -157,15 +155,15 @@ impl public_methods for borrowck_ctxt {\n             self.cat_field(expr, base_cmt, f_name)\n           }\n \n-          ast::expr_index(base, _) {\n+          ast::expr_index(base, _) => {\n             if self.method_map.contains_key(expr.id) {\n                 return self.cat_rvalue(expr, expr_ty);\n             }\n \n             self.cat_index(expr, base)\n           }\n \n-          ast::expr_path(_) {\n+          ast::expr_path(_) => {\n             let def = self.tcx.def_map.get(expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n@@ -182,7 +180,7 @@ impl public_methods for borrowck_ctxt {\n           ast::expr_block(*) | ast::expr_loop(*) | ast::expr_alt(*) |\n           ast::expr_lit(*) | ast::expr_break | ast::expr_mac(*) |\n           ast::expr_again | ast::expr_rec(*) | ast::expr_struct(*) |\n-          ast::expr_unary_move(*) | ast::expr_repeat(*) {\n+          ast::expr_unary_move(*) | ast::expr_repeat(*) => {\n             return self.cat_rvalue(expr, expr_ty);\n           }\n         }\n@@ -198,29 +196,29 @@ impl public_methods for borrowck_ctxt {\n           ast::def_use(_) | ast::def_variant(*) |\n           ast::def_ty(_) | ast::def_prim_ty(_) |\n           ast::def_ty_param(*) | ast::def_class(*) |\n-          ast::def_typaram_binder(*) | ast::def_region(_) {\n+          ast::def_typaram_binder(*) | ast::def_region(_) => {\n             @{id:id, span:span,\n               cat:cat_special(sk_static_item), lp:none,\n               mutbl:m_imm, ty:expr_ty}\n           }\n \n-          ast::def_arg(vid, mode) {\n+          ast::def_arg(vid, mode) => {\n             // Idea: make this could be rewritten to model by-ref\n             // stuff as `&const` and `&mut`?\n \n             // m: mutability of the argument\n             // lp: loan path, must be none for aliasable things\n             let {m,lp} = alt ty::resolved_mode(self.tcx, mode) {\n-              ast::by_mutbl_ref {\n+              ast::by_mutbl_ref => {\n                 {m: m_mutbl, lp: none}\n               }\n-              ast::by_move | ast::by_copy {\n+              ast::by_move | ast::by_copy => {\n                 {m: m_imm, lp: some(@lp_arg(vid))}\n               }\n-              ast::by_ref {\n+              ast::by_ref => {\n                 {m: m_imm, lp: none}\n               }\n-              ast::by_val {\n+              ast::by_val => {\n                 // by-value is this hybrid mode where we have a\n                 // pointer but we do not own it.  This is not\n                 // considered loanable because, for example, a by-ref\n@@ -234,23 +232,23 @@ impl public_methods for borrowck_ctxt {\n               mutbl:m, ty:expr_ty}\n           }\n \n-          ast::def_self(_) {\n+          ast::def_self(_) => {\n             @{id:id, span:span,\n               cat:cat_special(sk_self), lp:none,\n               mutbl:m_imm, ty:expr_ty}\n           }\n \n-          ast::def_upvar(upvid, inner, fn_node_id) {\n+          ast::def_upvar(upvid, inner, fn_node_id) => {\n             let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n             let proto = ty::ty_fn_proto(ty);\n             alt proto {\n-              ast::proto_block {\n+              ast::proto_block => {\n                 let upcmt = self.cat_def(id, span, expr_ty, *inner);\n                 @{id:id, span:span,\n                   cat:cat_stack_upvar(upcmt), lp:upcmt.lp,\n                   mutbl:upcmt.mutbl, ty:upcmt.ty}\n               }\n-              ast::proto_bare | ast::proto_uniq | ast::proto_box {\n+              ast::proto_bare | ast::proto_uniq | ast::proto_box => {\n                 // FIXME #2152 allow mutation of moved upvars\n                 @{id:id, span:span,\n                   cat:cat_special(sk_heap_upvar), lp:none,\n@@ -259,21 +257,21 @@ impl public_methods for borrowck_ctxt {\n             }\n           }\n \n-          ast::def_local(vid, mutbl) {\n+          ast::def_local(vid, mutbl) => {\n             let m = if mutbl {m_mutbl} else {m_imm};\n             @{id:id, span:span,\n               cat:cat_local(vid), lp:some(@lp_local(vid)),\n               mutbl:m, ty:expr_ty}\n           }\n \n-          ast::def_binding(vid, ast::bind_by_value) {\n+          ast::def_binding(vid, ast::bind_by_value) => {\n             // by-value bindings are basically local variables\n             @{id:id, span:span,\n               cat:cat_local(vid), lp:some(@lp_local(vid)),\n               mutbl:m_imm, ty:expr_ty}\n           }\n \n-          ast::def_binding(pid, ast::bind_by_ref) {\n+          ast::def_binding(pid, ast::bind_by_ref) => {\n             // bindings are \"special\" since they are implicit pointers.\n \n             // lookup the mutability for this binding that we found in\n@@ -322,8 +320,8 @@ impl public_methods for borrowck_ctxt {\n     fn cat_field<N:ast_node>(node: N, base_cmt: cmt,\n                              f_name: ast::ident) -> cmt {\n         let f_mutbl = alt field_mutbl(self.tcx, base_cmt.ty, f_name) {\n-          some(f_mutbl) { f_mutbl }\n-          none {\n+          some(f_mutbl) => f_mutbl,\n+          none => {\n             self.tcx.sess.span_bug(\n                 node.span(),\n                 fmt!{\"Cannot find field `%s` in type `%s`\",\n@@ -342,7 +340,7 @@ impl public_methods for borrowck_ctxt {\n                              expl: bool) -> option<cmt> {\n         do ty::deref(self.tcx, base_cmt.ty, expl).map |mt| {\n             alt deref_kind(self.tcx, base_cmt.ty) {\n-              deref_ptr(ptr) {\n+              deref_ptr(ptr) => {\n                 let lp = do base_cmt.lp.chain |l| {\n                     // Given that the ptr itself is loanable, we can\n                     // loan out deref'd uniq ptrs as the data they are\n@@ -371,7 +369,7 @@ impl public_methods for borrowck_ctxt {\n                   mutbl:m, ty:mt.ty}\n               }\n \n-              deref_comp(comp) {\n+              deref_comp(comp) => {\n                 let lp = base_cmt.lp.map(|l| @lp_comp(l, comp) );\n                 let m = self.inherited_mutability(base_cmt.mutbl, mt.mutbl);\n                 @{id:node.id(), span:node.span(),\n@@ -386,8 +384,8 @@ impl public_methods for borrowck_ctxt {\n         let base_cmt = self.cat_autoderef(base);\n \n         let mt = alt ty::index(self.tcx, base_cmt.ty) {\n-          some(mt) { mt }\n-          none {\n+          some(mt) => mt,\n+          none => {\n             self.tcx.sess.span_bug(\n                 expr.span,\n                 fmt!{\"Explicit index of non-index type `%s`\",\n@@ -396,7 +394,7 @@ impl public_methods for borrowck_ctxt {\n         };\n \n         return alt deref_kind(self.tcx, base_cmt.ty) {\n-          deref_ptr(ptr) {\n+          deref_ptr(ptr) => {\n             // (a) the contents are loanable if the base is loanable\n             // and this is a *unique* vector\n             let deref_lp = alt ptr {\n@@ -423,7 +421,7 @@ impl public_methods for borrowck_ctxt {\n             comp(expr, deref_cmt, base_cmt.ty, m, mt.ty)\n           }\n \n-          deref_comp(_) {\n+          deref_comp(_) => {\n             // fixed-length vectors have no deref\n             comp(expr, base_cmt, base_cmt.ty, mt.mutbl, mt.ty)\n           }\n@@ -468,8 +466,8 @@ impl private_methods for borrowck_ctxt {\n         loop {\n             ctr += 1u;\n             alt self.cat_deref(base, cmt, ctr, false) {\n-              none { return cmt; }\n-              some(cmt1) { cmt = cmt1; }\n+              none => return cmt,\n+              some(cmt1) => cmt = cmt1\n             }\n         }\n     }\n@@ -480,25 +478,25 @@ fn field_mutbl(tcx: ty::ctxt,\n                f_name: ast::ident) -> option<ast::mutability> {\n     // Need to refactor so that records/class fields can be treated uniformly.\n     alt ty::get(base_ty).struct {\n-      ty::ty_rec(fields) {\n+      ty::ty_rec(fields) => {\n         for fields.each |f| {\n             if f.ident == f_name {\n                 return some(f.mt.mutbl);\n             }\n         }\n       }\n-      ty::ty_class(did, substs) {\n+      ty::ty_class(did, substs) => {\n         for ty::lookup_class_fields(tcx, did).each |fld| {\n             if fld.ident == f_name {\n                 let m = alt fld.mutability {\n-                  ast::class_mutable { ast::m_mutbl }\n-                  ast::class_immutable { ast::m_imm }\n+                  ast::class_mutable => ast::m_mutbl,\n+                  ast::class_immutable => ast::m_imm\n                 };\n                 return some(m);\n             }\n         }\n       }\n-      _ { }\n+      _ => { }\n     }\n \n     return none;"}, {"sha": "f84fca5c19748dce9a559cb6c363eed96756ae4c", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 84, "deletions": 85, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -65,16 +65,16 @@ impl methods for assignment_type {\n         // the liveness pass guarantees that immutable local variables\n         // are only assigned once; but it doesn't consider &mut\n         alt self {\n-          at_straight_up {true}\n-          at_swap {true}\n-          at_mutbl_ref {false}\n+          at_straight_up => true,\n+          at_swap => true,\n+          at_mutbl_ref => false\n         }\n     }\n     fn ing_form(desc: ~str) -> ~str {\n         alt self {\n-          at_straight_up { ~\"assigning to \" + desc }\n-          at_swap { ~\"swapping to and from \" + desc }\n-          at_mutbl_ref { ~\"taking mut reference to \" + desc }\n+          at_straight_up => ~\"assigning to \" + desc,\n+          at_swap => ~\"swapping to and from \" + desc,\n+          at_mutbl_ref => ~\"taking mut reference to \" + desc\n         }\n     }\n }\n@@ -85,13 +85,13 @@ impl methods for check_loan_ctxt {\n     fn purity(scope_id: ast::node_id) -> option<purity_cause> {\n         let default_purity = alt self.declared_purity {\n           // an unsafe declaration overrides all\n-          ast::unsafe_fn { return none; }\n+          ast::unsafe_fn => return none,\n \n           // otherwise, remember what was declared as the\n           // default, but we must scan for requirements\n           // imposed by the borrow check\n-          ast::pure_fn { some(pc_pure_fn) }\n-          ast::extern_fn | ast::impure_fn { none }\n+          ast::pure_fn => some(pc_pure_fn),\n+          ast::extern_fn | ast::impure_fn => none\n         };\n \n         // scan to see if this scope or any enclosing scope requires\n@@ -102,13 +102,13 @@ impl methods for check_loan_ctxt {\n         let pure_map = self.req_maps.pure_map;\n         loop {\n             alt pure_map.find(scope_id) {\n-              none {}\n-              some(e) {return some(pc_cmt(e));}\n+              none => (),\n+              some(e) => return some(pc_cmt(e))\n             }\n \n             alt region_map.find(scope_id) {\n-              none { return default_purity; }\n-              some(next_scope_id) { scope_id = next_scope_id; }\n+              none => return default_purity,\n+              some(next_scope_id) => scope_id = next_scope_id\n             }\n         }\n     }\n@@ -129,8 +129,8 @@ impl methods for check_loan_ctxt {\n             }\n \n             alt region_map.find(scope_id) {\n-              none { return; }\n-              some(next_scope_id) { scope_id = next_scope_id; }\n+              none => return,\n+              some(next_scope_id) => scope_id = next_scope_id,\n             }\n         }\n     }\n@@ -174,9 +174,9 @@ impl methods for check_loan_ctxt {\n         // (d) B is not a fn.\n \n         alt opt_expr {\n-          some(expr) {\n+          some(expr) => {\n             alt expr.node {\n-              ast::expr_path(_) if pc == pc_pure_fn {\n+              ast::expr_path(_) if pc == pc_pure_fn => {\n                 let def = self.tcx().def_map.get(expr.id);\n                 let did = ast_util::def_id_of_def(def);\n                 let is_fn_arg =\n@@ -185,32 +185,32 @@ impl methods for check_loan_ctxt {\n                 if is_fn_arg { return; } // case (a) above\n               }\n               ast::expr_fn_block(*) | ast::expr_fn(*) |\n-              ast::expr_loop_body(*) | ast::expr_do_body(*) {\n+              ast::expr_loop_body(*) | ast::expr_do_body(*) => {\n                 if self.is_stack_closure(expr.id) {\n                     // case (b) above\n                     return;\n                 }\n               }\n-              _ {}\n+              _ => ()\n             }\n           }\n-          none {}\n+          none => ()\n         }\n \n         let callee_ty = ty::node_id_to_type(tcx, callee_id);\n         alt ty::get(callee_ty).struct {\n-          ty::ty_fn(fn_ty) {\n+          ty::ty_fn(fn_ty) => {\n             alt fn_ty.purity {\n-              ast::pure_fn { return; } // case (c) above\n-              ast::impure_fn | ast::unsafe_fn | ast::extern_fn {\n+              ast::pure_fn => return, // case (c) above\n+              ast::impure_fn | ast::unsafe_fn | ast::extern_fn => {\n                 self.report_purity_error(\n                     pc, callee_span,\n                     fmt!{\"access to %s function\",\n                          pprust::purity_to_str(fn_ty.purity)});\n               }\n             }\n           }\n-          _ { return; } // case (d) above\n+          _ => return, // case (d) above\n         }\n     }\n \n@@ -220,30 +220,30 @@ impl methods for check_loan_ctxt {\n         let fn_ty = ty::node_id_to_type(self.tcx(), id);\n         let proto = ty::ty_fn_proto(fn_ty);\n         alt proto {\n-          ast::proto_block {true}\n-          ast::proto_bare | ast::proto_uniq | ast::proto_box {false}\n+          ast::proto_block => true,\n+          ast::proto_bare | ast::proto_uniq | ast::proto_box => false\n         }\n     }\n \n     fn is_allowed_pure_arg(expr: @ast::expr) -> bool {\n         return alt expr.node {\n-          ast::expr_path(_) {\n+          ast::expr_path(_) => {\n             let def = self.tcx().def_map.get(expr.id);\n             let did = ast_util::def_id_of_def(def);\n             did.crate == ast::local_crate &&\n                 (*self.fn_args).contains(did.node)\n           }\n-          ast::expr_fn_block(*) | ast::expr_fn(*) {\n+          ast::expr_fn_block(*) | ast::expr_fn(*) => {\n             self.is_stack_closure(expr.id)\n           }\n-          _ {false}\n+          _ => false\n         };\n     }\n \n     fn check_for_conflicting_loans(scope_id: ast::node_id) {\n         let new_loanss = alt self.req_maps.req_loan_map.find(scope_id) {\n-            none { return; }\n-            some(loanss) { loanss }\n+            none => return,\n+            some(loanss) => loanss\n         };\n \n         let par_scope_id = self.tcx().region_map.get(scope_id);\n@@ -253,11 +253,11 @@ impl methods for check_loan_ctxt {\n                     if old_loan.lp != new_loan.lp { again; }\n                     alt (old_loan.mutbl, new_loan.mutbl) {\n                       (m_const, _) | (_, m_const) |\n-                      (m_mutbl, m_mutbl) | (m_imm, m_imm) {\n+                      (m_mutbl, m_mutbl) | (m_imm, m_imm) => {\n                         /*ok*/\n                       }\n \n-                      (m_mutbl, m_imm) | (m_imm, m_mutbl) {\n+                      (m_mutbl, m_imm) | (m_imm, m_mutbl) => {\n                         self.bccx.span_err(\n                             new_loan.cmt.span,\n                             fmt!{\"loan of %s as %s \\\n@@ -277,20 +277,20 @@ impl methods for check_loan_ctxt {\n \n     fn is_local_variable(cmt: cmt) -> bool {\n         alt cmt.cat {\n-          cat_local(_) {true}\n-          _ {false}\n+          cat_local(_) => true,\n+          _ => false\n         }\n     }\n \n     fn is_self_field(cmt: cmt) -> bool {\n         alt cmt.cat {\n-          cat_comp(cmt_base, comp_field(*)) {\n+          cat_comp(cmt_base, comp_field(*)) => {\n             alt cmt_base.cat {\n-              cat_special(sk_self) { true }\n-              _ { false }\n+              cat_special(sk_self) => true,\n+              _ => false\n             }\n           }\n-          _ { false }\n+          _ => false\n         }\n     }\n \n@@ -308,8 +308,8 @@ impl methods for check_loan_ctxt {\n             // are only assigned once\n         } else {\n             alt cmt.mutbl {\n-              m_mutbl { /*ok*/ }\n-              m_const | m_imm {\n+              m_mutbl => { /*ok*/ }\n+              m_const | m_imm => {\n                 self.bccx.span_err(\n                     ex.span,\n                     at.ing_form(self.bccx.cmt_to_str(cmt)));\n@@ -322,8 +322,8 @@ impl methods for check_loan_ctxt {\n         // assigned, because it is uniquely tied to this function and\n         // is not visible from the outside\n         alt self.purity(ex.id) {\n-          none {}\n-          some(pc) {\n+          none => (),\n+          some(pc) => {\n             if cmt.lp.is_none() {\n                 self.report_purity_error(\n                     pc, ex.span, at.ing_form(self.bccx.cmt_to_str(cmt)));\n@@ -353,8 +353,8 @@ impl methods for check_loan_ctxt {\n \n         for self.walk_loans_of(ex.id, lp) |loan| {\n             alt loan.mutbl {\n-              m_mutbl | m_const { /*ok*/ }\n-              m_imm {\n+              m_mutbl | m_const => { /*ok*/ }\n+              m_imm => {\n                 self.bccx.span_err(\n                     ex.span,\n                     fmt!{\"%s prohibited due to outstanding loan\",\n@@ -376,22 +376,22 @@ impl methods for check_loan_ctxt {\n         //    let y = &x; // x loaned out as immutable\n         //    x.f = none; // changes type of y.f, which appears to be imm\n         alt *lp {\n-          lp_comp(lp_base, ck) if inherent_mutability(ck) != m_mutbl {\n+          lp_comp(lp_base, ck) if inherent_mutability(ck) != m_mutbl => {\n             self.check_for_loan_conflicting_with_assignment(\n                 at, ex, cmt, lp_base);\n           }\n-          lp_comp(*) | lp_local(*) | lp_arg(*) | lp_deref(*) {}\n+          lp_comp(*) | lp_local(*) | lp_arg(*) | lp_deref(*) => ()\n         }\n     }\n \n     fn report_purity_error(pc: purity_cause, sp: span, msg: ~str) {\n         alt pc {\n-          pc_pure_fn {\n+          pc_pure_fn => {\n             self.tcx().sess.span_err(\n                 sp,\n                 fmt!{\"%s prohibited in pure context\", msg});\n           }\n-          pc_cmt(e) {\n+          pc_cmt(e) => {\n             if self.reported.insert(e.cmt.id, ()) {\n                 self.tcx().sess.span_err(\n                     e.cmt.span,\n@@ -416,18 +416,17 @@ impl methods for check_loan_ctxt {\n \n         alt cmt.cat {\n           // Rvalues, locals, and arguments can be moved:\n-          cat_rvalue | cat_local(_) | cat_arg(_) { }\n+          cat_rvalue | cat_local(_) | cat_arg(_) => {}\n \n           // We allow moving out of static items because the old code\n           // did.  This seems consistent with permitting moves out of\n           // rvalues, I guess.\n-          cat_special(sk_static_item) { }\n+          cat_special(sk_static_item) => {}\n \n-          cat_deref(_, _, unsafe_ptr) {\n-          }\n+          cat_deref(_, _, unsafe_ptr) => {}\n \n           // Nothing else.\n-          _ {\n+          _ => {\n             self.bccx.span_err(\n                 cmt.span,\n                 fmt!{\"moving out of %s\", self.bccx.cmt_to_str(cmt)});\n@@ -439,8 +438,8 @@ impl methods for check_loan_ctxt {\n \n         // check for a conflicting loan:\n         let lp = alt cmt.lp {\n-          none { return; }\n-          some(lp) { lp }\n+          none => return,\n+          some(lp) => lp\n         };\n         for self.walk_loans_of(cmt.id, lp) |loan| {\n             self.bccx.span_err(\n@@ -461,8 +460,8 @@ impl methods for check_loan_ctxt {\n     fn check_last_use(expr: @ast::expr) {\n         let cmt = self.bccx.cat_expr(expr);\n         let lp = alt cmt.lp {\n-          none { return; }\n-          some(lp) { lp }\n+          none => return,\n+          some(lp) => lp\n         };\n         for self.walk_loans_of(cmt.id, lp) |_loan| {\n             debug!{\"Removing last use entry %? due to outstanding loan\",\n@@ -478,8 +477,8 @@ impl methods for check_loan_ctxt {\n                   callee_span: span,\n                   args: ~[@ast::expr]) {\n         alt self.purity(expr.id) {\n-          none {}\n-          some(pc) {\n+          none => {}\n+          some(pc) => {\n             self.check_pure_callee_or_arg(\n                 pc, callee, callee_id, callee_span);\n             for args.each |arg| {\n@@ -493,13 +492,13 @@ impl methods for check_loan_ctxt {\n                 ty::node_id_to_type(self.tcx(), callee_id));\n         do vec::iter2(args, arg_tys) |arg, arg_ty| {\n             alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n-              ast::by_move {\n+              ast::by_move => {\n                 self.check_move_out(arg);\n               }\n-              ast::by_mutbl_ref {\n+              ast::by_mutbl_ref => {\n                 self.check_assignment(at_mutbl_ref, arg);\n               }\n-              ast::by_ref | ast::by_copy | ast::by_val {\n+              ast::by_ref | ast::by_copy | ast::by_val => {\n               }\n             }\n         }\n@@ -523,19 +522,19 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                 // able to \"see\" into those functions anyway, so it\n                 // wouldn't be very helpful.\n                 alt fk {\n-                  visit::fk_ctor(*) {\n+                  visit::fk_ctor(*) => {\n                     self.in_ctor = true;\n                     self.declared_purity = decl.purity;\n                     self.fn_args = @decl.inputs.map(|i| i.id );\n                   }\n                   visit::fk_anon(*) |\n-                  visit::fk_fn_block(*) if is_stack_closure {\n+                  visit::fk_fn_block(*) if is_stack_closure => {\n                     self.in_ctor = false;\n                     // inherits the purity/fn_args from enclosing ctxt\n                   }\n                   visit::fk_anon(*) | visit::fk_fn_block(*) |\n                   visit::fk_method(*) | visit::fk_item_fn(*) |\n-                  visit::fk_dtor(*) {\n+                  visit::fk_dtor(*) => {\n                     self.in_ctor = false;\n                     self.declared_purity = decl.purity;\n                     self.fn_args = @decl.inputs.map(|i| i.id );\n@@ -553,10 +552,10 @@ fn check_loans_in_local(local: @ast::local,\n                         &&self: check_loan_ctxt,\n                         vt: visit::vt<check_loan_ctxt>) {\n     alt local.node.init {\n-      some({op: ast::init_move, expr: expr}) {\n+      some({op: ast::init_move, expr: expr}) => {\n         self.check_move_out(expr);\n       }\n-      some({op: ast::init_assign, _}) | none {}\n+      some({op: ast::init_assign, _}) | none => {}\n     }\n     visit::visit_local(local, self, vt);\n }\n@@ -567,27 +566,27 @@ fn check_loans_in_expr(expr: @ast::expr,\n     self.check_for_conflicting_loans(expr.id);\n \n     alt expr.node {\n-      ast::expr_path(*) if self.bccx.last_use_map.contains_key(expr.id) {\n+      ast::expr_path(*) if self.bccx.last_use_map.contains_key(expr.id) => {\n         self.check_last_use(expr);\n       }\n \n-      ast::expr_swap(l, r) {\n+      ast::expr_swap(l, r) => {\n         self.check_assignment(at_swap, l);\n         self.check_assignment(at_swap, r);\n       }\n-      ast::expr_move(dest, src) {\n+      ast::expr_move(dest, src) => {\n         self.check_assignment(at_straight_up, dest);\n         self.check_move_out(src);\n       }\n-      ast::expr_unary_move(src) {\n+      ast::expr_unary_move(src) => {\n         self.check_move_out(src);\n       }\n       ast::expr_assign(dest, _) |\n-      ast::expr_assign_op(_, dest, _) {\n+      ast::expr_assign_op(_, dest, _) => {\n         self.check_assignment(at_straight_up, dest);\n       }\n       ast::expr_fn(_, _, _, cap_clause) |\n-      ast::expr_fn_block(_, _, cap_clause) {\n+      ast::expr_fn_block(_, _, cap_clause) => {\n         for (*cap_clause).each |cap_item| {\n             if cap_item.is_move {\n                 let def = self.tcx().def_map.get(cap_item.id);\n@@ -601,40 +600,40 @@ fn check_loans_in_expr(expr: @ast::expr,\n             }\n         }\n       }\n-      ast::expr_addr_of(mutbl, base) {\n+      ast::expr_addr_of(mutbl, base) => {\n         alt mutbl {\n-          m_const { /*all memory is const*/ }\n-          m_mutbl {\n+          m_const => { /*all memory is const*/ }\n+          m_mutbl => {\n             // If we are taking an &mut ptr, make sure the memory\n             // being pointed at is assignable in the first place:\n             self.check_assignment(at_mutbl_ref, base);\n           }\n-          m_imm {\n+          m_imm => {\n             // XXX explain why no check is req'd here\n           }\n         }\n       }\n-      ast::expr_call(f, args, _) {\n+      ast::expr_call(f, args, _) => {\n         self.check_call(expr, some(f), f.id, f.span, args);\n       }\n       ast::expr_index(_, rval) |\n       ast::expr_binary(_, _, rval)\n-      if self.bccx.method_map.contains_key(expr.id) {\n+      if self.bccx.method_map.contains_key(expr.id) => {\n         self.check_call(expr,\n                         none,\n                         expr.callee_id,\n                         expr.span,\n                         ~[rval]);\n       }\n       ast::expr_unary(*) | ast::expr_index(*)\n-      if self.bccx.method_map.contains_key(expr.id) {\n+      if self.bccx.method_map.contains_key(expr.id) => {\n         self.check_call(expr,\n                         none,\n                         expr.callee_id,\n                         expr.span,\n                         ~[]);\n       }\n-      _ { }\n+      _ => { }\n     }\n \n     visit::visit_expr(expr, self, vt);\n@@ -647,12 +646,12 @@ fn check_loans_in_block(blk: ast::blk,\n         self.check_for_conflicting_loans(blk.node.id);\n \n         alt blk.node.rules {\n-          ast::default_blk {\n+          ast::default_blk => {\n           }\n-          ast::unchecked_blk {\n+          ast::unchecked_blk => {\n             self.declared_purity = ast::impure_fn;\n           }\n-          ast::unsafe_blk {\n+          ast::unsafe_blk => {\n             self.declared_purity = ast::unsafe_fn;\n           }\n         }"}, {"sha": "88e329f63c0d79a2ead3bc5dff397bccc9fa56fc", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -71,9 +71,9 @@ fn req_loans_in_fn(fk: visit::fn_kind,\n     self.root_ub = body.node.id;\n \n     alt fk {\n-      visit::fk_anon(*) | visit::fk_fn_block(*) {}\n+      visit::fk_anon(*) | visit::fk_fn_block(*) => {}\n       visit::fk_item_fn(*) | visit::fk_method(*) |\n-      visit::fk_ctor(*) | visit::fk_dtor(*) {\n+      visit::fk_ctor(*) | visit::fk_dtor(*) => {\n         self.item_ub = body.node.id;\n       }\n     }\n@@ -100,33 +100,33 @@ fn req_loans_in_expr(ex: @ast::expr,\n \n     // Special checks for various kinds of expressions:\n     alt ex.node {\n-      ast::expr_addr_of(mutbl, base) {\n+      ast::expr_addr_of(mutbl, base) => {\n         let base_cmt = self.bccx.cat_expr(base);\n \n         // make sure that the thing we are pointing out stays valid\n         // for the lifetime `scope_r` of the resulting ptr:\n         let scope_r =\n             alt check ty::get(tcx.ty(ex)).struct {\n-              ty::ty_rptr(r, _) { r }\n+              ty::ty_rptr(r, _) => r\n             };\n         self.guarantee_valid(base_cmt, mutbl, scope_r);\n         visit::visit_expr(ex, self, vt);\n       }\n \n-      ast::expr_call(f, args, _) {\n+      ast::expr_call(f, args, _) => {\n         let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n         let scope_r = ty::re_scope(ex.id);\n         do vec::iter2(args, arg_tys) |arg, arg_ty| {\n             alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n-              ast::by_mutbl_ref {\n+              ast::by_mutbl_ref => {\n                 let arg_cmt = self.bccx.cat_expr(arg);\n                 self.guarantee_valid(arg_cmt, m_mutbl, scope_r);\n               }\n-              ast::by_ref {\n+              ast::by_ref => {\n                 let arg_cmt = self.bccx.cat_expr(arg);\n                 self.guarantee_valid(arg_cmt, m_imm,  scope_r);\n               }\n-              ast::by_val {\n+              ast::by_val => {\n                 // Rust's by-val does not actually give ownership to\n                 // the callee.  This means that if a pointer type is\n                 // passed, it is effectively a borrow, and so the\n@@ -153,27 +153,27 @@ fn req_loans_in_expr(ex: @ast::expr,\n                 //\n                 alt opt_deref_kind(arg_ty.ty) {\n                   some(deref_ptr(region_ptr(_))) |\n-                  some(deref_ptr(unsafe_ptr)) {\n+                  some(deref_ptr(unsafe_ptr)) => {\n                     /* region pointers are (by induction) guaranteed */\n                     /* unsafe pointers are the user's problem */\n                   }\n                   some(deref_comp(_)) |\n-                  none {\n+                  none => {\n                     /* not a pointer, no worries */\n                   }\n-                  some(deref_ptr(_)) {\n+                  some(deref_ptr(_)) => {\n                     let arg_cmt = self.bccx.cat_borrow_of_expr(arg);\n                     self.guarantee_valid(arg_cmt, m_const, scope_r);\n                   }\n                 }\n               }\n-              ast::by_move | ast::by_copy {}\n+              ast::by_move | ast::by_copy => {}\n             }\n         }\n         visit::visit_expr(ex, self, vt);\n       }\n \n-      ast::expr_alt(ex_v, arms, _) {\n+      ast::expr_alt(ex_v, arms, _) => {\n         let cmt = self.bccx.cat_expr(ex_v);\n         for arms.each |arm| {\n             for arm.pats.each |pat| {\n@@ -185,7 +185,8 @@ fn req_loans_in_expr(ex: @ast::expr,\n \n       ast::expr_index(rcvr, _) |\n       ast::expr_binary(_, rcvr, _) |\n-      ast::expr_unary(_, rcvr) if self.bccx.method_map.contains_key(ex.id) {\n+      ast::expr_unary(_, rcvr)\n+      if self.bccx.method_map.contains_key(ex.id) => {\n         // Receivers in method calls are always passed by ref.\n         //\n         // Here, in an overloaded operator, the call is this expression,\n@@ -202,7 +203,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n       }\n \n       ast::expr_field(rcvr, _, _)\n-      if self.bccx.method_map.contains_key(ex.id) {\n+      if self.bccx.method_map.contains_key(ex.id) => {\n         // Receivers in method calls are always passed by ref.\n         //\n         // Here, the field a.b is in fact a closure.  Eventually, this\n@@ -218,7 +219,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n       }\n \n       // see explanation attached to the `root_ub` field:\n-      ast::expr_while(cond, body) {\n+      ast::expr_while(cond, body) => {\n         // during the condition, can only root for the condition\n         self.root_ub = cond.id;\n         vt.visit_expr(cond, self, vt);\n@@ -229,7 +230,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n       }\n \n       // see explanation attached to the `root_ub` field:\n-      ast::expr_loop(body) {\n+      ast::expr_loop(body) => {\n         self.root_ub = body.node.id;\n         visit::visit_expr(ex, self, vt);\n       }\n@@ -275,7 +276,7 @@ impl methods for gather_loan_ctxt {\n           // duration of the reference: if there is an attempt to move\n           // it within that scope, the loan will be detected and an\n           // error will be reported.\n-          some(_) {\n+          some(_) => {\n             alt self.bccx.loan(cmt, scope_r, req_mutbl) {\n               err(e) => { self.bccx.report(e); }\n               ok(loans) if loans.len() == 0 => {}\n@@ -313,7 +314,7 @@ impl methods for gather_loan_ctxt {\n           // also check that the mutability of the desired pointer\n           // matches with the actual mutability (but if an immutable\n           // pointer is desired, that is ok as long as we are pure)\n-          none {\n+          none => {\n             let result: bckres<preserve_condition> = {\n                 do self.check_mutbl(req_mutbl, cmt).chain |pc1| {\n                     do self.bccx.preserve(cmt, scope_r,\n@@ -325,13 +326,13 @@ impl methods for gather_loan_ctxt {\n             };\n \n             alt result {\n-              ok(pc_ok) {\n+              ok(pc_ok) => {\n                 // we were able guarantee the validity of the ptr,\n                 // perhaps by rooting or because it is immutably\n                 // rooted.  good.\n                 self.bccx.stable_paths += 1;\n               }\n-              ok(pc_if_pure(e)) {\n+              ok(pc_if_pure(e)) => {\n                 // we are only able to guarantee the validity if\n                 // the scope is pure\n                 alt scope_r {\n@@ -397,10 +398,10 @@ impl methods for gather_loan_ctxt {\n \n     fn add_loans(scope_id: ast::node_id, loans: @dvec<loan>) {\n         alt self.req_maps.req_loan_map.find(scope_id) {\n-          some(l) {\n+          some(l) => {\n             (*l).push(loans);\n           }\n-          none {\n+          none => {\n             self.req_maps.req_loan_map.insert(\n                 scope_id, @dvec::from_vec(~[mut loans]));\n           }\n@@ -450,21 +451,21 @@ impl methods for gather_loan_ctxt {\n \n         let tcx = self.tcx();\n         alt pat.node {\n-          ast::pat_wild {\n+          ast::pat_wild => {\n             // _\n           }\n \n-          ast::pat_enum(_, none) {\n+          ast::pat_enum(_, none) => {\n             // variant(*)\n           }\n-          ast::pat_enum(_, some(subpats)) {\n+          ast::pat_enum(_, some(subpats)) => {\n             // variant(x, y, z)\n             let enum_did = alt self.bccx.tcx.def_map\n .find(pat.id) {\n-              some(ast::def_variant(enum_did, _)) {enum_did}\n-              e {tcx.sess.span_bug(pat.span,\n-                                   fmt!{\"resolved to %?, \\\n-                                         not variant\", e})}\n+              some(ast::def_variant(enum_did, _)) => enum_did,\n+              e => tcx.sess.span_bug(pat.span,\n+                                     fmt!{\"resolved to %?, \\\n+                                               not variant\", e})\n             };\n \n             for subpats.each |subpat| {\n@@ -473,11 +474,11 @@ impl methods for gather_loan_ctxt {\n             }\n           }\n \n-          ast::pat_ident(_, _, none) if self.pat_is_variant(pat) {\n+          ast::pat_ident(_, _, none) if self.pat_is_variant(pat) => {\n             // nullary variant\n             debug!{\"nullary variant\"};\n           }\n-          ast::pat_ident(_, id, o_pat) {\n+          ast::pat_ident(_, id, o_pat) => {\n             // XXX: Needs to take by-ref/by-val into account.\n \n             // x or x @ p --- `x` must remain valid for the scope of the alt\n@@ -504,35 +505,35 @@ impl methods for gather_loan_ctxt {\n             }\n           }\n \n-          ast::pat_rec(field_pats, _) {\n+          ast::pat_rec(field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for field_pats.each |fp| {\n                 let cmt_field = self.bccx.cat_field(fp.pat, cmt, fp.ident);\n                 self.gather_pat(cmt_field, fp.pat, arm_id, alt_id);\n             }\n           }\n \n-          ast::pat_tup(subpats) {\n+          ast::pat_tup(subpats) => {\n             // (p1, ..., pN)\n             for subpats.each |subpat| {\n                 let subcmt = self.bccx.cat_tuple_elt(subpat, cmt);\n                 self.gather_pat(subcmt, subpat, arm_id, alt_id);\n             }\n           }\n \n-          ast::pat_box(subpat) | ast::pat_uniq(subpat) {\n+          ast::pat_box(subpat) | ast::pat_uniq(subpat) => {\n             // @p1, ~p1\n             alt self.bccx.cat_deref(subpat, cmt, 0u, true) {\n-              some(subcmt) {\n+              some(subcmt) => {\n                 self.gather_pat(subcmt, subpat, arm_id, alt_id);\n               }\n-              none {\n+              none => {\n                 tcx.sess.span_bug(pat.span, ~\"Non derefable type\");\n               }\n             }\n           }\n \n-          ast::pat_lit(_) | ast::pat_range(_, _) { /*always ok*/ }\n+          ast::pat_lit(_) | ast::pat_range(_, _) => { /*always ok*/ }\n         }\n     }\n "}, {"sha": "5479afd10b764e179babadcdb644d21e487ff5cf", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -71,25 +71,25 @@ impl loan_methods for loan_ctxt {\n         }\n \n         alt cmt.cat {\n-          cat_binding(_) | cat_rvalue | cat_special(_) {\n+          cat_binding(_) | cat_rvalue | cat_special(_) => {\n             // should never be loanable\n             self.bccx.tcx.sess.span_bug(\n                 cmt.span,\n                 ~\"rvalue with a non-none lp\");\n           }\n-          cat_local(local_id) | cat_arg(local_id) {\n+          cat_local(local_id) | cat_arg(local_id) => {\n             let local_scope_id = self.tcx().region_map.get(local_id);\n             self.ok_with_loan_of(cmt, ty::re_scope(local_scope_id), req_mutbl)\n           }\n-          cat_stack_upvar(cmt) {\n+          cat_stack_upvar(cmt) => {\n             self.loan(cmt, req_mutbl) // NDM correct?\n           }\n-          cat_discr(base, _) {\n+          cat_discr(base, _) => {\n             self.loan(base, req_mutbl)\n           }\n           cat_comp(cmt_base, comp_field(*)) |\n           cat_comp(cmt_base, comp_index(*)) |\n-          cat_comp(cmt_base, comp_tuple) {\n+          cat_comp(cmt_base, comp_tuple) => {\n             // For most components, the type of the embedded data is\n             // stable.  Therefore, the base structure need only be\n             // const---unless the component must be immutable.  In\n@@ -98,7 +98,7 @@ impl loan_methods for loan_ctxt {\n             // overwritten and the component along with it.\n             self.loan_stable_comp(cmt, cmt_base, req_mutbl)\n           }\n-          cat_comp(cmt_base, comp_variant(enum_did)) {\n+          cat_comp(cmt_base, comp_variant(enum_did)) => {\n             // For enums, the memory is unstable if there are multiple\n             // variants, because if the enum value is overwritten then\n             // the memory changes type.\n@@ -108,15 +108,15 @@ impl loan_methods for loan_ctxt {\n                 self.loan_unstable_deref(cmt, cmt_base, req_mutbl)\n             }\n           }\n-          cat_deref(cmt_base, _, uniq_ptr) {\n+          cat_deref(cmt_base, _, uniq_ptr) => {\n             // For unique pointers, the memory being pointed out is\n             // unstable because if the unique pointer is overwritten\n             // then the memory is freed.\n             self.loan_unstable_deref(cmt, cmt_base, req_mutbl)\n           }\n           cat_deref(cmt1, _, unsafe_ptr) |\n           cat_deref(cmt1, _, gc_ptr) |\n-          cat_deref(cmt1, _, region_ptr(_)) {\n+          cat_deref(cmt1, _, region_ptr(_)) => {\n             // Aliased data is simply not lendable.\n             self.bccx.tcx.sess.span_bug(\n                 cmt.span,\n@@ -132,8 +132,8 @@ impl loan_methods for loan_ctxt {\n                         cmt_base: cmt,\n                         req_mutbl: ast::mutability) -> bckres<()> {\n         let base_mutbl = alt req_mutbl {\n-          m_imm { m_imm }\n-          m_const | m_mutbl { m_const }\n+          m_imm => m_imm,\n+          m_const | m_mutbl => m_const\n         };\n \n         do self.loan(cmt_base, base_mutbl).chain |_ok| {"}, {"sha": "568030c85b5c71491b583479f67a02440a265674", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -64,13 +64,13 @@ impl private_methods for &preserve_ctxt {\n         let _i = indenter();\n \n         alt cmt.cat {\n-          cat_special(sk_self) | cat_special(sk_heap_upvar) {\n+          cat_special(sk_self) | cat_special(sk_heap_upvar) => {\n             self.compare_scope(cmt, ty::re_scope(self.item_ub))\n           }\n-          cat_special(sk_static_item) | cat_special(sk_method) {\n+          cat_special(sk_static_item) | cat_special(sk_method) => {\n             ok(pc_ok)\n           }\n-          cat_rvalue {\n+          cat_rvalue => {\n             // when we borrow an rvalue, we can keep it rooted but only\n             // up to the root_ub point\n \n@@ -85,10 +85,10 @@ impl private_methods for &preserve_ctxt {\n             // FIXME(#2977)--need to update trans!\n             self.compare_scope(cmt, scope_region)\n           }\n-          cat_stack_upvar(cmt) {\n+          cat_stack_upvar(cmt) => {\n             self.preserve(cmt)\n           }\n-          cat_local(local_id) {\n+          cat_local(local_id) => {\n             // Normally, local variables are lendable, and so this\n             // case should never trigger.  However, if we are\n             // preserving an expression like a.b where the field `b`\n@@ -103,14 +103,14 @@ impl private_methods for &preserve_ctxt {\n             let local_scope_id = self.tcx().region_map.get(local_id);\n             self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n-          cat_binding(local_id) {\n+          cat_binding(local_id) => {\n             // Bindings are these kind of weird implicit pointers (cc\n             // #2329).  We require (in gather_loans) that they be\n             // rooted in an immutable location.\n             let local_scope_id = self.tcx().region_map.get(local_id);\n             self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n-          cat_arg(local_id) {\n+          cat_arg(local_id) => {\n             // This can happen as not all args are lendable (e.g., &&\n             // modes).  In that case, the caller guarantees stability\n             // for at least the scope of the fn.  This is basically a\n@@ -120,12 +120,12 @@ impl private_methods for &preserve_ctxt {\n           }\n           cat_comp(cmt_base, comp_field(*)) |\n           cat_comp(cmt_base, comp_index(*)) |\n-          cat_comp(cmt_base, comp_tuple) {\n+          cat_comp(cmt_base, comp_tuple) => {\n             // Most embedded components: if the base is stable, the\n             // type never changes.\n             self.preserve(cmt_base)\n           }\n-          cat_comp(cmt_base, comp_variant(enum_did)) {\n+          cat_comp(cmt_base, comp_variant(enum_did)) => {\n             if ty::enum_is_univariant(self.tcx(), enum_did) {\n                 self.preserve(cmt_base)\n             } else {\n@@ -135,22 +135,22 @@ impl private_methods for &preserve_ctxt {\n                 self.require_imm(cmt, cmt_base, err_mut_variant)\n             }\n           }\n-          cat_deref(cmt_base, _, uniq_ptr) {\n+          cat_deref(cmt_base, _, uniq_ptr) => {\n             // Overwriting the base could cause this memory to be\n             // freed, so require imm.\n             self.require_imm(cmt, cmt_base, err_mut_uniq)\n           }\n-          cat_deref(_, _, region_ptr(region)) {\n+          cat_deref(_, _, region_ptr(region)) => {\n             // References are always \"stable\" for lifetime `region` by\n             // induction (when the reference of type &MT was created,\n             // the memory must have been stable).\n             self.compare_scope(cmt, region)\n           }\n-          cat_deref(_, _, unsafe_ptr) {\n+          cat_deref(_, _, unsafe_ptr) => {\n             // Unsafe pointers are the user's problem\n             ok(pc_ok)\n           }\n-          cat_deref(base, derefs, gc_ptr) {\n+          cat_deref(base, derefs, gc_ptr) => {\n             // GC'd pointers of type @MT: if this pointer lives in\n             // immutable, stable memory, then everything is fine.  But\n             // otherwise we have no guarantee the pointer will stay\n@@ -164,7 +164,7 @@ impl private_methods for &preserve_ctxt {\n                   ok(pc_ok) => {\n                     ok(pc_ok)\n                   }\n-                  ok(pc_if_pure(_)) {\n+                  ok(pc_if_pure(_)) => {\n                     debug!{\"must root @T, otherwise purity req'd\"};\n                     self.attempt_root(cmt, base, derefs)\n                   }\n@@ -178,7 +178,7 @@ impl private_methods for &preserve_ctxt {\n                 self.attempt_root(cmt, base, derefs)\n             }\n           }\n-          cat_discr(base, alt_id) {\n+          cat_discr(base, alt_id) => {\n             // Subtle: in an alt, we must ensure that each binding\n             // variable remains valid for the duration of the arm in\n             // which it appears, presuming that this arm is taken."}, {"sha": "1af377e1ba26b4b49162336eb37e036642eaa7ed", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56", "patch": "@@ -102,15 +102,15 @@ fn compute_capture_vars(tcx: ty::ctxt,\n     // named and add that\n \n     let implicit_mode = alt fn_proto {\n-      ast::proto_block { cap_ref }\n-      ast::proto_bare | ast::proto_box | ast::proto_uniq { cap_copy }\n+      ast::proto_block => cap_ref,\n+      ast::proto_bare | ast::proto_box | ast::proto_uniq => cap_copy\n     };\n \n     do vec::iter(*freevars) |fvar| {\n         let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n         alt cap_map.find(fvar_def_id) {\n-          option::some(_) { /* was explicitly named, do nothing */ }\n-          option::none {\n+          option::some(_) => { /* was explicitly named, do nothing */ }\n+          option::none => {\n             cap_map.insert(fvar_def_id, {def:fvar.def,\n                                          span: fvar.span,\n                                          cap_item: none,"}, {"sha": "28fbfacb78ccae53ab6c289678dcd58e9b2dc55d", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "4d2ffa4b3e9484d06a2d18f5314f9cc66e631b7a", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "0ac3caa633bb1b08e0fc9ccdb6cdf9565594962a", "filename": "src/rustc/middle/check_loop.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_loop.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "66c19a14e6f5fa2974dea1022f5984aa0c2971ac", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 111, "deletions": 89, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "7c8e807a085d916f882a168e6248ecdeca790855", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "e855e23b12b9acc581a57c35d3d0e17e5284852f", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "5abc64a3b0d4922c125f9ef7d802993f1b08b999", "filename": "src/rustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flang_items.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "61299171eae4b4575997727e9c428a2cf3278d3a", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "fe343d76cc92f9b6eac05fa40a5530b777cd4981", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 144, "deletions": 162, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "405afe20a1c15f58bad9871d7fbd96c0d2088c67", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "9cece96b89241ce290ff8d750253fe950dec5f0e", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "fc7f079e172432f87986e228b7b2a72902da9d87", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 365, "deletions": 379, "changes": 744, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "e3103cfefc6df3c39c5382df0269991694b7f48d", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 92, "deletions": 83, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "6df45f75adbe7f26fff2600ccfdac608f0f977ba", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 518, "deletions": 510, "changes": 1028, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "6e7c41e0fa97ea117547369654ea43bedbacf333", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "1912c50969336cc5c367e7270b6c9f341fe356c6", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 51, "deletions": 59, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "99fd0c8b7bc9124a6d1057e00fac3b3d86e09ebf", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 59, "deletions": 46, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "d0a448da5b2f601f1b3bab6526e7b5ea66af9588", "filename": "src/rustc/middle/trans/consts.rs", "status": "modified", "additions": 49, "deletions": 52, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "30300550c3199afa64fd75dedfc6716b817c59de", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 74, "deletions": 73, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "56f8892ff37e2e752b5cb8be60ea782065ab448e", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 80, "deletions": 92, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "434707f3fa8d50dd349d06ff5c6254b56119d1b9", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "b149857ffaa7c4de93d8d377679f14e93d5a9081", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "c4d4cd6f9b35aaf9c76a7eff495833336b70149f", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 61, "deletions": 63, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "d6d5d96e4dc18c6d7fc9800befa4cd6b16d330fa", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "84d7ca370f9dba07c5fb78c3ee3c68223c0a9456", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "03f7d2b5482439b16b48e8e71586f777a37d495f", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "4026d2b0a2497fd2a7fe65d473f0742c5e5244cf", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 44, "deletions": 40, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "c2bdf2801004115e39758e545cb5b782a6afc163", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "210c4c9af8656db6127c85f6cd556a57c08c846c", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 437, "deletions": 434, "changes": 871, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "a0c1d1da02f956891c7543260cf43a1d33b63f15", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "1211c5aa8d647dec6e1f9ed362c68af0d7660052", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 57, "deletions": 56, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "d4efdbf7b011cfc168e6f201e59185883c833b26", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 253, "deletions": 258, "changes": 511, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "316ef5a89278f9100c1d1fda8527e6f09e3825f6", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "e1cf67e94e6c1e063266ac8a4e98de5d28ad102f", "filename": "src/rustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "f86d5bf3a7a6e4db760a630d3d03e8b3d7cbca9a", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "7871e1802ea64273f996806f872a9919bc8dd990", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "aee2a62d9471f8262020f4c0fd3daead9982ee1c", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "e1d85828c139d611200e56b357867eee11cbb8b0", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "bafcfc4855d207e5df4c46a5a4c123e16f5810f1", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "74f9b6c306165fd95ca33d8e28fc8eb818f28c90", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "5a13d1d8efcf03413fbb1fd47ffe9bb77451ad8d", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 48, "deletions": 50, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "d13a18dfcc672e5f645f132830381a1e321d56a7", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 177, "deletions": 193, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "d471ba677b550e6091c3ba6b4343b9359c2cfc88", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "571da9db0699de8f2942e04aa9f103ad34026659", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 65, "deletions": 62, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "58341e2152ddb6f7dd2edceb4bdab7ef011b08b5", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "ba633111a6a01adcbe95cf7d41e7837644770973", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "9c55ebc4a95e06d0451f7c46beca073cfb30827f", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "398892d715f0d101abc105b0485c03dc0dd409df", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "76c74c71ef4ff362b0f6873e42ca68055d8741f1", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "723bcff5fb04c9626a00c901348a025fa9a555ba", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "7d56efcc4ee80bdc3be129e22fc0d44470ac2e65", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "b848c6b88999d1d90930ba93fcabeea08d22f7b5", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "123ad89ecd4b484a4acfc19759bd4527298d78e9", "filename": "src/rustdoc/markdown_index_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_index_pass.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "90d00d292b103b4095bb5f8df8a83aaf01389085", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "3f46f8f3d5b19e63590706bd58a313794ff7fd3d", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "11cf4f735cf91f463039aba8b32a01f6cb918097", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "d8060257a63fe175b0864876d7486333119b02fe", "filename": "src/rustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_hidden_pass.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "015da4b52d881c649e8aaab82a5ca9621d282124", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "29bebdf10e5cec2b8dcce9fb097661844f1f585f", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "afa299345dcb2425ac363bec234dd85f38805e51", "filename": "src/rustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_type_pass.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "a2ae6d5eba499ebe807514360d80e1b57ed92038", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "3c7057320ec9dadcd0745939b6a29809a8b2da49", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "dfc74f12cefe184f3afb9a5667e03f701189a52f", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "e0ebda079f744ba031546a9584b07da98bff0f45", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "067bd710b3d09edc663b92536c5c85f87052c460", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "c494bfc485a3868fabda8355ac03345c9f5c5530", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "5b2488efa2f0a0fad9ff27e0377f1fa94ba27c51", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "be3a868beb2ad82569901238ee8959e40ecf353a", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "7adc176bcffb9193027db87c390d1d13a9c03de9", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "ca014b6145511638d405694cad8db76256bd0694", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "5ffa7cc4f2698380a5c752ba25e27f376b72b114", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "f00396f9b1499a1f82cc1bdadea7560fc99ecd63", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "e99d2946e814afd33286ecc89be496c80f0b3552", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "2a8750b64bdc13881750a35044667c1316e37358", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "85008b0daf981024c10aaa3676d0d8d932ab46c4", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "c31ccde2ca644bc0e920f70a29c66a7c485f8047", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "1557ff120902ccfa9bddb56b17ca552d96b2dd51", "filename": "src/test/compile-fail/alt-join.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-join.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "6ba942decfc0b3ef017343d48565a7ade846be2c", "filename": "src/test/compile-fail/alt-pattern-field-mismatch-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch-2.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "71f44764e1446ae9b238d83d372151accdbf5581", "filename": "src/test/compile-fail/alt-pattern-field-mismatch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "d1ba0f625b161c3605541032ef5e6897cb1dca42", "filename": "src/test/compile-fail/alt-range-fail-dominate.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Falt-range-fail-dominate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Falt-range-fail-dominate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-range-fail-dominate.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "afda6d7015ebf3a40ea3c80188a42bf752c6824f", "filename": "src/test/compile-fail/alt-range-fail.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Falt-range-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Falt-range-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-range-fail.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "4f34c675cefc44ab4de64357fd947b4dcf44479a", "filename": "src/test/compile-fail/alt-tag-nullary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Falt-tag-nullary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Falt-tag-nullary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-tag-nullary.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "f0546574912e392a75af0edf58c65df23d079779", "filename": "src/test/compile-fail/alt-tag-unary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Falt-tag-unary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Falt-tag-unary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-tag-unary.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "4c8d72444c1c241f6305237c5e746e590a026543", "filename": "src/test/compile-fail/bad-record-pat-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fbad-record-pat-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fbad-record-pat-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-record-pat-2.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "48155a0b529063a7b3247996e7ba389f10e6def4", "filename": "src/test/compile-fail/bad-record-pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fbad-record-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fbad-record-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-record-pat.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "0414bb5e8676ca67eee6d93ef703ed990c67f804", "filename": "src/test/compile-fail/bogus-tag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "2d396bd591ca10b055f1c94ca5c62dc260b2f312", "filename": "src/test/compile-fail/borrowck-issue-2657-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "85d062dd98cc982ae2a4c6514b370fd5b2471a91", "filename": "src/test/compile-fail/borrowck-issue-2657-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "acb018dbb2d852b336c8152b6e1ca029e568e267", "filename": "src/test/compile-fail/borrowck-no-cycle-in-exchange-heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "103de904609bd4e27929d74371fac95b643690d5", "filename": "src/test/compile-fail/borrowck-pat-enum-in-box.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "6dd37e647ac97059953b2bd7da686b445a523f6b", "filename": "src/test/compile-fail/borrowck-pat-enum.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "2d7f33e662024714e5b52afd65741790c3a5d1be", "filename": "src/test/compile-fail/borrowck-pat-reassign-binding.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "12c2d0ef6e8d32672cd739e3b96b085ee016e8b2", "filename": "src/test/compile-fail/borrowck-pat-reassign-sometimes-binding.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "34031aa70d6421ce395a25eb0d1db9a346a419ed", "filename": "src/test/compile-fail/borrowck-unchecked-with-borrow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "5468a46a6a749e80ca616bede27f46a97ff04712", "filename": "src/test/compile-fail/deref-non-pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fderef-non-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fderef-non-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderef-non-pointer.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "4ac885e5b1010ed477fdb5807ac07a31cfa6728e", "filename": "src/test/compile-fail/issue-1193.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fissue-1193.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fissue-1193.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1193.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "f5639a887f06b960f2d1e7e004426d71725cc91d", "filename": "src/test/compile-fail/issue-2111.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "376426bb82e4c2021790e01793e24ff1e46caff5", "filename": "src/test/compile-fail/issue-2848.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fissue-2848.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fissue-2848.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2848.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "6085fc9fe8f3587697de2092698b91c4c17cbcf6", "filename": "src/test/compile-fail/issue-2849.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fissue-2849.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fissue-2849.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2849.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "f5aa30c1416a996a27f0ddc57dbae1b04ce6549a", "filename": "src/test/compile-fail/issue-3038.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fissue-3038.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fissue-3038.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3038.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "e1803b0248a5adad98aaafcc9b067db4ffe11a45", "filename": "src/test/compile-fail/liveness-missing-ret2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "4f9e62e0502b799a7591e71524ff6c563f0714c7", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "dea250a734c5df04f0f9af661cf1f8551358a76b", "filename": "src/test/compile-fail/non-exhaustive-match-nested.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "e712406ba19f64b1bcf6582f9fc5b8a8c5649cc0", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "207bbd91cc5245e0b6176022efb925c2a44cdcf2", "filename": "src/test/compile-fail/occurs-check-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Foccurs-check-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Foccurs-check-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check-3.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "37d194cbd509387a2df4539dece5142143fc5e77", "filename": "src/test/compile-fail/or-patter-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2For-patter-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2For-patter-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2For-patter-mismatch.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "1dee20e0ef656164be0e0efaa5114b9e1dc2d8a9", "filename": "src/test/compile-fail/pattern-tyvar-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "2622dadc040f9b533e7071a169b75b295700c1cf", "filename": "src/test/compile-fail/pattern-tyvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "0702618c68c5fdc0b5f7daf1064d2cd559b32d39", "filename": "src/test/compile-fail/regions-creating-enums.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "1865fe6aff989b878c1c58b75c576d36428c6650", "filename": "src/test/compile-fail/unreachable-arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "14a8629ab72e090284ecfa3d4826bc39d47e7c23", "filename": "src/test/pretty/block-disambig.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-disambig.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "1f9d68cc8a2666a089fd04d54d43759680dad5d6", "filename": "src/test/pretty/unary-op-disambig.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fpretty%2Funary-op-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Fpretty%2Funary-op-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Funary-op-disambig.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "08320af9775b0bbe4576f868a19fed4370dac276", "filename": "src/test/run-fail/alt-bot-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "ab444a8273e050ec5c9ef56b6f269b04e2ba803c", "filename": "src/test/run-fail/alt-disc-bot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-fail%2Falt-disc-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-fail%2Falt-disc-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Falt-disc-bot.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "3a3c4c5a0a8bbb31761c81293a3cd3e3e7ed13a0", "filename": "src/test/run-fail/alt-wildcards.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-fail%2Falt-wildcards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-fail%2Falt-wildcards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Falt-wildcards.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "f6d3779b9f00af6a30a6e0d13e8dc5b8c8b425ff", "filename": "src/test/run-fail/expr-alt-fail-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-fail%2Fexpr-alt-fail-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-fail%2Fexpr-alt-fail-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-alt-fail-fn.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "3a70b690755039c93bf1652f3cbf61bd3158ac58", "filename": "src/test/run-fail/expr-alt-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-fail%2Fexpr-alt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-fail%2Fexpr-alt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-alt-fail.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "026af3a2f65ace95f4f43704371525dc8bf3d322", "filename": "src/test/run-fail/issue-2156.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-fail%2Fissue-2156.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-fail%2Fissue-2156.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2156.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "d5f013a42b6e470ec5cad2e9705938d414aa22bc", "filename": "src/test/run-fail/unwind-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-fail%2Funwind-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-fail%2Funwind-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-alt.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "cbf1519dc3416f1d332edcf2d072313192e942f0", "filename": "src/test/run-pass/alt-bot-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-bot-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-bot-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-bot-2.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "7162bf69aa52c8ab1fbfea4b0f1edbfef98e75ae", "filename": "src/test/run-pass/alt-bot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-bot.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "796a73a0204f1dfce55f9e4c7a480ef9f4770ccc", "filename": "src/test/run-pass/alt-implicit-copy-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "355e678d3a33bbffa0f49ec94f41ef71e2ff6be0", "filename": "src/test/run-pass/alt-implicit-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-implicit-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-implicit-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-implicit-copy.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "2d4078ced04f1227eadc471dd3488ddb9111c078", "filename": "src/test/run-pass/alt-join.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-join.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "aa9e9f18481697817743bae7caf92287689677f1", "filename": "src/test/run-pass/alt-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-path.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "92366e54b308fa11855b46a7d7ca55a7804cdd79", "filename": "src/test/run-pass/alt-pattern-drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "bc1f788abc01eb19b45f8bec5655b0106dcf95fb", "filename": "src/test/run-pass/alt-pattern-lit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "badad32ce283715df9b36af2f5a492a6991d74d9", "filename": "src/test/run-pass/alt-pattern-no-type-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-pattern-no-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-pattern-no-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-no-type-params.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "e4ca776bb610c7bad94e51a6004cacd0b0bf6d07", "filename": "src/test/run-pass/alt-pattern-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-pattern-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-pattern-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-simple.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "358b8d64e6c59d46569f9bb555eb07ee16481e69", "filename": "src/test/run-pass/alt-phi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-phi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-phi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-phi.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "75ca1dd5e52abb94d550e3c12a358d6dcc4a80b9", "filename": "src/test/run-pass/alt-range.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-range.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "4693635458df391370a842b146a9054ad6d5c740", "filename": "src/test/run-pass/alt-str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-str.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "4b8cdce110ed5b9328a1ec7743d49139027c66d6", "filename": "src/test/run-pass/alt-tag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-tag.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "b907afa1e8de6f78d55421efee94349f8bb0ea6e", "filename": "src/test/run-pass/alt-unique-bind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "50c03e71be29b41ec22cc26e9cea6f2d2fe0b8ae", "filename": "src/test/run-pass/alt-with-ret-arm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "d2df3b2dab3d411b237af2aa1f3d6d89bfbaf318", "filename": "src/test/run-pass/binary-minus-without-space.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "685f68c61ad04d74b4ac3189f385ec64340bace2", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "bbc2abf51af18ad2e4ea4441d020391269b56d69", "filename": "src/test/run-pass/borrowck-pat-reassign-no-binding.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "87b4fd59e5f1d4d0b03c257570b749e1b86fa086", "filename": "src/test/run-pass/borrowck-preserve-box-in-arm-not-taken.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "99b446ce315346418172b2786f23e9ab7712ce27", "filename": "src/test/run-pass/borrowck-preserve-box-in-discr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "7a37432db744fdf38f2207a4c0175eb812b9c9bf", "filename": "src/test/run-pass/borrowck-preserve-box-in-pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "f8bf02a77037c6a12aee6383006c771eebd68fca", "filename": "src/test/run-pass/borrowck-preserve-box-sometimes-needed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-sometimes-needed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-sometimes-needed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-sometimes-needed.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "fde259046a759f336df1381e1e48803cd83a437a", "filename": "src/test/run-pass/borrowck-univariant-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "faf3ff73b014ff1f0a55a9b7eac795fb9dcc2d83", "filename": "src/test/run-pass/box-pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fbox-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fbox-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-pattern.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "175c5f9936a48877be269b6d48888988e38a77a4", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "3b9d41fc82ac15683f3b0bc22436d699a6186394", "filename": "src/test/run-pass/drop-on-empty-block-exit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fdrop-on-empty-block-exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fdrop-on-empty-block-exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-on-empty-block-exit.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "8930f113431ee3752f4a023c282fa0e671c36f26", "filename": "src/test/run-pass/expr-alt-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "a38464f6d0af48185366d444dde625dd532cfd5e", "filename": "src/test/run-pass/expr-alt-fail-all.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-fail-all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-fail-all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-fail-all.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "5635a660f42f14c6d5ed688cf5131047c1912150", "filename": "src/test/run-pass/expr-alt-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-fail.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "f3f9dee2ff4cf4302b9e5f24cffe12acbe7ada00", "filename": "src/test/run-pass/expr-alt-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "e03c196c289df593f4bdf0dbda4694a83110201a", "filename": "src/test/run-pass/expr-alt-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "5168fd5ca8094acfb67597aa5cdfa36263491e18", "filename": "src/test/run-pass/expr-alt-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "e1475373dc2aa691643823d991ac755d527ed65c", "filename": "src/test/run-pass/expr-alt-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "98536b1afe1cbbbffa4bcdce2e4f1da1717acd26", "filename": "src/test/run-pass/expr-alt-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "2bfef283f9de51144a840214677db471a27a9351", "filename": "src/test/run-pass/expr-alt-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "58a88bee1d36d685302784ed20b1e5531636330b", "filename": "src/test/run-pass/expr-alt-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-unique.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "2e855ce36fa571136e993741c0138af87b9ea27c", "filename": "src/test/run-pass/expr-alt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "1148d145ba007a9948860a6f5ef40d490df2a6fe", "filename": "src/test/run-pass/expr-empty-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-empty-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-empty-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-empty-ret.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "8d38e5d2941d8012756601082ce5dc96b18531e0", "filename": "src/test/run-pass/expr-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-fn.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "68013a41072a9c11fff30374cc55ac5fc87e2038", "filename": "src/test/run-pass/generic-tag-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "237c8c7f844a566665c37b7b2aa61aaa46e0318d", "filename": "src/test/run-pass/generic-tag-values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "a34fa14860db28051a473bdb41a71279c5322777", "filename": "src/test/run-pass/guards.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fguards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fguards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fguards.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "e4fc8c1650faa9ef236cb37777fb4d4f747cbdb6", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "ae9c27d7880e8acc58fbc85dcd236ca96391dfa2", "filename": "src/test/run-pass/inferred-suffix-in-pattern-range.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Finferred-suffix-in-pattern-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Finferred-suffix-in-pattern-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finferred-suffix-in-pattern-range.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "4c1f703733d599eef2785b67d1637bc185f5d1cb", "filename": "src/test/run-pass/issue-1701.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fissue-1701.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fissue-1701.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1701.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "8fb85a7d11e537f5cf0b738379d6195c86654a54", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "dbaa37abacda4ed36042b46a19087a5b9e187506", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "a7ae3a55000194cd62e1738cfd858c3b9a50e603", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "a314bf4856b2f3c2314c1c9a88a39841aa7ddf03", "filename": "src/test/run-pass/issue-687.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fissue-687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fissue-687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-687.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "c7d48d95108e7f5651f20cedc58a0465f9d24733", "filename": "src/test/run-pass/keyword-changes-2012-07-31.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fkeyword-changes-2012-07-31.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fkeyword-changes-2012-07-31.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkeyword-changes-2012-07-31.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "3a3bfa4f515eb8a3461f427339f6e8012fbdbdc5", "filename": "src/test/run-pass/leaky_comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fleaky_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fleaky_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fleaky_comm.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "cbaa9182dc54872e57addc35b39e4d215aa0269c", "filename": "src/test/run-pass/macro-interpolation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fmacro-interpolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fmacro-interpolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-interpolation.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "832cca5c4f18b34c3f0976d4af71223eef2cd7f4", "filename": "src/test/run-pass/module-polymorphism4-files/cat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Fcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Fcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Fcat.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "1e611804f9f93be159579e7ab25d5313b3b2583b", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "38661bb84b2d62f4ddfaee00fb890f5d91aed3b6", "filename": "src/test/run-pass/negative.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fnegative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fnegative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnegative.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "ff0f0228a6396e16587ef397913947695351e872", "filename": "src/test/run-pass/nested-alts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fnested-alts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fnested-alts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-alts.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "51d7b7d453897949d38f013f98592115716ac377", "filename": "src/test/run-pass/nested-exhaustive-alt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fnested-exhaustive-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fnested-exhaustive-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-exhaustive-alt.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}, {"sha": "ae901d1f9f1e7535a8d36e6e39633d50059bed34", "filename": "src/test/run-pass/nested-pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fnested-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025d86624de982cdab7e6b13600fec1499c02b56/src%2Ftest%2Frun-pass%2Fnested-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-pattern.rs?ref=025d86624de982cdab7e6b13600fec1499c02b56"}]}