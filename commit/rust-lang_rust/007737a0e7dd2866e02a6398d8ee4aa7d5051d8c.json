{"sha": "007737a0e7dd2866e02a6398d8ee4aa7d5051d8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNzczN2EwZTdkZDI4NjZlMDJhNjM5OGQ4ZWU0YWE3ZDUwNTFkOGM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-06T11:33:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-06T11:33:37Z"}, "message": "Merge #1779\n\n1779: minor r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "832c18b90aee7315384326be537aeb415cb5c4e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/832c18b90aee7315384326be537aeb415cb5c4e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/007737a0e7dd2866e02a6398d8ee4aa7d5051d8c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdckQRCRBK7hj4Ov3rIwAAdHIIAD+ZOrh4MklOzgyyiAvyJYjK\nfSYmAQZmaU/1vVfkyv1iY4hmC5V2NwMxiFEiLF8GqsObTOxaeBxri5KquJa0lifW\nTeYH6aApibURbNtHVF+ES9ic6gzl95jAU7B5nLGD57QJWJpRG15lXcEnyAP2OUbA\nHLPQYQ0CkZq4THc2ZZGRQMO8fKRYj7HpyUSKUaxUEcmhOA4VKOhsDx+hLuR8xSK8\nqlMOHx0LN/RGfGMO4QiYrSftv3bad76FBNrENcJQqdA8l+m4GrwMwJYSrlKSl/HO\nQlIGTTIDH2XMJriyLwXR8H4iTuDo0/l/TV1zvG8ceMotxS3hcJ9cypkvT0W+tu0=\n=YPu+\n-----END PGP SIGNATURE-----\n", "payload": "tree 832c18b90aee7315384326be537aeb415cb5c4e1\nparent 2015e8b4d15c8be6c8fd735b0c08ccbbe24fb934\nparent f477f2516a0fc5cf040f1f19608c0239a5ebf868\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1567769617 +0000\ncommitter GitHub <noreply@github.com> 1567769617 +0000\n\nMerge #1779\n\n1779: minor r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/007737a0e7dd2866e02a6398d8ee4aa7d5051d8c", "html_url": "https://github.com/rust-lang/rust/commit/007737a0e7dd2866e02a6398d8ee4aa7d5051d8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/007737a0e7dd2866e02a6398d8ee4aa7d5051d8c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2015e8b4d15c8be6c8fd735b0c08ccbbe24fb934", "url": "https://api.github.com/repos/rust-lang/rust/commits/2015e8b4d15c8be6c8fd735b0c08ccbbe24fb934", "html_url": "https://github.com/rust-lang/rust/commit/2015e8b4d15c8be6c8fd735b0c08ccbbe24fb934"}, {"sha": "f477f2516a0fc5cf040f1f19608c0239a5ebf868", "url": "https://api.github.com/repos/rust-lang/rust/commits/f477f2516a0fc5cf040f1f19608c0239a5ebf868", "html_url": "https://github.com/rust-lang/rust/commit/f477f2516a0fc5cf040f1f19608c0239a5ebf868"}], "stats": {"total": 100, "additions": 51, "deletions": 49}, "files": [{"sha": "fe90879b62215f02f7b7596bb516e681cb1a051a", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/007737a0e7dd2866e02a6398d8ee4aa7d5051d8c/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007737a0e7dd2866e02a6398d8ee4aa7d5051d8c/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=007737a0e7dd2866e02a6398d8ee4aa7d5051d8c", "patch": "@@ -1,51 +1,51 @@\n-/// This module implements import-resolution/macro expansion algorithm.\n-///\n-/// The result of this module is `CrateDefMap`: a data structure which contains:\n-///\n-///   * a tree of modules for the crate\n-///   * for each module, a set of items visible in the module (directly declared\n-///     or imported)\n-///\n-/// Note that `CrateDefMap` contains fully macro expanded code.\n-///\n-/// Computing `CrateDefMap` can be partitioned into several logically\n-/// independent \"phases\". The phases are mutually recursive though, there's no\n-/// strict ordering.\n-///\n-/// ## Collecting RawItems\n-///\n-///  This happens in the `raw` module, which parses a single source file into a\n-///  set of top-level items. Nested imports are desugared to flat imports in\n-///  this phase. Macro calls are represented as a triple of (Path, Option<Name>,\n-///  TokenTree).\n-///\n-/// ## Collecting Modules\n-///\n-/// This happens in the `collector` module. In this phase, we recursively walk\n-/// tree of modules, collect raw items from submodules, populate module scopes\n-/// with defined items (so, we assign item ids in this phase) and record the set\n-/// of unresolved imports and macros.\n-///\n-/// While we walk tree of modules, we also record macro_rules definitions and\n-/// expand calls to macro_rules defined macros.\n-///\n-/// ## Resolving Imports\n-///\n-/// We maintain a list of currently unresolved imports. On every iteration, we\n-/// try to resolve some imports from this list. If the import is resolved, we\n-/// record it, by adding an item to current module scope and, if necessary, by\n-/// recursively populating glob imports.\n-///\n-/// ## Resolving Macros\n-///\n-/// macro_rules from the same crate use a global mutable namespace. We expand\n-/// them immediately, when we collect modules.\n-///\n-/// Macros from other crates (including proc-macros) can be used with\n-/// `foo::bar!` syntax. We handle them similarly to imports. There's a list of\n-/// unexpanded macros. On every iteration, we try to resolve each macro call\n-/// path and, upon success, we run macro expansion and \"collect module\" phase\n-/// on the result\n+//! This module implements import-resolution/macro expansion algorithm.\n+//!\n+//! The result of this module is `CrateDefMap`: a data structure which contains:\n+//!\n+//!   * a tree of modules for the crate\n+//!   * for each module, a set of items visible in the module (directly declared\n+//!     or imported)\n+//!\n+//! Note that `CrateDefMap` contains fully macro expanded code.\n+//!\n+//! Computing `CrateDefMap` can be partitioned into several logically\n+//! independent \"phases\". The phases are mutually recursive though, there's no\n+//! strict ordering.\n+//!\n+//! ## Collecting RawItems\n+//!\n+//!  This happens in the `raw` module, which parses a single source file into a\n+//!  set of top-level items. Nested imports are desugared to flat imports in\n+//!  this phase. Macro calls are represented as a triple of (Path, Option<Name>,\n+//!  TokenTree).\n+//!\n+//! ## Collecting Modules\n+//!\n+//! This happens in the `collector` module. In this phase, we recursively walk\n+//! tree of modules, collect raw items from submodules, populate module scopes\n+//! with defined items (so, we assign item ids in this phase) and record the set\n+//! of unresolved imports and macros.\n+//!\n+//! While we walk tree of modules, we also record macro_rules definitions and\n+//! expand calls to macro_rules defined macros.\n+//!\n+//! ## Resolving Imports\n+//!\n+//! We maintain a list of currently unresolved imports. On every iteration, we\n+//! try to resolve some imports from this list. If the import is resolved, we\n+//! record it, by adding an item to current module scope and, if necessary, by\n+//! recursively populating glob imports.\n+//!\n+//! ## Resolving Macros\n+//!\n+//! macro_rules from the same crate use a global mutable namespace. We expand\n+//! them immediately, when we collect modules.\n+//!\n+//! Macros from other crates (including proc-macros) can be used with\n+//! `foo::bar!` syntax. We handle them similarly to imports. There's a list of\n+//! unexpanded macros. On every iteration, we try to resolve each macro call\n+//! path and, upon success, we run macro expansion and \"collect module\" phase\n+//! on the result\n \n mod per_ns;\n mod raw;"}, {"sha": "918c9591f537c9e48b772f7da433ae388a008aad", "filename": "crates/ra_hir/src/nameres/mod_resolution.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/007737a0e7dd2866e02a6398d8ee4aa7d5051d8c/crates%2Fra_hir%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007737a0e7dd2866e02a6398d8ee4aa7d5051d8c/crates%2Fra_hir%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=007737a0e7dd2866e02a6398d8ee4aa7d5051d8c", "patch": "@@ -1,3 +1,5 @@\n+//! This module resolves `mod foo;` declaration to file.\n+\n use std::{borrow::Cow, sync::Arc};\n \n use ra_db::{FileId, SourceRoot};\n@@ -77,7 +79,7 @@ pub(super) fn resolve_submodule(\n             let path = dir_path.join(file_path.as_ref()).normalize();\n             ResolutionMode::OutOfLine(OutOfLineMode::WithAttributePath(path))\n         }\n-        _ => {\n+        (None, None) => {\n             let is_dir_owner = is_root || mod_name == \"mod\";\n             if is_dir_owner {\n                 let file_mod = dir_path.join(format!(\"{}.rs\", name));"}]}