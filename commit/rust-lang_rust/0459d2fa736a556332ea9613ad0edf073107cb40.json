{"sha": "0459d2fa736a556332ea9613ad0edf073107cb40", "node_id": "C_kwDOAAsO6NoAKDA0NTlkMmZhNzM2YTU1NjMzMmVhOTYxM2FkMGVkZjA3MzEwN2NiNDA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-10T03:21:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-10T03:21:23Z"}, "message": "Auto merge of #100346 - matthiaskrgr:rollup-6rljn4p, r=matthiaskrgr\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #98775 (rustdoc: improve scroll locking in the rustdoc mobile sidebars)\n - #99479 (rustdoc-json: Remove doc FIXME for Import::id and explain)\n - #100040 (Error on broken pipe but do not backtrace or ICE)\n - #100072 (linker-plugin-lto.md: Correct the name of example c file)\n - #100098 (Some \"this expression has a field\"-related fixes)\n - #100226 (Do not manually craft a span pointing inside a multibyte character.)\n - #100240 (Fail gracefully when const pattern is not structural match.)\n - #100256 (Add some high-level docs to `FnCtxt` and `ItemCtxt`)\n - #100261 (Set tainted errors bit before emitting coerce suggestions.)\n - #100275 (also update anyhow in codegen_cranelift)\n - #100281 (Remove more Clean trait implementations)\n - #100314 (Mention `unit-test` in MIR opt test README)\n - #100319 (Remove more Clean trait implementations)\n - #100323 ([rustdoc] Don't render impl blocks with doc comment if they only contain private items by default)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "de38d91ee5d2918effcc2104d189305a83fe0572", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de38d91ee5d2918effcc2104d189305a83fe0572"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0459d2fa736a556332ea9613ad0edf073107cb40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0459d2fa736a556332ea9613ad0edf073107cb40", "html_url": "https://github.com/rust-lang/rust/commit/0459d2fa736a556332ea9613ad0edf073107cb40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0459d2fa736a556332ea9613ad0edf073107cb40/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34a6cae28e7013ff0e640026a8e46f315426829d", "url": "https://api.github.com/repos/rust-lang/rust/commits/34a6cae28e7013ff0e640026a8e46f315426829d", "html_url": "https://github.com/rust-lang/rust/commit/34a6cae28e7013ff0e640026a8e46f315426829d"}, {"sha": "752b9a85dc4f347e52faff39fabf6c84e5425ba7", "url": "https://api.github.com/repos/rust-lang/rust/commits/752b9a85dc4f347e52faff39fabf6c84e5425ba7", "html_url": "https://github.com/rust-lang/rust/commit/752b9a85dc4f347e52faff39fabf6c84e5425ba7"}], "stats": {"total": 1109, "additions": 798, "deletions": 311}, "files": [{"sha": "402fbb16f97ee9f0acf661ef75b25739aa48d349", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -15,9 +15,9 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.56\"\n+version = \"1.0.60\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4361135be9122e0870de935d7c439aef945b9f9ddd4199a553b5270b49c82a27\"\n+checksum = \"c794e162a5eff65c72ef524dfe393eb923c354e350bb78b9c7383df13f3bc142\"\n \n [[package]]\n name = \"ar\""}, {"sha": "94639bf8e1ee4f1d122cd6bf52e382d9e79d52dd", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -1148,6 +1148,17 @@ static DEFAULT_HOOK: LazyLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send +\n     LazyLock::new(|| {\n         let hook = panic::take_hook();\n         panic::set_hook(Box::new(|info| {\n+            // If the error was caused by a broken pipe then this is not a bug.\n+            // Write the error and return immediately. See #98700.\n+            #[cfg(windows)]\n+            if let Some(msg) = info.payload().downcast_ref::<String>() {\n+                if msg.starts_with(\"failed printing to stdout: \") && msg.ends_with(\"(os error 232)\")\n+                {\n+                    early_error_no_abort(ErrorOutputType::default(), &msg);\n+                    return;\n+                }\n+            };\n+\n             // Invoke the default handler, which prints the actual panic message and optionally a backtrace\n             (*DEFAULT_HOOK)(info);\n "}, {"sha": "4e7ba1c6ce4fa126df507839d3a972868313ccec", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::ty::adjustment;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::Symbol;\n use rustc_span::symbol::{kw, sym};\n-use rustc_span::{BytePos, Span, DUMMY_SP};\n+use rustc_span::{BytePos, Span};\n \n declare_lint! {\n     /// The `unused_must_use` lint detects unused result of a type flagged as\n@@ -504,23 +504,23 @@ trait UnusedDelimLint {\n             ast::ExprKind::Block(ref block, None) if block.stmts.len() > 0 => {\n                 let start = block.stmts[0].span;\n                 let end = block.stmts[block.stmts.len() - 1].span;\n-                if value.span.from_expansion() || start.from_expansion() || end.from_expansion() {\n-                    (\n-                        value.span.with_hi(value.span.lo() + BytePos(1)),\n-                        value.span.with_lo(value.span.hi() - BytePos(1)),\n-                    )\n+                if let Some(start) = start.find_ancestor_inside(value.span)\n+                    && let Some(end) = end.find_ancestor_inside(value.span)\n+                {\n+                    Some((\n+                        value.span.with_hi(start.lo()),\n+                        value.span.with_lo(end.hi()),\n+                    ))\n                 } else {\n-                    (value.span.with_hi(start.lo()), value.span.with_lo(end.hi()))\n+                    None\n                 }\n             }\n             ast::ExprKind::Paren(ref expr) => {\n-                if value.span.from_expansion() || expr.span.from_expansion() {\n-                    (\n-                        value.span.with_hi(value.span.lo() + BytePos(1)),\n-                        value.span.with_lo(value.span.hi() - BytePos(1)),\n-                    )\n+                let expr_span = expr.span.find_ancestor_inside(value.span);\n+                if let Some(expr_span) = expr_span {\n+                    Some((value.span.with_hi(expr_span.lo()), value.span.with_lo(expr_span.hi())))\n                 } else {\n-                    (value.span.with_hi(expr.span.lo()), value.span.with_lo(expr.span.hi()))\n+                    None\n                 }\n             }\n             _ => return,\n@@ -529,36 +529,38 @@ trait UnusedDelimLint {\n             left_pos.map_or(false, |s| s >= value.span.lo()),\n             right_pos.map_or(false, |s| s <= value.span.hi()),\n         );\n-        self.emit_unused_delims(cx, spans, ctx.into(), keep_space);\n+        self.emit_unused_delims(cx, value.span, spans, ctx.into(), keep_space);\n     }\n \n     fn emit_unused_delims(\n         &self,\n         cx: &EarlyContext<'_>,\n-        spans: (Span, Span),\n+        value_span: Span,\n+        spans: Option<(Span, Span)>,\n         msg: &str,\n         keep_space: (bool, bool),\n     ) {\n-        // FIXME(flip1995): Quick and dirty fix for #70814. This should be fixed in rustdoc\n-        // properly.\n-        if spans.0 == DUMMY_SP || spans.1 == DUMMY_SP {\n-            return;\n-        }\n-\n-        cx.struct_span_lint(self.lint(), MultiSpan::from(vec![spans.0, spans.1]), |lint| {\n-            let replacement = vec![\n-                (spans.0, if keep_space.0 { \" \".into() } else { \"\".into() }),\n-                (spans.1, if keep_space.1 { \" \".into() } else { \"\".into() }),\n-            ];\n-            lint.build(fluent::lint::unused_delim)\n-                .set_arg(\"delim\", Self::DELIM_STR)\n-                .set_arg(\"item\", msg)\n-                .multipart_suggestion(\n+        let primary_span = if let Some((lo, hi)) = spans {\n+            MultiSpan::from(vec![lo, hi])\n+        } else {\n+            MultiSpan::from(value_span)\n+        };\n+        cx.struct_span_lint(self.lint(), primary_span, |lint| {\n+            let mut db = lint.build(fluent::lint::unused_delim);\n+            db.set_arg(\"delim\", Self::DELIM_STR);\n+            db.set_arg(\"item\", msg);\n+            if let Some((lo, hi)) = spans {\n+                let replacement = vec![\n+                    (lo, if keep_space.0 { \" \".into() } else { \"\".into() }),\n+                    (hi, if keep_space.1 { \" \".into() } else { \"\".into() }),\n+                ];\n+                db.multipart_suggestion(\n                     fluent::lint::suggestion,\n                     replacement,\n                     Applicability::MachineApplicable,\n-                )\n-                .emit();\n+                );\n+            }\n+            db.emit();\n         });\n     }\n \n@@ -766,15 +768,12 @@ impl UnusedParens {\n                 // Otherwise proceed with linting.\n                 _ => {}\n             }\n-            let spans = if value.span.from_expansion() || inner.span.from_expansion() {\n-                (\n-                    value.span.with_hi(value.span.lo() + BytePos(1)),\n-                    value.span.with_lo(value.span.hi() - BytePos(1)),\n-                )\n+            let spans = if let Some(inner) = inner.span.find_ancestor_inside(value.span) {\n+                Some((value.span.with_hi(inner.lo()), value.span.with_lo(inner.hi())))\n             } else {\n-                (value.span.with_hi(inner.span.lo()), value.span.with_lo(inner.span.hi()))\n+                None\n             };\n-            self.emit_unused_delims(cx, spans, \"pattern\", (false, false));\n+            self.emit_unused_delims(cx, value.span, spans, \"pattern\", (false, false));\n         }\n     }\n }\n@@ -879,15 +878,12 @@ impl EarlyLintPass for UnusedParens {\n                     );\n                 }\n                 _ => {\n-                    let spans = if ty.span.from_expansion() || r.span.from_expansion() {\n-                        (\n-                            ty.span.with_hi(ty.span.lo() + BytePos(1)),\n-                            ty.span.with_lo(ty.span.hi() - BytePos(1)),\n-                        )\n+                    let spans = if let Some(r) = r.span.find_ancestor_inside(ty.span) {\n+                        Some((ty.span.with_hi(r.lo()), ty.span.with_lo(r.hi())))\n                     } else {\n-                        (ty.span.with_hi(r.span.lo()), ty.span.with_lo(r.span.hi()))\n+                        None\n                     };\n-                    self.emit_unused_delims(cx, spans, \"type\", (false, false));\n+                    self.emit_unused_delims(cx, ty.span, spans, \"type\", (false, false));\n                 }\n             }\n         }"}, {"sha": "f2045ac19cac42920293ecc3b71d865cf5cb29a9", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -168,7 +168,12 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         // once indirect_structural_match is a full fledged error, this\n         // level of indirection can be eliminated\n \n-        let inlined_const_as_pat = self.recur(cv, mir_structural_match_violation).unwrap();\n+        let inlined_const_as_pat =\n+            self.recur(cv, mir_structural_match_violation).unwrap_or_else(|_| Pat {\n+                span: self.span,\n+                ty: cv.ty(),\n+                kind: Box::new(PatKind::Constant { value: cv }),\n+            });\n \n         if self.include_lint_checks && !self.saw_const_match_error.get() {\n             // If we were able to successfully convert the const to some pat,"}, {"sha": "49dc5532abdc97d762b135cc9fdcb4e88436fce3", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -1479,6 +1479,10 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 }\n             }\n             Err(coercion_error) => {\n+                // Mark that we've failed to coerce the types here to suppress\n+                // any superfluous errors we might encounter while trying to\n+                // emit or provide suggestions on how to fix the initial error.\n+                fcx.set_tainted_by_errors();\n                 let (expected, found) = if label_expression_as_expected {\n                     // In the case where this is a \"forced unit\", like\n                     // `break`, we want to call the `()` \"expected\""}, {"sha": "a685add7f56a61903ab96c022c45e16d1bfdcbed", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -2526,15 +2526,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         // try to add a suggestion in case the field is a nested field of a field of the Adt\n-        if let Some((fields, substs)) = self.get_field_candidates(span, expr_t) {\n-            for candidate_field in fields.iter() {\n+        let mod_id = self.tcx.parent_module(id).to_def_id();\n+        if let Some((fields, substs)) =\n+            self.get_field_candidates_considering_privacy(span, expr_t, mod_id)\n+        {\n+            for candidate_field in fields {\n                 if let Some(mut field_path) = self.check_for_nested_field_satisfying(\n                     span,\n                     &|candidate_field, _| candidate_field.ident(self.tcx()) == field,\n                     candidate_field,\n                     substs,\n                     vec![],\n-                    self.tcx.parent_module(id).to_def_id(),\n+                    mod_id,\n                 ) {\n                     // field_path includes `field` that we're looking for, so pop it.\n                     field_path.pop();\n@@ -2558,22 +2561,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err\n     }\n \n-    pub(crate) fn get_field_candidates(\n+    pub(crate) fn get_field_candidates_considering_privacy(\n         &self,\n         span: Span,\n-        base_t: Ty<'tcx>,\n-    ) -> Option<(&[ty::FieldDef], SubstsRef<'tcx>)> {\n-        debug!(\"get_field_candidates(span: {:?}, base_t: {:?}\", span, base_t);\n+        base_ty: Ty<'tcx>,\n+        mod_id: DefId,\n+    ) -> Option<(impl Iterator<Item = &'tcx ty::FieldDef> + 'tcx, SubstsRef<'tcx>)> {\n+        debug!(\"get_field_candidates(span: {:?}, base_t: {:?}\", span, base_ty);\n \n-        for (base_t, _) in self.autoderef(span, base_t) {\n+        for (base_t, _) in self.autoderef(span, base_ty) {\n             match base_t.kind() {\n                 ty::Adt(base_def, substs) if !base_def.is_enum() => {\n+                    let tcx = self.tcx;\n                     let fields = &base_def.non_enum_variant().fields;\n-                    // For compile-time reasons put a limit on number of fields we search\n-                    if fields.len() > 100 {\n-                        return None;\n+                    // Some struct, e.g. some that impl `Deref`, have all private fields\n+                    // because you're expected to deref them to access the _real_ fields.\n+                    // This, for example, will help us suggest accessing a field through a `Box<T>`.\n+                    if fields.iter().all(|field| !field.vis.is_accessible_from(mod_id, tcx)) {\n+                        continue;\n                     }\n-                    return Some((fields, substs));\n+                    return Some((\n+                        fields\n+                            .iter()\n+                            .filter(move |field| field.vis.is_accessible_from(mod_id, tcx))\n+                            // For compile-time reasons put a limit on number of fields we search\n+                            .take(100),\n+                        substs,\n+                    ));\n                 }\n                 _ => {}\n             }\n@@ -2590,7 +2604,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         candidate_field: &ty::FieldDef,\n         subst: SubstsRef<'tcx>,\n         mut field_path: Vec<Ident>,\n-        id: DefId,\n+        mod_id: DefId,\n     ) -> Option<Vec<Ident>> {\n         debug!(\n             \"check_for_nested_field_satisfying(span: {:?}, candidate_field: {:?}, field_path: {:?}\",\n@@ -2602,24 +2616,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // up to a depth of three\n             None\n         } else {\n-            // recursively search fields of `candidate_field` if it's a ty::Adt\n             field_path.push(candidate_field.ident(self.tcx).normalize_to_macros_2_0());\n             let field_ty = candidate_field.ty(self.tcx, subst);\n-            if let Some((nested_fields, subst)) = self.get_field_candidates(span, field_ty) {\n-                for field in nested_fields.iter() {\n-                    if field.vis.is_accessible_from(id, self.tcx) {\n-                        if matches(candidate_field, field_ty) {\n-                            return Some(field_path);\n-                        } else if let Some(field_path) = self.check_for_nested_field_satisfying(\n-                            span,\n-                            matches,\n-                            field,\n-                            subst,\n-                            field_path.clone(),\n-                            id,\n-                        ) {\n-                            return Some(field_path);\n-                        }\n+            if matches(candidate_field, field_ty) {\n+                return Some(field_path);\n+            } else if let Some((nested_fields, subst)) =\n+                self.get_field_candidates_considering_privacy(span, field_ty, mod_id)\n+            {\n+                // recursively search fields of `candidate_field` if it's a ty::Adt\n+                for field in nested_fields {\n+                    if let Some(field_path) = self.check_for_nested_field_satisfying(\n+                        span,\n+                        matches,\n+                        field,\n+                        subst,\n+                        field_path.clone(),\n+                        mod_id,\n+                    ) {\n+                        return Some(field_path);\n                     }\n                 }\n             }"}, {"sha": "e008d50aa514a44b3eaf892010bb8ea3c6dc0372", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -26,6 +26,17 @@ use rustc_trait_selection::traits::{ObligationCause, ObligationCauseCode};\n use std::cell::{Cell, RefCell};\n use std::ops::Deref;\n \n+/// The `FnCtxt` stores type-checking context needed to type-check bodies of\n+/// functions, closures, and `const`s, including performing type inference\n+/// with [`InferCtxt`].\n+///\n+/// This is in contrast to [`ItemCtxt`], which is used to type-check item *signatures*\n+/// and thus does not perform type inference.\n+///\n+/// See [`ItemCtxt`]'s docs for more.\n+///\n+/// [`ItemCtxt`]: crate::collect::ItemCtxt\n+/// [`InferCtxt`]: infer::InferCtxt\n pub struct FnCtxt<'a, 'tcx> {\n     pub(super) body_id: hir::HirId,\n "}, {"sha": "f73d0fbb277163acfa2541162a924b2ef1e9fe6c", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -1000,7 +1000,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     label_span_not_found(&mut err);\n                 }\n \n-                self.check_for_field_method(&mut err, source, span, actual, item_name);\n+                // Don't suggest (for example) `expr.field.method()` if `expr.method()`\n+                // doesn't exist due to unsatisfied predicates.\n+                if unsatisfied_predicates.is_empty() {\n+                    self.check_for_field_method(&mut err, source, span, actual, item_name);\n+                }\n \n                 self.check_for_unwrap_self(&mut err, source, span, actual, item_name);\n \n@@ -1334,10 +1338,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         item_name: Ident,\n     ) {\n         if let SelfSource::MethodCall(expr) = source\n-            && let Some((fields, substs)) = self.get_field_candidates(span, actual)\n+            && let mod_id = self.tcx.parent_module(expr.hir_id).to_def_id()\n+            && let Some((fields, substs)) = self.get_field_candidates_considering_privacy(span, actual, mod_id)\n         {\n             let call_expr = self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n-            for candidate_field in fields.iter() {\n+            for candidate_field in fields {\n                 if let Some(field_path) = self.check_for_nested_field_satisfying(\n                     span,\n                     &|_, field_ty| {\n@@ -1353,7 +1358,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     candidate_field,\n                     substs,\n                     vec![],\n-                    self.tcx.parent_module(expr.hir_id).to_def_id(),\n+                    mod_id,\n                 ) {\n                     let field_path_str = field_path\n                         .iter()"}, {"sha": "e7c5ecc60ec78c7a01cafd3cee3d8aad1f38839c", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -94,7 +94,27 @@ pub fn provide(providers: &mut Providers) {\n ///////////////////////////////////////////////////////////////////////////\n \n /// Context specific to some particular item. This is what implements\n-/// `AstConv`. It has information about the predicates that are defined\n+/// [`AstConv`].\n+///\n+/// # `ItemCtxt` vs `FnCtxt`\n+///\n+/// `ItemCtxt` is primarily used to type-check item signatures and lower them\n+/// from HIR to their [`ty::Ty`] representation, which is exposed using [`AstConv`].\n+/// It's also used for the bodies of items like structs where the body (the fields)\n+/// are just signatures.\n+///\n+/// This is in contrast to [`FnCtxt`], which is used to type-check bodies of\n+/// functions, closures, and `const`s -- anywhere that expressions and statements show up.\n+///\n+/// An important thing to note is that `ItemCtxt` does no inference -- it has no [`InferCtxt`] --\n+/// while `FnCtxt` does do inference.\n+///\n+/// [`FnCtxt`]: crate::check::FnCtxt\n+/// [`InferCtxt`]: rustc_infer::infer::InferCtxt\n+///\n+/// # Trait predicates\n+///\n+/// `ItemCtxt` has information about the predicates that are defined\n /// on the trait. Unfortunately, this predicate information is\n /// available in various different forms at various points in the\n /// process. So we can't just store a pointer to e.g., the AST or the"}, {"sha": "b1854b22a7cd694b92476d87ff9854dd547d7b96", "filename": "src/doc/rustc/src/linker-plugin-lto.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -30,7 +30,7 @@ Using `rustc` directly:\n # Compile the Rust staticlib\n rustc --crate-type=staticlib -Clinker-plugin-lto -Copt-level=2 ./lib.rs\n # Compile the C code with `-flto=thin`\n-clang -c -O2 -flto=thin -o main.o ./main.c\n+clang -c -O2 -flto=thin -o cmain.o ./cmain.c\n # Link everything, making sure that we use an appropriate linker\n clang -flto=thin -fuse-ld=lld -L . -l\"name-of-your-rust-lib\" -o main -O2 ./cmain.o\n ```\n@@ -41,7 +41,7 @@ Using `cargo`:\n # Compile the Rust staticlib\n RUSTFLAGS=\"-Clinker-plugin-lto\" cargo build --release\n # Compile the C code with `-flto=thin`\n-clang -c -O2 -flto=thin -o main.o ./main.c\n+clang -c -O2 -flto=thin -o cmain.o ./cmain.c\n # Link everything, making sure that we use an appropriate linker\n clang -flto=thin -fuse-ld=lld -L . -l\"name-of-your-rust-lib\" -o main -O2 ./cmain.o\n ```"}, {"sha": "4e9456ba7cb71ecd2cd8b18bc708952fce0b681f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -16,8 +16,8 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n use crate::clean::{\n-    self, clean_fn_decl_from_did_and_sig, clean_middle_field, clean_middle_ty,\n-    clean_trait_ref_with_bindings, clean_ty, clean_ty_generics, clean_variant_def,\n+    self, clean_fn_decl_from_did_and_sig, clean_generics, clean_impl_item, clean_middle_field,\n+    clean_middle_ty, clean_trait_ref_with_bindings, clean_ty, clean_ty_generics, clean_variant_def,\n     clean_visibility, utils, Attributes, AttributesExt, Clean, ImplKind, ItemId, Type, Visibility,\n };\n use crate::core::DocContext;\n@@ -426,9 +426,9 @@ pub(crate) fn build_impl(\n                         true\n                     }\n                 })\n-                .map(|item| item.clean(cx))\n+                .map(|item| clean_impl_item(item, cx))\n                 .collect::<Vec<_>>(),\n-            impl_.generics.clean(cx),\n+            clean_generics(impl_.generics, cx),\n         ),\n         None => (\n             tcx.associated_items(did)"}, {"sha": "402e4f29860a261eab9b3a9bb74c469676d0d0c8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 162, "deletions": 166, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -48,75 +48,68 @@ pub(crate) trait Clean<'tcx, T> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> T;\n }\n \n-impl<'tcx> Clean<'tcx, Item> for DocModule<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n-        let mut items: Vec<Item> = vec![];\n-        let mut inserted = FxHashSet::default();\n-        items.extend(self.foreigns.iter().map(|(item, renamed)| {\n-            let item = clean_maybe_renamed_foreign_item(cx, item, *renamed);\n+pub(crate) fn clean_doc_module<'tcx>(doc: &DocModule<'tcx>, cx: &mut DocContext<'tcx>) -> Item {\n+    let mut items: Vec<Item> = vec![];\n+    let mut inserted = FxHashSet::default();\n+    items.extend(doc.foreigns.iter().map(|(item, renamed)| {\n+        let item = clean_maybe_renamed_foreign_item(cx, item, *renamed);\n+        if let Some(name) = item.name {\n+            inserted.insert((item.type_(), name));\n+        }\n+        item\n+    }));\n+    items.extend(doc.mods.iter().map(|x| {\n+        inserted.insert((ItemType::Module, x.name));\n+        clean_doc_module(x, cx)\n+    }));\n+\n+    // Split up imports from all other items.\n+    //\n+    // This covers the case where somebody does an import which should pull in an item,\n+    // but there's already an item with the same namespace and same name. Rust gives\n+    // priority to the not-imported one, so we should, too.\n+    items.extend(doc.items.iter().flat_map(|(item, renamed)| {\n+        // First, lower everything other than imports.\n+        if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n+            return Vec::new();\n+        }\n+        let v = clean_maybe_renamed_item(cx, item, *renamed);\n+        for item in &v {\n             if let Some(name) = item.name {\n                 inserted.insert((item.type_(), name));\n             }\n-            item\n-        }));\n-        items.extend(self.mods.iter().map(|x| {\n-            inserted.insert((ItemType::Module, x.name));\n-            x.clean(cx)\n-        }));\n-\n-        // Split up imports from all other items.\n-        //\n-        // This covers the case where somebody does an import which should pull in an item,\n-        // but there's already an item with the same namespace and same name. Rust gives\n-        // priority to the not-imported one, so we should, too.\n-        items.extend(self.items.iter().flat_map(|(item, renamed)| {\n-            // First, lower everything other than imports.\n-            if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n-                return Vec::new();\n-            }\n-            let v = clean_maybe_renamed_item(cx, item, *renamed);\n-            for item in &v {\n-                if let Some(name) = item.name {\n-                    inserted.insert((item.type_(), name));\n-                }\n-            }\n-            v\n-        }));\n-        items.extend(self.items.iter().flat_map(|(item, renamed)| {\n-            // Now we actually lower the imports, skipping everything else.\n-            if let hir::ItemKind::Use(path, hir::UseKind::Glob) = item.kind {\n-                let name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));\n-                clean_use_statement(item, name, path, hir::UseKind::Glob, cx, &mut inserted)\n-            } else {\n-                // skip everything else\n-                Vec::new()\n-            }\n-        }));\n-\n-        // determine if we should display the inner contents or\n-        // the outer `mod` item for the source code.\n-\n-        let span = Span::new({\n-            let where_outer = self.where_outer(cx.tcx);\n-            let sm = cx.sess().source_map();\n-            let outer = sm.lookup_char_pos(where_outer.lo());\n-            let inner = sm.lookup_char_pos(self.where_inner.lo());\n-            if outer.file.start_pos == inner.file.start_pos {\n-                // mod foo { ... }\n-                where_outer\n-            } else {\n-                // mod foo; (and a separate SourceFile for the contents)\n-                self.where_inner\n-            }\n-        });\n+        }\n+        v\n+    }));\n+    items.extend(doc.items.iter().flat_map(|(item, renamed)| {\n+        // Now we actually lower the imports, skipping everything else.\n+        if let hir::ItemKind::Use(path, hir::UseKind::Glob) = item.kind {\n+            let name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));\n+            clean_use_statement(item, name, path, hir::UseKind::Glob, cx, &mut inserted)\n+        } else {\n+            // skip everything else\n+            Vec::new()\n+        }\n+    }));\n+\n+    // determine if we should display the inner contents or\n+    // the outer `mod` item for the source code.\n+\n+    let span = Span::new({\n+        let where_outer = doc.where_outer(cx.tcx);\n+        let sm = cx.sess().source_map();\n+        let outer = sm.lookup_char_pos(where_outer.lo());\n+        let inner = sm.lookup_char_pos(doc.where_inner.lo());\n+        if outer.file.start_pos == inner.file.start_pos {\n+            // mod foo { ... }\n+            where_outer\n+        } else {\n+            // mod foo; (and a separate SourceFile for the contents)\n+            doc.where_inner\n+        }\n+    });\n \n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            ModuleItem(Module { items, span }),\n-            cx,\n-        )\n-    }\n+    Item::from_hir_id_and_parts(doc.id, Some(doc.name), ModuleItem(Module { items, span }), cx)\n }\n \n fn clean_generic_bound<'tcx>(\n@@ -568,69 +561,68 @@ fn is_elided_lifetime(param: &hir::GenericParam<'_>) -> bool {\n     matches!(param.kind, hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Elided })\n }\n \n-impl<'tcx> Clean<'tcx, Generics> for hir::Generics<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Generics {\n-        let impl_trait_params = self\n-            .params\n-            .iter()\n-            .filter(|param| is_impl_trait(param))\n-            .map(|param| {\n-                let param = clean_generic_param(cx, Some(self), param);\n-                match param.kind {\n-                    GenericParamDefKind::Lifetime { .. } => unreachable!(),\n-                    GenericParamDefKind::Type { did, ref bounds, .. } => {\n-                        cx.impl_trait_bounds.insert(did.into(), bounds.clone());\n-                    }\n-                    GenericParamDefKind::Const { .. } => unreachable!(),\n+pub(crate) fn clean_generics<'tcx>(\n+    gens: &hir::Generics<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> Generics {\n+    let impl_trait_params = gens\n+        .params\n+        .iter()\n+        .filter(|param| is_impl_trait(param))\n+        .map(|param| {\n+            let param = clean_generic_param(cx, Some(gens), param);\n+            match param.kind {\n+                GenericParamDefKind::Lifetime { .. } => unreachable!(),\n+                GenericParamDefKind::Type { did, ref bounds, .. } => {\n+                    cx.impl_trait_bounds.insert(did.into(), bounds.clone());\n                 }\n-                param\n-            })\n-            .collect::<Vec<_>>();\n+                GenericParamDefKind::Const { .. } => unreachable!(),\n+            }\n+            param\n+        })\n+        .collect::<Vec<_>>();\n \n-        let mut params = Vec::with_capacity(self.params.len());\n-        for p in self.params.iter().filter(|p| !is_impl_trait(p) && !is_elided_lifetime(p)) {\n-            let p = clean_generic_param(cx, Some(self), p);\n-            params.push(p);\n-        }\n-        params.extend(impl_trait_params);\n+    let mut params = Vec::with_capacity(gens.params.len());\n+    for p in gens.params.iter().filter(|p| !is_impl_trait(p) && !is_elided_lifetime(p)) {\n+        let p = clean_generic_param(cx, Some(gens), p);\n+        params.push(p);\n+    }\n+    params.extend(impl_trait_params);\n \n-        let mut generics = Generics {\n-            params,\n-            where_predicates: self\n-                .predicates\n-                .iter()\n-                .filter_map(|x| clean_where_predicate(x, cx))\n-                .collect(),\n-        };\n+    let mut generics = Generics {\n+        params,\n+        where_predicates: gens\n+            .predicates\n+            .iter()\n+            .filter_map(|x| clean_where_predicate(x, cx))\n+            .collect(),\n+    };\n \n-        // Some duplicates are generated for ?Sized bounds between type params and where\n-        // predicates. The point in here is to move the bounds definitions from type params\n-        // to where predicates when such cases occur.\n-        for where_pred in &mut generics.where_predicates {\n-            match *where_pred {\n-                WherePredicate::BoundPredicate {\n-                    ty: Generic(ref name), ref mut bounds, ..\n-                } => {\n-                    if bounds.is_empty() {\n-                        for param in &mut generics.params {\n-                            match param.kind {\n-                                GenericParamDefKind::Lifetime { .. } => {}\n-                                GenericParamDefKind::Type { bounds: ref mut ty_bounds, .. } => {\n-                                    if &param.name == name {\n-                                        mem::swap(bounds, ty_bounds);\n-                                        break;\n-                                    }\n+    // Some duplicates are generated for ?Sized bounds between type params and where\n+    // predicates. The point in here is to move the bounds definitions from type params\n+    // to where predicates when such cases occur.\n+    for where_pred in &mut generics.where_predicates {\n+        match *where_pred {\n+            WherePredicate::BoundPredicate { ty: Generic(ref name), ref mut bounds, .. } => {\n+                if bounds.is_empty() {\n+                    for param in &mut generics.params {\n+                        match param.kind {\n+                            GenericParamDefKind::Lifetime { .. } => {}\n+                            GenericParamDefKind::Type { bounds: ref mut ty_bounds, .. } => {\n+                                if &param.name == name {\n+                                    mem::swap(bounds, ty_bounds);\n+                                    break;\n                                 }\n-                                GenericParamDefKind::Const { .. } => {}\n                             }\n+                            GenericParamDefKind::Const { .. } => {}\n                         }\n                     }\n                 }\n-                _ => continue,\n             }\n+            _ => continue,\n         }\n-        generics\n     }\n+    generics\n }\n \n fn clean_ty_generics<'tcx>(\n@@ -896,7 +888,7 @@ fn clean_function<'tcx>(\n ) -> Box<Function> {\n     let (generics, decl) = enter_impl_trait(cx, |cx| {\n         // NOTE: generics must be cleaned before args\n-        let generics = generics.clean(cx);\n+        let generics = clean_generics(generics, cx);\n         let args = clean_args_from_types_and_body_id(cx, sig.decl.inputs, body_id);\n         let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n         (generics, decl)\n@@ -1025,15 +1017,15 @@ fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(names)) => {\n                 let (generics, decl) = enter_impl_trait(cx, |cx| {\n                     // NOTE: generics must be cleaned before args\n-                    let generics = trait_item.generics.clean(cx);\n+                    let generics = clean_generics(trait_item.generics, cx);\n                     let args = clean_args_from_types_and_names(cx, sig.decl.inputs, names);\n                     let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n                     (generics, decl)\n                 });\n                 TyMethodItem(Box::new(Function { decl, generics }))\n             }\n             hir::TraitItemKind::Type(bounds, Some(default)) => {\n-                let generics = enter_impl_trait(cx, |cx| trait_item.generics.clean(cx));\n+                let generics = enter_impl_trait(cx, |cx| clean_generics(trait_item.generics, cx));\n                 let bounds = bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect();\n                 let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, default), cx, None);\n                 AssocTypeItem(\n@@ -1046,7 +1038,7 @@ fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext\n                 )\n             }\n             hir::TraitItemKind::Type(bounds, None) => {\n-                let generics = enter_impl_trait(cx, |cx| trait_item.generics.clean(cx));\n+                let generics = enter_impl_trait(cx, |cx| clean_generics(trait_item.generics, cx));\n                 let bounds = bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect();\n                 TyAssocTypeItem(Box::new(generics), bounds)\n             }\n@@ -1058,45 +1050,46 @@ fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext\n     })\n }\n \n-impl<'tcx> Clean<'tcx, Item> for hir::ImplItem<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n-        let local_did = self.def_id.to_def_id();\n-        cx.with_param_env(local_did, |cx| {\n-            let inner = match self.kind {\n-                hir::ImplItemKind::Const(ty, expr) => {\n-                    let default = ConstantKind::Local { def_id: local_did, body: expr };\n-                    AssocConstItem(clean_ty(ty, cx), default)\n-                }\n-                hir::ImplItemKind::Fn(ref sig, body) => {\n-                    let m = clean_function(cx, sig, self.generics, body);\n-                    let defaultness = cx.tcx.impl_defaultness(self.def_id);\n-                    MethodItem(m, Some(defaultness))\n-                }\n-                hir::ImplItemKind::TyAlias(hir_ty) => {\n-                    let type_ = clean_ty(hir_ty, cx);\n-                    let generics = self.generics.clean(cx);\n-                    let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, hir_ty), cx, None);\n-                    AssocTypeItem(\n-                        Box::new(Typedef { type_, generics, item_type: Some(item_type) }),\n-                        Vec::new(),\n-                    )\n-                }\n-            };\n+pub(crate) fn clean_impl_item<'tcx>(\n+    impl_: &hir::ImplItem<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> Item {\n+    let local_did = impl_.def_id.to_def_id();\n+    cx.with_param_env(local_did, |cx| {\n+        let inner = match impl_.kind {\n+            hir::ImplItemKind::Const(ty, expr) => {\n+                let default = ConstantKind::Local { def_id: local_did, body: expr };\n+                AssocConstItem(clean_ty(ty, cx), default)\n+            }\n+            hir::ImplItemKind::Fn(ref sig, body) => {\n+                let m = clean_function(cx, sig, impl_.generics, body);\n+                let defaultness = cx.tcx.impl_defaultness(impl_.def_id);\n+                MethodItem(m, Some(defaultness))\n+            }\n+            hir::ImplItemKind::TyAlias(hir_ty) => {\n+                let type_ = clean_ty(hir_ty, cx);\n+                let generics = clean_generics(impl_.generics, cx);\n+                let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, hir_ty), cx, None);\n+                AssocTypeItem(\n+                    Box::new(Typedef { type_, generics, item_type: Some(item_type) }),\n+                    Vec::new(),\n+                )\n+            }\n+        };\n \n-            let mut what_rustc_thinks =\n-                Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx);\n+        let mut what_rustc_thinks =\n+            Item::from_def_id_and_parts(local_did, Some(impl_.ident.name), inner, cx);\n \n-            let impl_ref = cx.tcx.impl_trait_ref(cx.tcx.local_parent(self.def_id));\n+        let impl_ref = cx.tcx.impl_trait_ref(cx.tcx.local_parent(impl_.def_id));\n \n-            // Trait impl items always inherit the impl's visibility --\n-            // we don't want to show `pub`.\n-            if impl_ref.is_some() {\n-                what_rustc_thinks.visibility = Inherited;\n-            }\n+        // Trait impl items always inherit the impl's visibility --\n+        // we don't want to show `pub`.\n+        if impl_ref.is_some() {\n+            what_rustc_thinks.visibility = Inherited;\n+        }\n \n-            what_rustc_thinks\n-        })\n-    }\n+        what_rustc_thinks\n+    })\n }\n \n impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n@@ -1905,32 +1898,32 @@ fn clean_maybe_renamed_item<'tcx>(\n             }),\n             ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n                 bounds: ty.bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n-                generics: ty.generics.clean(cx),\n+                generics: clean_generics(ty.generics, cx),\n             }),\n             ItemKind::TyAlias(hir_ty, generics) => {\n                 let rustdoc_ty = clean_ty(hir_ty, cx);\n                 let ty = clean_middle_ty(hir_ty_to_ty(cx.tcx, hir_ty), cx, None);\n                 TypedefItem(Box::new(Typedef {\n                     type_: rustdoc_ty,\n-                    generics: generics.clean(cx),\n+                    generics: clean_generics(generics, cx),\n                     item_type: Some(ty),\n                 }))\n             }\n             ItemKind::Enum(ref def, generics) => EnumItem(Enum {\n                 variants: def.variants.iter().map(|v| v.clean(cx)).collect(),\n-                generics: generics.clean(cx),\n+                generics: clean_generics(generics, cx),\n             }),\n             ItemKind::TraitAlias(generics, bounds) => TraitAliasItem(TraitAlias {\n-                generics: generics.clean(cx),\n+                generics: clean_generics(generics, cx),\n                 bounds: bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n             }),\n             ItemKind::Union(ref variant_data, generics) => UnionItem(Union {\n-                generics: generics.clean(cx),\n+                generics: clean_generics(generics, cx),\n                 fields: variant_data.fields().iter().map(|x| clean_field(x, cx)).collect(),\n             }),\n             ItemKind::Struct(ref variant_data, generics) => StructItem(Struct {\n                 struct_type: CtorKind::from_hir(variant_data),\n-                generics: generics.clean(cx),\n+                generics: clean_generics(generics, cx),\n                 fields: variant_data.fields().iter().map(|x| clean_field(x, cx)).collect(),\n             }),\n             ItemKind::Impl(impl_) => return clean_impl(impl_, item.hir_id(), cx),\n@@ -1953,7 +1946,7 @@ fn clean_maybe_renamed_item<'tcx>(\n                 TraitItem(Trait {\n                     def_id,\n                     items,\n-                    generics: generics.clean(cx),\n+                    generics: clean_generics(generics, cx),\n                     bounds: bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n                 })\n             }\n@@ -1988,8 +1981,11 @@ fn clean_impl<'tcx>(\n     let tcx = cx.tcx;\n     let mut ret = Vec::new();\n     let trait_ = impl_.of_trait.as_ref().map(|t| clean_trait_ref(t, cx));\n-    let items =\n-        impl_.items.iter().map(|ii| tcx.hir().impl_item(ii.id).clean(cx)).collect::<Vec<_>>();\n+    let items = impl_\n+        .items\n+        .iter()\n+        .map(|ii| clean_impl_item(tcx.hir().impl_item(ii.id), cx))\n+        .collect::<Vec<_>>();\n     let def_id = tcx.hir().local_def_id(hir_id);\n \n     // If this impl block is an implementation of the Deref trait, then we\n@@ -2006,7 +2002,7 @@ fn clean_impl<'tcx>(\n     let mut make_item = |trait_: Option<Path>, for_: Type, items: Vec<Item>| {\n         let kind = ImplItem(Box::new(Impl {\n             unsafety: impl_.unsafety,\n-            generics: impl_.generics.clean(cx),\n+            generics: clean_generics(impl_.generics, cx),\n             trait_,\n             for_,\n             items,\n@@ -2203,7 +2199,7 @@ fn clean_maybe_renamed_foreign_item<'tcx>(\n             hir::ForeignItemKind::Fn(decl, names, generics) => {\n                 let (generics, decl) = enter_impl_trait(cx, |cx| {\n                     // NOTE: generics must be cleaned before args\n-                    let generics = generics.clean(cx);\n+                    let generics = clean_generics(generics, cx);\n                     let args = clean_args_from_types_and_names(cx, decl.inputs, names);\n                     let decl = clean_fn_decl_with_args(cx, decl, args);\n                     (generics, decl)"}, {"sha": "718cbbd2b83742bf4e97e7d5ce93710e1ea906fe", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -2,9 +2,9 @@ use crate::clean::auto_trait::AutoTraitFinder;\n use crate::clean::blanket_impl::BlanketImplFinder;\n use crate::clean::render_macro_matchers::render_macro_matcher;\n use crate::clean::{\n-    clean_middle_const, clean_middle_region, clean_middle_ty, inline, Clean, Crate, ExternalCrate,\n-    Generic, GenericArg, GenericArgs, ImportSource, Item, ItemKind, Lifetime, Path, PathSegment,\n-    Primitive, PrimitiveType, Type, TypeBinding, Visibility,\n+    clean_doc_module, clean_middle_const, clean_middle_region, clean_middle_ty, inline, Crate,\n+    ExternalCrate, Generic, GenericArg, GenericArgs, ImportSource, Item, ItemKind, Lifetime, Path,\n+    PathSegment, Primitive, PrimitiveType, Type, TypeBinding, Visibility,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -37,7 +37,7 @@ pub(crate) fn krate(cx: &mut DocContext<'_>) -> Crate {\n \n     // Clean the crate, translating the entire librustc_ast AST to one that is\n     // understood by rustdoc.\n-    let mut module = module.clean(cx);\n+    let mut module = clean_doc_module(&module, cx);\n \n     match *module.kind {\n         ItemKind::ModuleItem(ref module) => {"}, {"sha": "5dec610b30c7b66ffe86d6aaa56cc4392c6db42c", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -348,8 +348,7 @@ function loadCss(cssFileName) {\n \n     function onHashChange(ev) {\n         // If we're in mobile mode, we should hide the sidebar in any case.\n-        const sidebar = document.getElementsByClassName(\"sidebar\")[0];\n-        removeClass(sidebar, \"shown\");\n+        hideSidebar();\n         handleHashes(ev);\n     }\n \n@@ -734,11 +733,50 @@ function loadCss(cssFileName) {\n         });\n     }());\n \n+    let oldSidebarScrollPosition = null;\n+\n+    function showSidebar() {\n+        if (window.innerWidth < window.RUSTDOC_MOBILE_BREAKPOINT) {\n+            // This is to keep the scroll position on mobile.\n+            oldSidebarScrollPosition = window.scrollY;\n+            document.body.style.width = `${document.body.offsetWidth}px`;\n+            document.body.style.position = \"fixed\";\n+            document.body.style.top = `-${oldSidebarScrollPosition}px`;\n+            document.querySelector(\".mobile-topbar\").style.top = `${oldSidebarScrollPosition}px`;\n+            document.querySelector(\".mobile-topbar\").style.position = \"relative\";\n+        } else {\n+            oldSidebarScrollPosition = null;\n+        }\n+        const sidebar = document.getElementsByClassName(\"sidebar\")[0];\n+        addClass(sidebar, \"shown\");\n+    }\n+\n     function hideSidebar() {\n+        if (oldSidebarScrollPosition !== null) {\n+            // This is to keep the scroll position on mobile.\n+            document.body.style.width = \"\";\n+            document.body.style.position = \"\";\n+            document.body.style.top = \"\";\n+            document.querySelector(\".mobile-topbar\").style.top = \"\";\n+            document.querySelector(\".mobile-topbar\").style.position = \"\";\n+            // The scroll position is lost when resetting the style, hence why we store it in\n+            // `oldSidebarScrollPosition`.\n+            window.scrollTo(0, oldSidebarScrollPosition);\n+            oldSidebarScrollPosition = null;\n+        }\n         const sidebar = document.getElementsByClassName(\"sidebar\")[0];\n         removeClass(sidebar, \"shown\");\n     }\n \n+    window.addEventListener(\"resize\", () => {\n+        if (window.innerWidth >= window.RUSTDOC_MOBILE_BREAKPOINT &&\n+            oldSidebarScrollPosition !== null) {\n+            // If the user opens the sidebar in \"mobile\" mode, and then grows the browser window,\n+            // we need to switch away from mobile mode and make the main content area scrollable.\n+            hideSidebar();\n+        }\n+    });\n+\n     function handleClick(id, f) {\n         const elem = document.getElementById(id);\n         if (elem) {\n@@ -781,9 +819,9 @@ function loadCss(cssFileName) {\n         sidebar_menu_toggle.addEventListener(\"click\", () => {\n             const sidebar = document.getElementsByClassName(\"sidebar\")[0];\n             if (!hasClass(sidebar, \"shown\")) {\n-                addClass(sidebar, \"shown\");\n+                showSidebar();\n             } else {\n-                removeClass(sidebar, \"shown\");\n+                hideSidebar();\n             }\n         });\n     }"}, {"sha": "06d15d9e5ffea9ad239ad69ee5f8f50fefe302df", "filename": "src/librustdoc/html/static/js/source-script.js", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsource-script.js", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsource-script.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsource-script.js?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -10,7 +10,7 @@\n (function() {\n \n const rootPath = document.getElementById(\"rustdoc-vars\").attributes[\"data-root-path\"].value;\n-let oldScrollPosition = 0;\n+let oldScrollPosition = null;\n \n const NAME_OFFSET = 0;\n const DIRS_OFFSET = 1;\n@@ -75,25 +75,39 @@ function toggleSidebar() {\n             oldScrollPosition = window.scrollY;\n             document.body.style.position = \"fixed\";\n             document.body.style.top = `-${oldScrollPosition}px`;\n+        } else {\n+            oldScrollPosition = null;\n         }\n         addClass(document.documentElement, \"source-sidebar-expanded\");\n         child.innerText = \"<\";\n         updateLocalStorage(\"source-sidebar-show\", \"true\");\n     } else {\n-        if (window.innerWidth < window.RUSTDOC_MOBILE_BREAKPOINT) {\n+        if (window.innerWidth < window.RUSTDOC_MOBILE_BREAKPOINT && oldScrollPosition !== null) {\n             // This is to keep the scroll position on mobile.\n             document.body.style.position = \"\";\n             document.body.style.top = \"\";\n             // The scroll position is lost when resetting the style, hence why we store it in\n-            // `oldScroll`.\n+            // `oldScrollPosition`.\n             window.scrollTo(0, oldScrollPosition);\n+            oldScrollPosition = null;\n         }\n         removeClass(document.documentElement, \"source-sidebar-expanded\");\n         child.innerText = \">\";\n         updateLocalStorage(\"source-sidebar-show\", \"false\");\n     }\n }\n \n+window.addEventListener(\"resize\", () => {\n+    if (window.innerWidth >= window.RUSTDOC_MOBILE_BREAKPOINT && oldScrollPosition !== null) {\n+        // If the user opens the sidebar in \"mobile\" mode, and then grows the browser window,\n+        // we need to switch away from mobile mode and make the main content area scrollable.\n+        document.body.style.position = \"\";\n+        document.body.style.top = \"\";\n+        window.scrollTo(0, oldScrollPosition);\n+        oldScrollPosition = null;\n+    }\n+});\n+\n function createSidebarToggle() {\n     const sidebarToggle = document.createElement(\"div\");\n     sidebarToggle.id = \"sidebar-toggle\";"}, {"sha": "4c21fd553289bd2a6066e8d01e86cf82b5483dbb", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -685,24 +685,18 @@ impl FromWithTcx<clean::Variant> for Variant {\n impl FromWithTcx<clean::Import> for Import {\n     fn from_tcx(import: clean::Import, tcx: TyCtxt<'_>) -> Self {\n         use clean::ImportKind::*;\n-        match import.kind {\n-            Simple(s) => Import {\n-                source: import.source.path.whole_name(),\n-                name: s.to_string(),\n-                id: import.source.did.map(ItemId::from).map(|i| from_item_id(i, tcx)),\n-                glob: false,\n-            },\n-            Glob => Import {\n-                source: import.source.path.whole_name(),\n-                name: import\n-                    .source\n-                    .path\n-                    .last_opt()\n-                    .unwrap_or_else(|| Symbol::intern(\"*\"))\n-                    .to_string(),\n-                id: import.source.did.map(ItemId::from).map(|i| from_item_id(i, tcx)),\n-                glob: true,\n-            },\n+        let (name, glob) = match import.kind {\n+            Simple(s) => (s.to_string(), false),\n+            Glob => (\n+                import.source.path.last_opt().unwrap_or_else(|| Symbol::intern(\"*\")).to_string(),\n+                true,\n+            ),\n+        };\n+        Import {\n+            source: import.source.path.whole_name(),\n+            name,\n+            id: import.source.did.map(ItemId::from).map(|i| from_item_id(i, tcx)),\n+            glob,\n         }\n     }\n }"}, {"sha": "9914edf3036e431ba5bedd089b32b3b4cfb6b4e8", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -17,6 +17,7 @@ pub(crate) const STRIP_HIDDEN: Pass = Pass {\n /// Strip items marked `#[doc(hidden)]`\n pub(crate) fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n     let mut retained = ItemIdSet::default();\n+    let is_json_output = cx.output_format.is_json() && !cx.show_coverage;\n \n     // strip all #[doc(hidden)] items\n     let krate = {\n@@ -25,7 +26,12 @@ pub(crate) fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clea\n     };\n \n     // strip all impls referencing stripped items\n-    let mut stripper = ImplStripper { retained: &retained, cache: &cx.cache };\n+    let mut stripper = ImplStripper {\n+        retained: &retained,\n+        cache: &cx.cache,\n+        is_json_output,\n+        document_private: cx.render_options.document_private,\n+    };\n     stripper.fold_crate(krate)\n }\n "}, {"sha": "f3aa3c7ce2459d4ac5b4fbc676d65d80e51a213c", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -17,19 +17,25 @@ pub(crate) const STRIP_PRIVATE: Pass = Pass {\n pub(crate) fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n     // This stripper collects all *retained* nodes.\n     let mut retained = ItemIdSet::default();\n+    let is_json_output = cx.output_format.is_json() && !cx.show_coverage;\n \n     // strip all private items\n     {\n         let mut stripper = Stripper {\n             retained: &mut retained,\n             access_levels: &cx.cache.access_levels,\n             update_retained: true,\n-            is_json_output: cx.output_format.is_json() && !cx.show_coverage,\n+            is_json_output,\n         };\n         krate = ImportStripper.fold_crate(stripper.fold_crate(krate));\n     }\n \n     // strip all impls referencing private items\n-    let mut stripper = ImplStripper { retained: &retained, cache: &cx.cache };\n+    let mut stripper = ImplStripper {\n+        retained: &retained,\n+        cache: &cx.cache,\n+        is_json_output,\n+        document_private: cx.render_options.document_private,\n+    };\n     stripper.fold_crate(krate)\n }"}, {"sha": "3f069e8393f7e9667bfea7a05834ea86f21e0ee8", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -14,17 +14,19 @@ pub(crate) struct Stripper<'a> {\n     pub(crate) is_json_output: bool,\n }\n \n-impl<'a> Stripper<'a> {\n-    // We need to handle this differently for the JSON output because some non exported items could\n-    // be used in public API. And so, we need these items as well. `is_exported` only checks if they\n-    // are in the public API, which is not enough.\n-    #[inline]\n-    fn is_item_reachable(&self, item_id: ItemId) -> bool {\n-        if self.is_json_output {\n-            self.access_levels.is_reachable(item_id.expect_def_id())\n-        } else {\n-            self.access_levels.is_exported(item_id.expect_def_id())\n-        }\n+// We need to handle this differently for the JSON output because some non exported items could\n+// be used in public API. And so, we need these items as well. `is_exported` only checks if they\n+// are in the public API, which is not enough.\n+#[inline]\n+fn is_item_reachable(\n+    is_json_output: bool,\n+    access_levels: &AccessLevels<DefId>,\n+    item_id: ItemId,\n+) -> bool {\n+    if is_json_output {\n+        access_levels.is_reachable(item_id.expect_def_id())\n+    } else {\n+        access_levels.is_exported(item_id.expect_def_id())\n     }\n }\n \n@@ -61,7 +63,9 @@ impl<'a> DocFolder for Stripper<'a> {\n             | clean::MacroItem(..)\n             | clean::ForeignTypeItem => {\n                 let item_id = i.item_id;\n-                if item_id.is_local() && !self.is_item_reachable(item_id) {\n+                if item_id.is_local()\n+                    && !is_item_reachable(self.is_json_output, self.access_levels, item_id)\n+                {\n                     debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n                     return None;\n                 }\n@@ -133,15 +137,36 @@ impl<'a> DocFolder for Stripper<'a> {\n pub(crate) struct ImplStripper<'a> {\n     pub(crate) retained: &'a ItemIdSet,\n     pub(crate) cache: &'a Cache,\n+    pub(crate) is_json_output: bool,\n+    pub(crate) document_private: bool,\n }\n \n impl<'a> DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if let clean::ImplItem(ref imp) = *i.kind {\n             // Impl blocks can be skipped if they are: empty; not a trait impl; and have no\n             // documentation.\n-            if imp.trait_.is_none() && imp.items.is_empty() && i.doc_value().is_none() {\n-                return None;\n+            //\n+            // There is one special case: if the impl block contains only private items.\n+            if imp.trait_.is_none() {\n+                // If the only items present are private ones and we're not rendering private items,\n+                // we don't document it.\n+                if !imp.items.is_empty()\n+                    && !self.document_private\n+                    && imp.items.iter().all(|i| {\n+                        let item_id = i.item_id;\n+                        item_id.is_local()\n+                            && !is_item_reachable(\n+                                self.is_json_output,\n+                                &self.cache.access_levels,\n+                                item_id,\n+                            )\n+                    })\n+                {\n+                    return None;\n+                } else if imp.items.is_empty() && i.doc_value().is_none() {\n+                    return None;\n+                }\n             }\n             if let Some(did) = imp.for_.def_id(self.cache) {\n                 if did.is_local() && !imp.for_.is_assoc_ty() && !self.retained.contains(&did.into())"}, {"sha": "ecdecadd2efb560833a9dc7d0bb466b4b36c9bc1", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -591,8 +591,11 @@ pub struct Import {\n     /// May be different from the last segment of `source` when renaming imports:\n     /// `use source as name;`\n     pub name: String,\n-    /// The ID of the item being imported.\n-    pub id: Option<Id>, // FIXME is this actually ever None?\n+    /// The ID of the item being imported. Will be `None` in case of re-exports of primitives:\n+    /// ```rust\n+    /// pub use i32 as my_i32;\n+    /// ```\n+    pub id: Option<Id>,\n     /// Whether this import uses a glob: `use source::*;`\n     pub glob: bool,\n }"}, {"sha": "0721d9f7019bccdadbd15164e6e36d949fa66c86", "filename": "src/test/mir-opt/README.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fmir-opt%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fmir-opt%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2FREADME.md?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -14,6 +14,18 @@ presence of pointers in constants or other bit width dependent things. In that c\n \n to your test, causing separate files to be generated for 32bit and 64bit systems.\n \n+## Unit testing\n+\n+If you are only testing the behavior of a particular mir-opt pass on some specific input (as is\n+usually the case), you should add\n+\n+```\n+// unit-test: PassName\n+```\n+\n+to the top of the file. This makes sure that other passes don't run which means you'll get the input\n+you expected and your test won't break when other code changes.\n+\n ## Emit a diff of the mir for a specific optimization\n \n This is what you want most often when you want to see how an optimization changes the MIR."}, {"sha": "b3bcea253388f0c00c955d9907c1d13f792aaf81", "filename": "src/test/rustdoc-gui/sidebar-mobile-scroll.goml", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile-scroll.goml", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile-scroll.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile-scroll.goml?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -0,0 +1,31 @@\n+// This test ensures that the mobile sidebar preserves scroll position.\n+goto: file://|DOC_PATH|/test_docs/struct.Foo.html\n+// Switching to \"mobile view\" by reducing the width to 600px.\n+size: (600, 600)\n+assert-css: (\".sidebar\", {\"display\": \"block\", \"left\": \"-1000px\"})\n+\n+// Scroll down.\n+scroll-to: \"//h2[@id='blanket-implementations']\"\n+assert-window-property: {\"pageYOffset\": \"702\"}\n+\n+// Open the sidebar menu.\n+click: \".sidebar-menu-toggle\"\n+wait-for-css: (\".sidebar\", {\"left\": \"0px\"})\n+\n+// We are no longer \"scrolled\". It's important that the user can't\n+// scroll the body at all, but these test scripts are run only in Chrome,\n+// and we need to use a more complicated solution to this problem because\n+// of Mobile Safari...\n+assert-window-property: {\"pageYOffset\": \"0\"}\n+\n+// Close the sidebar menu. Make sure the scroll position gets restored.\n+click: \".sidebar-menu-toggle\"\n+wait-for-css: (\".sidebar\", {\"left\": \"-1000px\"})\n+assert-window-property: {\"pageYOffset\": \"702\"}\n+\n+// Now test that scrollability returns when the browser window is just resized.\n+click: \".sidebar-menu-toggle\"\n+wait-for-css: (\".sidebar\", {\"left\": \"0px\"})\n+assert-window-property: {\"pageYOffset\": \"0\"}\n+size: (900, 900)\n+assert-window-property: {\"pageYOffset\": \"702\"}"}, {"sha": "e4662a10ed5da5c4c5c5789eda530d7cf808489a", "filename": "src/test/rustdoc-gui/sidebar-source-code-display.goml", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Frustdoc-gui%2Fsidebar-source-code-display.goml", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Frustdoc-gui%2Fsidebar-source-code-display.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar-source-code-display.goml?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -233,6 +233,17 @@ wait-for-css: (\".sidebar\", {\"width\": \"0px\"})\n // The \"scrollTop\" property should be the same.\n assert-window-property: {\"pageYOffset\": \"2519\"}\n \n+// We now check that the scroll position is restored if the window is resized.\n+size: (500, 700)\n+click: \"#sidebar-toggle\"\n+wait-for-css: (\"#source-sidebar\", {\"visibility\": \"visible\"})\n+assert-window-property: {\"pageYOffset\": \"0\"}\n+size: (900, 900)\n+assert-window-property: {\"pageYOffset\": \"2519\"}\n+size: (500, 700)\n+click: \"#sidebar-toggle\"\n+wait-for-css: (\"#source-sidebar\", {\"visibility\": \"hidden\"})\n+\n // We now check that opening the sidebar and clicking a link will close it.\n // The behavior here on mobile is different than the behavior on desktop,\n // but common sense dictates that if you have a list of files that fills the entire screen, and"}, {"sha": "878a1a4a79ce73ba069494d8f086993b2ecf4c7f", "filename": "src/test/rustdoc-json/primitive.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Frustdoc-json%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Frustdoc-json%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fprimitive.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -12,3 +12,9 @@ mod usize {}\n // @has - \"$.index[*][?(@.name=='checked_add')]\"\n // @!is - \"$.index[*][?(@.name=='checked_add')]\" $local_crate_id\n // @!has - \"$.index[*][?(@.name=='is_ascii_uppercase')]\"\n+\n+// @is - \"$.index[*][?(@.kind=='import' && @.inner.name=='my_i32')].inner.id\" null\n+pub use i32 as my_i32;\n+\n+// @is - \"$.index[*][?(@.kind=='import' && @.inner.name=='u32')].inner.id\" null\n+pub use u32;"}, {"sha": "43971996163022cde80231616b6a78798de5ddb1", "filename": "src/test/rustdoc/empty-impl-block-private-with-doc.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Frustdoc%2Fempty-impl-block-private-with-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Frustdoc%2Fempty-impl-block-private-with-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fempty-impl-block-private-with-doc.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -0,0 +1,44 @@\n+// compile-flags: --document-private-items\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/struct.Foo.html'\n+pub struct Foo;\n+\n+// There are 3 impl blocks with public item and one that should not be displayed\n+// by default because it only contains private items (but not in this case because\n+// we used `--document-private-items`).\n+// @count - '//*[@class=\"impl has-srclink\"]' 'impl Foo' 4\n+\n+// Impl block only containing private items should not be displayed unless the\n+// `--document-private-items` flag is used.\n+/// Private\n+impl Foo {\n+    const BAR: u32 = 0;\n+    type FOO = i32;\n+    fn hello() {}\n+}\n+\n+// But if any element of the impl block is public, it should be displayed.\n+/// Not private\n+impl Foo {\n+    pub const BAR: u32 = 0;\n+    type FOO = i32;\n+    fn hello() {}\n+}\n+\n+/// Not private\n+impl Foo {\n+    const BAR: u32 = 0;\n+    pub type FOO = i32;\n+    fn hello() {}\n+}\n+\n+/// Not private\n+impl Foo {\n+    const BAR: u32 = 0;\n+    type FOO = i32;\n+    pub fn hello() {}\n+}"}, {"sha": "5caf020658c5f5afaf75ea63535c4aeee62462fa", "filename": "src/test/rustdoc/empty-impl-block-private.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Frustdoc%2Fempty-impl-block-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Frustdoc%2Fempty-impl-block-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fempty-impl-block-private.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -0,0 +1,40 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/struct.Foo.html'\n+pub struct Foo;\n+\n+// There are 3 impl blocks with public item and one that should not be displayed\n+// because it only contains private items.\n+// @count - '//*[@class=\"impl has-srclink\"]' 'impl Foo' 3\n+\n+// Impl block only containing private items should not be displayed.\n+/// Private\n+impl Foo {\n+    const BAR: u32 = 0;\n+    type FOO = i32;\n+    fn hello() {}\n+}\n+\n+// But if any element of the impl block is public, it should be displayed.\n+/// Not private\n+impl Foo {\n+    pub const BAR: u32 = 0;\n+    type FOO = i32;\n+    fn hello() {}\n+}\n+\n+/// Not private\n+impl Foo {\n+    const BAR: u32 = 0;\n+    pub type FOO = i32;\n+    fn hello() {}\n+}\n+\n+/// Not private\n+impl Foo {\n+    const BAR: u32 = 0;\n+    type FOO = i32;\n+    pub fn hello() {}\n+}"}, {"sha": "e1ccda71d40eaf5d352fd572a582db497704c826", "filename": "src/test/ui/consts/const_in_pattern/incomplete-slice.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fincomplete-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fincomplete-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fincomplete-slice.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -0,0 +1,15 @@\n+#[derive(PartialEq)]\n+enum E {\n+    A,\n+}\n+\n+const E_SL: &[E] = &[E::A];\n+\n+fn main() {\n+    match &[][..] {\n+        //~^ ERROR non-exhaustive patterns: `&_` not covered [E0004]\n+        E_SL => {}\n+        //~^ WARN to use a constant of type `E` in a pattern, `E` must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| WARN this was previously accepted by the compiler but is being phased out\n+    }\n+}"}, {"sha": "0ff70837138431f8ccd49d5f2842c6690464c599", "filename": "src/test/ui/consts/const_in_pattern/incomplete-slice.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fincomplete-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fincomplete-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fincomplete-slice.stderr?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -0,0 +1,26 @@\n+warning: to use a constant of type `E` in a pattern, `E` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/incomplete-slice.rs:11:9\n+   |\n+LL |         E_SL => {}\n+   |         ^^^^\n+   |\n+   = note: `#[warn(indirect_structural_match)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+\n+error[E0004]: non-exhaustive patterns: `&_` not covered\n+  --> $DIR/incomplete-slice.rs:9:11\n+   |\n+LL |     match &[][..] {\n+   |           ^^^^^^^ pattern `&_` not covered\n+   |\n+   = note: the matched value is of type `&[E]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         E_SL => {}\n+LL +         &_ => todo!()\n+   |\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "b92449c6e0aff6776e77d51a8efcc9a96e22b265", "filename": "src/test/ui/copy-a-resource.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcopy-a-resource.stderr?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -10,6 +10,10 @@ LL |     let _y = x.clone();\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let _y = x.i.clone();\n+   |                ++\n \n error: aborting due to previous error\n "}, {"sha": "ffe3d7b81f51eca8b207d10a60cd3f5154cef018", "filename": "src/test/ui/hrtb/issue-30786.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.stderr?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -18,10 +18,6 @@ note: the following trait bounds were not satisfied:\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n-help: one of the expressions' fields has a method of the same name\n-   |\n-LL |     let filter = map.stream.filterx(|x: &_| true);\n-   |                      +++++++\n \n error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:129:30: 129:37]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-30786.rs:130:24\n@@ -43,10 +39,6 @@ note: the following trait bounds were not satisfied:\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n-help: one of the expressions' fields has a method of the same name\n-   |\n-LL |     let count = filter.stream.countx();\n-   |                        +++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "208b340d0641067309f2545dff511e8851662e9d", "filename": "src/test/ui/issues/issue-2823.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -10,6 +10,10 @@ LL |     let _d = c.clone();\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let _d = c.x.clone();\n+   |                ++\n \n error: aborting due to previous error\n "}, {"sha": "8fcfae22a3d3385e31d9e7ed9f62b48c41dc4930", "filename": "src/test/ui/lint/unused_parens_multibyte_recovery.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Flint%2Funused_parens_multibyte_recovery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Flint%2Funused_parens_multibyte_recovery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_parens_multibyte_recovery.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -0,0 +1,11 @@\n+// ignore-tidy-trailing-newlines\n+//\n+// error-pattern: this file contains an unclosed delimiter\n+// error-pattern: this file contains an unclosed delimiter\n+// error-pattern: this file contains an unclosed delimiter\n+// error-pattern: format argument must be a string literal\n+//\n+// Verify that unused parens lint does not try to create a span\n+// which points in the middle of a multibyte character.\n+\n+fn f(){(print!(\u00e1\n\\ No newline at end of file"}, {"sha": "a0302b17e255d06d2fe85d7fb810ef67fbcd2f28", "filename": "src/test/ui/lint/unused_parens_multibyte_recovery.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Flint%2Funused_parens_multibyte_recovery.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Flint%2Funused_parens_multibyte_recovery.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_parens_multibyte_recovery.stderr?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -0,0 +1,43 @@\n+error: this file contains an unclosed delimiter\n+  --> $DIR/unused_parens_multibyte_recovery.rs:11:17\n+   |\n+LL | fn f(){(print!(\u00e1\n+   |       --      - ^\n+   |       ||      |\n+   |       ||      unclosed delimiter\n+   |       |unclosed delimiter\n+   |       unclosed delimiter\n+\n+error: this file contains an unclosed delimiter\n+  --> $DIR/unused_parens_multibyte_recovery.rs:11:17\n+   |\n+LL | fn f(){(print!(\u00e1\n+   |       --      - ^\n+   |       ||      |\n+   |       ||      unclosed delimiter\n+   |       |unclosed delimiter\n+   |       unclosed delimiter\n+\n+error: this file contains an unclosed delimiter\n+  --> $DIR/unused_parens_multibyte_recovery.rs:11:17\n+   |\n+LL | fn f(){(print!(\u00e1\n+   |       --      - ^\n+   |       ||      |\n+   |       ||      unclosed delimiter\n+   |       |unclosed delimiter\n+   |       unclosed delimiter\n+\n+error: format argument must be a string literal\n+  --> $DIR/unused_parens_multibyte_recovery.rs:11:16\n+   |\n+LL | fn f(){(print!(\u00e1\n+   |                ^\n+   |\n+help: you might be missing a string literal to format with\n+   |\n+LL | fn f(){(print!(\"{}\", \u00e1\n+   |                +++++\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "15e22e946da8a1da79630526c7f82f0fff9b02cb", "filename": "src/test/ui/noncopyable-class.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnoncopyable-class.stderr?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -10,6 +10,14 @@ LL |     let _y = x.clone();\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let _y = x.i.clone();\n+   |                ++\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |     let _y = x.j.x.clone();\n+   |                ++++\n \n error: aborting due to previous error\n "}, {"sha": "3de06b21420b4771d5303554fa8b99ef9392f15b", "filename": "src/test/ui/suggestions/field-access-considering-privacy.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access-considering-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access-considering-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access-considering-privacy.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -0,0 +1,35 @@\n+use a::TyCtxt;\n+\n+mod a {\n+    use std::ops::Deref;\n+    pub struct TyCtxt<'tcx> {\n+        gcx: &'tcx GlobalCtxt<'tcx>,\n+    }\n+\n+    impl<'tcx> Deref for TyCtxt<'tcx> {\n+        type Target = &'tcx GlobalCtxt<'tcx>;\n+\n+        fn deref(&self) -> &Self::Target {\n+            &self.gcx\n+        }\n+    }\n+\n+    pub struct GlobalCtxt<'tcx> {\n+        pub sess: &'tcx Session,\n+        _t: &'tcx (),\n+    }\n+\n+    pub struct Session {\n+        pub opts: (),\n+    }\n+}\n+\n+mod b {\n+    fn foo<'tcx>(tcx: crate::TyCtxt<'tcx>) {\n+        tcx.opts;\n+        //~^ ERROR no field `opts` on type `TyCtxt<'tcx>`\n+        //~| HELP one of the expressions' fields has a field of the same name\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "cbf6f3d10025856fdabcf425d7399f98493f5b8f", "filename": "src/test/ui/suggestions/field-access-considering-privacy.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access-considering-privacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access-considering-privacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access-considering-privacy.stderr?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -0,0 +1,14 @@\n+error[E0609]: no field `opts` on type `TyCtxt<'tcx>`\n+  --> $DIR/field-access-considering-privacy.rs:29:13\n+   |\n+LL |         tcx.opts;\n+   |             ^^^^ unknown field\n+   |\n+help: one of the expressions' fields has a field of the same name\n+   |\n+LL |         tcx.sess.opts;\n+   |             +++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0609`."}, {"sha": "8f0b34bab0c87f4920f2a8fd2a87a1c98ab095cc", "filename": "src/test/ui/typeck/issue-100246.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Ftypeck%2Fissue-100246.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Ftypeck%2Fissue-100246.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-100246.rs?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -0,0 +1,30 @@\n+#![recursion_limit = \"5\"] // To reduce noise\n+\n+//expect incompatible type error when ambiguous traits are in scope\n+//and not an overflow error on the span in the main function.\n+\n+struct Ratio<T>(T);\n+\n+pub trait Pow {\n+    fn pow(self) -> Self;\n+}\n+\n+impl<'a, T> Pow for &'a Ratio<T>\n+where\n+    &'a T: Pow,\n+{\n+    fn pow(self) -> Self {\n+        self\n+    }\n+}\n+\n+fn downcast<'a, W: ?Sized>() -> std::io::Result<&'a W> {\n+    todo!()\n+}\n+\n+struct Other;\n+\n+fn main() -> std::io::Result<()> {\n+    let other: Other = downcast()?;//~ERROR 28:24: 28:35: `?` operator has incompatible types\n+    Ok(())\n+}"}, {"sha": "8b77de94e89f866aee1c72f0c916d5927e3f151d", "filename": "src/test/ui/typeck/issue-100246.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Ftypeck%2Fissue-100246.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0459d2fa736a556332ea9613ad0edf073107cb40/src%2Ftest%2Fui%2Ftypeck%2Fissue-100246.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-100246.stderr?ref=0459d2fa736a556332ea9613ad0edf073107cb40", "patch": "@@ -0,0 +1,13 @@\n+error[E0308]: `?` operator has incompatible types\n+  --> $DIR/issue-100246.rs:28:24\n+   |\n+LL |     let other: Other = downcast()?;\n+   |                        ^^^^^^^^^^^ expected struct `Other`, found reference\n+   |\n+   = note: `?` operator cannot convert from `&_` to `Other`\n+   = note: expected struct `Other`\n+           found reference `&_`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}