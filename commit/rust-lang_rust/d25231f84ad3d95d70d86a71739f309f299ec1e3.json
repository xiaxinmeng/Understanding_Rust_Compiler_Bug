{"sha": "d25231f84ad3d95d70d86a71739f309f299ec1e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNTIzMWY4NGFkM2Q5NWQ3MGQ4NmE3MTczOWYzMDlmMjk5ZWMxZTM=", "commit": {"author": {"name": "dylan_DPC", "email": "dylan.dpc@gmail.com", "date": "2018-07-08T13:44:36Z"}, "committer": {"name": "dylan_DPC", "email": "dylan.dpc@gmail.com", "date": "2018-07-19T17:45:24Z"}, "message": "use LiveVariableMap as trait bound", "tree": {"sha": "d7e4a77d57518496b37c2f2a655111c742a98f61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7e4a77d57518496b37c2f2a655111c742a98f61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d25231f84ad3d95d70d86a71739f309f299ec1e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d25231f84ad3d95d70d86a71739f309f299ec1e3", "html_url": "https://github.com/rust-lang/rust/commit/d25231f84ad3d95d70d86a71739f309f299ec1e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d25231f84ad3d95d70d86a71739f309f299ec1e3/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2b5583f6084c68cf1f46a1554db7ee3f0252ec1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2b5583f6084c68cf1f46a1554db7ee3f0252ec1", "html_url": "https://github.com/rust-lang/rust/commit/f2b5583f6084c68cf1f46a1554db7ee3f0252ec1"}], "stats": {"total": 51, "additions": 26, "deletions": 25}, "files": [{"sha": "972e92de77e52a87bef850a6f564745e9a742bd6", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d25231f84ad3d95d70d86a71739f309f299ec1e3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d25231f84ad3d95d70d86a71739f309f299ec1e3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=d25231f84ad3d95d70d86a71739f309f299ec1e3", "patch": "@@ -22,7 +22,7 @@ use rustc::ty::{Ty, TypeFoldable};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use std::rc::Rc;\n-use util::liveness::LivenessResults;\n+use util::liveness::{LivenessResults, LiveVariableMap};\n \n use super::TypeChecker;\n \n@@ -34,10 +34,10 @@ use super::TypeChecker;\n ///\n /// NB. This computation requires normalization; therefore, it must be\n /// performed before\n-pub(super) fn generate<'gcx, 'tcx>(\n+pub(super) fn generate<'gcx, 'tcx, V: LiveVariableMap>(\n     cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n-    liveness: &LivenessResults<Local>,\n+    liveness: &LivenessResults<V>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) {\n@@ -55,16 +55,17 @@ pub(super) fn generate<'gcx, 'tcx>(\n     }\n }\n \n-struct TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx>\n+struct TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx, V: LiveVariableMap>\n where\n     'typeck: 'gen,\n     'flow: 'gen,\n     'tcx: 'typeck + 'flow,\n     'gcx: 'tcx,\n+    V: 'gen,\n {\n     cx: &'gen mut TypeChecker<'typeck, 'gcx, 'tcx>,\n     mir: &'gen Mir<'tcx>,\n-    liveness: &'gen LivenessResults<Local>,\n+    liveness: &'gen LivenessResults<V>,\n     flow_inits: &'gen mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n     move_data: &'gen MoveData<'tcx>,\n     drop_data: FxHashMap<Ty<'tcx>, DropData<'tcx>>,\n@@ -75,7 +76,7 @@ struct DropData<'tcx> {\n     region_constraint_data: Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>,\n }\n \n-impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx> {\n+impl<'gen, 'typeck, 'flow, 'gcx, 'tcx, V:LiveVariableMap> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx, V> {\n     /// Liveness constraints:\n     ///\n     /// > If a variable V is live at point P, then all regions R in the type of V\n@@ -92,7 +93,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n                 }\n             });\n \n-        let mut all_live_locals: Vec<(Location, Vec<Local>)> = vec![];\n+        let mut all_live_locals: Vec<(Location, Vec<V::LiveVar>)> = vec![];\n         self.liveness\n             .drop\n             .simulate_block(self.mir, bb, |location, live_locals| {"}, {"sha": "5bd81f332e6b2d4b4bda7dce36843b653cfebd60", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d25231f84ad3d95d70d86a71739f309f299ec1e3/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d25231f84ad3d95d70d86a71739f309f299ec1e3/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=d25231f84ad3d95d70d86a71739f309f299ec1e3", "patch": "@@ -48,21 +48,21 @@ use rustc::ty::TyCtxt;\n use std::io::{self, Write};\n use transform::MirSource;\n \n-pub type LocalSet<V: Idx> = IdxSetBuf<V>;\n+pub type LocalSet<V: LiveVariableMap> = IdxSetBuf<V::LiveVar>;\n \n /// This gives the result of the liveness analysis at the boundary of\n /// basic blocks. You can use `simulate_block` to obtain the\n /// intra-block results.\n-pub struct LivenessResult<V: Idx> {\n+pub struct LivenessResult<V: LiveVariableMap> {\n     /// Liveness mode in use when these results were computed.\n     pub mode: LivenessMode,\n \n     /// Live variables on exit to each basic block. This is equal to\n     /// the union of the `ins` for each successor.\n-    pub outs: IndexVec<BasicBlock, LocalSet<V>>,\n+    pub outs: IndexVec<BasicBlock, LocalSet<V::LiveVar>>,\n }\n \n-trait LiveVariableMap {\n+pub(crate) trait LiveVariableMap {\n     type LiveVar;\n \n     fn from_local(&self, local: Local) -> Option<Self::LiveVar>;\n@@ -103,18 +103,18 @@ pub struct LivenessMode {\n }\n \n /// A combination of liveness results, used in NLL.\n-pub struct LivenessResults<V: Idx> {\n+pub struct LivenessResults<V: LiveVariableMap> {\n     /// Liveness results where a regular use makes a variable X live,\n     /// but not a drop.\n-    pub regular: LivenessResult<V>,\n+    pub regular: LivenessResult<V::LiveVar>,\n \n     /// Liveness results where a drop makes a variable X live,\n     /// but not a regular use.\n-    pub drop: LivenessResult<V>,\n+    pub drop: LivenessResult<V::LiveVar>,\n }\n \n-impl<V: Idx> LivenessResults<V> {\n-    pub fn compute<'tcx>(mir: &Mir<'tcx>, map: &dyn LiveVariableMap<LiveVar = V>) -> LivenessResults<V> {\n+impl<V: LiveVariableMap> LivenessResults<V> {\n+    pub fn compute<'tcx>(mir: &Mir<'tcx>, map: &dyn LiveVariableMap<LiveVar = V>) -> LivenessResults<V::LiveVar> {\n         LivenessResults {\n             regular: liveness_of_locals(\n                 &mir,\n@@ -138,7 +138,7 @@ impl<V: Idx> LivenessResults<V> {\n /// Compute which local variables are live within the given function\n /// `mir`. The liveness mode `mode` determines what sorts of uses are\n /// considered to make a variable live (e.g., do drops count?).\n-pub fn liveness_of_locals<'tcx, V: Idx>(mir: &Mir<'tcx>, mode: LivenessMode) -> LivenessResult<V> {\n+pub fn liveness_of_locals<'tcx, V: LiveVariableMap>(mir: &Mir<'tcx>, mode: LivenessMode) -> LivenessResult<V::LiveVar> {\n     let locals = mir.local_decls.len();\n     let def_use: IndexVec<_, _> = mir.basic_blocks()\n         .iter()\n@@ -179,8 +179,7 @@ pub fn liveness_of_locals<'tcx, V: Idx>(mir: &Mir<'tcx>, mode: LivenessMode) ->\n     LivenessResult { mode, outs }\n }\n \n-impl<V> LivenessResult<V>\n-where V:Idx\n+impl<V: LiveVariableMap> LivenessResult<V>\n {\n     /// Walks backwards through the statements/terminator in the given\n     /// basic block `block`.  At each point within `block`, invokes\n@@ -422,12 +421,13 @@ fn block<'tcx, 'lv>(mode: LivenessMode, b: &BasicBlockData<'tcx>, locals: usize)\n     visitor.defs_uses\n }\n \n-pub fn dump_mir<'a, 'tcx, V: Idx>(\n+pub fn dump_mir<'a, 'tcx, V: LiveVariableMap>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pass_name: &str,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n     result: &LivenessResult<Local>,\n+    map: &impl LiveVariableMap<LiveVar = V>\n ) {\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n@@ -439,13 +439,13 @@ pub fn dump_mir<'a, 'tcx, V: Idx>(\n     dump_matched_mir_node(tcx, pass_name, &node_path, source, mir, result);\n }\n \n-fn dump_matched_mir_node<'a, 'tcx, V: Idx>(\n+fn dump_matched_mir_node<'a, 'tcx, V: LiveVariableMap>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pass_name: &str,\n     node_path: &str,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n-    result: &LivenessResult<V>,\n+    result: &LivenessResult<V::LiveVar>,\n ) {\n     let mut file_path = PathBuf::new();\n     file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n@@ -462,16 +462,16 @@ fn dump_matched_mir_node<'a, 'tcx, V: Idx>(\n     });\n }\n \n-pub fn write_mir_fn<'a, 'tcx, V :Idx>(\n+pub fn write_mir_fn<'a, 'tcx, V: LiveVariableMap>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     src: MirSource,\n     mir: &Mir<'tcx>,\n     w: &mut dyn Write,\n-    result: &LivenessResult<V>,\n+    result: &LivenessResult<V::LiveVar>,\n ) -> io::Result<()> {\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n-        let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LocalSet<V>>| {\n+        let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LocalSet<Local>>| {\n             let live: Vec<String> = mir.local_decls\n                 .indices()\n                 .filter(|i| result[block].contains(i))"}]}