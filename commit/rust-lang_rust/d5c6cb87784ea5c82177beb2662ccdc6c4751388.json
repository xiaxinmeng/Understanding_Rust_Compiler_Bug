{"sha": "d5c6cb87784ea5c82177beb2662ccdc6c4751388", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1YzZjYjg3Nzg0ZWE1YzgyMTc3YmViMjY2MmNjZGM2YzQ3NTEzODg=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-13T20:15:08Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-28T20:35:20Z"}, "message": "Eagerly evaluate in `super_relate_consts`", "tree": {"sha": "1c54adf7f45f5c036b0201b778efecb9eab942e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c54adf7f45f5c036b0201b778efecb9eab942e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5c6cb87784ea5c82177beb2662ccdc6c4751388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5c6cb87784ea5c82177beb2662ccdc6c4751388", "html_url": "https://github.com/rust-lang/rust/commit/d5c6cb87784ea5c82177beb2662ccdc6c4751388", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5c6cb87784ea5c82177beb2662ccdc6c4751388/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "908d97d03ce4d20287163d91a71695f03f3a906e", "url": "https://api.github.com/repos/rust-lang/rust/commits/908d97d03ce4d20287163d91a71695f03f3a906e", "html_url": "https://github.com/rust-lang/rust/commit/908d97d03ce4d20287163d91a71695f03f3a906e"}], "stats": {"total": 97, "additions": 39, "deletions": 58}, "files": [{"sha": "55525d868e2fa4cb41d71b6c707ba91c1b576666", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 37, "deletions": 56, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d5c6cb87784ea5c82177beb2662ccdc6c4751388/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5c6cb87784ea5c82177beb2662ccdc6c4751388/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=d5c6cb87784ea5c82177beb2662ccdc6c4751388", "patch": "@@ -8,8 +8,7 @@ use crate::hir::def_id::DefId;\n use crate::ty::subst::{Kind, UnpackedKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::mir::interpret::{GlobalId, ConstValue, Scalar};\n-use syntax_pos::DUMMY_SP;\n+use crate::mir::interpret::{ConstValue, Scalar, GlobalId};\n use std::rc::Rc;\n use std::iter;\n use rustc_target::spec::abi;\n@@ -473,54 +472,8 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         (&ty::Array(a_t, sz_a), &ty::Array(b_t, sz_b)) =>\n         {\n             let t = relation.relate(&a_t, &b_t)?;\n-\n-            let to_u64 = |ct: &'tcx ty::Const<'tcx>| -> Option<u64> {\n-                match ct.val {\n-                    // FIXME(const_generics): this doesn't work right now,\n-                    // because it tries to relate an `Infer` to a `Param`.\n-                    ConstValue::Unevaluated(def_id, substs) => {\n-                        // FIXME(eddyb) get the right param_env.\n-                        let param_env = ty::ParamEnv::empty();\n-                        if let Some(substs) = tcx.lift_to_global(&substs) {\n-                            let instance = ty::Instance::resolve(\n-                                tcx.global_tcx(),\n-                                param_env,\n-                                def_id,\n-                                substs,\n-                            );\n-                            if let Some(instance) = instance {\n-                                let cid = GlobalId {\n-                                    instance,\n-                                    promoted: None,\n-                                };\n-                                return tcx.const_eval(param_env.and(cid))\n-                                    .ok()\n-                                    .map(|c| c.unwrap_usize(tcx));\n-                            }\n-                        }\n-                        None\n-                    }\n-                    _ => ct.assert_usize(tcx),\n-                }\n-            };\n-            match (to_u64(sz_a), to_u64(sz_b)) {\n-                (Some(sz_a_u64), Some(sz_b_u64)) => {\n-                    if sz_a_u64 == sz_b_u64 {\n-                        Ok(tcx.mk_ty(ty::Array(t, sz_a)))\n-                    } else {\n-                        Err(TypeError::FixedArraySize(\n-                            expected_found(relation, &sz_a_u64, &sz_b_u64)))\n-                    }\n-                }\n-                _ => {\n-                    if let Ok(sz) = relation.relate(&sz_a, &sz_b) {\n-                        Ok(tcx.mk_ty(ty::Array(t, sz)))\n-                    } else {\n-                        tcx.sess.delay_span_bug(DUMMY_SP, \"array length could not be evaluated\");\n-                        Ok(tcx.types.err)\n-                    }\n-                }\n-            }\n+            let sz = relation.relate(&sz_a, &sz_b)?;\n+            Ok(tcx.mk_ty(ty::Array(t, sz)))\n         }\n \n         (&ty::Slice(a_t), &ty::Slice(b_t)) =>\n@@ -594,11 +547,36 @@ where\n {\n     let tcx = relation.tcx();\n \n+    let eagerly_eval = |x: &'tcx ty::Const<'tcx>| {\n+        if let ConstValue::Unevaluated(def_id, substs) = x.val {\n+            // FIXME(eddyb) get the right param_env.\n+            let param_env = ty::ParamEnv::empty();\n+            if let Some(substs) = tcx.lift_to_global(&substs) {\n+                let instance = ty::Instance::resolve(\n+                    tcx.global_tcx(),\n+                    param_env,\n+                    def_id,\n+                    substs,\n+                );\n+                if let Some(instance) = instance {\n+                    let cid = GlobalId {\n+                        instance,\n+                        promoted: None,\n+                    };\n+                    if let Ok(ct) = tcx.const_eval(param_env.and(cid)) {\n+                        return ct.val;\n+                    }\n+                }\n+            }\n+        }\n+        x.val\n+    };\n+\n     // Currently, the values that can be unified are those that\n     // implement both `PartialEq` and `Eq`, corresponding to\n     // `structural_match` types.\n     // FIXME(const_generics): check for `structural_match` synthetic attribute.\n-    match (a.val, b.val) {\n+    match (eagerly_eval(a), eagerly_eval(b)) {\n         (ConstValue::Infer(_), _) | (_, ConstValue::Infer(_)) => {\n             // The caller should handle these cases!\n             bug!(\"var types encountered in super_relate_consts: {:?} {:?}\", a, b)\n@@ -609,8 +587,13 @@ where\n         (ConstValue::Placeholder(p1), ConstValue::Placeholder(p2)) if p1 == p2 => {\n             Ok(a)\n         }\n-        (ConstValue::Scalar(Scalar::Raw { .. }), _) if a == b => {\n-            Ok(a)\n+        (a_val @ ConstValue::Scalar(Scalar::Raw { .. }), b_val @ _)\n+            if a.ty == b.ty && a_val == b_val =>\n+        {\n+            Ok(tcx.mk_const(ty::Const {\n+                val: a_val,\n+                ty: a.ty,\n+            }))\n         }\n         (ConstValue::ByRef(..), _) => {\n             bug!(\n@@ -631,9 +614,7 @@ where\n                 }))\n             }\n \n-            _ => {\n-            Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n-        }\n+        _ => Err(TypeError::ConstMismatch(expected_found(relation, &a, &b))),\n     }\n }\n "}, {"sha": "29297b24e988f774f171b919c0791827d77a46ff", "filename": "src/test/ui/consts/const-array-oob-arith.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5c6cb87784ea5c82177beb2662ccdc6c4751388/src%2Ftest%2Fui%2Fconsts%2Fconst-array-oob-arith.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5c6cb87784ea5c82177beb2662ccdc6c4751388/src%2Ftest%2Fui%2Fconsts%2Fconst-array-oob-arith.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-array-oob-arith.stderr?ref=d5c6cb87784ea5c82177beb2662ccdc6c4751388", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/const-array-oob-arith.rs:7:45\n    |\n LL | const BLUB: [i32; (ARR[0] - 40) as usize] = [5];\n-   |                                             ^^^ expected an array with a fixed size of 2 elements, found one with 1 elements\n+   |                                             ^^^ expected `Const { ty: usize, val: Scalar(Bits { size: 8, bits: 2 }) }`, found `Const { ty: usize, val: Scalar(Bits { size: 8, bits: 1 }) }`\n    |\n    = note: expected type `[i32; 2]`\n               found type `[i32; 1]`\n@@ -11,7 +11,7 @@ error[E0308]: mismatched types\n   --> $DIR/const-array-oob-arith.rs:8:44\n    |\n LL | const BOO: [i32; (ARR[0] - 41) as usize] = [5, 99];\n-   |                                            ^^^^^^^ expected an array with a fixed size of 1 elements, found one with 2 elements\n+   |                                            ^^^^^^^ expected `Const { ty: usize, val: Scalar(Bits { size: 8, bits: 1 }) }`, found `Const { ty: usize, val: Scalar(Bits { size: 8, bits: 2 }) }`\n    |\n    = note: expected type `[i32; 1]`\n               found type `[i32; 2]`"}]}