{"sha": "efb171e2350de2bec6dd1f035b99bc00535c1c15", "node_id": "C_kwDOAAsO6NoAKGVmYjE3MWUyMzUwZGUyYmVjNmRkMWYwMzViOTliYzAwNTM1YzFjMTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-05T14:58:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-05T14:58:31Z"}, "message": "Auto merge of #98584 - lcnr:region-stuff-more-beans, r=oli-obk\n\ncontinue nll transition by removing stuff\n\nr? `@jackh726` for now\n\nbuilding on #98641", "tree": {"sha": "978ba25322f303839483357bcf27aa55e9303482", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/978ba25322f303839483357bcf27aa55e9303482"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efb171e2350de2bec6dd1f035b99bc00535c1c15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efb171e2350de2bec6dd1f035b99bc00535c1c15", "html_url": "https://github.com/rust-lang/rust/commit/efb171e2350de2bec6dd1f035b99bc00535c1c15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efb171e2350de2bec6dd1f035b99bc00535c1c15/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54f79babae06d3772c067f696e5b12db822ae25f", "url": "https://api.github.com/repos/rust-lang/rust/commits/54f79babae06d3772c067f696e5b12db822ae25f", "html_url": "https://github.com/rust-lang/rust/commit/54f79babae06d3772c067f696e5b12db822ae25f"}, {"sha": "9f95c605f83bcf4c158ea4b3fd5a7abb825a4178", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f95c605f83bcf4c158ea4b3fd5a7abb825a4178", "html_url": "https://github.com/rust-lang/rust/commit/9f95c605f83bcf4c158ea4b3fd5a7abb825a4178"}], "stats": {"total": 1270, "additions": 111, "deletions": 1159}, "files": [{"sha": "7120d5ad93455c8fd61684b22e71542bb01fa780", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -128,7 +128,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         let region_constraints = self.with_region_constraints(|region_constraints| {\n             make_query_region_constraints(\n                 tcx,\n-                region_obligations.iter().map(|(_, r_o)| (r_o.sup_type, r_o.sub_region)),\n+                region_obligations.iter().map(|r_o| (r_o.sup_type, r_o.sub_region)),\n                 region_constraints,\n             )\n         });"}, {"sha": "fad949a3bc6a15a55fa2aeb34284e1b6a96ba9ee", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -4,7 +4,6 @@\n //! and use that to decide when one free region outlives another, and so forth.\n \n use rustc_data_structures::transitive_relation::TransitiveRelation;\n-use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, Lift, Region, TyCtxt};\n \n /// Combines a `FreeRegionMap` and a `TyCtxt`.\n@@ -14,16 +13,13 @@ use rustc_middle::ty::{self, Lift, Region, TyCtxt};\n pub(crate) struct RegionRelations<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n \n-    /// The context used for debug messages\n-    pub context: DefId,\n-\n     /// Free-region relationships.\n     pub free_regions: &'a FreeRegionMap<'tcx>,\n }\n \n impl<'a, 'tcx> RegionRelations<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>, context: DefId, free_regions: &'a FreeRegionMap<'tcx>) -> Self {\n-        Self { tcx, context, free_regions }\n+    pub fn new(tcx: TyCtxt<'tcx>, free_regions: &'a FreeRegionMap<'tcx>) -> Self {\n+        Self { tcx, free_regions }\n     }\n \n     pub fn lub_free_regions(&self, r_a: Region<'tcx>, r_b: Region<'tcx>) -> Region<'tcx> {"}, {"sha": "87fa22b3835ef1c2a1fbcff2d40c58d19cbb7241", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -120,13 +120,9 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     ) -> LexicalRegionResolutions<'tcx> {\n         let mut var_data = self.construct_var_data(self.tcx());\n \n-        // Dorky hack to cause `dump_constraints` to only get called\n-        // if debug mode is enabled:\n-        debug!(\n-            \"----() End constraint listing (context={:?}) {:?}---\",\n-            self.region_rels.context,\n-            self.dump_constraints(self.region_rels)\n-        );\n+        if cfg!(debug_assertions) {\n+            self.dump_constraints();\n+        }\n \n         let graph = self.construct_graph();\n         self.expand_givens(&graph);\n@@ -156,8 +152,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n-    fn dump_constraints(&self, free_regions: &RegionRelations<'_, 'tcx>) {\n-        debug!(\"----() Start constraint listing (context={:?}) ()----\", free_regions.context);\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn dump_constraints(&self) {\n         for (idx, (constraint, _)) in self.data.constraints.iter().enumerate() {\n             debug!(\"Constraint {} => {:?}\", idx, constraint);\n         }"}, {"sha": "c73302c7e415a49ecb5be7db867ca35b809eeb4a", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -15,7 +15,6 @@ use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::Rollback;\n use rustc_data_structures::unify as ut;\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n-use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n@@ -147,7 +146,7 @@ pub struct InferCtxtInner<'tcx> {\n     /// for each body-id in this map, which will process the\n     /// obligations within. This is expected to be done 'late enough'\n     /// that all type inference variables have been bound and so forth.\n-    region_obligations: Vec<(hir::HirId, RegionObligation<'tcx>)>,\n+    region_obligations: Vec<RegionObligation<'tcx>>,\n \n     undo_log: InferCtxtUndoLogs<'tcx>,\n \n@@ -171,7 +170,7 @@ impl<'tcx> InferCtxtInner<'tcx> {\n     }\n \n     #[inline]\n-    pub fn region_obligations(&self) -> &[(hir::HirId, RegionObligation<'tcx>)] {\n+    pub fn region_obligations(&self) -> &[RegionObligation<'tcx>] {\n         &self.region_obligations\n     }\n \n@@ -1267,7 +1266,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// `resolve_vars_if_possible` as well as `fully_resolve`.\n     pub fn resolve_regions(\n         &self,\n-        region_context: DefId,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n     ) -> Vec<RegionResolutionError<'tcx>> {\n         let (var_infos, data) = {\n@@ -1286,8 +1284,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 .into_infos_and_data()\n         };\n \n-        let region_rels =\n-            &RegionRelations::new(self.tcx, region_context, outlives_env.free_region_map());\n+        let region_rels = &RegionRelations::new(self.tcx, outlives_env.free_region_map());\n \n         let (lexical_region_resolutions, errors) =\n             lexical_region_resolve::resolve(outlives_env.param_env, region_rels, var_infos, data);\n@@ -1302,12 +1299,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// result. After this, no more unification operations should be\n     /// done -- or the compiler will panic -- but it is legal to use\n     /// `resolve_vars_if_possible` as well as `fully_resolve`.\n-    pub fn resolve_regions_and_report_errors(\n-        &self,\n-        region_context: DefId,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) {\n-        let errors = self.resolve_regions(region_context, outlives_env);\n+    pub fn resolve_regions_and_report_errors(&self, outlives_env: &OutlivesEnvironment<'tcx>) {\n+        let errors = self.resolve_regions(outlives_env);\n \n         if !self.is_tainted_by_errors() {\n             // As a heuristic, just skip reporting region errors"}, {"sha": "b897de7315a02dd2b0c6f14592379d1f6059d4a4", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 10, "deletions": 78, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -1,8 +1,6 @@\n use crate::infer::free_regions::FreeRegionMap;\n use crate::infer::{GenericKind, InferCtxt};\n use crate::traits::query::OutlivesBound;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir as hir;\n use rustc_middle::ty::{self, ReEarlyBound, ReFree, ReVar, Region};\n \n use super::explicit_outlives_bounds;\n@@ -31,9 +29,7 @@ pub struct OutlivesEnvironment<'tcx> {\n     pub param_env: ty::ParamEnv<'tcx>,\n     free_region_map: FreeRegionMap<'tcx>,\n \n-    // Contains, for each body B that we are checking (that is, the fn\n-    // item, but also any nested closures), the set of implied region\n-    // bounds that are in scope in that particular body.\n+    // Contains the implied region bounds in scope for our current body.\n     //\n     // Example:\n     //\n@@ -43,24 +39,15 @@ pub struct OutlivesEnvironment<'tcx> {\n     // } // body B0\n     // ```\n     //\n-    // Here, for body B0, the list would be `[T: 'a]`, because we\n+    // Here, when checking the body B0, the list would be `[T: 'a]`, because we\n     // infer that `T` must outlive `'a` from the implied bounds on the\n     // fn declaration.\n     //\n-    // For the body B1, the list would be `[T: 'a, T: 'b]`, because we\n+    // For the body B1 however, the list would be `[T: 'a, T: 'b]`, because we\n     // also can see that -- within the closure body! -- `T` must\n     // outlive `'b`. This is not necessarily true outside the closure\n     // body, since the closure may never be called.\n-    //\n-    // We collect this map as we descend the tree. We then use the\n-    // results when proving outlives obligations like `T: 'x` later\n-    // (e.g., if `T: 'x` must be proven within the body B1, then we\n-    // know it is true if either `'a: 'x` or `'b: 'x`).\n-    region_bound_pairs_map: FxHashMap<hir::HirId, RegionBoundPairs<'tcx>>,\n-\n-    // Used to compute `region_bound_pairs_map`: contains the set of\n-    // in-scope region-bound pairs thus far.\n-    region_bound_pairs_accum: RegionBoundPairs<'tcx>,\n+    region_bound_pairs: RegionBoundPairs<'tcx>,\n }\n \n /// \"Region-bound pairs\" tracks outlives relations that are known to\n@@ -73,8 +60,7 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n         let mut env = OutlivesEnvironment {\n             param_env,\n             free_region_map: Default::default(),\n-            region_bound_pairs_map: Default::default(),\n-            region_bound_pairs_accum: vec![],\n+            region_bound_pairs: Default::default(),\n         };\n \n         env.add_outlives_bounds(None, explicit_outlives_bounds(param_env));\n@@ -87,62 +73,9 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n         &self.free_region_map\n     }\n \n-    /// Borrows current value of the `region_bound_pairs`.\n-    pub fn region_bound_pairs_map(&self) -> &FxHashMap<hir::HirId, RegionBoundPairs<'tcx>> {\n-        &self.region_bound_pairs_map\n-    }\n-\n-    /// This is a hack to support the old-school regionck, which\n-    /// processes region constraints from the main function and the\n-    /// closure together. In that context, when we enter a closure, we\n-    /// want to be able to \"save\" the state of the surrounding a\n-    /// function. We can then add implied bounds and the like from the\n-    /// closure arguments into the environment -- these should only\n-    /// apply in the closure body, so once we exit, we invoke\n-    /// `pop_snapshot_post_typeck_child` to remove them.\n-    ///\n-    /// Example:\n-    ///\n-    /// ```ignore (pseudo-rust)\n-    /// fn foo<T>() {\n-    ///    callback(for<'a> |x: &'a T| {\n-    ///         // ^^^^^^^ not legal syntax, but probably should be\n-    ///         // within this closure body, `T: 'a` holds\n-    ///    })\n-    /// }\n-    /// ```\n-    ///\n-    /// This \"containment\" of closure's effects only works so well. In\n-    /// particular, we (intentionally) leak relationships between free\n-    /// regions that are created by the closure's bounds. The case\n-    /// where this is useful is when you have (e.g.) a closure with a\n-    /// signature like `for<'a, 'b> fn(x: &'a &'b u32)` -- in this\n-    /// case, we want to keep the relationship `'b: 'a` in the\n-    /// free-region-map, so that later if we have to take `LUB('b,\n-    /// 'a)` we can get the result `'b`.\n-    ///\n-    /// I have opted to keep **all modifications** to the\n-    /// free-region-map, however, and not just those that concern free\n-    /// variables bound in the closure. The latter seems more correct,\n-    /// but it is not the existing behavior, and I could not find a\n-    /// case where the existing behavior went wrong. In any case, it\n-    /// seems like it'd be readily fixed if we wanted. There are\n-    /// similar leaks around givens that seem equally suspicious, to\n-    /// be honest. --nmatsakis\n-    pub fn push_snapshot_pre_typeck_child(&self) -> usize {\n-        self.region_bound_pairs_accum.len()\n-    }\n-\n-    /// See `push_snapshot_pre_typeck_child`.\n-    pub fn pop_snapshot_post_typeck_child(&mut self, len: usize) {\n-        self.region_bound_pairs_accum.truncate(len);\n-    }\n-\n-    /// Save the current set of region-bound pairs under the given `body_id`.\n-    pub fn save_implied_bounds(&mut self, body_id: hir::HirId) {\n-        let old =\n-            self.region_bound_pairs_map.insert(body_id, self.region_bound_pairs_accum.clone());\n-        assert!(old.is_none());\n+    /// Borrows current `region_bound_pairs`.\n+    pub fn region_bound_pairs(&self) -> &RegionBoundPairs<'tcx> {\n+        &self.region_bound_pairs\n     }\n \n     /// Processes outlives bounds that are known to hold, whether from implied or other sources.\n@@ -164,11 +97,10 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n             debug!(\"add_outlives_bounds: outlives_bound={:?}\", outlives_bound);\n             match outlives_bound {\n                 OutlivesBound::RegionSubParam(r_a, param_b) => {\n-                    self.region_bound_pairs_accum.push((r_a, GenericKind::Param(param_b)));\n+                    self.region_bound_pairs.push((r_a, GenericKind::Param(param_b)));\n                 }\n                 OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n-                    self.region_bound_pairs_accum\n-                        .push((r_a, GenericKind::Projection(projection_b)));\n+                    self.region_bound_pairs.push((r_a, GenericKind::Projection(projection_b)));\n                 }\n                 OutlivesBound::RegionSubRegion(r_a, r_b) => {\n                     if let (ReEarlyBound(_) | ReFree(_), ReVar(vid_b)) = (r_a.kind(), r_b.kind()) {"}, {"sha": "b839566bec99f5f0a8d655bb0128be4c13e7a7e9", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -60,18 +60,16 @@\n //! imply that `'b: 'a`.\n \n use crate::infer::outlives::components::{push_outlives_components, Component};\n+use crate::infer::outlives::env::OutlivesEnvironment;\n use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::outlives::verify::VerifyBoundCx;\n use crate::infer::{\n     self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, UndoLog, VerifyBound,\n };\n use crate::traits::{ObligationCause, ObligationCauseCode};\n+use rustc_data_structures::undo_log::UndoLogs;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n-\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::undo_log::UndoLogs;\n-use rustc_hir as hir;\n use smallvec::smallvec;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n@@ -80,16 +78,11 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// and later processed by regionck, when full type information is\n     /// available (see `region_obligations` field for more\n     /// information).\n-    pub fn register_region_obligation(\n-        &self,\n-        body_id: hir::HirId,\n-        obligation: RegionObligation<'tcx>,\n-    ) {\n-        debug!(\"register_region_obligation(body_id={:?}, obligation={:?})\", body_id, obligation);\n-\n+    #[instrument(level = \"debug\", skip(self))]\n+    pub fn register_region_obligation(&self, obligation: RegionObligation<'tcx>) {\n         let mut inner = self.inner.borrow_mut();\n         inner.undo_log.push(UndoLog::PushRegionObligation);\n-        inner.region_obligations.push((body_id, obligation));\n+        inner.region_obligations.push(obligation);\n     }\n \n     pub fn register_region_obligation_with_cause(\n@@ -109,14 +102,11 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             )\n         });\n \n-        self.register_region_obligation(\n-            cause.body_id,\n-            RegionObligation { sup_type, sub_region, origin },\n-        );\n+        self.register_region_obligation(RegionObligation { sup_type, sub_region, origin });\n     }\n \n     /// Trait queries just want to pass back type obligations \"as is\"\n-    pub fn take_registered_region_obligations(&self) -> Vec<(hir::HirId, RegionObligation<'tcx>)> {\n+    pub fn take_registered_region_obligations(&self) -> Vec<RegionObligation<'tcx>> {\n         std::mem::take(&mut self.inner.borrow_mut().region_obligations)\n     }\n \n@@ -144,10 +134,10 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// - `param_env` is the parameter environment for the enclosing function.\n     /// - `body_id` is the body-id whose region obligations are being\n     ///   processed.\n-    #[instrument(level = \"debug\", skip(self, region_bound_pairs_map))]\n+    #[instrument(level = \"debug\", skip(self, region_bound_pairs))]\n     pub fn process_registered_region_obligations(\n         &self,\n-        region_bound_pairs_map: &FxHashMap<hir::HirId, RegionBoundPairs<'tcx>>,\n+        region_bound_pairs: &RegionBoundPairs<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) {\n         assert!(\n@@ -157,26 +147,31 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n         let my_region_obligations = self.take_registered_region_obligations();\n \n-        for (body_id, RegionObligation { sup_type, sub_region, origin }) in my_region_obligations {\n+        for RegionObligation { sup_type, sub_region, origin } in my_region_obligations {\n             debug!(\n                 \"process_registered_region_obligations: sup_type={:?} sub_region={:?} origin={:?}\",\n                 sup_type, sub_region, origin\n             );\n \n             let sup_type = self.resolve_vars_if_possible(sup_type);\n \n-            if let Some(region_bound_pairs) = region_bound_pairs_map.get(&body_id) {\n-                let outlives =\n-                    &mut TypeOutlives::new(self, self.tcx, &region_bound_pairs, None, param_env);\n-                outlives.type_must_outlive(origin, sup_type, sub_region);\n-            } else {\n-                self.tcx.sess.delay_span_bug(\n-                    origin.span(),\n-                    &format!(\"no region-bound-pairs for {:?}\", body_id),\n-                );\n-            }\n+            let outlives =\n+                &mut TypeOutlives::new(self, self.tcx, &region_bound_pairs, None, param_env);\n+            outlives.type_must_outlive(origin, sup_type, sub_region);\n         }\n     }\n+\n+    pub fn check_region_obligations_and_report_errors(\n+        &self,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+    ) {\n+        self.process_registered_region_obligations(\n+            outlives_env.region_bound_pairs(),\n+            outlives_env.param_env,\n+        );\n+\n+        self.resolve_regions_and_report_errors(outlives_env)\n+    }\n }\n \n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`"}, {"sha": "49434ec142828d8ae3e35fbe892afb82eb144ce0", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -212,15 +212,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 panic!(\"Unable to fulfill trait {:?} for '{:?}': {:?}\", trait_did, ty, errors);\n             }\n \n-            let body_id_map: FxHashMap<_, _> = infcx\n-                .inner\n-                .borrow()\n-                .region_obligations()\n-                .iter()\n-                .map(|&(id, _)| (id, vec![]))\n-                .collect();\n-\n-            infcx.process_registered_region_obligations(&body_id_map, full_env);\n+            infcx.process_registered_region_obligations(&Default::default(), full_env);\n \n             let region_data = infcx\n                 .inner"}, {"sha": "ae69f2f7eb3244d5fc82346e488a17908bdfaf65", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -16,7 +16,6 @@ use crate::traits::{\n //use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::CRATE_HIR_ID;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::{util, TraitEngine};\n use rustc_middle::traits::specialization_graph::OverlapMode;\n@@ -317,14 +316,13 @@ fn negative_impl<'cx, 'tcx>(\n         let (subject2, obligations) =\n             impl_subject_and_oblig(selcx, impl_env, impl2_def_id, impl2_substs);\n \n-        !equate(&infcx, impl_env, impl1_def_id, subject1, subject2, obligations)\n+        !equate(&infcx, impl_env, subject1, subject2, obligations)\n     })\n }\n \n fn equate<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     impl_env: ty::ParamEnv<'tcx>,\n-    impl1_def_id: DefId,\n     subject1: ImplSubject<'tcx>,\n     subject2: ImplSubject<'tcx>,\n     obligations: impl Iterator<Item = PredicateObligation<'tcx>>,\n@@ -341,7 +339,7 @@ fn equate<'cx, 'tcx>(\n     let opt_failing_obligation = obligations\n         .into_iter()\n         .chain(more_obligations)\n-        .find(|o| negative_impl_exists(selcx, impl_env, impl1_def_id, o));\n+        .find(|o| negative_impl_exists(selcx, impl_env, o));\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n         debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n@@ -356,18 +354,17 @@ fn equate<'cx, 'tcx>(\n fn negative_impl_exists<'cx, 'tcx>(\n     selcx: &SelectionContext<'cx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    region_context: DefId,\n     o: &PredicateObligation<'tcx>,\n ) -> bool {\n     let infcx = &selcx.infcx().fork();\n \n-    if resolve_negative_obligation(infcx, param_env, region_context, o) {\n+    if resolve_negative_obligation(infcx, param_env, o) {\n         return true;\n     }\n \n     // Try to prove a negative obligation exists for super predicates\n     for o in util::elaborate_predicates(infcx.tcx, iter::once(o.predicate)) {\n-        if resolve_negative_obligation(infcx, param_env, region_context, &o) {\n+        if resolve_negative_obligation(infcx, param_env, &o) {\n             return true;\n         }\n     }\n@@ -379,7 +376,6 @@ fn negative_impl_exists<'cx, 'tcx>(\n fn resolve_negative_obligation<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    region_context: DefId,\n     o: &PredicateObligation<'tcx>,\n ) -> bool {\n     let tcx = infcx.tcx;\n@@ -397,19 +393,11 @@ fn resolve_negative_obligation<'cx, 'tcx>(\n         return false;\n     }\n \n-    let mut outlives_env = OutlivesEnvironment::new(param_env);\n-    // FIXME -- add \"assumed to be well formed\" types into the `outlives_env`\n-\n-    // \"Save\" the accumulated implied bounds into the outlives environment\n-    // (due to the FIXME above, there aren't any, but this step is still needed).\n-    // The \"body id\" is given as `CRATE_HIR_ID`, which is the same body-id used\n-    // by the \"dummy\" causes elsewhere (body-id is only relevant when checking\n-    // function bodies with closures).\n-    outlives_env.save_implied_bounds(CRATE_HIR_ID);\n-\n-    infcx.process_registered_region_obligations(outlives_env.region_bound_pairs_map(), param_env);\n+    // FIXME -- also add \"assumed to be well formed\" types into the `outlives_env`\n+    let outlives_env = OutlivesEnvironment::new(param_env);\n+    infcx.process_registered_region_obligations(outlives_env.region_bound_pairs(), param_env);\n \n-    let errors = infcx.resolve_regions(region_context, &outlives_env);\n+    let errors = infcx.resolve_regions(&outlives_env);\n \n     if !errors.is_empty() {\n         return false;"}, {"sha": "b45f72e8748d615611cc9c5e97630f73a1487d49", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -198,17 +198,13 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n     }\n }\n \n+#[instrument(level = \"debug\", skip(tcx, elaborated_env))]\n fn do_normalize_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    region_context: DefId,\n     cause: ObligationCause<'tcx>,\n     elaborated_env: ty::ParamEnv<'tcx>,\n     predicates: Vec<ty::Predicate<'tcx>>,\n ) -> Result<Vec<ty::Predicate<'tcx>>, ErrorGuaranteed> {\n-    debug!(\n-        \"do_normalize_predicates(predicates={:?}, region_context={:?}, cause={:?})\",\n-        predicates, region_context, cause,\n-    );\n     let span = cause.span;\n     tcx.infer_ctxt().enter(|infcx| {\n         // FIXME. We should really... do something with these region\n@@ -240,7 +236,7 @@ fn do_normalize_predicates<'tcx>(\n         // cares about declarations like `'a: 'b`.\n         let outlives_env = OutlivesEnvironment::new(elaborated_env);\n \n-        infcx.resolve_regions_and_report_errors(region_context, &outlives_env);\n+        infcx.resolve_regions_and_report_errors(&outlives_env);\n \n         let predicates = match infcx.fully_resolve(predicates) {\n             Ok(predicates) => predicates,\n@@ -269,9 +265,9 @@ fn do_normalize_predicates<'tcx>(\n \n // FIXME: this is gonna need to be removed ...\n /// Normalizes the parameter environment, reporting errors if they occur.\n+#[instrument(level = \"debug\", skip(tcx))]\n pub fn normalize_param_env_or_error<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    region_context: DefId,\n     unnormalized_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n ) -> ty::ParamEnv<'tcx> {\n@@ -289,12 +285,6 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // parameter environments once for every fn as it goes,\n     // and errors will get reported then; so outside of type inference we\n     // can be sure that no errors should occur.\n-\n-    debug!(\n-        \"normalize_param_env_or_error(region_context={:?}, unnormalized_env={:?}, cause={:?})\",\n-        region_context, unnormalized_env, cause\n-    );\n-\n     let mut predicates: Vec<_> =\n         util::elaborate_predicates(tcx, unnormalized_env.caller_bounds().into_iter())\n             .map(|obligation| obligation.predicate)\n@@ -338,7 +328,6 @@ pub fn normalize_param_env_or_error<'tcx>(\n     );\n     let Ok(non_outlives_predicates) = do_normalize_predicates(\n         tcx,\n-        region_context,\n         cause.clone(),\n         elaborated_env,\n         predicates,\n@@ -362,7 +351,6 @@ pub fn normalize_param_env_or_error<'tcx>(\n     );\n     let Ok(outlives_predicates) = do_normalize_predicates(\n         tcx,\n-        region_context,\n         cause,\n         outlives_env,\n         outlives_predicates,"}, {"sha": "aad3c37f84e5a783250e31ad60ad9d512a103c47", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 3, "deletions": 67, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -1,73 +1,7 @@\n-use crate::infer::at::At;\n-use crate::infer::canonical::OriginalQueryValues;\n-use crate::infer::InferOk;\n-\n-use rustc_middle::ty::subst::GenericArg;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n pub use rustc_middle::traits::query::{DropckConstraint, DropckOutlivesResult};\n \n-pub trait AtExt<'tcx> {\n-    fn dropck_outlives(&self, ty: Ty<'tcx>) -> InferOk<'tcx, Vec<GenericArg<'tcx>>>;\n-}\n-\n-impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n-    /// Given a type `ty` of some value being dropped, computes a set\n-    /// of \"kinds\" (types, regions) that must be outlive the execution\n-    /// of the destructor. These basically correspond to data that the\n-    /// destructor might access. This is used during regionck to\n-    /// impose \"outlives\" constraints on any lifetimes referenced\n-    /// within.\n-    ///\n-    /// The rules here are given by the \"dropck\" RFCs, notably [#1238]\n-    /// and [#1327]. This is a fixed-point computation, where we\n-    /// explore all the data that will be dropped (transitively) when\n-    /// a value of type `ty` is dropped. For each type T that will be\n-    /// dropped and which has a destructor, we must assume that all\n-    /// the types/regions of T are live during the destructor, unless\n-    /// they are marked with a special attribute (`#[may_dangle]`).\n-    ///\n-    /// [#1238]: https://github.com/rust-lang/rfcs/blob/master/text/1238-nonparametric-dropck.md\n-    /// [#1327]: https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md\n-    fn dropck_outlives(&self, ty: Ty<'tcx>) -> InferOk<'tcx, Vec<GenericArg<'tcx>>> {\n-        debug!(\"dropck_outlives(ty={:?}, param_env={:?})\", ty, self.param_env,);\n-\n-        // Quick check: there are a number of cases that we know do not require\n-        // any destructor.\n-        let tcx = self.infcx.tcx;\n-        if trivial_dropck_outlives(tcx, ty) {\n-            return InferOk { value: vec![], obligations: vec![] };\n-        }\n-\n-        let mut orig_values = OriginalQueryValues::default();\n-        let c_ty = self.infcx.canonicalize_query(self.param_env.and(ty), &mut orig_values);\n-        let span = self.cause.span;\n-        debug!(\"c_ty = {:?}\", c_ty);\n-        if let Ok(result) = tcx.dropck_outlives(c_ty)\n-            && result.is_proven()\n-            && let Ok(InferOk { value, obligations }) =\n-                self.infcx.instantiate_query_response_and_region_obligations(\n-                    self.cause,\n-                    self.param_env,\n-                    &orig_values,\n-                    result,\n-                )\n-        {\n-            let ty = self.infcx.resolve_vars_if_possible(ty);\n-            let kinds = value.into_kinds_reporting_overflows(tcx, span, ty);\n-            return InferOk { value: kinds, obligations };\n-        }\n-\n-        // Errors and ambiguity in dropck occur in two cases:\n-        // - unresolved inference variables at the end of typeck\n-        // - non well-formed types where projections cannot be resolved\n-        // Either of these should have created an error before.\n-        tcx.sess.delay_span_bug(span, \"dtorck encountered internal error\");\n-\n-        InferOk { value: vec![], obligations: vec![] }\n-    }\n-}\n-\n /// This returns true if the type `ty` is \"trivial\" for\n /// dropck-outlives -- that is, if it doesn't require any types to\n /// outlive. This is similar but not *quite* the same as the\n@@ -79,6 +13,8 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n ///\n /// Note also that `needs_drop` requires a \"global\" type (i.e., one\n /// with erased regions), but this function does not.\n+///\n+// FIXME(@lcnr): remove this module and move this function somewhere else.\n pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind() {\n         // None of these types have a destructor and hence they do not\n@@ -105,7 +41,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, *ty),\n \n         // (T1..Tn) and closures have same properties as T1..Tn --\n-        // check if *any* of those are trivial.\n+        // check if *all* of them are trivial.\n         ty::Tuple(tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t)),\n         ty::Closure(_, ref substs) => {\n             trivial_dropck_outlives(tcx, substs.as_closure().tupled_upvars_ty())"}, {"sha": "c9d46b2810ddbd58f3fae39e649aee0384ee8523", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -95,7 +95,7 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n         infcx.tcx,\n         region_obligations\n             .iter()\n-            .map(|(_, r_o)| (r_o.sup_type, r_o.sub_region))\n+            .map(|r_o| (r_o.sup_type, r_o.sub_region))\n             .map(|(ty, r)| (infcx.resolve_vars_if_possible(ty), r)),\n         &region_constraint_data,\n     );"}, {"sha": "1d345caf69971e11b6cbe9e24b2707fcbf150e53", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -211,7 +211,7 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n         tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.hir_id)\n     });\n     let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n-    traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n+    traits::normalize_param_env_or_error(tcx, unnormalized_env, cause)\n }\n \n /// Elaborate the environment."}, {"sha": "ef74214781e5d614d5e1476bb5457d592d152b9b", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -13,6 +13,7 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ItemKind, Node, PathSegment};\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{RegionVariableOrigin, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n@@ -736,10 +737,8 @@ fn check_opaque_meets_bounds<'tcx>(\n             hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n             // Can have different predicates to their defining use\n             hir::OpaqueTyOrigin::TyAlias => {\n-                // Finally, resolve all regions. This catches wily misuses of\n-                // lifetime parameters.\n-                let fcx = FnCtxt::new(&inh, param_env, hir_id);\n-                fcx.regionck_item(hir_id, span, FxHashSet::default());\n+                let outlives_environment = OutlivesEnvironment::new(param_env);\n+                infcx.check_region_obligations_and_report_errors(&outlives_environment);\n             }\n         }\n "}, {"sha": "0a9b6863ef577cf42a7c51bd4671555fef8ae88b", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -1,10 +1,12 @@\n+use crate::check::regionck::OutlivesEnvironmentExt;\n use crate::errors::LifetimesOrBoundsMismatchOnTrait;\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::util;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n@@ -78,10 +80,11 @@ fn compare_predicate_entailment<'tcx>(\n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n     // This node-id should be used for the `body_id` field on each\n-    // `ObligationCause` (and the `FnCtxt`). This is what\n-    // `regionck_item` expects.\n+    // `ObligationCause` (and the `FnCtxt`).\n+    //\n+    // FIXME(@lcnr): remove that after removing `cause.body_id` from\n+    // obligations.\n     let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n-\n     // We sometimes modify the span further down.\n     let mut cause = ObligationCause::new(\n         impl_m_span,\n@@ -208,8 +211,7 @@ fn compare_predicate_entailment<'tcx>(\n         Reveal::UserFacing,\n         hir::Constness::NotConst,\n     );\n-    let param_env =\n-        traits::normalize_param_env_or_error(tcx, impl_m.def_id, param_env, normalize_cause);\n+    let param_env = traits::normalize_param_env_or_error(tcx, param_env, normalize_cause);\n \n     tcx.infer_ctxt().enter(|infcx| {\n         let inh = Inherited::new(infcx, impl_m.def_id.expect_local());\n@@ -399,8 +401,9 @@ fn compare_predicate_entailment<'tcx>(\n \n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n-        let fcx = FnCtxt::new(&inh, param_env, impl_m_hir_id);\n-        fcx.regionck_item(impl_m_hir_id, impl_m_span, wf_tys);\n+        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n+        outlives_environment.add_implied_bounds(infcx, wf_tys, impl_m_hir_id);\n+        infcx.check_region_obligations_and_report_errors(&outlives_environment);\n \n         Ok(())\n     })\n@@ -1155,8 +1158,8 @@ pub(crate) fn compare_const_impl<'tcx>(\n             return;\n         }\n \n-        let fcx = FnCtxt::new(&inh, param_env, impl_c_hir_id);\n-        fcx.regionck_item(impl_c_hir_id, impl_c_span, FxHashSet::default());\n+        let outlives_environment = OutlivesEnvironment::new(param_env);\n+        infcx.resolve_regions_and_report_errors(&outlives_environment);\n     });\n }\n \n@@ -1247,12 +1250,7 @@ fn compare_type_predicate_entailment<'tcx>(\n         Reveal::UserFacing,\n         hir::Constness::NotConst,\n     );\n-    let param_env = traits::normalize_param_env_or_error(\n-        tcx,\n-        impl_ty.def_id,\n-        param_env,\n-        normalize_cause.clone(),\n-    );\n+    let param_env = traits::normalize_param_env_or_error(tcx, param_env, normalize_cause.clone());\n     tcx.infer_ctxt().enter(|infcx| {\n         let inh = Inherited::new(infcx, impl_ty.def_id.expect_local());\n         let infcx = &inh.infcx;\n@@ -1279,8 +1277,8 @@ fn compare_type_predicate_entailment<'tcx>(\n \n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n-        let fcx = FnCtxt::new(&inh, param_env, impl_ty_hir_id);\n-        fcx.regionck_item(impl_ty_hir_id, impl_ty_span, FxHashSet::default());\n+        let outlives_environment = OutlivesEnvironment::new(param_env);\n+        infcx.check_region_obligations_and_report_errors(&outlives_environment);\n \n         Ok(())\n     })\n@@ -1504,12 +1502,16 @@ pub fn check_type_bounds<'tcx>(\n \n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n+        //\n+        // FIXME: Remove that `FnCtxt`.\n         let fcx = FnCtxt::new(&inh, param_env, impl_ty_hir_id);\n         let implied_bounds = match impl_ty.container {\n             ty::TraitContainer(_) => FxHashSet::default(),\n             ty::ImplContainer(def_id) => fcx.impl_implied_bounds(def_id, impl_ty_span),\n         };\n-        fcx.regionck_item(impl_ty_hir_id, impl_ty_span, implied_bounds);\n+        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n+        outlives_environment.add_implied_bounds(infcx, implied_bounds, impl_ty_hir_id);\n+        infcx.check_region_obligations_and_report_errors(&outlives_environment);\n \n         Ok(())\n     })"}, {"sha": "72095c408075cdc8fdfeb054d4eedef0cb03729f", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -1,13 +1,13 @@\n-use crate::check::regionck::RegionCtxt;\n-use crate::hir;\n+// FIXME(@lcnr): Move this module out of `rustc_typeck`.\n+//\n+// We don't do any drop checking during hir typeck.\n use crate::hir::def_id::{DefId, LocalDefId};\n use rustc_errors::{struct_span_err, ErrorGuaranteed};\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::util::IgnoreRegions;\n use rustc_middle::ty::{self, Predicate, Ty, TyCtxt};\n-use rustc_span::Span;\n \n /// This function confirms that the `Drop` implementation identified by\n /// `drop_impl_did` is not any more specialized than the type it is\n@@ -229,19 +229,6 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     result\n }\n \n-/// This function is not only checking that the dropck obligations are met for\n-/// the given type, but it's also currently preventing non-regular recursion in\n-/// types from causing stack overflows (dropck_no_diverge_on_nonregular_*.rs).\n-///\n-/// FIXME: Completely rip out dropck and regionck.\n-pub(crate) fn check_drop_obligations<'a, 'tcx>(\n-    _rcx: &mut RegionCtxt<'a, 'tcx>,\n-    _ty: Ty<'tcx>,\n-    _span: Span,\n-    _body_id: hir::HirId,\n-) {\n-}\n-\n // This is an implementation of the TypeRelation trait with the\n // aim of simply comparing for equality (without side-effects).\n // It is not intended to be used anywhere else other than here."}, {"sha": "dee58791cec1827ac5a40319e0ea04db19a8c3f8", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -368,7 +368,7 @@ fn typeck_with_fallback<'tcx>(\n \n     let typeck_results = Inherited::build(tcx, def_id).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n-        let (fcx, wf_tys) = if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n+        let fcx = if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n             let fn_sig = if crate::collect::get_infer_ret_ty(&decl.output).is_some() {\n                 let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n                 <dyn AstConv<'_>>::ty_of_fn(&fcx, id, header.unsafety, header.abi, decl, None, None)\n@@ -378,24 +378,15 @@ fn typeck_with_fallback<'tcx>(\n \n             check_abi(tcx, id, span, fn_sig.abi());\n \n-            // When normalizing the function signature, we assume all types are\n-            // well-formed. So, we don't need to worry about the obligations\n-            // from normalization. We could just discard these, but to align with\n-            // compare_method and elsewhere, we just add implied bounds for\n-            // these types.\n-            let mut wf_tys = FxHashSet::default();\n-            // Compute the fty from point of view of inside the fn.\n+            // Compute the function signature from point of view of inside the fn.\n             let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n             let fn_sig = inh.normalize_associated_types_in(\n                 body.value.span,\n                 body_id.hir_id,\n                 param_env,\n                 fn_sig,\n             );\n-            wf_tys.extend(fn_sig.inputs_and_output.iter());\n-\n-            let fcx = check_fn(&inh, param_env, fn_sig, decl, id, body, None, true).0;\n-            (fcx, wf_tys)\n+            check_fn(&inh, param_env, fn_sig, decl, id, body, None, true).0\n         } else {\n             let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n             let expected_type = body_ty\n@@ -458,7 +449,7 @@ fn typeck_with_fallback<'tcx>(\n \n             fcx.write_ty(id, expected_type);\n \n-            (fcx, FxHashSet::default())\n+            fcx\n         };\n \n         let fallback_has_occurred = fcx.type_inference_fallback();\n@@ -490,11 +481,7 @@ fn typeck_with_fallback<'tcx>(\n \n         fcx.check_asms();\n \n-        if fn_sig.is_some() {\n-            fcx.regionck_fn(id, body, span, wf_tys);\n-        } else {\n-            fcx.regionck_expr(body);\n-        }\n+        fcx.infcx.skip_region_resolution();\n \n         fcx.resolve_type_vars_in_body(body)\n     });"}, {"sha": "1c3c5f999bca8ef2e4459dba147bb63652d2f9e7", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 840, "changes": 843, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -1,114 +1,16 @@\n-//! The region check is a final pass that runs over the AST after we have\n-//! inferred the type constraints but before we have actually finalized\n-//! the types. Its purpose is to embed a variety of region constraints.\n-//! Inserting these constraints as a separate pass is good because (1) it\n-//! localizes the code that has to do with region inference and (2) often\n-//! we cannot know what constraints are needed until the basic types have\n-//! been inferred.\n-//!\n-//! ### Interaction with the borrow checker\n-//!\n-//! In general, the job of the borrowck module (which runs later) is to\n-//! check that all soundness criteria are met, given a particular set of\n-//! regions. The job of *this* module is to anticipate the needs of the\n-//! borrow checker and infer regions that will satisfy its requirements.\n-//! It is generally true that the inference doesn't need to be sound,\n-//! meaning that if there is a bug and we inferred bad regions, the borrow\n-//! checker should catch it. This is not entirely true though; for\n-//! example, the borrow checker doesn't check subtyping, and it doesn't\n-//! check that region pointers are always live when they are used. It\n-//! might be worthwhile to fix this so that borrowck serves as a kind of\n-//! verification step -- that would add confidence in the overall\n-//! correctness of the compiler, at the cost of duplicating some type\n-//! checks and effort.\n-//!\n-//! ### Inferring the duration of borrows, automatic and otherwise\n-//!\n-//! Whenever we introduce a borrowed pointer, for example as the result of\n-//! a borrow expression `let x = &data`, the lifetime of the pointer `x`\n-//! is always specified as a region inference variable. `regionck` has the\n-//! job of adding constraints such that this inference variable is as\n-//! narrow as possible while still accommodating all uses (that is, every\n-//! dereference of the resulting pointer must be within the lifetime).\n-//!\n-//! #### Reborrows\n-//!\n-//! Generally speaking, `regionck` does NOT try to ensure that the data\n-//! `data` will outlive the pointer `x`. That is the job of borrowck. The\n-//! one exception is when \"re-borrowing\" the contents of another borrowed\n-//! pointer. For example, imagine you have a borrowed pointer `b` with\n-//! lifetime `L1` and you have an expression `&*b`. The result of this\n-//! expression will be another borrowed pointer with lifetime `L2` (which is\n-//! an inference variable). The borrow checker is going to enforce the\n-//! constraint that `L2 < L1`, because otherwise you are re-borrowing data\n-//! for a lifetime larger than the original loan. However, without the\n-//! routines in this module, the region inferencer would not know of this\n-//! dependency and thus it might infer the lifetime of `L2` to be greater\n-//! than `L1` (issue #3148).\n-//!\n-//! There are a number of troublesome scenarios in the tests\n-//! `region-dependent-*.rs`, but here is one example:\n-//!\n-//!     struct Foo { i: i32 }\n-//!     struct Bar { foo: Foo  }\n-//!     fn get_i<'a>(x: &'a Bar) -> &'a i32 {\n-//!        let foo = &x.foo; // Lifetime L1\n-//!        &foo.i            // Lifetime L2\n-//!     }\n-//!\n-//! Note that this comes up either with `&` expressions, `ref`\n-//! bindings, and `autorefs`, which are the three ways to introduce\n-//! a borrow.\n-//!\n-//! The key point here is that when you are borrowing a value that\n-//! is \"guaranteed\" by a borrowed pointer, you must link the\n-//! lifetime of that borrowed pointer (`L1`, here) to the lifetime of\n-//! the borrow itself (`L2`). What do I mean by \"guaranteed\" by a\n-//! borrowed pointer? I mean any data that is reached by first\n-//! dereferencing a borrowed pointer and then either traversing\n-//! interior offsets or boxes. We say that the guarantor\n-//! of such data is the region of the borrowed pointer that was\n-//! traversed. This is essentially the same as the ownership\n-//! relation, except that a borrowed pointer never owns its\n-//! contents.\n-\n-use crate::check::dropck;\n-use crate::check::FnCtxt;\n-use crate::mem_categorization as mc;\n use crate::outlives::outlives_bounds::InferCtxtExt as _;\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::def_id::LocalDefId;\n-use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::PatKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::{self, InferCtxt, RegionObligation};\n-use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n-use rustc_middle::ty::adjustment;\n-use rustc_middle::ty::{self, Ty};\n-use rustc_span::Span;\n-use std::ops::Deref;\n-\n-// a variation on try that just returns unit\n-macro_rules! ignore_err {\n-    ($e:expr) => {\n-        match $e {\n-            Ok(e) => e,\n-            Err(_) => {\n-                debug!(\"ignoring mem-categorization error!\");\n-                return ();\n-            }\n-        }\n-    };\n-}\n+use rustc_infer::infer::InferCtxt;\n+use rustc_middle::ty::Ty;\n \n pub(crate) trait OutlivesEnvironmentExt<'tcx> {\n     fn add_implied_bounds(\n         &mut self,\n         infcx: &InferCtxt<'_, 'tcx>,\n         fn_sig_tys: FxHashSet<Ty<'tcx>>,\n         body_id: hir::HirId,\n-        span: Span,\n     );\n }\n \n@@ -135,750 +37,11 @@ impl<'tcx> OutlivesEnvironmentExt<'tcx> for OutlivesEnvironment<'tcx> {\n         infcx: &InferCtxt<'a, 'tcx>,\n         fn_sig_tys: FxHashSet<Ty<'tcx>>,\n         body_id: hir::HirId,\n-        span: Span,\n     ) {\n         for ty in fn_sig_tys {\n             let ty = infcx.resolve_vars_if_possible(ty);\n-            let implied_bounds = infcx.implied_outlives_bounds(self.param_env, body_id, ty, span);\n+            let implied_bounds = infcx.implied_outlives_bounds(self.param_env, body_id, ty);\n             self.add_outlives_bounds(Some(infcx), implied_bounds)\n         }\n     }\n }\n-\n-///////////////////////////////////////////////////////////////////////////\n-// PUBLIC ENTRY POINTS\n-\n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn regionck_expr(&self, body: &'tcx hir::Body<'tcx>) {\n-        let subject = self.tcx.hir().body_owner_def_id(body.id());\n-        let id = body.value.hir_id;\n-        let mut rcx = RegionCtxt::new(self, id, Subject(subject), self.param_env);\n-\n-        // There are no add'l implied bounds when checking a\n-        // standalone expr (e.g., the `E` in a type like `[u32; E]`).\n-        rcx.outlives_environment.save_implied_bounds(id);\n-\n-        if !self.errors_reported_since_creation() {\n-            // regionck assumes typeck succeeded\n-            rcx.visit_body(body);\n-            rcx.visit_region_obligations(id);\n-        }\n-        // Checked by NLL\n-        rcx.fcx.skip_region_resolution();\n-    }\n-\n-    /// Region checking during the WF phase for items. `wf_tys` are the\n-    /// types from which we should derive implied bounds, if any.\n-    #[instrument(level = \"debug\", skip(self))]\n-    pub fn regionck_item(&self, item_id: hir::HirId, span: Span, wf_tys: FxHashSet<Ty<'tcx>>) {\n-        let subject = self.tcx.hir().local_def_id(item_id);\n-        let mut rcx = RegionCtxt::new(self, item_id, Subject(subject), self.param_env);\n-        rcx.outlives_environment.add_implied_bounds(self, wf_tys, item_id, span);\n-        rcx.outlives_environment.save_implied_bounds(item_id);\n-        rcx.visit_region_obligations(item_id);\n-        rcx.resolve_regions_and_report_errors();\n-    }\n-\n-    /// Region check a function body. Not invoked on closures, but\n-    /// only on the \"root\" fn item (in which closures may be\n-    /// embedded). Walks the function body and adds various add'l\n-    /// constraints that are needed for region inference. This is\n-    /// separated both to isolate \"pure\" region constraints from the\n-    /// rest of type check and because sometimes we need type\n-    /// inference to have completed before we can determine which\n-    /// constraints to add.\n-    pub(crate) fn regionck_fn(\n-        &self,\n-        fn_id: hir::HirId,\n-        body: &'tcx hir::Body<'tcx>,\n-        span: Span,\n-        wf_tys: FxHashSet<Ty<'tcx>>,\n-    ) {\n-        debug!(\"regionck_fn(id={})\", fn_id);\n-        let subject = self.tcx.hir().body_owner_def_id(body.id());\n-        let hir_id = body.value.hir_id;\n-        let mut rcx = RegionCtxt::new(self, hir_id, Subject(subject), self.param_env);\n-        // We need to add the implied bounds from the function signature\n-        rcx.outlives_environment.add_implied_bounds(self, wf_tys, fn_id, span);\n-        rcx.outlives_environment.save_implied_bounds(fn_id);\n-\n-        if !self.errors_reported_since_creation() {\n-            // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, body, self.tcx.hir().span(fn_id));\n-        }\n-\n-        // Checked by NLL\n-        rcx.fcx.skip_region_resolution();\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// INTERNALS\n-\n-pub struct RegionCtxt<'a, 'tcx> {\n-    pub fcx: &'a FnCtxt<'a, 'tcx>,\n-\n-    outlives_environment: OutlivesEnvironment<'tcx>,\n-\n-    // id of innermost fn body id\n-    body_id: hir::HirId,\n-    body_owner: LocalDefId,\n-\n-    // id of AST node being analyzed (the subject of the analysis).\n-    subject_def_id: LocalDefId,\n-}\n-\n-impl<'a, 'tcx> Deref for RegionCtxt<'a, 'tcx> {\n-    type Target = FnCtxt<'a, 'tcx>;\n-    fn deref(&self) -> &Self::Target {\n-        self.fcx\n-    }\n-}\n-\n-pub struct Subject(LocalDefId);\n-\n-impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n-    pub fn new(\n-        fcx: &'a FnCtxt<'a, 'tcx>,\n-        initial_body_id: hir::HirId,\n-        Subject(subject): Subject,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> RegionCtxt<'a, 'tcx> {\n-        let outlives_environment = OutlivesEnvironment::new(param_env);\n-        RegionCtxt {\n-            fcx,\n-            body_id: initial_body_id,\n-            body_owner: subject,\n-            subject_def_id: subject,\n-            outlives_environment,\n-        }\n-    }\n-\n-    /// Try to resolve the type for the given node, returning `t_err` if an error results. Note that\n-    /// we never care about the details of the error, the same error will be detected and reported\n-    /// in the writeback phase.\n-    ///\n-    /// Note one important point: we do not attempt to resolve *region variables* here. This is\n-    /// because regionck is essentially adding constraints to those region variables and so may yet\n-    /// influence how they are resolved.\n-    ///\n-    /// Consider this silly example:\n-    ///\n-    /// ```ignore UNSOLVED (does replacing @i32 with Box<i32> preserve the desired semantics for the example?)\n-    /// fn borrow(x: &i32) -> &i32 {x}\n-    /// fn foo(x: @i32) -> i32 {  // block: B\n-    ///     let b = borrow(x);    // region: <R0>\n-    ///     *b\n-    /// }\n-    /// ```\n-    ///\n-    /// Here, the region of `b` will be `<R0>`. `<R0>` is constrained to be some subregion of the\n-    /// block B and some superregion of the call. If we forced it now, we'd choose the smaller\n-    /// region (the call). But that would make the *b illegal. Since we don't resolve, the type\n-    /// of b will be `&<R0>.i32` and then `*b` will require that `<R0>` be bigger than the let and\n-    /// the `*b` expression, so we will effectively resolve `<R0>` to be the block B.\n-    pub fn resolve_type(&self, unresolved_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.resolve_vars_if_possible(unresolved_ty)\n-    }\n-\n-    /// Try to resolve the type for the given node.\n-    fn resolve_node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n-        let t = self.node_ty(id);\n-        self.resolve_type(t)\n-    }\n-\n-    /// This is the \"main\" function when region-checking a function item or a\n-    /// closure within a function item. It begins by updating various fields\n-    /// (e.g., `outlives_environment`) to be appropriate to the function and\n-    /// then adds constraints derived from the function body.\n-    ///\n-    /// Note that it does **not** restore the state of the fields that\n-    /// it updates! This is intentional, since -- for the main\n-    /// function -- we wish to be able to read the final\n-    /// `outlives_environment` and other fields from the caller. For\n-    /// closures, however, we save and restore any \"scoped state\"\n-    /// before we invoke this function. (See `visit_fn` in the\n-    /// `intravisit::Visitor` impl below.)\n-    fn visit_fn_body(\n-        &mut self,\n-        id: hir::HirId, // the id of the fn itself\n-        body: &'tcx hir::Body<'tcx>,\n-        span: Span,\n-    ) {\n-        // When we enter a function, we can derive\n-        debug!(\"visit_fn_body(id={:?})\", id);\n-\n-        let body_id = body.id();\n-        self.body_id = body_id.hir_id;\n-        self.body_owner = self.tcx.hir().body_owner_def_id(body_id);\n-\n-        let Some(fn_sig) = self.typeck_results.borrow().liberated_fn_sigs().get(id) else {\n-            bug!(\"No fn-sig entry for id={:?}\", id);\n-        };\n-\n-        // Collect the types from which we create inferred bounds.\n-        // For the return type, if diverging, substitute `bool` just\n-        // because it will have no effect.\n-        //\n-        // FIXME(#27579) return types should not be implied bounds\n-        let fn_sig_tys: FxHashSet<_> =\n-            fn_sig.inputs().iter().cloned().chain(Some(fn_sig.output())).collect();\n-\n-        self.outlives_environment.add_implied_bounds(self.fcx, fn_sig_tys, body_id.hir_id, span);\n-        self.outlives_environment.save_implied_bounds(body_id.hir_id);\n-        self.link_fn_params(body.params);\n-        self.visit_body(body);\n-        self.visit_region_obligations(body_id.hir_id);\n-    }\n-\n-    fn visit_inline_const(&mut self, id: hir::HirId, body: &'tcx hir::Body<'tcx>) {\n-        debug!(\"visit_inline_const(id={:?})\", id);\n-\n-        // Save state of current function. We will restore afterwards.\n-        let old_body_id = self.body_id;\n-        let old_body_owner = self.body_owner;\n-        let env_snapshot = self.outlives_environment.push_snapshot_pre_typeck_child();\n-\n-        let body_id = body.id();\n-        self.body_id = body_id.hir_id;\n-        self.body_owner = self.tcx.hir().body_owner_def_id(body_id);\n-\n-        self.outlives_environment.save_implied_bounds(body_id.hir_id);\n-\n-        self.visit_body(body);\n-        self.visit_region_obligations(body_id.hir_id);\n-\n-        // Restore state from previous function.\n-        self.outlives_environment.pop_snapshot_post_typeck_child(env_snapshot);\n-        self.body_id = old_body_id;\n-        self.body_owner = old_body_owner;\n-    }\n-\n-    fn visit_region_obligations(&mut self, hir_id: hir::HirId) {\n-        debug!(\"visit_region_obligations: hir_id={:?}\", hir_id);\n-\n-        // region checking can introduce new pending obligations\n-        // which, when processed, might generate new region\n-        // obligations. So make sure we process those.\n-        self.select_all_obligations_or_error();\n-    }\n-\n-    fn resolve_regions_and_report_errors(&self) {\n-        self.infcx.process_registered_region_obligations(\n-            self.outlives_environment.region_bound_pairs_map(),\n-            self.param_env,\n-        );\n-\n-        self.fcx.resolve_regions_and_report_errors(\n-            self.subject_def_id.to_def_id(),\n-            &self.outlives_environment,\n-        );\n-    }\n-\n-    fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat<'_>) {\n-        debug!(\"regionck::visit_pat(pat={:?})\", pat);\n-        pat.each_binding(|_, hir_id, span, _| {\n-            let typ = self.resolve_node_type(hir_id);\n-            let body_id = self.body_id;\n-            dropck::check_drop_obligations(self, typ, span, body_id);\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n-    // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n-    // However, right now we run into an issue whereby some free\n-    // regions are not properly related if they appear within the\n-    // types of arguments that must be inferred. This could be\n-    // addressed by deferring the construction of the region\n-    // hierarchy, and in particular the relationships between free\n-    // regions, until regionck, as described in #3238.\n-\n-    fn visit_fn(\n-        &mut self,\n-        fk: intravisit::FnKind<'tcx>,\n-        _: &'tcx hir::FnDecl<'tcx>,\n-        body_id: hir::BodyId,\n-        span: Span,\n-        hir_id: hir::HirId,\n-    ) {\n-        assert!(\n-            matches!(fk, intravisit::FnKind::Closure),\n-            \"visit_fn invoked for something other than a closure\"\n-        );\n-\n-        // Save state of current function before invoking\n-        // `visit_fn_body`.  We will restore afterwards.\n-        let old_body_id = self.body_id;\n-        let old_body_owner = self.body_owner;\n-        let env_snapshot = self.outlives_environment.push_snapshot_pre_typeck_child();\n-\n-        let body = self.tcx.hir().body(body_id);\n-        self.visit_fn_body(hir_id, body, span);\n-\n-        // Restore state from previous function.\n-        self.outlives_environment.pop_snapshot_post_typeck_child(env_snapshot);\n-        self.body_id = old_body_id;\n-        self.body_owner = old_body_owner;\n-    }\n-\n-    //visit_pat: visit_pat, // (..) see above\n-\n-    fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n-        // see above\n-        self.constrain_bindings_in_pat(arm.pat);\n-        intravisit::walk_arm(self, arm);\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n-        // see above\n-        self.constrain_bindings_in_pat(l.pat);\n-        self.link_local(l);\n-        intravisit::walk_local(self, l);\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n-        // Check any autoderefs or autorefs that appear.\n-        let cmt_result = self.constrain_adjustments(expr);\n-\n-        // If necessary, constrain destructors in this expression. This will be\n-        // the adjusted form if there is an adjustment.\n-        match cmt_result {\n-            Ok(head_cmt) => {\n-                self.check_safety_of_rvalue_destructor_if_necessary(&head_cmt, expr.span);\n-            }\n-            Err(..) => {\n-                self.tcx.sess.delay_span_bug(expr.span, \"cat_expr Errd\");\n-            }\n-        }\n-\n-        match expr.kind {\n-            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, ref base) => {\n-                self.link_addr_of(expr, m, base);\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::Match(ref discr, arms, _) => {\n-                self.link_match(discr, arms);\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::ConstBlock(anon_const) => {\n-                let body = self.tcx.hir().body(anon_const.body);\n-                self.visit_inline_const(anon_const.hir_id, body);\n-            }\n-\n-            _ => intravisit::walk_expr(self, expr),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n-    /// Creates a temporary `MemCategorizationContext` and pass it to the closure.\n-    fn with_mc<F, R>(&self, f: F) -> R\n-    where\n-        F: for<'b> FnOnce(mc::MemCategorizationContext<'b, 'tcx>) -> R,\n-    {\n-        f(mc::MemCategorizationContext::new(\n-            &self.infcx,\n-            self.outlives_environment.param_env,\n-            self.body_owner,\n-            &self.typeck_results.borrow(),\n-        ))\n-    }\n-\n-    /// Invoked on any adjustments that occur. Checks that if this is a region pointer being\n-    /// dereferenced, the lifetime of the pointer includes the deref expr.\n-    fn constrain_adjustments(\n-        &mut self,\n-        expr: &hir::Expr<'_>,\n-    ) -> mc::McResult<PlaceWithHirId<'tcx>> {\n-        debug!(\"constrain_adjustments(expr={:?})\", expr);\n-\n-        let mut place = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n-\n-        let typeck_results = self.typeck_results.borrow();\n-        let adjustments = typeck_results.expr_adjustments(expr);\n-        if adjustments.is_empty() {\n-            return Ok(place);\n-        }\n-\n-        debug!(\"constrain_adjustments: adjustments={:?}\", adjustments);\n-\n-        // If necessary, constrain destructors in the unadjusted form of this\n-        // expression.\n-        self.check_safety_of_rvalue_destructor_if_necessary(&place, expr.span);\n-\n-        for adjustment in adjustments {\n-            debug!(\"constrain_adjustments: adjustment={:?}, place={:?}\", adjustment, place);\n-\n-            if let adjustment::Adjust::Deref(Some(deref)) = adjustment.kind {\n-                self.link_region(\n-                    expr.span,\n-                    deref.region,\n-                    ty::BorrowKind::from_mutbl(deref.mutbl),\n-                    &place,\n-                );\n-            }\n-\n-            if let adjustment::Adjust::Borrow(ref autoref) = adjustment.kind {\n-                self.link_autoref(expr, &place, autoref);\n-            }\n-\n-            place = self.with_mc(|mc| mc.cat_expr_adjusted(expr, place, adjustment))?;\n-        }\n-\n-        Ok(place)\n-    }\n-\n-    fn check_safety_of_rvalue_destructor_if_necessary(\n-        &mut self,\n-        place_with_id: &PlaceWithHirId<'tcx>,\n-        span: Span,\n-    ) {\n-        if let PlaceBase::Rvalue = place_with_id.place.base {\n-            if place_with_id.place.projections.is_empty() {\n-                let typ = self.resolve_type(place_with_id.place.ty());\n-                let body_id = self.body_id;\n-                dropck::check_drop_obligations(self, typ, span, body_id);\n-            }\n-        }\n-    }\n-    /// Adds constraints to inference such that `T: 'a` holds (or\n-    /// reports an error if it cannot).\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `origin`, the reason we need this constraint\n-    /// - `ty`, the type `T`\n-    /// - `region`, the region `'a`\n-    pub fn type_must_outlive(\n-        &self,\n-        origin: infer::SubregionOrigin<'tcx>,\n-        ty: Ty<'tcx>,\n-        region: ty::Region<'tcx>,\n-    ) {\n-        self.infcx.register_region_obligation(\n-            self.body_id,\n-            RegionObligation { sub_region: region, sup_type: ty, origin },\n-        );\n-    }\n-\n-    /// Computes the guarantor for an expression `&base` and then ensures that the lifetime of the\n-    /// resulting pointer is linked to the lifetime of its guarantor (if any).\n-    fn link_addr_of(\n-        &mut self,\n-        expr: &hir::Expr<'_>,\n-        mutability: hir::Mutability,\n-        base: &hir::Expr<'_>,\n-    ) {\n-        debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n-\n-        let cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(base)));\n-\n-        debug!(\"link_addr_of: cmt={:?}\", cmt);\n-\n-        self.link_region_from_node_type(expr.span, expr.hir_id, mutability, &cmt);\n-    }\n-\n-    /// Computes the guarantors for any ref bindings in a `let` and\n-    /// then ensures that the lifetime of the resulting pointer is\n-    /// linked to the lifetime of the initialization expression.\n-    fn link_local(&self, local: &hir::Local<'_>) {\n-        debug!(\"regionck::for_local()\");\n-        let init_expr = match local.init {\n-            None => {\n-                return;\n-            }\n-            Some(expr) => &*expr,\n-        };\n-        let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(init_expr)));\n-        self.link_pattern(discr_cmt, local.pat);\n-    }\n-\n-    /// Computes the guarantors for any ref bindings in a match and\n-    /// then ensures that the lifetime of the resulting pointer is\n-    /// linked to the lifetime of its guarantor (if any).\n-    fn link_match(&self, discr: &hir::Expr<'_>, arms: &[hir::Arm<'_>]) {\n-        debug!(\"regionck::for_match()\");\n-        let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(discr)));\n-        debug!(\"discr_cmt={:?}\", discr_cmt);\n-        for arm in arms {\n-            self.link_pattern(discr_cmt.clone(), arm.pat);\n-        }\n-    }\n-\n-    /// Computes the guarantors for any ref bindings in a match and\n-    /// then ensures that the lifetime of the resulting pointer is\n-    /// linked to the lifetime of its guarantor (if any).\n-    fn link_fn_params(&self, params: &[hir::Param<'_>]) {\n-        for param in params {\n-            let param_ty = self.node_ty(param.hir_id);\n-            let param_cmt =\n-                self.with_mc(|mc| mc.cat_rvalue(param.hir_id, param.pat.span, param_ty));\n-            debug!(\"param_ty={:?} param_cmt={:?} param={:?}\", param_ty, param_cmt, param);\n-            self.link_pattern(param_cmt, param.pat);\n-        }\n-    }\n-\n-    /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n-    /// in the discriminant, if needed.\n-    fn link_pattern(&self, discr_cmt: PlaceWithHirId<'tcx>, root_pat: &hir::Pat<'_>) {\n-        debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\", discr_cmt, root_pat);\n-        ignore_err!(self.with_mc(|mc| {\n-            mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id, .. }| {\n-                // `ref x` pattern\n-                if let PatKind::Binding(..) = kind\n-                    && let Some(ty::BindByReference(mutbl)) = mc.typeck_results.extract_binding_mode(self.tcx.sess, *hir_id, *span) {\n-                    self.link_region_from_node_type(*span, *hir_id, mutbl, sub_cmt);\n-                }\n-            })\n-        }));\n-    }\n-\n-    /// Link lifetime of borrowed pointer resulting from autoref to lifetimes in the value being\n-    /// autoref'd.\n-    fn link_autoref(\n-        &self,\n-        expr: &hir::Expr<'_>,\n-        expr_cmt: &PlaceWithHirId<'tcx>,\n-        autoref: &adjustment::AutoBorrow<'tcx>,\n-    ) {\n-        debug!(\"link_autoref(autoref={:?}, expr_cmt={:?})\", autoref, expr_cmt);\n-\n-        match *autoref {\n-            adjustment::AutoBorrow::Ref(r, m) => {\n-                self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m.into()), expr_cmt);\n-            }\n-\n-            adjustment::AutoBorrow::RawPtr(_) => {}\n-        }\n-    }\n-\n-    /// Like `link_region()`, except that the region is extracted from the type of `id`,\n-    /// which must be some reference (`&T`, `&str`, etc).\n-    fn link_region_from_node_type(\n-        &self,\n-        span: Span,\n-        id: hir::HirId,\n-        mutbl: hir::Mutability,\n-        cmt_borrowed: &PlaceWithHirId<'tcx>,\n-    ) {\n-        debug!(\n-            \"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n-            id, mutbl, cmt_borrowed\n-        );\n-\n-        let rptr_ty = self.resolve_node_type(id);\n-        if let ty::Ref(r, _, _) = rptr_ty.kind() {\n-            debug!(\"rptr_ty={}\", rptr_ty);\n-            self.link_region(span, *r, ty::BorrowKind::from_mutbl(mutbl), cmt_borrowed);\n-        }\n-    }\n-\n-    /// Informs the inference engine that `borrow_cmt` is being borrowed with\n-    /// kind `borrow_kind` and lifetime `borrow_region`.\n-    /// In order to ensure borrowck is satisfied, this may create constraints\n-    /// between regions, as explained in `link_reborrowed_region()`.\n-    fn link_region(\n-        &self,\n-        span: Span,\n-        borrow_region: ty::Region<'tcx>,\n-        borrow_kind: ty::BorrowKind,\n-        borrow_place: &PlaceWithHirId<'tcx>,\n-    ) {\n-        let origin = infer::DataBorrowed(borrow_place.place.ty(), span);\n-        self.type_must_outlive(origin, borrow_place.place.ty(), borrow_region);\n-\n-        for pointer_ty in borrow_place.place.deref_tys() {\n-            debug!(\n-                \"link_region(borrow_region={:?}, borrow_kind={:?}, pointer_ty={:?})\",\n-                borrow_region, borrow_kind, borrow_place\n-            );\n-            match *pointer_ty.kind() {\n-                ty::RawPtr(_) => return,\n-                ty::Ref(ref_region, _, ref_mutability) => {\n-                    if self.link_reborrowed_region(span, borrow_region, ref_region, ref_mutability)\n-                    {\n-                        return;\n-                    }\n-                }\n-                _ => assert!(pointer_ty.is_box(), \"unexpected built-in deref type {}\", pointer_ty),\n-            }\n-        }\n-        if let PlaceBase::Upvar(upvar_id) = borrow_place.place.base {\n-            self.link_upvar_region(span, borrow_region, upvar_id);\n-        }\n-    }\n-\n-    /// This is the most complicated case: the path being borrowed is\n-    /// itself the referent of a borrowed pointer. Let me give an\n-    /// example fragment of code to make clear(er) the situation:\n-    ///\n-    /// ```ignore (incomplete Rust code)\n-    /// let r: &'a mut T = ...;  // the original reference \"r\" has lifetime 'a\n-    /// ...\n-    /// &'z *r                   // the reborrow has lifetime 'z\n-    /// ```\n-    ///\n-    /// Now, in this case, our primary job is to add the inference\n-    /// constraint that `'z <= 'a`. Given this setup, let's clarify the\n-    /// parameters in (roughly) terms of the example:\n-    ///\n-    /// ```plain,ignore (pseudo-Rust)\n-    /// A borrow of: `& 'z bk * r` where `r` has type `& 'a bk T`\n-    /// borrow_region   ^~                 ref_region    ^~\n-    /// borrow_kind        ^~               ref_kind        ^~\n-    /// ref_cmt                 ^\n-    /// ```\n-    ///\n-    /// Here `bk` stands for some borrow-kind (e.g., `mut`, `uniq`, etc).\n-    ///\n-    /// There is a complication beyond the simple scenario I just painted: there\n-    /// may in fact be more levels of reborrowing. In the example, I said the\n-    /// borrow was like `&'z *r`, but it might in fact be a borrow like\n-    /// `&'z **q` where `q` has type `&'a &'b mut T`. In that case, we want to\n-    /// ensure that `'z <= 'a` and `'z <= 'b`.\n-    ///\n-    /// The return value of this function indicates whether we *don't* need to\n-    /// the recurse to the next reference up.\n-    ///\n-    /// This is explained more below.\n-    fn link_reborrowed_region(\n-        &self,\n-        span: Span,\n-        borrow_region: ty::Region<'tcx>,\n-        ref_region: ty::Region<'tcx>,\n-        ref_mutability: hir::Mutability,\n-    ) -> bool {\n-        debug!(\"link_reborrowed_region: {:?} <= {:?}\", borrow_region, ref_region);\n-        self.sub_regions(infer::Reborrow(span), borrow_region, ref_region);\n-\n-        // Decide whether we need to recurse and link any regions within\n-        // the `ref_cmt`. This is concerned for the case where the value\n-        // being reborrowed is in fact a borrowed pointer found within\n-        // another borrowed pointer. For example:\n-        //\n-        //    let p: &'b &'a mut T = ...;\n-        //    ...\n-        //    &'z **p\n-        //\n-        // What makes this case particularly tricky is that, if the data\n-        // being borrowed is a `&mut` or `&uniq` borrow, borrowck requires\n-        // not only that `'z <= 'a`, (as before) but also `'z <= 'b`\n-        // (otherwise the user might mutate through the `&mut T` reference\n-        // after `'b` expires and invalidate the borrow we are looking at\n-        // now).\n-        //\n-        // So let's re-examine our parameters in light of this more\n-        // complicated (possible) scenario:\n-        //\n-        //     A borrow of: `& 'z bk * * p` where `p` has type `&'b bk & 'a bk T`\n-        //     borrow_region   ^~                 ref_region             ^~\n-        //     borrow_kind        ^~               ref_kind                 ^~\n-        //     ref_cmt                 ^~~\n-        //\n-        // (Note that since we have not examined `ref_cmt.cat`, we don't\n-        // know whether this scenario has occurred; but I wanted to show\n-        // how all the types get adjusted.)\n-        match ref_mutability {\n-            hir::Mutability::Not => {\n-                // The reference being reborrowed is a shareable ref of\n-                // type `&'a T`. In this case, it doesn't matter where we\n-                // *found* the `&T` pointer, the memory it references will\n-                // be valid and immutable for `'a`. So we can stop here.\n-                true\n-            }\n-\n-            hir::Mutability::Mut => {\n-                // The reference being reborrowed is either an `&mut T`. This is\n-                // the case where recursion is needed.\n-                false\n-            }\n-        }\n-    }\n-\n-    /// An upvar may be behind up to 2 references:\n-    ///\n-    /// * One can come from the reference to a \"by-reference\" upvar.\n-    /// * Another one can come from the reference to the closure itself if it's\n-    ///   a `FnMut` or `Fn` closure.\n-    ///\n-    /// This function links the lifetimes of those references to the lifetime\n-    /// of the borrow that's provided. See [RegionCtxt::link_reborrowed_region] for some\n-    /// more explanation of this in the general case.\n-    ///\n-    /// We also supply a *cause*, and in this case we set the cause to\n-    /// indicate that the reference being \"reborrowed\" is itself an upvar. This\n-    /// provides a nicer error message should something go wrong.\n-    fn link_upvar_region(\n-        &self,\n-        span: Span,\n-        borrow_region: ty::Region<'tcx>,\n-        upvar_id: ty::UpvarId,\n-    ) {\n-        debug!(\"link_upvar_region(borrorw_region={:?}, upvar_id={:?}\", borrow_region, upvar_id);\n-        // A by-reference upvar can't be borrowed for longer than the\n-        // upvar is borrowed from the environment.\n-        let closure_local_def_id = upvar_id.closure_expr_id;\n-        let mut all_captures_are_imm_borrow = true;\n-        for captured_place in self\n-            .typeck_results\n-            .borrow()\n-            .closure_min_captures\n-            .get(&closure_local_def_id.to_def_id())\n-            .and_then(|root_var_min_cap| root_var_min_cap.get(&upvar_id.var_path.hir_id))\n-            .into_iter()\n-            .flatten()\n-        {\n-            match captured_place.info.capture_kind {\n-                ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                    self.sub_regions(\n-                        infer::ReborrowUpvar(span, upvar_id),\n-                        borrow_region,\n-                        captured_place.region.unwrap(),\n-                    );\n-                    if let ty::ImmBorrow = upvar_borrow {\n-                        debug!(\"link_upvar_region: capture by shared ref\");\n-                    } else {\n-                        all_captures_are_imm_borrow = false;\n-                    }\n-                }\n-                ty::UpvarCapture::ByValue => {\n-                    all_captures_are_imm_borrow = false;\n-                }\n-            }\n-        }\n-        if all_captures_are_imm_borrow {\n-            return;\n-        }\n-        let fn_hir_id = self.tcx.hir().local_def_id_to_hir_id(closure_local_def_id);\n-        let ty = self.resolve_node_type(fn_hir_id);\n-        debug!(\"link_upvar_region: ty={:?}\", ty);\n-\n-        // A closure capture can't be borrowed for longer than the\n-        // reference to the closure.\n-        if let ty::Closure(_, substs) = ty.kind() {\n-            match self.infcx.closure_kind(substs) {\n-                Some(ty::ClosureKind::Fn | ty::ClosureKind::FnMut) => {\n-                    // Region of environment pointer\n-                    let env_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                        scope: upvar_id.closure_expr_id.to_def_id(),\n-                        bound_region: ty::BrEnv,\n-                    }));\n-                    self.sub_regions(\n-                        infer::ReborrowUpvar(span, upvar_id),\n-                        borrow_region,\n-                        env_region,\n-                    );\n-                }\n-                Some(ty::ClosureKind::FnOnce) => {}\n-                None => {\n-                    span_bug!(span, \"Have not inferred closure kind before regionck\");\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "c76c3a4c7baee14901ffeed19ed7daaf8432d5dd", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -62,7 +62,10 @@ impl<'tcx> CheckWfFcxBuilder<'tcx> {\n             }\n             let wf_tys = f(&fcx);\n             fcx.select_all_obligations_or_error();\n-            fcx.regionck_item(id, span, wf_tys);\n+\n+            let mut outlives_environment = OutlivesEnvironment::new(param_env);\n+            outlives_environment.add_implied_bounds(&fcx.infcx, wf_tys, id);\n+            fcx.infcx.check_region_obligations_and_report_errors(&outlives_environment);\n         });\n     }\n }\n@@ -655,13 +658,12 @@ fn resolve_regions_with_wf_tys<'tcx>(\n     // call individually.\n     tcx.infer_ctxt().enter(|infcx| {\n         let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-        outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id, DUMMY_SP);\n-        outlives_environment.save_implied_bounds(id);\n-        let region_bound_pairs = outlives_environment.region_bound_pairs_map().get(&id).unwrap();\n+        outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id);\n+        let region_bound_pairs = outlives_environment.region_bound_pairs();\n \n         add_constraints(&infcx, region_bound_pairs);\n \n-        let errors = infcx.resolve_regions(id.expect_owner().to_def_id(), &outlives_environment);\n+        let errors = infcx.resolve_regions(&outlives_environment);\n \n         debug!(?errors, \"errors\");\n "}, {"sha": "ec4fe3c4203234340ed90122dad847af61d469ed", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -349,7 +349,7 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n \n                     // Finally, resolve all regions.\n                     let outlives_env = OutlivesEnvironment::new(param_env);\n-                    infcx.resolve_regions_and_report_errors(impl_did.to_def_id(), &outlives_env);\n+                    infcx.resolve_regions_and_report_errors(&outlives_env);\n                 }\n             }\n             _ => {\n@@ -606,7 +606,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n \n         // Finally, resolve all regions.\n         let outlives_env = OutlivesEnvironment::new(param_env);\n-        infcx.resolve_regions_and_report_errors(impl_did.to_def_id(), &outlives_env);\n+        infcx.resolve_regions_and_report_errors(&outlives_env);\n \n         CoerceUnsizedInfo { custom_kind: kind }\n     })"}, {"sha": "66b121d75c523ecfd542fb1ab605a129758704bb", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -150,7 +150,7 @@ fn get_impl_substs<'tcx>(\n \n     // Conservatively use an empty `ParamEnv`.\n     let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n-    infcx.resolve_regions_and_report_errors(impl1_def_id.to_def_id(), &outlives_env);\n+    infcx.resolve_regions_and_report_errors(&outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n         let span = tcx.def_span(impl1_def_id);\n         tcx.sess.emit_err(SubstsOnOverriddenImpl { span });"}, {"sha": "70b8bcd02208ddd92c91beda2e14cd9fbf90d43b", "filename": "compiler/rustc_typeck/src/outlives/outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb171e2350de2bec6dd1f035b99bc00535c1c15/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Foutlives_bounds.rs?ref=efb171e2350de2bec6dd1f035b99bc00535c1c15", "patch": "@@ -1,6 +1,5 @@\n use rustc_hir as hir;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::source_map::Span;\n use rustc_trait_selection::infer::InferCtxt;\n use rustc_trait_selection::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n use rustc_trait_selection::traits::query::NoSolution;\n@@ -14,7 +13,6 @@ pub trait InferCtxtExt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         body_id: hir::HirId,\n         ty: Ty<'tcx>,\n-        span: Span,\n     ) -> Vec<OutlivesBound<'tcx>>;\n }\n \n@@ -38,16 +36,14 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     ///   Note that this may cause outlives obligations to be injected\n     ///   into the inference context with this body-id.\n     /// - `ty`, the type that we are supposed to assume is WF.\n-    /// - `span`, a span to use when normalizing, hopefully not important,\n-    ///   might be useful if a `bug!` occurs.\n-    #[instrument(level = \"debug\", skip(self, param_env, body_id, span))]\n+    #[instrument(level = \"debug\", skip(self, param_env, body_id))]\n     fn implied_outlives_bounds(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n         body_id: hir::HirId,\n         ty: Ty<'tcx>,\n-        span: Span,\n     ) -> Vec<OutlivesBound<'tcx>> {\n+        let span = self.tcx.hir().span(body_id);\n         let result = param_env\n             .and(type_op::implied_outlives_bounds::ImpliedOutlivesBounds { ty })\n             .fully_perform(self);"}]}