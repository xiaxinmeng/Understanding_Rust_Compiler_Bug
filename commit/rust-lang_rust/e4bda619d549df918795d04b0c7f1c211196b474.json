{"sha": "e4bda619d549df918795d04b0c7f1c211196b474", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0YmRhNjE5ZDU0OWRmOTE4Nzk1ZDA0YjBjN2YxYzIxMTE5NmI0NzQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-06T11:22:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-06T11:22:17Z"}, "message": "Rollup merge of #71889 - RalfJung:rwlock, r=Amanieu\n\nExplain our RwLock implementation\n\nTurns out that [with the latest POSIX docs](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_wrlock.html), our `RwLock` implementation is actually correct. However, we cannot fully rely on that due to bugs in older glibc (fix released in 2016). Update the comments to explain that.\n\nI also clarified our Mutex docs a bit and fixed another instance of https://github.com/rust-lang/rust/pull/55865.\n\nr? @Amanieu\nFixes https://github.com/rust-lang/rust/issues/53127", "tree": {"sha": "60780f7b301f03e4914494aa54eb73d37648fc3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60780f7b301f03e4914494aa54eb73d37648fc3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4bda619d549df918795d04b0c7f1c211196b474", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJesp3pCRBK7hj4Ov3rIwAAdHIIAEMAXoAOYLsJ8mjySkww2yuZ\ncHcoUCN7CzntbG1ogMVs82Ntwr6xUHHulXpylB5S8lMOaiQgj9MO3cJazJtxMVM5\nGciFK8abmJuuGTcUGaQfzohsGav6rF2Hy5dgDwxf17FLsD3rvOfGMVvKovKn2/zW\niPaytE+FqVS9OkKhwxuQ2XiEHfeDmV4InD2dAS3aWVK0uzCl8iLM7/gNsIuWL12D\nDiH1B8S3hAuxtUnDv/C8uMZSl3uTFf//v9hpxSeMtzPjGfvypzfbxrwyBCgyUJuR\nji0DkL4IarQjkPPEts1v3R6D0jVr/zDnkcfigYd5u/v6IMa93EPkk8L7hAKdWqg=\n=GW5D\n-----END PGP SIGNATURE-----\n", "payload": "tree 60780f7b301f03e4914494aa54eb73d37648fc3c\nparent 3f56b84182dfa9aea0cd60d6be26e840ca5e210e\nparent f9866f95afad4ea97b975631c6016aa951fd4f83\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588764137 +0200\ncommitter GitHub <noreply@github.com> 1588764137 +0200\n\nRollup merge of #71889 - RalfJung:rwlock, r=Amanieu\n\nExplain our RwLock implementation\n\nTurns out that [with the latest POSIX docs](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_wrlock.html), our `RwLock` implementation is actually correct. However, we cannot fully rely on that due to bugs in older glibc (fix released in 2016). Update the comments to explain that.\n\nI also clarified our Mutex docs a bit and fixed another instance of https://github.com/rust-lang/rust/pull/55865.\n\nr? @Amanieu\nFixes https://github.com/rust-lang/rust/issues/53127\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4bda619d549df918795d04b0c7f1c211196b474", "html_url": "https://github.com/rust-lang/rust/commit/e4bda619d549df918795d04b0c7f1c211196b474", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4bda619d549df918795d04b0c7f1c211196b474/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f56b84182dfa9aea0cd60d6be26e840ca5e210e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f56b84182dfa9aea0cd60d6be26e840ca5e210e", "html_url": "https://github.com/rust-lang/rust/commit/3f56b84182dfa9aea0cd60d6be26e840ca5e210e"}, {"sha": "f9866f95afad4ea97b975631c6016aa951fd4f83", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9866f95afad4ea97b975631c6016aa951fd4f83", "html_url": "https://github.com/rust-lang/rust/commit/f9866f95afad4ea97b975631c6016aa951fd4f83"}], "stats": {"total": 58, "additions": 36, "deletions": 22}, "files": [{"sha": "45c600f75f5cf577a03b4bfda78c5be6f275f275", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4bda619d549df918795d04b0c7f1c211196b474/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4bda619d549df918795d04b0c7f1c211196b474/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=e4bda619d549df918795d04b0c7f1c211196b474", "patch": "@@ -28,14 +28,20 @@ impl Mutex {\n         //\n         // A pthread mutex initialized with PTHREAD_MUTEX_INITIALIZER will have\n         // a type of PTHREAD_MUTEX_DEFAULT, which has undefined behavior if you\n-        // try to re-lock it from the same thread when you already hold a lock.\n+        // try to re-lock it from the same thread when you already hold a lock\n+        // (https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html).\n+        // This is the case even if PTHREAD_MUTEX_DEFAULT == PTHREAD_MUTEX_NORMAL\n+        // (https://github.com/rust-lang/rust/issues/33770#issuecomment-220847521) -- in that\n+        // case, `pthread_mutexattr_settype(PTHREAD_MUTEX_DEFAULT)` will of course be the same\n+        // as setting it to `PTHREAD_MUTEX_NORMAL`, but not setting any mode will result in\n+        // a Mutex where re-locking is UB.\n         //\n         // In practice, glibc takes advantage of this undefined behavior to\n         // implement hardware lock elision, which uses hardware transactional\n         // memory to avoid acquiring the lock. While a transaction is in\n         // progress, the lock appears to be unlocked. This isn't a problem for\n         // other threads since the transactional memory will abort if a conflict\n-        // is detected, however no abort is generated if re-locking from the\n+        // is detected, however no abort is generated when re-locking from the\n         // same thread.\n         //\n         // Since locking the same mutex twice will result in two aliasing &mut"}, {"sha": "2b5067a34f648fa41baa290706ad3a53a347cce3", "filename": "src/libstd/sys/unix/rwlock.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e4bda619d549df918795d04b0c7f1c211196b474/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4bda619d549df918795d04b0c7f1c211196b474/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs?ref=e4bda619d549df918795d04b0c7f1c211196b474", "patch": "@@ -22,32 +22,33 @@ impl RWLock {\n     pub unsafe fn read(&self) {\n         let r = libc::pthread_rwlock_rdlock(self.inner.get());\n \n-        // According to the pthread_rwlock_rdlock spec, this function **may**\n-        // fail with EDEADLK if a deadlock is detected. On the other hand\n-        // pthread mutexes will *never* return EDEADLK if they are initialized\n-        // as the \"fast\" kind (which ours always are). As a result, a deadlock\n-        // situation may actually return from the call to pthread_rwlock_rdlock\n-        // instead of blocking forever (as mutexes and Windows rwlocks do). Note\n-        // that not all unix implementations, however, will return EDEADLK for\n-        // their rwlocks.\n+        // According to POSIX, when a thread tries to acquire this read lock\n+        // while it already holds the write lock\n+        // (or vice versa, or tries to acquire the write lock twice),\n+        // \"the call shall either deadlock or return [EDEADLK]\"\n+        // (https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_wrlock.html,\n+        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_rdlock.html).\n+        // So, in principle, all we have to do here is check `r == 0` to be sure we properly\n+        // got the lock.\n         //\n-        // We roughly maintain the deadlocking behavior by panicking to ensure\n-        // that this lock acquisition does not succeed.\n-        //\n-        // We also check whether this lock is already write locked. This\n-        // is only possible if it was write locked by the current thread and\n-        // the implementation allows recursive locking. The POSIX standard\n-        // doesn't require recursively locking a rwlock to deadlock, but we can't\n-        // allow that because it could lead to aliasing issues.\n+        // However, (at least) glibc before version 2.25 does not conform to this spec,\n+        // and can return `r == 0` even when this thread already holds the write lock.\n+        // We thus check for this situation ourselves and panic when detecting that a thread\n+        // got the write lock more than once, or got a read and a write lock.\n         if r == libc::EAGAIN {\n             panic!(\"rwlock maximum reader count exceeded\");\n         } else if r == libc::EDEADLK || (r == 0 && *self.write_locked.get()) {\n+            // Above, we make sure to only access `write_locked` when `r == 0` to avoid\n+            // data races.\n             if r == 0 {\n+                // `pthread_rwlock_rdlock` succeeded when it should not have.\n                 self.raw_unlock();\n             }\n             panic!(\"rwlock read lock would result in deadlock\");\n         } else {\n-            assert_eq!(r, 0);\n+            // According to POSIX, for a properly initialized rwlock this can only\n+            // return EAGAIN or EDEADLK or 0. We rely on that.\n+            debug_assert_eq!(r, 0);\n             self.num_readers.fetch_add(1, Ordering::Relaxed);\n         }\n     }\n@@ -56,6 +57,7 @@ impl RWLock {\n         let r = libc::pthread_rwlock_tryrdlock(self.inner.get());\n         if r == 0 {\n             if *self.write_locked.get() {\n+                // `pthread_rwlock_tryrdlock` succeeded when it should not have.\n                 self.raw_unlock();\n                 false\n             } else {\n@@ -69,17 +71,22 @@ impl RWLock {\n     #[inline]\n     pub unsafe fn write(&self) {\n         let r = libc::pthread_rwlock_wrlock(self.inner.get());\n-        // See comments above for why we check for EDEADLK and write_locked. We\n-        // also need to check that num_readers is 0.\n+        // See comments above for why we check for EDEADLK and write_locked. For the same reason,\n+        // we also need to check that there are no readers (tracked in `num_readers`).\n         if r == libc::EDEADLK\n-            || *self.write_locked.get()\n+            || (r == 0 && *self.write_locked.get())\n             || self.num_readers.load(Ordering::Relaxed) != 0\n         {\n+            // Above, we make sure to only access `write_locked` when `r == 0` to avoid\n+            // data races.\n             if r == 0 {\n+                // `pthread_rwlock_wrlock` succeeded when it should not have.\n                 self.raw_unlock();\n             }\n             panic!(\"rwlock write lock would result in deadlock\");\n         } else {\n+            // According to POSIX, for a properly initialized rwlock this can only\n+            // return EDEADLK or 0. We rely on that.\n             debug_assert_eq!(r, 0);\n         }\n         *self.write_locked.get() = true;\n@@ -89,6 +96,7 @@ impl RWLock {\n         let r = libc::pthread_rwlock_trywrlock(self.inner.get());\n         if r == 0 {\n             if *self.write_locked.get() || self.num_readers.load(Ordering::Relaxed) != 0 {\n+                // `pthread_rwlock_trywrlock` succeeded when it should not have.\n                 self.raw_unlock();\n                 false\n             } else {"}]}