{"sha": "a03d6da3ef7852cbcfcf98b7639b529b96587ca3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwM2Q2ZGEzZWY3ODUyY2JjZmNmOThiNzYzOWI1MjliOTY1ODdjYTM=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-08-02T02:03:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-02T02:03:19Z"}, "message": "Rollup merge of #86439 - CDirkx:ip-protocol-assignment, r=m-ou-se\n\nRemove `Ipv4Addr::is_ietf_protocol_assignment`\n\nThis PR removes the unstable method `Ipv4Addr::is_ietf_protocol_assignment`, as I suggested in https://github.com/rust-lang/rust/issues/85612#issuecomment-847863404. The method was added in #60145, as far as I can tell primarily for the implementation of `Ipv4Addr::is_global` (addresses reserved for IETF protocol assignment are not globally reachable unless otherwise specified).\n\nThe method was added in 2019, but I haven't been able to find any open-source code using this method so far. I'm also having a hard time coming up with a usecase for specifically this method; knowing that an address is reserved for future protocols doesn't allow you to do much with it, especially since now some of those addresses are indeed assigned to a protocol and have their own behaviour (and might even be defined to be globally reachable, so if that is what you care about it is always more accurate to call `!is_global()`, instead of `is_ietf_protocol_assignment()`).\n\nBecause of these reasons, I propose removing the method (or alternatively make it a private helper for `is_global`) and also not introduce `Ipv6Addr::is_ietf_protocol_assignment` and `IpAddr::is_ietf_protocol_assignment` in the future.", "tree": {"sha": "07b433868914e1d64e897429fafc0120b90c9972", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07b433868914e1d64e897429fafc0120b90c9972"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a03d6da3ef7852cbcfcf98b7639b529b96587ca3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhB1JnCRBK7hj4Ov3rIwAAz0gIADNouPAlPVVqTE2l7Tq0zFxT\nlm+nEoExWDLAGsubKy4p+y7iFuNDH/Zwmy0kq8HfSw38wVYhRf8DjPn35ZWydg3O\n7sXGQ01J3mmYxYp2Z2perVa/A58w+wr6j5PqtBeskIEF6prf+dGmKM2H7V2GWIUT\n4wdisFu98c+ybl5/oy/HfrvY7CbXxL35slbv4Xb8NENr2PiA6Nvn2eWyj5WwSVOS\nB39poIGXbZ5lDiXlWmIH4tnvVDjR6vb5gVhXlJDxbkRvHxxe9MVZFD+OkFbIsgjH\njYn26WFqLqFdoGnPa9r7VP7dPxbS6AUdcgXwsCeln1t//3rfsKkC6lE0HZtVGnk=\n=HuIB\n-----END PGP SIGNATURE-----\n", "payload": "tree 07b433868914e1d64e897429fafc0120b90c9972\nparent 016612dc8d9ed850a066bccd42e4d6f7816f0484\nparent a26237e634be7f94dbd40cc1204514f2b4c380d2\nauthor Yuki Okushi <jtitor@2k36.org> 1627869799 +0900\ncommitter GitHub <noreply@github.com> 1627869799 +0900\n\nRollup merge of #86439 - CDirkx:ip-protocol-assignment, r=m-ou-se\n\nRemove `Ipv4Addr::is_ietf_protocol_assignment`\n\nThis PR removes the unstable method `Ipv4Addr::is_ietf_protocol_assignment`, as I suggested in https://github.com/rust-lang/rust/issues/85612#issuecomment-847863404. The method was added in #60145, as far as I can tell primarily for the implementation of `Ipv4Addr::is_global` (addresses reserved for IETF protocol assignment are not globally reachable unless otherwise specified).\n\nThe method was added in 2019, but I haven't been able to find any open-source code using this method so far. I'm also having a hard time coming up with a usecase for specifically this method; knowing that an address is reserved for future protocols doesn't allow you to do much with it, especially since now some of those addresses are indeed assigned to a protocol and have their own behaviour (and might even be defined to be globally reachable, so if that is what you care about it is always more accurate to call `!is_global()`, instead of `is_ietf_protocol_assignment()`).\n\nBecause of these reasons, I propose removing the method (or alternatively make it a private helper for `is_global`) and also not introduce `Ipv6Addr::is_ietf_protocol_assignment` and `IpAddr::is_ietf_protocol_assignment` in the future.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a03d6da3ef7852cbcfcf98b7639b529b96587ca3", "html_url": "https://github.com/rust-lang/rust/commit/a03d6da3ef7852cbcfcf98b7639b529b96587ca3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a03d6da3ef7852cbcfcf98b7639b529b96587ca3/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "016612dc8d9ed850a066bccd42e4d6f7816f0484", "url": "https://api.github.com/repos/rust-lang/rust/commits/016612dc8d9ed850a066bccd42e4d6f7816f0484", "html_url": "https://github.com/rust-lang/rust/commit/016612dc8d9ed850a066bccd42e4d6f7816f0484"}, {"sha": "a26237e634be7f94dbd40cc1204514f2b4c380d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a26237e634be7f94dbd40cc1204514f2b4c380d2", "html_url": "https://github.com/rust-lang/rust/commit/a26237e634be7f94dbd40cc1204514f2b4c380d2"}], "stats": {"total": 57, "additions": 6, "deletions": 51}, "files": [{"sha": "929286a343b5d6b38e11b0d68cb16b3ca4e13475", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 3, "deletions": 37, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a03d6da3ef7852cbcfcf98b7639b529b96587ca3/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d6da3ef7852cbcfcf98b7639b529b96587ca3/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=a03d6da3ef7852cbcfcf98b7639b529b96587ca3", "patch": "@@ -486,8 +486,7 @@ impl Ipv4Addr {\n     /// - addresses used for documentation (see [`Ipv4Addr::is_documentation()`])\n     /// - the unspecified address (see [`Ipv4Addr::is_unspecified()`]), and the whole\n     ///   `0.0.0.0/8` block\n-    /// - addresses reserved for future protocols (see\n-    /// [`Ipv4Addr::is_ietf_protocol_assignment()`], except\n+    /// - addresses reserved for future protocols, except\n     /// `192.0.0.9/32` and `192.0.0.10/32` which are globally routable\n     /// - addresses reserved for future use (see [`Ipv4Addr::is_reserved()`]\n     /// - addresses reserved for networking devices benchmarking (see\n@@ -560,7 +559,8 @@ impl Ipv4Addr {\n             && !self.is_broadcast()\n             && !self.is_documentation()\n             && !self.is_shared()\n-            && !self.is_ietf_protocol_assignment()\n+            // addresses reserved for future protocols (`192.0.0.0/24`)\n+            && !(self.octets()[0] == 192 && self.octets()[1] == 0 && self.octets()[2] == 0)\n             && !self.is_reserved()\n             && !self.is_benchmarking()\n             // Make sure the address is not in 0.0.0.0/8\n@@ -589,40 +589,6 @@ impl Ipv4Addr {\n         self.octets()[0] == 100 && (self.octets()[1] & 0b1100_0000 == 0b0100_0000)\n     }\n \n-    /// Returns [`true`] if this address is part of `192.0.0.0/24`, which is reserved to\n-    /// IANA for IETF protocol assignments, as documented in [IETF RFC 6890].\n-    ///\n-    /// Note that parts of this block are in use:\n-    ///\n-    /// - `192.0.0.8/32` is the \"IPv4 dummy address\" (see [IETF RFC 7600])\n-    /// - `192.0.0.9/32` is the \"Port Control Protocol Anycast\" (see [IETF RFC 7723])\n-    /// - `192.0.0.10/32` is used for NAT traversal (see [IETF RFC 8155])\n-    ///\n-    /// [IETF RFC 6890]: https://tools.ietf.org/html/rfc6890\n-    /// [IETF RFC 7600]: https://tools.ietf.org/html/rfc7600\n-    /// [IETF RFC 7723]: https://tools.ietf.org/html/rfc7723\n-    /// [IETF RFC 8155]: https://tools.ietf.org/html/rfc8155\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 0).is_ietf_protocol_assignment(), true);\n-    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 8).is_ietf_protocol_assignment(), true);\n-    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 9).is_ietf_protocol_assignment(), true);\n-    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 255).is_ietf_protocol_assignment(), true);\n-    /// assert_eq!(Ipv4Addr::new(192, 0, 1, 0).is_ietf_protocol_assignment(), false);\n-    /// assert_eq!(Ipv4Addr::new(191, 255, 255, 255).is_ietf_protocol_assignment(), false);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[inline]\n-    pub const fn is_ietf_protocol_assignment(&self) -> bool {\n-        self.octets()[0] == 192 && self.octets()[1] == 0 && self.octets()[2] == 0\n-    }\n-\n     /// Returns [`true`] if this address part of the `198.18.0.0/15` range, which is reserved for\n     /// network devices benchmarking. This range is defined in [IETF RFC 2544] as `192.18.0.0`\n     /// through `198.19.255.255` but [errata 423] corrects it to `198.18.0.0/15`."}, {"sha": "dbfab9dde404e26a58804412fbd1ff9ccc594094", "filename": "library/std/src/net/ip/tests.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a03d6da3ef7852cbcfcf98b7639b529b96587ca3/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d6da3ef7852cbcfcf98b7639b529b96587ca3/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs?ref=a03d6da3ef7852cbcfcf98b7639b529b96587ca3", "patch": "@@ -339,7 +339,6 @@ fn ipv4_properties() {\n             let broadcast: u16 = 1 << 6;\n             let documentation: u16 = 1 << 7;\n             let benchmarking: u16 = 1 << 8;\n-            let ietf_protocol_assignment: u16 = 1 << 9;\n             let reserved: u16 = 1 << 10;\n             let shared: u16 = 1 << 11;\n \n@@ -397,12 +396,6 @@ fn ipv4_properties() {\n                 assert!(!ip!($s).is_benchmarking());\n             }\n \n-            if ($mask & ietf_protocol_assignment) == ietf_protocol_assignment {\n-                assert!(ip!($s).is_ietf_protocol_assignment());\n-            } else {\n-                assert!(!ip!($s).is_ietf_protocol_assignment());\n-            }\n-\n             if ($mask & reserved) == reserved {\n                 assert!(ip!($s).is_reserved());\n             } else {\n@@ -426,7 +419,6 @@ fn ipv4_properties() {\n     let broadcast: u16 = 1 << 6;\n     let documentation: u16 = 1 << 7;\n     let benchmarking: u16 = 1 << 8;\n-    let ietf_protocol_assignment: u16 = 1 << 9;\n     let reserved: u16 = 1 << 10;\n     let shared: u16 = 1 << 11;\n \n@@ -449,9 +441,9 @@ fn ipv4_properties() {\n     check!(\"198.18.0.0\", benchmarking);\n     check!(\"198.18.54.2\", benchmarking);\n     check!(\"198.19.255.255\", benchmarking);\n-    check!(\"192.0.0.0\", ietf_protocol_assignment);\n-    check!(\"192.0.0.255\", ietf_protocol_assignment);\n-    check!(\"192.0.0.100\", ietf_protocol_assignment);\n+    check!(\"192.0.0.0\");\n+    check!(\"192.0.0.255\");\n+    check!(\"192.0.0.100\");\n     check!(\"240.0.0.0\", reserved);\n     check!(\"251.54.1.76\", reserved);\n     check!(\"254.255.255.255\", reserved);\n@@ -823,9 +815,6 @@ fn ipv4_const() {\n     const IS_SHARED: bool = IP_ADDRESS.is_shared();\n     assert!(!IS_SHARED);\n \n-    const IS_IETF_PROTOCOL_ASSIGNMENT: bool = IP_ADDRESS.is_ietf_protocol_assignment();\n-    assert!(!IS_IETF_PROTOCOL_ASSIGNMENT);\n-\n     const IS_BENCHMARKING: bool = IP_ADDRESS.is_benchmarking();\n     assert!(!IS_BENCHMARKING);\n "}]}