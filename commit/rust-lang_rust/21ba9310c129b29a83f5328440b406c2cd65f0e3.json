{"sha": "21ba9310c129b29a83f5328440b406c2cd65f0e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxYmE5MzEwYzEyOWIyOWE4M2Y1MzI4NDQwYjQwNmMyY2Q2NWYwZTM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-22T16:08:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-22T16:08:22Z"}, "message": "Rollup merge of #61030 - spastorino:make-operand-iterate, r=oli-obk\n\nMake maybe_codegen_consume_direct iterate instead of doing recursion\n\nr? @oli-obk", "tree": {"sha": "739c43008f8a61a7afe634b9460b6e4a5ad1d16c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/739c43008f8a61a7afe634b9460b6e4a5ad1d16c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21ba9310c129b29a83f5328440b406c2cd65f0e3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc5XP2CRBK7hj4Ov3rIwAAdHIIAJGva+fOtmNS93/tfAYn8kTC\ngl4kFDhWPpGbyPmPaK/INBEjNt6ve3GJtGw6k0w30A8D9uIVWm2MDDDgphgLbEld\nF1tBiRkgl/kAaQh8+i+Dltr6xMGhXN5jY/HL1nmAPzJcUwfI22XeB+jVYV5rwAtw\nOZRgPT/9/6lPdW7v8n4gkzcIkz7t4hzH36r7jAyhyL9KZWqBsaGWgqncAXZDFzWp\nKGvqB/s+8psS4bGKgZ0MKeHqndbw5Y986rXM1KKlkLkqwneO9KhPxw8whoEZ7ll7\n+AyCQDufTL0n4yDFhQuHMR6P/fwgGfN9Y6080LuIghFDzE52BMe7cMN+/FfEneI=\n=Xz/g\n-----END PGP SIGNATURE-----\n", "payload": "tree 739c43008f8a61a7afe634b9460b6e4a5ad1d16c\nparent 9abc9361fa78374c748c0188008cc71f1c25708f\nparent 3fd4b22bce195e5c12e478296c8e0c03de6c8331\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1558541302 +0200\ncommitter GitHub <noreply@github.com> 1558541302 +0200\n\nRollup merge of #61030 - spastorino:make-operand-iterate, r=oli-obk\n\nMake maybe_codegen_consume_direct iterate instead of doing recursion\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21ba9310c129b29a83f5328440b406c2cd65f0e3", "html_url": "https://github.com/rust-lang/rust/commit/21ba9310c129b29a83f5328440b406c2cd65f0e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21ba9310c129b29a83f5328440b406c2cd65f0e3/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9abc9361fa78374c748c0188008cc71f1c25708f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9abc9361fa78374c748c0188008cc71f1c25708f", "html_url": "https://github.com/rust-lang/rust/commit/9abc9361fa78374c748c0188008cc71f1c25708f"}, {"sha": "3fd4b22bce195e5c12e478296c8e0c03de6c8331", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fd4b22bce195e5c12e478296c8e0c03de6c8331", "html_url": "https://github.com/rust-lang/rust/commit/3fd4b22bce195e5c12e478296c8e0c03de6c8331"}], "stats": {"total": 70, "additions": 36, "deletions": 34}, "files": [{"sha": "3db05b7214d659578533a4cc4ca701dc8ef9d5ce", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/21ba9310c129b29a83f5328440b406c2cd65f0e3/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba9310c129b29a83f5328440b406c2cd65f0e3/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=21ba9310c129b29a83f5328440b406c2cd65f0e3", "patch": "@@ -380,45 +380,47 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Option<OperandRef<'tcx, Bx::Value>> {\n         debug!(\"maybe_codegen_consume_direct(place={:?})\", place);\n \n-        // watch out for locals that do not have an\n-        // alloca; they are handled somewhat differently\n-        if let mir::Place::Base(mir::PlaceBase::Local(index)) = *place {\n-            match self.locals[index] {\n-                LocalRef::Operand(Some(o)) => {\n-                    return Some(o);\n-                }\n-                LocalRef::Operand(None) => {\n-                    bug!(\"use of {:?} before def\", place);\n-                }\n-                LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n-                    // use path below\n-                }\n-            }\n-        }\n+        place.iterate(|place_base, place_projection| {\n+            if let mir::PlaceBase::Local(index) = place_base {\n+                match self.locals[*index] {\n+                    LocalRef::Operand(Some(mut o)) => {\n+                        // Moves out of scalar and scalar pair fields are trivial.\n+                        for proj in place_projection {\n+                            match proj.elem {\n+                                mir::ProjectionElem::Field(ref f, _) => {\n+                                    o = o.extract_field(bx, f.index());\n+                                }\n+                                mir::ProjectionElem::Index(_) |\n+                                mir::ProjectionElem::ConstantIndex { .. } => {\n+                                    // ZSTs don't require any actual memory access.\n+                                    // FIXME(eddyb) deduplicate this with the identical\n+                                    // checks in `codegen_consume` and `extract_field`.\n+                                    let elem = o.layout.field(bx.cx(), 0);\n+                                    if elem.is_zst() {\n+                                        o = OperandRef::new_zst(bx, elem);\n+                                    } else {\n+                                        return None;\n+                                    }\n+                                }\n+                                _ => return None,\n+                            }\n+                        }\n \n-        // Moves out of scalar and scalar pair fields are trivial.\n-        if let &mir::Place::Projection(ref proj) = place {\n-            if let Some(o) = self.maybe_codegen_consume_direct(bx, &proj.base) {\n-                match proj.elem {\n-                    mir::ProjectionElem::Field(ref f, _) => {\n-                        return Some(o.extract_field(bx, f.index()));\n+                        Some(o)\n                     }\n-                    mir::ProjectionElem::Index(_) |\n-                    mir::ProjectionElem::ConstantIndex { .. } => {\n-                        // ZSTs don't require any actual memory access.\n-                        // FIXME(eddyb) deduplicate this with the identical\n-                        // checks in `codegen_consume` and `extract_field`.\n-                        let elem = o.layout.field(bx.cx(), 0);\n-                        if elem.is_zst() {\n-                            return Some(OperandRef::new_zst(bx, elem));\n-                        }\n+                    LocalRef::Operand(None) => {\n+                        bug!(\"use of {:?} before def\", place);\n+                    }\n+                    LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n+                        // watch out for locals that do not have an\n+                        // alloca; they are handled somewhat differently\n+                        None\n                     }\n-                    _ => {}\n                 }\n+            } else {\n+                None\n             }\n-        }\n-\n-        None\n+        })\n     }\n \n     pub fn codegen_consume("}]}