{"sha": "bd019c4c26d49c9481ebc4b57134bfdc5c5e5a97", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkMDE5YzRjMjZkNDljOTQ4MWViYzRiNTcxMzRiZmRjNWM1ZTVhOTc=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-06-13T00:50:16Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-06-13T18:41:20Z"}, "message": "Thread order_lock through rwlock condvars for reacquiring access_lock. Fixes #7065.", "tree": {"sha": "672feee3cb550f839b4202151ae28188e8ace9eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/672feee3cb550f839b4202151ae28188e8ace9eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd019c4c26d49c9481ebc4b57134bfdc5c5e5a97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd019c4c26d49c9481ebc4b57134bfdc5c5e5a97", "html_url": "https://github.com/rust-lang/rust/commit/bd019c4c26d49c9481ebc4b57134bfdc5c5e5a97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd019c4c26d49c9481ebc4b57134bfdc5c5e5a97/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ca2056e46b436d3a252919758d6fb86977b0234", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ca2056e46b436d3a252919758d6fb86977b0234", "html_url": "https://github.com/rust-lang/rust/commit/0ca2056e46b436d3a252919758d6fb86977b0234"}], "stats": {"total": 94, "additions": 72, "deletions": 22}, "files": [{"sha": "39577d863b8dd13ca814ab2f8ddfe45233301c70", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 72, "deletions": 22, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/bd019c4c26d49c9481ebc4b57134bfdc5c5e5a97/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd019c4c26d49c9481ebc4b57134bfdc5c5e5a97/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=bd019c4c26d49c9481ebc4b57134bfdc5c5e5a97", "patch": "@@ -189,8 +189,27 @@ fn SemAndSignalRelease<'r>(sem: &'r Sem<~[Waitqueue]>)\n     }\n }\n \n+// FIXME(#3598): Want to use an Option down below, but we need a custom enum\n+// that's not polymorphic to get around the fact that lifetimes are invariant\n+// inside of type parameters.\n+enum ReacquireOrderLock<'self> {\n+    Nothing, // c.c\n+    Just(&'self Semaphore),\n+}\n+\n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n-pub struct Condvar<'self> { priv sem: &'self Sem<~[Waitqueue]> }\n+pub struct Condvar<'self> {\n+    // The 'Sem' object associated with this condvar. This is the one that's\n+    // atomically-unlocked-and-descheduled upon and reacquired during wakeup.\n+    priv sem: &'self Sem<~[Waitqueue]>,\n+    // This is (can be) an extra semaphore which is held around the reacquire\n+    // operation on the first one. This is only used in cvars associated with\n+    // rwlocks, and is needed to ensure that, when a downgrader is trying to\n+    // hand off the access lock (which would be the first field, here), a 2nd\n+    // writer waking up from a cvar wait can't race with a reader to steal it,\n+    // See the comment in write_cond for more detail.\n+    priv order: ReacquireOrderLock<'self>,\n+}\n \n #[unsafe_destructor]\n impl<'self> Drop for Condvar<'self> { fn finalize(&self) {} }\n@@ -247,7 +266,8 @@ impl<'self> Condvar<'self> {\n                 // unkillably reacquire the lock needs to happen atomically\n                 // wrt enqueuing.\n                 if out_of_bounds.is_none() {\n-                    reacquire = Some(SemAndSignalReacquire(self.sem));\n+                    reacquire = Some(CondvarReacquire { sem:   self.sem,\n+                                                        order: self.order });\n                 }\n             }\n         }\n@@ -261,28 +281,29 @@ impl<'self> Condvar<'self> {\n         // This is needed for a failing condition variable to reacquire the\n         // mutex during unwinding. As long as the wrapper (mutex, etc) is\n         // bounded in when it gets released, this shouldn't hang forever.\n-        struct SemAndSignalReacquire<'self> {\n+        struct CondvarReacquire<'self> {\n             sem: &'self Sem<~[Waitqueue]>,\n+            order: ReacquireOrderLock<'self>,\n         }\n \n         #[unsafe_destructor]\n-        impl<'self> Drop for SemAndSignalReacquire<'self> {\n+        impl<'self> Drop for CondvarReacquire<'self> {\n             fn finalize(&self) {\n                 unsafe {\n                     // Needs to succeed, instead of itself dying.\n                     do task::unkillable {\n-                        self.sem.acquire();\n+                        match self.order {\n+                            Just(lock) => do lock.access {\n+                                self.sem.acquire();\n+                            },\n+                            Nothing => {\n+                                self.sem.acquire();\n+                            },\n+                        }\n                     }\n                 }\n             }\n         }\n-\n-        fn SemAndSignalReacquire<'r>(sem: &'r Sem<~[Waitqueue]>)\n-                                  -> SemAndSignalReacquire<'r> {\n-            SemAndSignalReacquire {\n-                sem: sem\n-            }\n-        }\n     }\n \n     /// Wake up a blocked task. Returns false if there was no blocked task.\n@@ -350,9 +371,12 @@ fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n \n #[doc(hidden)]\n impl Sem<~[Waitqueue]> {\n-    // The only other place that condvars get built is rwlock_write_mode.\n+    // The only other places that condvars get built are rwlock.write_cond()\n+    // and rwlock_write_mode.\n     pub fn access_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n-        do self.access { blk(&Condvar { sem: self }) }\n+        do self.access {\n+            blk(&Condvar { sem: self, order: Nothing })\n+        }\n     }\n }\n \n@@ -534,17 +558,39 @@ impl RWlock {\n      * was signalled might reacquire the lock before other waiting writers.)\n      */\n     pub fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n-        // NB: You might think I should thread the order_lock into the cond\n-        // wait call, so that it gets waited on before access_lock gets\n-        // reacquired upon being woken up. However, (a) this would be not\n-        // pleasant to implement (and would mandate a new 'rw_cond' type) and\n-        // (b) I think violating no-starvation in that case is appropriate.\n+        // It's important to thread our order lock into the condvar, so that\n+        // when a cond.wait() wakes up, it uses it while reacquiring the\n+        // access lock. If we permitted a waking-up writer to \"cut in line\",\n+        // there could arise a subtle race when a downgrader attempts to hand\n+        // off the reader cloud lock to a waiting reader. This race is tested\n+        // in arc.rs (test_rw_write_cond_downgrade_read_race) and looks like:\n+        // T1 (writer)              T2 (downgrader)             T3 (reader)\n+        // [in cond.wait()]\n+        //                          [locks for writing]\n+        //                          [holds access_lock]\n+        // [is signalled, perhaps by\n+        //  downgrader or a 4th thread]\n+        // tries to lock access(!)\n+        //                                                      lock order_lock\n+        //                                                      xadd read_count[0->1]\n+        //                                                      tries to lock access\n+        //                          [downgrade]\n+        //                          xadd read_count[1->2]\n+        //                          unlock access\n+        // Since T1 contended on the access lock before T3 did, it will steal\n+        // the lock handoff. Adding order_lock in the condvar reacquire path\n+        // solves this because T1 will hold order_lock while waiting on access,\n+        // which will cause T3 to have to wait until T1 finishes its write,\n+        // which can't happen until T2 finishes the downgrade-read entirely.\n         unsafe {\n             do task::unkillable {\n                 (&self.order_lock).acquire();\n                 do (&self.access_lock).access_cond |cond| {\n                     (&self.order_lock).release();\n-                    do task::rekillable { blk(cond) }\n+                    do task::rekillable {\n+                        let opt_lock = Just(&self.order_lock);\n+                        blk(&Condvar { order: opt_lock, ..*cond })\n+                    }\n                 }\n             }\n         }\n@@ -605,7 +651,8 @@ impl RWlock {\n                     // Guaranteed not to let another writer in, because\n                     // another reader was holding the order_lock. Hence they\n                     // must be the one to get the access_lock (because all\n-                    // access_locks are acquired with order_lock held).\n+                    // access_locks are acquired with order_lock held). See\n+                    // the comment in write_cond for more justification.\n                     (&self.access_lock).release();\n                 }\n             }\n@@ -709,7 +756,10 @@ impl<'self> RWlockWriteMode<'self> {\n     pub fn write<U>(&self, blk: &fn() -> U) -> U { blk() }\n     /// Access the pre-downgrade rwlock in write mode with a condvar.\n     pub fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n-        blk(&Condvar { sem: &self.lock.access_lock })\n+        // Need to make the condvar use the order lock when reacquiring the\n+        // access lock. See comment in RWlock::write_cond for why.\n+        blk(&Condvar { sem:        &self.lock.access_lock,\n+                       order: Just(&self.lock.order_lock), })\n     }\n }\n "}]}