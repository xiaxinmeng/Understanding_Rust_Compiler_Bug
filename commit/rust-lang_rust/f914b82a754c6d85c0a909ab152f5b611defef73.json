{"sha": "f914b82a754c6d85c0a909ab152f5b611defef73", "node_id": "C_kwDOAAsO6NoAKGY5MTRiODJhNzU0YzZkODVjMGE5MDlhYjE1MmY1YjYxMWRlZmVmNzM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-30T10:39:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-30T10:39:09Z"}, "message": "Auto merge of #102509 - matthiaskrgr:rollup-gtenet8, r=matthiaskrgr\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #101075 (Migrate rustc_codegen_gcc to SessionDiagnostics )\n - #102350 (Improve errors for incomplete functions in struct definitions)\n - #102481 (rustdoc: remove unneeded CSS `.rust-example-rendered { position }`)\n - #102491 (rustdoc: remove no-op source sidebar `opacity`)\n - #102499 (Adjust the s390x data layout for LLVM 16)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "4aadd6df5dcdf3bea8a2cbd16bf91fb0e2753c92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4aadd6df5dcdf3bea8a2cbd16bf91fb0e2753c92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f914b82a754c6d85c0a909ab152f5b611defef73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f914b82a754c6d85c0a909ab152f5b611defef73", "html_url": "https://github.com/rust-lang/rust/commit/f914b82a754c6d85c0a909ab152f5b611defef73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f914b82a754c6d85c0a909ab152f5b611defef73/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a0ee3cdc66573c8b46471462db7088a89d25183", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a0ee3cdc66573c8b46471462db7088a89d25183", "html_url": "https://github.com/rust-lang/rust/commit/4a0ee3cdc66573c8b46471462db7088a89d25183"}, {"sha": "588a25a6f8bfeec3a6bb8d8f498b0ed0794f7096", "url": "https://api.github.com/repos/rust-lang/rust/commits/588a25a6f8bfeec3a6bb8d8f498b0ed0794f7096", "html_url": "https://github.com/rust-lang/rust/commit/588a25a6f8bfeec3a6bb8d8f498b0ed0794f7096"}], "stats": {"total": 687, "additions": 482, "deletions": 205}, "files": [{"sha": "ac0342f6b80a02c8632780c6a6844d2f4ffff104", "filename": "compiler/rustc_codegen_gcc/src/archive.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -1,6 +1,8 @@\n use std::fs::File;\n use std::path::{Path, PathBuf};\n \n+use crate::errors::RanlibFailure;\n+\n use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use rustc_session::Session;\n \n@@ -181,7 +183,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             std::process::Command::new(\"ranlib\").arg(output).status().expect(\"Couldn't run ranlib\");\n \n         if !status.success() {\n-            self.config.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n+            self.config.sess.emit_fatal(RanlibFailure::new(status.code()));\n         }\n \n         any_members"}, {"sha": "007b001f213f8cff99b7bed26e607d367db234e2", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -12,6 +12,7 @@ use std::borrow::Cow;\n \n use crate::builder::Builder;\n use crate::context::CodegenCx;\n+use crate::errors::UnwindingInlineAsm;\n use crate::type_of::LayoutGccExt;\n use crate::callee::get_fn;\n \n@@ -109,7 +110,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn codegen_inline_asm(&mut self, template: &[InlineAsmTemplatePiece], rust_operands: &[InlineAsmOperandRef<'tcx, Self>], options: InlineAsmOptions, span: &[Span], _instance: Instance<'_>, _dest_catch_funclet: Option<(Self::BasicBlock, Self::BasicBlock, Option<&Self::Funclet>)>) {\n         if options.contains(InlineAsmOptions::MAY_UNWIND) {\n             self.sess()\n-                .struct_span_err(span[0], \"GCC backend does not support unwinding from inline asm\")\n+                .create_err(UnwindingInlineAsm { span: span[0] })\n                 .emit();\n             return;\n         }"}, {"sha": "81f533288677a3ae1b1767185c30414672256452", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -14,6 +14,7 @@ use rustc_target::abi::{self, Align, HasDataLayout, Primitive, Size, WrappingRan\n \n use crate::base;\n use crate::context::CodegenCx;\n+use crate::errors::LinkageConstOrMutType;\n use crate::type_of::LayoutGccExt;\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -368,10 +369,7 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n                 cx.layout_of(mt.ty).gcc_type(cx, true)\n             }\n             else {\n-                cx.sess().span_fatal(\n-                    span,\n-                    \"must have type `*const T` or `*mut T` due to `#[linkage]` attribute\",\n-                )\n+                cx.sess().emit_fatal(LinkageConstOrMutType { span: span })\n             };\n         // Declare a symbol `foo` with the desired linkage.\n         let global1 = cx.declare_global_with_linkage(&sym, llty2, base::global_linkage_to_gcc(linkage));"}, {"sha": "46ade33eb01cbb5af767762be2c5edbcb64908b3", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::mir::mono::CodegenUnit;\n use rustc_middle::ty::{self, Instance, ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt};\n use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n use rustc_session::Session;\n-use rustc_span::Span;\n+use rustc_span::{Span, source_map::respan};\n use rustc_target::abi::{call::FnAbi, HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n use rustc_target::spec::{HasTargetSpec, Target, TlsModel};\n \n@@ -293,7 +293,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         self.is_native_int_type(typ) || self.is_non_native_int_type(typ) || typ.is_compatible_with(self.bool_type)\n     }\n \n-    pub fn sess(&self) -> &Session {\n+    pub fn sess(&self) -> &'tcx Session {\n         &self.tcx.sess\n     }\n \n@@ -477,7 +477,7 @@ impl<'gcc, 'tcx> LayoutOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n     #[inline]\n     fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n         if let LayoutError::SizeOverflow(_) = err {\n-            self.sess().span_fatal(span, &err.to_string())\n+            self.sess().emit_fatal(respan(span, err))\n         } else {\n             span_bug!(span, \"failed to get layout for `{}`: {}\", ty, err)\n         }\n@@ -495,7 +495,7 @@ impl<'gcc, 'tcx> FnAbiOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n         fn_abi_request: FnAbiRequest<'tcx>,\n     ) -> ! {\n         if let FnAbiError::Layout(LayoutError::SizeOverflow(_)) = err {\n-            self.sess().span_fatal(span, &err.to_string())\n+            self.sess().emit_fatal(respan(span, err))\n         } else {\n             match fn_abi_request {\n                 FnAbiRequest::OfFnPtr { sig, extra_args } => {"}, {"sha": "d7816e395c8ebd7e5c225505782fa374621261f0", "filename": "compiler/rustc_codegen_gcc/src/errors.rs", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -0,0 +1,242 @@\n+use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n+use rustc_macros::Diagnostic;\n+use rustc_middle::ty::Ty;\n+use rustc_span::{Span, Symbol};\n+use std::borrow::Cow;\n+\n+struct ExitCode(Option<i32>);\n+\n+impl IntoDiagnosticArg for ExitCode {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        let ExitCode(exit_code) = self;\n+        match exit_code {\n+            Some(t) => t.into_diagnostic_arg(),\n+            None => DiagnosticArgValue::Str(Cow::Borrowed(\"<signal>\")),\n+        }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::ranlib_failure)]\n+pub(crate) struct RanlibFailure {\n+    exit_code: ExitCode,\n+}\n+\n+impl RanlibFailure {\n+    pub fn new(exit_code: Option<i32>) -> Self {\n+        RanlibFailure { exit_code: ExitCode(exit_code) }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_basic_integer, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationBasicInteger<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_invalid_float_vector, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInvalidFloatVector<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub elem_ty: &'a str,\n+    pub vec_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_not_float, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationNotFloat<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unrecognized, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnrecognized {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_expected_signed_unsigned, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationExpectedSignedUnsigned<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub elem_ty: Ty<'a>,\n+    pub vec_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unsupported_element, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedElement<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub elem_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_invalid_bitmask, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInvalidBitmask<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+    pub expected_int_bits: u64,\n+    pub expected_bytes: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_simd_shuffle, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationSimdShuffle<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_expected_simd, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationExpectedSimd<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub position: &'a str,\n+    pub found_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_mask_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationMaskType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_length, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnLength<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_len: u64,\n+    pub ret_ty: Ty<'a>,\n+    pub out_len: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_length_input_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnLengthInputType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_len: u64,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_len: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_element, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnElement<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_inserted_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInsertedType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_integer_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnIntegerType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ret_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_mismatched_lengths, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationMismatchedLengths {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub m_len: u64,\n+    pub v_len: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unsupported_cast, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedCast<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub in_elem: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_elem: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unsupported_operation, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedOperation<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub in_elem: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::linkage_const_or_mut_type)]\n+pub(crate) struct LinkageConstOrMutType {\n+    #[primary_span]\n+    pub span: Span\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::lto_not_supported)]\n+pub(crate) struct LTONotSupported;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::unwinding_inline_asm)]\n+pub(crate) struct UnwindingInlineAsm {\n+    #[primary_span]\n+    pub span: Span\n+}"}, {"sha": "cc9c90c2427096174b97b4b2c56d7d8b689763ed", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -4,7 +4,7 @@ mod simd;\n use gccjit::{ComparisonOp, Function, RValue, ToRValue, Type, UnaryOp, FunctionType};\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::base::wants_msvc_seh;\n-use rustc_codegen_ssa::common::{IntPredicate, span_invalid_monomorphization_error};\n+use rustc_codegen_ssa::common::IntPredicate;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{ArgAbiMethods, BaseTypeMethods, BuilderMethods, ConstMethods, IntrinsicCallMethods};\n@@ -20,6 +20,7 @@ use crate::abi::GccType;\n use crate::builder::Builder;\n use crate::common::{SignType, TypeReflection};\n use crate::context::CodegenCx;\n+use crate::errors::InvalidMonomorphizationBasicInteger;\n use crate::type_of::LayoutGccExt;\n use crate::intrinsic::simd::generic_simd_intrinsic;\n \n@@ -242,15 +243,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                                 _ => bug!(),\n                             },\n                             None => {\n-                                span_invalid_monomorphization_error(\n-                                    tcx.sess,\n-                                    span,\n-                                    &format!(\n-                                        \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic integer type, found `{}`\",\n-                                      name, ty\n-                                    ),\n-                                );\n+                                tcx.sess.emit_err(InvalidMonomorphizationBasicInteger { span, name, ty });\n                                 return;\n                             }\n                         }"}, {"sha": "ffc85b773a2769bbde7cfe1718f0c41c16efe051", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/simd.rs", "status": "modified", "additions": 60, "deletions": 142, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -2,7 +2,7 @@ use std::cmp::Ordering;\n \n use gccjit::{BinaryOp, RValue, Type, ToRValue};\n use rustc_codegen_ssa::base::compare_simd_types;\n-use rustc_codegen_ssa::common::{TypeKind, span_invalid_monomorphization_error};\n+use rustc_codegen_ssa::common::TypeKind;\n use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods};\n@@ -14,43 +14,48 @@ use rustc_span::{Span, Symbol, sym};\n use rustc_target::abi::Align;\n \n use crate::builder::Builder;\n+use crate::errors::{\n+    InvalidMonomorphizationInvalidFloatVector,\n+    InvalidMonomorphizationNotFloat,\n+    InvalidMonomorphizationUnrecognized,\n+    InvalidMonomorphizationExpectedSignedUnsigned,\n+    InvalidMonomorphizationUnsupportedElement,\n+    InvalidMonomorphizationInvalidBitmask,\n+    InvalidMonomorphizationSimdShuffle,\n+    InvalidMonomorphizationExpectedSimd,\n+    InvalidMonomorphizationMaskType,\n+    InvalidMonomorphizationReturnLength,\n+    InvalidMonomorphizationReturnLengthInputType,\n+    InvalidMonomorphizationReturnElement,\n+    InvalidMonomorphizationReturnType,\n+    InvalidMonomorphizationInsertedType,\n+    InvalidMonomorphizationReturnIntegerType,\n+    InvalidMonomorphizationMismatchedLengths,\n+    InvalidMonomorphizationUnsupportedCast,\n+    InvalidMonomorphizationUnsupportedOperation\n+};\n use crate::intrinsic;\n \n pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, name: Symbol, callee_ty: Ty<'tcx>, args: &[OperandRef<'tcx, RValue<'gcc>>], ret_ty: Ty<'tcx>, llret_ty: Type<'gcc>, span: Span) -> Result<RValue<'gcc>, ()> {\n     // macros for error handling:\n-    #[allow(unused_macro_rules)]\n-    macro_rules! emit_error {\n-        ($msg: tt) => {\n-            emit_error!($msg, )\n-        };\n-        ($msg: tt, $($fmt: tt)*) => {\n-            span_invalid_monomorphization_error(\n-                bx.sess(), span,\n-                &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                         name, $($fmt)*));\n-        }\n-    }\n-\n     macro_rules! return_error {\n-        ($($fmt: tt)*) => {\n+        ($err:expr) => {\n             {\n-                emit_error!($($fmt)*);\n+                bx.sess().emit_err($err);\n                 return Err(());\n             }\n         }\n     }\n-\n     macro_rules! require {\n-        ($cond: expr, $($fmt: tt)*) => {\n+        ($cond:expr, $err:expr) => {\n             if !$cond {\n-                return_error!($($fmt)*);\n+                return_error!($err);\n             }\n-        };\n+        }\n     }\n-\n     macro_rules! require_simd {\n         ($ty: expr, $position: expr) => {\n-            require!($ty.is_simd(), \"expected SIMD {} type, found non-SIMD `{}`\", $position, $ty)\n+            require!($ty.is_simd(), InvalidMonomorphizationExpectedSimd { span, name, position: $position, found_ty: $ty })\n         };\n     }\n \n@@ -82,10 +87,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 bx.load(int_ty, ptr, Align::ONE)\n             }\n             _ => return_error!(\n-                \"invalid bitmask `{}`, expected `u{}` or `[u8; {}]`\",\n-                mask_ty,\n-                expected_int_bits,\n-                expected_bytes\n+                InvalidMonomorphizationInvalidBitmask { span, name, ty: mask_ty, expected_int_bits, expected_bytes }\n             ),\n         };\n \n@@ -127,18 +129,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLengthInputType { span, name, in_len, in_ty, ret_ty, out_len }\n         );\n         require!(\n             bx.type_kind(bx.element_type(llret_ty)) == TypeKind::Integer,\n-            \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphizationReturnIntegerType {span, name, ret_ty, out_ty}\n         );\n \n         return Ok(compare_simd_types(\n@@ -163,8 +158,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                         })\n                     }\n                     _ => return_error!(\n-                        \"simd_shuffle index must be an array of `u32`, got `{}`\",\n-                        args[2].layout.ty\n+                        InvalidMonomorphizationSimdShuffle { span, name, ty: args[2].layout.ty }\n                     ),\n                 }\n             }\n@@ -179,19 +173,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             out_len == n,\n-            \"expected return type of length {}, found `{}` with length {}\",\n-            n,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLength { span, name, in_len: n, ret_ty, out_len }\n         );\n         require!(\n             in_elem == out_ty,\n-            \"expected return element type `{}` (element of input `{}`), \\\n-             found `{}` with element type `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphizationReturnElement { span, name, in_elem, in_ty, ret_ty, out_ty }\n         );\n \n         let vector = args[2].immediate();\n@@ -207,10 +193,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     if name == sym::simd_insert {\n         require!(\n             in_elem == arg_tys[2],\n-            \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            arg_tys[2]\n+            InvalidMonomorphizationInsertedType { span, name, in_elem, in_ty, out_ty: arg_tys[2] }\n         );\n         let vector = args[0].immediate();\n         let index = args[1].immediate();\n@@ -263,10 +246,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     if name == sym::simd_extract {\n         require!(\n             ret_ty == in_elem,\n-            \"expected return type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty\n+            InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n         );\n         let vector = args[0].immediate();\n         return Ok(bx.context.new_vector_access(None, vector, args[1].immediate()).to_rvalue());\n@@ -279,13 +259,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         require!(\n             m_len == v_len,\n-            \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n-            m_len,\n-            v_len\n+            InvalidMonomorphizationMismatchedLengths { span, name, m_len, v_len }\n         );\n         match m_elem_ty.kind() {\n             ty::Int(_) => {}\n-            _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty),\n+            _ => return_error!(InvalidMonomorphizationMaskType { span, name, ty: m_elem_ty }),\n         }\n         return Ok(bx.vector_select(args[0].immediate(), args[1].immediate(), args[2].immediate()));\n     }\n@@ -295,12 +273,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLengthInputType { span, name, in_len, in_ty, ret_ty, out_len }\n         );\n         // casting cares about nominal type, not just structural type\n         if in_elem == out_elem {\n@@ -412,13 +385,8 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             }\n             _ => { /* Unsupported. Fallthrough. */ }\n         }\n-        require!(\n-            false,\n-            \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n-            in_ty,\n-            in_elem,\n-            ret_ty,\n-            out_elem\n+        return_error!(\n+            InvalidMonomorphizationUnsupportedCast { span, name, in_ty, in_elem, ret_ty, out_elem }\n         );\n     }\n \n@@ -431,10 +399,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                return_error!(InvalidMonomorphizationUnsupportedOperation { span, name, in_ty, in_elem })\n             })*\n         }\n     }\n@@ -448,40 +413,27 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         span: Span,\n         args: &[OperandRef<'tcx, RValue<'gcc>>],\n     ) -> Result<RValue<'gcc>, ()> {\n-        macro_rules! emit_error {\n-            ($msg: tt, $($fmt: tt)*) => {\n-                span_invalid_monomorphization_error(\n-                    bx.sess(), span,\n-                    &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                             name, $($fmt)*));\n-            }\n-        }\n         macro_rules! return_error {\n-            ($($fmt: tt)*) => {\n+            ($err:expr) => {\n                 {\n-                    emit_error!($($fmt)*);\n+                    bx.sess().emit_err($err);\n                     return Err(());\n                 }\n             }\n         }\n-\n         let (elem_ty_str, elem_ty) =\n             if let ty::Float(f) = in_elem.kind() {\n                 let elem_ty = bx.cx.type_float_from_ty(*f);\n                 match f.bit_width() {\n                     32 => (\"f32\", elem_ty),\n                     64 => (\"f64\", elem_ty),\n                     _ => {\n-                        return_error!(\n-                            \"unsupported element type `{}` of floating-point vector `{}`\",\n-                            f.name_str(),\n-                            in_ty\n-                        );\n+                        return_error!(InvalidMonomorphizationInvalidFloatVector { span, name, elem_ty: f.name_str(), vec_ty: in_ty });\n                     }\n                 }\n             }\n             else {\n-                return_error!(\"`{}` is not a floating-point type\", in_ty);\n+                return_error!(InvalidMonomorphizationNotFloat { span, name, ty: in_ty });\n             };\n \n         let vec_ty = bx.cx.type_vector(elem_ty, in_len);\n@@ -504,7 +456,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n                 sym::simd_round => (\"round\", bx.type_func(&[vec_ty], vec_ty)),\n                 sym::simd_trunc => (\"trunc\", bx.type_func(&[vec_ty], vec_ty)),\n-                _ => return_error!(\"unrecognized intrinsic `{}`\", name),\n+                _ => return_error!(InvalidMonomorphizationUnrecognized { span, name })\n             };\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let function = intrinsic::llvm::intrinsic(llvm_name, &bx.cx);\n@@ -557,10 +509,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                return_error!(InvalidMonomorphizationUnsupportedOperation { span, name, in_ty, in_elem })\n             })*\n         }\n     }\n@@ -579,12 +528,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n             ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n             _ => {\n-                return_error!(\n-                    \"expected element type `{}` of vector type `{}` \\\n-                     to be a signed or unsigned integer type\",\n-                    arg_tys[0].simd_size_and_type(bx.tcx()).1,\n-                    arg_tys[0]\n-                );\n+                return_error!(InvalidMonomorphizationExpectedSignedUnsigned {\n+                    span,\n+                    name,\n+                    elem_ty: arg_tys[0].simd_size_and_type(bx.tcx()).1,\n+                    vec_ty: arg_tys[0],\n+                });\n             }\n         };\n         let builtin_name =\n@@ -617,10 +566,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n@@ -644,13 +590,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                             Ok(bx.vector_reduce_op(args[0].immediate(), $vec_op))\n                         }\n                     }\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n-                        in_ty,\n-                        in_elem,\n-                        ret_ty\n-                    ),\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                 };\n             }\n         };\n@@ -676,20 +616,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) | ty::Float(_) => Ok(bx.$reduction(args[0].immediate())),\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n-                        in_ty,\n-                        in_elem,\n-                        ret_ty\n-                    ),\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                 };\n             }\n         };\n@@ -704,22 +635,13 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 let input = if !$boolean {\n                     require!(\n                         ret_ty == in_elem,\n-                        \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                        in_elem,\n-                        in_ty,\n-                        ret_ty\n+                        InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                     );\n                     args[0].immediate()\n                 } else {\n                     match in_elem.kind() {\n                         ty::Int(_) | ty::Uint(_) => {}\n-                        _ => return_error!(\n-                            \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                            sym::$name,\n-                            in_ty,\n-                            in_elem,\n-                            ret_ty\n-                        ),\n+                        _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                     }\n \n                     // boolean reductions operate on vectors of i1s:\n@@ -733,11 +655,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                         Ok(if !$boolean { r } else { bx.zext(r, bx.type_bool()) })\n                     }\n                     _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n-                        in_ty,\n-                        in_elem,\n-                        ret_ty\n+                        InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }\n                     ),\n                 };\n             }"}, {"sha": "007d61ed51de88474394a19a1c9217eb64dcd5fa", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -18,13 +18,16 @@\n #![recursion_limit=\"256\"]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n extern crate rustc_apfloat;\n extern crate rustc_ast;\n extern crate rustc_codegen_ssa;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n extern crate rustc_hir;\n+extern crate rustc_macros;\n extern crate rustc_metadata;\n extern crate rustc_middle;\n extern crate rustc_session;\n@@ -50,6 +53,7 @@ mod context;\n mod coverageinfo;\n mod debuginfo;\n mod declare;\n+mod errors;\n mod int;\n mod intrinsic;\n mod mono_item;\n@@ -59,6 +63,7 @@ mod type_of;\n use std::any::Any;\n use std::sync::{Arc, Mutex};\n \n+use crate::errors::LTONotSupported;\n use gccjit::{Context, OptimizationLevel, CType};\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, ModuleCodegen};\n@@ -97,7 +102,7 @@ pub struct GccCodegenBackend {\n impl CodegenBackend for GccCodegenBackend {\n     fn init(&self, sess: &Session) {\n         if sess.lto() != Lto::No {\n-            sess.warn(\"LTO is not supported. You may get a linker error.\");\n+            sess.emit_warning(LTONotSupported {});\n         }\n \n         let temp_dir = TempDir::new().expect(\"cannot create temporary directory\");"}, {"sha": "2ab69d2541169fc51580a1f83cf77ea1cd23224f", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -154,6 +154,11 @@ pub unsafe fn create_module<'ll>(\n             target_data_layout = target_data_layout.replace(\"-p10:8:8-p20:8:8\", \"\");\n         }\n     }\n+    if llvm_version < (16, 0, 0) {\n+        if sess.target.arch == \"s390x\" {\n+            target_data_layout = target_data_layout.replace(\"-v128:64\", \"\");\n+        }\n+    }\n \n     // Ensure the data-layout values hardcoded remain the defaults.\n     if sess.target.is_builtin {"}, {"sha": "178e1a67ccecff46fb28b1bfc715ec1cd0287fbf", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_gcc.ftl", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -0,0 +1,68 @@\n+codegen_gcc_ranlib_failure =\n+    Ranlib exited with code {$exit_code}\n+\n+codegen_gcc_linkage_const_or_mut_type =\n+    must have type `*const T` or `*mut T` due to `#[linkage]` attribute\n+\n+codegen_gcc_unwinding_inline_asm =\n+    GCC backend does not support unwinding from inline asm\n+\n+codegen_gcc_lto_not_supported =\n+    LTO is not supported. You may get a linker error.\n+\n+codegen_gcc_invalid_monomorphization_basic_integer =\n+    invalid monomorphization of `{$name}` intrinsic: expected basic integer type, found `{$ty}`\n+\n+codegen_gcc_invalid_monomorphization_invalid_float_vector =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported element type `{$elem_ty}` of floating-point vector `{$vec_ty}`\n+\n+codegen_gcc_invalid_monomorphization_not_float =\n+    invalid monomorphization of `{$name}` intrinsic: `{$ty}` is not a floating-point type\n+\n+codegen_gcc_invalid_monomorphization_unrecognized =\n+    invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n+\n+codegen_gcc_invalid_monomorphization_expected_signed_unsigned =\n+    invalid monomorphization of `{$name}` intrinsic: expected element type `{$elem_ty}` of vector type `{$vec_ty}` to be a signed or unsigned integer type\n+\n+codegen_gcc_invalid_monomorphization_unsupported_element =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported {$name} from `{$in_ty}` with element `{$elem_ty}` to `{$ret_ty}`\n+\n+codegen_gcc_invalid_monomorphization_invalid_bitmask =\n+    invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+\n+codegen_gcc_invalid_monomorphization_simd_shuffle =\n+    invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n+\n+codegen_gcc_invalid_monomorphization_expected_simd =\n+    invalid monomorphization of `{$name}` intrinsic: expected SIMD {$expected_ty} type, found non-SIMD `{$found_ty}`\n+\n+codegen_gcc_invalid_monomorphization_mask_type =\n+    invalid monomorphization of `{$name}` intrinsic: mask element type is `{$ty}`, expected `i_`\n+\n+codegen_gcc_invalid_monomorphization_return_length =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type of length {$in_len}, found `{$ret_ty}` with length {$out_len}\n+\n+codegen_gcc_invalid_monomorphization_return_length_input_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type with length {$in_len} (same as input type `{$in_ty}`), found `{$ret_ty}` with length {$out_len}\n+\n+codegen_gcc_invalid_monomorphization_return_element =\n+    invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_return_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}`\n+\n+codegen_gcc_invalid_monomorphization_inserted_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_return_integer_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_mismatched_lengths =\n+    invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n+\n+codegen_gcc_invalid_monomorphization_unsupported_cast =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported cast from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}` with element `{$out_elem}`\n+\n+codegen_gcc_invalid_monomorphization_unsupported_operation =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`"}, {"sha": "abf98a9621e78eb3db746b081ec04864ad328bb0", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -41,6 +41,7 @@ fluent_messages! {\n     borrowck => \"../locales/en-US/borrowck.ftl\",\n     builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n     const_eval => \"../locales/en-US/const_eval.ftl\",\n+    codegen_gcc => \"../locales/en-US/codegen_gcc.ftl\",\n     driver => \"../locales/en-US/driver.ftl\",\n     expand => \"../locales/en-US/expand.ftl\",\n     session => \"../locales/en-US/session.ftl\","}, {"sha": "092a77f944c093933d1bf32118e36dab577f8dc4", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -5,6 +5,7 @@ use crate::{\n };\n use crate::{Handler, Level, MultiSpan, StashKey};\n use rustc_lint_defs::Applicability;\n+use rustc_span::source_map::Spanned;\n \n use rustc_span::Span;\n use std::borrow::Cow;\n@@ -23,6 +24,18 @@ pub trait IntoDiagnostic<'a, T: EmissionGuarantee = ErrorGuaranteed> {\n     fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, T>;\n }\n \n+impl<'a, T, E> IntoDiagnostic<'a, E> for Spanned<T>\n+where\n+    T: IntoDiagnostic<'a, E>,\n+    E: EmissionGuarantee,\n+{\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, E> {\n+        let mut diag = self.node.into_diagnostic(handler);\n+        diag.set_span(self.span);\n+        diag\n+    }\n+}\n+\n /// Used for emitting structured error messages and other diagnostic information.\n ///\n /// If there is some state in a downstream crate you would like to"}, {"sha": "3c523659df74e15dbada8487c1405d1b9b1c0a79", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -7,6 +7,7 @@ use crate::ty::{\n };\n use rustc_ast as ast;\n use rustc_attr as attr;\n+use rustc_errors::{DiagnosticBuilder, Handler, IntoDiagnostic};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n@@ -206,6 +207,12 @@ pub enum LayoutError<'tcx> {\n     NormalizationFailure(Ty<'tcx>, NormalizationError<'tcx>),\n }\n \n+impl<'a> IntoDiagnostic<'a, !> for LayoutError<'a> {\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, !> {\n+        handler.struct_fatal(self.to_string())\n+    }\n+}\n+\n impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n@@ -3065,6 +3072,12 @@ impl<'tcx> fmt::Display for FnAbiError<'tcx> {\n     }\n }\n \n+impl<'tcx> IntoDiagnostic<'tcx, !> for FnAbiError<'tcx> {\n+    fn into_diagnostic(self, handler: &'tcx Handler) -> DiagnosticBuilder<'tcx, !> {\n+        handler.struct_fatal(self.to_string())\n+    }\n+}\n+\n // FIXME(eddyb) maybe use something like this for an unified `fn_abi_of`, not\n // just for error handling.\n #[derive(Debug)]"}, {"sha": "25425fbb2c6a60bef537c9f31925e11fc497cf2d", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -1753,18 +1753,24 @@ impl<'a> Parser<'a> {\n                 };\n                 // We use `parse_fn` to get a span for the function\n                 let fn_parse_mode = FnParseMode { req_name: |_| true, req_body: true };\n-                if let Err(mut db) =\n-                    self.parse_fn(&mut AttrVec::new(), fn_parse_mode, lo, &inherited_vis)\n-                {\n-                    db.delay_as_bug();\n+                match self.parse_fn(&mut AttrVec::new(), fn_parse_mode, lo, &inherited_vis) {\n+                    Ok(_) => {\n+                        let mut err = self.struct_span_err(\n+                            lo.to(self.prev_token.span),\n+                            &format!(\"functions are not allowed in {adt_ty} definitions\"),\n+                        );\n+                        err.help(\n+                            \"unlike in C++, Java, and C#, functions are declared in `impl` blocks\",\n+                        );\n+                        err.help(\"see https://doc.rust-lang.org/book/ch05-03-method-syntax.html for more information\");\n+                        err\n+                    }\n+                    Err(err) => {\n+                        err.cancel();\n+                        self.restore_snapshot(snapshot);\n+                        self.expected_ident_found()\n+                    }\n                 }\n-                let mut err = self.struct_span_err(\n-                    lo.to(self.prev_token.span),\n-                    &format!(\"functions are not allowed in {adt_ty} definitions\"),\n-                );\n-                err.help(\"unlike in C++, Java, and C#, functions are declared in `impl` blocks\");\n-                err.help(\"see https://doc.rust-lang.org/book/ch05-03-method-syntax.html for more information\");\n-                err\n             } else if self.eat_keyword(kw::Struct) {\n                 match self.parse_item_struct() {\n                     Ok((ident, _)) => {"}, {"sha": "cda88de0ea40693558af4084af4a49adcaa33ea4", "filename": "compiler/rustc_target/src/spec/s390x_unknown_linux_gnu.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_target%2Fsrc%2Fspec%2Fs390x_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_target%2Fsrc%2Fspec%2Fs390x_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fs390x_unknown_linux_gnu.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -6,9 +6,9 @@ pub fn target() -> Target {\n     base.endian = Endian::Big;\n     // z10 is the oldest CPU supported by LLVM\n     base.cpu = \"z10\".into();\n-    // FIXME: The data_layout string below and the ABI implementation in\n-    // cabi_s390x.rs are for now hard-coded to assume the no-vector ABI.\n-    // Pass the -vector feature string to LLVM to respect this assumption.\n+    // FIXME: The ABI implementation in cabi_s390x.rs is for now hard-coded to assume the no-vector\n+    // ABI. Pass the -vector feature string to LLVM to respect this assumption. On LLVM < 16, we\n+    // also strip v128 from the data_layout below to match the older LLVM's expectation.\n     base.features = \"-vector\".into();\n     base.max_atomic_width = Some(64);\n     base.min_global_align = Some(16);\n@@ -17,7 +17,7 @@ pub fn target() -> Target {\n     Target {\n         llvm_target: \"s390x-unknown-linux-gnu\".into(),\n         pointer_width: 64,\n-        data_layout: \"E-m:e-i1:8:16-i8:8:16-i64:64-f128:64-a:8:16-n32:64\".into(),\n+        data_layout: \"E-m:e-i1:8:16-i8:8:16-i64:64-f128:64-v128:64-a:8:16-n32:64\".into(),\n         arch: \"s390x\".into(),\n         options: base,\n     }"}, {"sha": "91e63aee5e49020211443eec54f3c776b0be92e7", "filename": "compiler/rustc_target/src/spec/s390x_unknown_linux_musl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_target%2Fsrc%2Fspec%2Fs390x_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/compiler%2Frustc_target%2Fsrc%2Fspec%2Fs390x_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fs390x_unknown_linux_musl.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -6,9 +6,9 @@ pub fn target() -> Target {\n     base.endian = Endian::Big;\n     // z10 is the oldest CPU supported by LLVM\n     base.cpu = \"z10\".into();\n-    // FIXME: The data_layout string below and the ABI implementation in\n-    // cabi_s390x.rs are for now hard-coded to assume the no-vector ABI.\n-    // Pass the -vector feature string to LLVM to respect this assumption.\n+    // FIXME: The ABI implementation in cabi_s390x.rs is for now hard-coded to assume the no-vector\n+    // ABI. Pass the -vector feature string to LLVM to respect this assumption. On LLVM < 16, we\n+    // also strip v128 from the data_layout below to match the older LLVM's expectation.\n     base.features = \"-vector\".into();\n     base.max_atomic_width = Some(64);\n     base.min_global_align = Some(16);\n@@ -18,7 +18,7 @@ pub fn target() -> Target {\n     Target {\n         llvm_target: \"s390x-unknown-linux-musl\".into(),\n         pointer_width: 64,\n-        data_layout: \"E-m:e-i1:8:16-i8:8:16-i64:64-f128:64-a:8:16-n32:64\".into(),\n+        data_layout: \"E-m:e-i1:8:16-i8:8:16-i64:64-f128:64-v128:64-a:8:16-n32:64\".into(),\n         arch: \"s390x\".into(),\n         options: base,\n     }"}, {"sha": "eb5271aaf7e38ce23599f7db8b0a88a8454768c3", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -448,7 +448,6 @@ img {\n }\n \n .source .sidebar > *:not(#sidebar-toggle) {\n-\topacity: 0;\n \tvisibility: hidden;\n }\n \n@@ -457,7 +456,6 @@ img {\n }\n \n .source-sidebar-expanded .source .sidebar > *:not(#sidebar-toggle) {\n-\topacity: 1;\n \tvisibility: visible;\n }\n \n@@ -1322,11 +1320,6 @@ h3.variant {\n \tfont-size: 1.25rem;\n }\n \n-/* Example code has the \"Run\" button that needs to be positioned relative to the pre */\n-pre.rust.rust-example-rendered {\n-\tposition: relative;\n-}\n-\n pre.rust {\n \ttab-size: 4;\n \t-moz-tab-size: 4;"}, {"sha": "24d1820ff27a81a69525e5367b939a5ca9b099fc", "filename": "src/test/rustdoc-gui/sidebar-source-code-display.goml", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/src%2Ftest%2Frustdoc-gui%2Fsidebar-source-code-display.goml", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/src%2Ftest%2Frustdoc-gui%2Fsidebar-source-code-display.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar-source-code-display.goml?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -3,20 +3,17 @@ javascript: false\n goto: file://|DOC_PATH|/src/test_docs/lib.rs.html\n // Since the javascript is disabled, there shouldn't be a toggle.\n assert-false: \"#sidebar-toggle\"\n-// For some reason, we need to wait a bit here because it seems like the transition on opacity\n-// is being applied whereas it can't be reproduced in a browser...\n-wait-for-css: (\".sidebar > *\", {\"visibility\": \"hidden\", \"opacity\": 0})\n+wait-for-css: (\".sidebar > *\", {\"visibility\": \"hidden\"})\n \n // Let's retry with javascript enabled.\n javascript: true\n reload:\n wait-for: \"#sidebar-toggle\"\n-assert-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\", \"opacity\": 1})\n-assert-css: (\".sidebar > *:not(#sidebar-toggle)\", {\"visibility\": \"hidden\", \"opacity\": 0})\n+assert-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\"})\n+assert-css: (\".sidebar > *:not(#sidebar-toggle)\", {\"visibility\": \"hidden\"})\n // Let's expand the sidebar now.\n click: \"#sidebar-toggle\"\n-// Because of the transition CSS, we check by using `wait-for-css` instead of `assert-css`.\n-wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\", \"opacity\": 1})\n+wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\"})\n \n // We now check that opening the sidebar and clicking a link will leave it open.\n // The behavior here on desktop is different than the behavior on mobile,\n@@ -36,7 +33,7 @@ show-text: true\n local-storage: {\"rustdoc-theme\": \"light\", \"rustdoc-use-system-theme\": \"false\"}\n reload:\n // Waiting for the sidebar to be displayed...\n-wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\", \"opacity\": 1})\n+wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\"})\n assert-css: (\n     \"#source-sidebar details[open] > .files a.selected\",\n     {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgb(255, 255, 255)\"},\n@@ -91,7 +88,7 @@ assert-css: (\n local-storage: {\"rustdoc-theme\": \"dark\", \"rustdoc-use-system-theme\": \"false\"}\n reload:\n // Waiting for the sidebar to be displayed...\n-wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\", \"opacity\": 1})\n+wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\"})\n assert-css: (\n     \"#source-sidebar details[open] > .files > a.selected\",\n     {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgb(51, 51, 51)\"},\n@@ -146,7 +143,7 @@ assert-css: (\n local-storage: {\"rustdoc-theme\": \"ayu\", \"rustdoc-use-system-theme\": \"false\"}\n reload:\n // Waiting for the sidebar to be displayed...\n-wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\", \"opacity\": 1})\n+wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\"})\n assert-css: (\n     \"#source-sidebar details[open] > .files a.selected\",\n     {\"color\": \"rgb(255, 180, 76)\", \"background-color\": \"rgb(20, 25, 31)\"},\n@@ -201,7 +198,7 @@ assert-css: (\n size: (500, 700)\n reload:\n // Waiting for the sidebar to be displayed...\n-wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\", \"opacity\": 1})\n+wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\"})\n \n // We now check it takes the full size of the display.\n assert-property: (\"body\", {\"clientWidth\": \"500\", \"clientHeight\": \"700\"})"}, {"sha": "188257ea53a316a94cc27b7aa6eaf60bf7e716ad", "filename": "src/test/ui/parser/fn-field-parse-error-ice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/src%2Ftest%2Fui%2Fparser%2Ffn-field-parse-error-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/src%2Ftest%2Fui%2Fparser%2Ffn-field-parse-error-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-field-parse-error-ice.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -3,7 +3,7 @@\n struct Baz {\n     inner : dyn fn ()\n     //~^ ERROR expected `,`, or `}`, found keyword `fn`\n-    //~| ERROR functions are not allowed in struct definitions\n+    //~| ERROR expected identifier, found keyword `fn`\n     //~| ERROR cannot find type `dyn` in this scope\n }\n "}, {"sha": "3bf68e8cc04fe96963a7d6f12cbc58250be952f0", "filename": "src/test/ui/parser/fn-field-parse-error-ice.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/src%2Ftest%2Fui%2Fparser%2Ffn-field-parse-error-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/src%2Ftest%2Fui%2Fparser%2Ffn-field-parse-error-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-field-parse-error-ice.stderr?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -4,16 +4,18 @@ error: expected `,`, or `}`, found keyword `fn`\n LL |     inner : dyn fn ()\n    |                ^ help: try adding a comma: `,`\n \n-error: functions are not allowed in struct definitions\n+error: expected identifier, found keyword `fn`\n   --> $DIR/fn-field-parse-error-ice.rs:4:17\n    |\n LL | struct Baz {\n    |        --- while parsing this struct\n LL |     inner : dyn fn ()\n-   |                 ^^\n+   |                 ^^ expected identifier, found keyword\n    |\n-   = help: unlike in C++, Java, and C#, functions are declared in `impl` blocks\n-   = help: see https://doc.rust-lang.org/book/ch05-03-method-syntax.html for more information\n+help: escape `fn` to use it as an identifier\n+   |\n+LL |     inner : dyn r#fn ()\n+   |                 ++\n \n error[E0412]: cannot find type `dyn` in this scope\n   --> $DIR/fn-field-parse-error-ice.rs:4:13"}, {"sha": "cd8a79ba6874130a76ca66cfdb49a3335468abb7", "filename": "src/test/ui/structs/incomplete-fn-in-struct-definition.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/src%2Ftest%2Fui%2Fstructs%2Fincomplete-fn-in-struct-definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/src%2Ftest%2Fui%2Fstructs%2Fincomplete-fn-in-struct-definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fincomplete-fn-in-struct-definition.rs?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -0,0 +1,5 @@\n+fn main() {}\n+\n+struct S {\n+    fn: u8 //~ ERROR expected identifier, found keyword `fn`\n+}"}, {"sha": "0d12ba9c91688b316a77012424607cacbb88aadb", "filename": "src/test/ui/structs/incomplete-fn-in-struct-definition.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f914b82a754c6d85c0a909ab152f5b611defef73/src%2Ftest%2Fui%2Fstructs%2Fincomplete-fn-in-struct-definition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f914b82a754c6d85c0a909ab152f5b611defef73/src%2Ftest%2Fui%2Fstructs%2Fincomplete-fn-in-struct-definition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fincomplete-fn-in-struct-definition.stderr?ref=f914b82a754c6d85c0a909ab152f5b611defef73", "patch": "@@ -0,0 +1,15 @@\n+error: expected identifier, found keyword `fn`\n+  --> $DIR/incomplete-fn-in-struct-definition.rs:4:5\n+   |\n+LL | struct S {\n+   |        - while parsing this struct\n+LL |     fn: u8\n+   |     ^^ expected identifier, found keyword\n+   |\n+help: escape `fn` to use it as an identifier\n+   |\n+LL |     r#fn: u8\n+   |     ++\n+\n+error: aborting due to previous error\n+"}]}