{"sha": "91444af87a0dbf021e671e329926f840344b1dca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNDQ0YWY4N2EwZGJmMDIxZTY3MWUzMjk5MjZmODQwMzQ0YjFkY2E=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-11-01T15:55:13Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-05-15T08:27:27Z"}, "message": "Refactor try_mark_previous_green.", "tree": {"sha": "1eab84775d88292e73398283f383e7b246a6e90f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1eab84775d88292e73398283f383e7b246a6e90f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91444af87a0dbf021e671e329926f840344b1dca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91444af87a0dbf021e671e329926f840344b1dca", "html_url": "https://github.com/rust-lang/rust/commit/91444af87a0dbf021e671e329926f840344b1dca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91444af87a0dbf021e671e329926f840344b1dca/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2c59ae304f3a6735bce209eb206d610c903da05", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2c59ae304f3a6735bce209eb206d610c903da05", "html_url": "https://github.com/rust-lang/rust/commit/c2c59ae304f3a6735bce209eb206d610c903da05"}], "stats": {"total": 229, "additions": 112, "deletions": 117}, "files": [{"sha": "91521c603c7a759a89b28d46e158e5da98b64a1f", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 112, "deletions": 117, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/91444af87a0dbf021e671e329926f840344b1dca/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91444af87a0dbf021e671e329926f840344b1dca/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=91444af87a0dbf021e671e329926f840344b1dca", "patch": "@@ -488,6 +488,117 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n+    fn try_mark_parent_green<Ctxt: QueryContext<DepKind = K>>(\n+        &self,\n+        tcx: Ctxt,\n+        data: &DepGraphData<K>,\n+        parent_dep_node_index: SerializedDepNodeIndex,\n+        dep_node: &DepNode<K>,\n+    ) -> Option<()> {\n+        let dep_dep_node_color = data.colors.get(parent_dep_node_index);\n+        let dep_dep_node = &data.previous.index_to_node(parent_dep_node_index);\n+\n+        match dep_dep_node_color {\n+            Some(DepNodeColor::Green(_)) => {\n+                // This dependency has been marked as green before, we are\n+                // still fine and can continue with checking the other\n+                // dependencies.\n+                debug!(\n+                    \"try_mark_previous_green({:?}) --- found dependency {:?} to \\\n+                            be immediately green\",\n+                    dep_node, dep_dep_node,\n+                );\n+                return Some(());\n+            }\n+            Some(DepNodeColor::Red) => {\n+                // We found a dependency the value of which has changed\n+                // compared to the previous compilation session. We cannot\n+                // mark the DepNode as green and also don't need to bother\n+                // with checking any of the other dependencies.\n+                debug!(\n+                    \"try_mark_previous_green({:?}) - END - dependency {:?} was immediately red\",\n+                    dep_node, dep_dep_node,\n+                );\n+                return None;\n+            }\n+            None => {}\n+        }\n+\n+        // We don't know the state of this dependency. If it isn't\n+        // an eval_always node, let's try to mark it green recursively.\n+        if !dep_dep_node.kind.is_eval_always() {\n+            debug!(\n+                \"try_mark_previous_green({:?}) --- state of dependency {:?} ({}) \\\n+                                 is unknown, trying to mark it green\",\n+                dep_node, dep_dep_node, dep_dep_node.hash,\n+            );\n+\n+            let node_index =\n+                self.try_mark_previous_green(tcx, data, parent_dep_node_index, dep_dep_node);\n+            if node_index.is_some() {\n+                debug!(\n+                    \"try_mark_previous_green({:?}) --- managed to MARK dependency {:?} as green\",\n+                    dep_node, dep_dep_node\n+                );\n+                return Some(());\n+            }\n+        }\n+\n+        // We failed to mark it green, so we try to force the query.\n+        debug!(\n+            \"try_mark_previous_green({:?}) --- trying to force dependency {:?}\",\n+            dep_node, dep_dep_node\n+        );\n+        if !tcx.try_force_from_dep_node(dep_dep_node) {\n+            // The DepNode could not be forced.\n+            debug!(\n+                \"try_mark_previous_green({:?}) - END - dependency {:?} could not be forced\",\n+                dep_node, dep_dep_node\n+            );\n+            return None;\n+        }\n+\n+        let dep_dep_node_color = data.colors.get(parent_dep_node_index);\n+\n+        match dep_dep_node_color {\n+            Some(DepNodeColor::Green(_)) => {\n+                debug!(\n+                    \"try_mark_previous_green({:?}) --- managed to FORCE dependency {:?} to green\",\n+                    dep_node, dep_dep_node\n+                );\n+                return Some(());\n+            }\n+            Some(DepNodeColor::Red) => {\n+                debug!(\n+                    \"try_mark_previous_green({:?}) - END - dependency {:?} was red after forcing\",\n+                    dep_node, dep_dep_node\n+                );\n+                return None;\n+            }\n+            None => {}\n+        }\n+\n+        if !tcx.dep_context().sess().has_errors_or_delayed_span_bugs() {\n+            panic!(\"try_mark_previous_green() - Forcing the DepNode should have set its color\")\n+        }\n+\n+        // If the query we just forced has resulted in\n+        // some kind of compilation error, we cannot rely on\n+        // the dep-node color having been properly updated.\n+        // This means that the query system has reached an\n+        // invalid state. We let the compiler continue (by\n+        // returning `None`) so it can emit error messages\n+        // and wind down, but rely on the fact that this\n+        // invalid state will not be persisted to the\n+        // incremental compilation cache because of\n+        // compilation errors being present.\n+        debug!(\n+            \"try_mark_previous_green({:?}) - END - dependency {:?} resulted in compilation error\",\n+            dep_node, dep_dep_node\n+        );\n+        return None;\n+    }\n+\n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n     fn try_mark_previous_green<Ctxt: QueryContext<DepKind = K>>(\n         &self,\n@@ -512,123 +623,7 @@ impl<K: DepKind> DepGraph<K> {\n         let prev_deps = data.previous.edge_targets_from(prev_dep_node_index);\n \n         for &dep_dep_node_index in prev_deps {\n-            let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n-\n-            match dep_dep_node_color {\n-                Some(DepNodeColor::Green(_)) => {\n-                    // This dependency has been marked as green before, we are\n-                    // still fine and can continue with checking the other\n-                    // dependencies.\n-                    debug!(\n-                        \"try_mark_previous_green({:?}) --- found dependency {:?} to \\\n-                            be immediately green\",\n-                        dep_node,\n-                        data.previous.index_to_node(dep_dep_node_index)\n-                    );\n-                }\n-                Some(DepNodeColor::Red) => {\n-                    // We found a dependency the value of which has changed\n-                    // compared to the previous compilation session. We cannot\n-                    // mark the DepNode as green and also don't need to bother\n-                    // with checking any of the other dependencies.\n-                    debug!(\n-                        \"try_mark_previous_green({:?}) - END - dependency {:?} was \\\n-                            immediately red\",\n-                        dep_node,\n-                        data.previous.index_to_node(dep_dep_node_index)\n-                    );\n-                    return None;\n-                }\n-                None => {\n-                    let dep_dep_node = &data.previous.index_to_node(dep_dep_node_index);\n-\n-                    // We don't know the state of this dependency. If it isn't\n-                    // an eval_always node, let's try to mark it green recursively.\n-                    if !dep_dep_node.kind.is_eval_always() {\n-                        debug!(\n-                            \"try_mark_previous_green({:?}) --- state of dependency {:?} ({}) \\\n-                                 is unknown, trying to mark it green\",\n-                            dep_node, dep_dep_node, dep_dep_node.hash,\n-                        );\n-\n-                        let node_index = self.try_mark_previous_green(\n-                            tcx,\n-                            data,\n-                            dep_dep_node_index,\n-                            dep_dep_node,\n-                        );\n-                        if node_index.is_some() {\n-                            debug!(\n-                                \"try_mark_previous_green({:?}) --- managed to MARK \\\n-                                    dependency {:?} as green\",\n-                                dep_node, dep_dep_node\n-                            );\n-                            continue;\n-                        }\n-                    }\n-\n-                    // We failed to mark it green, so we try to force the query.\n-                    debug!(\n-                        \"try_mark_previous_green({:?}) --- trying to force \\\n-                            dependency {:?}\",\n-                        dep_node, dep_dep_node\n-                    );\n-                    if tcx.try_force_from_dep_node(dep_dep_node) {\n-                        let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n-\n-                        match dep_dep_node_color {\n-                            Some(DepNodeColor::Green(_)) => {\n-                                debug!(\n-                                    \"try_mark_previous_green({:?}) --- managed to \\\n-                                        FORCE dependency {:?} to green\",\n-                                    dep_node, dep_dep_node\n-                                );\n-                            }\n-                            Some(DepNodeColor::Red) => {\n-                                debug!(\n-                                    \"try_mark_previous_green({:?}) - END - \\\n-                                        dependency {:?} was red after forcing\",\n-                                    dep_node, dep_dep_node\n-                                );\n-                                return None;\n-                            }\n-                            None => {\n-                                if !tcx.dep_context().sess().has_errors_or_delayed_span_bugs() {\n-                                    panic!(\n-                                        \"try_mark_previous_green() - Forcing the DepNode \\\n-                                          should have set its color\"\n-                                    )\n-                                } else {\n-                                    // If the query we just forced has resulted in\n-                                    // some kind of compilation error, we cannot rely on\n-                                    // the dep-node color having been properly updated.\n-                                    // This means that the query system has reached an\n-                                    // invalid state. We let the compiler continue (by\n-                                    // returning `None`) so it can emit error messages\n-                                    // and wind down, but rely on the fact that this\n-                                    // invalid state will not be persisted to the\n-                                    // incremental compilation cache because of\n-                                    // compilation errors being present.\n-                                    debug!(\n-                                        \"try_mark_previous_green({:?}) - END - \\\n-                                            dependency {:?} resulted in compilation error\",\n-                                        dep_node, dep_dep_node\n-                                    );\n-                                    return None;\n-                                }\n-                            }\n-                        }\n-                    } else {\n-                        // The DepNode could not be forced.\n-                        debug!(\n-                            \"try_mark_previous_green({:?}) - END - dependency {:?} \\\n-                                could not be forced\",\n-                            dep_node, dep_dep_node\n-                        );\n-                        return None;\n-                    }\n-                }\n-            }\n+            self.try_mark_parent_green(tcx, data, dep_dep_node_index, dep_node)?\n         }\n \n         // If we got here without hitting a `return` that means that all"}]}