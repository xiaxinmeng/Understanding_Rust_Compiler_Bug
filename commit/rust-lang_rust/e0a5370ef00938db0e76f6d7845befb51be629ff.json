{"sha": "e0a5370ef00938db0e76f6d7845befb51be629ff", "node_id": "C_kwDOAAsO6NoAKGUwYTUzNzBlZjAwOTM4ZGIwZTc2ZjZkNzg0NWJlZmI1MWJlNjI5ZmY", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-01-15T01:45:00Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-01-18T22:25:31Z"}, "message": "Respond to code review comments", "tree": {"sha": "7a8a247b1798652f70bb8116bdacf1741b15292b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a8a247b1798652f70bb8116bdacf1741b15292b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0a5370ef00938db0e76f6d7845befb51be629ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0a5370ef00938db0e76f6d7845befb51be629ff", "html_url": "https://github.com/rust-lang/rust/commit/e0a5370ef00938db0e76f6d7845befb51be629ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0a5370ef00938db0e76f6d7845befb51be629ff/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32930d9ea7cc79239daa19a040cbae9867053af8", "url": "https://api.github.com/repos/rust-lang/rust/commits/32930d9ea7cc79239daa19a040cbae9867053af8", "html_url": "https://github.com/rust-lang/rust/commit/32930d9ea7cc79239daa19a040cbae9867053af8"}], "stats": {"total": 300, "additions": 265, "deletions": 35}, "files": [{"sha": "21a8d7b5634569975ce0029d50e243a38db5194f", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e0a5370ef00938db0e76f6d7845befb51be629ff/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0a5370ef00938db0e76f6d7845befb51be629ff/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs?ref=e0a5370ef00938db0e76f6d7845befb51be629ff", "patch": "@@ -21,6 +21,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::hir::map::Map;\n use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n use rustc_middle::ty;\n use std::collections::BTreeMap;\n@@ -53,15 +54,18 @@ pub fn compute_drop_ranges<'a, 'tcx>(\n     DropRanges { tracked_value_map: drop_ranges.tracked_value_map, nodes: drop_ranges.nodes }\n }\n \n-/// Applies `f` to consumable portion of a HIR node.\n+/// Applies `f` to consumable node in the HIR subtree pointed to by `place`.\n ///\n-/// The `node` parameter should be the result of calling `Map::find(place)`.\n-fn for_each_consumable(\n-    place: TrackedValue,\n-    node: Option<Node<'_>>,\n-    mut f: impl FnMut(TrackedValue),\n-) {\n+/// This includes the place itself, and if the place is a reference to a local\n+/// variable then `f` is also called on the HIR node for that variable as well.\n+///\n+/// For example, if `place` points to `foo()`, then `f` is called once for the\n+/// result of `foo`. On the other hand, if `place` points to `x` then `f` will\n+/// be called both on the `ExprKind::Path` node that represents the expression\n+/// as well as the HirId of the local `x` itself.\n+fn for_each_consumable<'tcx>(hir: Map<'tcx>, place: TrackedValue, mut f: impl FnMut(TrackedValue)) {\n     f(place);\n+    let node = hir.find(place.hir_id());\n     if let Some(Node::Expr(expr)) = node {\n         match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(\n@@ -108,15 +112,37 @@ impl TrackedValue {\n     }\n }\n \n-impl From<&PlaceWithHirId<'_>> for TrackedValue {\n-    fn from(place_with_id: &PlaceWithHirId<'_>) -> Self {\n+/// Represents a reason why we might not be able to convert a HirId or Place\n+/// into a tracked value.\n+#[derive(Debug)]\n+enum TrackedValueConversionError {\n+    /// Place projects are not currently supported.\n+    ///\n+    /// The reasoning around these is kind of subtle, so we choose to be more\n+    /// conservative around these for now. There is not reason in theory we\n+    /// cannot support these, we just have not implemented it yet.\n+    PlaceProjectionsNotSupported,\n+}\n+\n+impl TryFrom<&PlaceWithHirId<'_>> for TrackedValue {\n+    type Error = TrackedValueConversionError;\n+\n+    fn try_from(place_with_id: &PlaceWithHirId<'_>) -> Result<Self, Self::Error> {\n+        if !place_with_id.place.projections.is_empty() {\n+            debug!(\n+                \"TrackedValue from PlaceWithHirId: {:?} has projections, which are not supported.\",\n+                place_with_id\n+            );\n+            return Err(TrackedValueConversionError::PlaceProjectionsNotSupported);\n+        }\n+\n         match place_with_id.place.base {\n             PlaceBase::Rvalue | PlaceBase::StaticItem => {\n-                TrackedValue::Temporary(place_with_id.hir_id)\n+                Ok(TrackedValue::Temporary(place_with_id.hir_id))\n             }\n             PlaceBase::Local(hir_id)\n             | PlaceBase::Upvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id }, .. }) => {\n-                TrackedValue::Variable(hir_id)\n+                Ok(TrackedValue::Variable(hir_id))\n             }\n         }\n     }"}, {"sha": "d7305957f94f8bb1d4a68a488afee59c6808645f", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 153, "deletions": 14, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/e0a5370ef00938db0e76f6d7845befb51be629ff/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0a5370ef00938db0e76f6d7845befb51be629ff/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=e0a5370ef00938db0e76f6d7845befb51be629ff", "patch": "@@ -43,6 +43,41 @@ pub(super) fn build_control_flow_graph<'tcx>(\n /// We are interested in points where a variables is dropped or initialized, and the control flow\n /// of the code. We identify locations in code by their post-order traversal index, so it is\n /// important for this traversal to match that in `RegionResolutionVisitor` and `InteriorVisitor`.\n+///\n+/// We make several simplifying assumptions, with the goal of being more conservative than\n+/// necessary rather than less conservative (since being less conservative is unsound, but more\n+/// conservative is still safe). These assumptions are:\n+///\n+/// 1. Moving a variable `a` counts as a move of the whole variable.\n+/// 2. Moving a partial path like `a.b.c` is ignored.\n+/// 3. Reinitializing through a field (e.g. `a.b.c = 5`) counds as a reinitialization of all of\n+///    `a`.\n+///\n+/// Some examples:\n+///\n+/// Rule 1:\n+/// ```rust\n+/// let mut a = (vec![0], vec![0]);\n+/// drop(a);\n+/// // `a` is not considered initialized.\n+/// ```\n+///\n+/// Rule 2:\n+/// ```rust\n+/// let mut a = (vec![0], vec![0]);\n+/// drop(a.0);\n+/// drop(a.1);\n+/// // `a` is still considered initialized.\n+/// ```\n+///\n+/// Rule 3:\n+/// ```rust\n+/// let mut a = (vec![0], vec![0]);\n+/// drop(a);\n+/// a.1 = vec![1];\n+/// // all of `a` is considered initialized\n+/// ```\n+\n struct DropRangeVisitor<'a, 'tcx> {\n     hir: Map<'tcx>,\n     places: ConsumedAndBorrowedPlaces,\n@@ -89,23 +124,76 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n             .get(&expr.hir_id)\n             .map_or(vec![], |places| places.iter().cloned().collect());\n         for place in places {\n-            for_each_consumable(place, self.hir.find(place.hir_id()), |value| {\n-                self.record_drop(value)\n-            });\n+            for_each_consumable(self.hir, place, |value| self.record_drop(value));\n         }\n     }\n \n+    /// Marks an expression as being reinitialized.\n+    ///\n+    /// Note that we always approximated on the side of things being more\n+    /// initialized than they actually are, as opposed to less. In cases such\n+    /// as `x.y = ...`, we would consider all of `x` as being initialized\n+    /// instead of just the `y` field.\n+    ///\n+    /// This is because it is always safe to consider something initialized\n+    /// even when it is not, but the other way around will cause problems.\n+    ///\n+    /// In the future, we will hopefully tighten up these rules to be more\n+    /// precise.\n     fn reinit_expr(&mut self, expr: &hir::Expr<'_>) {\n-        if let ExprKind::Path(hir::QPath::Resolved(\n-            _,\n-            hir::Path { res: hir::def::Res::Local(hir_id), .. },\n-        )) = expr.kind\n-        {\n-            let location = self.expr_index;\n-            debug!(\"reinitializing {:?} at {:?}\", hir_id, location);\n-            self.drop_ranges.reinit_at(TrackedValue::Variable(*hir_id), location);\n-        } else {\n-            debug!(\"reinitializing {:?} is not supported\", expr);\n+        // Walk the expression to find the base. For example, in an expression\n+        // like `*a[i].x`, we want to find the `a` and mark that as\n+        // reinitialized.\n+        match expr.kind {\n+            ExprKind::Path(hir::QPath::Resolved(\n+                _,\n+                hir::Path { res: hir::def::Res::Local(hir_id), .. },\n+            )) => {\n+                // This is the base case, where we have found an actual named variable.\n+\n+                let location = self.expr_index;\n+                debug!(\"reinitializing {:?} at {:?}\", hir_id, location);\n+                self.drop_ranges.reinit_at(TrackedValue::Variable(*hir_id), location);\n+            }\n+\n+            ExprKind::Field(base, _) => self.reinit_expr(base),\n+\n+            // Most expressions do not refer to something where we need to track\n+            // reinitializations.\n+            //\n+            // Some of these may be interesting in the future\n+            ExprKind::Path(..)\n+            | ExprKind::Box(_)\n+            | ExprKind::ConstBlock(_)\n+            | ExprKind::Array(_)\n+            | ExprKind::Call(_, _)\n+            | ExprKind::MethodCall(_, _, _, _)\n+            | ExprKind::Tup(_)\n+            | ExprKind::Binary(_, _, _)\n+            | ExprKind::Unary(_, _)\n+            | ExprKind::Lit(_)\n+            | ExprKind::Cast(_, _)\n+            | ExprKind::Type(_, _)\n+            | ExprKind::DropTemps(_)\n+            | ExprKind::Let(_, _, _)\n+            | ExprKind::If(_, _, _)\n+            | ExprKind::Loop(_, _, _, _)\n+            | ExprKind::Match(_, _, _)\n+            | ExprKind::Closure(_, _, _, _, _)\n+            | ExprKind::Block(_, _)\n+            | ExprKind::Assign(_, _, _)\n+            | ExprKind::AssignOp(_, _, _)\n+            | ExprKind::Index(_, _)\n+            | ExprKind::AddrOf(_, _, _)\n+            | ExprKind::Break(_, _)\n+            | ExprKind::Continue(_)\n+            | ExprKind::Ret(_)\n+            | ExprKind::InlineAsm(_)\n+            | ExprKind::LlvmInlineAsm(_)\n+            | ExprKind::Struct(_, _, _)\n+            | ExprKind::Repeat(_, _)\n+            | ExprKind::Yield(_, _)\n+            | ExprKind::Err => (),\n         }\n     }\n \n@@ -158,13 +246,47 @@ impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n                 self.drop_ranges.add_control_edge(true_end, self.expr_index + 1);\n             }\n             ExprKind::Match(scrutinee, arms, ..) => {\n+                // We walk through the match expression almost like a chain of if expressions.\n+                // Here's a diagram to follow along with:\n+                //\n+                //           \u250c\u2500\u2510\n+                //     match \u2502A\u2502 {\n+                //       \u250c\u2500\u2500\u2500\u2534\u2500\u2518\n+                //       \u2502\n+                //      \u250c\u25bc\u250c\u2500\u2500\u2500\u25ba\u250c\u2500\u2510   \u250c\u2500\u2510\n+                //      \u2502B\u2502 if \u2502C\u2502 =>\u2502D\u2502,\n+                //      \u2514\u2500\u2518    \u251c\u2500\u2534\u2500\u2500\u25ba\u2514\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                //          \u250c\u2500\u2500\u2518              \u2502\n+                //       \u250c\u2500\u2500\u2518                 \u2502\n+                //       \u2502                    \u2502\n+                //      \u250c\u25bc\u250c\u2500\u2500\u2500\u25ba\u250c\u2500\u2510   \u250c\u2500\u2510      \u2502\n+                //      \u2502E\u2502 if \u2502F\u2502 =>\u2502G\u2502,     \u2502\n+                //      \u2514\u2500\u2518    \u251c\u2500\u2534\u2500\u2500\u25ba\u2514\u2500\u2534\u2510     \u2502\n+                //             \u2502        \u2502     \u2502\n+                //     }       \u25bc        \u25bc     \u2502\n+                //     \u250c\u2500\u2510\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                //     \u2502H\u2502\n+                //     \u2514\u2500\u2518\n+                //\n+                // The order we want is that the scrutinee (A) flows into the first pattern (B),\n+                // which flows into the guard (C). Then the guard either flows into the arm body\n+                // (D) or into the start of the next arm (E). Finally, the body flows to the end\n+                // of the match block (H).\n+                //\n+                // The subsequent arms follow the same ordering. First we go to the pattern, then\n+                // the guard (if present, otherwise it flows straight into the body), then into\n+                // the body and then to the end of the match expression.\n+                //\n+                // The comments below show which edge is being added.\n                 self.visit_expr(scrutinee);\n \n                 let (guard_exit, arm_end_ids) = arms.iter().fold(\n                     (self.expr_index, vec![]),\n                     |(incoming_edge, mut arm_end_ids), hir::Arm { pat, body, guard, .. }| {\n+                        // A -> B, or C -> E\n                         self.drop_ranges.add_control_edge(incoming_edge, self.expr_index + 1);\n                         self.visit_pat(pat);\n+                        // B -> C and E -> F are added implicitly due to the traversal order.\n                         match guard {\n                             Some(Guard::If(expr)) => self.visit_expr(expr),\n                             Some(Guard::IfLet(pat, expr)) => {\n@@ -173,17 +295,34 @@ impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n                             }\n                             None => (),\n                         }\n+                        // Likewise, C -> D and F -> G are added implicitly.\n+\n+                        // Save C, F, so we can add the other outgoing edge.\n                         let to_next_arm = self.expr_index;\n+\n                         // The default edge does not get added since we also have an explicit edge,\n                         // so we also need to add an edge to the next node as well.\n+                        //\n+                        // This adds C -> D, F -> G\n                         self.drop_ranges.add_control_edge(self.expr_index, self.expr_index + 1);\n                         self.visit_expr(body);\n+\n+                        // Save the end of the body so we can add the exit edge once we know where\n+                        // the exit is.\n                         arm_end_ids.push(self.expr_index);\n+\n+                        // Pass C to the next iteration, as well as vec![D]\n+                        //\n+                        // On the last round through, we pass F and vec![D, G] so that we can\n+                        // add all the exit edges.\n                         (to_next_arm, arm_end_ids)\n                     },\n                 );\n+                // F -> H\n                 self.drop_ranges.add_control_edge(guard_exit, self.expr_index + 1);\n+\n                 arm_end_ids.into_iter().for_each(|arm_end| {\n+                    // D -> H, G -> H\n                     self.drop_ranges.add_control_edge(arm_end, self.expr_index + 1)\n                 });\n             }\n@@ -275,7 +414,7 @@ impl DropRangesBuilder {\n         let mut tracked_value_map = FxHashMap::<_, TrackedValueIndex>::default();\n         let mut next = <_>::from(0u32);\n         for value in tracked_values {\n-            for_each_consumable(value, hir.find(value.hir_id()), |value| {\n+            for_each_consumable(hir, value, |value| {\n                 if !tracked_value_map.contains_key(&value) {\n                     tracked_value_map.insert(value, next);\n                     next = next + 1;"}, {"sha": "059a135a6fb6517018424292aa9ee3858e2614c8", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0a5370ef00938db0e76f6d7845befb51be629ff/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0a5370ef00938db0e76f6d7845befb51be629ff/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=e0a5370ef00938db0e76f6d7845befb51be629ff", "patch": "@@ -85,11 +85,9 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n             \"consume {:?}; diag_expr_id={:?}, using parent {:?}\",\n             place_with_id, diag_expr_id, parent\n         );\n-        // We do not currently support partial drops or reinits, so just ignore\n-        // any places with projections.\n-        if place_with_id.place.projections.is_empty() {\n-            self.mark_consumed(parent, place_with_id.into());\n-        }\n+        place_with_id\n+            .try_into()\n+            .map_or((), |tracked_value| self.mark_consumed(parent, tracked_value));\n     }\n \n     fn borrow(\n@@ -98,7 +96,9 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n         _diag_expr_id: HirId,\n         _bk: rustc_middle::ty::BorrowKind,\n     ) {\n-        self.places.borrowed.insert(place_with_id.into());\n+        place_with_id\n+            .try_into()\n+            .map_or(false, |tracked_value| self.places.borrowed.insert(tracked_value));\n     }\n \n     fn mutate("}, {"sha": "36f6e78cb3bfe12333526c3ac56b2a4969f319f9", "filename": "src/test/ui/generator/partial-drop.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e0a5370ef00938db0e76f6d7845befb51be629ff/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0a5370ef00938db0e76f6d7845befb51be629ff/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.rs?ref=e0a5370ef00938db0e76f6d7845befb51be629ff", "patch": "@@ -15,7 +15,26 @@ fn main() {\n         let guard = Bar { foo: Foo, x: 42 };\n         drop(guard.foo);\n         yield;\n-    })\n+    });\n+\n+    assert_send(|| {\n+        //~^ ERROR generator cannot be sent between threads safely\n+        // FIXME: it would be nice to make this work.\n+        let guard = Bar { foo: Foo, x: 42 };\n+        drop(guard);\n+        guard.foo = Foo;\n+        guard.x = 23;\n+        yield;\n+    });\n+\n+    assert_send(|| {\n+        //~^ ERROR generator cannot be sent between threads safely\n+        // FIXME: it would be nice to make this work.\n+        let guard = Bar { foo: Foo, x: 42 };\n+        let Bar { foo, x } = guard;\n+        drop(foo);\n+        yield;\n+    });\n }\n \n fn assert_send<T: Send>(_: T) {}"}, {"sha": "9a1b0734d8c865111a2397a6f82c9053a86e1c7e", "filename": "src/test/ui/generator/partial-drop.stderr", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e0a5370ef00938db0e76f6d7845befb51be629ff/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0a5370ef00938db0e76f6d7845befb51be629ff/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fpartial-drop.stderr?ref=e0a5370ef00938db0e76f6d7845befb51be629ff", "patch": "@@ -13,13 +13,59 @@ LL |         let guard = Bar { foo: Foo, x: 42 };\n LL |         drop(guard.foo);\n LL |         yield;\n    |         ^^^^^ yield occurs here, with `guard` maybe used later\n-LL |     })\n+LL |     });\n    |     - `guard` is later dropped here\n note: required by a bound in `assert_send`\n-  --> $DIR/partial-drop.rs:21:19\n+  --> $DIR/partial-drop.rs:40:19\n    |\n LL | fn assert_send<T: Send>(_: T) {}\n    |                   ^^^^ required by this bound in `assert_send`\n \n-error: aborting due to previous error\n+error: generator cannot be sent between threads safely\n+  --> $DIR/partial-drop.rs:20:5\n+   |\n+LL |     assert_send(|| {\n+   |     ^^^^^^^^^^^ generator is not `Send`\n+   |\n+   = help: within `[generator@$DIR/partial-drop.rs:20:17: 28:6]`, the trait `Send` is not implemented for `Foo`\n+note: generator is not `Send` as this value is used across a yield\n+  --> $DIR/partial-drop.rs:27:9\n+   |\n+LL |         let guard = Bar { foo: Foo, x: 42 };\n+   |             ----- has type `Bar` which is not `Send`\n+...\n+LL |         yield;\n+   |         ^^^^^ yield occurs here, with `guard` maybe used later\n+LL |     });\n+   |     - `guard` is later dropped here\n+note: required by a bound in `assert_send`\n+  --> $DIR/partial-drop.rs:40:19\n+   |\n+LL | fn assert_send<T: Send>(_: T) {}\n+   |                   ^^^^ required by this bound in `assert_send`\n+\n+error: generator cannot be sent between threads safely\n+  --> $DIR/partial-drop.rs:30:5\n+   |\n+LL |     assert_send(|| {\n+   |     ^^^^^^^^^^^ generator is not `Send`\n+   |\n+   = help: within `[generator@$DIR/partial-drop.rs:30:17: 37:6]`, the trait `Send` is not implemented for `Foo`\n+note: generator is not `Send` as this value is used across a yield\n+  --> $DIR/partial-drop.rs:36:9\n+   |\n+LL |         let guard = Bar { foo: Foo, x: 42 };\n+   |             ----- has type `Bar` which is not `Send`\n+...\n+LL |         yield;\n+   |         ^^^^^ yield occurs here, with `guard` maybe used later\n+LL |     });\n+   |     - `guard` is later dropped here\n+note: required by a bound in `assert_send`\n+  --> $DIR/partial-drop.rs:40:19\n+   |\n+LL | fn assert_send<T: Send>(_: T) {}\n+   |                   ^^^^ required by this bound in `assert_send`\n+\n+error: aborting due to 3 previous errors\n "}]}