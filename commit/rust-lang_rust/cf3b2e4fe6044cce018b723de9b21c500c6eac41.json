{"sha": "cf3b2e4fe6044cce018b723de9b21c500c6eac41", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmM2IyZTRmZTYwNDRjY2UwMThiNzIzZGU5YjIxYzUwMGM2ZWFjNDE=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-11-06T17:24:47Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-11-06T17:25:44Z"}, "message": "Implement low-hanging fruit of collection conventions\n\n* Renames/deprecates the simplest and most obvious methods\n* Adds FIXME(conventions)s for outstanding work\n* Marks \"handled\" methods as unstable\n\nNOTE: the semantics of reserve and reserve_exact have changed!\nOther methods have had their semantics changed as well, but in a\nway that should obviously not typecheck if used incorrectly.\n\nLots of work and breakage to come, but this handles most of the core\nAPIs and most eggregious breakage. Future changes should *mostly* focus on\nniche collections, APIs, or simply back-compat additions.\n\n[breaking-change]", "tree": {"sha": "b8ed60b532124b478db06e66677f9987bb03a2df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8ed60b532124b478db06e66677f9987bb03a2df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf3b2e4fe6044cce018b723de9b21c500c6eac41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf3b2e4fe6044cce018b723de9b21c500c6eac41", "html_url": "https://github.com/rust-lang/rust/commit/cf3b2e4fe6044cce018b723de9b21c500c6eac41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf3b2e4fe6044cce018b723de9b21c500c6eac41/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60a669a1743b845dfa349684ef057bc98ec6d840", "url": "https://api.github.com/repos/rust-lang/rust/commits/60a669a1743b845dfa349684ef057bc98ec6d840", "html_url": "https://github.com/rust-lang/rust/commit/60a669a1743b845dfa349684ef057bc98ec6d840"}], "stats": {"total": 2448, "additions": 1386, "deletions": 1062}, "files": [{"sha": "c9d6007744944b3f50d32a994a9bc5373d249ae1", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -162,6 +162,8 @@ use core::ptr;\n use slice;\n use vec::Vec;\n \n+// FIXME(conventions): implement into_iter\n+\n /// A priority queue implemented with a binary heap.\n ///\n /// This will be a max-heap.\n@@ -184,6 +186,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// use std::collections::BinaryHeap;\n     /// let pq: BinaryHeap<uint> = BinaryHeap::new();\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> BinaryHeap<T> { BinaryHeap{data: vec!(),} }\n \n     /// Creates an empty `BinaryHeap` with a specific capacity.\n@@ -197,6 +200,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// use std::collections::BinaryHeap;\n     /// let pq: BinaryHeap<uint> = BinaryHeap::with_capacity(10u);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(capacity: uint) -> BinaryHeap<T> {\n         BinaryHeap { data: Vec::with_capacity(capacity) }\n     }\n@@ -234,6 +238,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Items<'a, T> {\n         Items { iter: self.data.iter() }\n     }\n@@ -268,10 +273,19 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let pq: BinaryHeap<uint> = BinaryHeap::with_capacity(100u);\n     /// assert!(pq.capacity() >= 100u);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n \n-    /// Reserves capacity for exactly `n` elements in the `BinaryHeap`.\n-    /// Do nothing if the capacity is already sufficient.\n+    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n+    /// given `BinaryHeap`. Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it requests. Therefore\n+    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n+    /// insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Example\n     ///\n@@ -280,12 +294,17 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// let mut pq: BinaryHeap<uint> = BinaryHeap::new();\n     /// pq.reserve_exact(100u);\n-    /// assert!(pq.capacity() == 100u);\n+    /// assert!(pq.capacity() >= 100u);\n     /// ```\n-    pub fn reserve_exact(&mut self, n: uint) { self.data.reserve_exact(n) }\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve_exact(&mut self, additional: uint) { self.data.reserve_exact(additional) }\n \n-    /// Reserves capacity for at least `n` elements in the `BinaryHeap`.\n-    /// Do nothing if the capacity is already sufficient.\n+    /// Reserves capacity for at least `additional` more elements to be inserted in the\n+    /// `BinaryHeap`. The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Example\n     ///\n@@ -296,8 +315,15 @@ impl<T: Ord> BinaryHeap<T> {\n     /// pq.reserve(100u);\n     /// assert!(pq.capacity() >= 100u);\n     /// ```\n-    pub fn reserve(&mut self, n: uint) {\n-        self.data.reserve(n)\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve(&mut self, additional: uint) {\n+        self.data.reserve(additional)\n+    }\n+\n+    /// Discards as much additional capacity as possible.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn shrink_to_fit(&mut self) {\n+        self.data.shrink_to_fit()\n     }\n \n     /// Removes the greatest item from a queue and returns it, or `None` if it\n@@ -314,6 +340,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(pq.pop(), Some(1i));\n     /// assert_eq!(pq.pop(), None);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn pop(&mut self) -> Option<T> {\n         match self.data.pop() {\n             None           => { None }\n@@ -342,6 +369,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(pq.len(), 3);\n     /// assert_eq!(pq.top(), Some(&5i));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push(&mut self, item: T) {\n         self.data.push(item);\n         let new_len = self.len() - 1;\n@@ -495,12 +523,15 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n \n     /// Returns the length of the queue.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.data.len() }\n \n     /// Returns true if the queue contains no elements\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Drops all items from the queue.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) { self.data.truncate(0) }\n }\n \n@@ -528,8 +559,7 @@ impl<T: Ord> Extendable<T> for BinaryHeap<T> {\n     fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n         let (lower, _) = iter.size_hint();\n \n-        let len = self.capacity();\n-        self.reserve(len + lower);\n+        self.reserve(lower);\n \n         for elem in iter {\n             self.push(elem);"}, {"sha": "833cfc04c552befe8625f05b43e5663d68ded994", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -75,6 +75,8 @@ use std::hash;\n \n use vec::Vec;\n \n+// FIXME(conventions): look, we just need to refactor this whole thing. Inside and out.\n+\n type MatchWords<'a> = Chain<MaskWords<'a>, Skip<Take<Enumerate<Repeat<u32>>>>>;\n // Take two BitV's, and return iterators of their words, where the shorter one\n // has been padded with 0's\n@@ -216,6 +218,7 @@ impl Bitv {\n     /// use std::collections::Bitv;\n     /// let mut bv = Bitv::new();\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> Bitv {\n         Bitv { storage: Vec::new(), nbits: 0 }\n     }\n@@ -613,6 +616,7 @@ impl Bitv {\n     /// bv.truncate(2);\n     /// assert!(bv.eq_vec([false, true]));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn truncate(&mut self, len: uint) {\n         if len < self.len() {\n             self.nbits = len;\n@@ -760,14 +764,17 @@ impl Bitv {\n \n     /// Return the total number of bits in this vector\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.nbits }\n \n     /// Returns true if there are no bits in this vector\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears all bits in this vector.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         for w in self.storage.iter_mut() { *w = 0u32; }\n     }\n@@ -849,8 +856,7 @@ impl Clone for Bitv {\n     #[inline]\n     fn clone_from(&mut self, source: &Bitv) {\n         self.nbits = source.nbits;\n-        self.storage.reserve(source.storage.len());\n-        for (i, w) in self.storage.iter_mut().enumerate() { *w = source.storage[i]; }\n+        self.storage.clone_from(&source.storage);\n     }\n }\n \n@@ -1052,6 +1058,7 @@ impl BitvSet {\n     /// let mut s = BitvSet::new();\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> BitvSet {\n         BitvSet(Bitv::new())\n     }\n@@ -1067,6 +1074,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(nbits: uint) -> BitvSet {\n         let bitv = Bitv::with_capacity(nbits, false);\n         BitvSet::from_bitv(bitv)\n@@ -1106,6 +1114,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint {\n         let &BitvSet(ref bitv) = self;\n         bitv.capacity()\n@@ -1212,6 +1221,7 @@ impl BitvSet {\n     /// println!(\"new capacity: {}\", s.capacity());\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn shrink_to_fit(&mut self) {\n         let &BitvSet(ref mut bitv) = self;\n         // Obtain original length\n@@ -1240,6 +1250,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> BitPositions<'a> {\n         BitPositions {set: self, next_idx: 0u}\n     }\n@@ -1262,6 +1273,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn union<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n         TwoBitPositions {\n             set: self,\n@@ -1290,6 +1302,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Take<TwoBitPositions<'a>> {\n         let min = cmp::min(self.capacity(), other.capacity());\n         TwoBitPositions {\n@@ -1326,6 +1339,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n         TwoBitPositions {\n             set: self,\n@@ -1355,6 +1369,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n         TwoBitPositions {\n             set: self,\n@@ -1473,27 +1488,31 @@ impl BitvSet {\n \n     /// Return the number of set bits in this set.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint  {\n         let &BitvSet(ref bitv) = self;\n         bitv.storage.iter().fold(0, |acc, &n| acc + n.count_ones())\n     }\n \n     /// Returns whether there are no bits set in this set\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool {\n         let &BitvSet(ref bitv) = self;\n         bitv.storage.iter().all(|&n| n == 0)\n     }\n \n     /// Clears all bits in this set\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         let &BitvSet(ref mut bitv) = self;\n         bitv.clear();\n     }\n \n     /// Returns `true` if this set contains the specified integer.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains(&self, value: &uint) -> bool {\n         let &BitvSet(ref bitv) = self;\n         *value < bitv.nbits && bitv.get(*value)\n@@ -1502,12 +1521,14 @@ impl BitvSet {\n     /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_disjoint(&self, other: &BitvSet) -> bool {\n         self.intersection(other).next().is_none()\n     }\n \n     /// Returns `true` if the set is a subset of another.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_subset(&self, other: &BitvSet) -> bool {\n         let &BitvSet(ref self_bitv) = self;\n         let &BitvSet(ref other_bitv) = other;\n@@ -1521,12 +1542,14 @@ impl BitvSet {\n \n     /// Returns `true` if the set is a superset of another.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_superset(&self, other: &BitvSet) -> bool {\n         other.is_subset(self)\n     }\n \n     /// Adds a value to the set. Returns `true` if the value was not already\n     /// present in the set.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn insert(&mut self, value: uint) -> bool {\n         if self.contains(&value) {\n             return false;\n@@ -1545,6 +1568,7 @@ impl BitvSet {\n \n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn remove(&mut self, value: &uint) -> bool {\n         if !self.contains(value) {\n             return false;"}, {"sha": "9b644115f301009811b59c1173837dbf556a53db", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 89, "deletions": 87, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -25,6 +25,8 @@ use core::fmt::Show;\n \n use ring_buf::RingBuf;\n \n+// FIXME(conventions): implement bounded iterators\n+\n /// A map based on a B-Tree.\n ///\n /// B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing\n@@ -125,6 +127,7 @@ pub struct OccupiedEntry<'a, K:'a, V:'a> {\n \n impl<K: Ord, V> BTreeMap<K, V> {\n     /// Makes a new empty BTreeMap with a reasonable choice for B.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> BTreeMap<K, V> {\n         //FIXME(Gankro): Tune this as a function of size_of<K/V>?\n         BTreeMap::with_b(6)\n@@ -155,12 +158,19 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         let b = self.b;\n         // avoid recursive destructors by manually traversing the tree\n         for _ in mem::replace(self, BTreeMap::with_b(b)).into_iter() {};\n     }\n \n+    /// Deprecated: renamed to `get`.\n+    #[deprecated = \"renamed to `get`\"]\n+    pub fn find(&self, key: &K) -> Option<&V> {\n+        self.get(key)\n+    }\n+\n     // Searching in a B-Tree is pretty straightforward.\n     //\n     // Start at the root. Try to find the key in the current node. If we find it, return it.\n@@ -178,10 +188,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1u, \"a\");\n-    /// assert_eq!(map.find(&1), Some(&\"a\"));\n-    /// assert_eq!(map.find(&2), None);\n+    /// assert_eq!(map.get(&1), Some(&\"a\"));\n+    /// assert_eq!(map.get(&2), None);\n     /// ```\n-    pub fn find(&self, key: &K) -> Option<&V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get(&self, key: &K) -> Option<&V> {\n         let mut cur_node = &self.root;\n         loop {\n             match cur_node.search(key) {\n@@ -209,9 +220,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n-    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains_key(&self, key: &K) -> bool {\n-        self.find(key).is_some()\n+        self.get(key).is_some()\n+    }\n+\n+    /// Deprecated: renamed to `get_mut`.\n+    #[deprecated = \"renamed to `get_mut`\"]\n+    pub fn find_mut(&mut self, key: &K) -> Option<&mut V> {\n+        self.get_mut(key)\n     }\n \n     /// Returns a mutable reference to the value corresponding to the key.\n@@ -223,14 +240,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1u, \"a\");\n-    /// match map.find_mut(&1) {\n+    /// match map.get_mut(&1) {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n-    // See `find` for implementation notes, this is basically a copy-paste with mut's added\n-    pub fn find_mut(&mut self, key: &K) -> Option<&mut V> {\n+    // See `get` for implementation notes, this is basically a copy-paste with mut's added\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n         loop {\n@@ -248,6 +266,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n \n+    /// Deprecated: renamed to `insert`.\n+    #[deprecated = \"renamed to `insert`\"]\n+    pub fn swap(&mut self, key: K, value: V) -> Option<V> {\n+        self.insert(key, value)\n+    }\n+\n     // Insertion in a B-Tree is a bit complicated.\n     //\n     // First we do the same kind of search described in `find`. But we need to maintain a stack of\n@@ -283,14 +307,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// assert_eq!(map.swap(37u, \"a\"), None);\n+    /// assert_eq!(map.insert(37u, \"a\"), None);\n     /// assert_eq!(map.is_empty(), false);\n     ///\n     /// map.insert(37, \"b\");\n-    /// assert_eq!(map.swap(37, \"c\"), Some(\"b\"));\n+    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    pub fn swap(&mut self, key: K, mut value: V) -> Option<V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, key: K, mut value: V) -> Option<V> {\n         // This is a stack of rawptrs to nodes paired with indices, respectively\n         // representing the nodes and edges of our search path. We have to store rawptrs\n         // because as far as Rust is concerned, we can mutate aliased data with such a\n@@ -338,25 +363,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n \n-    /// Inserts a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Returns `true` if the key did\n-    /// not already exist in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map = BTreeMap::new();\n-    /// assert_eq!(map.insert(2u, \"value\"), true);\n-    /// assert_eq!(map.insert(2, \"value2\"), false);\n-    /// assert_eq!(map[2], \"value2\");\n-    /// ```\n-    #[inline]\n-    pub fn insert(&mut self, key: K, value: V) -> bool {\n-        self.swap(key, value).is_none()\n-    }\n-\n     // Deletion is the most complicated operation for a B-Tree.\n     //\n     // First we do the same kind of search described in\n@@ -392,6 +398,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     //      the underflow handling process on the parent. If merging merges the last two children\n     //      of the root, then we replace the root with the merged node.\n \n+    /// Deprecated: renamed to `remove`.\n+    #[deprecated = \"renamed to `remove`\"]\n+    pub fn pop(&mut self, key: &K) -> Option<V> {\n+        self.remove(key)\n+    }\n+\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n@@ -402,10 +414,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1u, \"a\");\n-    /// assert_eq!(map.pop(&1), Some(\"a\"));\n-    /// assert_eq!(map.pop(&1), None);\n+    /// assert_eq!(map.remove(&1), Some(\"a\"));\n+    /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    pub fn pop(&mut self, key: &K) -> Option<V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, key: &K) -> Option<V> {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n@@ -426,24 +439,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             }\n         }\n     }\n-\n-    /// Removes a key-value pair from the map. Returns `true` if the key\n-    /// was present in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map = BTreeMap::new();\n-    /// assert_eq!(map.remove(&1u), false);\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.remove(&1), true);\n-    /// ```\n-    #[inline]\n-    pub fn remove(&mut self, key: &K) -> bool {\n-        self.pop(key).is_some()\n-    }\n }\n \n /// The stack module provides a safe interface for constructing and manipulating a stack of ptrs\n@@ -793,13 +788,13 @@ impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n \n impl<K: Ord, V> Index<K, V> for BTreeMap<K, V> {\n     fn index(&self, key: &K) -> &V {\n-        self.find(key).expect(\"no entry found for key\")\n+        self.get(key).expect(\"no entry found for key\")\n     }\n }\n \n impl<K: Ord, V> IndexMut<K, V> for BTreeMap<K, V> {\n     fn index_mut(&mut self, key: &K) -> &mut V {\n-        self.find_mut(key).expect(\"no entry found for key\")\n+        self.get_mut(key).expect(\"no entry found for key\")\n     }\n }\n \n@@ -891,8 +886,8 @@ impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n \n             // Handle any operation on the left stack as necessary\n             match op {\n-                Push(item) => { self.left.push(item); },\n-                Pop => { self.left.pop(); },\n+                Push(item) => { self.left.push_back(item); },\n+                Pop => { self.left.pop_back(); },\n             }\n         }\n     }\n@@ -933,8 +928,8 @@ impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n             };\n \n             match op {\n-                Push(item) => { self.right.push(item); },\n-                Pop => { self.right.pop(); }\n+                Push(item) => { self.right.push_back(item); },\n+                Pop => { self.right.pop_back(); }\n             }\n         }\n     }\n@@ -1010,6 +1005,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n         let len = self.len();\n         Entries {\n@@ -1023,6 +1019,7 @@ impl<K, V> BTreeMap<K, V> {\n     }\n \n     /// Gets a mutable iterator over the entries of the map.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter_mut<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n         let len = self.len();\n         MutEntries {\n@@ -1036,6 +1033,7 @@ impl<K, V> BTreeMap<K, V> {\n     }\n \n     /// Gets an owning iterator over the entries of the map.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveEntries<K, V> {\n         let len = self.len();\n         MoveEntries {\n@@ -1049,11 +1047,13 @@ impl<K, V> BTreeMap<K, V> {\n     }\n \n     /// Gets an iterator over the keys of the map.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         self.iter().map(|(k, _)| k)\n     }\n \n     /// Gets an iterator over the values of the map.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         self.iter().map(|(_, v)| v)\n     }\n@@ -1070,6 +1070,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements.\n@@ -1084,6 +1085,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n@@ -1137,58 +1139,58 @@ mod test {\n         assert_eq!(map.len(), 0);\n \n         for i in range(0, size) {\n-            assert_eq!(map.swap(i, 10*i), None);\n+            assert_eq!(map.insert(i, 10*i), None);\n             assert_eq!(map.len(), i + 1);\n         }\n \n         for i in range(0, size) {\n-            assert_eq!(map.find(&i).unwrap(), &(i*10));\n+            assert_eq!(map.get(&i).unwrap(), &(i*10));\n         }\n \n         for i in range(size, size*2) {\n-            assert_eq!(map.find(&i), None);\n+            assert_eq!(map.get(&i), None);\n         }\n \n         for i in range(0, size) {\n-            assert_eq!(map.swap(i, 100*i), Some(10*i));\n+            assert_eq!(map.insert(i, 100*i), Some(10*i));\n             assert_eq!(map.len(), size);\n         }\n \n         for i in range(0, size) {\n-            assert_eq!(map.find(&i).unwrap(), &(i*100));\n+            assert_eq!(map.get(&i).unwrap(), &(i*100));\n         }\n \n         for i in range(0, size/2) {\n-            assert_eq!(map.pop(&(i*2)), Some(i*200));\n+            assert_eq!(map.remove(&(i*2)), Some(i*200));\n             assert_eq!(map.len(), size - i - 1);\n         }\n \n         for i in range(0, size/2) {\n-            assert_eq!(map.find(&(2*i)), None);\n-            assert_eq!(map.find(&(2*i+1)).unwrap(), &(i*200 + 100));\n+            assert_eq!(map.get(&(2*i)), None);\n+            assert_eq!(map.get(&(2*i+1)).unwrap(), &(i*200 + 100));\n         }\n \n         for i in range(0, size/2) {\n-            assert_eq!(map.pop(&(2*i)), None);\n-            assert_eq!(map.pop(&(2*i+1)), Some(i*200 + 100));\n+            assert_eq!(map.remove(&(2*i)), None);\n+            assert_eq!(map.remove(&(2*i+1)), Some(i*200 + 100));\n             assert_eq!(map.len(), size/2 - i - 1);\n         }\n     }\n \n     #[test]\n     fn test_basic_small() {\n         let mut map = BTreeMap::new();\n-        assert_eq!(map.pop(&1), None);\n-        assert_eq!(map.find(&1), None);\n-        assert_eq!(map.swap(1u, 1u), None);\n-        assert_eq!(map.find(&1), Some(&1));\n-        assert_eq!(map.swap(1, 2), Some(1));\n-        assert_eq!(map.find(&1), Some(&2));\n-        assert_eq!(map.swap(2, 4), None);\n-        assert_eq!(map.find(&2), Some(&4));\n-        assert_eq!(map.pop(&1), Some(2));\n-        assert_eq!(map.pop(&2), Some(4));\n-        assert_eq!(map.pop(&1), None);\n+        assert_eq!(map.remove(&1), None);\n+        assert_eq!(map.get(&1), None);\n+        assert_eq!(map.insert(1u, 1u), None);\n+        assert_eq!(map.get(&1), Some(&1));\n+        assert_eq!(map.insert(1, 2), Some(1));\n+        assert_eq!(map.get(&1), Some(&2));\n+        assert_eq!(map.insert(2, 4), None);\n+        assert_eq!(map.get(&2), Some(&4));\n+        assert_eq!(map.remove(&1), Some(2));\n+        assert_eq!(map.remove(&2), Some(4));\n+        assert_eq!(map.remove(&1), None);\n     }\n \n     #[test]\n@@ -1283,7 +1285,7 @@ mod test {\n                 assert_eq!(view.set(100), 10);\n             }\n         }\n-        assert_eq!(map.find(&1).unwrap(), &100);\n+        assert_eq!(map.get(&1).unwrap(), &100);\n         assert_eq!(map.len(), 6);\n \n \n@@ -1295,7 +1297,7 @@ mod test {\n                 *v *= 10;\n             }\n         }\n-        assert_eq!(map.find(&2).unwrap(), &200);\n+        assert_eq!(map.get(&2).unwrap(), &200);\n         assert_eq!(map.len(), 6);\n \n         // Existing key (take)\n@@ -1305,7 +1307,7 @@ mod test {\n                 assert_eq!(view.take(), 30);\n             }\n         }\n-        assert_eq!(map.find(&3), None);\n+        assert_eq!(map.get(&3), None);\n         assert_eq!(map.len(), 5);\n \n \n@@ -1316,7 +1318,7 @@ mod test {\n                 assert_eq!(*view.set(1000), 1000);\n             }\n         }\n-        assert_eq!(map.find(&10).unwrap(), &1000);\n+        assert_eq!(map.get(&10).unwrap(), &1000);\n         assert_eq!(map.len(), 6);\n     }\n }\n@@ -1374,15 +1376,15 @@ mod bench {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n         find_rand_n(100, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.find(&i); });\n+                    |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_rand_10_000(b: &mut Bencher) {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n         find_rand_n(10_000, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.find(&i); });\n+                    |m, i| { m.get(&i); });\n     }\n \n     // Find seq\n@@ -1391,23 +1393,23 @@ mod bench {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n         find_seq_n(100, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.find(&i); });\n+                   |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_seq_10_000(b: &mut Bencher) {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n         find_seq_n(10_000, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.find(&i); });\n+                   |m, i| { m.get(&i); });\n     }\n \n     fn bench_iter(b: &mut Bencher, size: uint) {\n         let mut map = BTreeMap::<uint, uint>::new();\n         let mut rng = weak_rng();\n \n         for _ in range(0, size) {\n-            map.swap(rng.gen(), rng.gen());\n+            map.insert(rng.gen(), rng.gen());\n         }\n \n         b.iter(|| {"}, {"sha": "f6a3de11d13df0d30eb9a0e0698baf0a93a48629", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -20,6 +20,9 @@ use core::{iter, fmt};\n use core::iter::Peekable;\n use core::fmt::Show;\n \n+// FIXME(conventions): implement bounded iterators\n+// FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n+\n /// A set based on a B-Tree.\n ///\n /// See BTreeMap's documentation for a detailed discussion of this collection's performance\n@@ -61,6 +64,7 @@ pub struct UnionItems<'a, T:'a> {\n \n impl<T: Ord> BTreeSet<T> {\n     /// Makes a new BTreeSet with a reasonable choice of B.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::new() }\n     }\n@@ -75,35 +79,41 @@ impl<T: Ord> BTreeSet<T> {\n \n impl<T> BTreeSet<T> {\n     /// Gets an iterator over the BTreeSet's contents.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Items<'a, T> {\n         self.map.keys()\n     }\n \n     /// Gets an iterator for moving out the BtreeSet's contents.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveItems<T> {\n         self.map.into_iter().map(|(k, _)| k)\n     }\n }\n \n impl<T: Ord> BTreeSet<T> {\n     /// Visits the values representing the difference, in ascending order.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> DifferenceItems<'a, T> {\n         DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the symmetric difference, in ascending order.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n         -> SymDifferenceItems<'a, T> {\n         SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the intersection, in ascending order.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n         -> IntersectionItems<'a, T> {\n         IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the union, in ascending order.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> UnionItems<'a, T> {\n         UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n@@ -120,6 +130,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.insert(1i);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -134,6 +145,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.insert(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the set, removing all values.\n@@ -148,6 +160,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         self.map.clear()\n     }\n@@ -163,8 +176,9 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains(&self, value: &T) -> bool {\n-        self.map.find(value).is_some()\n+        self.map.contains_key(value)\n     }\n \n     /// Returns `true` if the set has no elements in common with `other`.\n@@ -184,6 +198,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(1);\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool {\n         self.intersection(other).next().is_none()\n     }\n@@ -204,6 +219,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// set.insert(4);\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n         // Stolen from TreeMap\n         let mut x = self.iter();\n@@ -248,6 +264,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// set.insert(2);\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_superset(&self, other: &BTreeSet<T>) -> bool {\n         other.is_subset(self)\n     }\n@@ -266,8 +283,9 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.insert(2i), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn insert(&mut self, value: T) -> bool {\n-        self.map.insert(value, ())\n+        self.map.insert(value, ()).is_none()\n     }\n \n     /// Removes a value from the set. Returns `true` if the value was\n@@ -284,8 +302,9 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn remove(&mut self, value: &T) -> bool {\n-        self.map.remove(value)\n+        self.map.remove(value).is_some()\n     }\n }\n "}, {"sha": "9d9955141df15ae4b1c7960657956863efb0fabd", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 87, "deletions": 60, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -195,6 +195,7 @@ impl<T> Default for DList<T> {\n impl<T> DList<T> {\n     /// Creates an empty `DList`.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> DList<T> {\n         DList{list_head: None, list_tail: Rawlink::none(), length: 0}\n     }\n@@ -209,9 +210,9 @@ impl<T> DList<T> {\n     /// use std::collections::DList;\n     ///\n     /// let mut dl = DList::new();\n-    /// dl.push(1i);\n-    /// dl.push(2);\n-    /// dl.push(3);\n+    /// dl.push_back(1i);\n+    /// dl.push_back(2);\n+    /// dl.push_back(3);\n     ///\n     /// dl.rotate_forward();\n     ///\n@@ -236,9 +237,9 @@ impl<T> DList<T> {\n     /// use std::collections::DList;\n     ///\n     /// let mut dl = DList::new();\n-    /// dl.push(1i);\n-    /// dl.push(2);\n-    /// dl.push(3);\n+    /// dl.push_back(1i);\n+    /// dl.push_back(2);\n+    /// dl.push_back(3);\n     ///\n     /// dl.rotate_backward();\n     ///\n@@ -264,10 +265,10 @@ impl<T> DList<T> {\n     ///\n     /// let mut a = DList::new();\n     /// let mut b = DList::new();\n-    /// a.push(1i);\n-    /// a.push(2);\n-    /// b.push(3i);\n-    /// b.push(4);\n+    /// a.push_back(1i);\n+    /// a.push_back(2);\n+    /// b.push_back(3i);\n+    /// b.push_back(4);\n     ///\n     /// a.append(b);\n     ///\n@@ -305,10 +306,10 @@ impl<T> DList<T> {\n     ///\n     /// let mut a = DList::new();\n     /// let mut b = DList::new();\n-    /// a.push(1i);\n-    /// a.push(2);\n-    /// b.push(3i);\n-    /// b.push(4);\n+    /// a.push_back(1i);\n+    /// a.push_back(2);\n+    /// b.push_back(3i);\n+    /// b.push_back(4);\n     ///\n     /// a.prepend(b);\n     ///\n@@ -333,10 +334,10 @@ impl<T> DList<T> {\n     /// use std::collections::DList;\n     ///\n     /// let mut a: DList<int> = DList::new();\n-    /// a.push(2i);\n-    /// a.push(4);\n-    /// a.push(7);\n-    /// a.push(8);\n+    /// a.push_back(2i);\n+    /// a.push_back(4);\n+    /// a.push_back(7);\n+    /// a.push_back(8);\n     ///\n     /// // insert 11 before the first odd number in the list\n     /// a.insert_when(11, |&e, _| e % 2 == 1);\n@@ -387,12 +388,14 @@ impl<T> DList<T> {\n \n     /// Provides a forward iterator.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Items<'a, T> {\n         Items{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n     /// Provides a forward iterator with mutable references.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n         let head_raw = match self.list_head {\n             Some(ref mut h) => Rawlink::some(&mut **h),\n@@ -408,6 +411,7 @@ impl<T> DList<T> {\n \n     /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveItems<T> {\n         MoveItems{list: self}\n     }\n@@ -416,6 +420,7 @@ impl<T> DList<T> {\n     ///\n     /// This operation should compute in O(1) time.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool {\n         self.list_head.is_none()\n     }\n@@ -424,6 +429,7 @@ impl<T> DList<T> {\n     ///\n     /// This operation should compute in O(1) time.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint {\n         self.length\n     }\n@@ -432,41 +438,47 @@ impl<T> DList<T> {\n     ///\n     /// This operation should compute in O(n) time.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         *self = DList::new()\n     }\n \n     /// Provides a reference to the front element, or `None` if the list is\n     /// empty.\n     #[inline]\n-    pub fn front<'a>(&'a self) -> Option<&'a T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn front(&self) -> Option<&T> {\n         self.list_head.as_ref().map(|head| &head.value)\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the list\n     /// is empty.\n     #[inline]\n-    pub fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn front_mut(&mut self) -> Option<&mut T> {\n         self.list_head.as_mut().map(|head| &mut head.value)\n     }\n \n     /// Provides a reference to the back element, or `None` if the list is\n     /// empty.\n     #[inline]\n-    pub fn back<'a>(&'a self) -> Option<&'a T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn back(&self) -> Option<&T> {\n         self.list_tail.resolve_immut().as_ref().map(|tail| &tail.value)\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n     /// is empty.\n     #[inline]\n-    pub fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn back_mut(&mut self) -> Option<&mut T> {\n         self.list_tail.resolve().map(|tail| &mut tail.value)\n     }\n \n     /// Adds an element first in the list.\n     ///\n     /// This operation should compute in O(1) time.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push_front(&mut self, elt: T) {\n         self.push_front_node(box Node::new(elt))\n     }\n@@ -475,10 +487,17 @@ impl<T> DList<T> {\n     /// empty.\n     ///\n     /// This operation should compute in O(1) time.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn pop_front(&mut self) -> Option<T> {\n         self.pop_front_node().map(|box Node{value, ..}| value)\n     }\n \n+    /// Deprecated: Renamed to `push_back`.\n+    #[deprecated = \"Renamed to `push_back`\"]\n+    pub fn push(&mut self, elt: T) {\n+        self.push_back(elt)\n+    }\n+\n     /// Appends an element to the back of a list\n     ///\n     /// # Example\n@@ -487,14 +506,21 @@ impl<T> DList<T> {\n     /// use std::collections::DList;\n     ///\n     /// let mut d = DList::new();\n-    /// d.push(1i);\n-    /// d.push(3);\n+    /// d.push_back(1i);\n+    /// d.push_back(3);\n     /// assert_eq!(3, *d.back().unwrap());\n     /// ```\n-    pub fn push(&mut self, elt: T) {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn push_back(&mut self, elt: T) {\n         self.push_back_node(box Node::new(elt))\n     }\n \n+    /// Deprecated: Renamed to `pop_back`.\n+    #[deprecated = \"Renamed to `pop_back`\"]\n+    pub fn pop(&mut self) -> Option<T> {\n+        self.pop_back()\n+    }\n+\n     /// Removes the last element from a list and returns it, or `None` if\n     /// it is empty.\n     ///\n@@ -504,12 +530,13 @@ impl<T> DList<T> {\n     /// use std::collections::DList;\n     ///\n     /// let mut d = DList::new();\n-    /// assert_eq!(d.pop(), None);\n-    /// d.push(1i);\n-    /// d.push(3);\n-    /// assert_eq!(d.pop(), Some(3));\n+    /// assert_eq!(d.pop_back(), None);\n+    /// d.push_back(1i);\n+    /// d.push_back(3);\n+    /// assert_eq!(d.pop_back(), Some(3));\n     /// ```\n-    pub fn pop(&mut self) -> Option<T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn pop_back(&mut self) -> Option<T> {\n         self.pop_back_node().map(|box Node{value, ..}| value)\n     }\n }\n@@ -682,7 +709,7 @@ impl<A> Iterator<A> for MoveItems<A> {\n \n impl<A> DoubleEndedIterator<A> for MoveItems<A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> { self.list.pop() }\n+    fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n }\n \n impl<A> FromIterator<A> for DList<A> {\n@@ -695,7 +722,7 @@ impl<A> FromIterator<A> for DList<A> {\n \n impl<A> Extendable<A> for DList<A> {\n     fn extend<T: Iterator<A>>(&mut self, mut iterator: T) {\n-        for elt in iterator { self.push(elt); }\n+        for elt in iterator { self.push_back(elt); }\n     }\n }\n \n@@ -801,21 +828,21 @@ mod tests {\n     fn test_basic() {\n         let mut m: DList<Box<int>> = DList::new();\n         assert_eq!(m.pop_front(), None);\n-        assert_eq!(m.pop(), None);\n+        assert_eq!(m.pop_back(), None);\n         assert_eq!(m.pop_front(), None);\n         m.push_front(box 1);\n         assert_eq!(m.pop_front(), Some(box 1));\n-        m.push(box 2);\n-        m.push(box 3);\n+        m.push_back(box 2);\n+        m.push_back(box 3);\n         assert_eq!(m.len(), 2);\n         assert_eq!(m.pop_front(), Some(box 2));\n         assert_eq!(m.pop_front(), Some(box 3));\n         assert_eq!(m.len(), 0);\n         assert_eq!(m.pop_front(), None);\n-        m.push(box 1);\n-        m.push(box 3);\n-        m.push(box 5);\n-        m.push(box 7);\n+        m.push_back(box 1);\n+        m.push_back(box 3);\n+        m.push_back(box 5);\n+        m.push_back(box 7);\n         assert_eq!(m.pop_front(), Some(box 1));\n \n         let mut n = DList::new();\n@@ -853,19 +880,19 @@ mod tests {\n         {\n             let mut m = DList::new();\n             let mut n = DList::new();\n-            n.push(2i);\n+            n.push_back(2i);\n             m.append(n);\n             assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop(), Some(2));\n+            assert_eq!(m.pop_back(), Some(2));\n             check_links(&m);\n         }\n         {\n             let mut m = DList::new();\n             let n = DList::new();\n-            m.push(2i);\n+            m.push_back(2i);\n             m.append(n);\n             assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop(), Some(2));\n+            assert_eq!(m.pop_back(), Some(2));\n             check_links(&m);\n         }\n \n@@ -887,10 +914,10 @@ mod tests {\n         {\n             let mut m = DList::new();\n             let mut n = DList::new();\n-            n.push(2i);\n+            n.push_back(2i);\n             m.prepend(n);\n             assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop(), Some(2));\n+            assert_eq!(m.pop_back(), Some(2));\n             check_links(&m);\n         }\n \n@@ -948,9 +975,9 @@ mod tests {\n     #[test]\n     fn test_iterator_clone() {\n         let mut n = DList::new();\n-        n.push(2i);\n-        n.push(3);\n-        n.push(4);\n+        n.push_back(2i);\n+        n.push_back(3);\n+        n.push_back(4);\n         let mut it = n.iter();\n         it.next();\n         let mut jt = it.clone();\n@@ -1005,7 +1032,7 @@ mod tests {\n         let mut n = DList::new();\n         assert!(n.iter_mut().next().is_none());\n         n.push_front(4i);\n-        n.push(5);\n+        n.push_back(5);\n         let mut it = n.iter_mut();\n         assert_eq!(it.size_hint(), (2, Some(2)));\n         assert!(it.next().is_some());\n@@ -1079,8 +1106,8 @@ mod tests {\n         assert_eq!(n.pop_front(), Some(1));\n \n         let mut m = DList::new();\n-        m.push(2i);\n-        m.push(4);\n+        m.push_back(2i);\n+        m.push_back(4);\n         m.insert_ordered(3);\n         check_links(&m);\n         assert_eq!(vec![2,3,4], m.into_iter().collect::<Vec<int>>());\n@@ -1117,7 +1144,7 @@ mod tests {\n         assert!(n == m);\n         n.push_front(1);\n         assert!(n != m);\n-        m.push(1);\n+        m.push_back(1);\n         assert!(n == m);\n \n         let n = list_from([2i,3,4]);\n@@ -1132,9 +1159,9 @@ mod tests {\n \n       assert!(hash::hash(&x) == hash::hash(&y));\n \n-      x.push(1i);\n-      x.push(2);\n-      x.push(3);\n+      x.push_back(1i);\n+      x.push_back(2);\n+      x.push_back(3);\n \n       y.push_front(3i);\n       y.push_front(2);\n@@ -1214,7 +1241,7 @@ mod tests {\n             let r: u8 = rand::random();\n             match r % 6 {\n                 0 => {\n-                    m.pop();\n+                    m.pop_back();\n                     v.pop();\n                 }\n                 1 => {\n@@ -1226,7 +1253,7 @@ mod tests {\n                     v.insert(0, -i);\n                 }\n                 3 | 5 | _ => {\n-                    m.push(i);\n+                    m.push_back(i);\n                     v.push(i);\n                 }\n             }\n@@ -1262,16 +1289,16 @@ mod tests {\n     fn bench_push_back(b: &mut test::Bencher) {\n         let mut m: DList<int> = DList::new();\n         b.iter(|| {\n-            m.push(0);\n+            m.push_back(0);\n         })\n     }\n \n     #[bench]\n     fn bench_push_back_pop_back(b: &mut test::Bencher) {\n         let mut m: DList<int> = DList::new();\n         b.iter(|| {\n-            m.push(0);\n-            m.pop();\n+            m.push_back(0);\n+            m.pop_back();\n         })\n     }\n "}, {"sha": "454d4f1ca872324b5e4dbc9c87d38d73edcadb46", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 124, "deletions": 68, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -16,6 +16,10 @@\n use core::prelude::*;\n use core::fmt;\n \n+// FIXME(conventions): implement BitXor\n+// FIXME(contentions): implement union family of methods? (general design may be wrong here)\n+// FIXME(conventions): implement len\n+\n #[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n /// A specialized `Set` implementation to use enum types.\n pub struct EnumSet<E> {\n@@ -47,52 +51,104 @@ pub trait CLike {\n     fn from_uint(uint) -> Self;\n }\n \n-fn bit<E:CLike>(e: E) -> uint {\n+fn bit<E:CLike>(e: &E) -> uint {\n     1 << e.to_uint()\n }\n \n impl<E:CLike> EnumSet<E> {\n-    /// Returns an empty `EnumSet`.\n+    /// Deprecated: Renamed to `new`.\n+    #[deprecated = \"Renamed to `new`\"]\n     pub fn empty() -> EnumSet<E> {\n+        EnumSet::new()\n+    }\n+\n+    /// Returns an empty `EnumSet`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn new() -> EnumSet<E> {\n         EnumSet {bits: 0}\n     }\n \n     /// Returns true if the `EnumSet` is empty.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool {\n         self.bits == 0\n     }\n \n+    pub fn clear(&mut self) {\n+        self.bits = 0;\n+    }\n+\n     /// Returns `true` if the `EnumSet` contains any enum of the given `EnumSet`.\n+    /// Deprecated: Use `is_disjoint`.\n+    #[deprecated = \"Use `is_disjoint`\"]\n     pub fn intersects(&self, e: EnumSet<E>) -> bool {\n-        (self.bits & e.bits) != 0\n+        !self.is_disjoint(&e)\n     }\n \n-    /// Returns the intersection of both `EnumSets`.\n-    pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & e.bits}\n+    /// Returns `false` if the `EnumSet` contains any enum of the given `EnumSet`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn is_disjoint(&self, other: &EnumSet<E>) -> bool {\n+        (self.bits & other.bits) == 0\n     }\n \n-    /// Returns `true` if a given `EnumSet` is included in an `EnumSet`.\n-    pub fn contains(&self, e: EnumSet<E>) -> bool {\n-        (self.bits & e.bits) == e.bits\n+    /// Returns `true` if a given `EnumSet` is included in this `EnumSet`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn is_superset(&self, other: &EnumSet<E>) -> bool {\n+        (self.bits & other.bits) == other.bits\n+    }\n+\n+    /// Returns `true` if this `EnumSet` is included in the given `EnumSet`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn is_subset(&self, other: &EnumSet<E>) -> bool {\n+        other.is_subset(self)\n     }\n \n     /// Returns the union of both `EnumSets`.\n     pub fn union(&self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits | e.bits}\n     }\n \n-    /// Adds an enum to an `EnumSet`.\n+    /// Returns the intersection of both `EnumSets`.\n+    pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> {\n+        EnumSet {bits: self.bits & e.bits}\n+    }\n+\n+    /// Deprecated: Use `insert`.\n+    #[deprecated = \"Use `insert`\"]\n     pub fn add(&mut self, e: E) {\n-        self.bits |= bit(e);\n+        self.insert(e);\n     }\n \n-    /// Returns `true` if an `EnumSet` contains a given enum.\n+    /// Adds an enum to the `EnumSet`, and returns `true` if it wasn't there before\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, e: E) -> bool {\n+        let result = !self.contains(&e);\n+        self.bits |= bit(&e);\n+        result\n+    }\n+\n+    /// Removes an enum from the EnumSet\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, e: &E) -> bool {\n+        let result = self.contains(e);\n+        self.bits &= !bit(e);\n+        result\n+    }\n+\n+    /// Deprecated: use `contains`.\n+    #[deprecated = \"use `contains\"]\n     pub fn contains_elem(&self, e: E) -> bool {\n+        self.contains(&e)\n+    }\n+\n+    /// Returns `true` if an `EnumSet` contains a given enum.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn contains(&self, e: &E) -> bool {\n         (self.bits & bit(e)) != 0\n     }\n \n     /// Returns an iterator over an `EnumSet`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter(&self) -> Items<E> {\n         Items::new(self.bits)\n     }\n@@ -174,18 +230,18 @@ mod test {\n     }\n \n     #[test]\n-    fn test_empty() {\n-        let e: EnumSet<Foo> = EnumSet::empty();\n+    fn test_new() {\n+        let e: EnumSet<Foo> = EnumSet::new();\n         assert!(e.is_empty());\n     }\n \n     #[test]\n     fn test_show() {\n-        let mut e = EnumSet::empty();\n+        let mut e = EnumSet::new();\n         assert_eq!(\"{}\", e.to_string().as_slice());\n-        e.add(A);\n+        e.insert(A);\n         assert_eq!(\"{A}\", e.to_string().as_slice());\n-        e.add(C);\n+        e.insert(C);\n         assert_eq!(\"{A, C}\", e.to_string().as_slice());\n     }\n \n@@ -194,100 +250,100 @@ mod test {\n \n     #[test]\n     fn test_two_empties_do_not_intersect() {\n-        let e1: EnumSet<Foo> = EnumSet::empty();\n-        let e2: EnumSet<Foo> = EnumSet::empty();\n-        assert!(!e1.intersects(e2));\n+        let e1: EnumSet<Foo> = EnumSet::new();\n+        let e2: EnumSet<Foo> = EnumSet::new();\n+        assert!(e1.is_disjoint(&e2));\n     }\n \n     #[test]\n     fn test_empty_does_not_intersect_with_full() {\n-        let e1: EnumSet<Foo> = EnumSet::empty();\n+        let e1: EnumSet<Foo> = EnumSet::new();\n \n-        let mut e2: EnumSet<Foo> = EnumSet::empty();\n-        e2.add(A);\n-        e2.add(B);\n-        e2.add(C);\n+        let mut e2: EnumSet<Foo> = EnumSet::new();\n+        e2.insert(A);\n+        e2.insert(B);\n+        e2.insert(C);\n \n-        assert!(!e1.intersects(e2));\n+        assert!(e1.is_disjoint(&e2));\n     }\n \n     #[test]\n     fn test_disjoint_intersects() {\n-        let mut e1: EnumSet<Foo> = EnumSet::empty();\n-        e1.add(A);\n+        let mut e1: EnumSet<Foo> = EnumSet::new();\n+        e1.insert(A);\n \n-        let mut e2: EnumSet<Foo> = EnumSet::empty();\n-        e2.add(B);\n+        let mut e2: EnumSet<Foo> = EnumSet::new();\n+        e2.insert(B);\n \n-        assert!(!e1.intersects(e2));\n+        assert!(e1.is_disjoint(&e2));\n     }\n \n     #[test]\n     fn test_overlapping_intersects() {\n-        let mut e1: EnumSet<Foo> = EnumSet::empty();\n-        e1.add(A);\n+        let mut e1: EnumSet<Foo> = EnumSet::new();\n+        e1.insert(A);\n \n-        let mut e2: EnumSet<Foo> = EnumSet::empty();\n-        e2.add(A);\n-        e2.add(B);\n+        let mut e2: EnumSet<Foo> = EnumSet::new();\n+        e2.insert(A);\n+        e2.insert(B);\n \n-        assert!(e1.intersects(e2));\n+        assert!(!e1.is_disjoint(&e2));\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n     // contains and contains_elem\n \n     #[test]\n-    fn test_contains() {\n-        let mut e1: EnumSet<Foo> = EnumSet::empty();\n-        e1.add(A);\n+    fn test_superset() {\n+        let mut e1: EnumSet<Foo> = EnumSet::new();\n+        e1.insert(A);\n \n-        let mut e2: EnumSet<Foo> = EnumSet::empty();\n-        e2.add(A);\n-        e2.add(B);\n+        let mut e2: EnumSet<Foo> = EnumSet::new();\n+        e2.insert(A);\n+        e2.insert(B);\n \n-        assert!(!e1.contains(e2));\n-        assert!(e2.contains(e1));\n+        assert!(!e1.is_superset(&e2));\n+        assert!(e2.is_superset(&e1));\n     }\n \n     #[test]\n-    fn test_contains_elem() {\n-        let mut e1: EnumSet<Foo> = EnumSet::empty();\n-        e1.add(A);\n-        assert!(e1.contains_elem(A));\n-        assert!(!e1.contains_elem(B));\n-        assert!(!e1.contains_elem(C));\n-\n-        e1.add(A);\n-        e1.add(B);\n-        assert!(e1.contains_elem(A));\n-        assert!(e1.contains_elem(B));\n-        assert!(!e1.contains_elem(C));\n+    fn test_contains() {\n+        let mut e1: EnumSet<Foo> = EnumSet::new();\n+        e1.insert(A);\n+        assert!(e1.contains(&A));\n+        assert!(!e1.contains(&B));\n+        assert!(!e1.contains(&C));\n+\n+        e1.insert(A);\n+        e1.insert(B);\n+        assert!(e1.contains(&A));\n+        assert!(e1.contains(&B));\n+        assert!(!e1.contains(&C));\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n     // iter\n \n     #[test]\n     fn test_iterator() {\n-        let mut e1: EnumSet<Foo> = EnumSet::empty();\n+        let mut e1: EnumSet<Foo> = EnumSet::new();\n \n         let elems: Vec<Foo> = e1.iter().collect();\n         assert!(elems.is_empty())\n \n-        e1.add(A);\n+        e1.insert(A);\n         let elems = e1.iter().collect();\n         assert_eq!(vec![A], elems)\n \n-        e1.add(C);\n+        e1.insert(C);\n         let elems = e1.iter().collect();\n         assert_eq!(vec![A,C], elems)\n \n-        e1.add(C);\n+        e1.insert(C);\n         let elems = e1.iter().collect();\n         assert_eq!(vec![A,C], elems)\n \n-        e1.add(B);\n+        e1.insert(B);\n         let elems = e1.iter().collect();\n         assert_eq!(vec![A,B,C], elems)\n     }\n@@ -297,13 +353,13 @@ mod test {\n \n     #[test]\n     fn test_operators() {\n-        let mut e1: EnumSet<Foo> = EnumSet::empty();\n-        e1.add(A);\n-        e1.add(C);\n+        let mut e1: EnumSet<Foo> = EnumSet::new();\n+        e1.insert(A);\n+        e1.insert(C);\n \n-        let mut e2: EnumSet<Foo> = EnumSet::empty();\n-        e2.add(B);\n-        e2.add(C);\n+        let mut e2: EnumSet<Foo> = EnumSet::new();\n+        e2.insert(B);\n+        e2.insert(C);\n \n         let e_union = e1 | e2;\n         let elems = e_union.iter().collect();"}, {"sha": "549ebb14b3e160c7ef5eb8adff4fbf63268132d2", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 218, "deletions": 110, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -27,6 +27,11 @@ use vec::Vec;\n static INITIAL_CAPACITY: uint = 8u; // 2^3\n static MINIMUM_CAPACITY: uint = 2u;\n \n+// FIXME(conventions): implement shrink_to_fit. Awkward with the current design, but it should\n+// be scrapped anyway. Defer to rewrite?\n+// FIXME(conventions): implement into_iter\n+\n+\n /// `RingBuf` is a circular buffer that implements `Deque`.\n #[deriving(Clone)]\n pub struct RingBuf<T> {\n@@ -42,36 +47,65 @@ impl<T> Default for RingBuf<T> {\n \n impl<T> RingBuf<T> {\n     /// Creates an empty `RingBuf`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> RingBuf<T> {\n         RingBuf::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Creates an empty `RingBuf` with space for at least `n` elements.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(n: uint) -> RingBuf<T> {\n         RingBuf{nelts: 0, lo: 0,\n               elts: Vec::from_fn(cmp::max(MINIMUM_CAPACITY, n), |_| None)}\n     }\n \n     /// Retrieves an element in the `RingBuf` by index.\n     ///\n-    /// Fails if there is no element with the given index.\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// buf.push_back(3i);\n+    /// buf.push_back(4);\n+    /// buf.push_back(5);\n+    /// assert_eq!(buf.get(1).unwrap(), &4);\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get(&self, i: uint) -> Option<&T> {\n+        match self.elts.get(i) {\n+            None => None,\n+            Some(opt) => opt.as_ref(),\n+        }\n+    }\n+\n+    /// Retrieves an element in the `RingBuf` mutably by index.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// # #![allow(deprecated)]\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push(3i);\n-    /// buf.push(4);\n-    /// buf.push(5);\n-    /// *buf.get_mut(1) = 7;\n+    /// buf.push_back(3i);\n+    /// buf.push_back(4);\n+    /// buf.push_back(5);\n+    /// match buf.get_mut(1) {\n+    ///     None => {}\n+    ///     Some(elem) => {\n+    ///         *elem = 7;\n+    ///     }\n+    /// }\n+    ///\n     /// assert_eq!(buf[1], 7);\n     /// ```\n-    #[deprecated = \"use indexing instead: `buf[index] = value`\"]\n-    pub fn get_mut(&mut self, i: uint) -> &mut T {\n-        &mut self[i]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get_mut(&mut self, i: uint) -> Option<&mut T> {\n+        match self.elts.get_mut(i) {\n+            None => None,\n+            Some(opt) => opt.as_mut(),\n+        }\n     }\n \n     /// Swaps elements at indices `i` and `j`.\n@@ -86,9 +120,9 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push(3i);\n-    /// buf.push(4);\n-    /// buf.push(5);\n+    /// buf.push_back(3i);\n+    /// buf.push_back(4);\n+    /// buf.push_back(5);\n     /// buf.swap(0, 2);\n     /// assert_eq!(buf[0], 5);\n     /// assert_eq!(buf[2], 3);\n@@ -107,21 +141,70 @@ impl<T> RingBuf<T> {\n         raw_index(self.lo, self.elts.len(), idx)\n     }\n \n-    /// Reserves capacity for exactly `n` elements in the given `RingBuf`,\n-    /// doing nothing if `self`'s capacity is already equal to or greater\n-    /// than the requested capacity.\n-    pub fn reserve_exact(&mut self, n: uint) {\n-        self.elts.reserve_exact(n);\n+    /// Returns the number of elements the `RingBuf` can hold without\n+    /// reallocating.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let buf: RingBuf<int> = RingBuf::with_capacity(10);\n+    /// assert_eq!(buf.capacity(), 10);\n+    /// ```\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn capacity(&self) -> uint {\n+        // FXIME(Gankro): not the actual usable capacity if you use reserve/reserve_exact\n+        self.elts.capacity()\n     }\n \n-    /// Reserves capacity for at least `n` elements in the given `RingBuf`,\n-    /// over-allocating in case the caller needs to reserve additional\n-    /// space.\n+    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n+    /// given `RingBuf`. Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it requests. Therefore\n+    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n+    /// insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n-    /// Do nothing if `self`'s capacity is already equal to or greater\n-    /// than the requested capacity.\n-    pub fn reserve(&mut self, n: uint) {\n-        self.elts.reserve(n);\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf: RingBuf<int> = vec![1].into_iter().collect();\n+    /// buf.reserve_exact(10);\n+    /// assert!(buf.capacity() >= 11);\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve_exact(&mut self, additional: uint) {\n+        // FIXME(Gankro): this is just wrong. The ringbuf won't actually use this space\n+        self.elts.reserve_exact(additional);\n+    }\n+\n+    /// Reserves capacity for at least `additional` more elements to be inserted in the given\n+    /// `Ringbuf`. The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf: RingBuf<int> = vec![1].into_iter().collect();\n+    /// buf.reserve(10);\n+    /// assert!(buf.capacity() >= 11);\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve(&mut self, additional: uint) {\n+        // FIXME(Gankro): this is just wrong. The ringbuf won't actually use this space\n+        self.elts.reserve(additional);\n     }\n \n     /// Returns a front-to-back iterator.\n@@ -132,12 +215,13 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push(5i);\n-    /// buf.push(3);\n-    /// buf.push(4);\n+    /// buf.push_back(5i);\n+    /// buf.push_back(3);\n+    /// buf.push_back(4);\n     /// let b: &[_] = &[&5, &3, &4];\n     /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), b);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter(&self) -> Items<T> {\n         Items{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts.as_slice()}\n     }\n@@ -150,15 +234,16 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push(5i);\n-    /// buf.push(3);\n-    /// buf.push(4);\n+    /// buf.push_back(5i);\n+    /// buf.push_back(3);\n+    /// buf.push_back(4);\n     /// for num in buf.iter_mut() {\n     ///     *num = *num - 2;\n     /// }\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n     /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter_mut(&mut self) -> MutItems<T> {\n         let start_index = raw_index(self.lo, self.elts.len(), 0);\n         let end_index = raw_index(self.lo, self.elts.len(), self.nelts);\n@@ -197,9 +282,10 @@ impl<T> RingBuf<T> {\n     ///\n     /// let mut v = RingBuf::new();\n     /// assert_eq!(v.len(), 0);\n-    /// v.push(1i);\n+    /// v.push_back(1i);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.nelts }\n \n     /// Returns true if the buffer contains no elements\n@@ -214,6 +300,7 @@ impl<T> RingBuf<T> {\n     /// v.push_front(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the buffer, removing all values.\n@@ -224,10 +311,11 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut v = RingBuf::new();\n-    /// v.push(1i);\n+    /// v.push_back(1i);\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         for x in self.elts.iter_mut() { *x = None }\n         self.nelts = 0;\n@@ -245,10 +333,11 @@ impl<T> RingBuf<T> {\n     /// let mut d = RingBuf::new();\n     /// assert_eq!(d.front(), None);\n     ///\n-    /// d.push(1i);\n-    /// d.push(2i);\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n     /// assert_eq!(d.front(), Some(&1i));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn front(&self) -> Option<&T> {\n         if self.nelts > 0 { Some(&self[0]) } else { None }\n     }\n@@ -264,14 +353,15 @@ impl<T> RingBuf<T> {\n     /// let mut d = RingBuf::new();\n     /// assert_eq!(d.front_mut(), None);\n     ///\n-    /// d.push(1i);\n-    /// d.push(2i);\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n     /// match d.front_mut() {\n     ///     Some(x) => *x = 9i,\n     ///     None => (),\n     /// }\n     /// assert_eq!(d.front(), Some(&9i));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         if self.nelts > 0 { Some(&mut self[0]) } else { None }\n     }\n@@ -287,10 +377,11 @@ impl<T> RingBuf<T> {\n     /// let mut d = RingBuf::new();\n     /// assert_eq!(d.back(), None);\n     ///\n-    /// d.push(1i);\n-    /// d.push(2i);\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n     /// assert_eq!(d.back(), Some(&2i));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn back(&self) -> Option<&T> {\n         if self.nelts > 0 { Some(&self[self.nelts - 1]) } else { None }\n     }\n@@ -306,14 +397,15 @@ impl<T> RingBuf<T> {\n     /// let mut d = RingBuf::new();\n     /// assert_eq!(d.back(), None);\n     ///\n-    /// d.push(1i);\n-    /// d.push(2i);\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n     /// match d.back_mut() {\n     ///     Some(x) => *x = 9i,\n     ///     None => (),\n     /// }\n     /// assert_eq!(d.back(), Some(&9i));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         let nelts = self.nelts;\n         if nelts > 0 { Some(&mut self[nelts - 1]) } else { None }\n@@ -328,13 +420,14 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut d = RingBuf::new();\n-    /// d.push(1i);\n-    /// d.push(2i);\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n     ///\n     /// assert_eq!(d.pop_front(), Some(1i));\n     /// assert_eq!(d.pop_front(), Some(2i));\n     /// assert_eq!(d.pop_front(), None);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn pop_front(&mut self) -> Option<T> {\n         let result = self.elts[self.lo].take();\n         if result.is_some() {\n@@ -356,6 +449,7 @@ impl<T> RingBuf<T> {\n     /// d.push_front(2i);\n     /// assert_eq!(d.front(), Some(&2i));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push_front(&mut self, t: T) {\n         if self.nelts == self.elts.len() {\n             grow(self.nelts, &mut self.lo, &mut self.elts);\n@@ -367,6 +461,12 @@ impl<T> RingBuf<T> {\n         self.nelts += 1u;\n     }\n \n+    /// Deprecated: Renamed to `push_back`.\n+    #[deprecated = \"Renamed to `push_back`\"]\n+    pub fn push(&mut self, t: T) {\n+        self.push_back(t)\n+    }\n+\n     /// Appends an element to the back of a buffer\n     ///\n     /// # Example\n@@ -375,11 +475,12 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push(1i);\n-    /// buf.push(3);\n+    /// buf.push_back(1i);\n+    /// buf.push_back(3);\n     /// assert_eq!(3, *buf.back().unwrap());\n     /// ```\n-    pub fn push(&mut self, t: T) {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn push_back(&mut self, t: T) {\n         if self.nelts == self.elts.len() {\n             grow(self.nelts, &mut self.lo, &mut self.elts);\n         }\n@@ -388,6 +489,12 @@ impl<T> RingBuf<T> {\n         self.nelts += 1u;\n     }\n \n+    /// Deprecated: Renamed to `pop_back`.\n+    #[deprecated = \"Renamed to `pop_back`\"]\n+    pub fn pop(&mut self) -> Option<T> {\n+        self.pop_back()\n+    }\n+\n     /// Removes the last element from a buffer and returns it, or `None` if\n     /// it is empty.\n     ///\n@@ -397,12 +504,13 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// assert_eq!(buf.pop(), None);\n-    /// buf.push(1i);\n-    /// buf.push(3);\n-    /// assert_eq!(buf.pop(), Some(3));\n+    /// assert_eq!(buf.pop_back(), None);\n+    /// buf.push_back(1i);\n+    /// buf.push_back(3);\n+    /// assert_eq!(buf.pop_back(), Some(3));\n     /// ```\n-    pub fn pop(&mut self) -> Option<T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn pop_back(&mut self) -> Option<T> {\n         if self.nelts > 0 {\n             self.nelts -= 1;\n             let hi = self.raw_index(self.nelts);\n@@ -523,7 +631,7 @@ impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut Vec<Option<T>>) {\n     assert_eq!(nelts, elts.len());\n     let lo = *loptr;\n-    elts.reserve(nelts * 2);\n+    elts.reserve_exact(nelts);\n     let newlen = elts.capacity();\n \n     /* fill with None */\n@@ -630,7 +738,7 @@ impl<A> FromIterator<A> for RingBuf<A> {\n impl<A> Extendable<A> for RingBuf<A> {\n     fn extend<T: Iterator<A>>(&mut self, mut iterator: T) {\n         for elt in iterator {\n-            self.push(elt);\n+            self.push_back(elt);\n         }\n     }\n }\n@@ -666,9 +774,9 @@ mod tests {\n         assert_eq!(d.len(), 0u);\n         d.push_front(17i);\n         d.push_front(42i);\n-        d.push(137);\n+        d.push_back(137);\n         assert_eq!(d.len(), 3u);\n-        d.push(137);\n+        d.push_back(137);\n         assert_eq!(d.len(), 4u);\n         debug!(\"{}\", d.front());\n         assert_eq!(*d.front().unwrap(), 42);\n@@ -677,21 +785,21 @@ mod tests {\n         let mut i = d.pop_front();\n         debug!(\"{}\", i);\n         assert_eq!(i, Some(42));\n-        i = d.pop();\n+        i = d.pop_back();\n         debug!(\"{}\", i);\n         assert_eq!(i, Some(137));\n-        i = d.pop();\n+        i = d.pop_back();\n         debug!(\"{}\", i);\n         assert_eq!(i, Some(137));\n-        i = d.pop();\n+        i = d.pop_back();\n         debug!(\"{}\", i);\n         assert_eq!(i, Some(17));\n         assert_eq!(d.len(), 0u);\n-        d.push(3);\n+        d.push_back(3);\n         assert_eq!(d.len(), 1u);\n         d.push_front(2);\n         assert_eq!(d.len(), 2u);\n-        d.push(4);\n+        d.push_back(4);\n         assert_eq!(d.len(), 3u);\n         d.push_front(1);\n         assert_eq!(d.len(), 4u);\n@@ -711,22 +819,22 @@ mod tests {\n         assert_eq!(deq.len(), 0);\n         deq.push_front(a.clone());\n         deq.push_front(b.clone());\n-        deq.push(c.clone());\n+        deq.push_back(c.clone());\n         assert_eq!(deq.len(), 3);\n-        deq.push(d.clone());\n+        deq.push_back(d.clone());\n         assert_eq!(deq.len(), 4);\n         assert_eq!((*deq.front().unwrap()).clone(), b.clone());\n         assert_eq!((*deq.back().unwrap()).clone(), d.clone());\n         assert_eq!(deq.pop_front().unwrap(), b.clone());\n-        assert_eq!(deq.pop().unwrap(), d.clone());\n-        assert_eq!(deq.pop().unwrap(), c.clone());\n-        assert_eq!(deq.pop().unwrap(), a.clone());\n+        assert_eq!(deq.pop_back().unwrap(), d.clone());\n+        assert_eq!(deq.pop_back().unwrap(), c.clone());\n+        assert_eq!(deq.pop_back().unwrap(), a.clone());\n         assert_eq!(deq.len(), 0);\n-        deq.push(c.clone());\n+        deq.push_back(c.clone());\n         assert_eq!(deq.len(), 1);\n         deq.push_front(b.clone());\n         assert_eq!(deq.len(), 2);\n-        deq.push(d.clone());\n+        deq.push_back(d.clone());\n         assert_eq!(deq.len(), 3);\n         deq.push_front(a.clone());\n         assert_eq!(deq.len(), 4);\n@@ -750,7 +858,7 @@ mod tests {\n \n         let mut deq = RingBuf::new();\n         for i in range(0u, 66) {\n-            deq.push(i);\n+            deq.push_back(i);\n         }\n \n         for i in range(0u, 66) {\n@@ -788,7 +896,7 @@ mod tests {\n     fn bench_push_back(b: &mut test::Bencher) {\n         let mut deq = RingBuf::new();\n         b.iter(|| {\n-            deq.push(0i);\n+            deq.push_back(0i);\n         })\n     }\n \n@@ -861,17 +969,17 @@ mod tests {\n     #[test]\n     fn test_with_capacity() {\n         let mut d = RingBuf::with_capacity(0);\n-        d.push(1i);\n+        d.push_back(1i);\n         assert_eq!(d.len(), 1);\n         let mut d = RingBuf::with_capacity(50);\n-        d.push(1i);\n+        d.push_back(1i);\n         assert_eq!(d.len(), 1);\n     }\n \n     #[test]\n     fn test_with_capacity_non_power_two() {\n         let mut d3 = RingBuf::with_capacity(3);\n-        d3.push(1i);\n+        d3.push_back(1i);\n \n         // X = None, | = lo\n         // [|1, X, X]\n@@ -880,20 +988,20 @@ mod tests {\n         assert_eq!(d3.front(), None);\n \n         // [X, |3, X]\n-        d3.push(3);\n+        d3.push_back(3);\n         // [X, |3, 6]\n-        d3.push(6);\n+        d3.push_back(6);\n         // [X, X, |6]\n         assert_eq!(d3.pop_front(), Some(3));\n \n         // Pushing the lo past half way point to trigger\n         // the 'B' scenario for growth\n         // [9, X, |6]\n-        d3.push(9);\n+        d3.push_back(9);\n         // [9, 12, |6]\n-        d3.push(12);\n+        d3.push_back(12);\n \n-        d3.push(15);\n+        d3.push_back(15);\n         // There used to be a bug here about how the\n         // RingBuf made growth assumptions about the\n         // underlying Vec which didn't hold and lead\n@@ -912,25 +1020,25 @@ mod tests {\n     #[test]\n     fn test_reserve_exact() {\n         let mut d = RingBuf::new();\n-        d.push(0u64);\n+        d.push_back(0u64);\n         d.reserve_exact(50);\n-        assert_eq!(d.elts.capacity(), 50);\n+        assert!(d.capacity() >= 51);\n         let mut d = RingBuf::new();\n-        d.push(0u32);\n+        d.push_back(0u32);\n         d.reserve_exact(50);\n-        assert_eq!(d.elts.capacity(), 50);\n+        assert!(d.capacity() >= 51);\n     }\n \n     #[test]\n     fn test_reserve() {\n         let mut d = RingBuf::new();\n-        d.push(0u64);\n+        d.push_back(0u64);\n         d.reserve(50);\n-        assert_eq!(d.elts.capacity(), 64);\n+        assert!(d.capacity() >= 64);\n         let mut d = RingBuf::new();\n-        d.push(0u32);\n+        d.push_back(0u32);\n         d.reserve(50);\n-        assert_eq!(d.elts.capacity(), 64);\n+        assert!(d.capacity() >= 64);\n     }\n \n     #[test]\n@@ -948,7 +1056,7 @@ mod tests {\n         assert_eq!(d.iter().size_hint(), (0, Some(0)));\n \n         for i in range(0i, 5) {\n-            d.push(i);\n+            d.push_back(i);\n         }\n         {\n             let b: &[_] = &[&0,&1,&2,&3,&4];\n@@ -979,7 +1087,7 @@ mod tests {\n         assert_eq!(d.iter().rev().next(), None);\n \n         for i in range(0i, 5) {\n-            d.push(i);\n+            d.push_back(i);\n         }\n         {\n             let b: &[_] = &[&4,&3,&2,&1,&0];\n@@ -998,11 +1106,11 @@ mod tests {\n         let mut d = RingBuf::with_capacity(3);\n         assert!(d.iter_mut().rev().next().is_none());\n \n-        d.push(1i);\n-        d.push(2);\n-        d.push(3);\n+        d.push_back(1i);\n+        d.push_back(2);\n+        d.push_back(3);\n         assert_eq!(d.pop_front(), Some(1));\n-        d.push(4);\n+        d.push_back(4);\n \n         assert_eq!(d.iter_mut().rev().map(|x| *x).collect::<Vec<int>>(),\n                    vec!(4, 3, 2));\n@@ -1075,13 +1183,13 @@ mod tests {\n         let mut d = RingBuf::new();\n         d.push_front(17i);\n         d.push_front(42);\n-        d.push(137);\n-        d.push(137);\n+        d.push_back(137);\n+        d.push_back(137);\n         assert_eq!(d.len(), 4u);\n         let mut e = d.clone();\n         assert_eq!(e.len(), 4u);\n         while !d.is_empty() {\n-            assert_eq!(d.pop(), e.pop());\n+            assert_eq!(d.pop_back(), e.pop_back());\n         }\n         assert_eq!(d.len(), 0u);\n         assert_eq!(e.len(), 0u);\n@@ -1094,15 +1202,15 @@ mod tests {\n         d.push_front(137i);\n         d.push_front(17);\n         d.push_front(42);\n-        d.push(137);\n+        d.push_back(137);\n         let mut e = RingBuf::with_capacity(0);\n-        e.push(42);\n-        e.push(17);\n-        e.push(137);\n-        e.push(137);\n+        e.push_back(42);\n+        e.push_back(17);\n+        e.push_back(137);\n+        e.push_back(137);\n         assert!(&e == &d);\n-        e.pop();\n-        e.push(0);\n+        e.pop_back();\n+        e.push_back(0);\n         assert!(e != d);\n         e.clear();\n         assert!(e == RingBuf::new());\n@@ -1113,15 +1221,15 @@ mod tests {\n       let mut x = RingBuf::new();\n       let mut y = RingBuf::new();\n \n-      x.push(1i);\n-      x.push(2);\n-      x.push(3);\n+      x.push_back(1i);\n+      x.push_back(2);\n+      x.push_back(3);\n \n-      y.push(0i);\n-      y.push(1i);\n+      y.push_back(0i);\n+      y.push_back(1i);\n       y.pop_front();\n-      y.push(2);\n-      y.push(3);\n+      y.push_back(2);\n+      y.push_back(3);\n \n       assert!(hash::hash(&x) == hash::hash(&y));\n     }\n@@ -1130,9 +1238,9 @@ mod tests {\n     fn test_ord() {\n         let x = RingBuf::new();\n         let mut y = RingBuf::new();\n-        y.push(1i);\n-        y.push(2);\n-        y.push(3);\n+        y.push_back(1i);\n+        y.push_back(2);\n+        y.push_back(3);\n         assert!(x < y);\n         assert!(y > x);\n         assert!(x <= x);"}, {"sha": "13703d6fe95f11c9c0f93d73785f503482714d57", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -1523,10 +1523,10 @@ mod tests {\n     fn test_capacity() {\n         let mut v = vec![0u64];\n         v.reserve_exact(10u);\n-        assert_eq!(v.capacity(), 10u);\n+        assert!(v.capacity() >= 11u);\n         let mut v = vec![0u32];\n         v.reserve_exact(10u);\n-        assert_eq!(v.capacity(), 10u);\n+        assert!(v.capacity() >= 11u);\n     }\n \n     #[test]\n@@ -2318,7 +2318,7 @@ mod bench {\n                 v.set_len(1024);\n             }\n             for i in range(0u, 1024) {\n-                *v.get_mut(i) = 0;\n+                v[i] = 0;\n             }\n         });\n     }"}, {"sha": "bed14e933bf3dc368ac640bb62a4fd5a351e9801", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -76,6 +76,8 @@ pub use core::str::{truncate_utf16_at_nul, utf8_char_width, CharRange};\n pub use core::str::{Str, StrSlice};\n pub use unicode::str::{UnicodeStrSlice, Words, Graphemes, GraphemeIndices};\n \n+// FIXME(conventions): ensure bit/char conventions are followed by str's API\n+\n /*\n Section: Creating a string\n */\n@@ -308,7 +310,7 @@ impl<'a> Iterator<char> for Recompositions<'a> {\n                                             self.composee = Some(ch);\n                                             return Some(k);\n                                         }\n-                                        self.buffer.push(ch);\n+                                        self.buffer.push_back(ch);\n                                         self.last_ccc = Some(ch_class);\n                                     }\n                                 }\n@@ -322,7 +324,7 @@ impl<'a> Iterator<char> for Recompositions<'a> {\n                                         self.state = Purging;\n                                         return Some(k);\n                                     }\n-                                    self.buffer.push(ch);\n+                                    self.buffer.push_back(ch);\n                                     self.last_ccc = Some(ch_class);\n                                     continue;\n                                 }\n@@ -332,7 +334,7 @@ impl<'a> Iterator<char> for Recompositions<'a> {\n                                         continue;\n                                     }\n                                     None => {\n-                                        self.buffer.push(ch);\n+                                        self.buffer.push_back(ch);\n                                         self.last_ccc = Some(ch_class);\n                                     }\n                                 }"}, {"sha": "ff9bd039a7d9a8ac979471206d241a5bbde0fe63", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -330,8 +330,8 @@ impl String {\n \n         let mut buf = String::new();\n         buf.push(ch);\n-        let size = buf.len() * length;\n-        buf.reserve(size);\n+        let size = buf.len() * (length - 1);\n+        buf.reserve_exact(size);\n         for _ in range(1, length) {\n             buf.push(ch)\n         }\n@@ -379,27 +379,23 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[unstable = \"just implemented, needs to prove itself\"]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint {\n         self.vec.capacity()\n     }\n \n-    /// Reserves capacity for at least `extra` additional bytes in this string buffer.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut s = String::with_capacity(10);\n-    /// let before = s.capacity();\n-    /// s.reserve_additional(100);\n-    /// assert!(s.capacity() - before >= 100);\n-    /// ```\n-    #[inline]\n+    /// Deprecated: Renamed to `reserve`.\n+    #[deprecated = \"Renamed to `reserve`\"]\n     pub fn reserve_additional(&mut self, extra: uint) {\n-        self.vec.reserve_additional(extra)\n+        self.vec.reserve(extra)\n     }\n \n-    /// Reserves capacity for at least `capacity` bytes in this string buffer.\n+    /// Reserves capacity for at least `additional` more bytes to be inserted in the given\n+    /// `String`. The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Example\n     ///\n@@ -409,22 +405,33 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    pub fn reserve(&mut self, capacity: uint) {\n-        self.vec.reserve(capacity)\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve(&mut self, additional: uint) {\n+        self.vec.reserve(additional)\n     }\n \n-    /// Reserves capacity for exactly `capacity` bytes in this string buffer.\n+    /// Reserves the minimum capacity for exactly `additional` more bytes to be inserted in the\n+    /// given `String`. Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it requests. Therefore\n+    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n+    /// insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Example\n     ///\n     /// ```\n     /// let mut s = String::new();\n-    /// s.reserve_exact(10);\n-    /// assert_eq!(s.capacity(), 10);\n+    /// s.reserve(10);\n+    /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    pub fn reserve_exact(&mut self, capacity: uint) {\n-        self.vec.reserve_exact(capacity)\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve_exact(&mut self, additional: uint) {\n+        self.vec.reserve_exact(additional)\n     }\n \n     /// Shrinks the capacity of this string buffer to match its length.\n@@ -439,6 +446,7 @@ impl String {\n     /// assert_eq!(s.capacity(), 3);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn shrink_to_fit(&mut self) {\n         self.vec.shrink_to_fit()\n     }\n@@ -459,7 +467,7 @@ impl String {\n     pub fn push(&mut self, ch: char) {\n         let cur_len = self.len();\n         // This may use up to 4 bytes.\n-        self.vec.reserve_additional(4);\n+        self.vec.reserve(4);\n \n         unsafe {\n             // Attempt to not use an intermediate buffer by just pushing bytes\n@@ -590,7 +598,7 @@ impl String {\n         let len = self.len();\n         assert!(idx <= len);\n         assert!(self.as_slice().is_char_boundary(idx));\n-        self.vec.reserve_additional(4);\n+        self.vec.reserve(4);\n         let mut bits = [0, ..4];\n         let amt = ch.encode_utf8(bits).unwrap();\n "}, {"sha": "ea1c37d036ae0cf0aa3ca6a8df43f9519ff02432", "filename": "src/libcollections/tree/map.rs", "status": "modified", "additions": 159, "deletions": 156, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Ftree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Ftree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmap.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -21,6 +21,9 @@ use std::hash::{Writer, Hash};\n \n use vec::Vec;\n \n+// FIXME(conventions): implement bounded iterators\n+// FIXME(conventions): replace rev_iter(_mut) by making iter(_mut) DoubleEnded\n+\n /// This is implemented as an AA tree, which is a simplified variation of\n /// a red-black tree where red (horizontal) nodes can only be added\n /// as a right child. The time complexity is the same, and re-balancing\n@@ -60,7 +63,7 @@ use vec::Vec;\n /// }\n ///\n /// for key in range(0, 4) {\n-///     match map.find(&key) {\n+///     match map.get(&key) {\n ///         Some(val) => println!(\"{} has a value: {}\", key, val),\n ///         None => println!(\"{} not in map\", key),\n ///     }\n@@ -188,14 +191,14 @@ impl<K: Ord, V> Default for TreeMap<K,V> {\n impl<K: Ord, V> Index<K, V> for TreeMap<K, V> {\n     #[inline]\n     fn index<'a>(&'a self, i: &K) -> &'a V {\n-        self.find(i).expect(\"no entry found for key\")\n+        self.get(i).expect(\"no entry found for key\")\n     }\n }\n \n impl<K: Ord, V> IndexMut<K, V> for TreeMap<K, V> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &K) -> &'a mut V {\n-        self.find_mut(i).expect(\"no entry found for key\")\n+        self.get_mut(i).expect(\"no entry found for key\")\n     }\n }\n \n@@ -208,6 +211,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// use std::collections::TreeMap;\n     /// let mut map: TreeMap<&str, int> = TreeMap::new();\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n     /// Gets a lazy iterator over the keys in the map, in ascending order.\n@@ -226,6 +230,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         self.iter().map(|(k, _v)| k)\n     }\n@@ -247,6 +252,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         self.iter().map(|(_k, v)| v)\n     }\n@@ -267,6 +273,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n         Entries {\n             stack: vec!(),\n@@ -314,10 +321,11 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///     if key == &\"b\" { break }\n     /// }\n     ///\n-    /// assert_eq!(map.find(&\"a\"), Some(&11));\n-    /// assert_eq!(map.find(&\"b\"), Some(&12));\n-    /// assert_eq!(map.find(&\"c\"), Some(&3));\n+    /// assert_eq!(map.get(&\"a\"), Some(&11));\n+    /// assert_eq!(map.get(&\"b\"), Some(&12));\n+    /// assert_eq!(map.get(&\"c\"), Some(&3));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter_mut<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n         MutEntries {\n             stack: vec!(),\n@@ -345,15 +353,15 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///     if key == &\"b\" { break }\n     /// }\n     ///\n-    /// assert_eq!(map.find(&\"a\"), Some(&1));\n-    /// assert_eq!(map.find(&\"b\"), Some(&12));\n-    /// assert_eq!(map.find(&\"c\"), Some(&13));\n+    /// assert_eq!(map.get(&\"a\"), Some(&1));\n+    /// assert_eq!(map.get(&\"b\"), Some(&12));\n+    /// assert_eq!(map.get(&\"c\"), Some(&13));\n     /// ```\n     pub fn rev_iter_mut<'a>(&'a mut self) -> RevMutEntries<'a, K, V> {\n         RevMutEntries{iter: self.iter_mut()}\n     }\n \n-    /// Gets a lazy iterator that consumes the TreeMap.\n+    /// Gets a lazy iterator that consumes the treemap.\n     ///\n     /// # Example\n     ///\n@@ -368,6 +376,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n     /// assert_eq!(vec, vec![(\"a\", 1), (\"b\", 2), (\"c\", 3)]);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveEntries<K, V> {\n         let TreeMap { root, length } = self;\n         let stk = match root {\n@@ -392,6 +401,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements.\n@@ -406,6 +416,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     #[inline]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n@@ -421,11 +432,18 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         self.root = None;\n         self.length = 0\n     }\n \n+    /// Deprecated: Renamed to `get`.\n+    #[deprecated = \"Renamed to `get`\"]\n+    pub fn find(&self, key: &K) -> Option<&V> {\n+        self.get(key)\n+    }\n+\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// # Example\n@@ -435,11 +453,12 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///\n     /// let mut map = TreeMap::new();\n     /// map.insert(1u, \"a\");\n-    /// assert_eq!(map.find(&1), Some(&\"a\"));\n-    /// assert_eq!(map.find(&2), None);\n+    /// assert_eq!(map.get(&1), Some(&\"a\"));\n+    /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[inline]\n-    pub fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get(&self, key: &K) -> Option<&V> {\n         tree_find_with(&self.root, |k2| key.cmp(k2))\n     }\n \n@@ -456,8 +475,15 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains_key(&self, key: &K) -> bool {\n-        self.find(key).is_some()\n+        self.get(key).is_some()\n+    }\n+\n+    /// Deprecated: Renamed to `get_mut`.\n+    #[deprecated = \"Renamed to `get_mut`\"]\n+    pub fn find_mut(&mut self, key: &K) -> Option<&mut V> {\n+        self.get_mut(key)\n     }\n \n     /// Returns a mutable reference to the value corresponding to the key.\n@@ -469,52 +495,22 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///\n     /// let mut map = TreeMap::new();\n     /// map.insert(1u, \"a\");\n-    /// match map.find_mut(&1) {\n+    /// match map.get_mut(&1) {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     #[inline]\n-    pub fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {\n         tree_find_with_mut(&mut self.root, |x| key.cmp(x))\n     }\n \n-    /// Inserts a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Returns `true` if the key did\n-    /// not already exist in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut map = TreeMap::new();\n-    /// assert_eq!(map.insert(2u, \"value\"), true);\n-    /// assert_eq!(map.insert(2, \"value2\"), false);\n-    /// assert_eq!(map[2], \"value2\");\n-    /// ```\n-    #[inline]\n-    pub fn insert(&mut self, key: K, value: V) -> bool {\n-        self.swap(key, value).is_none()\n-    }\n-\n-    /// Removes a key-value pair from the map. Returns `true` if the key\n-    /// was present in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut map = TreeMap::new();\n-    /// assert_eq!(map.remove(&1u), false);\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.remove(&1), true);\n-    /// ```\n-    #[inline]\n-    pub fn remove(&mut self, key: &K) -> bool {\n-        self.pop(key).is_some()\n+    /// Deprecated: Renamed to `insert`.\n+    #[deprecated = \"Renamed to `insert`\"]\n+    pub fn swap(&mut self, key: K, value: V) -> Option<V> {\n+        self.insert(key, value)\n     }\n \n     /// Inserts a key-value pair from the map. If the key already had a value\n@@ -526,19 +522,26 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// use std::collections::TreeMap;\n     ///\n     /// let mut map = TreeMap::new();\n-    /// assert_eq!(map.swap(37u, \"a\"), None);\n+    /// assert_eq!(map.insert(37u, \"a\"), None);\n     /// assert_eq!(map.is_empty(), false);\n     ///\n     /// map.insert(37, \"b\");\n-    /// assert_eq!(map.swap(37, \"c\"), Some(\"b\"));\n+    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    pub fn swap(&mut self, key: K, value: V) -> Option<V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n         let ret = insert(&mut self.root, key, value);\n         if ret.is_none() { self.length += 1 }\n         ret\n     }\n \n+    /// Deprecated: Renamed to `remove`.\n+    #[deprecated = \"Renamed to `remove`\"]\n+    pub fn pop(&mut self, key: &K) -> Option<V> {\n+        self.remove(key)\n+    }\n+\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n@@ -549,10 +552,11 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///\n     /// let mut map = TreeMap::new();\n     /// map.insert(1u, \"a\");\n-    /// assert_eq!(map.pop(&1), Some(\"a\"));\n-    /// assert_eq!(map.pop(&1), None);\n+    /// assert_eq!(map.remove(&1), Some(\"a\"));\n+    /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    pub fn pop(&mut self, key: &K) -> Option<V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, key: &K) -> Option<V> {\n         let ret = remove(&mut self.root, key);\n         if ret.is_some() { self.length -= 1 }\n         ret\n@@ -567,7 +571,7 @@ impl<K, V> TreeMap<K, V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::TreeMap;\n+    /// use collections::tree_map::TreeMap;\n     ///\n     /// fn get_headers() -> TreeMap<String, String> {\n     ///     let mut result = TreeMap::new();\n@@ -585,7 +589,7 @@ impl<K, V> TreeMap<K, V> {\n     /// assert_eq!((*ua.unwrap()).as_slice(), \"Curl-Rust/0.1\");\n     /// ```\n     #[inline]\n-    pub fn find_with<'a>(&'a self, f:|&K| -> Ordering) -> Option<&'a V> {\n+    pub fn find_with(&self, f:|&K| -> Ordering) -> Option<&V> {\n         tree_find_with(&self.root, f)\n     }\n \n@@ -596,9 +600,7 @@ impl<K, V> TreeMap<K, V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut t = TreeMap::new();\n+    /// let mut t = collections::tree_map::TreeMap::new();\n     /// t.insert(\"Content-Type\", \"application/xml\");\n     /// t.insert(\"User-Agent\", \"Curl-Rust/0.1\");\n     ///\n@@ -608,7 +610,7 @@ impl<K, V> TreeMap<K, V> {\n     ///    None => panic!(),\n     /// }\n     ///\n-    /// assert_eq!(t.find(&\"User-Agent\"), Some(&new_ua));\n+    /// assert_eq!(t.get(&\"User-Agent\"), Some(&new_ua));\n     /// ```\n     #[inline]\n     pub fn find_with_mut<'a>(&'a mut self, f:|&K| -> Ordering) -> Option<&'a mut V> {\n@@ -742,10 +744,10 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///     *value = \"changed\";\n     /// }\n     ///\n-    /// assert_eq!(map.find(&2), Some(&\"a\"));\n-    /// assert_eq!(map.find(&4), Some(&\"changed\"));\n-    /// assert_eq!(map.find(&6), Some(&\"changed\"));\n-    /// assert_eq!(map.find(&8), Some(&\"changed\"));\n+    /// assert_eq!(map.get(&2), Some(&\"a\"));\n+    /// assert_eq!(map.get(&4), Some(&\"changed\"));\n+    /// assert_eq!(map.get(&6), Some(&\"changed\"));\n+    /// assert_eq!(map.get(&8), Some(&\"changed\"));\n     /// ```\n     pub fn lower_bound_mut<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n         bound_setup!(self.iter_mut_for_traversal(), k, true)\n@@ -776,10 +778,10 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///     *value = \"changed\";\n     /// }\n     ///\n-    /// assert_eq!(map.find(&2), Some(&\"a\"));\n-    /// assert_eq!(map.find(&4), Some(&\"b\"));\n-    /// assert_eq!(map.find(&6), Some(&\"changed\"));\n-    /// assert_eq!(map.find(&8), Some(&\"changed\"));\n+    /// assert_eq!(map.get(&2), Some(&\"a\"));\n+    /// assert_eq!(map.get(&4), Some(&\"b\"));\n+    /// assert_eq!(map.get(&6), Some(&\"changed\"));\n+    /// assert_eq!(map.get(&8), Some(&\"changed\"));\n     /// ```\n     pub fn upper_bound_mut<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n         bound_setup!(self.iter_mut_for_traversal(), k, false)\n@@ -1287,16 +1289,16 @@ mod test_treemap {\n     #[test]\n     fn find_empty() {\n         let m: TreeMap<int,int> = TreeMap::new();\n-        assert!(m.find(&5) == None);\n+        assert!(m.get(&5) == None);\n     }\n \n     #[test]\n     fn find_not_found() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(1i, 2i));\n-        assert!(m.insert(5i, 3i));\n-        assert!(m.insert(9i, 3i));\n-        assert_eq!(m.find(&2), None);\n+        assert!(m.insert(1i, 2i).is_none());\n+        assert!(m.insert(5i, 3i).is_none());\n+        assert!(m.insert(9i, 3i).is_none());\n+        assert_eq!(m.get(&2), None);\n     }\n \n     #[test]\n@@ -1308,41 +1310,42 @@ mod test_treemap {\n     #[test]\n     fn find_with_not_found() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(\"test1\", 2i));\n-        assert!(m.insert(\"test2\", 3i));\n-        assert!(m.insert(\"test3\", 3i));\n+        assert!(m.insert(\"test1\", 2i).is_none());\n+        assert!(m.insert(\"test2\", 3i).is_none());\n+        assert!(m.insert(\"test3\", 3i).is_none());\n         assert_eq!(m.find_with(|&k| \"test4\".cmp(k)), None);\n     }\n \n     #[test]\n     fn find_with_found() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(\"test1\", 2i));\n-        assert!(m.insert(\"test2\", 3i));\n-        assert!(m.insert(\"test3\", 4i));\n+        assert!(m.insert(\"test1\", 2i).is_none());\n+        assert!(m.insert(\"test2\", 3i).is_none());\n+        assert!(m.insert(\"test3\", 4i).is_none());\n         assert_eq!(m.find_with(|&k| \"test2\".cmp(k)), Some(&3i));\n     }\n \n     #[test]\n     fn test_find_mut() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(1i, 12i));\n-        assert!(m.insert(2, 8));\n-        assert!(m.insert(5, 14));\n+        assert!(m.insert(1i, 12i).is_none());\n+        assert!(m.insert(2, 8).is_none());\n+        assert!(m.insert(5, 14).is_none());\n         let new = 100;\n-        match m.find_mut(&5) {\n+        match m.get_mut(&5) {\n           None => panic!(), Some(x) => *x = new\n         }\n-        assert_eq!(m.find(&5), Some(&new));\n+        assert_eq!(m.get(&5), Some(&new));\n     }\n \n     #[test]\n     fn test_find_with_mut() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(\"t1\", 12i));\n-        assert!(m.insert(\"t2\", 8));\n-        assert!(m.insert(\"t5\", 14));\n+        assert!(m.insert(\"t1\", 12i).is_none());\n+        assert!(m.insert(\"t2\", 8).is_none());\n+        assert!(m.insert(\"t5\", 14).is_none());\n         let new = 100;\n+\n         match m.find_with_mut(|&k| \"t5\".cmp(k)) {\n           None => panic!(), Some(x) => *x = new\n         }\n@@ -1352,23 +1355,23 @@ mod test_treemap {\n     #[test]\n     fn insert_replace() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(5i, 2i));\n-        assert!(m.insert(2, 9));\n-        assert!(!m.insert(2, 11));\n-        assert_eq!(m.find(&2).unwrap(), &11);\n+        assert!(m.insert(5i, 2i).is_none());\n+        assert!(m.insert(2, 9).is_none());\n+        assert!(!m.insert(2, 11).is_none());\n+        assert_eq!(m.get(&2).unwrap(), &11);\n     }\n \n     #[test]\n     fn test_clear() {\n         let mut m = TreeMap::new();\n         m.clear();\n-        assert!(m.insert(5i, 11i));\n-        assert!(m.insert(12, -3));\n-        assert!(m.insert(19, 2));\n+        assert!(m.insert(5i, 11i).is_none());\n+        assert!(m.insert(12, -3).is_none());\n+        assert!(m.insert(19, 2).is_none());\n         m.clear();\n-        assert!(m.find(&5).is_none());\n-        assert!(m.find(&12).is_none());\n-        assert!(m.find(&19).is_none());\n+        assert!(m.get(&5).is_none());\n+        assert!(m.get(&12).is_none());\n+        assert!(m.get(&19).is_none());\n         assert!(m.is_empty());\n     }\n \n@@ -1384,16 +1387,16 @@ mod test_treemap {\n         m.insert(k1.clone(), v1.clone());\n         m.insert(k2.clone(), v2.clone());\n \n-        assert_eq!(m.find(&k2), Some(&v2));\n-        assert_eq!(m.find(&k1), Some(&v1));\n+        assert_eq!(m.get(&k2), Some(&v2));\n+        assert_eq!(m.get(&k1), Some(&v1));\n     }\n \n     fn check_equal<K: PartialEq + Ord, V: PartialEq>(ctrl: &[(K, V)],\n                                             map: &TreeMap<K, V>) {\n         assert_eq!(ctrl.is_empty(), map.is_empty());\n         for x in ctrl.iter() {\n             let &(ref k, ref v) = x;\n-            assert!(map.find(k).unwrap() == v)\n+            assert!(map.get(k).unwrap() == v)\n         }\n         for (map_k, map_v) in map.iter() {\n             let mut found = false;\n@@ -1455,7 +1458,7 @@ mod test_treemap {\n         let mut ctrl = vec![];\n \n         check_equal(ctrl.as_slice(), &map);\n-        assert!(map.find(&5).is_none());\n+        assert!(map.get(&5).is_none());\n \n         let seed: &[_] = &[42];\n         let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n@@ -1465,7 +1468,7 @@ mod test_treemap {\n                 let k = rng.gen();\n                 let v = rng.gen();\n                 if !ctrl.iter().any(|x| x == &(k, v)) {\n-                    assert!(map.insert(k, v));\n+                    assert!(map.insert(k, v).is_none());\n                     ctrl.push((k, v));\n                     check_structure(&map);\n                     check_equal(ctrl.as_slice(), &map);\n@@ -1475,7 +1478,7 @@ mod test_treemap {\n             for _ in range(0u, 30) {\n                 let r = rng.gen_range(0, ctrl.len());\n                 let (key, _) = ctrl.remove(r).unwrap();\n-                assert!(map.remove(&key));\n+                assert!(map.remove(&key).is_some());\n                 check_structure(&map);\n                 check_equal(ctrl.as_slice(), &map);\n             }\n@@ -1485,31 +1488,31 @@ mod test_treemap {\n     #[test]\n     fn test_len() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(3i, 6i));\n+        assert!(m.insert(3i, 6i).is_none());\n         assert_eq!(m.len(), 1);\n-        assert!(m.insert(0, 0));\n+        assert!(m.insert(0, 0).is_none());\n         assert_eq!(m.len(), 2);\n-        assert!(m.insert(4, 8));\n+        assert!(m.insert(4, 8).is_none());\n         assert_eq!(m.len(), 3);\n-        assert!(m.remove(&3));\n+        assert!(m.remove(&3).is_some());\n         assert_eq!(m.len(), 2);\n-        assert!(!m.remove(&5));\n+        assert!(!m.remove(&5).is_some());\n         assert_eq!(m.len(), 2);\n-        assert!(m.insert(2, 4));\n+        assert!(m.insert(2, 4).is_none());\n         assert_eq!(m.len(), 3);\n-        assert!(m.insert(1, 2));\n+        assert!(m.insert(1, 2).is_none());\n         assert_eq!(m.len(), 4);\n     }\n \n     #[test]\n     fn test_iterator() {\n         let mut m = TreeMap::new();\n \n-        assert!(m.insert(3i, 6i));\n-        assert!(m.insert(0, 0));\n-        assert!(m.insert(4, 8));\n-        assert!(m.insert(2, 4));\n-        assert!(m.insert(1, 2));\n+        assert!(m.insert(3i, 6i).is_none());\n+        assert!(m.insert(0, 0).is_none());\n+        assert!(m.insert(4, 8).is_none());\n+        assert!(m.insert(2, 4).is_none());\n+        assert!(m.insert(1, 2).is_none());\n \n         let mut n = 0;\n         for (k, v) in m.iter() {\n@@ -1524,7 +1527,7 @@ mod test_treemap {\n     fn test_interval_iteration() {\n         let mut m = TreeMap::new();\n         for i in range(1i, 100i) {\n-            assert!(m.insert(i * 2, i * 4));\n+            assert!(m.insert(i * 2, i * 4).is_none());\n         }\n \n         for i in range(1i, 198i) {\n@@ -1548,11 +1551,11 @@ mod test_treemap {\n     fn test_rev_iter() {\n         let mut m = TreeMap::new();\n \n-        assert!(m.insert(3i, 6i));\n-        assert!(m.insert(0, 0));\n-        assert!(m.insert(4, 8));\n-        assert!(m.insert(2, 4));\n-        assert!(m.insert(1, 2));\n+        assert!(m.insert(3i, 6i).is_none());\n+        assert!(m.insert(0, 0).is_none());\n+        assert!(m.insert(4, 8).is_none());\n+        assert!(m.insert(2, 4).is_none());\n+        assert!(m.insert(1, 2).is_none());\n \n         let mut n = 4;\n         for (k, v) in m.rev_iter() {\n@@ -1566,7 +1569,7 @@ mod test_treemap {\n     fn test_mut_iter() {\n         let mut m = TreeMap::new();\n         for i in range(0u, 10) {\n-            assert!(m.insert(i, 100 * i));\n+            assert!(m.insert(i, 100 * i).is_none());\n         }\n \n         for (i, (&k, v)) in m.iter_mut().enumerate() {\n@@ -1581,7 +1584,7 @@ mod test_treemap {\n     fn test_mut_rev_iter() {\n         let mut m = TreeMap::new();\n         for i in range(0u, 10) {\n-            assert!(m.insert(i, 100 * i));\n+            assert!(m.insert(i, 100 * i).is_none());\n         }\n \n         for (i, (&k, v)) in m.rev_iter_mut().enumerate() {\n@@ -1598,8 +1601,8 @@ mod test_treemap {\n         let mut m_lower = TreeMap::new();\n         let mut m_upper = TreeMap::new();\n         for i in range(1i, 100i) {\n-            assert!(m_lower.insert(i * 2, i * 4));\n-            assert!(m_upper.insert(i * 2, i * 4));\n+            assert!(m_lower.insert(i * 2, i * 4).is_none());\n+            assert!(m_upper.insert(i * 2, i * 4).is_none());\n         }\n \n         for i in range(1i, 199) {\n@@ -1653,15 +1656,15 @@ mod test_treemap {\n         let mut b = TreeMap::new();\n \n         assert!(a == b);\n-        assert!(a.insert(0i, 5i));\n+        assert!(a.insert(0i, 5i).is_none());\n         assert!(a != b);\n-        assert!(b.insert(0, 4));\n+        assert!(b.insert(0, 4).is_none());\n         assert!(a != b);\n-        assert!(a.insert(5, 19));\n+        assert!(a.insert(5, 19).is_none());\n         assert!(a != b);\n-        assert!(!b.insert(0, 5));\n+        assert!(!b.insert(0, 5).is_none());\n         assert!(a != b);\n-        assert!(b.insert(5, 19));\n+        assert!(b.insert(5, 19).is_none());\n         assert!(a == b);\n     }\n \n@@ -1671,15 +1674,15 @@ mod test_treemap {\n         let mut b = TreeMap::new();\n \n         assert!(!(a < b) && !(b < a));\n-        assert!(b.insert(0i, 5i));\n+        assert!(b.insert(0i, 5i).is_none());\n         assert!(a < b);\n-        assert!(a.insert(0, 7));\n+        assert!(a.insert(0, 7).is_none());\n         assert!(!(a < b) && b < a);\n-        assert!(b.insert(-2, 0));\n+        assert!(b.insert(-2, 0).is_none());\n         assert!(b < a);\n-        assert!(a.insert(-5, 2));\n+        assert!(a.insert(-5, 2).is_none());\n         assert!(a < b);\n-        assert!(a.insert(6, 2));\n+        assert!(a.insert(6, 2).is_none());\n         assert!(a < b && !(b < a));\n     }\n \n@@ -1689,10 +1692,10 @@ mod test_treemap {\n         let mut b = TreeMap::new();\n \n         assert!(a <= b && a >= b);\n-        assert!(a.insert(1i, 1i));\n+        assert!(a.insert(1i, 1i).is_none());\n         assert!(a > b && a >= b);\n         assert!(b < a && b <= a);\n-        assert!(b.insert(2, 2));\n+        assert!(b.insert(2, 2).is_none());\n         assert!(b > a && b >= a);\n         assert!(a < b && a <= b);\n     }\n@@ -1720,11 +1723,11 @@ mod test_treemap {\n         let (x4, y4) = (29, 5);\n         let (x5, y5) = (103, 3);\n \n-        assert!(m.insert(x1, y1));\n-        assert!(m.insert(x2, y2));\n-        assert!(m.insert(x3, y3));\n-        assert!(m.insert(x4, y4));\n-        assert!(m.insert(x5, y5));\n+        assert!(m.insert(x1, y1).is_none());\n+        assert!(m.insert(x2, y2).is_none());\n+        assert!(m.insert(x3, y3).is_none());\n+        assert!(m.insert(x4, y4).is_none());\n+        assert!(m.insert(x5, y5).is_none());\n \n         let m = m;\n         let mut a = m.iter();\n@@ -1765,7 +1768,7 @@ mod test_treemap {\n         let map: TreeMap<int, int> = xs.iter().map(|&x| x).collect();\n \n         for &(k, v) in xs.iter() {\n-            assert_eq!(map.find(&k), Some(&v));\n+            assert_eq!(map.get(&k), Some(&v));\n         }\n     }\n \n@@ -1795,17 +1798,17 @@ mod test_treemap {\n     #[test]\n     fn test_swap() {\n         let mut m = TreeMap::new();\n-        assert_eq!(m.swap(1u, 2i), None);\n-        assert_eq!(m.swap(1u, 3i), Some(2));\n-        assert_eq!(m.swap(1u, 4i), Some(3));\n+        assert_eq!(m.insert(1u, 2i), None);\n+        assert_eq!(m.insert(1u, 3i), Some(2));\n+        assert_eq!(m.insert(1u, 4i), Some(3));\n     }\n \n     #[test]\n     fn test_pop() {\n         let mut m = TreeMap::new();\n         m.insert(1u, 2i);\n-        assert_eq!(m.pop(&1), Some(2));\n-        assert_eq!(m.pop(&1), None);\n+        assert_eq!(m.remove(&1), Some(2));\n+        assert_eq!(m.remove(&1), None);\n     }\n }\n \n@@ -1857,15 +1860,15 @@ mod bench {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n         find_rand_n(100, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.find(&i); });\n+                    |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_rand_10_000(b: &mut Bencher) {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n         find_rand_n(10_000, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.find(&i); });\n+                    |m, i| { m.get(&i); });\n     }\n \n     // Find seq\n@@ -1874,23 +1877,23 @@ mod bench {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n         find_seq_n(100, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.find(&i); });\n+                   |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_seq_10_000(b: &mut Bencher) {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n         find_seq_n(10_000, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.find(&i); });\n+                   |m, i| { m.get(&i); });\n     }\n \n     fn bench_iter(b: &mut Bencher, size: uint) {\n         let mut map = TreeMap::<uint, uint>::new();\n         let mut rng = weak_rng();\n \n         for _ in range(0, size) {\n-            map.swap(rng.gen(), rng.gen());\n+            map.insert(rng.gen(), rng.gen());\n         }\n \n         b.iter(|| {"}, {"sha": "22307a5d376b928e8bf040e7b4c89d6e58761677", "filename": "src/libcollections/tree/set.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Ftree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Ftree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fset.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -19,6 +19,10 @@ use std::hash::{Writer, Hash};\n \n use tree_map::{TreeMap, Entries, RevEntries, MoveEntries};\n \n+// FIXME(conventions): implement bounded iterators\n+// FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n+// FIXME(conventions): replace rev_iter(_mut) by making iter(_mut) DoubleEnded\n+\n /// An implementation of the `Set` trait on top of the `TreeMap` container. The\n /// only requirement is that the type of the elements contained ascribes to the\n /// `Ord` trait.\n@@ -145,6 +149,7 @@ impl<T: Ord> TreeSet<T> {\n     /// let mut set: TreeSet<int> = TreeSet::new();\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n     /// Gets a lazy iterator over the values in the set, in ascending order.\n@@ -161,6 +166,7 @@ impl<T: Ord> TreeSet<T> {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n         SetItems{iter: self.map.iter()}\n     }\n@@ -197,6 +203,7 @@ impl<T: Ord> TreeSet<T> {\n     /// assert_eq!(v, vec![1, 2, 3, 4, 5]);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveSetItems<T> {\n         self.map.into_iter().map(|(value, _)| value)\n     }\n@@ -261,6 +268,7 @@ impl<T: Ord> TreeSet<T> {\n     /// let diff: TreeSet<int> = b.difference(&a).map(|&x| x).collect();\n     /// assert_eq!(diff, [4, 5].iter().map(|&x| x).collect());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> DifferenceItems<'a, T> {\n         DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n@@ -286,6 +294,7 @@ impl<T: Ord> TreeSet<T> {\n     /// assert_eq!(diff1, diff2);\n     /// assert_eq!(diff1, [1, 2, 4, 5].iter().map(|&x| x).collect());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)\n         -> SymDifferenceItems<'a, T> {\n         SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n@@ -309,6 +318,7 @@ impl<T: Ord> TreeSet<T> {\n     /// let diff: TreeSet<int> = a.intersection(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)\n         -> IntersectionItems<'a, T> {\n         IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n@@ -332,6 +342,7 @@ impl<T: Ord> TreeSet<T> {\n     /// let diff: TreeSet<int> = a.union(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [1, 2, 3, 4, 5].iter().map(|&x| x).collect());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> UnionItems<'a, T> {\n         UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n@@ -349,6 +360,7 @@ impl<T: Ord> TreeSet<T> {\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -363,6 +375,7 @@ impl<T: Ord> TreeSet<T> {\n     /// v.insert(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the set, removing all values.\n@@ -378,6 +391,7 @@ impl<T: Ord> TreeSet<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) { self.map.clear() }\n \n     /// Returns `true` if the set contains a value.\n@@ -392,6 +406,7 @@ impl<T: Ord> TreeSet<T> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains(&self, value: &T) -> bool {\n         self.map.contains_key(value)\n     }\n@@ -413,6 +428,7 @@ impl<T: Ord> TreeSet<T> {\n     /// b.insert(1);\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n         self.intersection(other).next().is_none()\n     }\n@@ -433,6 +449,7 @@ impl<T: Ord> TreeSet<T> {\n     /// set.insert(4);\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_subset(&self, other: &TreeSet<T>) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -476,6 +493,7 @@ impl<T: Ord> TreeSet<T> {\n     /// set.insert(2);\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_superset(&self, other: &TreeSet<T>) -> bool {\n         other.is_subset(self)\n     }\n@@ -495,7 +513,8 @@ impl<T: Ord> TreeSet<T> {\n     /// assert_eq!(set.len(), 1);\n     /// ```\n     #[inline]\n-    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }\n \n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n@@ -512,7 +531,8 @@ impl<T: Ord> TreeSet<T> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[inline]\n-    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value).is_some() }\n }\n \n /// A lazy forward iterator over a set."}, {"sha": "d604e176a672de74a1857ab5cddc28c21d0085ab", "filename": "src/libcollections/trie/map.rs", "status": "modified", "additions": 106, "deletions": 102, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Ftrie%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Ftrie%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmap.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -32,6 +32,10 @@ use std::hash::{Writer, Hash};\n use slice::{Items, MutItems};\n use slice;\n \n+// FIXME(conventions): implement bounded iterators\n+// FIXME(conventions): implement into_iter\n+// FIXME(conventions): replace each_reverse by making iter DoubleEnded\n+\n // FIXME: #5244: need to manually update the TrieNode constructor\n const SHIFT: uint = 4;\n const SIZE: uint = 1 << SHIFT;\n@@ -59,14 +63,14 @@ enum Child<T> {\n /// map.insert(1, \"Martin\");\n ///\n /// assert_eq!(map.len(), 3);\n-/// assert_eq!(map.find(&1), Some(&\"Martin\"));\n+/// assert_eq!(map.get(&1), Some(&\"Martin\"));\n ///\n /// if !map.contains_key(&90) {\n ///     println!(\"Nobody is keyed 90\");\n /// }\n ///\n /// // Update a key\n-/// match map.find_mut(&1) {\n+/// match map.get_mut(&1) {\n ///     Some(value) => *value = \"Olga\",\n ///     None => (),\n /// }\n@@ -140,6 +144,7 @@ impl<T> TrieMap<T> {\n     /// let mut map: TrieMap<&str> = TrieMap::new();\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> TrieMap<T> {\n         TrieMap{root: TrieNode::new(), length: 0}\n     }\n@@ -169,12 +174,14 @@ impl<T> TrieMap<T> {\n \n     /// Gets an iterator visiting all keys in ascending order by the keys.\n     /// The iterator's element type is `uint`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'r>(&'r self) -> Keys<'r, T> {\n         self.iter().map(|(k, _v)| k)\n     }\n \n     /// Gets an iterator visiting all values in ascending order by the keys.\n     /// The iterator's element type is `&'r T`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'r>(&'r self) -> Values<'r, T> {\n         self.iter().map(|(_k, v)| v)\n     }\n@@ -191,6 +198,7 @@ impl<T> TrieMap<T> {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Entries<'a, T> {\n         let mut iter = unsafe {Entries::new()};\n         iter.stack[0] = self.root.children.iter();\n@@ -214,10 +222,11 @@ impl<T> TrieMap<T> {\n     ///     *value = -(key as int);\n     /// }\n     ///\n-    /// assert_eq!(map.find(&1), Some(&-1));\n-    /// assert_eq!(map.find(&2), Some(&-2));\n-    /// assert_eq!(map.find(&3), Some(&-3));\n+    /// assert_eq!(map.get(&1), Some(&-1));\n+    /// assert_eq!(map.get(&2), Some(&-2));\n+    /// assert_eq!(map.get(&3), Some(&-3));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter_mut<'a>(&'a mut self) -> MutEntries<'a, T> {\n         let mut iter = unsafe {MutEntries::new()};\n         iter.stack[0] = self.root.children.iter_mut();\n@@ -241,6 +250,7 @@ impl<T> TrieMap<T> {\n     /// assert_eq!(a.len(), 1);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements.\n@@ -256,6 +266,7 @@ impl<T> TrieMap<T> {\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the map, removing all values.\n@@ -271,11 +282,18 @@ impl<T> TrieMap<T> {\n     /// assert!(a.is_empty());\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         self.root = TrieNode::new();\n         self.length = 0;\n     }\n \n+    /// Deprecated: renamed to `get`.\n+    #[deprecated = \"renamed to `get`\"]\n+    pub fn find(&self, key: &uint) -> Option<&T> {\n+        self.get(key)\n+    }\n+\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// # Example\n@@ -285,12 +303,13 @@ impl<T> TrieMap<T> {\n     ///\n     /// let mut map = TrieMap::new();\n     /// map.insert(1, \"a\");\n-    /// assert_eq!(map.find(&1), Some(&\"a\"));\n-    /// assert_eq!(map.find(&2), None);\n+    /// assert_eq!(map.get(&1), Some(&\"a\"));\n+    /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[inline]\n-    pub fn find<'a>(&'a self, key: &uint) -> Option<&'a T> {\n-        let mut node: &'a TrieNode<T> = &self.root;\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get(&self, key: &uint) -> Option<&T> {\n+        let mut node = &self.root;\n         let mut idx = 0;\n         loop {\n             match node.children[chunk(*key, idx)] {\n@@ -321,8 +340,15 @@ impl<T> TrieMap<T> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains_key(&self, key: &uint) -> bool {\n-        self.find(key).is_some()\n+        self.get(key).is_some()\n+    }\n+\n+    /// Deprecated: renamed to `get_mut`.\n+    #[deprecated = \"renamed to `get_mut`\"]\n+    pub fn find_mut(&mut self, key: &uint) -> Option<&mut T> {\n+        self.get_mut(key)\n     }\n \n     /// Returns a mutable reference to the value corresponding to the key.\n@@ -334,52 +360,22 @@ impl<T> TrieMap<T> {\n     ///\n     /// let mut map = TrieMap::new();\n     /// map.insert(1, \"a\");\n-    /// match map.find_mut(&1) {\n+    /// match map.get_mut(&1) {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     #[inline]\n-    pub fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {\n         find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n     }\n \n-    /// Inserts a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Returns `true` if the key did\n-    /// not already exist in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    ///\n-    /// let mut map = TrieMap::new();\n-    /// assert_eq!(map.insert(2, \"value\"), true);\n-    /// assert_eq!(map.insert(2, \"value2\"), false);\n-    /// assert_eq!(map[2], \"value2\");\n-    /// ```\n-    #[inline]\n-    pub fn insert(&mut self, key: uint, value: T) -> bool {\n-        self.swap(key, value).is_none()\n-    }\n-\n-    /// Removes a key-value pair from the map. Returns `true` if the key\n-    /// was present in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    ///\n-    /// let mut map = TrieMap::new();\n-    /// assert_eq!(map.remove(&1), false);\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.remove(&1), true);\n-    /// ```\n-    #[inline]\n-    pub fn remove(&mut self, key: &uint) -> bool {\n-        self.pop(key).is_some()\n+    /// Deprecated: Renamed to `insert`.\n+    #[deprecated = \"Renamed to `insert`\"]\n+    pub fn swap(&mut self, key: uint, value: T) -> Option<T> {\n+        self.insert(key, value)\n     }\n \n     /// Inserts a key-value pair from the map. If the key already had a value\n@@ -391,21 +387,28 @@ impl<T> TrieMap<T> {\n     /// use std::collections::TrieMap;\n     ///\n     /// let mut map = TrieMap::new();\n-    /// assert_eq!(map.swap(37, \"a\"), None);\n+    /// assert_eq!(map.insert(37, \"a\"), None);\n     /// assert_eq!(map.is_empty(), false);\n     ///\n     /// map.insert(37, \"b\");\n-    /// assert_eq!(map.swap(37, \"c\"), Some(\"b\"));\n+    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    pub fn swap(&mut self, key: uint, value: T) -> Option<T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, key: uint, value: T) -> Option<T> {\n         let ret = insert(&mut self.root.count,\n                          &mut self.root.children[chunk(key, 0)],\n                          key, value, 1);\n         if ret.is_none() { self.length += 1 }\n         ret\n     }\n \n+    /// Deprecated: Renamed to `remove`.\n+    #[deprecated = \"Renamed to `remove`\"]\n+    pub fn pop(&mut self, key: &uint) -> Option<T> {\n+        self.remove(key)\n+    }\n+\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n@@ -416,10 +419,11 @@ impl<T> TrieMap<T> {\n     ///\n     /// let mut map = TrieMap::new();\n     /// map.insert(1, \"a\");\n-    /// assert_eq!(map.pop(&1), Some(\"a\"));\n-    /// assert_eq!(map.pop(&1), None);\n+    /// assert_eq!(map.remove(&1), Some(\"a\"));\n+    /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    pub fn pop(&mut self, key: &uint) -> Option<T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, key: &uint) -> Option<T> {\n         let ret = remove(&mut self.root.count,\n                          &mut self.root.children[chunk(*key, 0)],\n                          *key, 1);\n@@ -582,9 +586,9 @@ impl<T> TrieMap<T> {\n     ///     *value = \"changed\";\n     /// }\n     ///\n-    /// assert_eq!(map.find(&2), Some(&\"a\"));\n-    /// assert_eq!(map.find(&4), Some(&\"changed\"));\n-    /// assert_eq!(map.find(&6), Some(&\"changed\"));\n+    /// assert_eq!(map.get(&2), Some(&\"a\"));\n+    /// assert_eq!(map.get(&4), Some(&\"changed\"));\n+    /// assert_eq!(map.get(&6), Some(&\"changed\"));\n     /// ```\n     pub fn lower_bound_mut<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> {\n         self.bound_mut(key, false)\n@@ -607,9 +611,9 @@ impl<T> TrieMap<T> {\n     ///     *value = \"changed\";\n     /// }\n     ///\n-    /// assert_eq!(map.find(&2), Some(&\"a\"));\n-    /// assert_eq!(map.find(&4), Some(&\"b\"));\n-    /// assert_eq!(map.find(&6), Some(&\"changed\"));\n+    /// assert_eq!(map.get(&2), Some(&\"a\"));\n+    /// assert_eq!(map.get(&4), Some(&\"b\"));\n+    /// assert_eq!(map.get(&6), Some(&\"changed\"));\n     /// ```\n     pub fn upper_bound_mut<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> {\n         self.bound_mut(key, true)\n@@ -643,14 +647,14 @@ impl<S: Writer, T: Hash<S>> Hash<S> for TrieMap<T> {\n impl<T> Index<uint, T> for TrieMap<T> {\n     #[inline]\n     fn index<'a>(&'a self, i: &uint) -> &'a T {\n-        self.find(i).expect(\"key not present\")\n+        self.get(i).expect(\"key not present\")\n     }\n }\n \n impl<T> IndexMut<uint, T> for TrieMap<T> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut T {\n-        self.find_mut(i).expect(\"key not present\")\n+        self.get_mut(i).expect(\"key not present\")\n     }\n }\n \n@@ -957,24 +961,24 @@ mod test {\n     #[test]\n     fn test_find_mut() {\n         let mut m = TrieMap::new();\n-        assert!(m.insert(1u, 12i));\n-        assert!(m.insert(2u, 8i));\n-        assert!(m.insert(5u, 14i));\n+        assert!(m.insert(1u, 12i).is_none());\n+        assert!(m.insert(2u, 8i).is_none());\n+        assert!(m.insert(5u, 14i).is_none());\n         let new = 100;\n-        match m.find_mut(&5) {\n+        match m.get_mut(&5) {\n             None => panic!(), Some(x) => *x = new\n         }\n-        assert_eq!(m.find(&5), Some(&new));\n+        assert_eq!(m.get(&5), Some(&new));\n     }\n \n     #[test]\n     fn test_find_mut_missing() {\n         let mut m = TrieMap::new();\n-        assert!(m.find_mut(&0).is_none());\n-        assert!(m.insert(1u, 12i));\n-        assert!(m.find_mut(&0).is_none());\n-        assert!(m.insert(2, 8));\n-        assert!(m.find_mut(&0).is_none());\n+        assert!(m.get_mut(&0).is_none());\n+        assert!(m.insert(1u, 12i).is_none());\n+        assert!(m.get_mut(&0).is_none());\n+        assert!(m.insert(2, 8).is_none());\n+        assert!(m.get_mut(&0).is_none());\n     }\n \n     #[test]\n@@ -983,32 +987,32 @@ mod test {\n         let n = 300u;\n \n         for x in range_step(1u, n, 2) {\n-            assert!(trie.insert(x, x + 1));\n+            assert!(trie.insert(x, x + 1).is_none());\n             assert!(trie.contains_key(&x));\n             check_integrity(&trie.root);\n         }\n \n         for x in range_step(0u, n, 2) {\n             assert!(!trie.contains_key(&x));\n-            assert!(trie.insert(x, x + 1));\n+            assert!(trie.insert(x, x + 1).is_none());\n             check_integrity(&trie.root);\n         }\n \n         for x in range(0u, n) {\n             assert!(trie.contains_key(&x));\n-            assert!(!trie.insert(x, x + 1));\n+            assert!(!trie.insert(x, x + 1).is_none());\n             check_integrity(&trie.root);\n         }\n \n         for x in range_step(1u, n, 2) {\n-            assert!(trie.remove(&x));\n+            assert!(trie.remove(&x).is_some());\n             assert!(!trie.contains_key(&x));\n             check_integrity(&trie.root);\n         }\n \n         for x in range_step(0u, n, 2) {\n             assert!(trie.contains_key(&x));\n-            assert!(!trie.insert(x, x + 1));\n+            assert!(!trie.insert(x, x + 1).is_none());\n             check_integrity(&trie.root);\n         }\n     }\n@@ -1017,11 +1021,11 @@ mod test {\n     fn test_each_reverse() {\n         let mut m = TrieMap::new();\n \n-        assert!(m.insert(3, 6));\n-        assert!(m.insert(0, 0));\n-        assert!(m.insert(4, 8));\n-        assert!(m.insert(2, 4));\n-        assert!(m.insert(1, 2));\n+        assert!(m.insert(3, 6).is_none());\n+        assert!(m.insert(0, 0).is_none());\n+        assert!(m.insert(4, 8).is_none());\n+        assert!(m.insert(2, 4).is_none());\n+        assert!(m.insert(1, 2).is_none());\n \n         let mut n = 4;\n         m.each_reverse(|k, v| {\n@@ -1054,19 +1058,19 @@ mod test {\n     }\n \n     #[test]\n-    fn test_swap() {\n+    fn test_insert() {\n         let mut m = TrieMap::new();\n-        assert_eq!(m.swap(1u, 2i), None);\n-        assert_eq!(m.swap(1u, 3i), Some(2));\n-        assert_eq!(m.swap(1u, 4i), Some(3));\n+        assert_eq!(m.insert(1u, 2i), None);\n+        assert_eq!(m.insert(1u, 3i), Some(2));\n+        assert_eq!(m.insert(1u, 4i), Some(3));\n     }\n \n     #[test]\n-    fn test_pop() {\n+    fn test_remove() {\n         let mut m = TrieMap::new();\n         m.insert(1u, 2i);\n-        assert_eq!(m.pop(&1), Some(2));\n-        assert_eq!(m.pop(&1), None);\n+        assert_eq!(m.remove(&1), Some(2));\n+        assert_eq!(m.remove(&1), None);\n     }\n \n     #[test]\n@@ -1076,7 +1080,7 @@ mod test {\n         let map: TrieMap<int> = xs.iter().map(|&x| x).collect();\n \n         for &(k, v) in xs.iter() {\n-            assert_eq!(map.find(&k), Some(&v));\n+            assert_eq!(map.get(&k), Some(&v));\n         }\n     }\n \n@@ -1243,15 +1247,15 @@ mod test {\n         let mut b = TrieMap::new();\n \n         assert!(a == b);\n-        assert!(a.insert(0, 5i));\n+        assert!(a.insert(0, 5i).is_none());\n         assert!(a != b);\n-        assert!(b.insert(0, 4i));\n+        assert!(b.insert(0, 4i).is_none());\n         assert!(a != b);\n-        assert!(a.insert(5, 19));\n+        assert!(a.insert(5, 19).is_none());\n         assert!(a != b);\n-        assert!(!b.insert(0, 5));\n+        assert!(!b.insert(0, 5).is_none());\n         assert!(a != b);\n-        assert!(b.insert(5, 19));\n+        assert!(b.insert(5, 19).is_none());\n         assert!(a == b);\n     }\n \n@@ -1261,15 +1265,15 @@ mod test {\n         let mut b = TrieMap::new();\n \n         assert!(!(a < b) && !(b < a));\n-        assert!(b.insert(2u, 5i));\n+        assert!(b.insert(2u, 5i).is_none());\n         assert!(a < b);\n-        assert!(a.insert(2, 7));\n+        assert!(a.insert(2, 7).is_none());\n         assert!(!(a < b) && b < a);\n-        assert!(b.insert(1, 0));\n+        assert!(b.insert(1, 0).is_none());\n         assert!(b < a);\n-        assert!(a.insert(0, 6));\n+        assert!(a.insert(0, 6).is_none());\n         assert!(a < b);\n-        assert!(a.insert(6, 2));\n+        assert!(a.insert(6, 2).is_none());\n         assert!(a < b && !(b < a));\n     }\n \n@@ -1279,10 +1283,10 @@ mod test {\n         let mut b = TrieMap::new();\n \n         assert!(a <= b && a >= b);\n-        assert!(a.insert(1u, 1i));\n+        assert!(a.insert(1u, 1i).is_none());\n         assert!(a > b && a >= b);\n         assert!(b < a && b <= a);\n-        assert!(b.insert(2, 2));\n+        assert!(b.insert(2, 2).is_none());\n         assert!(b > a && b >= a);\n         assert!(a < b && a <= b);\n     }\n@@ -1355,7 +1359,7 @@ mod bench {\n         let mut rng = weak_rng();\n \n         for _ in range(0, size) {\n-            map.swap(rng.gen(), rng.gen());\n+            map.insert(rng.gen(), rng.gen());\n         }\n \n         b.iter(|| {"}, {"sha": "dd5a81fe96ee9f8fd9b0fa8b5a242f925c5a16e5", "filename": "src/libcollections/trie/set.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Ftrie%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Ftrie%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fset.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -8,6 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// FIXME(conventions): implement bounded iterators\n+// FIXME(conventions): implement union family of fns\n+// FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n+// FIXME(conventions): replace each_reverse by making iter DoubleEnded\n+// FIXME(conventions): implement iter_mut and into_iter\n+\n use core::prelude::*;\n \n use core::default::Default;\n@@ -79,6 +85,7 @@ impl TrieSet {\n     /// let mut set = TrieSet::new();\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> TrieSet {\n         TrieSet{map: TrieMap::new()}\n     }\n@@ -126,6 +133,7 @@ impl TrieSet {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> SetItems<'a> {\n         SetItems{iter: self.map.iter()}\n     }\n@@ -177,6 +185,7 @@ impl TrieSet {\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -191,6 +200,7 @@ impl TrieSet {\n     /// v.insert(1);\n     /// assert!(!v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the set, removing all values.\n@@ -206,6 +216,7 @@ impl TrieSet {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) { self.map.clear() }\n \n     /// Returns `true` if the set contains a value.\n@@ -220,6 +231,7 @@ impl TrieSet {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains(&self, value: &uint) -> bool {\n         self.map.contains_key(value)\n     }\n@@ -242,6 +254,7 @@ impl TrieSet {\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_disjoint(&self, other: &TrieSet) -> bool {\n         self.iter().all(|v| !other.contains(&v))\n     }\n@@ -263,6 +276,7 @@ impl TrieSet {\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_subset(&self, other: &TrieSet) -> bool {\n         self.iter().all(|v| other.contains(&v))\n     }\n@@ -287,6 +301,7 @@ impl TrieSet {\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_superset(&self, other: &TrieSet) -> bool {\n         other.is_subset(self)\n     }\n@@ -306,8 +321,9 @@ impl TrieSet {\n     /// assert_eq!(set.len(), 1);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn insert(&mut self, value: uint) -> bool {\n-        self.map.insert(value, ())\n+        self.map.insert(value, ()).is_none()\n     }\n \n     /// Removes a value from the set. Returns `true` if the value was\n@@ -325,8 +341,9 @@ impl TrieSet {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn remove(&mut self, value: &uint) -> bool {\n-        self.map.remove(value)\n+        self.map.remove(value).is_some()\n     }\n }\n "}, {"sha": "707084d9c70b42445bb2b2982e73d42cd956f9f0", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 74, "deletions": 77, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -312,7 +312,7 @@ impl<T: Clone> Vec<T> {\n     #[inline]\n     #[experimental]\n     pub fn push_all(&mut self, other: &[T]) {\n-        self.reserve_additional(other.len());\n+        self.reserve(other.len());\n \n         for i in range(0, other.len()) {\n             let len = self.len();\n@@ -342,7 +342,7 @@ impl<T: Clone> Vec<T> {\n     /// ```\n     #[stable]\n     pub fn grow(&mut self, n: uint, value: T) {\n-        self.reserve_additional(n);\n+        self.reserve(n);\n         let mut i: uint = 0u;\n \n         while i < n {\n@@ -489,7 +489,7 @@ impl<T> Extendable<T> for Vec<T> {\n     #[inline]\n     fn extend<I: Iterator<T>>(&mut self, mut iterator: I) {\n         let (lower, _) = iterator.size_hint();\n-        self.reserve_additional(lower);\n+        self.reserve(lower);\n         for element in iterator {\n             self.push(element)\n         }\n@@ -578,74 +578,70 @@ impl<T> Vec<T> {\n         self.cap\n     }\n \n-     /// Reserves capacity for at least `n` additional elements in the given\n-     /// vector.\n-     ///\n-     /// # Failure\n-     ///\n-     /// Fails if the new capacity overflows `uint`.\n-     ///\n-     /// # Example\n-     ///\n-     /// ```\n-     /// let mut vec: Vec<int> = vec![1i];\n-     /// vec.reserve_additional(10);\n-     /// assert!(vec.capacity() >= 11);\n-     /// ```\n+    /// Deprecated: Renamed to `reserve`.\n+    #[deprecated = \"Renamed to `reserve`\"]\n     pub fn reserve_additional(&mut self, extra: uint) {\n-        if self.cap - self.len < extra {\n-            match self.len.checked_add(&extra) {\n-                None => panic!(\"Vec::reserve_additional: `uint` overflow\"),\n-                Some(new_cap) => self.reserve(new_cap)\n-            }\n-        }\n+        self.reserve(extra)\n     }\n \n-    /// Reserves capacity for at least `n` elements in the given vector.\n+    /// Reserves capacity for at least `additional` more elements to be inserted in the given\n+    /// `Vec`. The collection may reserve more space to avoid frequent reallocations.\n     ///\n-    /// This function will over-allocate in order to amortize the allocation\n-    /// costs in scenarios where the caller may need to repeatedly reserve\n-    /// additional space.\n+    /// # Panics\n     ///\n-    /// If the capacity for `self` is already equal to or greater than the\n-    /// requested capacity, then no action is taken.\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// let mut vec = vec![1i, 2, 3];\n+    /// let mut vec: Vec<int> = vec![1];\n     /// vec.reserve(10);\n-    /// assert!(vec.capacity() >= 10);\n+    /// assert!(vec.capacity() >= 11);\n     /// ```\n-    pub fn reserve(&mut self, capacity: uint) {\n-        if capacity > self.cap {\n-            self.reserve_exact(num::next_power_of_two(capacity))\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve(&mut self, additional: uint) {\n+        if self.cap - self.len < additional {\n+            match self.len.checked_add(&additional) {\n+                None => panic!(\"Vec::reserve: `uint` overflow\"),\n+                // if the checked_add\n+                Some(new_cap) => {\n+                    let amort_cap = num::next_power_of_two(new_cap);\n+                    // next_power_of_two will overflow to exactly 0 for really big capacities\n+                    if amort_cap == 0 {\n+                        self.grow_capacity(new_cap);\n+                    } else {\n+                        self.grow_capacity(amort_cap);\n+                    }\n+                }\n+            }\n         }\n     }\n \n-    /// Reserves capacity for exactly `capacity` elements in the given vector.\n+    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n+    /// given `Vec`. Does nothing if the capacity is already sufficient.\n     ///\n-    /// If the capacity for `self` is already equal to or greater than the\n-    /// requested capacity, then no action is taken.\n+    /// Note that the allocator may give the collection more space than it requests. Therefore\n+    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n+    /// insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// let mut vec: Vec<int> = Vec::with_capacity(10);\n-    /// vec.reserve_exact(11);\n-    /// assert_eq!(vec.capacity(), 11);\n+    /// let mut vec: Vec<int> = vec![1];\n+    /// vec.reserve_exact(10);\n+    /// assert!(vec.capacity() >= 11);\n     /// ```\n-    pub fn reserve_exact(&mut self, capacity: uint) {\n-        if mem::size_of::<T>() == 0 { return }\n-\n-        if capacity > self.cap {\n-            let size = capacity.checked_mul(&mem::size_of::<T>())\n-                               .expect(\"capacity overflow\");\n-            unsafe {\n-                self.ptr = alloc_or_realloc(self.ptr, self.cap * mem::size_of::<T>(), size);\n-                if self.ptr.is_null() { ::alloc::oom() }\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve_exact(&mut self, additional: uint) {\n+        if self.cap - self.len < additional {\n+            match self.len.checked_add(&additional) {\n+                None => panic!(\"Vec::reserve: `uint` overflow\"),\n+                Some(new_cap) => self.grow_capacity(new_cap)\n             }\n-            self.cap = capacity;\n         }\n     }\n \n@@ -663,6 +659,7 @@ impl<T> Vec<T> {\n     /// assert!(vec.capacity() >= 3);\n     /// ```\n     #[stable]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn shrink_to_fit(&mut self) {\n         if mem::size_of::<T>() == 0 { return }\n \n@@ -713,7 +710,7 @@ impl<T> Vec<T> {\n     /// vec.truncate(2);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[unstable = \"waiting on panic semantics\"]\n+    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n     pub fn truncate(&mut self, len: uint) {\n         unsafe {\n             // drop any extra elements\n@@ -761,6 +758,7 @@ impl<T> Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveItems<T> {\n         unsafe {\n             let ptr = self.ptr;\n@@ -796,26 +794,6 @@ impl<T> Vec<T> {\n         self.len = len;\n     }\n \n-    /// Returns a mutable reference to the value at index `index`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if `index` is out of bounds\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut vec = vec![1i, 2, 3];\n-    /// *vec.get_mut(1) = 4;\n-    /// assert_eq!(vec, vec![1i, 4, 3]);\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"use `foo[index] = bar` instead\"]\n-    pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n-        &mut self.as_mut_slice()[index]\n-    }\n-\n     /// Removes an element from anywhere in the vector and return it, replacing\n     /// it with the last element. This does not preserve ordering, but is O(1).\n     ///\n@@ -868,7 +846,7 @@ impl<T> Vec<T> {\n         let len = self.len();\n         assert!(index <= len);\n         // space for the new element\n-        self.reserve(len + 1);\n+        self.reserve(1);\n \n         unsafe { // infallible\n             // The spot to put the new value\n@@ -970,7 +948,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[unstable = \"this function may be renamed or change to unboxed closures\"]\n     pub fn grow_fn(&mut self, n: uint, f: |uint| -> T) {\n-        self.reserve_additional(n);\n+        self.reserve(n);\n         for i in range(0u, n) {\n             self.push(f(i));\n         }\n@@ -1076,7 +1054,26 @@ impl<T> Vec<T> {\n     /// v.push(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Reserves capacity for exactly `capacity` elements in the given vector.\n+    ///\n+    /// If the capacity for `self` is already equal to or greater than the\n+    /// requested capacity, then no action is taken.\n+    fn grow_capacity(&mut self, capacity: uint) {\n+        if mem::size_of::<T>() == 0 { return }\n+\n+        if capacity > self.cap {\n+            let size = capacity.checked_mul(&mem::size_of::<T>())\n+                               .expect(\"capacity overflow\");\n+            unsafe {\n+                self.ptr = alloc_or_realloc(self.ptr, self.cap * mem::size_of::<T>(), size);\n+                if self.ptr.is_null() { ::alloc::oom() }\n+            }\n+            self.cap = capacity;\n+        }\n+    }\n }\n \n impl<T: PartialEq> Vec<T> {\n@@ -1742,24 +1739,24 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_reserve_additional() {\n+    fn test_reserve() {\n         let mut v = Vec::new();\n         assert_eq!(v.capacity(), 0);\n \n-        v.reserve_additional(2);\n+        v.reserve(2);\n         assert!(v.capacity() >= 2);\n \n         for i in range(0i, 16) {\n             v.push(i);\n         }\n \n         assert!(v.capacity() >= 16);\n-        v.reserve_additional(16);\n+        v.reserve(16);\n         assert!(v.capacity() >= 32);\n \n         v.push(16);\n \n-        v.reserve_additional(16);\n+        v.reserve(16);\n         assert!(v.capacity() >= 33)\n     }\n "}, {"sha": "38a345272b042db8fddebe73668905b2f4b7dbd9", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 131, "deletions": 135, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -26,6 +26,8 @@ use vec::Vec;\n use hash;\n use hash::Hash;\n \n+// FIXME(conventions): capacity management???\n+\n /// A map optimized for small integer keys.\n ///\n /// # Example\n@@ -42,14 +44,14 @@ use hash::Hash;\n ///     println!(\"The end is near!\");\n /// }\n ///\n-/// assert_eq!(months.find(&1), Some(&\"Jan\"));\n+/// assert_eq!(months.get(&1), Some(&\"Jan\"));\n ///\n-/// match months.find_mut(&3) {\n+/// match months.get_mut(&3) {\n ///     Some(value) => *value = \"Venus\",\n ///     None => (),\n /// }\n ///\n-/// assert_eq!(months.find(&3), Some(&\"Venus\"));\n+/// assert_eq!(months.get(&3), Some(&\"Venus\"));\n ///\n /// // Print out all months\n /// for (key, value) in months.iter() {\n@@ -77,10 +79,7 @@ impl<V:Clone> Clone for VecMap<V> {\n \n     #[inline]\n     fn clone_from(&mut self, source: &VecMap<V>) {\n-        self.v.reserve(source.v.len());\n-        for (i, w) in self.v.iter_mut().enumerate() {\n-            *w = source.v[i].clone();\n-        }\n+        self.v.clone_from(&source.v);\n     }\n }\n \n@@ -99,6 +98,7 @@ impl<V> VecMap<V> {\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::new();\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> VecMap<V> { VecMap{v: vec!()} }\n \n     /// Creates an empty `VecMap` with space for at least `capacity`\n@@ -110,18 +110,21 @@ impl<V> VecMap<V> {\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::with_capacity(10);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(capacity: uint) -> VecMap<V> {\n         VecMap { v: Vec::with_capacity(capacity) }\n     }\n \n     /// Returns an iterator visiting all keys in ascending order by the keys.\n     /// The iterator's element type is `uint`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n         self.iter().map(|(k, _v)| k)\n     }\n \n     /// Returns an iterator visiting all values in ascending order by the keys.\n     /// The iterator's element type is `&'r V`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'r>(&'r self) -> Values<'r, V> {\n         self.iter().map(|(_k, v)| v)\n     }\n@@ -144,6 +147,7 @@ impl<V> VecMap<V> {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'r>(&'r self) -> Entries<'r, V> {\n         Entries {\n             front: 0,\n@@ -174,6 +178,7 @@ impl<V> VecMap<V> {\n     ///     assert_eq!(value, &\"x\");\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter_mut<'r>(&'r mut self) -> MutEntries<'r, V> {\n         MutEntries {\n             front: 0,\n@@ -201,6 +206,7 @@ impl<V> VecMap<V> {\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(&mut self)\n         -> FilterMap<(uint, Option<V>), (uint, V),\n                 Enumerate<vec::MoveItems<Option<V>>>>\n@@ -223,6 +229,7 @@ impl<V> VecMap<V> {\n     /// a.insert(1, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint {\n         self.v.iter().filter(|elt| elt.is_some()).count()\n     }\n@@ -239,6 +246,7 @@ impl<V> VecMap<V> {\n     /// a.insert(1, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool {\n         self.v.iter().all(|elt| elt.is_none())\n     }\n@@ -255,8 +263,15 @@ impl<V> VecMap<V> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) { self.v.clear() }\n \n+    /// Deprecated: Renamed to `get`.\n+    #[deprecated = \"Renamed to `get`\"]\n+    pub fn find(&self, key: &uint) -> Option<&V> {\n+        self.get(key)\n+    }\n+\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// # Example\n@@ -266,10 +281,11 @@ impl<V> VecMap<V> {\n     ///\n     /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n-    /// assert_eq!(map.find(&1), Some(&\"a\"));\n-    /// assert_eq!(map.find(&2), None);\n+    /// assert_eq!(map.get(&1), Some(&\"a\"));\n+    /// assert_eq!(map.get(&2), None);\n     /// ```\n-    pub fn find<'a>(&'a self, key: &uint) -> Option<&'a V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get(&self, key: &uint) -> Option<&V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n               Some(ref value) => Some(value),\n@@ -293,8 +309,15 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains_key(&self, key: &uint) -> bool {\n-        self.find(key).is_some()\n+        self.get(key).is_some()\n+    }\n+\n+    /// Deprecated: Renamed to `get_mut`.\n+    #[deprecated = \"Renamed to `get_mut`\"]\n+    pub fn find_mut(&mut self, key: &uint) -> Option<&mut V> {\n+        self.get_mut(key)\n     }\n \n     /// Returns a mutable reference to the value corresponding to the key.\n@@ -306,13 +329,14 @@ impl<V> VecMap<V> {\n     ///\n     /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n-    /// match map.find_mut(&1) {\n+    /// match map.get_mut(&1) {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n-    pub fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get_mut(&mut self, key: &uint) -> Option<&mut V> {\n         if *key < self.v.len() {\n             match *(&mut self.v[*key]) {\n               Some(ref mut value) => Some(value),\n@@ -323,45 +347,10 @@ impl<V> VecMap<V> {\n         }\n     }\n \n-    /// Inserts a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Returns `true` if the key did\n-    /// not already exist in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut map = VecMap::new();\n-    /// assert_eq!(map.insert(2, \"value\"), true);\n-    /// assert_eq!(map.insert(2, \"value2\"), false);\n-    /// assert_eq!(map[2], \"value2\");\n-    /// ```\n-    pub fn insert(&mut self, key: uint, value: V) -> bool {\n-        let exists = self.contains_key(&key);\n-        let len = self.v.len();\n-        if len <= key {\n-            self.v.grow_fn(key - len + 1, |_| None);\n-        }\n-        self.v[key] = Some(value);\n-        !exists\n-    }\n-\n-    /// Removes a key-value pair from the map. Returns `true` if the key\n-    /// was present in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut map = VecMap::new();\n-    /// assert_eq!(map.remove(&1), false);\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.remove(&1), true);\n-    /// ```\n-    pub fn remove(&mut self, key: &uint) -> bool {\n-        self.pop(key).is_some()\n+    /// Deprecated: Renamed to `insert`.\n+    #[deprecated = \"Renamed to `insert`\"]\n+    pub fn swap(&mut self, key: uint, value: V) -> Option<V> {\n+        self.insert(key, value)\n     }\n \n     /// Inserts a key-value pair from the map. If the key already had a value\n@@ -373,20 +362,26 @@ impl<V> VecMap<V> {\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n-    /// assert_eq!(map.swap(37, \"a\"), None);\n+    /// assert_eq!(map.insert(37, \"a\"), None);\n     /// assert_eq!(map.is_empty(), false);\n     ///\n     /// map.insert(37, \"b\");\n-    /// assert_eq!(map.swap(37, \"c\"), Some(\"b\"));\n+    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    pub fn swap(&mut self, key: uint, value: V) -> Option<V> {\n-        match self.find_mut(&key) {\n-            Some(loc) => { return Some(replace(loc, value)); }\n-            None => ()\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, key: uint, value: V) -> Option<V> {\n+        let len = self.v.len();\n+        if len <= key {\n+            self.v.grow_fn(key - len + 1, |_| None);\n         }\n-        self.insert(key, value);\n-        return None;\n+        replace(&mut self.v[key], Some(value))\n+    }\n+\n+    /// Deprecated: Renamed to `remove`.\n+    #[deprecated = \"Renamed to `remove`\"]\n+    pub fn pop(&mut self, key: &uint) -> Option<V> {\n+        self.remove(key)\n     }\n \n     /// Removes a key from the map, returning the value at the key if the key\n@@ -399,10 +394,11 @@ impl<V> VecMap<V> {\n     ///\n     /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n-    /// assert_eq!(map.pop(&1), Some(\"a\"));\n-    /// assert_eq!(map.pop(&1), None);\n+    /// assert_eq!(map.remove(&1), Some(\"a\"));\n+    /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    pub fn pop(&mut self, key: &uint) -> Option<V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, key: &uint) -> Option<V> {\n         if *key >= self.v.len() {\n             return None;\n         }\n@@ -460,11 +456,11 @@ impl<V:Clone> VecMap<V> {\n                            val: V,\n                            ff: |uint, V, V| -> V)\n                            -> bool {\n-        let new_val = match self.find(&key) {\n+        let new_val = match self.get(&key) {\n             None => val,\n             Some(orig) => ff(key, (*orig).clone(), val)\n         };\n-        self.insert(key, new_val)\n+        self.insert(key, new_val).is_none()\n     }\n }\n \n@@ -514,14 +510,14 @@ impl<V> Extendable<(uint, V)> for VecMap<V> {\n impl<V> Index<uint, V> for VecMap<V> {\n     #[inline]\n     fn index<'a>(&'a self, i: &uint) -> &'a V {\n-        self.find(i).expect(\"key not present\")\n+        self.get(i).expect(\"key not present\")\n     }\n }\n \n impl<V> IndexMut<uint, V> for VecMap<V> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut V {\n-        self.find_mut(i).expect(\"key not present\")\n+        self.get_mut(i).expect(\"key not present\")\n     }\n }\n \n@@ -615,45 +611,45 @@ mod test_map {\n     use super::VecMap;\n \n     #[test]\n-    fn test_find_mut() {\n+    fn test_get_mut() {\n         let mut m = VecMap::new();\n-        assert!(m.insert(1, 12i));\n-        assert!(m.insert(2, 8));\n-        assert!(m.insert(5, 14));\n+        assert!(m.insert(1, 12i).is_none());\n+        assert!(m.insert(2, 8).is_none());\n+        assert!(m.insert(5, 14).is_none());\n         let new = 100;\n-        match m.find_mut(&5) {\n+        match m.get_mut(&5) {\n             None => panic!(), Some(x) => *x = new\n         }\n-        assert_eq!(m.find(&5), Some(&new));\n+        assert_eq!(m.get(&5), Some(&new));\n     }\n \n     #[test]\n     fn test_len() {\n         let mut map = VecMap::new();\n         assert_eq!(map.len(), 0);\n         assert!(map.is_empty());\n-        assert!(map.insert(5, 20i));\n+        assert!(map.insert(5, 20i).is_none());\n         assert_eq!(map.len(), 1);\n         assert!(!map.is_empty());\n-        assert!(map.insert(11, 12));\n+        assert!(map.insert(11, 12).is_none());\n         assert_eq!(map.len(), 2);\n         assert!(!map.is_empty());\n-        assert!(map.insert(14, 22));\n+        assert!(map.insert(14, 22).is_none());\n         assert_eq!(map.len(), 3);\n         assert!(!map.is_empty());\n     }\n \n     #[test]\n     fn test_clear() {\n         let mut map = VecMap::new();\n-        assert!(map.insert(5, 20i));\n-        assert!(map.insert(11, 12));\n-        assert!(map.insert(14, 22));\n+        assert!(map.insert(5, 20i).is_none());\n+        assert!(map.insert(11, 12).is_none());\n+        assert!(map.insert(14, 22).is_none());\n         map.clear();\n         assert!(map.is_empty());\n-        assert!(map.find(&5).is_none());\n-        assert!(map.find(&11).is_none());\n-        assert!(map.find(&14).is_none());\n+        assert!(map.get(&5).is_none());\n+        assert!(map.get(&11).is_none());\n+        assert!(map.get(&14).is_none());\n     }\n \n     #[test]\n@@ -678,28 +674,28 @@ mod test_map {\n         map.update_with_key(3, 2, add_more_to_count);\n \n         // check the total counts\n-        assert_eq!(map.find(&3).unwrap(), &10);\n-        assert_eq!(map.find(&5).unwrap(), &3);\n-        assert_eq!(map.find(&9).unwrap(), &1);\n+        assert_eq!(map.get(&3).unwrap(), &10);\n+        assert_eq!(map.get(&5).unwrap(), &3);\n+        assert_eq!(map.get(&9).unwrap(), &1);\n \n         // sadly, no sevens were counted\n-        assert!(map.find(&7).is_none());\n+        assert!(map.get(&7).is_none());\n     }\n \n     #[test]\n-    fn test_swap() {\n+    fn test_insert() {\n         let mut m = VecMap::new();\n-        assert_eq!(m.swap(1, 2i), None);\n-        assert_eq!(m.swap(1, 3i), Some(2));\n-        assert_eq!(m.swap(1, 4i), Some(3));\n+        assert_eq!(m.insert(1, 2i), None);\n+        assert_eq!(m.insert(1, 3i), Some(2));\n+        assert_eq!(m.insert(1, 4i), Some(3));\n     }\n \n     #[test]\n-    fn test_pop() {\n+    fn test_remove() {\n         let mut m = VecMap::new();\n         m.insert(1, 2i);\n-        assert_eq!(m.pop(&1), Some(2));\n-        assert_eq!(m.pop(&1), None);\n+        assert_eq!(m.remove(&1), Some(2));\n+        assert_eq!(m.remove(&1), None);\n     }\n \n     #[test]\n@@ -732,11 +728,11 @@ mod test_map {\n     fn test_iterator() {\n         let mut m = VecMap::new();\n \n-        assert!(m.insert(0, 1i));\n-        assert!(m.insert(1, 2));\n-        assert!(m.insert(3, 5));\n-        assert!(m.insert(6, 10));\n-        assert!(m.insert(10, 11));\n+        assert!(m.insert(0, 1i).is_none());\n+        assert!(m.insert(1, 2).is_none());\n+        assert!(m.insert(3, 5).is_none());\n+        assert!(m.insert(6, 10).is_none());\n+        assert!(m.insert(10, 11).is_none());\n \n         let mut it = m.iter();\n         assert_eq!(it.size_hint(), (0, Some(11)));\n@@ -757,11 +753,11 @@ mod test_map {\n     fn test_iterator_size_hints() {\n         let mut m = VecMap::new();\n \n-        assert!(m.insert(0, 1i));\n-        assert!(m.insert(1, 2));\n-        assert!(m.insert(3, 5));\n-        assert!(m.insert(6, 10));\n-        assert!(m.insert(10, 11));\n+        assert!(m.insert(0, 1i).is_none());\n+        assert!(m.insert(1, 2).is_none());\n+        assert!(m.insert(3, 5).is_none());\n+        assert!(m.insert(6, 10).is_none());\n+        assert!(m.insert(10, 11).is_none());\n \n         assert_eq!(m.iter().size_hint(), (0, Some(11)));\n         assert_eq!(m.iter().rev().size_hint(), (0, Some(11)));\n@@ -773,11 +769,11 @@ mod test_map {\n     fn test_mut_iterator() {\n         let mut m = VecMap::new();\n \n-        assert!(m.insert(0, 1i));\n-        assert!(m.insert(1, 2));\n-        assert!(m.insert(3, 5));\n-        assert!(m.insert(6, 10));\n-        assert!(m.insert(10, 11));\n+        assert!(m.insert(0, 1i).is_none());\n+        assert!(m.insert(1, 2).is_none());\n+        assert!(m.insert(3, 5).is_none());\n+        assert!(m.insert(6, 10).is_none());\n+        assert!(m.insert(10, 11).is_none());\n \n         for (k, v) in m.iter_mut() {\n             *v += k as int;\n@@ -796,11 +792,11 @@ mod test_map {\n     fn test_rev_iterator() {\n         let mut m = VecMap::new();\n \n-        assert!(m.insert(0, 1i));\n-        assert!(m.insert(1, 2));\n-        assert!(m.insert(3, 5));\n-        assert!(m.insert(6, 10));\n-        assert!(m.insert(10, 11));\n+        assert!(m.insert(0, 1i).is_none());\n+        assert!(m.insert(1, 2).is_none());\n+        assert!(m.insert(3, 5).is_none());\n+        assert!(m.insert(6, 10).is_none());\n+        assert!(m.insert(10, 11).is_none());\n \n         let mut it = m.iter().rev();\n         assert_eq!(it.next().unwrap(), (10, &11));\n@@ -815,11 +811,11 @@ mod test_map {\n     fn test_mut_rev_iterator() {\n         let mut m = VecMap::new();\n \n-        assert!(m.insert(0, 1i));\n-        assert!(m.insert(1, 2));\n-        assert!(m.insert(3, 5));\n-        assert!(m.insert(6, 10));\n-        assert!(m.insert(10, 11));\n+        assert!(m.insert(0, 1i).is_none());\n+        assert!(m.insert(1, 2).is_none());\n+        assert!(m.insert(3, 5).is_none());\n+        assert!(m.insert(6, 10).is_none());\n+        assert!(m.insert(10, 11).is_none());\n \n         for (k, v) in m.iter_mut().rev() {\n             *v += k as int;\n@@ -880,15 +876,15 @@ mod test_map {\n         let mut b = VecMap::new();\n \n         assert!(a == b);\n-        assert!(a.insert(0, 5i));\n+        assert!(a.insert(0, 5i).is_none());\n         assert!(a != b);\n-        assert!(b.insert(0, 4i));\n+        assert!(b.insert(0, 4i).is_none());\n         assert!(a != b);\n-        assert!(a.insert(5, 19));\n+        assert!(a.insert(5, 19).is_none());\n         assert!(a != b);\n-        assert!(!b.insert(0, 5));\n+        assert!(!b.insert(0, 5).is_none());\n         assert!(a != b);\n-        assert!(b.insert(5, 19));\n+        assert!(b.insert(5, 19).is_none());\n         assert!(a == b);\n     }\n \n@@ -898,15 +894,15 @@ mod test_map {\n         let mut b = VecMap::new();\n \n         assert!(!(a < b) && !(b < a));\n-        assert!(b.insert(2u, 5i));\n+        assert!(b.insert(2u, 5i).is_none());\n         assert!(a < b);\n-        assert!(a.insert(2, 7));\n+        assert!(a.insert(2, 7).is_none());\n         assert!(!(a < b) && b < a);\n-        assert!(b.insert(1, 0));\n+        assert!(b.insert(1, 0).is_none());\n         assert!(b < a);\n-        assert!(a.insert(0, 6));\n+        assert!(a.insert(0, 6).is_none());\n         assert!(a < b);\n-        assert!(a.insert(6, 2));\n+        assert!(a.insert(6, 2).is_none());\n         assert!(a < b && !(b < a));\n     }\n \n@@ -916,10 +912,10 @@ mod test_map {\n         let mut b = VecMap::new();\n \n         assert!(a <= b && a >= b);\n-        assert!(a.insert(1u, 1i));\n+        assert!(a.insert(1u, 1i).is_none());\n         assert!(a > b && a >= b);\n         assert!(b < a && b <= a);\n-        assert!(b.insert(2, 2));\n+        assert!(b.insert(2, 2).is_none());\n         assert!(b > a && b >= a);\n         assert!(a < b && a <= b);\n     }\n@@ -948,7 +944,7 @@ mod test_map {\n         let map: VecMap<char> = xs.iter().map(|&x| x).collect();\n \n         for &(k, v) in xs.iter() {\n-            assert_eq!(map.find(&k), Some(&v));\n+            assert_eq!(map.get(&k), Some(&v));\n         }\n     }\n \n@@ -1022,15 +1018,15 @@ mod bench {\n         let mut m : VecMap<uint> = VecMap::new();\n         find_rand_n(100, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.find(&i); });\n+                    |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_rand_10_000(b: &mut Bencher) {\n         let mut m : VecMap<uint> = VecMap::new();\n         find_rand_n(10_000, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.find(&i); });\n+                    |m, i| { m.get(&i); });\n     }\n \n     // Find seq\n@@ -1039,14 +1035,14 @@ mod bench {\n         let mut m : VecMap<uint> = VecMap::new();\n         find_seq_n(100, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.find(&i); });\n+                   |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_seq_10_000(b: &mut Bencher) {\n         let mut m : VecMap<uint> = VecMap::new();\n         find_seq_n(10_000, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.find(&i); });\n+                   |m, i| { m.get(&i); });\n     }\n }"}, {"sha": "87aebb24f987b7c6295c59031a3e3a82dbbda012", "filename": "src/libstd/collections/hash/bench.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -102,14 +102,14 @@ fn hashmap_as_queue(b: &mut Bencher) {\n     let mut k = 1i;\n \n     b.iter(|| {\n-        m.pop(&k);\n+        m.remove(&k);\n         m.insert(k + 1000, k + 1000);\n         k += 1;\n     });\n }\n \n #[bench]\n-fn find_pop_insert(b: &mut Bencher) {\n+fn get_remove_insert(b: &mut Bencher) {\n     use super::map::HashMap;\n \n     let mut m = HashMap::new();\n@@ -121,9 +121,9 @@ fn find_pop_insert(b: &mut Bencher) {\n     let mut k = 1i;\n \n     b.iter(|| {\n-        m.find(&(k + 400));\n-        m.find(&(k + 2000));\n-        m.pop(&k);\n+        m.get(&(k + 400));\n+        m.get(&(k + 2000));\n+        m.remove(&k);\n         m.insert(k + 1000, k + 1000);\n         k += 1;\n     })"}, {"sha": "7ff332c295cf68471bac022ef019cd75e5b6368a", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 109, "deletions": 144, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -36,6 +36,9 @@ use super::table::{\n     SafeHash\n };\n \n+// FIXME(conventions): update capacity management to match other collections (no auto-shrink)\n+// FIXME(conventions): axe find_copy/get_copy in favour of Option.cloned (also implement that)\n+\n const INITIAL_LOG2_CAP: uint = 5;\n pub const INITIAL_CAPACITY: uint = 1 << INITIAL_LOG2_CAP; // 2^5\n \n@@ -233,7 +236,7 @@ impl DefaultResizePolicy {\n /// // look up the values associated with some keys.\n /// let to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\n /// for book in to_find.iter() {\n-///     match book_reviews.find(book) {\n+///     match book_reviews.get(book) {\n ///         Some(review) => println!(\"{}: {}\", *book, *review),\n ///         None => println!(\"{} is unreviewed.\", *book)\n ///     }\n@@ -480,6 +483,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> HashMap<K, V, RandomSipHasher> {\n         let hasher = RandomSipHasher::new();\n         HashMap::with_hasher(hasher)\n@@ -494,6 +498,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomSipHasher> {\n         let hasher = RandomSipHasher::new();\n         HashMap::with_capacity_and_hasher(capacity, hasher)\n@@ -741,38 +746,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Retrieves a mutable value for the given key.\n-    /// See [`find_mut`](../trait.MutableMap.html#tymethod.find_mut) for a non-panicking\n-    /// alternative.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the key is not present.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1i);\n-    /// {\n-    ///     // val will freeze map to prevent usage during its lifetime\n-    ///     let val = map.get_mut(&\"a\");\n-    ///     *val = 40;\n-    /// }\n-    /// assert_eq!(map[\"a\"], 40);\n-    ///\n-    /// // A more direct way could be:\n-    /// *map.get_mut(&\"a\") = -2;\n-    /// assert_eq!(map[\"a\"], -2);\n-    /// ```\n-    #[deprecated = \"use indexing instead: `&mut map[key]`\"]\n-    pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V {\n-        &mut self[*k]\n-    }\n-\n     /// Return true if the map contains a value for the specified key,\n     /// using equivalence.\n     ///\n@@ -875,6 +848,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///     println!(\"{}\", key);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys(&self) -> Keys<K, V> {\n         self.iter().map(|(k, _v)| k)\n     }\n@@ -896,6 +870,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///     println!(\"{}\", key);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values(&self) -> Values<K, V> {\n         self.iter().map(|(_k, v)| v)\n     }\n@@ -917,6 +892,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter(&self) -> Entries<K, V> {\n         Entries { inner: self.table.iter() }\n     }\n@@ -944,6 +920,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter_mut(&mut self) -> MutEntries<K, V> {\n         MutEntries { inner: self.table.iter_mut() }\n     }\n@@ -965,6 +942,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// // Not possible with .iter()\n     /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveEntries<K, V> {\n         MoveEntries {\n             inner: self.table.into_iter().map(|(_, k, v)| (k, v))\n@@ -996,6 +974,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// a.insert(1u, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.table.size() }\n \n     /// Return true if the map contains no elements.\n@@ -1011,6 +990,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n@@ -1026,6 +1006,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         // Prevent reallocations from happening from now on. Makes it possible\n         // for the map to be reused but has a downside: reserves permanently.\n@@ -1045,6 +1026,12 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n+    /// Deprecated: Renamed to `get`.\n+    #[deprecated = \"Renamed to `get`\"]\n+    pub fn find(&self, k: &K) -> Option<&V> {\n+        self.get(k)\n+    }\n+\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// # Example\n@@ -1054,10 +1041,11 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// let mut map = HashMap::new();\n     /// map.insert(1u, \"a\");\n-    /// assert_eq!(map.find(&1), Some(&\"a\"));\n-    /// assert_eq!(map.find(&2), None);\n+    /// assert_eq!(map.get(&1), Some(&\"a\"));\n+    /// assert_eq!(map.get(&2), None);\n     /// ```\n-    pub fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get(&self, k: &K) -> Option<&V> {\n         self.search(k).map(|bucket| {\n             let (_, v) = bucket.into_refs();\n             v\n@@ -1076,10 +1064,17 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains_key(&self, k: &K) -> bool {\n         self.search(k).is_some()\n     }\n \n+    /// Deprecated: Renamed to `get_mut`.\n+    #[deprecated = \"Renamed to `get_mut`\"]\n+    pub fn find_mut(&mut self, k: &K) -> Option<&mut V> {\n+        self.get_mut(k)\n+    }\n+\n     /// Returns a mutable reference to the value corresponding to the key.\n     ///\n     /// # Example\n@@ -1089,13 +1084,14 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// let mut map = HashMap::new();\n     /// map.insert(1u, \"a\");\n-    /// match map.find_mut(&1) {\n+    /// match map.get_mut(&1) {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n-    pub fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get_mut(&mut self, k: &K) -> Option<&mut V> {\n         match self.search_mut(k) {\n             Some(bucket) => {\n                 let (_, v) = bucket.into_mut_refs();\n@@ -1105,41 +1101,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Inserts a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Returns `true` if the key did\n-    /// not already exist in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// assert_eq!(map.insert(2u, \"value\"), true);\n-    /// assert_eq!(map.insert(2, \"value2\"), false);\n-    /// assert_eq!(map[2], \"value2\");\n-    /// ```\n-    #[inline]\n-    pub fn insert(&mut self, key: K, value: V) -> bool {\n-        self.swap(key, value).is_none()\n-    }\n-\n-    /// Removes a key-value pair from the map. Returns `true` if the key\n-    /// was present in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// assert_eq!(map.remove(&1u), false);\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.remove(&1), true);\n-    /// ```\n-    #[inline]\n-    pub fn remove(&mut self, key: &K) -> bool {\n-        self.pop(key).is_some()\n+    /// Deprecated: Renamed to `insert`.\n+    #[deprecated = \"Renamed to `insert`\"]\n+    pub fn swap(&mut self, k: K, v: V) -> Option<V> {\n+        self.insert(k, v)\n     }\n \n     /// Inserts a key-value pair from the map. If the key already had a value\n@@ -1151,14 +1116,15 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// assert_eq!(map.swap(37u, \"a\"), None);\n+    /// assert_eq!(map.insert(37u, \"a\"), None);\n     /// assert_eq!(map.is_empty(), false);\n     ///\n     /// map.insert(37, \"b\");\n-    /// assert_eq!(map.swap(37, \"c\"), Some(\"b\"));\n+    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    pub fn swap(&mut self, k: K, v: V) -> Option<V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n         let hash = self.make_hash(&k);\n         let potential_new_size = self.table.size() + 1;\n         self.make_some_room(potential_new_size);\n@@ -1170,6 +1136,12 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         retval\n     }\n \n+    /// Deprecated: Renamed to `remove`.\n+    #[deprecated = \"Renamed to `remove`\"]\n+    pub fn pop(&mut self, k: &K) -> Option<V> {\n+        self.remove(k)\n+    }\n+\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n@@ -1180,10 +1152,11 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// let mut map = HashMap::new();\n     /// map.insert(1u, \"a\");\n-    /// assert_eq!(map.pop(&1), Some(\"a\"));\n-    /// assert_eq!(map.pop(&1), None);\n+    /// assert_eq!(map.remove(&1), Some(\"a\"));\n+    /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    pub fn pop(&mut self, k: &K) -> Option<V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, k: &K) -> Option<V> {\n         if self.table.size() == 0 {\n             return None\n         }\n@@ -1260,7 +1233,7 @@ impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// let s: String = map.find_copy(&1).unwrap();\n     /// ```\n     pub fn find_copy(&self, k: &K) -> Option<V> {\n-        self.find(k).map(|v| (*v).clone())\n+        self.get(k).map(|v| (*v).clone())\n     }\n \n     /// Return a copy of the value corresponding to the key.\n@@ -1288,7 +1261,7 @@ impl<K: Eq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<K, V,\n         if self.len() != other.len() { return false; }\n \n         self.iter().all(|(key, value)|\n-            other.find(key).map_or(false, |v| *value == *v)\n+            other.get(key).map_or(false, |v| *value == *v)\n         )\n     }\n }\n@@ -1317,14 +1290,14 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H>\n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Index<K, V> for HashMap<K, V, H> {\n     #[inline]\n     fn index<'a>(&'a self, index: &K) -> &'a V {\n-        self.find(index).expect(\"no entry found for key\")\n+        self.get(index).expect(\"no entry found for key\")\n     }\n }\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> IndexMut<K, V> for HashMap<K, V, H> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, index: &K) -> &'a mut V {\n-        match self.find_mut(index) {\n+        match self.get_mut(index) {\n             Some(v) => v,\n             None => panic!(\"no entry found for key\")\n         }\n@@ -1514,7 +1487,7 @@ mod test_map {\n     fn test_create_capacity_zero() {\n         let mut m = HashMap::with_capacity(0);\n \n-        assert!(m.insert(1i, 1i));\n+        assert!(m.insert(1i, 1i).is_none());\n \n         assert!(m.contains_key(&1));\n         assert!(!m.contains_key(&0));\n@@ -1524,12 +1497,12 @@ mod test_map {\n     fn test_insert() {\n         let mut m = HashMap::new();\n         assert_eq!(m.len(), 0);\n-        assert!(m.insert(1i, 2i));\n+        assert!(m.insert(1i, 2i).is_none());\n         assert_eq!(m.len(), 1);\n-        assert!(m.insert(2i, 4i));\n+        assert!(m.insert(2i, 4i).is_none());\n         assert_eq!(m.len(), 2);\n-        assert_eq!(*m.find(&1).unwrap(), 2);\n-        assert_eq!(*m.find(&2).unwrap(), 4);\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n+        assert_eq!(*m.get(&2).unwrap(), 4);\n     }\n \n     local_data_key!(drop_vector: RefCell<Vec<int>>)\n@@ -1588,7 +1561,7 @@ mod test_map {\n \n             for i in range(0u, 50) {\n                 let k = Dropable::new(i);\n-                let v = m.pop(&k);\n+                let v = m.remove(&k);\n \n                 assert!(v.is_some());\n \n@@ -1679,7 +1652,7 @@ mod test_map {\n     #[test]\n     fn test_empty_pop() {\n         let mut m: HashMap<int, bool> = HashMap::new();\n-        assert_eq!(m.pop(&0), None);\n+        assert_eq!(m.remove(&0), None);\n     }\n \n     #[test]\n@@ -1692,15 +1665,15 @@ mod test_map {\n             assert!(m.is_empty());\n \n             for i in range_inclusive(1i, 1000) {\n-                assert!(m.insert(i, i));\n+                assert!(m.insert(i, i).is_none());\n \n                 for j in range_inclusive(1, i) {\n-                    let r = m.find(&j);\n+                    let r = m.get(&j);\n                     assert_eq!(r, Some(&j));\n                 }\n \n                 for j in range_inclusive(i+1, 1000) {\n-                    let r = m.find(&j);\n+                    let r = m.get(&j);\n                     assert_eq!(r, None);\n                 }\n             }\n@@ -1711,7 +1684,7 @@ mod test_map {\n \n             // remove forwards\n             for i in range_inclusive(1i, 1000) {\n-                assert!(m.remove(&i));\n+                assert!(m.remove(&i).is_some());\n \n                 for j in range_inclusive(1, i) {\n                     assert!(!m.contains_key(&j));\n@@ -1727,12 +1700,12 @@ mod test_map {\n             }\n \n             for i in range_inclusive(1i, 1000) {\n-                assert!(m.insert(i, i));\n+                assert!(m.insert(i, i).is_none());\n             }\n \n             // remove backwards\n             for i in range_step_inclusive(1000i, 1, -1) {\n-                assert!(m.remove(&i));\n+                assert!(m.remove(&i).is_some());\n \n                 for j in range_inclusive(i, 1000) {\n                     assert!(!m.contains_key(&j));\n@@ -1748,68 +1721,68 @@ mod test_map {\n     #[test]\n     fn test_find_mut() {\n         let mut m = HashMap::new();\n-        assert!(m.insert(1i, 12i));\n-        assert!(m.insert(2i, 8i));\n-        assert!(m.insert(5i, 14i));\n+        assert!(m.insert(1i, 12i).is_none());\n+        assert!(m.insert(2i, 8i).is_none());\n+        assert!(m.insert(5i, 14i).is_none());\n         let new = 100;\n-        match m.find_mut(&5) {\n+        match m.get_mut(&5) {\n             None => panic!(), Some(x) => *x = new\n         }\n-        assert_eq!(m.find(&5), Some(&new));\n+        assert_eq!(m.get(&5), Some(&new));\n     }\n \n     #[test]\n     fn test_insert_overwrite() {\n         let mut m = HashMap::new();\n-        assert!(m.insert(1i, 2i));\n-        assert_eq!(*m.find(&1).unwrap(), 2);\n-        assert!(!m.insert(1i, 3i));\n-        assert_eq!(*m.find(&1).unwrap(), 3);\n+        assert!(m.insert(1i, 2i).is_none());\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n+        assert!(!m.insert(1i, 3i).is_none());\n+        assert_eq!(*m.get(&1).unwrap(), 3);\n     }\n \n     #[test]\n     fn test_insert_conflicts() {\n         let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1i, 2i));\n-        assert!(m.insert(5i, 3i));\n-        assert!(m.insert(9i, 4i));\n-        assert_eq!(*m.find(&9).unwrap(), 4);\n-        assert_eq!(*m.find(&5).unwrap(), 3);\n-        assert_eq!(*m.find(&1).unwrap(), 2);\n+        assert!(m.insert(1i, 2i).is_none());\n+        assert!(m.insert(5i, 3i).is_none());\n+        assert!(m.insert(9i, 4i).is_none());\n+        assert_eq!(*m.get(&9).unwrap(), 4);\n+        assert_eq!(*m.get(&5).unwrap(), 3);\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n     }\n \n     #[test]\n     fn test_conflict_remove() {\n         let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1i, 2i));\n-        assert_eq!(*m.find(&1).unwrap(), 2);\n-        assert!(m.insert(5, 3));\n-        assert_eq!(*m.find(&1).unwrap(), 2);\n-        assert_eq!(*m.find(&5).unwrap(), 3);\n-        assert!(m.insert(9, 4));\n-        assert_eq!(*m.find(&1).unwrap(), 2);\n-        assert_eq!(*m.find(&5).unwrap(), 3);\n-        assert_eq!(*m.find(&9).unwrap(), 4);\n-        assert!(m.remove(&1));\n-        assert_eq!(*m.find(&9).unwrap(), 4);\n-        assert_eq!(*m.find(&5).unwrap(), 3);\n+        assert!(m.insert(1i, 2i).is_none());\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n+        assert!(m.insert(5, 3).is_none());\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n+        assert_eq!(*m.get(&5).unwrap(), 3);\n+        assert!(m.insert(9, 4).is_none());\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n+        assert_eq!(*m.get(&5).unwrap(), 3);\n+        assert_eq!(*m.get(&9).unwrap(), 4);\n+        assert!(m.remove(&1).is_some());\n+        assert_eq!(*m.get(&9).unwrap(), 4);\n+        assert_eq!(*m.get(&5).unwrap(), 3);\n     }\n \n     #[test]\n     fn test_is_empty() {\n         let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1i, 2i));\n+        assert!(m.insert(1i, 2i).is_none());\n         assert!(!m.is_empty());\n-        assert!(m.remove(&1));\n+        assert!(m.remove(&1).is_some());\n         assert!(m.is_empty());\n     }\n \n     #[test]\n     fn test_pop() {\n         let mut m = HashMap::new();\n         m.insert(1i, 2i);\n-        assert_eq!(m.pop(&1), Some(2));\n-        assert_eq!(m.pop(&1), None);\n+        assert_eq!(m.remove(&1), Some(2));\n+        assert_eq!(m.remove(&1), None);\n     }\n \n     #[test]\n@@ -1821,19 +1794,11 @@ mod test_map {\n         assert_eq!(m.pop_equiv(&KindaIntLike(1)), None);\n     }\n \n-    #[test]\n-    fn test_swap() {\n-        let mut m = HashMap::new();\n-        assert_eq!(m.swap(1i, 2i), None);\n-        assert_eq!(m.swap(1i, 3i), Some(2));\n-        assert_eq!(m.swap(1i, 4i), Some(3));\n-    }\n-\n     #[test]\n     fn test_iterate() {\n         let mut m = HashMap::with_capacity(4);\n         for i in range(0u, 32) {\n-            assert!(m.insert(i, i*2));\n+            assert!(m.insert(i, i*2).is_none());\n         }\n         assert_eq!(m.len(), 32);\n \n@@ -1871,9 +1836,9 @@ mod test_map {\n     #[test]\n     fn test_find() {\n         let mut m = HashMap::new();\n-        assert!(m.find(&1i).is_none());\n+        assert!(m.get(&1i).is_none());\n         m.insert(1i, 2i);\n-        match m.find(&1) {\n+        match m.get(&1) {\n             None => panic!(),\n             Some(v) => assert_eq!(*v, 2)\n         }\n@@ -1882,7 +1847,7 @@ mod test_map {\n     #[test]\n     fn test_find_copy() {\n         let mut m = HashMap::new();\n-        assert!(m.find(&1i).is_none());\n+        assert!(m.get(&1i).is_none());\n \n         for i in range(1i, 10000) {\n             m.insert(i, i + 7);\n@@ -2026,7 +1991,7 @@ mod test_map {\n         let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n         for &(k, v) in xs.iter() {\n-            assert_eq!(map.find(&k), Some(&v));\n+            assert_eq!(map.get(&k), Some(&v));\n         }\n     }\n \n@@ -2093,7 +2058,7 @@ mod test_map {\n                 assert_eq!(view.set(100), 10);\n             }\n         }\n-        assert_eq!(map.find(&1).unwrap(), &100);\n+        assert_eq!(map.get(&1).unwrap(), &100);\n         assert_eq!(map.len(), 6);\n \n \n@@ -2106,7 +2071,7 @@ mod test_map {\n                 *v = new_v;\n             }\n         }\n-        assert_eq!(map.find(&2).unwrap(), &200);\n+        assert_eq!(map.get(&2).unwrap(), &200);\n         assert_eq!(map.len(), 6);\n \n         // Existing key (take)\n@@ -2116,7 +2081,7 @@ mod test_map {\n                 assert_eq!(view.take(), 30);\n             }\n         }\n-        assert_eq!(map.find(&3), None);\n+        assert_eq!(map.get(&3), None);\n         assert_eq!(map.len(), 5);\n \n \n@@ -2127,7 +2092,7 @@ mod test_map {\n                 assert_eq!(*view.set(1000), 1000);\n             }\n         }\n-        assert_eq!(map.find(&10).unwrap(), &1000);\n+        assert_eq!(map.get(&10).unwrap(), &1000);\n         assert_eq!(map.len(), 6);\n     }\n }"}, {"sha": "45574deec41002d95951eec55f94c03ddcd1155d", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -23,6 +23,9 @@ use result::{Ok, Err};\n \n use super::map::{HashMap, Entries, MoveEntries, INITIAL_CAPACITY};\n \n+// FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n+// FIXME(conventions): update capacity management to match other collections (no auto-shrink)\n+\n \n // Future Optimization (FIXME!)\n // =============================\n@@ -103,6 +106,7 @@ impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n     /// let mut set: HashSet<int> = HashSet::new();\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> HashSet<T, RandomSipHasher> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n@@ -117,6 +121,7 @@ impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n     /// let mut set: HashSet<int> = HashSet::with_capacity(10);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(capacity: uint) -> HashSet<T, RandomSipHasher> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n     }\n@@ -240,16 +245,11 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n         self.map.keys()\n     }\n \n-    /// Deprecated: use `into_iter`.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> SetMoveItems<T> {\n-        self.into_iter()\n-    }\n-\n     /// Creates a consuming iterator, that is, one that moves each value out\n     /// of the set in arbitrary order. The set cannot be used after calling\n     /// this.\n@@ -270,6 +270,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> SetMoveItems<T> {\n         self.map.into_iter().map(|(k, _)| k)\n     }\n@@ -296,6 +297,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// let diff: HashSet<int> = b.difference(&a).map(|&x| x).collect();\n     /// assert_eq!(diff, [4i].iter().map(|&x| x).collect());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn difference<'a>(&'a self, other: &'a HashSet<T, H>) -> SetAlgebraItems<'a, T, H> {\n         Repeat::new(other).zip(self.iter())\n             .filter_map(|(other, elt)| {\n@@ -323,6 +325,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff1, diff2);\n     /// assert_eq!(diff1, [1i, 4].iter().map(|&x| x).collect());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, H>)\n         -> Chain<SetAlgebraItems<'a, T, H>, SetAlgebraItems<'a, T, H>> {\n         self.difference(other).chain(other.difference(self))\n@@ -345,6 +348,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// let diff: HashSet<int> = a.intersection(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [2i, 3].iter().map(|&x| x).collect());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>)\n         -> SetAlgebraItems<'a, T, H> {\n         Repeat::new(other).zip(self.iter())\n@@ -370,6 +374,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn union<'a>(&'a self, other: &'a HashSet<T, H>)\n         -> Chain<SetItems<'a, T>, SetAlgebraItems<'a, T, H>> {\n         self.iter().chain(other.difference(self))\n@@ -387,6 +392,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// v.insert(1u);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -401,6 +407,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// v.insert(1u);\n     /// assert!(!v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.map.len() == 0 }\n \n     /// Clears the set, removing all values.\n@@ -415,6 +422,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) { self.map.clear() }\n \n     /// Returns `true` if the set contains a value.\n@@ -428,6 +436,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n \n     /// Returns `true` if the set has no elements in common with `other`.\n@@ -447,6 +456,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// b.insert(1);\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_disjoint(&self, other: &HashSet<T, H>) -> bool {\n         self.iter().all(|v| !other.contains(v))\n     }\n@@ -467,6 +477,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// set.insert(4);\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_subset(&self, other: &HashSet<T, H>) -> bool {\n         self.iter().all(|v| other.contains(v))\n     }\n@@ -491,6 +502,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_superset(&self, other: &HashSet<T, H>) -> bool {\n         other.is_subset(self)\n     }\n@@ -509,7 +521,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.insert(2), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n-    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }\n \n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n@@ -525,7 +538,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n-    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value).is_some() }\n }\n \n impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {"}, {"sha": "aab0924e7e43973c80a0e2810b8d14dad71ef6f5", "filename": "src/libstd/collections/lru_cache.rs", "status": "modified", "additions": 91, "deletions": 59, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibstd%2Fcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibstd%2Fcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Flru_cache.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -20,20 +20,20 @@\n //! use std::collections::LruCache;\n //!\n //! let mut cache: LruCache<int, int> = LruCache::new(2);\n-//! cache.put(1, 10);\n-//! cache.put(2, 20);\n-//! cache.put(3, 30);\n+//! cache.insert(1, 10);\n+//! cache.insert(2, 20);\n+//! cache.insert(3, 30);\n //! assert!(cache.get(&1).is_none());\n //! assert_eq!(*cache.get(&2).unwrap(), 20);\n //! assert_eq!(*cache.get(&3).unwrap(), 30);\n //!\n-//! cache.put(2, 22);\n+//! cache.insert(2, 22);\n //! assert_eq!(*cache.get(&2).unwrap(), 22);\n //!\n-//! cache.put(6, 60);\n+//! cache.insert(6, 60);\n //! assert!(cache.get(&3).is_none());\n //!\n-//! cache.change_capacity(1);\n+//! cache.set_capacity(1);\n //! assert!(cache.get(&2).is_none());\n //! ```\n \n@@ -49,6 +49,9 @@ use boxed::Box;\n use ptr;\n use result::{Ok, Err};\n \n+// FIXME(conventions): implement iterators?\n+// FIXME(conventions): implement indexing?\n+\n struct KeyRef<K> { k: *const K }\n \n struct LruEntry<K, V> {\n@@ -99,6 +102,7 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n     /// use std::collections::LruCache;\n     /// let mut cache: LruCache<int, &str> = LruCache::new(10);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new(capacity: uint) -> LruCache<K, V> {\n         let cache = LruCache {\n             map: HashMap::new(),\n@@ -112,30 +116,38 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n         return cache;\n     }\n \n-    /// Put a key-value pair into cache.\n+    /// Deprecated: Replaced with `insert`.\n+    #[deprecated = \"Replaced with `insert`\"]\n+    pub fn put(&mut self, k: K, v: V) {\n+        self.insert(k, v);\n+    }\n+\n+    /// Inserts a key-value pair into the cache. If the key already existed, the old value is\n+    /// returned.\n     ///\n     /// # Example\n     ///\n     /// ```\n     /// use std::collections::LruCache;\n     /// let mut cache = LruCache::new(2);\n     ///\n-    /// cache.put(1i, \"a\");\n-    /// cache.put(2, \"b\");\n+    /// cache.insert(1i, \"a\");\n+    /// cache.insert(2, \"b\");\n     /// assert_eq!(cache.get(&1), Some(&\"a\"));\n     /// assert_eq!(cache.get(&2), Some(&\"b\"));\n     /// ```\n-    pub fn put(&mut self, k: K, v: V) {\n-        let (node_ptr, node_opt) = match self.map.find_mut(&KeyRef{k: &k}) {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n+        let (node_ptr, node_opt, old_val) = match self.map.get_mut(&KeyRef{k: &k}) {\n             Some(node) => {\n-                node.value = v;\n+                let old_val = mem::replace(&mut node.value, v);\n                 let node_ptr: *mut LruEntry<K, V> = &mut **node;\n-                (node_ptr, None)\n+                (node_ptr, None, Some(old_val))\n             }\n             None => {\n                 let mut node = box LruEntry::new(k, v);\n                 let node_ptr: *mut LruEntry<K, V> = &mut *node;\n-                (node_ptr, Some(node))\n+                (node_ptr, Some(node), None)\n             }\n         };\n         match node_opt {\n@@ -146,13 +158,14 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n             }\n             Some(node) => {\n                 let keyref = unsafe { &(*node_ptr).key };\n-                self.map.swap(KeyRef{k: keyref}, node);\n+                self.map.insert(KeyRef{k: keyref}, node);\n                 self.attach(node_ptr);\n                 if self.len() > self.capacity() {\n                     self.remove_lru();\n                 }\n             }\n         }\n+        old_val\n     }\n \n     /// Return a value corresponding to the key in the cache.\n@@ -163,16 +176,17 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n     /// use std::collections::LruCache;\n     /// let mut cache = LruCache::new(2);\n     ///\n-    /// cache.put(1i, \"a\");\n-    /// cache.put(2, \"b\");\n-    /// cache.put(2, \"c\");\n-    /// cache.put(3, \"d\");\n+    /// cache.insert(1i, \"a\");\n+    /// cache.insert(2, \"b\");\n+    /// cache.insert(2, \"c\");\n+    /// cache.insert(3, \"d\");\n     ///\n     /// assert_eq!(cache.get(&1), None);\n     /// assert_eq!(cache.get(&2), Some(&\"c\"));\n     /// ```\n-    pub fn get<'a>(&'a mut self, k: &K) -> Option<&'a V> {\n-        let (value, node_ptr_opt) = match self.map.find_mut(&KeyRef{k: k}) {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get(&mut self, k: &K) -> Option<&V> {\n+        let (value, node_ptr_opt) = match self.map.get_mut(&KeyRef{k: k}) {\n             None => (None, None),\n             Some(node) => {\n                 let node_ptr: *mut LruEntry<K, V> = &mut **node;\n@@ -189,6 +203,12 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n         return value;\n     }\n \n+    /// Deprecated: Renamed to `remove`.\n+    #[deprecated = \"Renamed to `remove`\"]\n+    pub fn pop(&mut self, k: &K) -> Option<V> {\n+        self.remove(k)\n+    }\n+\n     /// Remove and return a value corresponding to the key from the cache.\n     ///\n     /// # Example\n@@ -197,15 +217,16 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n     /// use std::collections::LruCache;\n     /// let mut cache = LruCache::new(2);\n     ///\n-    /// cache.put(2i, \"a\");\n+    /// cache.insert(2i, \"a\");\n     ///\n-    /// assert_eq!(cache.pop(&1), None);\n-    /// assert_eq!(cache.pop(&2), Some(\"a\"));\n-    /// assert_eq!(cache.pop(&2), None);\n+    /// assert_eq!(cache.remove(&1), None);\n+    /// assert_eq!(cache.remove(&2), Some(\"a\"));\n+    /// assert_eq!(cache.remove(&2), None);\n     /// assert_eq!(cache.len(), 0);\n     /// ```\n-    pub fn pop(&mut self, k: &K) -> Option<V> {\n-        match self.map.pop(&KeyRef{k: k}) {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, k: &K) -> Option<V> {\n+        match self.map.remove(&KeyRef{k: k}) {\n             None => None,\n             Some(lru_entry) => Some(lru_entry.value)\n         }\n@@ -220,10 +241,17 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n     /// let mut cache: LruCache<int, &str> = LruCache::new(2);\n     /// assert_eq!(cache.capacity(), 2);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint {\n         self.max_size\n     }\n \n+    /// Deprecated: Renamed to `set_capacity`.\n+    #[deprecated = \"Renamed to `set_capacity`\"]\n+    pub fn change_capacity(&mut self, capacity: uint) {\n+        self.set_capacity(capacity)\n+    }\n+\n     /// Change the number of key-value pairs the cache can hold. Remove\n     /// least-recently-used key-value pairs if necessary.\n     ///\n@@ -233,29 +261,30 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n     /// use std::collections::LruCache;\n     /// let mut cache = LruCache::new(2);\n     ///\n-    /// cache.put(1i, \"a\");\n-    /// cache.put(2, \"b\");\n-    /// cache.put(3, \"c\");\n+    /// cache.insert(1i, \"a\");\n+    /// cache.insert(2, \"b\");\n+    /// cache.insert(3, \"c\");\n     ///\n     /// assert_eq!(cache.get(&1), None);\n     /// assert_eq!(cache.get(&2), Some(&\"b\"));\n     /// assert_eq!(cache.get(&3), Some(&\"c\"));\n     ///\n-    /// cache.change_capacity(3);\n-    /// cache.put(1i, \"a\");\n-    /// cache.put(2, \"b\");\n+    /// cache.set_capacity(3);\n+    /// cache.insert(1i, \"a\");\n+    /// cache.insert(2, \"b\");\n     ///\n     /// assert_eq!(cache.get(&1), Some(&\"a\"));\n     /// assert_eq!(cache.get(&2), Some(&\"b\"));\n     /// assert_eq!(cache.get(&3), Some(&\"c\"));\n     ///\n-    /// cache.change_capacity(1);\n+    /// cache.set_capacity(1);\n     ///\n     /// assert_eq!(cache.get(&1), None);\n     /// assert_eq!(cache.get(&2), None);\n     /// assert_eq!(cache.get(&3), Some(&\"c\"));\n     /// ```\n-    pub fn change_capacity(&mut self, capacity: uint) {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn set_capacity(&mut self, capacity: uint) {\n         for _ in range(capacity, self.len()) {\n             self.remove_lru();\n         }\n@@ -267,7 +296,7 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n         if self.len() > 0 {\n             let lru = unsafe { (*self.head).prev };\n             self.detach(lru);\n-            self.map.pop(&KeyRef{k: unsafe { &(*lru).key }});\n+            self.map.remove(&KeyRef{k: unsafe { &(*lru).key }});\n         }\n     }\n \n@@ -290,12 +319,15 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n     }\n \n     /// Return the number of key-value pairs in the cache.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns whether the cache is currently empty.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clear the cache of all key-value pairs.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) { self.map.clear(); }\n }\n \n@@ -347,8 +379,8 @@ mod tests {\n     #[test]\n     fn test_put_and_get() {\n         let mut cache: LruCache<int, int> = LruCache::new(2);\n-        cache.put(1, 10);\n-        cache.put(2, 20);\n+        cache.insert(1, 10);\n+        cache.insert(2, 20);\n         assert_opt_eq(cache.get(&1), 10);\n         assert_opt_eq(cache.get(&2), 20);\n         assert_eq!(cache.len(), 2);\n@@ -357,31 +389,31 @@ mod tests {\n     #[test]\n     fn test_put_update() {\n         let mut cache: LruCache<String, Vec<u8>> = LruCache::new(1);\n-        cache.put(\"1\".to_string(), vec![10, 10]);\n-        cache.put(\"1\".to_string(), vec![10, 19]);\n+        cache.insert(\"1\".to_string(), vec![10, 10]);\n+        cache.insert(\"1\".to_string(), vec![10, 19]);\n         assert_opt_eq(cache.get(&\"1\".to_string()), vec![10, 19]);\n         assert_eq!(cache.len(), 1);\n     }\n \n     #[test]\n     fn test_expire_lru() {\n         let mut cache: LruCache<String, String> = LruCache::new(2);\n-        cache.put(\"foo1\".to_string(), \"bar1\".to_string());\n-        cache.put(\"foo2\".to_string(), \"bar2\".to_string());\n-        cache.put(\"foo3\".to_string(), \"bar3\".to_string());\n+        cache.insert(\"foo1\".to_string(), \"bar1\".to_string());\n+        cache.insert(\"foo2\".to_string(), \"bar2\".to_string());\n+        cache.insert(\"foo3\".to_string(), \"bar3\".to_string());\n         assert!(cache.get(&\"foo1\".to_string()).is_none());\n-        cache.put(\"foo2\".to_string(), \"bar2update\".to_string());\n-        cache.put(\"foo4\".to_string(), \"bar4\".to_string());\n+        cache.insert(\"foo2\".to_string(), \"bar2update\".to_string());\n+        cache.insert(\"foo4\".to_string(), \"bar4\".to_string());\n         assert!(cache.get(&\"foo3\".to_string()).is_none());\n     }\n \n     #[test]\n     fn test_pop() {\n         let mut cache: LruCache<int, int> = LruCache::new(2);\n-        cache.put(1, 10);\n-        cache.put(2, 20);\n+        cache.insert(1, 10);\n+        cache.insert(2, 20);\n         assert_eq!(cache.len(), 2);\n-        let opt1 = cache.pop(&1);\n+        let opt1 = cache.remove(&1);\n         assert!(opt1.is_some());\n         assert_eq!(opt1.unwrap(), 10);\n         assert!(cache.get(&1).is_none());\n@@ -392,35 +424,35 @@ mod tests {\n     fn test_change_capacity() {\n         let mut cache: LruCache<int, int> = LruCache::new(2);\n         assert_eq!(cache.capacity(), 2);\n-        cache.put(1, 10);\n-        cache.put(2, 20);\n-        cache.change_capacity(1);\n+        cache.insert(1, 10);\n+        cache.insert(2, 20);\n+        cache.set_capacity(1);\n         assert!(cache.get(&1).is_none());\n         assert_eq!(cache.capacity(), 1);\n     }\n \n     #[test]\n     fn test_to_string() {\n         let mut cache: LruCache<int, int> = LruCache::new(3);\n-        cache.put(1, 10);\n-        cache.put(2, 20);\n-        cache.put(3, 30);\n+        cache.insert(1, 10);\n+        cache.insert(2, 20);\n+        cache.insert(3, 30);\n         assert_eq!(cache.to_string(), \"{3: 30, 2: 20, 1: 10}\".to_string());\n-        cache.put(2, 22);\n+        cache.insert(2, 22);\n         assert_eq!(cache.to_string(), \"{2: 22, 3: 30, 1: 10}\".to_string());\n-        cache.put(6, 60);\n+        cache.insert(6, 60);\n         assert_eq!(cache.to_string(), \"{6: 60, 2: 22, 3: 30}\".to_string());\n         cache.get(&3);\n         assert_eq!(cache.to_string(), \"{3: 30, 6: 60, 2: 22}\".to_string());\n-        cache.change_capacity(2);\n+        cache.set_capacity(2);\n         assert_eq!(cache.to_string(), \"{3: 30, 6: 60}\".to_string());\n     }\n \n     #[test]\n     fn test_clear() {\n         let mut cache: LruCache<int, int> = LruCache::new(2);\n-        cache.put(1, 10);\n-        cache.put(2, 20);\n+        cache.insert(1, 10);\n+        cache.insert(2, 20);\n         cache.clear();\n         assert!(cache.get(&1).is_none());\n         assert!(cache.get(&2).is_none());"}, {"sha": "3419a3d98a1545b0b48d1e83805dd91a47bc82ca", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b2e4fe6044cce018b723de9b21c500c6eac41/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=cf3b2e4fe6044cce018b723de9b21c500c6eac41", "patch": "@@ -278,7 +278,7 @@\n //!     }\n //! }\n //!\n-//! assert_eq!(count.find(&'s'), Some(&8));\n+//! assert_eq!(count.get(&'s'), Some(&8));\n //!\n //! println!(\"Number of occurences of each character\");\n //! for (char, count) in count.iter() {"}]}