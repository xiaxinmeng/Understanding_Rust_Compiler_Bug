{"sha": "66409e03346c23859a5ee0ff78ff44673725553e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NDA5ZTAzMzQ2YzIzODU5YTVlZTBmZjc4ZmY0NDY3MzcyNTU1M2U=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-12-15T04:40:09Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-12-26T21:40:22Z"}, "message": "Fixed issues raised in review.", "tree": {"sha": "efec3729021e349a5e5145fcaef5e9b621b54d45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efec3729021e349a5e5145fcaef5e9b621b54d45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66409e03346c23859a5ee0ff78ff44673725553e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66409e03346c23859a5ee0ff78ff44673725553e", "html_url": "https://github.com/rust-lang/rust/commit/66409e03346c23859a5ee0ff78ff44673725553e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66409e03346c23859a5ee0ff78ff44673725553e/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "248dbbdffa842f3be4880c5dd016515d3c099f40", "url": "https://api.github.com/repos/rust-lang/rust/commits/248dbbdffa842f3be4880c5dd016515d3c099f40", "html_url": "https://github.com/rust-lang/rust/commit/248dbbdffa842f3be4880c5dd016515d3c099f40"}], "stats": {"total": 49, "additions": 18, "deletions": 31}, "files": [{"sha": "f1bcbf3b6b8a4ff186e657313baa1698f4b46ed2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 31, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/66409e03346c23859a5ee0ff78ff44673725553e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66409e03346c23859a5ee0ff78ff44673725553e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=66409e03346c23859a5ee0ff78ff44673725553e", "patch": "@@ -5057,7 +5057,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Luckily, we can (at least for now) deduce the intermediate steps\n         // just from the end-point.\n         //\n-        // There are basically four cases to consider:\n+        // There are basically five cases to consider:\n         //\n         // 1. Reference to a constructor of a struct:\n         //\n@@ -5119,37 +5119,27 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             // Case 2. Reference to a variant constructor.\n             Def::VariantCtor(def_id, ..) => {\n-                if self.tcx.features().type_alias_enum_variants {\n-                    let adt_def = self_ty.and_then(|t| t.ty_adt_def());\n-                    let (generics_def_id, index) = if let Some(adt_def) = adt_def {\n-                        debug_assert!(adt_def.is_enum());\n-                        (adt_def.did, last)\n-                    } else if last >= 1 && segments[last - 1].args.is_some() {\n-                        // Everything but the penultimate segment should have no\n-                        // parameters at all.\n-                        let enum_def_id = self.tcx.parent_def_id(def_id).unwrap();\n-                        (enum_def_id, last - 1)\n-                    } else {\n-                        // FIXME: lint here suggesting `Enum::<...>::Variant` form\n-                        // instead of `Enum::Variant::<...>` form.\n-\n-                        // Everything but the final segment should have no\n-                        // parameters at all.\n-                        let generics = self.tcx.generics_of(def_id);\n-                        // Variant and struct constructors use the\n-                        // generics of their parent type definition.\n-                        (generics.parent.unwrap_or(def_id), last)\n-                    };\n-                    path_segs.push(PathSeg(generics_def_id, index));\n+                let adt_def = self_ty.and_then(|t| t.ty_adt_def());\n+                let (generics_def_id, index) = if let Some(adt_def) = adt_def {\n+                    debug_assert!(adt_def.is_enum());\n+                    (adt_def.did, last)\n+                } else if last >= 1 && segments[last - 1].args.is_some() {\n+                    // Everything but the penultimate segment should have no\n+                    // parameters at all.\n+                    let enum_def_id = self.tcx.parent_def_id(def_id).unwrap();\n+                    (enum_def_id, last - 1)\n                 } else {\n+                    // FIXME: lint here suggesting `Enum::<...>::Variant` form\n+                    // instead of `Enum::Variant::<...>` form.\n+\n                     // Everything but the final segment should have no\n                     // parameters at all.\n                     let generics = self.tcx.generics_of(def_id);\n                     // Variant and struct constructors use the\n                     // generics of their parent type definition.\n-                    let generics_def_id = generics.parent.unwrap_or(def_id);\n-                    path_segs.push(PathSeg(generics_def_id, last));\n-                }\n+                    (generics.parent.unwrap_or(def_id), last)\n+                };\n+                path_segs.push(PathSeg(generics_def_id, index));\n             }\n \n             // Case 3. Reference to a top-level value.\n@@ -5234,14 +5224,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // provided (if any) into their appropriate spaces. We'll also report\n         // errors if type parameters are provided in an inappropriate place.\n \n-        let is_alias_variant_ctor = if tcx.features().type_alias_enum_variants {\n+        let is_alias_variant_ctor =\n             match def {\n                 Def::VariantCtor(_, _) if self_ty.is_some() => true,\n                 _ => false,\n-            }\n-        } else {\n-            false\n-        };\n+            };\n \n         let generic_segs: FxHashSet<_> = path_segs.iter().map(|PathSeg(_, index)| index).collect();\n         AstConv::prohibit_generics(self, segments.iter().enumerate().filter_map(|(index, seg)| {"}]}