{"sha": "b278d675a231fdfe825c72e499d59e8a3d07ffaa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNzhkNjc1YTIzMWZkZmU4MjVjNzJlNDk5ZDU5ZThhM2QwN2ZmYWE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-15T00:24:19Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-15T18:10:52Z"}, "message": "rt: Look up ports through a single port table\n\nInstead of a two-level lookup, just use one big table", "tree": {"sha": "426a39a89561d56ac72e328aecc64c045a578e18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/426a39a89561d56ac72e328aecc64c045a578e18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b278d675a231fdfe825c72e499d59e8a3d07ffaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b278d675a231fdfe825c72e499d59e8a3d07ffaa", "html_url": "https://github.com/rust-lang/rust/commit/b278d675a231fdfe825c72e499d59e8a3d07ffaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b278d675a231fdfe825c72e499d59e8a3d07ffaa/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "337d860a8777a761267daaad9b561787b10e7c87", "url": "https://api.github.com/repos/rust-lang/rust/commits/337d860a8777a761267daaad9b561787b10e7c87", "html_url": "https://github.com/rust-lang/rust/commit/337d860a8777a761267daaad9b561787b10e7c87"}], "stats": {"total": 138, "additions": 68, "deletions": 70}, "files": [{"sha": "de782c355c30fadf3c8c00520576ca74c810baf7", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b278d675a231fdfe825c72e499d59e8a3d07ffaa/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b278d675a231fdfe825c72e499d59e8a3d07ffaa/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=b278d675a231fdfe825c72e499d59e8a3d07ffaa", "patch": "@@ -513,27 +513,20 @@ get_port_id(rust_port *port) {\n extern \"C\" CDECL uintptr_t\n chan_id_send(type_desc *t, rust_task_id target_task_id,\n              rust_port_id target_port_id, void *sptr) {\n-    // FIXME: make sure this is thread-safe\n     bool sent = false;\n     rust_task *task = rust_task_thread::get_task();\n \n     LOG(task, comm, \"chan_id_send task: 0x%\" PRIxPTR\n         \" port: 0x%\" PRIxPTR, (uintptr_t) target_task_id,\n         (uintptr_t) target_port_id);\n \n-    rust_task *target_task = task->kernel->get_task_by_id(target_task_id);\n-    if(target_task) {\n-        rust_port *port = target_task->get_port_by_id(target_port_id);\n-        if(port) {\n-            port->send(sptr);\n-            port->deref();\n-            sent = true;\n-        } else {\n-            LOG(task, comm, \"didn't get the port\");\n-        }\n-        target_task->deref();\n+    rust_port *port = task->kernel->get_port_by_id(target_port_id);\n+    if(port) {\n+        port->send(sptr);\n+        port->deref();\n+        sent = true;\n     } else {\n-        LOG(task, comm, \"didn't get the task\");\n+        LOG(task, comm, \"didn't get the port\");\n     }\n     return (uintptr_t)sent;\n }"}, {"sha": "e32f4d6dda8300a4c976254dcb2a3e1dcb429300", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b278d675a231fdfe825c72e499d59e8a3d07ffaa/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b278d675a231fdfe825c72e499d59e8a3d07ffaa/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=b278d675a231fdfe825c72e499d59e8a3d07ffaa", "patch": "@@ -18,6 +18,7 @@ rust_kernel::rust_kernel(rust_srv *srv) :\n     _log(srv, NULL),\n     srv(srv),\n     max_task_id(0),\n+    max_port_id(0),\n     rval(0),\n     max_sched_id(0),\n     env(srv->env)\n@@ -212,6 +213,46 @@ rust_kernel::get_task_by_id(rust_task_id id) {\n     return task;\n }\n \n+rust_port_id\n+rust_kernel::register_port(rust_port *port) {\n+    uintptr_t new_live_ports;\n+    rust_port_id new_port_id;\n+    {\n+        scoped_lock with(port_lock);\n+        new_port_id = max_port_id++;\n+        port_table.put(new_port_id, port);\n+        new_live_ports = port_table.count();\n+    }\n+    K(srv, new_port_id != INTPTR_MAX, \"Hit the maximum port id\");\n+    KLOG_(\"Registered port %\" PRIdPTR, new_port_id);\n+    KLOG_(\"Total outstanding ports: %d\", new_live_ports);\n+    return new_port_id;\n+}\n+\n+void\n+rust_kernel::release_port_id(rust_port_id id) {\n+    KLOG_(\"Releasing port %\" PRIdPTR, id);\n+    uintptr_t new_live_ports;\n+    {\n+        scoped_lock with(port_lock);\n+        port_table.remove(id);\n+        new_live_ports = port_table.count();\n+    }\n+    KLOG_(\"Total outstanding ports: %d\", new_live_ports);\n+}\n+\n+rust_port *\n+rust_kernel::get_port_by_id(rust_port_id id) {\n+    scoped_lock with(port_lock);\n+    rust_port *port = NULL;\n+    // get leaves port unchanged if not found.\n+    port_table.get(id, &port);\n+    if(port) {\n+        port->ref();\n+    }\n+    return port;\n+}\n+\n #ifdef __WIN32__\n void\n rust_kernel::win32_require(LPCTSTR fn, BOOL ok) {"}, {"sha": "26938ec565ba742f28860044229d6afed5677a95", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b278d675a231fdfe825c72e499d59e8a3d07ffaa/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/b278d675a231fdfe825c72e499d59e8a3d07ffaa/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=b278d675a231fdfe825c72e499d59e8a3d07ffaa", "patch": "@@ -30,6 +30,12 @@ class rust_kernel {\n     rust_task_id max_task_id;\n     hash_map<rust_task_id, rust_task *> task_table;\n \n+    // Protects max_port_id and port_table\n+    lock_and_signal port_lock;\n+    // The next port id\n+    rust_task_id max_port_id;\n+    hash_map<rust_port_id, rust_port *> port_table;\n+\n     lock_and_signal rval_lock;\n     int rval;\n \n@@ -73,6 +79,10 @@ class rust_kernel {\n     rust_task *get_task_by_id(rust_task_id id);\n     void release_task_id(rust_task_id tid);\n \n+    rust_port_id register_port(rust_port *port);\n+    rust_port *get_port_by_id(rust_port_id id);\n+    void release_port_id(rust_port_id tid);\n+\n     void set_exit_status(int code);\n };\n "}, {"sha": "cf75e113c06f3c6e34b7b8a175de421570b6c8fe", "filename": "src/rt/rust_port.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b278d675a231fdfe825c72e499d59e8a3d07ffaa/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b278d675a231fdfe825c72e499d59e8a3d07ffaa/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=b278d675a231fdfe825c72e499d59e8a3d07ffaa", "patch": "@@ -11,7 +11,7 @@ rust_port::rust_port(rust_task *task, size_t unit_sz)\n         PRIxPTR, (uintptr_t)task, unit_sz, (uintptr_t)this);\n \n     task->ref();\n-    id = task->register_port(this);\n+    id = kernel->register_port(this);\n }\n \n rust_port::~rust_port() {\n@@ -39,7 +39,7 @@ void rust_port::deref() {\n void rust_port::begin_detach(uintptr_t *yield) {\n     *yield = false;\n \n-    task->release_port(id);\n+    kernel->release_port_id(id);\n \n     scoped_lock with(ref_lock);\n     ref_count--;"}, {"sha": "aba93576700d1e5026d5409cb94ef98ce6762ac1", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 9, "deletions": 45, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b278d675a231fdfe825c72e499d59e8a3d07ffaa/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b278d675a231fdfe825c72e499d59e8a3d07ffaa/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=b278d675a231fdfe825c72e499d59e8a3d07ffaa", "patch": "@@ -75,7 +75,6 @@ rust_task::rust_task(rust_task_thread *thread, rust_task_list *state,\n     kernel(thread->kernel),\n     name(name),\n     list_index(-1),\n-    next_port_id(0),\n     rendezvous_ptr(0),\n     local_region(&thread->srv->local_region),\n     boxed(&local_region),\n@@ -107,11 +106,6 @@ rust_task::rust_task(rust_task_thread *thread, rust_task_list *state,\n void\n rust_task::delete_this()\n {\n-    {\n-        scoped_lock with (port_lock);\n-        I(thread, port_table.is_empty());\n-    }\n-\n     DLOG(thread, task, \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n          name, (uintptr_t)this, ref_count);\n \n@@ -476,49 +470,19 @@ rust_task::calloc(size_t size, const char *tag) {\n     return local_region.calloc(size, tag);\n }\n \n-rust_port_id rust_task::register_port(rust_port *port) {\n-    I(thread, !port_lock.lock_held_by_current_thread());\n-    scoped_lock with(port_lock);\n-\n-    rust_port_id id = next_port_id++;\n-    A(thread, id != INTPTR_MAX, \"Hit the maximum port id\");\n-    port_table.put(id, port);\n-    return id;\n-}\n-\n-void rust_task::release_port(rust_port_id id) {\n-    scoped_lock with(port_lock);\n-    port_table.remove(id);\n-}\n-\n-rust_port *rust_task::get_port_by_id(rust_port_id id) {\n-    I(thread, !port_lock.lock_held_by_current_thread());\n-    scoped_lock with(port_lock);\n-    rust_port *port = NULL;\n-    port_table.get(id, &port);\n-    if (port) {\n-        port->ref();\n-    }\n-    return port;\n-}\n-\n void\n rust_task::notify(bool success) {\n     // FIXME (1078) Do this in rust code\n     if(notify_enabled) {\n-        rust_task *target_task = kernel->get_task_by_id(notify_chan.task);\n-        if (target_task) {\n-            rust_port *target_port =\n-                target_task->get_port_by_id(notify_chan.port);\n-            if(target_port) {\n-                task_notification msg;\n-                msg.id = id;\n-                msg.result = !success ? tr_failure : tr_success;\n-\n-                target_port->send(&msg);\n-                target_port->deref();\n-            }\n-            target_task->deref();\n+        rust_port *target_port =\n+            kernel->get_port_by_id(notify_chan.port);\n+        if(target_port) {\n+            task_notification msg;\n+            msg.id = id;\n+            msg.result = !success ? tr_failure : tr_success;\n+\n+            target_port->send(&msg);\n+            target_port->deref();\n         }\n     }\n }"}, {"sha": "2d12de9f1966793650575adf1e398546c47e86c3", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b278d675a231fdfe825c72e499d59e8a3d07ffaa/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/b278d675a231fdfe825c72e499d59e8a3d07ffaa/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=b278d675a231fdfe825c72e499d59e8a3d07ffaa", "patch": "@@ -70,8 +70,6 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     const char *const name;\n     int32_t list_index;\n \n-    rust_port_id next_port_id;\n-\n     // Rendezvous pointer for receiving data when blocked on a port. If we're\n     // trying to read data and no data is available on any incoming channel,\n     // we block on the port, and yield control to the scheduler. Since, we\n@@ -100,10 +98,6 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n \n private:\n \n-    // Protects port_table\n-    lock_and_signal port_lock;\n-    hash_map<rust_port_id, rust_port *> port_table;\n-\n     // Protects state, cond, cond_name\n     lock_and_signal state_lock;\n     rust_task_list *state;\n@@ -201,10 +195,6 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n \n     void *calloc(size_t size, const char *tag);\n \n-    rust_port_id register_port(rust_port *port);\n-    void release_port(rust_port_id id);\n-    rust_port *get_port_by_id(rust_port_id id);\n-\n     // Use this function sparingly. Depending on the ref count is generally\n     // not at all safe.\n     intptr_t get_ref_count() const { return ref_count; }"}]}