{"sha": "cc71eef498a24af884c4ffa288101a73447bfc61", "node_id": "C_kwDOAAsO6NoAKGNjNzFlZWY0OThhMjRhZjg4NGM0ZmZhMjg4MTAxYTczNDQ3YmZjNjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-06T23:38:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-06T23:38:28Z"}, "message": "Auto merge of #100213 - matthiaskrgr:rollup-mqe7t1n, r=matthiaskrgr\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #100071 (deps: dedupe `annotate-snippets` crate versions)\n - #100127 (Remove Windows function preloading)\n - #100130 (Avoid pointing out `return` span if it has nothing to do with type error)\n - #100169 (Optimize `pointer::as_aligned_to`)\n - #100175 (ascii -> ASCII in code comment)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "08264d7f0b3f50f0b8353fed508381c608601d6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08264d7f0b3f50f0b8353fed508381c608601d6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc71eef498a24af884c4ffa288101a73447bfc61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc71eef498a24af884c4ffa288101a73447bfc61", "html_url": "https://github.com/rust-lang/rust/commit/cc71eef498a24af884c4ffa288101a73447bfc61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc71eef498a24af884c4ffa288101a73447bfc61/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2befdefdda0f2bc5ff93f7f95633c98841409098", "url": "https://api.github.com/repos/rust-lang/rust/commits/2befdefdda0f2bc5ff93f7f95633c98841409098", "html_url": "https://github.com/rust-lang/rust/commit/2befdefdda0f2bc5ff93f7f95633c98841409098"}, {"sha": "ee0b755fe625cd10b11adfaa51f3d0f1e3ca33f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee0b755fe625cd10b11adfaa51f3d0f1e3ca33f0", "html_url": "https://github.com/rust-lang/rust/commit/ee0b755fe625cd10b11adfaa51f3d0f1e3ca33f0"}], "stats": {"total": 485, "additions": 266, "deletions": 219}, "files": [{"sha": "11d57deb699714aeb6b8a1262665f5e993d3529d", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -82,12 +82,6 @@ dependencies = [\n  \"url 2.2.2\",\n ]\n \n-[[package]]\n-name = \"annotate-snippets\"\n-version = \"0.8.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d78ea013094e5ea606b1c05fe35f1dd7ea1eb1ea259908d040b25bd5ec677ee5\"\n-\n [[package]]\n name = \"annotate-snippets\"\n version = \"0.9.1\"\n@@ -3862,7 +3856,7 @@ dependencies = [\n name = \"rustc_errors\"\n version = \"0.0.0\"\n dependencies = [\n- \"annotate-snippets 0.8.0\",\n+ \"annotate-snippets\",\n  \"atty\",\n  \"rustc_data_structures\",\n  \"rustc_error_messages\",\n@@ -4114,7 +4108,7 @@ dependencies = [\n name = \"rustc_macros\"\n version = \"0.1.0\"\n dependencies = [\n- \"annotate-snippets 0.8.0\",\n+ \"annotate-snippets\",\n  \"fluent-bundle\",\n  \"fluent-syntax\",\n  \"proc-macro2\",\n@@ -4729,7 +4723,7 @@ dependencies = [\n name = \"rustfmt-nightly\"\n version = \"1.5.1\"\n dependencies = [\n- \"annotate-snippets 0.9.1\",\n+ \"annotate-snippets\",\n  \"anyhow\",\n  \"bytecount\",\n  \"cargo_metadata 0.14.0\","}, {"sha": "36805aa874fe7740961f1740f80317f74556e02e", "filename": "compiler/rustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/compiler%2Frustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/compiler%2Frustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2FCargo.toml?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -18,7 +18,7 @@ rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n unicode-width = \"0.1.4\"\n atty = \"0.2\"\n termcolor = \"1.0\"\n-annotate-snippets = \"0.8.0\"\n+annotate-snippets = \"0.9\"\n termize = \"0.1.1\"\n serde = { version = \"1.0.125\", features = [\"derive\"] }\n serde_json = \"1.0.59\""}, {"sha": "3df562c7edac7fc1ca0077797aa455b7f2cc5db2", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -183,7 +183,11 @@ impl AnnotateSnippetEmitterWriter {\n                     annotation_type: annotation_type_for_level(*level),\n                 }),\n                 footer: vec![],\n-                opt: FormatOptions { color: true, anonymized_line_numbers: self.ui_testing },\n+                opt: FormatOptions {\n+                    color: true,\n+                    anonymized_line_numbers: self.ui_testing,\n+                    margin: None,\n+                },\n                 slices: annotated_files\n                     .iter()\n                     .map(|(source, line_index, annotations)| {"}, {"sha": "547c8debb505db657a21b4a4ff323d42c0ff37e9", "filename": "compiler/rustc_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/compiler%2Frustc_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/compiler%2Frustc_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2FCargo.toml?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -7,7 +7,7 @@ edition = \"2021\"\n proc-macro = true\n \n [dependencies]\n-annotate-snippets = \"0.8.0\"\n+annotate-snippets = \"0.9\"\n fluent-bundle = \"0.15.2\"\n fluent-syntax = \"0.11\"\n synstructure = \"0.12.1\""}, {"sha": "21d0a7869d68ea570df88c6e42047cb9ae3904ee", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -1493,6 +1493,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     // type)\n                     (self.final_ty.unwrap_or(self.expected_ty), expression_ty)\n                 };\n+                let (expected, found) = fcx.resolve_vars_if_possible((expected, found));\n \n                 let mut err;\n                 let mut unsized_return = false;\n@@ -1695,9 +1696,30 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             );\n         }\n \n-        if let (Some(sp), Some(fn_output)) = (fcx.ret_coercion_span.get(), fn_output) {\n+        let ret_coercion_span = fcx.ret_coercion_span.get();\n+\n+        if let Some(sp) = ret_coercion_span\n+            // If the closure has an explicit return type annotation, or if\n+            // the closure's return type has been inferred from outside\n+            // requirements (such as an Fn* trait bound), then a type error\n+            // may occur at the first return expression we see in the closure\n+            // (if it conflicts with the declared return type). Skip adding a\n+            // note in this case, since it would be incorrect.\n+            && !fcx.return_type_pre_known\n+        {\n+            err.span_note(\n+                sp,\n+                &format!(\n+                    \"return type inferred to be `{}` here\",\n+                    expected\n+                ),\n+            );\n+        }\n+\n+        if let (Some(sp), Some(fn_output)) = (ret_coercion_span, fn_output) {\n             self.add_impl_trait_explanation(&mut err, cause, fcx, expected, sp, fn_output);\n         }\n+\n         err\n     }\n "}, {"sha": "0595b9a73bed56ce5c733974686e89ab95e0c5ef", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -45,7 +45,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.note_type_is_not_clone(err, expected, expr_ty, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n-        self.report_closure_inferred_return_type(err, expected);\n     }\n \n     // Requires that the two types unify, and prints an error message if\n@@ -1418,25 +1417,4 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => false,\n         }\n     }\n-\n-    // Report the type inferred by the return statement.\n-    fn report_closure_inferred_return_type(&self, err: &mut Diagnostic, expected: Ty<'tcx>) {\n-        if let Some(sp) = self.ret_coercion_span.get()\n-            // If the closure has an explicit return type annotation, or if\n-            // the closure's return type has been inferred from outside\n-            // requirements (such as an Fn* trait bound), then a type error\n-            // may occur at the first return expression we see in the closure\n-            // (if it conflicts with the declared return type). Skip adding a\n-            // note in this case, since it would be incorrect.\n-            && !self.return_type_pre_known\n-        {\n-            err.span_note(\n-                sp,\n-                &format!(\n-                    \"return type inferred to be `{}` here\",\n-                    self.resolve_vars_if_possible(expected)\n-                ),\n-            );\n-        }\n-    }\n }"}, {"sha": "2cd6e23c71a3e6cbd9c7a44cdf53c5dddbad89bf", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -1336,11 +1336,8 @@ impl<T: ?Sized> *const T {\n             panic!(\"is_aligned_to: align is not a power-of-two\");\n         }\n \n-        // SAFETY: `is_power_of_two()` will return `false` for zero.\n-        unsafe { core::intrinsics::assume(align != 0) };\n-\n         // Cast is needed for `T: !Sized`\n-        self.cast::<u8>().addr() % align == 0\n+        self.cast::<u8>().addr() & align - 1 == 0\n     }\n }\n "}, {"sha": "56ad5f7658e3d9dd48870131c671b13c17b2d63f", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -1614,11 +1614,8 @@ impl<T: ?Sized> *mut T {\n             panic!(\"is_aligned_to: align is not a power-of-two\");\n         }\n \n-        // SAFETY: `is_power_of_two()` will return `false` for zero.\n-        unsafe { core::intrinsics::assume(align != 0) };\n-\n         // Cast is needed for `T: !Sized`\n-        self.cast::<u8>().addr() % align == 0\n+        self.cast::<u8>().addr() & align - 1 == 0\n     }\n }\n "}, {"sha": "ee66895a7ed2a9dfa6caf796e42cc0e3d9b4da78", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -2353,7 +2353,7 @@ impl str {\n     #[inline]\n     pub fn is_ascii(&self) -> bool {\n         // We can treat each byte as character here: all multibyte characters\n-        // start with a byte that is not in the ascii range, so we will stop\n+        // start with a byte that is not in the ASCII range, so we will stop\n         // there already.\n         self.as_bytes().is_ascii()\n     }"}, {"sha": "c5a30f8bac86d1687919e0e11a1ea28d1d10b1cd", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -1250,19 +1250,21 @@ compat_fn_with_fallback! {\n     }\n }\n \n-compat_fn_optional! {\n+compat_fn_with_fallback! {\n     pub static SYNCH_API: &CStr = ansi_str!(\"api-ms-win-core-synch-l1-2-0\");\n-\n-    // >= Windows 8 / Server 2012\n-    // https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitonaddress\n-    pub fn WaitOnAddress(\n-        Address: LPVOID,\n-        CompareAddress: LPVOID,\n-        AddressSize: SIZE_T,\n-        dwMilliseconds: DWORD\n-    ) -> BOOL;\n-    pub fn WakeByAddressSingle(Address: LPVOID) -> ();\n+    #[allow(unused)]\n+    fn WakeByAddressSingle(Address: LPVOID) -> () {\n+        // This fallback is currently tightly coupled to its use in Parker::unpark.\n+        //\n+        // FIXME: If `WakeByAddressSingle` needs to be used anywhere other than\n+        // Parker::unpark then this fallback will be wrong and will need to be decoupled.\n+        crate::sys::windows::thread_parker::unpark_keyed_event(Address)\n+    }\n }\n+pub use crate::sys::compat::WaitOnAddress;\n+// Change exported name of `WakeByAddressSingle` to make the strange fallback\n+// behaviour clear.\n+pub use WakeByAddressSingle::call as wake_by_address_single_or_unpark_keyed_event;\n \n compat_fn_with_fallback! {\n     pub static NTDLL: &CStr = ansi_str!(\"ntdll\");"}, {"sha": "473544c4d4f7b99c231209dba5a1765cdacc3fd6", "filename": "library/std/src/sys/windows/compat.rs", "status": "modified", "additions": 65, "deletions": 134, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -7,47 +7,17 @@\n //! `GetModuleHandle` and `GetProcAddress` to look up DLL entry points at\n //! runtime.\n //!\n-//! This implementation uses a static initializer to look up the DLL entry\n-//! points. The CRT (C runtime) executes static initializers before `main`\n-//! is called (for binaries) and before `DllMain` is called (for DLLs).\n-//! This is the ideal time to look up DLL imports, because we are guaranteed\n-//! that no other threads will attempt to call these entry points. Thus,\n-//! we can look up the imports and store them in `static mut` fields\n-//! without any synchronization.\n+//! This is implemented simply by storing a function pointer in an atomic.\n+//! Loading and calling this function will have little or no overhead\n+//! compared with calling any other dynamically imported function.\n //!\n-//! This has an additional advantage: Because the DLL import lookup happens\n-//! at module initialization, the cost of these lookups is deterministic,\n-//! and is removed from the code paths that actually call the DLL imports.\n-//! That is, there is no unpredictable \"cache miss\" that occurs when calling\n-//! a DLL import. For applications that benefit from predictable delays,\n-//! this is a benefit. This also eliminates the comparison-and-branch\n-//! from the hot path.\n-//!\n-//! Currently, the standard library uses only a small number of dynamic\n-//! DLL imports. If this number grows substantially, then the cost of\n-//! performing all of the lookups at initialization time might become\n-//! substantial.\n-//!\n-//! The mechanism of registering a static initializer with the CRT is\n-//! documented in\n-//! [CRT Initialization](https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-160).\n-//! It works by contributing a global symbol to the `.CRT$XCU` section.\n-//! The linker builds a table of all static initializer functions.\n-//! The CRT startup code then iterates that table, calling each\n-//! initializer function.\n-//!\n-//! # **WARNING!!*\n-//! The environment that a static initializer function runs in is highly\n-//! constrained. There are **many** restrictions on what static initializers\n-//! can safely do. Static initializer functions **MUST NOT** do any of the\n-//! following (this list is not comprehensive):\n-//! * touch any other static field that is used by a different static\n-//!   initializer, because the order that static initializers run in\n-//!   is not defined.\n-//! * call `LoadLibrary` or any other function that acquires the DLL\n-//!   loader lock.\n-//! * call any Rust function or CRT function that touches any static\n-//!   (global) state.\n+//! The stored function pointer starts out as an importer function which will\n+//! swap itself with the real function when it's called for the first time. If\n+//! the real function can't be imported then a fallback function is used in its\n+//! place. While this is low cost for the happy path (where the function is\n+//! already loaded) it does mean there's some overhead the first time the\n+//! function is called. In the worst case, multiple threads may all end up\n+//! importing the same function unnecessarily.\n \n use crate::ffi::{c_void, CStr};\n use crate::ptr::NonNull;\n@@ -85,39 +55,6 @@ pub(crate) const fn const_cstr_from_bytes(bytes: &'static [u8]) -> &'static CStr\n     unsafe { crate::ffi::CStr::from_bytes_with_nul_unchecked(bytes) }\n }\n \n-#[used]\n-#[link_section = \".CRT$XCU\"]\n-static INIT_TABLE_ENTRY: unsafe extern \"C\" fn() = init;\n-\n-/// This is where the magic preloading of symbols happens.\n-///\n-/// Note that any functions included here will be unconditionally included in\n-/// the final binary, regardless of whether or not they're actually used.\n-///\n-/// Therefore, this is limited to `compat_fn_optional` functions which must be\n-/// preloaded and any functions which may be more time sensitive, even for the first call.\n-unsafe extern \"C\" fn init() {\n-    // There is no locking here. This code is executed before main() is entered, and\n-    // is guaranteed to be single-threaded.\n-    //\n-    // DO NOT do anything interesting or complicated in this function! DO NOT call\n-    // any Rust functions or CRT functions if those functions touch any global state,\n-    // because this function runs during global initialization. For example, DO NOT\n-    // do any dynamic allocation, don't call LoadLibrary, etc.\n-\n-    if let Some(synch) = Module::new(c::SYNCH_API) {\n-        // These are optional and so we must manually attempt to load them\n-        // before they can be used.\n-        c::WaitOnAddress::preload(synch);\n-        c::WakeByAddressSingle::preload(synch);\n-    }\n-\n-    if let Some(kernel32) = Module::new(c::KERNEL32) {\n-        // Preloading this means getting a precise time will be as fast as possible.\n-        c::GetSystemTimePreciseAsFileTime::preload(kernel32);\n-    }\n-}\n-\n /// Represents a loaded module.\n ///\n /// Note that the modules std depends on must not be unloaded.\n@@ -151,7 +88,7 @@ impl Module {\n macro_rules! compat_fn_with_fallback {\n     (pub static $module:ident: &CStr = $name:expr; $(\n         $(#[$meta:meta])*\n-        pub fn $symbol:ident($($argname:ident: $argtype:ty),*) -> $rettype:ty $fallback_body:block\n+        $vis:vis fn $symbol:ident($($argname:ident: $argtype:ty),*) -> $rettype:ty $fallback_body:block\n     )*) => (\n         pub static $module: &CStr = $name;\n     $(\n@@ -196,78 +133,72 @@ macro_rules! compat_fn_with_fallback {\n                 $fallback_body\n             }\n \n-            #[allow(unused)]\n-            pub(in crate::sys) fn preload(module: Module) {\n-                load_from_module(Some(module));\n-            }\n-\n             #[inline(always)]\n             pub unsafe fn call($($argname: $argtype),*) -> $rettype {\n                 let func: F = mem::transmute(PTR.load(Ordering::Relaxed));\n                 func($($argname),*)\n             }\n         }\n         $(#[$meta])*\n-        pub use $symbol::call as $symbol;\n+        $vis use $symbol::call as $symbol;\n     )*)\n }\n \n-/// A function that either exists or doesn't.\n+/// Optionally load `WaitOnAddress`.\n+/// Unlike the dynamic loading described above, this does not have a fallback.\n ///\n-/// NOTE: Optional functions must be preloaded in the `init` function above, or they will always be None.\n-macro_rules! compat_fn_optional {\n-    (pub static $module:ident: &CStr = $name:expr; $(\n-        $(#[$meta:meta])*\n-        pub fn $symbol:ident($($argname:ident: $argtype:ty),*) -> $rettype:ty;\n-    )*) => (\n-        pub static $module: &CStr = $name;\n-    $(\n-        $(#[$meta])*\n-        pub mod $symbol {\n-            #[allow(unused_imports)]\n-            use super::*;\n-            use crate::mem;\n-            use crate::sync::atomic::{AtomicPtr, Ordering};\n-            use crate::sys::compat::Module;\n-            use crate::ptr::{self, NonNull};\n-\n-            type F = unsafe extern \"system\" fn($($argtype),*) -> $rettype;\n-\n-            /// `PTR` will either be `null()` or set to the loaded function.\n-            static PTR: AtomicPtr<c_void> = AtomicPtr::new(ptr::null_mut());\n-\n-            /// Only allow access to the function if it has loaded successfully.\n-            #[inline(always)]\n-            #[cfg(not(miri))]\n-            pub fn option() -> Option<F> {\n-                unsafe {\n-                    NonNull::new(PTR.load(Ordering::Relaxed)).map(|f| mem::transmute(f))\n-                }\n-            }\n-\n-            // Miri does not understand the way we do preloading\n-            // therefore load the function here instead.\n-            #[cfg(miri)]\n-            pub fn option() -> Option<F> {\n-                let mut func = NonNull::new(PTR.load(Ordering::Relaxed));\n-                if func.is_none() {\n-                    unsafe { Module::new($module).map(preload) };\n-                    func = NonNull::new(PTR.load(Ordering::Relaxed));\n-                }\n-                unsafe {\n-                    func.map(|f| mem::transmute(f))\n-                }\n-            }\n+/// This is rexported from sys::c. You should prefer to import\n+/// from there in case this changes again in the future.\n+pub mod WaitOnAddress {\n+    use super::*;\n+    use crate::mem;\n+    use crate::ptr;\n+    use crate::sync::atomic::{AtomicBool, AtomicPtr, Ordering};\n+    use crate::sys::c;\n+\n+    static MODULE_NAME: &CStr = ansi_str!(\"api-ms-win-core-synch-l1-2-0\");\n+    static SYMBOL_NAME: &CStr = ansi_str!(\"WaitOnAddress\");\n+\n+    // WaitOnAddress function signature.\n+    type F = unsafe extern \"system\" fn(\n+        Address: c::LPVOID,\n+        CompareAddress: c::LPVOID,\n+        AddressSize: c::SIZE_T,\n+        dwMilliseconds: c::DWORD,\n+    );\n+\n+    // A place to store the loaded function atomically.\n+    static WAIT_ON_ADDRESS: AtomicPtr<c_void> = AtomicPtr::new(ptr::null_mut());\n+\n+    // We can skip trying to load again if we already tried.\n+    static LOAD_MODULE: AtomicBool = AtomicBool::new(true);\n+\n+    #[inline(always)]\n+    pub fn option() -> Option<F> {\n+        let f = WAIT_ON_ADDRESS.load(Ordering::Acquire);\n+        if !f.is_null() { Some(unsafe { mem::transmute(f) }) } else { try_load() }\n+    }\n \n-            #[allow(unused)]\n-            pub(in crate::sys) fn preload(module: Module) {\n-                unsafe {\n-                    static SYMBOL_NAME: &CStr = ansi_str!(sym $symbol);\n-                    if let Some(f) = module.proc_address(SYMBOL_NAME) {\n-                        PTR.store(f.as_ptr(), Ordering::Relaxed);\n-                    }\n-                }\n+    #[cold]\n+    fn try_load() -> Option<F> {\n+        if LOAD_MODULE.load(Ordering::Acquire) {\n+            // load the module\n+            let mut wait_on_address = None;\n+            if let Some(func) = try_load_inner() {\n+                WAIT_ON_ADDRESS.store(func.as_ptr(), Ordering::Release);\n+                wait_on_address = Some(unsafe { mem::transmute(func) });\n             }\n+            // Don't try to load the module again even if loading failed.\n+            LOAD_MODULE.store(false, Ordering::Release);\n+            wait_on_address\n+        } else {\n+            None\n         }\n-    )*)\n+    }\n+\n+    // In the future this could be a `try` block but until then I think it's a\n+    // little bit cleaner as a separate function.\n+    fn try_load_inner() -> Option<NonNull<c_void>> {\n+        unsafe { Module::new(MODULE_NAME)?.proc_address(SYMBOL_NAME) }\n+    }\n }"}, {"sha": "16863c9903ac7f76a5947fd2b386941c19575fcd", "filename": "library/std/src/sys/windows/thread_parker.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -197,21 +197,9 @@ impl Parker {\n         // purpose, to make sure every unpark() has a release-acquire ordering\n         // with park().\n         if self.state.swap(NOTIFIED, Release) == PARKED {\n-            if let Some(wake_by_address_single) = c::WakeByAddressSingle::option() {\n-                unsafe {\n-                    wake_by_address_single(self.ptr());\n-                }\n-            } else {\n-                // If we run NtReleaseKeyedEvent before the waiting thread runs\n-                // NtWaitForKeyedEvent, this (shortly) blocks until we can wake it up.\n-                // If the waiting thread wakes up before we run NtReleaseKeyedEvent\n-                // (e.g. due to a timeout), this blocks until we do wake up a thread.\n-                // To prevent this thread from blocking indefinitely in that case,\n-                // park_impl() will, after seeing the state set to NOTIFIED after\n-                // waking up, call NtWaitForKeyedEvent again to unblock us.\n-                unsafe {\n-                    c::NtReleaseKeyedEvent(keyed_event_handle(), self.ptr(), 0, ptr::null_mut());\n-                }\n+            unsafe {\n+                // This calls either WakeByAddressSingle or unpark_keyed_event (see below).\n+                c::wake_by_address_single_or_unpark_keyed_event(self.ptr());\n             }\n         }\n     }\n@@ -221,6 +209,19 @@ impl Parker {\n     }\n }\n \n+// This function signature makes it compatible with c::WakeByAddressSingle\n+// so that it can be used as a fallback for that function.\n+pub unsafe extern \"C\" fn unpark_keyed_event(address: c::LPVOID) {\n+    // If we run NtReleaseKeyedEvent before the waiting thread runs\n+    // NtWaitForKeyedEvent, this (shortly) blocks until we can wake it up.\n+    // If the waiting thread wakes up before we run NtReleaseKeyedEvent\n+    // (e.g. due to a timeout), this blocks until we do wake up a thread.\n+    // To prevent this thread from blocking indefinitely in that case,\n+    // park_impl() will, after seeing the state set to NOTIFIED after\n+    // waking up, call NtWaitForKeyedEvent again to unblock us.\n+    c::NtReleaseKeyedEvent(keyed_event_handle(), address, 0, ptr::null_mut());\n+}\n+\n fn keyed_event_handle() -> c::HANDLE {\n     const INVALID: c::HANDLE = ptr::invalid_mut(!0);\n     static HANDLE: AtomicPtr<libc::c_void> = AtomicPtr::new(INVALID);"}, {"sha": "59607afec8f8da20f901af644eba78a8afe679c3", "filename": "src/test/ui/closures/issue-84128.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fclosures%2Fissue-84128.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fclosures%2Fissue-84128.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-84128.stderr?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -6,11 +6,6 @@ LL |         Foo(())\n    |         |\n    |         arguments to this struct are incorrect\n    |\n-note: return type inferred to be `{integer}` here\n-  --> $DIR/issue-84128.rs:10:20\n-   |\n-LL |             return Foo(0);\n-   |                    ^^^^^^\n note: tuple struct defined here\n   --> $DIR/issue-84128.rs:5:8\n    |"}, {"sha": "d2bba88211ea8c455c7915eb975c7c9fffc698a1", "filename": "src/test/ui/expr/if/if-branch-types.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-branch-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-branch-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-branch-types.stderr?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -5,6 +5,11 @@ LL |     let x = if true { 10i32 } else { 10u32 };\n    |                       -----          ^^^^^ expected `i32`, found `u32`\n    |                       |\n    |                       expected because of this\n+   |\n+help: change the type of the numeric literal from `u32` to `i32`\n+   |\n+LL |     let x = if true { 10i32 } else { 10i32 };\n+   |                                        ~~~\n \n error: aborting due to previous error\n "}, {"sha": "f1fffdb1e7ef8d6443b84aef1cc8e73d1c7be692", "filename": "src/test/ui/expr/if/if-else-type-mismatch.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-else-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-else-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-else-type-mismatch.stderr?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -10,6 +10,11 @@ LL | |         2u32\n    | |         ^^^^ expected `i32`, found `u32`\n LL | |     };\n    | |_____- `if` and `else` have incompatible types\n+   |\n+help: change the type of the numeric literal from `u32` to `i32`\n+   |\n+LL |         2i32\n+   |          ~~~\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/if-else-type-mismatch.rs:8:38\n@@ -18,6 +23,11 @@ LL |     let _ = if true { 42i32 } else { 42u32 };\n    |                       -----          ^^^^^ expected `i32`, found `u32`\n    |                       |\n    |                       expected because of this\n+   |\n+help: change the type of the numeric literal from `u32` to `i32`\n+   |\n+LL |     let _ = if true { 42i32 } else { 42i32 };\n+   |                                        ~~~\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/if-else-type-mismatch.rs:13:9"}, {"sha": "b98da1ed8be6e50b6999bf36ab44742706b8fdbe", "filename": "src/test/ui/generator/type-mismatch-signature-deduction.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -11,6 +11,12 @@ note: return type inferred to be `Result<{integer}, _>` here\n    |\n LL |             return Ok(6);\n    |                    ^^^^^\n+help: try wrapping the expression in a variant of `Result`\n+   |\n+LL |         Ok(5)\n+   |         +++ +\n+LL |         Err(5)\n+   |         ++++ +\n \n error[E0271]: type mismatch resolving `<[generator@$DIR/type-mismatch-signature-deduction.rs:7:5: 7:7] as Generator>::Return == i32`\n   --> $DIR/type-mismatch-signature-deduction.rs:5:13"}, {"sha": "d4a3495515cf14516f1dce084cd539001e450ead", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -12,10 +12,15 @@ error[E0308]: mismatched types\n   --> $DIR/equality.rs:15:5\n    |\n LL | fn two(x: bool) -> impl Foo {\n-   |                    -------- expected `_` because of return type\n+   |                    -------- expected `i32` because of return type\n ...\n LL |     0_u32\n    |     ^^^^^ expected `i32`, found `u32`\n+   |\n+help: change the type of the numeric literal from `u32` to `i32`\n+   |\n+LL |     0_i32\n+   |       ~~~\n \n error[E0277]: cannot add `impl Foo` to `u32`\n   --> $DIR/equality.rs:24:11"}, {"sha": "d6f5a1ac25b641e5cc653d68404c694976c92bd2", "filename": "src/test/ui/impl-trait/object-unsafe-trait-in-return-position-impl-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/object-unsafe-trait-in-return-position-impl-trait.rs:36:5\n    |\n LL | fn can() -> impl NotObjectSafe {\n-   |             ------------------ expected `_` because of return type\n+   |             ------------------ expected `A` because of return type\n ...\n LL |     B\n    |     ^ expected struct `A`, found struct `B`\n@@ -11,7 +11,7 @@ error[E0308]: mismatched types\n   --> $DIR/object-unsafe-trait-in-return-position-impl-trait.rs:43:5\n    |\n LL | fn cat() -> impl ObjectSafe {\n-   |             --------------- expected `_` because of return type\n+   |             --------------- expected `A` because of return type\n ...\n LL |     B\n    |     ^ expected struct `A`, found struct `B`"}, {"sha": "11c1072f02ccc2c85d18dd00359d05f853fd48bd", "filename": "src/test/ui/impl-trait/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 61, "deletions": 6, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -2,28 +2,43 @@ error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:5:5\n    |\n LL | fn foo() -> impl std::fmt::Display {\n-   |             ---------------------- expected `_` because of return type\n+   |             ---------------------- expected `i32` because of return type\n ...\n LL |     1u32\n    |     ^^^^ expected `i32`, found `u32`\n+   |\n+help: change the type of the numeric literal from `u32` to `i32`\n+   |\n+LL |     1i32\n+   |      ~~~\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:12:16\n    |\n LL | fn bar() -> impl std::fmt::Display {\n-   |             ---------------------- expected `_` because of return type\n+   |             ---------------------- expected `i32` because of return type\n ...\n LL |         return 1u32;\n    |                ^^^^ expected `i32`, found `u32`\n+   |\n+help: change the type of the numeric literal from `u32` to `i32`\n+   |\n+LL |         return 1i32;\n+   |                 ~~~\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:20:9\n    |\n LL | fn baz() -> impl std::fmt::Display {\n-   |             ---------------------- expected `_` because of return type\n+   |             ---------------------- expected `i32` because of return type\n ...\n LL |         1u32\n    |         ^^^^ expected `i32`, found `u32`\n+   |\n+help: you can convert a `u32` to an `i32` and panic if the converted value doesn't fit\n+   |\n+LL |     }.try_into().unwrap()\n+   |      ++++++++++++++++++++\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:28:9\n@@ -36,36 +51,56 @@ LL | |         1u32\n    | |         ^^^^ expected `i32`, found `u32`\n LL | |     }\n    | |_____- `if` and `else` have incompatible types\n+   |\n+help: change the type of the numeric literal from `u32` to `i32`\n+   |\n+LL |         1i32\n+   |          ~~~\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:35:14\n    |\n LL | fn bat() -> impl std::fmt::Display {\n-   |             ---------------------- expected `_` because of return type\n+   |             ---------------------- expected `i32` because of return type\n ...\n LL |         _ => 1u32,\n    |              ^^^^ expected `i32`, found `u32`\n+   |\n+help: you can convert a `u32` to an `i32` and panic if the converted value doesn't fit\n+   |\n+LL |     }.try_into().unwrap()\n+   |      ++++++++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:40:5\n    |\n LL |   fn can() -> impl std::fmt::Display {\n-   |               ---------------------- expected `_` because of return type\n+   |               ---------------------- expected `i32` because of return type\n LL | /     match 13 {\n LL | |         0 => return 0i32,\n LL | |         1 => 1u32,\n LL | |         _ => 2u32,\n LL | |     }\n    | |_____^ expected `i32`, found `u32`\n+   |\n+help: you can convert a `u32` to an `i32` and panic if the converted value doesn't fit\n+   |\n+LL |     }.try_into().unwrap()\n+   |      ++++++++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:53:13\n    |\n LL | fn cat() -> impl std::fmt::Display {\n-   |             ---------------------- expected `_` because of return type\n+   |             ---------------------- expected `i32` because of return type\n ...\n LL |             1u32\n    |             ^^^^ expected `i32`, found `u32`\n+   |\n+help: you can convert a `u32` to an `i32` and panic if the converted value doesn't fit\n+   |\n+LL |     }.try_into().unwrap()\n+   |      ++++++++++++++++++++\n \n error[E0308]: `match` arms have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:61:14\n@@ -78,6 +113,11 @@ LL | |         1 => 1u32,\n LL | |         _ => 2u32,\n LL | |     }\n    | |_____- `match` arms have incompatible types\n+   |\n+help: change the type of the numeric literal from `u32` to `i32`\n+   |\n+LL |         1 => 1i32,\n+   |               ~~~\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:97:9\n@@ -90,6 +130,11 @@ LL | |         1u32\n    | |         ^^^^ expected `i32`, found `u32`\n LL | |     }\n    | |_____- `if` and `else` have incompatible types\n+   |\n+help: change the type of the numeric literal from `u32` to `i32`\n+   |\n+LL |         1i32\n+   |          ~~~\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:66:13\n@@ -125,6 +170,11 @@ LL | |         1 => 1u32,\n LL | |         _ => 2u32,\n LL | |     }\n    | |_____- `match` arms have incompatible types\n+   |\n+help: change the type of the numeric literal from `u32` to `i32`\n+   |\n+LL |         1 => 1i32,\n+   |               ~~~\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:77:13\n@@ -164,6 +214,11 @@ LL | |         1u32\n    | |         ^^^^ expected `i32`, found `u32`\n LL | |     }\n    | |_____- `if` and `else` have incompatible types\n+   |\n+help: change the type of the numeric literal from `u32` to `i32`\n+   |\n+LL |         1i32\n+   |          ~~~\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:85:13"}, {"sha": "f2ba610e2d1f62ac15c37ae854113949196d076f", "filename": "src/test/ui/mismatched_types/dont-point-return-on-E0308.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fmismatched_types%2Fdont-point-return-on-E0308.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fmismatched_types%2Fdont-point-return-on-E0308.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fdont-point-return-on-E0308.rs?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -0,0 +1,18 @@\n+// edition:2021\n+\n+async fn f(_: &()) {}\n+//~^ NOTE function defined here\n+//~| NOTE\n+// Second note is the span of the underlined argument, I think...\n+\n+fn main() {\n+    (|| async {\n+        Err::<(), ()>(())?;\n+        f(());\n+        //~^ ERROR mismatched types\n+        //~| NOTE arguments to this function are incorrect\n+        //~| NOTE expected `&()`, found `()`\n+        //~| HELP consider borrowing here\n+        Ok::<(), ()>(())\n+    })();\n+}"}, {"sha": "13942682d289c23842e4229ad77df791d3206917", "filename": "src/test/ui/mismatched_types/dont-point-return-on-E0308.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fmismatched_types%2Fdont-point-return-on-E0308.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fmismatched_types%2Fdont-point-return-on-E0308.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fdont-point-return-on-E0308.stderr?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -0,0 +1,19 @@\n+error[E0308]: mismatched types\n+  --> $DIR/dont-point-return-on-E0308.rs:11:11\n+   |\n+LL |         f(());\n+   |         - ^^\n+   |         | |\n+   |         | expected `&()`, found `()`\n+   |         | help: consider borrowing here: `&()`\n+   |         arguments to this function are incorrect\n+   |\n+note: function defined here\n+  --> $DIR/dont-point-return-on-E0308.rs:3:10\n+   |\n+LL | async fn f(_: &()) {}\n+   |          ^ ------\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "9157566e3a79bfa7e150a2ac1e88db723a39b2b3", "filename": "src/test/ui/mismatched_types/issue-84976.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-84976.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-84976.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-84976.stderr?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -3,6 +3,11 @@ error[E0308]: mismatched types\n    |\n LL |     length = { foo(&length) };\n    |                ^^^^^^^^^^^^ expected `u32`, found `i32`\n+   |\n+help: you can convert an `i32` to a `u32` and panic if the converted value doesn't fit\n+   |\n+LL |     length = { foo(&length).try_into().unwrap() };\n+   |                            ++++++++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/issue-84976.rs:17:14"}, {"sha": "f78f1d822bf608849b0343cfa8189c53ea035888", "filename": "src/test/ui/reify-intrinsic.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Freify-intrinsic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Freify-intrinsic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freify-intrinsic.stderr?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -23,6 +23,9 @@ LL |         std::intrinsics::unlikely,\n    |\n    = note: expected fn item `extern \"rust-intrinsic\" fn(_) -> _ {likely}`\n               found fn item `extern \"rust-intrinsic\" fn(_) -> _ {unlikely}`\n+   = note: different `fn` items always have unique types, even if their signatures are the same\n+   = help: change the expected type to be function pointer `extern \"rust-intrinsic\" fn(bool) -> bool`\n+   = help: if the expected type is due to type inference, cast the expected `fn` to a function pointer: `likely as extern \"rust-intrinsic\" fn(bool) -> bool`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "66886db6eb9465762b89014697cee1bafcd6cc95", "filename": "src/test/ui/type-alias-impl-trait/issue-74280.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc71eef498a24af884c4ffa288101a73447bfc61/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.stderr?ref=cc71eef498a24af884c4ffa288101a73447bfc61", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-74280.rs:9:5\n    |\n LL | fn test() -> Test {\n-   |              ---- expected `_` because of return type\n+   |              ---- expected `()` because of return type\n LL |     let y = || -> Test { () };\n LL |     7\n    |     ^ expected `()`, found integer"}]}