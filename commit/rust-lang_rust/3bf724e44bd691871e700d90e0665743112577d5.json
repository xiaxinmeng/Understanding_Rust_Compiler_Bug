{"sha": "3bf724e44bd691871e700d90e0665743112577d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiZjcyNGU0NGJkNjkxODcxZTcwMGQ5MGUwNjY1NzQzMTEyNTc3ZDU=", "commit": {"author": {"name": "Robert Gawdzik", "email": "rgawdzik@hotmail.com", "date": "2014-03-07T22:37:18Z"}, "committer": {"name": "Robert Gawdzik", "email": "rgawdzik@hotmail.com", "date": "2014-03-09T01:46:18Z"}, "message": "Refactored get_metadata_section to return a Result<T,~str>, added error messages. Closes #6615.", "tree": {"sha": "a8bf7946a362891ea1615d5d44214ebf4a3e1d4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8bf7946a362891ea1615d5d44214ebf4a3e1d4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bf724e44bd691871e700d90e0665743112577d5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bf724e44bd691871e700d90e0665743112577d5", "html_url": "https://github.com/rust-lang/rust/commit/3bf724e44bd691871e700d90e0665743112577d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bf724e44bd691871e700d90e0665743112577d5/comments", "author": null, "committer": null, "parents": [{"sha": "33768c46ec980a911284d77804e5e45ead6530eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/33768c46ec980a911284d77804e5e45ead6530eb", "html_url": "https://github.com/rust-lang/rust/commit/33768c46ec980a911284d77804e5e45ead6530eb"}], "stats": {"total": 45, "additions": 28, "deletions": 17}, "files": [{"sha": "60478f3543fcc7f844cbfdd96c96ee7006cdcc02", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3bf724e44bd691871e700d90e0665743112577d5/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf724e44bd691871e700d90e0665743112577d5/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=3bf724e44bd691871e700d90e0665743112577d5", "patch": "@@ -298,17 +298,17 @@ impl<'a> Context<'a> {\n \n         let lib = m.move_iter().next().unwrap();\n         if slot.is_none() {\n-            info!(\"{} reading meatadata from: {}\", flavor, lib.display());\n+            info!(\"{} reading metadata from: {}\", flavor, lib.display());\n             match get_metadata_section(self.os, &lib) {\n-                Some(blob) => {\n+                Ok(blob) => {\n                     if self.crate_matches(blob.as_slice()) {\n                         *slot = Some(blob);\n                     } else {\n                         info!(\"metadata mismatch\");\n                         return None;\n                     }\n                 }\n-                None => {\n+                Err(_) => {\n                     info!(\"no metadata found\");\n                     return None\n                 }\n@@ -387,15 +387,18 @@ impl ArchiveMetadata {\n }\n \n // Just a small wrapper to time how long reading metadata takes.\n-fn get_metadata_section(os: Os, filename: &Path) -> Option<MetadataBlob> {\n+fn get_metadata_section(os: Os, filename: &Path) -> Result<MetadataBlob, ~str> {\n     let start = time::precise_time_ns();\n     let ret = get_metadata_section_imp(os, filename);\n     info!(\"reading {} => {}ms\", filename.filename_display(),\n            (time::precise_time_ns() - start) / 1000000);\n     return ret;\n }\n \n-fn get_metadata_section_imp(os: Os, filename: &Path) -> Option<MetadataBlob> {\n+fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, ~str> {\n+    if !filename.exists() {\n+        return Err(format!(\"no such file: '{}'\", filename.display()));\n+    }\n     if filename.filename_str().unwrap().ends_with(\".rlib\") {\n         // Use ArchiveRO for speed here, it's backed by LLVM and uses mmap\n         // internally to read the file. We also avoid even using a memcpy by\n@@ -404,19 +407,26 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Option<MetadataBlob> {\n             Some(ar) => ar,\n             None => {\n                 debug!(\"llvm didn't like `{}`\", filename.display());\n-                return None;\n+                return Err(format!(\"failed to read rlib metadata: '{}'\",\n+                                   filename.display()));\n             }\n         };\n-        return ArchiveMetadata::new(archive).map(|ar| MetadataArchive(ar));\n+        return match ArchiveMetadata::new(archive).map(|ar| MetadataArchive(ar)) {\n+            None => return Err(format!(\"failed to read rlib metadata: '{}'\",\n+                                       filename.display())),\n+            Some(blob) => return Ok(blob)\n+        }\n     }\n     unsafe {\n         let mb = filename.with_c_str(|buf| {\n             llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n         });\n-        if mb as int == 0 { return None }\n+        if mb as int == 0 {\n+            return Err(format!(\"error reading library: '{}'\",filename.display()))\n+        }\n         let of = match ObjectFile::new(mb) {\n             Some(of) => of,\n-            _ => return None\n+            _ => return Err(format!(\"provided path not an object file: '{}'\", filename.display()))\n         };\n         let si = mk_section_iter(of.llof);\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n@@ -426,30 +436,31 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Option<MetadataBlob> {\n             if read_meta_section_name(os) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n-                let mut found = None;\n+                let mut found = Err(format!(\"metadata not found: '{}'\", filename.display()));\n                 let cvbuf: *u8 = cast::transmute(cbuf);\n                 let vlen = encoder::metadata_encoding_version.len();\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);\n                 let minsz = cmp::min(vlen, csz);\n                 let version_ok = vec::raw::buf_as_slice(cvbuf, minsz,\n                     |buf0| buf0 == encoder::metadata_encoding_version);\n-                if !version_ok { return None; }\n+                if !version_ok { return Err(format!(\"incompatible metadata version found: '{}'\",\n+                                                    filename.display()));}\n \n                 let cvbuf1 = cvbuf.offset(vlen as int);\n                 debug!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n                 vec::raw::buf_as_slice(cvbuf1, csz-vlen, |bytes| {\n                     let inflated = flate::inflate_bytes(bytes);\n-                    found = Some(MetadataVec(inflated));\n+                    found = Ok(MetadataVec(inflated));\n                 });\n-                if found.is_some() {\n+                if found.is_ok() {\n                     return found;\n                 }\n             }\n             llvm::LLVMMoveToNextSection(si.llsi);\n         }\n-        return None;\n+        return Err(format!(\"metadata not found: '{}'\", filename.display()));\n     }\n }\n \n@@ -477,9 +488,9 @@ pub fn read_meta_section_name(os: Os) -> &'static str {\n pub fn list_file_metadata(os: Os, path: &Path,\n                           out: &mut io::Writer) -> io::IoResult<()> {\n     match get_metadata_section(os, path) {\n-        Some(bytes) => decoder::list_crate_metadata(bytes.as_slice(), out),\n-        None => {\n-            write!(out, \"could not find metadata in {}.\\n\", path.display())\n+        Ok(bytes) => decoder::list_crate_metadata(bytes.as_slice(), out),\n+        Err(msg) => {\n+            write!(out, \"{}\\n\", msg)\n         }\n     }\n }"}]}