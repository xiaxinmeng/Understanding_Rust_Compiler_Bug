{"sha": "aeda30e301d74e40fc1eb992fad581afb627126f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlZGEzMGUzMDFkNzRlNDBmYzFlYjk5MmZhZDU4MWFmYjYyNzEyNmY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-11-13T15:44:48Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-11-13T15:44:48Z"}, "message": "Move tricky workspace logic to a separate module", "tree": {"sha": "0b3a116ab450e5a1eae24bde65ed683e75f9555a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b3a116ab450e5a1eae24bde65ed683e75f9555a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aeda30e301d74e40fc1eb992fad581afb627126f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aeda30e301d74e40fc1eb992fad581afb627126f", "html_url": "https://github.com/rust-lang/rust/commit/aeda30e301d74e40fc1eb992fad581afb627126f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aeda30e301d74e40fc1eb992fad581afb627126f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0f13d8cfa3a9d6d3968be1cc852eb3120c94653", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0f13d8cfa3a9d6d3968be1cc852eb3120c94653", "html_url": "https://github.com/rust-lang/rust/commit/f0f13d8cfa3a9d6d3968be1cc852eb3120c94653"}], "stats": {"total": 1213, "additions": 611, "deletions": 602}, "files": [{"sha": "24aa9b8fababab1a45f16d26d1be752cd1c5fca1", "filename": "crates/project_model/src/lib.rs", "status": "modified", "additions": 4, "deletions": 602, "changes": 606, "blob_url": "https://github.com/rust-lang/rust/blob/aeda30e301d74e40fc1eb992fad581afb627126f/crates%2Fproject_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda30e301d74e40fc1eb992fad581afb627126f/crates%2Fproject_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Flib.rs?ref=aeda30e301d74e40fc1eb992fad581afb627126f", "patch": "@@ -4,74 +4,27 @@ mod cargo_workspace;\n mod project_json;\n mod sysroot;\n mod cfg_flag;\n+mod workspace;\n \n use std::{\n-    fmt,\n-    fs::{self, read_dir, ReadDir},\n+    fs::{read_dir, ReadDir},\n     io,\n-    path::Component,\n     process::Command,\n };\n \n use anyhow::{bail, Context, Result};\n-use base_db::{CrateDisplayName, CrateGraph, CrateId, CrateName, Edition, Env, FileId};\n-use cfg::CfgOptions;\n use paths::{AbsPath, AbsPathBuf};\n-use rustc_hash::{FxHashMap, FxHashSet};\n-\n-use crate::cfg_flag::CfgFlag;\n+use rustc_hash::FxHashSet;\n \n pub use crate::{\n     cargo_workspace::{CargoConfig, CargoWorkspace, Package, Target, TargetKind},\n     project_json::{ProjectJson, ProjectJsonData},\n     sysroot::Sysroot,\n+    workspace::{PackageRoot, ProjectWorkspace},\n };\n \n pub use proc_macro_api::ProcMacroClient;\n \n-#[derive(Clone, Eq, PartialEq)]\n-pub enum ProjectWorkspace {\n-    /// Project workspace was discovered by running `cargo metadata` and `rustc --print sysroot`.\n-    Cargo { cargo: CargoWorkspace, sysroot: Sysroot, rustc: Option<CargoWorkspace> },\n-    /// Project workspace was manually specified using a `rust-project.json` file.\n-    Json { project: ProjectJson, sysroot: Option<Sysroot> },\n-}\n-\n-impl fmt::Debug for ProjectWorkspace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => f\n-                .debug_struct(\"Cargo\")\n-                .field(\"n_packages\", &cargo.packages().len())\n-                .field(\"n_sysroot_crates\", &sysroot.crates().len())\n-                .field(\n-                    \"n_rustc_compiler_crates\",\n-                    &rustc.as_ref().map_or(0, |rc| rc.packages().len()),\n-                )\n-                .finish(),\n-            ProjectWorkspace::Json { project, sysroot } => {\n-                let mut debug_struct = f.debug_struct(\"Json\");\n-                debug_struct.field(\"n_crates\", &project.n_crates());\n-                if let Some(sysroot) = sysroot {\n-                    debug_struct.field(\"n_sysroot_crates\", &sysroot.crates().len());\n-                }\n-                debug_struct.finish()\n-            }\n-        }\n-    }\n-}\n-\n-/// `PackageRoot` describes a package root folder.\n-/// Which may be an external dependency, or a member of\n-/// the current workspace.\n-#[derive(Debug, Clone, Eq, PartialEq, Hash)]\n-pub struct PackageRoot {\n-    /// Is a member of the current workspace\n-    pub is_member: bool,\n-    pub include: Vec<AbsPathBuf>,\n-    pub exclude: Vec<AbsPathBuf>,\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n pub enum ProjectManifest {\n     ProjectJson(AbsPathBuf),\n@@ -158,462 +111,6 @@ impl ProjectManifest {\n     }\n }\n \n-impl ProjectWorkspace {\n-    pub fn load(\n-        manifest: ProjectManifest,\n-        cargo_config: &CargoConfig,\n-        with_sysroot: bool,\n-    ) -> Result<ProjectWorkspace> {\n-        let res = match manifest {\n-            ProjectManifest::ProjectJson(project_json) => {\n-                let file = fs::read_to_string(&project_json).with_context(|| {\n-                    format!(\"Failed to read json file {}\", project_json.display())\n-                })?;\n-                let data = serde_json::from_str(&file).with_context(|| {\n-                    format!(\"Failed to deserialize json file {}\", project_json.display())\n-                })?;\n-                let project_location = project_json.parent().unwrap().to_path_buf();\n-                let project = ProjectJson::new(&project_location, data);\n-                let sysroot = match &project.sysroot_src {\n-                    Some(path) => Some(Sysroot::load(path)?),\n-                    None => None,\n-                };\n-                ProjectWorkspace::Json { project, sysroot }\n-            }\n-            ProjectManifest::CargoToml(cargo_toml) => {\n-                let cargo_version = utf8_stdout({\n-                    let mut cmd = Command::new(toolchain::cargo());\n-                    cmd.arg(\"--version\");\n-                    cmd\n-                })?;\n-\n-                let cargo = CargoWorkspace::from_cargo_metadata(&cargo_toml, cargo_config)\n-                    .with_context(|| {\n-                        format!(\n-                            \"Failed to read Cargo metadata from Cargo.toml file {}, {}\",\n-                            cargo_toml.display(),\n-                            cargo_version\n-                        )\n-                    })?;\n-                let sysroot = if with_sysroot {\n-                    Sysroot::discover(&cargo_toml).with_context(|| {\n-                        format!(\n-                            \"Failed to find sysroot for Cargo.toml file {}. Is rust-src installed?\",\n-                            cargo_toml.display()\n-                        )\n-                    })?\n-                } else {\n-                    Sysroot::default()\n-                };\n-\n-                let rustc = if let Some(rustc_dir) = &cargo_config.rustc_source {\n-                    Some(\n-                        CargoWorkspace::from_cargo_metadata(&rustc_dir, cargo_config)\n-                            .with_context(|| {\n-                                format!(\"Failed to read Cargo metadata for Rust sources\")\n-                            })?,\n-                    )\n-                } else {\n-                    None\n-                };\n-\n-                ProjectWorkspace::Cargo { cargo, sysroot, rustc }\n-            }\n-        };\n-\n-        Ok(res)\n-    }\n-\n-    pub fn load_inline(project_json: ProjectJson) -> Result<ProjectWorkspace> {\n-        let sysroot = match &project_json.sysroot_src {\n-            Some(path) => Some(Sysroot::load(path)?),\n-            None => None,\n-        };\n-\n-        Ok(ProjectWorkspace::Json { project: project_json, sysroot })\n-    }\n-\n-    /// Returns the roots for the current `ProjectWorkspace`\n-    /// The return type contains the path and whether or not\n-    /// the root is a member of the current workspace\n-    pub fn to_roots(&self) -> Vec<PackageRoot> {\n-        match self {\n-            ProjectWorkspace::Json { project, sysroot } => project\n-                .crates()\n-                .map(|(_, krate)| PackageRoot {\n-                    is_member: krate.is_workspace_member,\n-                    include: krate.include.clone(),\n-                    exclude: krate.exclude.clone(),\n-                })\n-                .collect::<FxHashSet<_>>()\n-                .into_iter()\n-                .chain(sysroot.as_ref().into_iter().flat_map(|sysroot| {\n-                    sysroot.crates().map(move |krate| PackageRoot {\n-                        is_member: false,\n-                        include: vec![sysroot[krate].root_dir().to_path_buf()],\n-                        exclude: Vec::new(),\n-                    })\n-                }))\n-                .collect::<Vec<_>>(),\n-            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n-                let roots = cargo\n-                    .packages()\n-                    .map(|pkg| {\n-                        let is_member = cargo[pkg].is_member;\n-                        let pkg_root = cargo[pkg].root().to_path_buf();\n-\n-                        let mut include = vec![pkg_root.clone()];\n-                        include.extend(cargo[pkg].out_dir.clone());\n-\n-                        let mut exclude = vec![pkg_root.join(\".git\")];\n-                        if is_member {\n-                            exclude.push(pkg_root.join(\"target\"));\n-                        } else {\n-                            exclude.push(pkg_root.join(\"tests\"));\n-                            exclude.push(pkg_root.join(\"examples\"));\n-                            exclude.push(pkg_root.join(\"benches\"));\n-                        }\n-                        PackageRoot { is_member, include, exclude }\n-                    })\n-                    .chain(sysroot.crates().map(|krate| PackageRoot {\n-                        is_member: false,\n-                        include: vec![sysroot[krate].root_dir().to_path_buf()],\n-                        exclude: Vec::new(),\n-                    }));\n-                if let Some(rustc_packages) = rustc {\n-                    roots\n-                        .chain(rustc_packages.packages().map(|krate| PackageRoot {\n-                            is_member: false,\n-                            include: vec![rustc_packages[krate].root().to_path_buf()],\n-                            exclude: Vec::new(),\n-                        }))\n-                        .collect()\n-                } else {\n-                    roots.collect()\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn proc_macro_dylib_paths(&self) -> Vec<AbsPathBuf> {\n-        match self {\n-            ProjectWorkspace::Json { project, sysroot: _ } => project\n-                .crates()\n-                .filter_map(|(_, krate)| krate.proc_macro_dylib_path.as_ref())\n-                .cloned()\n-                .collect(),\n-            ProjectWorkspace::Cargo { cargo, sysroot: _sysroot, rustc: _rustc_crates } => cargo\n-                .packages()\n-                .filter_map(|pkg| cargo[pkg].proc_macro_dylib_path.as_ref())\n-                .cloned()\n-                .collect(),\n-        }\n-    }\n-\n-    pub fn n_packages(&self) -> usize {\n-        match self {\n-            ProjectWorkspace::Json { project, .. } => project.n_crates(),\n-            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n-                let rustc_package_len = rustc.as_ref().map_or(0, |rc| rc.packages().len());\n-                cargo.packages().len() + sysroot.crates().len() + rustc_package_len\n-            }\n-        }\n-    }\n-\n-    pub fn to_crate_graph(\n-        &self,\n-        target: Option<&str>,\n-        proc_macro_client: &ProcMacroClient,\n-        load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-    ) -> CrateGraph {\n-        let mut crate_graph = CrateGraph::default();\n-        match self {\n-            ProjectWorkspace::Json { project, sysroot } => {\n-                let sysroot_dps = sysroot\n-                    .as_ref()\n-                    .map(|sysroot| sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load));\n-\n-                let mut cfg_cache: FxHashMap<Option<&str>, Vec<CfgFlag>> = FxHashMap::default();\n-                let crates: FxHashMap<_, _> = project\n-                    .crates()\n-                    .filter_map(|(crate_id, krate)| {\n-                        let file_path = &krate.root_module;\n-                        let file_id = match load(&file_path) {\n-                            Some(id) => id,\n-                            None => {\n-                                log::error!(\"failed to load crate root {}\", file_path.display());\n-                                return None;\n-                            }\n-                        };\n-\n-                        let env = krate.env.clone().into_iter().collect();\n-                        let proc_macro = krate\n-                            .proc_macro_dylib_path\n-                            .clone()\n-                            .map(|it| proc_macro_client.by_dylib_path(&it));\n-\n-                        let target = krate.target.as_deref().or(target);\n-                        let target_cfgs = cfg_cache\n-                            .entry(target)\n-                            .or_insert_with(|| get_rustc_cfg_options(target));\n-\n-                        let mut cfg_options = CfgOptions::default();\n-                        cfg_options.extend(target_cfgs.iter().chain(krate.cfg.iter()).cloned());\n-\n-                        Some((\n-                            crate_id,\n-                            crate_graph.add_crate_root(\n-                                file_id,\n-                                krate.edition,\n-                                krate.display_name.clone(),\n-                                cfg_options,\n-                                env,\n-                                proc_macro.unwrap_or_default(),\n-                            ),\n-                        ))\n-                    })\n-                    .collect();\n-\n-                for (from, krate) in project.crates() {\n-                    if let Some(&from) = crates.get(&from) {\n-                        if let Some((public_deps, _proc_macro)) = &sysroot_dps {\n-                            for (name, to) in public_deps.iter() {\n-                                if let Err(_) = crate_graph.add_dep(from, name.clone(), *to) {\n-                                    log::error!(\"cyclic dependency on {} for {:?}\", name, from)\n-                                }\n-                            }\n-                        }\n-\n-                        for dep in &krate.deps {\n-                            let to_crate_id = dep.crate_id;\n-                            if let Some(&to) = crates.get(&to_crate_id) {\n-                                if let Err(_) = crate_graph.add_dep(from, dep.name.clone(), to) {\n-                                    log::error!(\"cyclic dependency {:?} -> {:?}\", from, to);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n-                let (public_deps, libproc_macro) =\n-                    sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load);\n-\n-                let mut cfg_options = CfgOptions::default();\n-                cfg_options.extend(get_rustc_cfg_options(target));\n-\n-                let mut pkg_to_lib_crate = FxHashMap::default();\n-\n-                // Add test cfg for non-sysroot crates\n-                cfg_options.insert_atom(\"test\".into());\n-                cfg_options.insert_atom(\"debug_assertions\".into());\n-\n-                let mut pkg_crates = FxHashMap::default();\n-\n-                // Next, create crates for each package, target pair\n-                for pkg in cargo.packages() {\n-                    let mut lib_tgt = None;\n-                    for &tgt in cargo[pkg].targets.iter() {\n-                        if let Some(crate_id) = add_target_crate_root(\n-                            &mut crate_graph,\n-                            &cargo[pkg],\n-                            &cargo[tgt],\n-                            &cfg_options,\n-                            proc_macro_client,\n-                            load,\n-                        ) {\n-                            if cargo[tgt].kind == TargetKind::Lib {\n-                                lib_tgt = Some((crate_id, cargo[tgt].name.clone()));\n-                                pkg_to_lib_crate.insert(pkg, crate_id);\n-                            }\n-                            if cargo[tgt].is_proc_macro {\n-                                if let Some(proc_macro) = libproc_macro {\n-                                    if let Err(_) = crate_graph.add_dep(\n-                                        crate_id,\n-                                        CrateName::new(\"proc_macro\").unwrap(),\n-                                        proc_macro,\n-                                    ) {\n-                                        log::error!(\n-                                            \"cyclic dependency on proc_macro for {}\",\n-                                            &cargo[pkg].name\n-                                        )\n-                                    }\n-                                }\n-                            }\n-\n-                            pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n-                        }\n-                    }\n-\n-                    // Set deps to the core, std and to the lib target of the current package\n-                    for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                        if let Some((to, name)) = lib_tgt.clone() {\n-                            // For root projects with dashes in their name,\n-                            // cargo metadata does not do any normalization,\n-                            // so we do it ourselves currently\n-                            let name = CrateName::normalize_dashes(&name);\n-                            if to != from && crate_graph.add_dep(from, name, to).is_err() {\n-                                log::error!(\n-                                    \"cyclic dependency between targets of {}\",\n-                                    &cargo[pkg].name\n-                                )\n-                            }\n-                        }\n-                        for (name, krate) in public_deps.iter() {\n-                            if let Err(_) = crate_graph.add_dep(from, name.clone(), *krate) {\n-                                log::error!(\n-                                    \"cyclic dependency on {} for {}\",\n-                                    name,\n-                                    &cargo[pkg].name\n-                                )\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // Now add a dep edge from all targets of upstream to the lib\n-                // target of downstream.\n-                for pkg in cargo.packages() {\n-                    for dep in cargo[pkg].dependencies.iter() {\n-                        let name = CrateName::new(&dep.name).unwrap();\n-                        if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n-                            for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                                if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n-                                    log::error!(\n-                                        \"cyclic dependency {} -> {}\",\n-                                        &cargo[pkg].name,\n-                                        &cargo[dep.pkg].name\n-                                    )\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                let mut rustc_pkg_crates = FxHashMap::default();\n-\n-                // If the user provided a path to rustc sources, we add all the rustc_private crates\n-                // and create dependencies on them for the crates in the current workspace\n-                if let Some(rustc_workspace) = rustc {\n-                    for pkg in rustc_workspace.packages() {\n-                        for &tgt in rustc_workspace[pkg].targets.iter() {\n-                            if rustc_workspace[tgt].kind != TargetKind::Lib {\n-                                continue;\n-                            }\n-                            // Exclude alloc / core / std\n-                            if rustc_workspace[tgt]\n-                                .root\n-                                .components()\n-                                .any(|c| c == Component::Normal(\"library\".as_ref()))\n-                            {\n-                                continue;\n-                            }\n-\n-                            if let Some(crate_id) = add_target_crate_root(\n-                                &mut crate_graph,\n-                                &rustc_workspace[pkg],\n-                                &rustc_workspace[tgt],\n-                                &cfg_options,\n-                                proc_macro_client,\n-                                load,\n-                            ) {\n-                                pkg_to_lib_crate.insert(pkg, crate_id);\n-                                // Add dependencies on the core / std / alloc for rustc\n-                                for (name, krate) in public_deps.iter() {\n-                                    if let Err(_) =\n-                                        crate_graph.add_dep(crate_id, name.clone(), *krate)\n-                                    {\n-                                        log::error!(\n-                                            \"cyclic dependency on {} for {}\",\n-                                            name,\n-                                            &cargo[pkg].name\n-                                        )\n-                                    }\n-                                }\n-                                rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n-                            }\n-                        }\n-                    }\n-                    // Now add a dep edge from all targets of upstream to the lib\n-                    // target of downstream.\n-                    for pkg in rustc_workspace.packages() {\n-                        for dep in rustc_workspace[pkg].dependencies.iter() {\n-                            let name = CrateName::new(&dep.name).unwrap();\n-                            if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n-                                for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n-                                    if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n-                                        log::error!(\n-                                            \"cyclic dependency {} -> {}\",\n-                                            &rustc_workspace[pkg].name,\n-                                            &rustc_workspace[dep.pkg].name\n-                                        )\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    // Add dependencies for all the crates of the current workspace to rustc_private libraries\n-                    for dep in rustc_workspace.packages() {\n-                        let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n-\n-                        if let Some(&to) = pkg_to_lib_crate.get(&dep) {\n-                            for pkg in cargo.packages() {\n-                                if !cargo[pkg].is_member {\n-                                    continue;\n-                                }\n-                                for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                                    if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n-                                        log::error!(\n-                                            \"cyclic dependency {} -> {}\",\n-                                            &cargo[pkg].name,\n-                                            &rustc_workspace[dep].name\n-                                        )\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        if crate_graph.patch_cfg_if() {\n-            log::debug!(\"Patched std to depend on cfg-if\")\n-        } else {\n-            log::debug!(\"Did not patch std to depend on cfg-if\")\n-        }\n-        crate_graph\n-    }\n-}\n-\n-fn get_rustc_cfg_options(target: Option<&str>) -> Vec<CfgFlag> {\n-    let mut res = Vec::new();\n-\n-    // Some nightly-only cfgs, which are required for stdlib\n-    res.push(CfgFlag::Atom(\"target_thread_local\".into()));\n-    for &ty in [\"8\", \"16\", \"32\", \"64\", \"cas\", \"ptr\"].iter() {\n-        for &key in [\"target_has_atomic\", \"target_has_atomic_load_store\"].iter() {\n-            res.push(CfgFlag::KeyValue { key: key.to_string(), value: ty.into() });\n-        }\n-    }\n-\n-    let rustc_cfgs = {\n-        let mut cmd = Command::new(toolchain::rustc());\n-        cmd.args(&[\"--print\", \"cfg\", \"-O\"]);\n-        if let Some(target) = target {\n-            cmd.args(&[\"--target\", target]);\n-        }\n-        utf8_stdout(cmd)\n-    };\n-\n-    match rustc_cfgs {\n-        Ok(rustc_cfgs) => res.extend(rustc_cfgs.lines().map(|it| it.parse().unwrap())),\n-        Err(e) => log::error!(\"failed to get rustc cfgs: {:#}\", e),\n-    }\n-\n-    res\n-}\n-\n fn utf8_stdout(mut cmd: Command) -> Result<String> {\n     let output = cmd.output().with_context(|| format!(\"{:?} failed\", cmd))?;\n     if !output.status.success() {\n@@ -627,98 +124,3 @@ fn utf8_stdout(mut cmd: Command) -> Result<String> {\n     let stdout = String::from_utf8(output.stdout)?;\n     Ok(stdout.trim().to_string())\n }\n-\n-fn add_target_crate_root(\n-    crate_graph: &mut CrateGraph,\n-    pkg: &cargo_workspace::PackageData,\n-    tgt: &cargo_workspace::TargetData,\n-    cfg_options: &CfgOptions,\n-    proc_macro_client: &ProcMacroClient,\n-    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-) -> Option<CrateId> {\n-    let root = tgt.root.as_path();\n-    if let Some(file_id) = load(root) {\n-        let edition = pkg.edition;\n-        let cfg_options = {\n-            let mut opts = cfg_options.clone();\n-            for feature in pkg.features.iter() {\n-                opts.insert_key_value(\"feature\".into(), feature.into());\n-            }\n-            opts.extend(pkg.cfgs.iter().cloned());\n-            opts\n-        };\n-        let mut env = Env::default();\n-        if let Some(out_dir) = &pkg.out_dir {\n-            // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n-            if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n-                env.set(\"OUT_DIR\", out_dir);\n-            }\n-        }\n-        let proc_macro = pkg\n-            .proc_macro_dylib_path\n-            .as_ref()\n-            .map(|it| proc_macro_client.by_dylib_path(&it))\n-            .unwrap_or_default();\n-\n-        let display_name = CrateDisplayName::from_canonical_name(pkg.name.clone());\n-        let crate_id = crate_graph.add_crate_root(\n-            file_id,\n-            edition,\n-            Some(display_name),\n-            cfg_options,\n-            env,\n-            proc_macro.clone(),\n-        );\n-\n-        return Some(crate_id);\n-    }\n-    None\n-}\n-fn sysroot_to_crate_graph(\n-    crate_graph: &mut CrateGraph,\n-    sysroot: &Sysroot,\n-    target: Option<&str>,\n-    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-) -> (Vec<(CrateName, CrateId)>, Option<CrateId>) {\n-    let mut cfg_options = CfgOptions::default();\n-    cfg_options.extend(get_rustc_cfg_options(target));\n-    let sysroot_crates: FxHashMap<_, _> = sysroot\n-        .crates()\n-        .filter_map(|krate| {\n-            let file_id = load(&sysroot[krate].root)?;\n-\n-            let env = Env::default();\n-            let proc_macro = vec![];\n-            let name = CrateName::new(&sysroot[krate].name)\n-                .expect(\"Sysroot crates' names do not contain dashes\");\n-            let crate_id = crate_graph.add_crate_root(\n-                file_id,\n-                Edition::Edition2018,\n-                Some(name.into()),\n-                cfg_options.clone(),\n-                env,\n-                proc_macro,\n-            );\n-            Some((krate, crate_id))\n-        })\n-        .collect();\n-\n-    for from in sysroot.crates() {\n-        for &to in sysroot[from].deps.iter() {\n-            let name = CrateName::new(&sysroot[to].name).unwrap();\n-            if let (Some(&from), Some(&to)) = (sysroot_crates.get(&from), sysroot_crates.get(&to)) {\n-                if let Err(_) = crate_graph.add_dep(from, name, to) {\n-                    log::error!(\"cyclic dependency between sysroot crates\")\n-                }\n-            }\n-        }\n-    }\n-\n-    let public_deps = sysroot\n-        .public_deps()\n-        .map(|(name, idx)| (CrateName::new(name).unwrap(), sysroot_crates[&idx]))\n-        .collect::<Vec<_>>();\n-\n-    let libproc_macro = sysroot.proc_macro().and_then(|it| sysroot_crates.get(&it).copied());\n-    (public_deps, libproc_macro)\n-}"}, {"sha": "43ea351d184348898b1a18b4041dd38668b896ca", "filename": "crates/project_model/src/workspace.rs", "status": "added", "additions": 607, "deletions": 0, "changes": 607, "blob_url": "https://github.com/rust-lang/rust/blob/aeda30e301d74e40fc1eb992fad581afb627126f/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda30e301d74e40fc1eb992fad581afb627126f/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fworkspace.rs?ref=aeda30e301d74e40fc1eb992fad581afb627126f", "patch": "@@ -0,0 +1,607 @@\n+use std::{fmt, fs, path::Component, process::Command};\n+\n+use anyhow::{Context, Result};\n+use base_db::{CrateDisplayName, CrateGraph, CrateId, CrateName, Edition, Env, FileId};\n+use cfg::CfgOptions;\n+use paths::{AbsPath, AbsPathBuf};\n+use proc_macro_api::ProcMacroClient;\n+use rustc_hash::{FxHashMap, FxHashSet};\n+\n+use crate::{\n+    cargo_workspace, cfg_flag::CfgFlag, utf8_stdout, CargoConfig, CargoWorkspace, ProjectJson,\n+    ProjectManifest, Sysroot, TargetKind,\n+};\n+\n+/// `PackageRoot` describes a package root folder.\n+/// Which may be an external dependency, or a member of\n+/// the current workspace.\n+#[derive(Debug, Clone, Eq, PartialEq, Hash)]\n+pub struct PackageRoot {\n+    /// Is a member of the current workspace\n+    pub is_member: bool,\n+    pub include: Vec<AbsPathBuf>,\n+    pub exclude: Vec<AbsPathBuf>,\n+}\n+\n+#[derive(Clone, Eq, PartialEq)]\n+pub enum ProjectWorkspace {\n+    /// Project workspace was discovered by running `cargo metadata` and `rustc --print sysroot`.\n+    Cargo { cargo: CargoWorkspace, sysroot: Sysroot, rustc: Option<CargoWorkspace> },\n+    /// Project workspace was manually specified using a `rust-project.json` file.\n+    Json { project: ProjectJson, sysroot: Option<Sysroot> },\n+}\n+\n+impl fmt::Debug for ProjectWorkspace {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => f\n+                .debug_struct(\"Cargo\")\n+                .field(\"n_packages\", &cargo.packages().len())\n+                .field(\"n_sysroot_crates\", &sysroot.crates().len())\n+                .field(\n+                    \"n_rustc_compiler_crates\",\n+                    &rustc.as_ref().map_or(0, |rc| rc.packages().len()),\n+                )\n+                .finish(),\n+            ProjectWorkspace::Json { project, sysroot } => {\n+                let mut debug_struct = f.debug_struct(\"Json\");\n+                debug_struct.field(\"n_crates\", &project.n_crates());\n+                if let Some(sysroot) = sysroot {\n+                    debug_struct.field(\"n_sysroot_crates\", &sysroot.crates().len());\n+                }\n+                debug_struct.finish()\n+            }\n+        }\n+    }\n+}\n+\n+impl ProjectWorkspace {\n+    pub fn load(\n+        manifest: ProjectManifest,\n+        cargo_config: &CargoConfig,\n+        with_sysroot: bool,\n+    ) -> Result<ProjectWorkspace> {\n+        let res = match manifest {\n+            ProjectManifest::ProjectJson(project_json) => {\n+                let file = fs::read_to_string(&project_json).with_context(|| {\n+                    format!(\"Failed to read json file {}\", project_json.display())\n+                })?;\n+                let data = serde_json::from_str(&file).with_context(|| {\n+                    format!(\"Failed to deserialize json file {}\", project_json.display())\n+                })?;\n+                let project_location = project_json.parent().unwrap().to_path_buf();\n+                let project = ProjectJson::new(&project_location, data);\n+                let sysroot = match &project.sysroot_src {\n+                    Some(path) => Some(Sysroot::load(path)?),\n+                    None => None,\n+                };\n+                ProjectWorkspace::Json { project, sysroot }\n+            }\n+            ProjectManifest::CargoToml(cargo_toml) => {\n+                let cargo_version = utf8_stdout({\n+                    let mut cmd = Command::new(toolchain::cargo());\n+                    cmd.arg(\"--version\");\n+                    cmd\n+                })?;\n+\n+                let cargo = CargoWorkspace::from_cargo_metadata(&cargo_toml, cargo_config)\n+                    .with_context(|| {\n+                        format!(\n+                            \"Failed to read Cargo metadata from Cargo.toml file {}, {}\",\n+                            cargo_toml.display(),\n+                            cargo_version\n+                        )\n+                    })?;\n+                let sysroot = if with_sysroot {\n+                    Sysroot::discover(&cargo_toml).with_context(|| {\n+                        format!(\n+                            \"Failed to find sysroot for Cargo.toml file {}. Is rust-src installed?\",\n+                            cargo_toml.display()\n+                        )\n+                    })?\n+                } else {\n+                    Sysroot::default()\n+                };\n+\n+                let rustc = if let Some(rustc_dir) = &cargo_config.rustc_source {\n+                    Some(\n+                        CargoWorkspace::from_cargo_metadata(&rustc_dir, cargo_config)\n+                            .with_context(|| {\n+                                format!(\"Failed to read Cargo metadata for Rust sources\")\n+                            })?,\n+                    )\n+                } else {\n+                    None\n+                };\n+\n+                ProjectWorkspace::Cargo { cargo, sysroot, rustc }\n+            }\n+        };\n+\n+        Ok(res)\n+    }\n+\n+    pub fn load_inline(project_json: ProjectJson) -> Result<ProjectWorkspace> {\n+        let sysroot = match &project_json.sysroot_src {\n+            Some(path) => Some(Sysroot::load(path)?),\n+            None => None,\n+        };\n+\n+        Ok(ProjectWorkspace::Json { project: project_json, sysroot })\n+    }\n+\n+    /// Returns the roots for the current `ProjectWorkspace`\n+    /// The return type contains the path and whether or not\n+    /// the root is a member of the current workspace\n+    pub fn to_roots(&self) -> Vec<PackageRoot> {\n+        match self {\n+            ProjectWorkspace::Json { project, sysroot } => project\n+                .crates()\n+                .map(|(_, krate)| PackageRoot {\n+                    is_member: krate.is_workspace_member,\n+                    include: krate.include.clone(),\n+                    exclude: krate.exclude.clone(),\n+                })\n+                .collect::<FxHashSet<_>>()\n+                .into_iter()\n+                .chain(sysroot.as_ref().into_iter().flat_map(|sysroot| {\n+                    sysroot.crates().map(move |krate| PackageRoot {\n+                        is_member: false,\n+                        include: vec![sysroot[krate].root_dir().to_path_buf()],\n+                        exclude: Vec::new(),\n+                    })\n+                }))\n+                .collect::<Vec<_>>(),\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n+                let roots = cargo\n+                    .packages()\n+                    .map(|pkg| {\n+                        let is_member = cargo[pkg].is_member;\n+                        let pkg_root = cargo[pkg].root().to_path_buf();\n+\n+                        let mut include = vec![pkg_root.clone()];\n+                        include.extend(cargo[pkg].out_dir.clone());\n+\n+                        let mut exclude = vec![pkg_root.join(\".git\")];\n+                        if is_member {\n+                            exclude.push(pkg_root.join(\"target\"));\n+                        } else {\n+                            exclude.push(pkg_root.join(\"tests\"));\n+                            exclude.push(pkg_root.join(\"examples\"));\n+                            exclude.push(pkg_root.join(\"benches\"));\n+                        }\n+                        PackageRoot { is_member, include, exclude }\n+                    })\n+                    .chain(sysroot.crates().map(|krate| PackageRoot {\n+                        is_member: false,\n+                        include: vec![sysroot[krate].root_dir().to_path_buf()],\n+                        exclude: Vec::new(),\n+                    }));\n+                if let Some(rustc_packages) = rustc {\n+                    roots\n+                        .chain(rustc_packages.packages().map(|krate| PackageRoot {\n+                            is_member: false,\n+                            include: vec![rustc_packages[krate].root().to_path_buf()],\n+                            exclude: Vec::new(),\n+                        }))\n+                        .collect()\n+                } else {\n+                    roots.collect()\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn proc_macro_dylib_paths(&self) -> Vec<AbsPathBuf> {\n+        match self {\n+            ProjectWorkspace::Json { project, sysroot: _ } => project\n+                .crates()\n+                .filter_map(|(_, krate)| krate.proc_macro_dylib_path.as_ref())\n+                .cloned()\n+                .collect(),\n+            ProjectWorkspace::Cargo { cargo, sysroot: _sysroot, rustc: _rustc_crates } => cargo\n+                .packages()\n+                .filter_map(|pkg| cargo[pkg].proc_macro_dylib_path.as_ref())\n+                .cloned()\n+                .collect(),\n+        }\n+    }\n+\n+    pub fn n_packages(&self) -> usize {\n+        match self {\n+            ProjectWorkspace::Json { project, .. } => project.n_crates(),\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n+                let rustc_package_len = rustc.as_ref().map_or(0, |rc| rc.packages().len());\n+                cargo.packages().len() + sysroot.crates().len() + rustc_package_len\n+            }\n+        }\n+    }\n+\n+    pub fn to_crate_graph(\n+        &self,\n+        target: Option<&str>,\n+        proc_macro_client: &ProcMacroClient,\n+        load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+    ) -> CrateGraph {\n+        let mut crate_graph = CrateGraph::default();\n+        match self {\n+            ProjectWorkspace::Json { project, sysroot } => {\n+                let sysroot_dps = sysroot\n+                    .as_ref()\n+                    .map(|sysroot| sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load));\n+\n+                let mut cfg_cache: FxHashMap<Option<&str>, Vec<CfgFlag>> = FxHashMap::default();\n+                let crates: FxHashMap<_, _> = project\n+                    .crates()\n+                    .filter_map(|(crate_id, krate)| {\n+                        let file_path = &krate.root_module;\n+                        let file_id = match load(&file_path) {\n+                            Some(id) => id,\n+                            None => {\n+                                log::error!(\"failed to load crate root {}\", file_path.display());\n+                                return None;\n+                            }\n+                        };\n+\n+                        let env = krate.env.clone().into_iter().collect();\n+                        let proc_macro = krate\n+                            .proc_macro_dylib_path\n+                            .clone()\n+                            .map(|it| proc_macro_client.by_dylib_path(&it));\n+\n+                        let target = krate.target.as_deref().or(target);\n+                        let target_cfgs = cfg_cache\n+                            .entry(target)\n+                            .or_insert_with(|| get_rustc_cfg_options(target));\n+\n+                        let mut cfg_options = CfgOptions::default();\n+                        cfg_options.extend(target_cfgs.iter().chain(krate.cfg.iter()).cloned());\n+\n+                        Some((\n+                            crate_id,\n+                            crate_graph.add_crate_root(\n+                                file_id,\n+                                krate.edition,\n+                                krate.display_name.clone(),\n+                                cfg_options,\n+                                env,\n+                                proc_macro.unwrap_or_default(),\n+                            ),\n+                        ))\n+                    })\n+                    .collect();\n+\n+                for (from, krate) in project.crates() {\n+                    if let Some(&from) = crates.get(&from) {\n+                        if let Some((public_deps, _proc_macro)) = &sysroot_dps {\n+                            for (name, to) in public_deps.iter() {\n+                                if let Err(_) = crate_graph.add_dep(from, name.clone(), *to) {\n+                                    log::error!(\"cyclic dependency on {} for {:?}\", name, from)\n+                                }\n+                            }\n+                        }\n+\n+                        for dep in &krate.deps {\n+                            let to_crate_id = dep.crate_id;\n+                            if let Some(&to) = crates.get(&to_crate_id) {\n+                                if let Err(_) = crate_graph.add_dep(from, dep.name.clone(), to) {\n+                                    log::error!(\"cyclic dependency {:?} -> {:?}\", from, to);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n+                let (public_deps, libproc_macro) =\n+                    sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load);\n+\n+                let mut cfg_options = CfgOptions::default();\n+                cfg_options.extend(get_rustc_cfg_options(target));\n+\n+                let mut pkg_to_lib_crate = FxHashMap::default();\n+\n+                // Add test cfg for non-sysroot crates\n+                cfg_options.insert_atom(\"test\".into());\n+                cfg_options.insert_atom(\"debug_assertions\".into());\n+\n+                let mut pkg_crates = FxHashMap::default();\n+\n+                // Next, create crates for each package, target pair\n+                for pkg in cargo.packages() {\n+                    let mut lib_tgt = None;\n+                    for &tgt in cargo[pkg].targets.iter() {\n+                        if let Some(crate_id) = add_target_crate_root(\n+                            &mut crate_graph,\n+                            &cargo[pkg],\n+                            &cargo[tgt],\n+                            &cfg_options,\n+                            proc_macro_client,\n+                            load,\n+                        ) {\n+                            if cargo[tgt].kind == TargetKind::Lib {\n+                                lib_tgt = Some((crate_id, cargo[tgt].name.clone()));\n+                                pkg_to_lib_crate.insert(pkg, crate_id);\n+                            }\n+                            if cargo[tgt].is_proc_macro {\n+                                if let Some(proc_macro) = libproc_macro {\n+                                    if let Err(_) = crate_graph.add_dep(\n+                                        crate_id,\n+                                        CrateName::new(\"proc_macro\").unwrap(),\n+                                        proc_macro,\n+                                    ) {\n+                                        log::error!(\n+                                            \"cyclic dependency on proc_macro for {}\",\n+                                            &cargo[pkg].name\n+                                        )\n+                                    }\n+                                }\n+                            }\n+\n+                            pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n+                        }\n+                    }\n+\n+                    // Set deps to the core, std and to the lib target of the current package\n+                    for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                        if let Some((to, name)) = lib_tgt.clone() {\n+                            // For root projects with dashes in their name,\n+                            // cargo metadata does not do any normalization,\n+                            // so we do it ourselves currently\n+                            let name = CrateName::normalize_dashes(&name);\n+                            if to != from && crate_graph.add_dep(from, name, to).is_err() {\n+                                log::error!(\n+                                    \"cyclic dependency between targets of {}\",\n+                                    &cargo[pkg].name\n+                                )\n+                            }\n+                        }\n+                        for (name, krate) in public_deps.iter() {\n+                            if let Err(_) = crate_graph.add_dep(from, name.clone(), *krate) {\n+                                log::error!(\n+                                    \"cyclic dependency on {} for {}\",\n+                                    name,\n+                                    &cargo[pkg].name\n+                                )\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // Now add a dep edge from all targets of upstream to the lib\n+                // target of downstream.\n+                for pkg in cargo.packages() {\n+                    for dep in cargo[pkg].dependencies.iter() {\n+                        let name = CrateName::new(&dep.name).unwrap();\n+                        if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                            for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                                if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n+                                    log::error!(\n+                                        \"cyclic dependency {} -> {}\",\n+                                        &cargo[pkg].name,\n+                                        &cargo[dep.pkg].name\n+                                    )\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                let mut rustc_pkg_crates = FxHashMap::default();\n+\n+                // If the user provided a path to rustc sources, we add all the rustc_private crates\n+                // and create dependencies on them for the crates in the current workspace\n+                if let Some(rustc_workspace) = rustc {\n+                    for pkg in rustc_workspace.packages() {\n+                        for &tgt in rustc_workspace[pkg].targets.iter() {\n+                            if rustc_workspace[tgt].kind != TargetKind::Lib {\n+                                continue;\n+                            }\n+                            // Exclude alloc / core / std\n+                            if rustc_workspace[tgt]\n+                                .root\n+                                .components()\n+                                .any(|c| c == Component::Normal(\"library\".as_ref()))\n+                            {\n+                                continue;\n+                            }\n+\n+                            if let Some(crate_id) = add_target_crate_root(\n+                                &mut crate_graph,\n+                                &rustc_workspace[pkg],\n+                                &rustc_workspace[tgt],\n+                                &cfg_options,\n+                                proc_macro_client,\n+                                load,\n+                            ) {\n+                                pkg_to_lib_crate.insert(pkg, crate_id);\n+                                // Add dependencies on the core / std / alloc for rustc\n+                                for (name, krate) in public_deps.iter() {\n+                                    if let Err(_) =\n+                                        crate_graph.add_dep(crate_id, name.clone(), *krate)\n+                                    {\n+                                        log::error!(\n+                                            \"cyclic dependency on {} for {}\",\n+                                            name,\n+                                            &cargo[pkg].name\n+                                        )\n+                                    }\n+                                }\n+                                rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n+                            }\n+                        }\n+                    }\n+                    // Now add a dep edge from all targets of upstream to the lib\n+                    // target of downstream.\n+                    for pkg in rustc_workspace.packages() {\n+                        for dep in rustc_workspace[pkg].dependencies.iter() {\n+                            let name = CrateName::new(&dep.name).unwrap();\n+                            if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                                for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n+                                    if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n+                                        log::error!(\n+                                            \"cyclic dependency {} -> {}\",\n+                                            &rustc_workspace[pkg].name,\n+                                            &rustc_workspace[dep.pkg].name\n+                                        )\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    // Add dependencies for all the crates of the current workspace to rustc_private libraries\n+                    for dep in rustc_workspace.packages() {\n+                        let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n+\n+                        if let Some(&to) = pkg_to_lib_crate.get(&dep) {\n+                            for pkg in cargo.packages() {\n+                                if !cargo[pkg].is_member {\n+                                    continue;\n+                                }\n+                                for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                                    if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n+                                        log::error!(\n+                                            \"cyclic dependency {} -> {}\",\n+                                            &cargo[pkg].name,\n+                                            &rustc_workspace[dep].name\n+                                        )\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if crate_graph.patch_cfg_if() {\n+            log::debug!(\"Patched std to depend on cfg-if\")\n+        } else {\n+            log::debug!(\"Did not patch std to depend on cfg-if\")\n+        }\n+        crate_graph\n+    }\n+}\n+\n+fn add_target_crate_root(\n+    crate_graph: &mut CrateGraph,\n+    pkg: &cargo_workspace::PackageData,\n+    tgt: &cargo_workspace::TargetData,\n+    cfg_options: &CfgOptions,\n+    proc_macro_client: &ProcMacroClient,\n+    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+) -> Option<CrateId> {\n+    let root = tgt.root.as_path();\n+    if let Some(file_id) = load(root) {\n+        let edition = pkg.edition;\n+        let cfg_options = {\n+            let mut opts = cfg_options.clone();\n+            for feature in pkg.features.iter() {\n+                opts.insert_key_value(\"feature\".into(), feature.into());\n+            }\n+            opts.extend(pkg.cfgs.iter().cloned());\n+            opts\n+        };\n+        let mut env = Env::default();\n+        if let Some(out_dir) = &pkg.out_dir {\n+            // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n+            if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n+                env.set(\"OUT_DIR\", out_dir);\n+            }\n+        }\n+        let proc_macro = pkg\n+            .proc_macro_dylib_path\n+            .as_ref()\n+            .map(|it| proc_macro_client.by_dylib_path(&it))\n+            .unwrap_or_default();\n+\n+        let display_name = CrateDisplayName::from_canonical_name(pkg.name.clone());\n+        let crate_id = crate_graph.add_crate_root(\n+            file_id,\n+            edition,\n+            Some(display_name),\n+            cfg_options,\n+            env,\n+            proc_macro.clone(),\n+        );\n+\n+        return Some(crate_id);\n+    }\n+    None\n+}\n+fn sysroot_to_crate_graph(\n+    crate_graph: &mut CrateGraph,\n+    sysroot: &Sysroot,\n+    target: Option<&str>,\n+    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+) -> (Vec<(CrateName, CrateId)>, Option<CrateId>) {\n+    let mut cfg_options = CfgOptions::default();\n+    cfg_options.extend(get_rustc_cfg_options(target));\n+    let sysroot_crates: FxHashMap<_, _> = sysroot\n+        .crates()\n+        .filter_map(|krate| {\n+            let file_id = load(&sysroot[krate].root)?;\n+\n+            let env = Env::default();\n+            let proc_macro = vec![];\n+            let name = CrateName::new(&sysroot[krate].name)\n+                .expect(\"Sysroot crates' names do not contain dashes\");\n+            let crate_id = crate_graph.add_crate_root(\n+                file_id,\n+                Edition::Edition2018,\n+                Some(name.into()),\n+                cfg_options.clone(),\n+                env,\n+                proc_macro,\n+            );\n+            Some((krate, crate_id))\n+        })\n+        .collect();\n+\n+    for from in sysroot.crates() {\n+        for &to in sysroot[from].deps.iter() {\n+            let name = CrateName::new(&sysroot[to].name).unwrap();\n+            if let (Some(&from), Some(&to)) = (sysroot_crates.get(&from), sysroot_crates.get(&to)) {\n+                if let Err(_) = crate_graph.add_dep(from, name, to) {\n+                    log::error!(\"cyclic dependency between sysroot crates\")\n+                }\n+            }\n+        }\n+    }\n+\n+    let public_deps = sysroot\n+        .public_deps()\n+        .map(|(name, idx)| (CrateName::new(name).unwrap(), sysroot_crates[&idx]))\n+        .collect::<Vec<_>>();\n+\n+    let libproc_macro = sysroot.proc_macro().and_then(|it| sysroot_crates.get(&it).copied());\n+    (public_deps, libproc_macro)\n+}\n+\n+fn get_rustc_cfg_options(target: Option<&str>) -> Vec<CfgFlag> {\n+    let mut res = Vec::new();\n+\n+    // Some nightly-only cfgs, which are required for stdlib\n+    res.push(CfgFlag::Atom(\"target_thread_local\".into()));\n+    for &ty in [\"8\", \"16\", \"32\", \"64\", \"cas\", \"ptr\"].iter() {\n+        for &key in [\"target_has_atomic\", \"target_has_atomic_load_store\"].iter() {\n+            res.push(CfgFlag::KeyValue { key: key.to_string(), value: ty.into() });\n+        }\n+    }\n+\n+    let rustc_cfgs = {\n+        let mut cmd = Command::new(toolchain::rustc());\n+        cmd.args(&[\"--print\", \"cfg\", \"-O\"]);\n+        if let Some(target) = target {\n+            cmd.args(&[\"--target\", target]);\n+        }\n+        utf8_stdout(cmd)\n+    };\n+\n+    match rustc_cfgs {\n+        Ok(rustc_cfgs) => res.extend(rustc_cfgs.lines().map(|it| it.parse().unwrap())),\n+        Err(e) => log::error!(\"failed to get rustc cfgs: {:#}\", e),\n+    }\n+\n+    res\n+}"}]}