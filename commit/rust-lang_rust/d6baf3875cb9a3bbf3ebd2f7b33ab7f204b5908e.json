{"sha": "d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YmFmMzg3NWNiOWEzYmJmM2ViZDJmN2IzM2FiN2YyMDRiNTkwOGU=", "commit": {"author": {"name": "Eric Arellano", "email": "ericarellano@me.com", "date": "2020-12-07T19:54:55Z"}, "committer": {"name": "Eric Arellano", "email": "ericarellano@me.com", "date": "2020-12-07T19:54:55Z"}, "message": "Dogfood 'str_split_once() with Tidy", "tree": {"sha": "58dd26b5f0fdb87c3eb18aaf1f3f295cfc0f41c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58dd26b5f0fdb87c3eb18aaf1f3f295cfc0f41c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e", "html_url": "https://github.com/rust-lang/rust/commit/d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e/comments", "author": {"login": "Eric-Arellano", "id": 14852634, "node_id": "MDQ6VXNlcjE0ODUyNjM0", "avatar_url": "https://avatars.githubusercontent.com/u/14852634?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Eric-Arellano", "html_url": "https://github.com/Eric-Arellano", "followers_url": "https://api.github.com/users/Eric-Arellano/followers", "following_url": "https://api.github.com/users/Eric-Arellano/following{/other_user}", "gists_url": "https://api.github.com/users/Eric-Arellano/gists{/gist_id}", "starred_url": "https://api.github.com/users/Eric-Arellano/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Eric-Arellano/subscriptions", "organizations_url": "https://api.github.com/users/Eric-Arellano/orgs", "repos_url": "https://api.github.com/users/Eric-Arellano/repos", "events_url": "https://api.github.com/users/Eric-Arellano/events{/privacy}", "received_events_url": "https://api.github.com/users/Eric-Arellano/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Eric-Arellano", "id": 14852634, "node_id": "MDQ6VXNlcjE0ODUyNjM0", "avatar_url": "https://avatars.githubusercontent.com/u/14852634?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Eric-Arellano", "html_url": "https://github.com/Eric-Arellano", "followers_url": "https://api.github.com/users/Eric-Arellano/followers", "following_url": "https://api.github.com/users/Eric-Arellano/following{/other_user}", "gists_url": "https://api.github.com/users/Eric-Arellano/gists{/gist_id}", "starred_url": "https://api.github.com/users/Eric-Arellano/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Eric-Arellano/subscriptions", "organizations_url": "https://api.github.com/users/Eric-Arellano/orgs", "repos_url": "https://api.github.com/users/Eric-Arellano/repos", "events_url": "https://api.github.com/users/Eric-Arellano/events{/privacy}", "received_events_url": "https://api.github.com/users/Eric-Arellano/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12db2225b6e82b861597d1a98c018d56100a741c", "url": "https://api.github.com/repos/rust-lang/rust/commits/12db2225b6e82b861597d1a98c018d56100a741c", "html_url": "https://github.com/rust-lang/rust/commit/12db2225b6e82b861597d1a98c018d56100a741c"}], "stats": {"total": 119, "additions": 63, "deletions": 56}, "files": [{"sha": "e06616a59f38c16becbd95cfbfe5759ef9898034", "filename": "src/tools/tidy/src/cargo.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs?ref=d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e", "patch": "@@ -59,11 +59,10 @@ fn verify(tomlfile: &Path, libfile: &Path, bad: &mut bool) {\n             break;\n         }\n \n-        let mut parts = line.splitn(2, '=');\n-        let krate = parts.next().unwrap().trim();\n-        if parts.next().is_none() {\n-            continue;\n-        }\n+        let krate = match line.split_once('=') {\n+            None => continue,\n+            Some((krate, _)) => krate.trim(),\n+        };\n \n         // Don't worry about depending on core/std while not writing `extern crate\n         // core/std` -- that's intentional."}, {"sha": "1c175901be8d2da1180b7d2cf13e2820bebac155", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "modified", "additions": 53, "deletions": 42, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e", "patch": "@@ -85,47 +85,55 @@ fn extract_error_codes(\n     for line in f.lines() {\n         let s = line.trim();\n         if !reached_no_explanation && s.starts_with('E') && s.contains(\"include_str!(\\\"\") {\n-            if let Some(err_code) = s.splitn(2, ':').next() {\n-                let err_code = err_code.to_owned();\n-                if !error_codes.contains_key(&err_code) {\n-                    error_codes.insert(err_code.clone(), false);\n-                }\n-                // Now we extract the tests from the markdown file!\n-                let md = some_or_continue!(s.splitn(2, \"include_str!(\\\"\").nth(1));\n-                let md_file_name = some_or_continue!(md.splitn(2, \"\\\")\").next());\n-                let path = some_or_continue!(path.parent())\n-                    .join(md_file_name)\n-                    .canonicalize()\n-                    .expect(\"failed to canonicalize error explanation file path\");\n-                match read_to_string(&path) {\n-                    Ok(content) => {\n-                        if !IGNORE_EXPLANATION_CHECK.contains(&err_code.as_str())\n-                            && !check_if_error_code_is_test_in_explanation(&content, &err_code)\n-                        {\n-                            errors.push(format!(\n-                                \"`{}` doesn't use its own error code in compile_fail example\",\n-                                path.display(),\n-                            ));\n-                        }\n-                        if check_error_code_explanation(&content, error_codes, err_code) {\n-                            errors.push(format!(\n-                                \"`{}` uses invalid tag `compile-fail` instead of `compile_fail`\",\n-                                path.display(),\n-                            ));\n-                        }\n+            let err_code = match s.split_once(':') {\n+                None => continue,\n+                Some((err_code, _)) => err_code.to_owned(),\n+            };\n+            if !error_codes.contains_key(&err_code) {\n+                error_codes.insert(err_code.clone(), false);\n+            }\n+            // Now we extract the tests from the markdown file!\n+            let md_file_name = match s.split_once(\"include_str!(\\\"\") {\n+                None => continue,\n+                Some((_, md)) => match md.split_once(\"\\\")\") {\n+                    None => continue,\n+                    Some((file_name, _)) => file_name,\n+                },\n+            };\n+            let path = some_or_continue!(path.parent())\n+                .join(md_file_name)\n+                .canonicalize()\n+                .expect(\"failed to canonicalize error explanation file path\");\n+            match read_to_string(&path) {\n+                Ok(content) => {\n+                    if !IGNORE_EXPLANATION_CHECK.contains(&err_code.as_str())\n+                        && !check_if_error_code_is_test_in_explanation(&content, &err_code)\n+                    {\n+                        errors.push(format!(\n+                            \"`{}` doesn't use its own error code in compile_fail example\",\n+                            path.display(),\n+                        ));\n                     }\n-                    Err(e) => {\n-                        eprintln!(\"Couldn't read `{}`: {}\", path.display(), e);\n+                    if check_error_code_explanation(&content, error_codes, err_code) {\n+                        errors.push(format!(\n+                            \"`{}` uses invalid tag `compile-fail` instead of `compile_fail`\",\n+                            path.display(),\n+                        ));\n                     }\n                 }\n+                Err(e) => {\n+                    eprintln!(\"Couldn't read `{}`: {}\", path.display(), e);\n+                }\n             }\n         } else if reached_no_explanation && s.starts_with('E') {\n-            if let Some(err_code) = s.splitn(2, ',').next() {\n-                let err_code = err_code.to_owned();\n-                if !error_codes.contains_key(&err_code) {\n-                    // this check should *never* fail!\n-                    error_codes.insert(err_code, false);\n-                }\n+            let err_code = match s.split_once(',') {\n+                None => s,\n+                Some((err_code, _)) => err_code,\n+            }\n+            .to_string();\n+            if !error_codes.contains_key(&err_code) {\n+                // this check should *never* fail!\n+                error_codes.insert(err_code, false);\n             }\n         } else if s == \";\" {\n             reached_no_explanation = true;\n@@ -137,12 +145,15 @@ fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, boo\n     for line in f.lines() {\n         let s = line.trim();\n         if s.starts_with(\"error[E\") || s.starts_with(\"warning[E\") {\n-            if let Some(err_code) = s.splitn(2, ']').next() {\n-                if let Some(err_code) = err_code.splitn(2, '[').nth(1) {\n-                    let nb = error_codes.entry(err_code.to_owned()).or_insert(false);\n-                    *nb = true;\n-                }\n-            }\n+            let err_code = match s.split_once(']') {\n+                None => continue,\n+                Some((err_code, _)) => match err_code.split_once('[') {\n+                    None => continue,\n+                    Some((_, err_code)) => err_code,\n+                },\n+            };\n+            let nb = error_codes.entry(err_code.to_owned()).or_insert(false);\n+            *nb = true;\n         }\n     }\n }"}, {"sha": "93d4d3d8047d82678686876fe0205157288df6a3", "filename": "src/tools/tidy/src/extdeps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs?ref=d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e", "patch": "@@ -23,7 +23,7 @@ pub fn check(root: &Path, bad: &mut bool) {\n         }\n \n         // Extract source value.\n-        let source = line.splitn(2, '=').nth(1).unwrap().trim();\n+        let source = line.split_once('=').unwrap().1.trim();\n \n         // Ensure source is allowed.\n         if !ALLOWED_SOURCES.contains(&&*source) {"}, {"sha": "3c2880d0d5e261eaeb3063d4617eaf5502688ccc", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e", "patch": "@@ -112,6 +112,7 @@ pub fn check(\n                 let gate_test_str = \"gate-test-\";\n \n                 let feature_name = match line.find(gate_test_str) {\n+                    // NB: the `splitn` always succeeds, even if the delimiter is not present.\n                     Some(i) => line[i + gate_test_str.len()..].splitn(2, ' ').next().unwrap(),\n                     None => continue,\n                 };"}, {"sha": "e11d293210b0a97c566e96745c0ce8b30dfe37d5", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e", "patch": "@@ -3,6 +3,8 @@\n //! This library contains the tidy lints and exposes it\n //! to be used by tools.\n \n+#![feature(str_split_once)]\n+\n use std::fs::File;\n use std::io::Read;\n use walkdir::{DirEntry, WalkDir};"}, {"sha": "4c8c1d58ed7233564a4cc2ea399c859565fab5b3", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=d6baf3875cb9a3bbf3ebd2f7b33ab7f204b5908e", "patch": "@@ -19,14 +19,8 @@ pub fn check(path: &Path, bad: &mut bool) {\n                     //\n                     // For now, just make sure that there is a corresponding\n                     // `$testname.rs` file.\n-                    let testname = file_path\n-                        .file_name()\n-                        .unwrap()\n-                        .to_str()\n-                        .unwrap()\n-                        .splitn(2, '.')\n-                        .next()\n-                        .unwrap();\n+                    let testname =\n+                        file_path.file_name().unwrap().to_str().unwrap().split_once('.').unwrap().0;\n                     if !file_path.with_file_name(testname).with_extension(\"rs\").exists() {\n                         println!(\"Stray file with UI testing output: {:?}\", file_path);\n                         *bad = true;"}]}