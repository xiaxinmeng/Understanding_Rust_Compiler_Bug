{"sha": "11fd2beef95f2a1e28fbd7b7b7b8647f88f15d40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExZmQyYmVlZjk1ZjJhMWUyOGZiZDdiN2I3Yjg2NDdmODhmMTVkNDA=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-24T23:40:46Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-25T00:24:31Z"}, "message": "Convert dlist records into structs", "tree": {"sha": "ecbcb06d34e564365b4fd97a311f59c6c5ed2932", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecbcb06d34e564365b4fd97a311f59c6c5ed2932"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11fd2beef95f2a1e28fbd7b7b7b8647f88f15d40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11fd2beef95f2a1e28fbd7b7b7b8647f88f15d40", "html_url": "https://github.com/rust-lang/rust/commit/11fd2beef95f2a1e28fbd7b7b7b8647f88f15d40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11fd2beef95f2a1e28fbd7b7b7b8647f88f15d40/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "339618a7f9096507667139364450c9be40768d17", "url": "https://api.github.com/repos/rust-lang/rust/commits/339618a7f9096507667139364450c9be40768d17", "html_url": "https://github.com/rust-lang/rust/commit/339618a7f9096507667139364450c9be40768d17"}], "stats": {"total": 239, "additions": 128, "deletions": 111}, "files": [{"sha": "4f0d76d69f32ce491900fe29775ba97e4da5beca", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 122, "deletions": 106, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/11fd2beef95f2a1e28fbd7b7b7b8647f88f15d40/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11fd2beef95f2a1e28fbd7b7b7b8647f88f15d40/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=11fd2beef95f2a1e28fbd7b7b7b8647f88f15d40", "patch": "@@ -28,28 +28,26 @@ use option::{None, Option, Some};\n use option;\n use vec;\n \n-type DListLink<T> = Option<DListNode<T>>;\n+pub type DListLink<T> = Option<@DListNode<T>>;\n \n-enum DListNode<T> = @{\n+pub struct DListNode<T> {\n     data: T,\n     mut linked: bool, // for assertions\n     mut prev: DListLink<T>,\n-    mut next: DListLink<T>\n-};\n-\n-pub enum DList<T> {\n-    DList_(@{\n-        mut size: uint,\n-        mut hd:   DListLink<T>,\n-        mut tl:   DListLink<T>\n-    })\n+    mut next: DListLink<T>,\n+}\n+\n+pub struct DList<T> {\n+    mut size: uint,\n+    mut hd: DListLink<T>,\n+    mut tl: DListLink<T>,\n }\n \n priv impl<T> DListNode<T> {\n-    pure fn assert_links() {\n+    pure fn assert_links(@self) {\n         match self.next {\n             Some(neighbour) => match neighbour.prev {\n-              Some(me) => if !managed::ptr_eq(*self, *me) {\n+              Some(me) => if !managed::ptr_eq(self, me) {\n                   fail ~\"Asymmetric next-link in dlist node.\"\n               },\n               None => fail ~\"One-way next-link in dlist node.\"\n@@ -58,7 +56,7 @@ priv impl<T> DListNode<T> {\n         }\n         match self.prev {\n             Some(neighbour) => match neighbour.next {\n-              Some(me) => if !managed::ptr_eq(*me, *self) {\n+              Some(me) => if !managed::ptr_eq(me, self) {\n                   fail ~\"Asymmetric prev-link in dlist node.\"\n               },\n               None => fail ~\"One-way prev-link in dlist node.\"\n@@ -70,24 +68,24 @@ priv impl<T> DListNode<T> {\n \n impl<T> DListNode<T> {\n     /// Get the next node in the list, if there is one.\n-    pure fn next_link() -> Option<DListNode<T>> {\n+    pure fn next_link(@self) -> DListLink<T> {\n         self.assert_links();\n         self.next\n     }\n     /// Get the next node in the list, failing if there isn't one.\n-    pure fn next_node() -> DListNode<T> {\n+    pure fn next_node(@self) -> @DListNode<T> {\n         match self.next_link() {\n             Some(nobe) => nobe,\n             None       => fail ~\"This dlist node has no next neighbour.\"\n         }\n     }\n     /// Get the previous node in the list, if there is one.\n-    pure fn prev_link() -> Option<DListNode<T>> {\n+    pure fn prev_link(@self) -> DListLink<T> {\n         self.assert_links();\n         self.prev\n     }\n     /// Get the previous node in the list, failing if there isn't one.\n-    pure fn prev_node() -> DListNode<T> {\n+    pure fn prev_node(@self) -> @DListNode<T> {\n         match self.prev_link() {\n             Some(nobe) => nobe,\n             None       => fail ~\"This dlist node has no previous neighbour.\"\n@@ -96,24 +94,23 @@ impl<T> DListNode<T> {\n }\n \n /// Creates a new dlist node with the given data.\n-pub pure fn new_dlist_node<T>(data: T) -> DListNode<T> {\n-    DListNode(@{data: move data, mut linked: false,\n-                 mut prev: None, mut next: None})\n+pub pure fn new_dlist_node<T>(data: T) -> @DListNode<T> {\n+    @DListNode { data: data, linked: false, prev: None, next: None }\n }\n \n /// Creates a new, empty dlist.\n-pub pure fn DList<T>() -> DList<T> {\n-    DList_(@{mut size: 0, mut hd: None, mut tl: None})\n+pub pure fn DList<T>() -> @DList<T> {\n+    @DList { size: 0, hd: None, tl: None }\n }\n \n /// Creates a new dlist with a single element\n-pub pure fn from_elem<T>(data: T) -> DList<T> {\n+pub pure fn from_elem<T>(data: T) -> @DList<T> {\n     let list = DList();\n-    unsafe { list.push(move data); }\n+    unsafe { list.push(data); }\n     list\n }\n \n-pub fn from_vec<T: Copy>(vec: &[T]) -> DList<T> {\n+pub fn from_vec<T: Copy>(vec: &[T]) -> @DList<T> {\n     do vec::foldl(DList(), vec) |list,data| {\n         list.push(*data); // Iterating left-to-right -- add newly to the tail.\n         list\n@@ -122,7 +119,7 @@ pub fn from_vec<T: Copy>(vec: &[T]) -> DList<T> {\n \n /// Produce a list from a list of lists, leaving no elements behind in the\n /// input. O(number of sub-lists).\n-pub fn concat<T>(lists: DList<DList<T>>) -> DList<T> {\n+pub fn concat<T>(lists: @DList<@DList<T>>) -> @DList<T> {\n     let result = DList();\n     while !lists.is_empty() {\n         result.append(lists.pop().get());\n@@ -131,27 +128,26 @@ pub fn concat<T>(lists: DList<DList<T>>) -> DList<T> {\n }\n \n priv impl<T> DList<T> {\n-    pure fn new_link(data: T) -> DListLink<T> {\n-        Some(DListNode(@{data: move data, mut linked: true,\n-                          mut prev: None, mut next: None}))\n+    static pure fn new_link(data: T) -> DListLink<T> {\n+        Some(@DListNode { data: data, linked: true, prev: None, next: None })\n     }\n-    pure fn assert_mine(nobe: DListNode<T>) {\n+    pure fn assert_mine(@self, nobe: @DListNode<T>) {\n         // These asserts could be stronger if we had node-root back-pointers,\n         // but those wouldn't allow for O(1) append.\n         if self.size == 0 {\n             fail ~\"This dlist is empty; that node can't be on it.\"\n         }\n         if !nobe.linked { fail ~\"That node isn't linked to any dlist.\" }\n         if !((nobe.prev.is_some()\n-              || managed::ptr_eq(*self.hd.expect(~\"headless dlist?\"),\n-                                 *nobe)) &&\n+              || managed::ptr_eq(self.hd.expect(~\"headless dlist?\"),\n+                                 nobe)) &&\n              (nobe.next.is_some()\n-              || managed::ptr_eq(*self.tl.expect(~\"tailless dlist?\"),\n-                                 *nobe))) {\n+              || managed::ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n+                                 nobe))) {\n             fail ~\"That node isn't on this dlist.\"\n         }\n     }\n-    fn make_mine(nobe: DListNode<T>) {\n+    fn make_mine(nobe: @DListNode<T>) {\n         if nobe.prev.is_some() || nobe.next.is_some() || nobe.linked {\n             fail ~\"Cannot insert node that's already on a dlist!\"\n         }\n@@ -171,7 +167,7 @@ priv impl<T> DList<T> {\n         }\n     }\n     // Remove a node from the list.\n-    fn unlink(nobe: DListNode<T>) {\n+    fn unlink(@self, nobe: @DListNode<T>) {\n         self.assert_mine(nobe);\n         assert self.size > 0;\n         self.link(nobe.prev, nobe.next);\n@@ -181,24 +177,24 @@ priv impl<T> DList<T> {\n         self.size -= 1;\n     }\n \n-    fn add_head(nobe: DListLink<T>) {\n+    fn add_head(@self, nobe: DListLink<T>) {\n         self.link(nobe, self.hd); // Might set tail too.\n         self.hd = nobe;\n         self.size += 1;\n     }\n-    fn add_tail(nobe: DListLink<T>) {\n+    fn add_tail(@self, nobe: DListLink<T>) {\n         self.link(self.tl, nobe); // Might set head too.\n         self.tl = nobe;\n         self.size += 1;\n     }\n-    fn insert_left(nobe: DListLink<T>, neighbour: DListNode<T>) {\n+    fn insert_left(@self, nobe: DListLink<T>, neighbour: @DListNode<T>) {\n         self.assert_mine(neighbour);\n         assert self.size > 0;\n         self.link(neighbour.prev, nobe);\n         self.link(nobe, Some(neighbour));\n         self.size += 1;\n     }\n-    fn insert_right(neighbour: DListNode<T>, nobe: DListLink<T>) {\n+    fn insert_right(@self, neighbour: @DListNode<T>, nobe: DListLink<T>) {\n         self.assert_mine(neighbour);\n         assert self.size > 0;\n         self.link(nobe, neighbour.next);\n@@ -209,128 +205,136 @@ priv impl<T> DList<T> {\n \n impl<T> DList<T> {\n     /// Get the size of the list. O(1).\n-    pure fn len()          -> uint { self.size }\n+    pure fn len(@self) -> uint { self.size }\n     /// Returns true if the list is empty. O(1).\n-    pure fn is_empty()     -> bool { self.len() == 0 }\n+    pure fn is_empty(@self) -> bool { self.len() == 0 }\n     /// Returns true if the list is not empty. O(1).\n-    pure fn is_not_empty() -> bool { self.len() != 0 }\n+    pure fn is_not_empty(@self) -> bool { self.len() != 0 }\n \n     /// Add data to the head of the list. O(1).\n-    fn push_head(data: T) {\n-        self.add_head(self.new_link(move data));\n+    fn push_head(@self, data: T) {\n+        self.add_head(DList::new_link(data));\n     }\n     /**\n      * Add data to the head of the list, and get the new containing\n      * node. O(1).\n      */\n-    fn push_head_n(data: T) -> DListNode<T> {\n-        let mut nobe = self.new_link(move data);\n+    fn push_head_n(@self, data: T) -> @DListNode<T> {\n+        let mut nobe = DList::new_link(data);\n         self.add_head(nobe);\n-        option::get(nobe)\n+        nobe.get()\n     }\n     /// Add data to the tail of the list. O(1).\n-    fn push(data: T) {\n-        self.add_tail(self.new_link(move data));\n+    fn push(@self, data: T) {\n+        self.add_tail(DList::new_link(data));\n     }\n     /**\n      * Add data to the tail of the list, and get the new containing\n      * node. O(1).\n      */\n-    fn push_n(data: T) -> DListNode<T> {\n-        let mut nobe = self.new_link(move data);\n+    fn push_n(@self, data: T) -> @DListNode<T> {\n+        let mut nobe = DList::new_link(data);\n         self.add_tail(nobe);\n-        option::get(nobe)\n+        nobe.get()\n     }\n     /**\n      * Insert data into the middle of the list, left of the given node.\n      * O(1).\n      */\n-    fn insert_before(data: T, neighbour: DListNode<T>) {\n-        self.insert_left(self.new_link(move data), neighbour);\n+    fn insert_before(@self, data: T, neighbour: @DListNode<T>) {\n+        self.insert_left(DList::new_link(data), neighbour);\n     }\n     /**\n      * Insert an existing node in the middle of the list, left of the\n      * given node. O(1).\n      */\n-    fn insert_n_before(nobe: DListNode<T>, neighbour: DListNode<T>) {\n+    fn insert_n_before(@self, nobe: @DListNode<T>, neighbour: @DListNode<T>) {\n         self.make_mine(nobe);\n         self.insert_left(Some(nobe), neighbour);\n     }\n     /**\n      * Insert data in the middle of the list, left of the given node,\n      * and get its containing node. O(1).\n      */\n-    fn insert_before_n(data: T, neighbour: DListNode<T>) -> DListNode<T> {\n-        let mut nobe = self.new_link(move data);\n+    fn insert_before_n(\n+        @self,\n+        data: T,\n+        neighbour: @DListNode<T>\n+    ) -> @DListNode<T> {\n+        let mut nobe = DList::new_link(data);\n         self.insert_left(nobe, neighbour);\n-        option::get(nobe)\n+        nobe.get()\n     }\n     /**\n      * Insert data into the middle of the list, right of the given node.\n      * O(1).\n      */\n-    fn insert_after(data: T, neighbour: DListNode<T>) {\n-        self.insert_right(neighbour, self.new_link(move data));\n+    fn insert_after(@self, data: T, neighbour: @DListNode<T>) {\n+        self.insert_right(neighbour, DList::new_link(data));\n     }\n     /**\n      * Insert an existing node in the middle of the list, right of the\n      * given node. O(1).\n      */\n-    fn insert_n_after(nobe: DListNode<T>, neighbour: DListNode<T>) {\n+    fn insert_n_after(@self, nobe: @DListNode<T>, neighbour: @DListNode<T>) {\n         self.make_mine(nobe);\n         self.insert_right(neighbour, Some(nobe));\n     }\n     /**\n      * Insert data in the middle of the list, right of the given node,\n      * and get its containing node. O(1).\n      */\n-    fn insert_after_n(data: T, neighbour: DListNode<T>) -> DListNode<T> {\n-        let mut nobe = self.new_link(move data);\n+    fn insert_after_n(\n+        @self,\n+        data: T,\n+        neighbour: @DListNode<T>\n+    ) -> @DListNode<T> {\n+        let mut nobe = DList::new_link(data);\n         self.insert_right(neighbour, nobe);\n-        option::get(nobe)\n+        nobe.get()\n     }\n \n     /// Remove a node from the head of the list. O(1).\n-    fn pop_n() -> Option<DListNode<T>> {\n+    fn pop_n(@self) -> DListLink<T> {\n         let hd = self.peek_n();\n         hd.map(|nobe| self.unlink(*nobe));\n         hd\n     }\n     /// Remove a node from the tail of the list. O(1).\n-    fn pop_tail_n() -> Option<DListNode<T>> {\n+    fn pop_tail_n(@self) -> DListLink<T> {\n         let tl = self.peek_tail_n();\n         tl.map(|nobe| self.unlink(*nobe));\n         tl\n     }\n     /// Get the node at the list's head. O(1).\n-    pure fn peek_n() -> Option<DListNode<T>> { self.hd }\n+    pure fn peek_n(@self) -> DListLink<T> { self.hd }\n     /// Get the node at the list's tail. O(1).\n-    pure fn peek_tail_n() -> Option<DListNode<T>> { self.tl }\n+    pure fn peek_tail_n(@self) -> DListLink<T> { self.tl }\n \n     /// Get the node at the list's head, failing if empty. O(1).\n-    pure fn head_n() -> DListNode<T> {\n+    pure fn head_n(@self) -> @DListNode<T> {\n         match self.hd {\n             Some(nobe) => nobe,\n             None       => fail ~\"Attempted to get the head of an empty dlist.\"\n         }\n     }\n     /// Get the node at the list's tail, failing if empty. O(1).\n-    pure fn tail_n() -> DListNode<T> {\n+    pure fn tail_n(@self) -> @DListNode<T> {\n         match self.tl {\n             Some(nobe) => nobe,\n             None       => fail ~\"Attempted to get the tail of an empty dlist.\"\n         }\n     }\n \n     /// Remove a node from anywhere in the list. O(1).\n-    fn remove(nobe: DListNode<T>) { self.unlink(nobe); }\n+    fn remove(@self, nobe: @DListNode<T>) { self.unlink(nobe); }\n \n     /**\n      * Empty another list onto the end of this list, joining this list's tail\n      * to the other list's head. O(1).\n      */\n-    fn append(them: DList<T>) {\n-        if managed::ptr_eq(*self, *them) {\n+    fn append(@self, them: @DList<T>) {\n+        if managed::ptr_eq(self, them) {\n             fail ~\"Cannot append a dlist to itself!\"\n         }\n         if them.len() > 0 {\n@@ -346,8 +350,8 @@ impl<T> DList<T> {\n      * Empty another list onto the start of this list, joining the other\n      * list's tail to this list's head. O(1).\n      */\n-    fn prepend(them: DList<T>) {\n-        if managed::ptr_eq(*self, *them) {\n+    fn prepend(@self, them: @DList<T>) {\n+        if managed::ptr_eq(self, them) {\n             fail ~\"Cannot prepend a dlist to itself!\"\n         }\n         if them.len() > 0 {\n@@ -361,7 +365,7 @@ impl<T> DList<T> {\n     }\n \n     /// Reverse the list's elements in place. O(n).\n-    fn reverse() {\n+    fn reverse(@self) {\n         do option::while_some(self.hd) |nobe| {\n             let next_nobe = nobe.next;\n             self.remove(nobe);\n@@ -375,7 +379,7 @@ impl<T> DList<T> {\n      * Remove everything from the list. This is important because the cyclic\n      * links won't otherwise be automatically refcounted-collected. O(n).\n      */\n-    fn clear() {\n+    fn clear(@self) {\n         // Cute as it would be to simply detach the list and proclaim \"O(1)!\",\n         // the GC would still be a hidden O(n). Better to be honest about it.\n         while !self.is_empty() {\n@@ -384,7 +388,7 @@ impl<T> DList<T> {\n     }\n \n     /// Iterate over nodes.\n-    pure fn each_node(f: fn(DListNode<T>) -> bool) {\n+    pure fn each_node(@self, f: fn(@DListNode<T>) -> bool) {\n         let mut link = self.peek_n();\n         while link.is_some() {\n             let nobe = link.get();\n@@ -394,26 +398,26 @@ impl<T> DList<T> {\n     }\n \n     /// Check data structure integrity. O(n).\n-    fn assert_consistent() {\n-        if option::is_none(&self.hd) || option::is_none(&self.tl) {\n-            assert option::is_none(&self.hd) && option::is_none(&self.tl);\n+    fn assert_consistent(@self) {\n+        if self.hd.is_none() || self.tl.is_none() {\n+            assert self.hd.is_none() && self.tl.is_none();\n         }\n         // iterate forwards\n         let mut count = 0;\n         let mut link = self.peek_n();\n         let mut rabbit = link;\n-        while option::is_some(&link) {\n-            let nobe = option::get(link);\n+        while link.is_some() {\n+            let nobe = link.get();\n             assert nobe.linked;\n             // check cycle\n-            if option::is_some(&rabbit) {\n-                rabbit = option::get(rabbit).next;\n+            if rabbit.is_some() {\n+                rabbit = rabbit.get().next;\n             }\n-            if option::is_some(&rabbit) {\n-                rabbit = option::get(rabbit).next;\n+            if rabbit.is_some() {\n+                rabbit = rabbit.get().next;\n             }\n-            if option::is_some(&rabbit) {\n-                assert !managed::ptr_eq(*option::get(rabbit), *nobe);\n+            if rabbit.is_some() {\n+                assert !managed::ptr_eq(rabbit.get(), nobe);\n             }\n             // advance\n             link = nobe.next_link();\n@@ -423,18 +427,18 @@ impl<T> DList<T> {\n         // iterate backwards - some of this is probably redundant.\n         link = self.peek_tail_n();\n         rabbit = link;\n-        while option::is_some(&link) {\n-            let nobe = option::get(link);\n+        while link.is_some() {\n+            let nobe = link.get();\n             assert nobe.linked;\n             // check cycle\n-            if option::is_some(&rabbit) {\n-                rabbit = option::get(rabbit).prev;\n+            if rabbit.is_some() {\n+                rabbit = rabbit.get().prev;\n             }\n-            if option::is_some(&rabbit) {\n-                rabbit = option::get(rabbit).prev;\n+            if rabbit.is_some() {\n+                rabbit = rabbit.get().prev;\n             }\n-            if option::is_some(&rabbit) {\n-                assert !managed::ptr_eq(*option::get(rabbit), *nobe);\n+            if rabbit.is_some() {\n+                assert !managed::ptr_eq(rabbit.get(), nobe);\n             }\n             // advance\n             link = nobe.prev_link();\n@@ -446,21 +450,33 @@ impl<T> DList<T> {\n \n impl<T: Copy> DList<T> {\n     /// Remove data from the head of the list. O(1).\n-    fn pop()       -> Option<T> { self.pop_n().map       (|nobe| nobe.data) }\n+    fn pop(@self) -> Option<T> {\n+        self.pop_n().map(|nobe| nobe.data)\n+    }\n+\n     /// Remove data from the tail of the list. O(1).\n-    fn pop_tail()  -> Option<T> { self.pop_tail_n().map  (|nobe| nobe.data) }\n+    fn pop_tail(@self) -> Option<T> {\n+        self.pop_tail_n().map(|nobe| nobe.data)\n+    }\n+\n     /// Get data at the list's head. O(1).\n-    pure fn peek() -> Option<T> { self.peek_n().map      (|nobe| nobe.data) }\n+    pure fn peek(@self) -> Option<T> {\n+        self.peek_n().map(|nobe| nobe.data)\n+    }\n+\n     /// Get data at the list's tail. O(1).\n-    pure fn peek_tail() -> Option<T> {\n+    pure fn peek_tail(@self) -> Option<T> {\n         self.peek_tail_n().map (|nobe| nobe.data)\n     }\n+\n     /// Get data at the list's head, failing if empty. O(1).\n-    pure fn head() -> T { self.head_n().data }\n+    pure fn head(@self) -> T { self.head_n().data }\n+\n     /// Get data at the list's tail, failing if empty. O(1).\n-    pure fn tail() -> T { self.tail_n().data }\n+    pure fn tail(@self) -> T { self.tail_n().data }\n+\n     /// Get the elements of the list as a vector. O(n).\n-    pure fn to_vec() -> ~[T] {\n+    pure fn to_vec(@self) -> ~[T] {\n         let mut v = vec::with_capacity(self.size);\n         unsafe {\n             // Take this out of the unchecked when iter's functions are pure"}, {"sha": "5b5f786bac7ffb516cb0cb52a75b6e97301a7cc7", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/11fd2beef95f2a1e28fbd7b7b7b8647f88f15d40/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11fd2beef95f2a1e28fbd7b7b7b8647f88f15d40/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=11fd2beef95f2a1e28fbd7b7b7b8647f88f15d40", "patch": "@@ -10,12 +10,13 @@\n \n mod inst {\n     use dlist;\n+    use dlist::DList;\n     use managed;\n     use option::{Option, Some};\n     use option;\n \n     #[allow(non_camel_case_types)]\n-    pub type IMPL_T<A> = dlist::DList<A>;\n+    pub type IMPL_T<A> = @DList<A>;\n \n     /**\n     * Iterates through the current contents.\n@@ -36,11 +37,11 @@ mod inst {\n             }\n             if !nobe.linked ||\n                 (!((nobe.prev.is_some()\n-                    || managed::ptr_eq(*self.hd.expect(~\"headless dlist?\"),\n-                                   *nobe))\n+                    || managed::ptr_eq(self.hd.expect(~\"headless dlist?\"),\n+                                       nobe))\n                    && (nobe.next.is_some()\n-                    || managed::ptr_eq(*self.tl.expect(~\"tailless dlist?\"),\n-                                   *nobe)))) {\n+                    || managed::ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n+                                       nobe)))) {\n                 fail ~\"Removing a dlist node during iteration is forbidden!\"\n             }\n             link = nobe.next_link();"}]}