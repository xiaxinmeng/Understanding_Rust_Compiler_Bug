{"sha": "2bbfa02b1b15974d5772b520aa027bf79f8c248e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYmZhMDJiMWIxNTk3NGQ1NzcyYjUyMGFhMDI3YmY3OWY4YzI0OGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-23T08:56:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-23T08:56:45Z"}, "message": "Auto merge of #74667 - Manishearth:rollup-s6k59sw, r=Manishearth\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #74141 (libstd/libcore: fix various typos)\n - #74490 (add a Backtrace::disabled function)\n - #74548 (one more Path::with_extension example, to demonstrate behavior)\n - #74587 (Prefer constant over function)\n - #74606 (Remove Linux workarounds for missing CLOEXEC support)\n - #74637 (Make str point to primitive page)\n - #74654 (require type defaults to be after const generic parameters)\n - #74659 (Improve codegen for unchecked float casts on wasm)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "e7e74cc74874cf154f4b5c5ea97cf04c132c982d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7e74cc74874cf154f4b5c5ea97cf04c132c982d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bbfa02b1b15974d5772b520aa027bf79f8c248e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bbfa02b1b15974d5772b520aa027bf79f8c248e", "html_url": "https://github.com/rust-lang/rust/commit/2bbfa02b1b15974d5772b520aa027bf79f8c248e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bbfa02b1b15974d5772b520aa027bf79f8c248e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcac11993ca055bbdc7683a2f6ed7b88a838fb0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcac11993ca055bbdc7683a2f6ed7b88a838fb0f", "html_url": "https://github.com/rust-lang/rust/commit/fcac11993ca055bbdc7683a2f6ed7b88a838fb0f"}, {"sha": "8f02f2c1abd6c3fbd3053da5bb6759a4698a949e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f02f2c1abd6c3fbd3053da5bb6759a4698a949e", "html_url": "https://github.com/rust-lang/rust/commit/8f02f2c1abd6c3fbd3053da5bb6759a4698a949e"}], "stats": {"total": 568, "additions": 266, "deletions": 302}, "files": [{"sha": "f41c8c5a5591054c6c89d6ecc1e6108c94acd7c1", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -65,7 +65,7 @@ use crate::vec::Vec;\n ///\n /// # Examples\n ///\n-/// You can create a `String` from [a literal string][str] with [`String::from`]:\n+/// You can create a `String` from [a literal string][`str`] with [`String::from`]:\n ///\n /// [`String::from`]: From::from\n ///\n@@ -268,7 +268,8 @@ use crate::vec::Vec;\n ///\n /// Here, there's no need to allocate more memory inside the loop.\n ///\n-/// [`&str`]: str\n+/// [`str`]: type@str\n+/// [`&str`]: type@str\n /// [`Deref`]: core::ops::Deref\n /// [`as_str()`]: String::as_str\n #[derive(PartialOrd, Eq, Ord)]"}, {"sha": "03b798d57db9bcf37ba50b1ba515730782f2e7bd", "filename": "src/libcore/convert/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fmod.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -677,7 +677,7 @@ impl AsRef<str> for str {\n ///\n ///\n /// However there is one case where `!` syntax can be used\n-/// before `!` is stabilized as a full-fleged type: in the position of a function\u2019s return type.\n+/// before `!` is stabilized as a full-fledged type: in the position of a function\u2019s return type.\n /// Specifically, it is possible implementations for two different function pointer types:\n ///\n /// ```"}, {"sha": "a9882d54de4f18b3e47d86ce132d760c852e2ab6", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -43,7 +43,7 @@ struct SipHasher24 {\n ///\n /// SipHash is a general-purpose hashing function: it runs at a good\n /// speed (competitive with Spooky and City) and permits strong _keyed_\n-/// hashing. This lets you key your hashtables from a strong RNG, such as\n+/// hashing. This lets you key your hash tables from a strong RNG, such as\n /// [`rand::os::OsRng`](https://doc.rust-lang.org/rand/rand/os/struct.OsRng.html).\n ///\n /// Although the SipHash algorithm is considered to be generally strong,"}, {"sha": "1af4f1009d1ac86e94d3c2d49e62d3db44a93a25", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -15,7 +15,7 @@\n //!\n //! If an intrinsic is supposed to be used from a `const fn` with a `rustc_const_stable` attribute,\n //! the intrinsic's attribute must be `rustc_const_stable`, too. Such a change should not be done\n-//! without T-lang consulation, because it bakes a feature into the language that cannot be\n+//! without T-lang consultation, because it bakes a feature into the language that cannot be\n //! replicated in user code without compiler support.\n //!\n //! # Volatiles\n@@ -994,7 +994,7 @@ extern \"rust-intrinsic\" {\n     /// [`std::mem::align_of`](../../std/mem/fn.align_of.html).\n     #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n     pub fn min_align_of<T>() -> usize;\n-    /// The prefered alignment of a type.\n+    /// The preferred alignment of a type.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_pref_align_of\", issue = \"none\")]\n@@ -1246,14 +1246,14 @@ extern \"rust-intrinsic\" {\n     ///     assert!(mid <= len);\n     ///     unsafe {\n     ///         let slice2 = mem::transmute::<&mut [T], &mut [T]>(slice);\n-    ///         // first: transmute is not typesafe; all it checks is that T and\n+    ///         // first: transmute is not type safe; all it checks is that T and\n     ///         // U are of the same size. Second, right here, you have two\n     ///         // mutable references pointing to the same memory.\n     ///         (&mut slice[0..mid], &mut slice2[mid..len])\n     ///     }\n     /// }\n     ///\n-    /// // This gets rid of the typesafety problems; `&mut *` will *only* give\n+    /// // This gets rid of the type safety problems; `&mut *` will *only* give\n     /// // you an `&mut T` from an `&mut T` or `*mut T`.\n     /// fn split_at_mut_casts<T>(slice: &mut [T], mid: usize)\n     ///                          -> (&mut [T], &mut [T]) {"}, {"sha": "3ea3eeed6b0434f3f4f5fc7b3b5569051a255249", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -1069,7 +1069,7 @@ pub trait Iterator {\n     /// let vec = iter.collect::<Vec<_>>();\n     ///\n     /// // We have more elements which could fit in u32 (4, 5), but `map_while` returned `None` for `-3`\n-    /// // (as the `predicate` returned `None`) and `collect` stops at the first `None` entcountered.\n+    /// // (as the `predicate` returned `None`) and `collect` stops at the first `None` encountered.\n     /// assert_eq!(vec, vec![0, 1, 2]);\n     /// ```\n     ///"}, {"sha": "3b9057b7e8377911feec5d30b98e163a787d0fab", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -1047,7 +1047,7 @@ pub(crate) mod builtin {\n         };\n     }\n \n-    /// Includes a utf8-encoded file as a string.\n+    /// Includes a UTF-8 encoded file as a string.\n     ///\n     /// The file is located relative to the current file (similarly to how\n     /// modules are found). The provided path is interpreted in a platform-specific"}, {"sha": "6ff7baab70f61eee903dde10278c4e06dcdeabe1", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -348,11 +348,11 @@ pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n ///\n /// - If `T` is `Sized`, this function is always safe to call.\n /// - If the unsized tail of `T` is:\n-///     - a [slice], then the length of the slice tail must be an intialized\n+///     - a [slice], then the length of the slice tail must be an initialized\n ///       integer, and the size of the *entire value*\n ///       (dynamic tail length + statically sized prefix) must fit in `isize`.\n ///     - a [trait object], then the vtable part of the pointer must point\n-///       to a valid vtable acquired by an unsizing coersion, and the size\n+///       to a valid vtable acquired by an unsizing coercion, and the size\n ///       of the *entire value* (dynamic tail length + statically sized prefix)\n ///       must fit in `isize`.\n ///     - an (unstable) [extern type], then this function is always safe to\n@@ -483,11 +483,11 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n ///\n /// - If `T` is `Sized`, this function is always safe to call.\n /// - If the unsized tail of `T` is:\n-///     - a [slice], then the length of the slice tail must be an intialized\n+///     - a [slice], then the length of the slice tail must be an initialized\n ///       integer, and the size of the *entire value*\n ///       (dynamic tail length + statically sized prefix) must fit in `isize`.\n ///     - a [trait object], then the vtable part of the pointer must point\n-///       to a valid vtable acquired by an unsizing coersion, and the size\n+///       to a valid vtable acquired by an unsizing coercion, and the size\n ///       of the *entire value* (dynamic tail length + statically sized prefix)\n ///       must fit in `isize`.\n ///     - an (unstable) [extern type], then this function is always safe to"}, {"sha": "a5b1eb3f1fd67c61adcc65d041319bc7b88f6f29", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -687,7 +687,7 @@ impl f64 {\n     /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n     ///\n     /// Rather than trying to preserve signaling-ness cross-platform, this\n-    /// implementation favours preserving the exact bits. This means that\n+    /// implementation favors preserving the exact bits. This means that\n     /// any payloads encoded in NaNs will be preserved even if the result of\n     /// this method is sent over the network from an x86 machine to a MIPS one.\n     ///\n@@ -696,7 +696,7 @@ impl f64 {\n     ///\n     /// If the input isn't NaN, then there is no portability concern.\n     ///\n-    /// If you don't care about signalingness (very likely), then there is no\n+    /// If you don't care about signaling-ness (very likely), then there is no\n     /// portability concern.\n     ///\n     /// Note that this function is distinct from `as` casting, which attempts to"}, {"sha": "9bcacd8ddcf77ee54bb950f8a9dcff1d280fbf6d", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -128,7 +128,7 @@\n //!\n //! Crucially, we have to be able to rely on [`drop`] being called. If an element\n //! could be deallocated or otherwise invalidated without calling [`drop`], the pointers into it\n-//! from its neighbouring elements would become invalid, which would break the data structure.\n+//! from its neighboring elements would become invalid, which would break the data structure.\n //!\n //! Therefore, pinning also comes with a [`drop`]-related guarantee.\n //!"}, {"sha": "a2acc239bd38f942da26c334b1254e4a6a24db00", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -331,13 +331,13 @@ impl<T: ?Sized> *const T {\n         intrinsics::ptr_guaranteed_eq(self, other)\n     }\n \n-    /// Returns whether two pointers are guaranteed to be inequal.\n+    /// Returns whether two pointers are guaranteed to be unequal.\n     ///\n     /// At runtime this function behaves like `self != other`.\n     /// However, in some contexts (e.g., compile-time evaluation),\n     /// it is not always possible to determine the inequality of two pointers, so this function may\n-    /// spuriously return `false` for pointers that later actually turn out to be inequal.\n-    /// But when it returns `true`, the pointers are guaranteed to be inequal.\n+    /// spuriously return `false` for pointers that later actually turn out to be unequal.\n+    /// But when it returns `true`, the pointers are guaranteed to be unequal.\n     ///\n     /// This function is the mirror of [`guaranteed_eq`], but not its inverse. There are pointer\n     /// comparisons for which both functions return `false`."}, {"sha": "17fa90ecc08b5c81acc3e672bf9f3a6db429178d", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -317,13 +317,13 @@ impl<T: ?Sized> *mut T {\n         intrinsics::ptr_guaranteed_eq(self as *const _, other as *const _)\n     }\n \n-    /// Returns whether two pointers are guaranteed to be inequal.\n+    /// Returns whether two pointers are guaranteed to be unequal.\n     ///\n     /// At runtime this function behaves like `self != other`.\n     /// However, in some contexts (e.g., compile-time evaluation),\n     /// it is not always possible to determine the inequality of two pointers, so this function may\n-    /// spuriously return `false` for pointers that later actually turn out to be inequal.\n-    /// But when it returns `true`, the pointers are guaranteed to be inequal.\n+    /// spuriously return `false` for pointers that later actually turn out to be unequal.\n+    /// But when it returns `true`, the pointers are guaranteed to be unequal.\n     ///\n     /// This function is the mirror of [`guaranteed_eq`], but not its inverse. There are pointer\n     /// comparisons for which both functions return `false`."}, {"sha": "9f843a570990d615b795f7233734686b42675ed2", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -172,7 +172,7 @@ impl<T> NonNull<[T]> {\n     /// assert_eq!(unsafe { slice.as_ref()[2] }, 7);\n     /// ```\n     ///\n-    /// (Note that this example artifically demonstrates a use of this method,\n+    /// (Note that this example artificially demonstrates a use of this method,\n     /// but `let slice = NonNull::from(&x[..]);` would be a better way to write code like this.)\n     #[unstable(feature = \"nonnull_slice_from_raw_parts\", issue = \"71941\")]\n     #[rustc_const_unstable(feature = \"const_nonnull_slice_from_raw_parts\", issue = \"71941\")]"}, {"sha": "daf3e23d6a1234c2196fe76286000f792f60976c", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -1118,13 +1118,26 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_generics(&mut self, generics: &'a Generics) {\n         let mut prev_ty_default = None;\n         for param in &generics.params {\n-            if let GenericParamKind::Type { ref default, .. } = param.kind {\n-                if default.is_some() {\n+            match param.kind {\n+                GenericParamKind::Lifetime => (),\n+                GenericParamKind::Type { default: Some(_), .. } => {\n                     prev_ty_default = Some(param.ident.span);\n-                } else if let Some(span) = prev_ty_default {\n-                    self.err_handler()\n-                        .span_err(span, \"type parameters with a default must be trailing\");\n-                    break;\n+                }\n+                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n+                    if let Some(span) = prev_ty_default {\n+                        let mut err = self.err_handler().struct_span_err(\n+                            span,\n+                            \"type parameters with a default must be trailing\",\n+                        );\n+                        if matches!(param.kind, GenericParamKind::Const { .. }) {\n+                            err.note(\n+                                \"using type defaults and const parameters \\\n+                                 in the same parameter list is currently not permitted\",\n+                            );\n+                        }\n+                        err.emit();\n+                        break;\n+                    }\n                 }\n             }\n         }"}, {"sha": "33a3cdbfa9b443ff638b5e51d4f9c6bd3b851450", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -510,6 +510,14 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.wasm.trunc.saturate.signed.i32.f64\", fn(t_f64) -> t_i32);\n         ifn!(\"llvm.wasm.trunc.saturate.signed.i64.f32\", fn(t_f32) -> t_i64);\n         ifn!(\"llvm.wasm.trunc.saturate.signed.i64.f64\", fn(t_f64) -> t_i64);\n+        ifn!(\"llvm.wasm.trunc.unsigned.i32.f32\", fn(t_f32) -> t_i32);\n+        ifn!(\"llvm.wasm.trunc.unsigned.i32.f64\", fn(t_f64) -> t_i32);\n+        ifn!(\"llvm.wasm.trunc.unsigned.i64.f32\", fn(t_f32) -> t_i64);\n+        ifn!(\"llvm.wasm.trunc.unsigned.i64.f64\", fn(t_f64) -> t_i64);\n+        ifn!(\"llvm.wasm.trunc.signed.i32.f32\", fn(t_f32) -> t_i32);\n+        ifn!(\"llvm.wasm.trunc.signed.i32.f64\", fn(t_f64) -> t_i32);\n+        ifn!(\"llvm.wasm.trunc.signed.i64.f32\", fn(t_f32) -> t_i64);\n+        ifn!(\"llvm.wasm.trunc.signed.i64.f64\", fn(t_f64) -> t_i64);\n \n         ifn!(\"llvm.trap\", fn() -> void);\n         ifn!(\"llvm.debugtrap\", fn() -> void);"}, {"sha": "11b1c95c58b3e14e10dfb341bb1ccea0752fe4a5", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -629,27 +629,24 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n \n             sym::float_to_int_unchecked => {\n-                if float_type_width(arg_tys[0]).is_none() {\n-                    span_invalid_monomorphization_error(\n-                        tcx.sess,\n-                        span,\n-                        &format!(\n-                            \"invalid monomorphization of `float_to_int_unchecked` \\\n+                let float_width = match float_type_width(arg_tys[0]) {\n+                    Some(width) => width,\n+                    None => {\n+                        span_invalid_monomorphization_error(\n+                            tcx.sess,\n+                            span,\n+                            &format!(\n+                                \"invalid monomorphization of `float_to_int_unchecked` \\\n                                   intrinsic: expected basic float type, \\\n                                   found `{}`\",\n-                            arg_tys[0]\n-                        ),\n-                    );\n-                    return;\n-                }\n-                match int_type_width_signed(ret_ty, self.cx) {\n-                    Some((width, signed)) => {\n-                        if signed {\n-                            self.fptosi(args[0].immediate(), self.cx.type_ix(width))\n-                        } else {\n-                            self.fptoui(args[0].immediate(), self.cx.type_ix(width))\n-                        }\n+                                arg_tys[0]\n+                            ),\n+                        );\n+                        return;\n                     }\n+                };\n+                let (width, signed) = match int_type_width_signed(ret_ty, self.cx) {\n+                    Some(pair) => pair,\n                     None => {\n                         span_invalid_monomorphization_error(\n                             tcx.sess,\n@@ -663,7 +660,49 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                         );\n                         return;\n                     }\n+                };\n+\n+                // The LLVM backend can reorder and speculate `fptosi` and\n+                // `fptoui`, so on WebAssembly the codegen for this instruction\n+                // is quite heavyweight. To avoid this heavyweight codegen we\n+                // instead use the raw wasm intrinsics which will lower to one\n+                // instruction in WebAssembly (`iNN.trunc_fMM_{s,u}`). This one\n+                // instruction will trap if the operand is out of bounds, but\n+                // that's ok since this intrinsic is UB if the operands are out\n+                // of bounds, so the behavior can be different on WebAssembly\n+                // than other targets.\n+                //\n+                // Note, however, that when the `nontrapping-fptoint` feature is\n+                // enabled in LLVM then LLVM will lower `fptosi` to\n+                // `iNN.trunc_sat_fMM_{s,u}`, so if that's the case we don't\n+                // bother with intrinsics.\n+                let mut result = None;\n+                if self.sess().target.target.arch == \"wasm32\"\n+                    && !self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n+                {\n+                    let name = match (width, float_width, signed) {\n+                        (32, 32, true) => Some(\"llvm.wasm.trunc.signed.i32.f32\"),\n+                        (32, 64, true) => Some(\"llvm.wasm.trunc.signed.i32.f64\"),\n+                        (64, 32, true) => Some(\"llvm.wasm.trunc.signed.i64.f32\"),\n+                        (64, 64, true) => Some(\"llvm.wasm.trunc.signed.i64.f64\"),\n+                        (32, 32, false) => Some(\"llvm.wasm.trunc.unsigned.i32.f32\"),\n+                        (32, 64, false) => Some(\"llvm.wasm.trunc.unsigned.i32.f64\"),\n+                        (64, 32, false) => Some(\"llvm.wasm.trunc.unsigned.i64.f32\"),\n+                        (64, 64, false) => Some(\"llvm.wasm.trunc.unsigned.i64.f64\"),\n+                        _ => None,\n+                    };\n+                    if let Some(name) = name {\n+                        let intrinsic = self.get_intrinsic(name);\n+                        result = Some(self.call(intrinsic, &[args[0].immediate()], None));\n+                    }\n                 }\n+                result.unwrap_or_else(|| {\n+                    if signed {\n+                        self.fptosi(args[0].immediate(), self.cx.type_ix(width))\n+                    } else {\n+                        self.fptoui(args[0].immediate(), self.cx.type_ix(width))\n+                    }\n+                })\n             }\n \n             sym::discriminant_value => {"}, {"sha": "09f83ea5fca81c5eb42c2fa9dfd4218933699c1e", "filename": "src/libstd/backtrace.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbacktrace.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -291,6 +291,12 @@ impl Backtrace {\n         Backtrace::create(Backtrace::force_capture as usize)\n     }\n \n+    /// Forcibly captures a disabled backtrace, regardless of environment\n+    /// variable configuration.\n+    pub const fn disabled() -> Backtrace {\n+        Backtrace { inner: Inner::Disabled }\n+    }\n+\n     // Capture a backtrace which start just before the function addressed by\n     // `ip`\n     fn create(ip: usize) -> Backtrace {"}, {"sha": "c905bcf5e3db4255819b3c952eb5277012042add", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -1500,7 +1500,7 @@ mod tests {\n         assert_approx_eq!(f32::from_bits(0x44a72000), 1337.0);\n         assert_approx_eq!(f32::from_bits(0xc1640000), -14.25);\n \n-        // Check that NaNs roundtrip their bits regardless of signalingness\n+        // Check that NaNs roundtrip their bits regardless of signaling-ness\n         // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n         let masked_nan1 = f32::NAN.to_bits() ^ 0x002A_AAAA;\n         let masked_nan2 = f32::NAN.to_bits() ^ 0x0055_5555;"}, {"sha": "f09fc8d790b28faade6c3d0a2193263d32b07a42", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -1523,7 +1523,7 @@ mod tests {\n         assert_approx_eq!(f64::from_bits(0x4094e40000000000), 1337.0);\n         assert_approx_eq!(f64::from_bits(0xc02c800000000000), -14.25);\n \n-        // Check that NaNs roundtrip their bits regardless of signalingness\n+        // Check that NaNs roundtrip their bits regardless of signaling-ness\n         // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n         let masked_nan1 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n         let masked_nan2 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;"}, {"sha": "657737394ab82fe5feb1f29a57f2402cf1a2495c", "filename": "src/libstd/os/linux/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fos%2Flinux%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fos%2Flinux%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Flinux%2Ffs.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -285,7 +285,7 @@ pub trait MetadataExt {\n     /// ```\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_ctime_nsec(&self) -> i64;\n-    /// Returns the \"preferred\" blocksize for efficient filesystem I/O.\n+    /// Returns the \"preferred\" block size for efficient filesystem I/O.\n     ///\n     /// # Examples\n     ///"}, {"sha": "61b5bff380518674c4341fc74f121ea7a5381142", "filename": "src/libstd/os/redox/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fos%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fos%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fredox%2Ffs.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -289,7 +289,7 @@ pub trait MetadataExt {\n     /// ```\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_ctime_nsec(&self) -> i64;\n-    /// Returns the \"preferred\" blocksize for efficient filesystem I/O.\n+    /// Returns the \"preferred\" block size for efficient filesystem I/O.\n     ///\n     /// # Examples\n     ///"}, {"sha": "392c815ef2803a5002d03564d49e5f330c55e884", "filename": "src/libstd/path.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -2244,6 +2244,9 @@ impl Path {\n     ///\n     /// let path = Path::new(\"foo.rs\");\n     /// assert_eq!(path.with_extension(\"txt\"), PathBuf::from(\"foo.txt\"));\n+    ///\n+    /// let path = Path::new(\"foo.tar.gz\");\n+    /// assert_eq!(path.with_extension(\"\"), PathBuf::from(\"foo.tar\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf {"}, {"sha": "e5dc5b5adaa934a0ed34de571c425e2e231275da", "filename": "src/libstd/sys/sgx/fd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -19,7 +19,7 @@ impl FileDesc {\n         self.fd\n     }\n \n-    /// Extracts the actual filedescriptor without closing it.\n+    /// Extracts the actual file descriptor without closing it.\n     pub fn into_raw(self) -> Fd {\n         let fd = self.fd;\n         mem::forget(self);"}, {"sha": "f174a59b49a6ba51b01a1bc50f720ee2a6e4dd37", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -624,7 +624,7 @@ pub trait MetadataExt {\n     /// ```\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n     fn ctime_nsec(&self) -> i64;\n-    /// Returns the blocksize for filesystem I/O.\n+    /// Returns the block size for filesystem I/O.\n     ///\n     /// # Examples\n     ///\n@@ -635,7 +635,7 @@ pub trait MetadataExt {\n     ///\n     /// fn main() -> io::Result<()> {\n     ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let blocksize = meta.blksize();\n+    ///     let block_size = meta.blksize();\n     ///     Ok(())\n     /// }\n     /// ```"}, {"sha": "84c4d662161bca7fac8a938c71e5799618787e10", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 20, "deletions": 61, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -3,28 +3,28 @@\n use crate::cmp;\n use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read};\n use crate::mem;\n-use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sys::cvt;\n use crate::sys_common::AsInner;\n \n-use libc::{c_int, c_void, ssize_t};\n+use libc::{c_int, c_void};\n \n #[derive(Debug)]\n pub struct FileDesc {\n     fd: c_int,\n }\n \n-fn max_len() -> usize {\n-    // The maximum read limit on most posix-like systems is `SSIZE_MAX`,\n-    // with the man page quoting that if the count of bytes to read is\n-    // greater than `SSIZE_MAX` the result is \"unspecified\".\n-    //\n-    // On macOS, however, apparently the 64-bit libc is either buggy or\n-    // intentionally showing odd behavior by rejecting any read with a size\n-    // larger than or equal to INT_MAX. To handle both of these the read\n-    // size is capped on both platforms.\n-    if cfg!(target_os = \"macos\") { <c_int>::MAX as usize - 1 } else { <ssize_t>::MAX as usize }\n-}\n+// The maximum read limit on most POSIX-like systems is `SSIZE_MAX`,\n+// with the man page quoting that if the count of bytes to read is\n+// greater than `SSIZE_MAX` the result is \"unspecified\".\n+//\n+// On macOS, however, apparently the 64-bit libc is either buggy or\n+// intentionally showing odd behavior by rejecting any read with a size\n+// larger than or equal to INT_MAX. To handle both of these the read\n+// size is capped on both platforms.\n+#[cfg(target_os = \"macos\")]\n+const READ_LIMIT: usize = c_int::MAX as usize - 1;\n+#[cfg(not(target_os = \"macos\"))]\n+const READ_LIMIT: usize = libc::ssize_t::MAX as usize;\n \n impl FileDesc {\n     pub fn new(fd: c_int) -> FileDesc {\n@@ -44,7 +44,7 @@ impl FileDesc {\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::read(self.fd, buf.as_mut_ptr() as *mut c_void, cmp::min(buf.len(), max_len()))\n+            libc::read(self.fd, buf.as_mut_ptr() as *mut c_void, cmp::min(buf.len(), READ_LIMIT))\n         })?;\n         Ok(ret as usize)\n     }\n@@ -92,7 +92,7 @@ impl FileDesc {\n             cvt_pread64(\n                 self.fd,\n                 buf.as_mut_ptr() as *mut c_void,\n-                cmp::min(buf.len(), max_len()),\n+                cmp::min(buf.len(), READ_LIMIT),\n                 offset as i64,\n             )\n             .map(|n| n as usize)\n@@ -101,7 +101,7 @@ impl FileDesc {\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::write(self.fd, buf.as_ptr() as *const c_void, cmp::min(buf.len(), max_len()))\n+            libc::write(self.fd, buf.as_ptr() as *const c_void, cmp::min(buf.len(), READ_LIMIT))\n         })?;\n         Ok(ret as usize)\n     }\n@@ -144,7 +144,7 @@ impl FileDesc {\n             cvt_pwrite64(\n                 self.fd,\n                 buf.as_ptr() as *const c_void,\n-                cmp::min(buf.len(), max_len()),\n+                cmp::min(buf.len(), READ_LIMIT),\n                 offset as i64,\n             )\n             .map(|n| n as usize)\n@@ -223,50 +223,9 @@ impl FileDesc {\n     pub fn duplicate(&self) -> io::Result<FileDesc> {\n         // We want to atomically duplicate this file descriptor and set the\n         // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n-        // flag, however, isn't supported on older Linux kernels (earlier than\n-        // 2.6.24).\n-        //\n-        // To detect this and ensure that CLOEXEC is still set, we\n-        // follow a strategy similar to musl [1] where if passing\n-        // F_DUPFD_CLOEXEC causes `fcntl` to return EINVAL it means it's not\n-        // supported (the third parameter, 0, is always valid), so we stop\n-        // trying that.\n-        //\n-        // Also note that Android doesn't have F_DUPFD_CLOEXEC, but get it to\n-        // resolve so we at least compile this.\n-        //\n-        // [1]: http://comments.gmane.org/gmane.linux.lib.musl.general/2963\n-        #[cfg(any(target_os = \"android\", target_os = \"haiku\"))]\n-        use libc::F_DUPFD as F_DUPFD_CLOEXEC;\n-        #[cfg(not(any(target_os = \"android\", target_os = \"haiku\")))]\n-        use libc::F_DUPFD_CLOEXEC;\n-\n-        let make_filedesc = |fd| {\n-            let fd = FileDesc::new(fd);\n-            fd.set_cloexec()?;\n-            Ok(fd)\n-        };\n-        static TRY_CLOEXEC: AtomicBool = AtomicBool::new(!cfg!(target_os = \"android\"));\n-        let fd = self.raw();\n-        if TRY_CLOEXEC.load(Ordering::Relaxed) {\n-            match cvt(unsafe { libc::fcntl(fd, F_DUPFD_CLOEXEC, 0) }) {\n-                // We *still* call the `set_cloexec` method as apparently some\n-                // linux kernel at some point stopped setting CLOEXEC even\n-                // though it reported doing so on F_DUPFD_CLOEXEC.\n-                Ok(fd) => {\n-                    return Ok(if cfg!(target_os = \"linux\") {\n-                        make_filedesc(fd)?\n-                    } else {\n-                        FileDesc::new(fd)\n-                    });\n-                }\n-                Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {\n-                    TRY_CLOEXEC.store(false, Ordering::Relaxed);\n-                }\n-                Err(e) => return Err(e),\n-            }\n-        }\n-        cvt(unsafe { libc::fcntl(fd, libc::F_DUPFD, 0) }).and_then(make_filedesc)\n+        // is a POSIX flag that was added to Linux in 2.6.24.\n+        let fd = cvt(unsafe { libc::fcntl(self.raw(), libc::F_DUPFD_CLOEXEC, 0) })?;\n+        Ok(FileDesc::new(fd))\n     }\n }\n "}, {"sha": "acb18e6d064e6e826d0e3910035e12fd516f1e98", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 50, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -708,56 +708,7 @@ impl File {\n         // However, since this is a variadic function, C integer promotion rules mean that on\n         // the ABI level, this still gets passed as `c_int` (aka `u32` on Unix platforms).\n         let fd = cvt_r(|| unsafe { open64(path.as_ptr(), flags, opts.mode as c_int) })?;\n-        let fd = FileDesc::new(fd);\n-\n-        // Currently the standard library supports Linux 2.6.18 which did not\n-        // have the O_CLOEXEC flag (passed above). If we're running on an older\n-        // Linux kernel then the flag is just ignored by the OS. After we open\n-        // the first file, we check whether it has CLOEXEC set. If it doesn't,\n-        // we will explicitly ask for a CLOEXEC fd for every further file we\n-        // open, if it does, we will skip that step.\n-        //\n-        // The CLOEXEC flag, however, is supported on versions of macOS/BSD/etc\n-        // that we support, so we only do this on Linux currently.\n-        #[cfg(target_os = \"linux\")]\n-        fn ensure_cloexec(fd: &FileDesc) -> io::Result<()> {\n-            use crate::sync::atomic::{AtomicUsize, Ordering};\n-\n-            const OPEN_CLOEXEC_UNKNOWN: usize = 0;\n-            const OPEN_CLOEXEC_SUPPORTED: usize = 1;\n-            const OPEN_CLOEXEC_NOTSUPPORTED: usize = 2;\n-            static OPEN_CLOEXEC: AtomicUsize = AtomicUsize::new(OPEN_CLOEXEC_UNKNOWN);\n-\n-            let need_to_set;\n-            match OPEN_CLOEXEC.load(Ordering::Relaxed) {\n-                OPEN_CLOEXEC_UNKNOWN => {\n-                    need_to_set = !fd.get_cloexec()?;\n-                    OPEN_CLOEXEC.store(\n-                        if need_to_set {\n-                            OPEN_CLOEXEC_NOTSUPPORTED\n-                        } else {\n-                            OPEN_CLOEXEC_SUPPORTED\n-                        },\n-                        Ordering::Relaxed,\n-                    );\n-                }\n-                OPEN_CLOEXEC_SUPPORTED => need_to_set = false,\n-                OPEN_CLOEXEC_NOTSUPPORTED => need_to_set = true,\n-                _ => unreachable!(),\n-            }\n-            if need_to_set {\n-                fd.set_cloexec()?;\n-            }\n-            Ok(())\n-        }\n-\n-        #[cfg(not(target_os = \"linux\"))]\n-        fn ensure_cloexec(_: &FileDesc) -> io::Result<()> {\n-            Ok(())\n-        }\n-\n-        ensure_cloexec(&fd)?;\n-        Ok(File(fd))\n+        Ok(File(FileDesc::new(fd)))\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {"}, {"sha": "011325fddc5b93b08304406256bcc748d7e8e3eb", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 42, "deletions": 61, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -54,56 +54,47 @@ impl Socket {\n \n     pub fn new_raw(fam: c_int, ty: c_int) -> io::Result<Socket> {\n         unsafe {\n-            // On linux we first attempt to pass the SOCK_CLOEXEC flag to\n-            // atomically create the socket and set it as CLOEXEC. Support for\n-            // this option, however, was added in 2.6.27, and we still support\n-            // 2.6.18 as a kernel, so if the returned error is EINVAL we\n-            // fallthrough to the fallback.\n-            #[cfg(target_os = \"linux\")]\n-            {\n-                match cvt(libc::socket(fam, ty | libc::SOCK_CLOEXEC, 0)) {\n-                    Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n-                    Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {}\n-                    Err(e) => return Err(e),\n-                }\n-            }\n-\n-            let fd = cvt(libc::socket(fam, ty, 0))?;\n-            let fd = FileDesc::new(fd);\n-            fd.set_cloexec()?;\n-            let socket = Socket(fd);\n+            cfg_if::cfg_if! {\n+                if #[cfg(target_os = \"linux\")] {\n+                    // On Linux we pass the SOCK_CLOEXEC flag to atomically create\n+                    // the socket and set it as CLOEXEC, added in 2.6.27.\n+                    let fd = cvt(libc::socket(fam, ty | libc::SOCK_CLOEXEC, 0))?;\n+                    Ok(Socket(FileDesc::new(fd)))\n+                } else {\n+                    let fd = cvt(libc::socket(fam, ty, 0))?;\n+                    let fd = FileDesc::new(fd);\n+                    fd.set_cloexec()?;\n+                    let socket = Socket(fd);\n \n-            // macOS and iOS use `SO_NOSIGPIPE` as a `setsockopt`\n-            // flag to disable `SIGPIPE` emission on socket.\n-            #[cfg(target_vendor = \"apple\")]\n-            setsockopt(&socket, libc::SOL_SOCKET, libc::SO_NOSIGPIPE, 1)?;\n+                    // macOS and iOS use `SO_NOSIGPIPE` as a `setsockopt`\n+                    // flag to disable `SIGPIPE` emission on socket.\n+                    #[cfg(target_vendor = \"apple\")]\n+                    setsockopt(&socket, libc::SOL_SOCKET, libc::SO_NOSIGPIPE, 1)?;\n \n-            Ok(socket)\n+                    Ok(socket)\n+                }\n+            }\n         }\n     }\n \n     pub fn new_pair(fam: c_int, ty: c_int) -> io::Result<(Socket, Socket)> {\n         unsafe {\n             let mut fds = [0, 0];\n \n-            // Like above, see if we can set cloexec atomically\n-            #[cfg(target_os = \"linux\")]\n-            {\n-                match cvt(libc::socketpair(fam, ty | libc::SOCK_CLOEXEC, 0, fds.as_mut_ptr())) {\n-                    Ok(_) => {\n-                        return Ok((Socket(FileDesc::new(fds[0])), Socket(FileDesc::new(fds[1]))));\n-                    }\n-                    Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {}\n-                    Err(e) => return Err(e),\n+            cfg_if::cfg_if! {\n+                if #[cfg(target_os = \"linux\")] {\n+                    // Like above, set cloexec atomically\n+                    cvt(libc::socketpair(fam, ty | libc::SOCK_CLOEXEC, 0, fds.as_mut_ptr()))?;\n+                    Ok((Socket(FileDesc::new(fds[0])), Socket(FileDesc::new(fds[1]))))\n+                } else {\n+                    cvt(libc::socketpair(fam, ty, 0, fds.as_mut_ptr()))?;\n+                    let a = FileDesc::new(fds[0]);\n+                    let b = FileDesc::new(fds[1]);\n+                    a.set_cloexec()?;\n+                    b.set_cloexec()?;\n+                    Ok((Socket(a), Socket(b)))\n                 }\n             }\n-\n-            cvt(libc::socketpair(fam, ty, 0, fds.as_mut_ptr()))?;\n-            let a = FileDesc::new(fds[0]);\n-            let b = FileDesc::new(fds[1]);\n-            a.set_cloexec()?;\n-            b.set_cloexec()?;\n-            Ok((Socket(a), Socket(b)))\n         }\n     }\n \n@@ -177,30 +168,20 @@ impl Socket {\n     pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t) -> io::Result<Socket> {\n         // Unfortunately the only known way right now to accept a socket and\n         // atomically set the CLOEXEC flag is to use the `accept4` syscall on\n-        // Linux. This was added in 2.6.28, however, and because we support\n-        // 2.6.18 we must detect this support dynamically.\n-        #[cfg(target_os = \"linux\")]\n-        {\n-            syscall! {\n-                fn accept4(\n-                    fd: c_int,\n-                    addr: *mut sockaddr,\n-                    addr_len: *mut socklen_t,\n-                    flags: c_int\n-                ) -> c_int\n-            }\n-            let res = cvt_r(|| unsafe { accept4(self.0.raw(), storage, len, libc::SOCK_CLOEXEC) });\n-            match res {\n-                Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n-                Err(ref e) if e.raw_os_error() == Some(libc::ENOSYS) => {}\n-                Err(e) => return Err(e),\n+        // Linux. This was added in 2.6.28, glibc 2.10 and musl 0.9.5.\n+        cfg_if::cfg_if! {\n+            if #[cfg(target_os = \"linux\")] {\n+                let fd = cvt_r(|| unsafe {\n+                    libc::accept4(self.0.raw(), storage, len, libc::SOCK_CLOEXEC)\n+                })?;\n+                Ok(Socket(FileDesc::new(fd)))\n+            } else {\n+                let fd = cvt_r(|| unsafe { libc::accept(self.0.raw(), storage, len) })?;\n+                let fd = FileDesc::new(fd);\n+                fd.set_cloexec()?;\n+                Ok(Socket(fd))\n             }\n         }\n-\n-        let fd = cvt_r(|| unsafe { libc::accept(self.0.raw(), storage, len) })?;\n-        let fd = FileDesc::new(fd);\n-        fd.set_cloexec()?;\n-        Ok(Socket(fd))\n     }\n \n     pub fn duplicate(&self) -> io::Result<Socket> {"}, {"sha": "2fcb5b9c4e66e722098efde38810b1ab60389582", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -71,6 +71,7 @@ pub fn errno() -> i32 {\n \n /// Sets the platform-specific value of errno\n #[cfg(all(not(target_os = \"linux\"), not(target_os = \"dragonfly\")))] // needed for readdir and syscall!\n+#[allow(dead_code)] // but not all target cfgs actually end up using it\n pub fn set_errno(e: i32) {\n     unsafe { *errno_location() = e as c_int }\n }"}, {"sha": "7ae37bdda70bded963b72d304b7abbbbfed904a9", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 22, "deletions": 39, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -1,58 +1,41 @@\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::mem;\n-use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sys::fd::FileDesc;\n use crate::sys::{cvt, cvt_r};\n \n-use libc::c_int;\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Anonymous pipes\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct AnonPipe(FileDesc);\n \n pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n-    syscall! { fn pipe2(fds: *mut c_int, flags: c_int) -> c_int }\n-    static INVALID: AtomicBool = AtomicBool::new(false);\n-\n     let mut fds = [0; 2];\n \n-    // Unfortunately the only known way right now to create atomically set the\n-    // CLOEXEC flag is to use the `pipe2` syscall on Linux. This was added in\n-    // 2.6.27, however, and because we support 2.6.18 we must detect this\n-    // support dynamically.\n-    if cfg!(any(\n-        target_os = \"dragonfly\",\n-        target_os = \"freebsd\",\n-        target_os = \"linux\",\n-        target_os = \"netbsd\",\n-        target_os = \"openbsd\",\n-        target_os = \"redox\"\n-    )) && !INVALID.load(Ordering::SeqCst)\n-    {\n-        // Note that despite calling a glibc function here we may still\n-        // get ENOSYS. Glibc has `pipe2` since 2.9 and doesn't try to\n-        // emulate on older kernels, so if you happen to be running on\n-        // an older kernel you may see `pipe2` as a symbol but still not\n-        // see the syscall.\n-        match cvt(unsafe { pipe2(fds.as_mut_ptr(), libc::O_CLOEXEC) }) {\n-            Ok(_) => {\n-                return Ok((AnonPipe(FileDesc::new(fds[0])), AnonPipe(FileDesc::new(fds[1]))));\n-            }\n-            Err(ref e) if e.raw_os_error() == Some(libc::ENOSYS) => {\n-                INVALID.store(true, Ordering::SeqCst);\n-            }\n-            Err(e) => return Err(e),\n+    // The only known way right now to create atomically set the CLOEXEC flag is\n+    // to use the `pipe2` syscall. This was added to Linux in 2.6.27, glibc 2.9\n+    // and musl 0.9.3, and some other targets also have it.\n+    cfg_if::cfg_if! {\n+        if #[cfg(any(\n+            target_os = \"dragonfly\",\n+            target_os = \"freebsd\",\n+            target_os = \"linux\",\n+            target_os = \"netbsd\",\n+            target_os = \"openbsd\",\n+            target_os = \"redox\"\n+        ))] {\n+            cvt(unsafe { libc::pipe2(fds.as_mut_ptr(), libc::O_CLOEXEC) })?;\n+            Ok((AnonPipe(FileDesc::new(fds[0])), AnonPipe(FileDesc::new(fds[1]))))\n+        } else {\n+            cvt(unsafe { libc::pipe(fds.as_mut_ptr()) })?;\n+\n+            let fd0 = FileDesc::new(fds[0]);\n+            let fd1 = FileDesc::new(fds[1]);\n+            fd0.set_cloexec()?;\n+            fd1.set_cloexec()?;\n+            Ok((AnonPipe(fd0), AnonPipe(fd1)))\n         }\n     }\n-    cvt(unsafe { libc::pipe(fds.as_mut_ptr()) })?;\n-\n-    let fd0 = FileDesc::new(fds[0]);\n-    let fd1 = FileDesc::new(fds[1]);\n-    fd0.set_cloexec()?;\n-    fd1.set_cloexec()?;\n-    Ok((AnonPipe(fd0), AnonPipe(fd1)))\n }\n \n impl AnonPipe {"}, {"sha": "f4b33a00f7c85d79d8b682be0884024283a529f0", "filename": "src/libstd/sys/unix/weak.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fweak.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -16,6 +16,11 @@\n //! symbol, but that caused Debian to detect an unnecessarily strict versioned\n //! dependency on libc6 (#23628).\n \n+// There are a variety of `#[cfg]`s controlling which targets are involved in\n+// each instance of `weak!` and `syscall!`. Rather than trying to unify all of\n+// that, we'll just allow that some unix targets don't use this module at all.\n+#![allow(dead_code, unused_macros)]\n+\n use crate::ffi::CStr;\n use crate::marker;\n use crate::mem;"}, {"sha": "ea186846929be135479736277e31ece1035b4960", "filename": "src/libstd/sys/vxworks/fd.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -13,12 +13,10 @@ pub struct FileDesc {\n     fd: c_int,\n }\n \n-fn max_len() -> usize {\n-    // The maximum read limit on most posix-like systems is `SSIZE_MAX`,\n-    // with the man page quoting that if the count of bytes to read is\n-    // greater than `SSIZE_MAX` the result is \"unspecified\".\n-    <ssize_t>::MAX as usize\n-}\n+// The maximum read limit on most POSIX-like systems is `SSIZE_MAX`,\n+// with the man page quoting that if the count of bytes to read is\n+// greater than `SSIZE_MAX` the result is \"unspecified\".\n+const READ_LIMIT: usize = ssize_t::MAX as usize;\n \n impl FileDesc {\n     pub fn new(fd: c_int) -> FileDesc {\n@@ -29,7 +27,7 @@ impl FileDesc {\n         self.fd\n     }\n \n-    /// Extracts the actual filedescriptor without closing it.\n+    /// Extracts the actual file descriptor without closing it.\n     pub fn into_raw(self) -> c_int {\n         let fd = self.fd;\n         mem::forget(self);\n@@ -38,7 +36,7 @@ impl FileDesc {\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::read(self.fd, buf.as_mut_ptr() as *mut c_void, cmp::min(buf.len(), max_len()))\n+            libc::read(self.fd, buf.as_mut_ptr() as *mut c_void, cmp::min(buf.len(), READ_LIMIT))\n         })?;\n         Ok(ret as usize)\n     }\n@@ -79,7 +77,7 @@ impl FileDesc {\n             cvt_pread(\n                 self.fd,\n                 buf.as_mut_ptr() as *mut c_void,\n-                cmp::min(buf.len(), max_len()),\n+                cmp::min(buf.len(), READ_LIMIT),\n                 offset as i64,\n             )\n             .map(|n| n as usize)\n@@ -88,7 +86,7 @@ impl FileDesc {\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::write(self.fd, buf.as_ptr() as *const c_void, cmp::min(buf.len(), max_len()))\n+            libc::write(self.fd, buf.as_ptr() as *const c_void, cmp::min(buf.len(), READ_LIMIT))\n         })?;\n         Ok(ret as usize)\n     }\n@@ -124,7 +122,7 @@ impl FileDesc {\n             cvt_pwrite(\n                 self.fd,\n                 buf.as_ptr() as *const c_void,\n-                cmp::min(buf.len(), max_len()),\n+                cmp::min(buf.len(), READ_LIMIT),\n                 offset as i64,\n             )\n             .map(|n| n as usize)"}, {"sha": "8f46f4d284f0bf71ad499c3457da75c9faac5a55", "filename": "src/libstd/sys/vxworks/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Fvxworks%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Fvxworks%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ftime.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -1,6 +1,6 @@\n use crate::cmp::Ordering;\n use crate::time::Duration;\n-use ::core::hash::{Hash, Hasher};\n+use core::hash::{Hash, Hasher};\n \n pub use self::inner::{Instant, SystemTime, UNIX_EPOCH};\n use crate::convert::TryInto;"}, {"sha": "2eed9e436a956003a200a6af668024da9b786f0c", "filename": "src/libstd/sys/wasi/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -597,14 +597,14 @@ fn open_at(fd: &WasiFd, path: &Path, opts: &OpenOptions) -> io::Result<File> {\n ///\n /// WASI has no fundamental capability to do this. All syscalls and operations\n /// are relative to already-open file descriptors. The C library, however,\n-/// manages a map of preopened file descriptors to their path, and then the C\n+/// manages a map of pre-opened file descriptors to their path, and then the C\n /// library provides an API to look at this. In other words, when you want to\n /// open a path `p`, you have to find a previously opened file descriptor in a\n /// global table and then see if `p` is relative to that file descriptor.\n ///\n /// This function, if successful, will return two items:\n ///\n-/// * The first is a `ManuallyDrop<WasiFd>`. This represents a preopened file\n+/// * The first is a `ManuallyDrop<WasiFd>`. This represents a pre-opened file\n ///   descriptor which we don't have ownership of, but we can use. You shouldn't\n ///   actually drop the `fd`.\n ///\n@@ -619,15 +619,15 @@ fn open_at(fd: &WasiFd, path: &Path, opts: &OpenOptions) -> io::Result<File> {\n /// appropriate rights for performing `rights` actions.\n ///\n /// Note that this can fail if `p` doesn't look like it can be opened relative\n-/// to any preopened file descriptor.\n+/// to any pre-opened file descriptor.\n fn open_parent(p: &Path) -> io::Result<(ManuallyDrop<WasiFd>, PathBuf)> {\n     let p = CString::new(p.as_os_str().as_bytes())?;\n     unsafe {\n         let mut ret = ptr::null();\n         let fd = __wasilibc_find_relpath(p.as_ptr(), &mut ret);\n         if fd == -1 {\n             let msg = format!(\n-                \"failed to find a preopened file descriptor \\\n+                \"failed to find a pre-opened file descriptor \\\n                  through which {:?} could be opened\",\n                 p\n             );"}, {"sha": "4e3bfcd439744cb77b60cdbcc8575cb9a4e3441f", "filename": "src/test/codegen/unchecked-float-casts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -2,6 +2,7 @@\n // unchecked intrinsics.\n \n // compile-flags: -C opt-level=3\n+// ignore-wasm32 the wasm target is tested in `wasm_casts_*`\n \n #![crate_type = \"lib\"]\n "}, {"sha": "b7f8522fdfb033664327e8e7a65d84e1730af16c", "filename": "src/test/codegen/wasm_casts_trapping.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fwasm_casts_trapping.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -38,7 +38,6 @@ pub fn cast_f32_i32(a: f32) -> i32 {\n     a as _\n }\n \n-\n // CHECK-LABEL: @cast_f64_u64\n #[no_mangle]\n pub fn cast_f64_u64(a: f64) -> u64 {\n@@ -84,77 +83,66 @@ pub fn cast_f32_u8(a: f32) -> u8 {\n     a as _\n }\n \n-\n-\n // CHECK-LABEL: @cast_unchecked_f64_i64\n #[no_mangle]\n pub unsafe fn cast_unchecked_f64_i64(a: f64) -> i64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi double {{.*}} to i64\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.signed.{{.*}}\n     // CHECK-NEXT: ret i64 {{.*}}\n     a.to_int_unchecked()\n }\n \n // CHECK-LABEL: @cast_unchecked_f64_i32\n #[no_mangle]\n pub unsafe fn cast_unchecked_f64_i32(a: f64) -> i32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi double {{.*}} to i32\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.signed.{{.*}}\n     // CHECK-NEXT: ret i32 {{.*}}\n     a.to_int_unchecked()\n }\n \n // CHECK-LABEL: @cast_unchecked_f32_i64\n #[no_mangle]\n pub unsafe fn cast_unchecked_f32_i64(a: f32) -> i64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi float {{.*}} to i64\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.signed.{{.*}}\n     // CHECK-NEXT: ret i64 {{.*}}\n     a.to_int_unchecked()\n }\n \n // CHECK-LABEL: @cast_unchecked_f32_i32\n #[no_mangle]\n pub unsafe fn cast_unchecked_f32_i32(a: f32) -> i32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptosi float {{.*}} to i32\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.signed.{{.*}}\n     // CHECK-NEXT: ret i32 {{.*}}\n     a.to_int_unchecked()\n }\n \n-\n // CHECK-LABEL: @cast_unchecked_f64_u64\n #[no_mangle]\n pub unsafe fn cast_unchecked_f64_u64(a: f64) -> u64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui double {{.*}} to i64\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.unsigned.{{.*}}\n     // CHECK-NEXT: ret i64 {{.*}}\n     a.to_int_unchecked()\n }\n \n // CHECK-LABEL: @cast_unchecked_f64_u32\n #[no_mangle]\n pub unsafe fn cast_unchecked_f64_u32(a: f64) -> u32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui double {{.*}} to i32\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.unsigned.{{.*}}\n     // CHECK-NEXT: ret i32 {{.*}}\n     a.to_int_unchecked()\n }\n \n // CHECK-LABEL: @cast_unchecked_f32_u64\n #[no_mangle]\n pub unsafe fn cast_unchecked_f32_u64(a: f32) -> u64 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui float {{.*}} to i64\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.unsigned.{{.*}}\n     // CHECK-NEXT: ret i64 {{.*}}\n     a.to_int_unchecked()\n }\n \n // CHECK-LABEL: @cast_unchecked_f32_u32\n #[no_mangle]\n pub unsafe fn cast_unchecked_f32_u32(a: f32) -> u32 {\n-    // CHECK-NOT: {{.*}} call {{.*}} @llvm.wasm.trunc.{{.*}}\n-    // CHECK: fptoui float {{.*}} to i32\n+    // CHECK: {{.*}} call {{.*}} @llvm.wasm.trunc.unsigned.{{.*}}\n     // CHECK-NEXT: ret i32 {{.*}}\n     a.to_int_unchecked()\n }"}, {"sha": "7f17c6358b7b6c8e21bdead470a1579912b9d872", "filename": "src/test/ui/const-generics/defaults/wrong-order.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwrong-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwrong-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwrong-order.rs?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -0,0 +1,8 @@\n+#![feature(const_generics)] //~ WARN the feature `const_generics` is incomplete\n+\n+struct A<T = u32, const N: usize> {\n+    //~^ ERROR type parameters with a default must be trailing\n+    arg: T,\n+}\n+\n+fn main() {}"}, {"sha": "283f6656121c3192cb8a4b1726de0da0c532fe51", "filename": "src/test/ui/const-generics/defaults/wrong-order.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwrong-order.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bbfa02b1b15974d5772b520aa027bf79f8c248e/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwrong-order.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwrong-order.stderr?ref=2bbfa02b1b15974d5772b520aa027bf79f8c248e", "patch": "@@ -0,0 +1,19 @@\n+error: type parameters with a default must be trailing\n+  --> $DIR/wrong-order.rs:3:10\n+   |\n+LL | struct A<T = u32, const N: usize> {\n+   |          ^\n+   |\n+   = note: using type defaults and const parameters in the same parameter list is currently not permitted\n+\n+warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/wrong-order.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}]}