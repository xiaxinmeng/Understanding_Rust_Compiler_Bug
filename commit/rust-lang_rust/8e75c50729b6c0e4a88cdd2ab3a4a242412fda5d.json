{"sha": "8e75c50729b6c0e4a88cdd2ab3a4a242412fda5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNzVjNTA3MjliNmMwZTRhODhjZGQyYWIzYTRhMjQyNDEyZmRhNWQ=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-21T16:41:45Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-21T16:41:45Z"}, "message": "community fixups", "tree": {"sha": "af4038adb6d7bea70142f9316462a1041e4af467", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af4038adb6d7bea70142f9316462a1041e4af467"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e75c50729b6c0e4a88cdd2ab3a4a242412fda5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e75c50729b6c0e4a88cdd2ab3a4a242412fda5d", "html_url": "https://github.com/rust-lang/rust/commit/8e75c50729b6c0e4a88cdd2ab3a4a242412fda5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e75c50729b6c0e4a88cdd2ab3a4a242412fda5d/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9997a6eb270041c1479a4b0e42c987344c1ceee4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9997a6eb270041c1479a4b0e42c987344c1ceee4", "html_url": "https://github.com/rust-lang/rust/commit/9997a6eb270041c1479a4b0e42c987344c1ceee4"}], "stats": {"total": 22, "additions": 11, "deletions": 11}, "files": [{"sha": "f9163caa4e003d5182bc425ff9f190ae324b0035", "filename": "data.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e75c50729b6c0e4a88cdd2ab3a4a242412fda5d/data.md", "raw_url": "https://github.com/rust-lang/rust/raw/8e75c50729b6c0e4a88cdd2ab3a4a242412fda5d/data.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/data.md?ref=8e75c50729b6c0e4a88cdd2ab3a4a242412fda5d", "patch": "@@ -88,7 +88,7 @@ struct Foo<u32, u16> {\n }\n ```\n \n-The former case quite simply wastes space. An optimal use of space therefore requires\n+The latter case quite simply wastes space. An optimal use of space therefore requires\n different monomorphizations to *have different field orderings*.\n \n **Note: this is a hypothetical optimization that is not yet implemented in Rust 1.0.0**"}, {"sha": "d6711e7df41b7d186671a58d311d8c5e5658155a", "filename": "lifetimes.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8e75c50729b6c0e4a88cdd2ab3a4a242412fda5d/lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/8e75c50729b6c0e4a88cdd2ab3a4a242412fda5d/lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lifetimes.md?ref=8e75c50729b6c0e4a88cdd2ab3a4a242412fda5d", "patch": "@@ -247,11 +247,11 @@ Of course, it might be bounded by the *wrong* lifetime, but this will usually\n just cause a compiler error, rather than allow memory safety to be trivially\n violated.\n \n-Within a function, bounding lifetimes is more error-prone. The safest route\n-is to just use a small function to ensure the lifetime is bound. However if\n-this is unacceptable, the reference can be placed in a location with a specific\n-lifetime. Unfortunately it's impossible to name all lifetimes involved in a\n-function. To get around this, you can in principle use `copy_lifetime`, though\n+Within a function, bounding lifetimes is more error-prone. The safest and easiest\n+way to bound a lifetime is to return it from a function with a bound lifetime.\n+However if this is unacceptable, the reference can be placed in a location with\n+a specific lifetime. Unfortunately it's impossible to name all lifetimes involved\n+in a function. To get around this, you can in principle use `copy_lifetime`, though\n these are unstable due to their awkward nature and questionable utility.\n \n \n@@ -425,7 +425,7 @@ must be invariant to avoid lifetime smuggling.\n \n `Fn` is the most confusing case, largely because contravariance is easily the\n most confusing kind of variance, and basically never comes up. To understand it,\n-consider a function that *takes* a function `len` that takes a function `F`.\n+consider a function `len` that takes a function `F`.\n \n ```rust\n fn len<F>(func: F) -> usize\n@@ -435,8 +435,8 @@ fn len<F>(func: F) -> usize\n }\n ```\n \n-We require that F is a Fn that can take an `&'static str` and print a usize. Now\n-say we have a function that can take an `&'a str` (for *some* 'a). Such a function actually\n+We require that F is a Fn that can take an `&'static str` and returns a usize. Now\n+say we have a function that can take an `&'a str` (for *some* `'a`). Such a function actually\n accepts *more* inputs, since `&'static str` is a subtype of `&'a str`. Therefore\n `len` should happily accept such a function!\n \n@@ -643,8 +643,8 @@ trait Iterator {\n Given this definition, Self::Item has *no* connection to `self`. This means\n that we can call `next` several times in a row, and hold onto all the results\n *concurrently*. This is perfectly fine for by-value iterators, which have exactly\n-these semantics. It's also actually fine for shared references, as it's perfectly\n-fine to grab a huge pile of shared references to the same thing (although the\n+these semantics. It's also actually fine for shared references, as they admit\n+arbitrarily many references to the same thing (although the\n iterator needs to be a separate object from the thing being shared). But mutable\n references make this a mess. At first glance, they might seem completely\n incompatible with this API, as it would produce multiple mutable references to"}]}