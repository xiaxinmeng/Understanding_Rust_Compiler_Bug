{"sha": "a2489495d909c43cfbefaeb79db6a77b13908257", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNDg5NDk1ZDkwOWM0M2NmYmVmYWViNzlkYjZhNzdiMTM5MDgyNTc=", "commit": {"author": {"name": "Daniel Keep", "email": "daniel.keep@gmail.com", "date": "2016-04-24T16:04:01Z"}, "committer": {"name": "Alex Burka", "email": "alex@alexburka.com", "date": "2017-04-15T19:06:19Z"}, "message": "Implementation of the `vis` macro matcher.", "tree": {"sha": "dbd1690433ffb36b6bad7a56c3923e9313f0529a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbd1690433ffb36b6bad7a56c3923e9313f0529a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2489495d909c43cfbefaeb79db6a77b13908257", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2489495d909c43cfbefaeb79db6a77b13908257", "html_url": "https://github.com/rust-lang/rust/commit/a2489495d909c43cfbefaeb79db6a77b13908257", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2489495d909c43cfbefaeb79db6a77b13908257/comments", "author": {"login": "DanielKeep", "id": 77238, "node_id": "MDQ6VXNlcjc3MjM4", "avatar_url": "https://avatars.githubusercontent.com/u/77238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DanielKeep", "html_url": "https://github.com/DanielKeep", "followers_url": "https://api.github.com/users/DanielKeep/followers", "following_url": "https://api.github.com/users/DanielKeep/following{/other_user}", "gists_url": "https://api.github.com/users/DanielKeep/gists{/gist_id}", "starred_url": "https://api.github.com/users/DanielKeep/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DanielKeep/subscriptions", "organizations_url": "https://api.github.com/users/DanielKeep/orgs", "repos_url": "https://api.github.com/users/DanielKeep/repos", "events_url": "https://api.github.com/users/DanielKeep/events{/privacy}", "received_events_url": "https://api.github.com/users/DanielKeep/received_events", "type": "User", "site_admin": false}, "committer": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae23e65eb8f207d0c9be82e7f2043d98a32d4f57", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae23e65eb8f207d0c9be82e7f2043d98a32d4f57", "html_url": "https://github.com/rust-lang/rust/commit/ae23e65eb8f207d0c9be82e7f2043d98a32d4f57"}], "stats": {"total": 143, "additions": 142, "deletions": 1}, "files": [{"sha": "eb0b7c29f8d9ad8d74aa15a283c7b12f5ea1c608", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2489495d909c43cfbefaeb79db6a77b13908257/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2489495d909c43cfbefaeb79db6a77b13908257/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=a2489495d909c43cfbefaeb79db6a77b13908257", "patch": "@@ -529,6 +529,7 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n             token::NtPath(panictry!(p.parse_path(PathStyle::Type)))\n         },\n         \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n+        \"vis\" => token::NtVis(panictry!(p.parse_visibility(true))),\n         // this is not supposed to happen, since it has been checked\n         // when compiling the macro.\n         _ => p.span_bug(sp, \"invalid fragment specifier\")"}, {"sha": "4e197a85ebd9629192c6165ec5b4a4acf89ace63", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2489495d909c43cfbefaeb79db6a77b13908257/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2489495d909c43cfbefaeb79db6a77b13908257/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=a2489495d909c43cfbefaeb79db6a77b13908257", "patch": "@@ -790,6 +790,19 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> Result<bool, (String, &'\n                 // harmless\n                 Ok(true)\n             },\n+            \"vis\" => {\n+                // Explicitly disallow `priv`, on the off chance it comes back.\n+                match *tok {\n+                    Comma => Ok(true),\n+                    ModSep => Ok(true),\n+                    MatchNt(_, ref frag, _, _) => {\n+                        let name = frag.name.as_str();\n+                        Ok(name == \"ident\" || name == \"ty\")\n+                    },\n+                    Ident(i, _) if i.name.as_str() != \"priv\" => Ok(true),\n+                    _ => Ok(false)\n+                }\n+            },\n             \"\" => Ok(true), // keywords::Invalid\n             _ => Err((format!(\"invalid fragment specifier `{}`\", frag),\n                      \"valid fragment specifiers are `ident`, `block`, \\\n@@ -813,7 +826,7 @@ fn has_legal_fragment_specifier(tok: &quoted::TokenTree) -> Result<(), String> {\n fn is_legal_fragment_specifier(frag: &str) -> bool {\n     match frag {\n         \"item\" | \"block\" | \"stmt\" | \"expr\" | \"pat\" |\n-        \"path\" | \"ty\" | \"ident\" | \"meta\" | \"tt\" | \"\" => true,\n+        \"path\" | \"ty\" | \"ident\" | \"meta\" | \"tt\" | \"vis\" | \"\" => true,\n         _ => false,\n     }\n }"}, {"sha": "f39399a62e856c366fb62d73361cc8c68b3b6121", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2489495d909c43cfbefaeb79db6a77b13908257/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2489495d909c43cfbefaeb79db6a77b13908257/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=a2489495d909c43cfbefaeb79db6a77b13908257", "patch": "@@ -636,6 +636,7 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtWhereClause(where_clause) =>\n             token::NtWhereClause(fld.fold_where_clause(where_clause)),\n         token::NtArg(arg) => token::NtArg(fld.fold_arg(arg)),\n+        token::NtVis(vis) => token::NtVis(fld.fold_vis(vis)),\n     }\n }\n "}, {"sha": "513aa866043ad1b30d1ebba8dcc6f02ac69358c3", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2489495d909c43cfbefaeb79db6a77b13908257/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2489495d909c43cfbefaeb79db6a77b13908257/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=a2489495d909c43cfbefaeb79db6a77b13908257", "patch": "@@ -371,6 +371,7 @@ pub enum Nonterminal {\n     NtGenerics(ast::Generics),\n     NtWhereClause(ast::WhereClause),\n     NtArg(ast::Arg),\n+    NtVis(ast::Visibility),\n }\n \n impl fmt::Debug for Nonterminal {\n@@ -392,6 +393,7 @@ impl fmt::Debug for Nonterminal {\n             NtGenerics(..) => f.pad(\"NtGenerics(..)\"),\n             NtWhereClause(..) => f.pad(\"NtWhereClause(..)\"),\n             NtArg(..) => f.pad(\"NtArg(..)\"),\n+            NtVis(..) => f.pad(\"NtVis(..)\"),\n         }\n     }\n }"}, {"sha": "2494af2c1618692154384cd91152bc083869c66b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2489495d909c43cfbefaeb79db6a77b13908257/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2489495d909c43cfbefaeb79db6a77b13908257/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a2489495d909c43cfbefaeb79db6a77b13908257", "patch": "@@ -293,6 +293,7 @@ pub fn token_to_string(tok: &Token) -> String {\n             token::NtGenerics(ref e)    => generics_to_string(&e),\n             token::NtWhereClause(ref e) => where_clause_to_string(&e),\n             token::NtArg(ref e)         => arg_to_string(&e),\n+            token::NtVis(ref e)         => vis_to_string(&e),\n         }\n     }\n }\n@@ -373,6 +374,10 @@ pub fn ident_to_string(id: ast::Ident) -> String {\n     to_string(|s| s.print_ident(id))\n }\n \n+pub fn vis_to_string(v: &ast::Visibility) -> String {\n+    to_string(|s| s.print_visibility(v))\n+}\n+\n pub fn fun_to_string(decl: &ast::FnDecl,\n                      unsafety: ast::Unsafety,\n                      constness: ast::Constness,"}, {"sha": "64fa0bef464cc796a5a5c99000e5f15a559c5194", "filename": "src/test/run-pass/macro-pub-matcher.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/a2489495d909c43cfbefaeb79db6a77b13908257/src%2Ftest%2Frun-pass%2Fmacro-pub-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2489495d909c43cfbefaeb79db6a77b13908257/src%2Ftest%2Frun-pass%2Fmacro-pub-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-pub-matcher.rs?ref=a2489495d909c43cfbefaeb79db6a77b13908257", "patch": "@@ -0,0 +1,119 @@\n+#![allow(dead_code, unused_imports)]\n+#![feature(pub_restricted)]\n+\n+/**\n+Ensure that `:vis` matches can be captured in existing positions, and passed\n+through without the need for reparse tricks.\n+*/\n+macro_rules! vis_passthru {\n+    ($vis:vis const $name:ident: $ty:ty = $e:expr;) => { $vis const $name: $ty = $e; };\n+    ($vis:vis enum $name:ident {}) => { $vis struct $name {} };\n+    ($vis:vis extern \"C\" fn $name:ident() {}) => { $vis extern \"C\" fn $name() {} };\n+    ($vis:vis fn $name:ident() {}) => { $vis fn $name() {} };\n+    ($vis:vis mod $name:ident {}) => { $vis mod $name {} };\n+    ($vis:vis static $name:ident: $ty:ty = $e:expr;) => { $vis static $name: $ty = $e; };\n+    ($vis:vis struct $name:ident;) => { $vis struct $name; };\n+    ($vis:vis trait $name:ident {}) => { $vis trait $name {} };\n+    ($vis:vis type $name:ident = $ty:ty;) => { $vis type $name = $ty; };\n+    ($vis:vis use $path:ident as $name:ident;) => { $vis use self::$path as $name; };\n+}\n+\n+mod with_pub {\n+    vis_passthru! { pub const A: i32 = 0; }\n+    vis_passthru! { pub enum B {} }\n+    vis_passthru! { pub extern \"C\" fn c() {} }\n+    vis_passthru! { pub mod d {} }\n+    vis_passthru! { pub static E: i32 = 0; }\n+    vis_passthru! { pub struct F; }\n+    vis_passthru! { pub trait G {} }\n+    vis_passthru! { pub type H = i32; }\n+    vis_passthru! { pub use A as I; }\n+}\n+\n+mod without_pub {\n+    vis_passthru! { const A: i32 = 0; }\n+    vis_passthru! { enum B {} }\n+    vis_passthru! { extern \"C\" fn c() {} }\n+    vis_passthru! { mod d {} }\n+    vis_passthru! { static E: i32 = 0; }\n+    vis_passthru! { struct F; }\n+    vis_passthru! { trait G {} }\n+    vis_passthru! { type H = i32; }\n+    vis_passthru! { use A as I; }\n+}\n+\n+mod with_pub_restricted {\n+    vis_passthru! { pub(crate) const A: i32 = 0; }\n+    vis_passthru! { pub(crate) enum B {} }\n+    vis_passthru! { pub(crate) extern \"C\" fn c() {} }\n+    vis_passthru! { pub(crate) mod d {} }\n+    vis_passthru! { pub(crate) static E: i32 = 0; }\n+    vis_passthru! { pub(crate) struct F; }\n+    vis_passthru! { pub(crate) trait G {} }\n+    vis_passthru! { pub(crate) type H = i32; }\n+    vis_passthru! { pub(crate) use A as I; }\n+}\n+\n+mod garden {\n+    mod with_pub_restricted_path {\n+        vis_passthru! { pub(::garden) const A: i32 = 0; }\n+        vis_passthru! { pub(::garden) enum B {} }\n+        vis_passthru! { pub(::garden) extern \"C\" fn c() {} }\n+        vis_passthru! { pub(::garden) mod d {} }\n+        vis_passthru! { pub(::garden) static E: i32 = 0; }\n+        vis_passthru! { pub(::garden) struct F; }\n+        vis_passthru! { pub(::garden) trait G {} }\n+        vis_passthru! { pub(::garden) type H = i32; }\n+        vis_passthru! { pub(::garden) use A as I; }\n+    }\n+}\n+\n+/*\n+Ensure that the `:vis` matcher works in a more complex situation: parsing a\n+struct definition.\n+*/\n+macro_rules! vis_parse_struct {\n+    /*\n+    The rule duplication is currently unavoidable due to the leading attribute\n+    matching.\n+    */\n+    ($(#[$($attrs:tt)*])* pub($($vis:tt)*) struct $name:ident {$($body:tt)*}) => {\n+        vis_parse_struct! { @parse_fields $(#[$($attrs)*])*, pub($($vis)*), $name, $($body)* }\n+    };\n+    ($(#[$($attrs:tt)*])* pub struct $name:ident {$($body:tt)*}) => {\n+        vis_parse_struct! { @parse_fields $(#[$($attrs)*])*, pub, $name, $($body)* }\n+    };\n+    ($(#[$($attrs:tt)*])* struct $name:ident {$($body:tt)*}) => {\n+        vis_parse_struct! { @parse_fields $(#[$($attrs)*])*, , $name, $($body)* }\n+    };\n+\n+    ($(#[$($attrs:tt)*])* pub($($vis:tt)*) struct $name:ident ($($body:tt)*);) => {\n+        vis_parse_struct! { @parse_tuple $(#[$($attrs)*])*, pub($($vis)*), $name, $($body)* }\n+    };\n+    ($(#[$($attrs:tt)*])* pub struct $name:ident ($($body:tt)*);) => {\n+        vis_parse_struct! { @parse_tuple $(#[$($attrs)*])*, pub, $name, $($body)* }\n+    };\n+    ($(#[$($attrs:tt)*])* struct $name:ident ($($body:tt)*);) => {\n+        vis_parse_struct! { @parse_tuple $(#[$($attrs)*])*, , $name, $($body)* }\n+    };\n+\n+    (@parse_fields $(#[$attrs:meta])*, $vis:vis, $name:ident, $($fvis:vis $fname:ident: $fty:ty),* $(,)*) => {\n+        $(#[$attrs])* $vis struct $name { $($fvis $fname: $fty,)* }\n+    };\n+\n+    (@parse_tuple $(#[$attrs:meta])*, $vis:vis, $name:ident, $($fvis:vis $fty:ty),* $(,)*) => {\n+        $(#[$attrs])* $vis struct $name ( $($fvis $fty,)* );\n+    };\n+}\n+\n+mod test_struct {\n+    vis_parse_struct! { pub(crate) struct A { pub a: i32, b: i32, pub(crate) c: i32 } }\n+    vis_parse_struct! { pub struct B { a: i32, pub(crate) b: i32, pub c: i32 } }\n+    vis_parse_struct! { struct C { pub(crate) a: i32, pub b: i32, c: i32 } }\n+\n+    vis_parse_struct! { pub(crate) struct D (pub i32, i32, pub(crate) i32); }\n+    vis_parse_struct! { pub struct E (i32, pub(crate) i32, pub i32); }\n+    vis_parse_struct! { struct F (pub(crate) i32, pub i32, i32); }\n+}\n+\n+fn main() {}"}]}