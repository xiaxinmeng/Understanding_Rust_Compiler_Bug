{"sha": "1138d38d870e3915884e88df921588f1d1117644", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExMzhkMzhkODcwZTM5MTU4ODRlODhkZjkyMTU4OGYxZDExMTc2NDQ=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-19T17:33:42Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-19T17:33:42Z"}, "message": "Extract abi handling to abi.rs", "tree": {"sha": "2e0a9b18ecf6d54055e621f20168db479691cd3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e0a9b18ecf6d54055e621f20168db479691cd3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1138d38d870e3915884e88df921588f1d1117644", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1138d38d870e3915884e88df921588f1d1117644", "html_url": "https://github.com/rust-lang/rust/commit/1138d38d870e3915884e88df921588f1d1117644", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1138d38d870e3915884e88df921588f1d1117644/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b454bc34fb0986947f9c46c69e67354d382aec1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b454bc34fb0986947f9c46c69e67354d382aec1e", "html_url": "https://github.com/rust-lang/rust/commit/b454bc34fb0986947f9c46c69e67354d382aec1e"}], "stats": {"total": 282, "additions": 150, "deletions": 132}, "files": [{"sha": "69e33175c770afa7bf1cd652560c0785f372402b", "filename": "src/abi.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/1138d38d870e3915884e88df921588f1d1117644/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1138d38d870e3915884e88df921588f1d1117644/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=1138d38d870e3915884e88df921588f1d1117644", "patch": "@@ -0,0 +1,142 @@\n+use prelude::*;\n+\n+pub fn cton_sig_from_fn_sig<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sig: PolyFnSig<'tcx>, substs: &Substs<'tcx>) -> Signature {\n+    let sig = tcx.subst_and_normalize_erasing_regions(substs, ParamEnv::reveal_all(), &sig);\n+    cton_sig_from_mono_fn_sig(tcx, sig)\n+}\n+\n+pub fn cton_sig_from_instance<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, inst: Instance<'tcx>) -> Signature {\n+    let fn_ty = inst.ty(tcx);\n+    let sig = fn_ty.fn_sig(tcx);\n+    cton_sig_from_mono_fn_sig(tcx, sig)\n+}\n+\n+pub fn cton_sig_from_mono_fn_sig<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sig: PolyFnSig<'tcx>) -> Signature {\n+    // TODO: monomorphize signature\n+\n+    let sig = tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &sig);\n+    let inputs = sig.inputs();\n+    let _output = sig.output();\n+    assert!(!sig.variadic, \"Variadic function are not yet supported\");\n+    let call_conv = match sig.abi {\n+        _ => CallConv::SystemV,\n+    };\n+    Signature {\n+        params: Some(types::I64).into_iter() // First param is place to put return val\n+            .chain(inputs.into_iter().map(|ty| cton_type_from_ty(tcx, ty).unwrap_or(types::I64)))\n+            .map(AbiParam::new).collect(),\n+        returns: vec![],\n+        call_conv,\n+        argument_bytes: None,\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a> FunctionCx<'a, 'tcx> {\n+    pub fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n+        let tcx = self.tcx;\n+        let module = &mut self.module;\n+        let func_id = *self.def_id_fn_id_map.entry(inst).or_insert_with(|| {\n+            let sig = cton_sig_from_instance(tcx, inst);\n+            module.declare_function(&tcx.absolute_item_path_str(inst.def_id()), Linkage::Local, &sig).unwrap()\n+        });\n+        module.declare_func_in_func(func_id, &mut self.bcx.func)\n+    }\n+}\n+\n+pub fn codegen_fn_prelude<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, start_ebb: Ebb) {\n+    let ret_param = fx.bcx.append_ebb_param(start_ebb, types::I64);\n+    let _ = fx.bcx.create_stack_slot(StackSlotData {\n+        kind: StackSlotKind::ExplicitSlot,\n+        size: 0,\n+        offset: None,\n+    }); // Dummy stack slot for debugging\n+\n+    let func_params = fx.mir.args_iter().map(|local| {\n+        let layout = fx.layout_of(fx.mir.local_decls[local].ty);\n+        let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+            kind: StackSlotKind::ExplicitSlot,\n+            size: layout.size.bytes() as u32,\n+            offset: None,\n+        });\n+        let ty = fx.mir.local_decls[local].ty;\n+        let cton_type = fx.cton_type(ty).unwrap_or(types::I64);\n+        (local, fx.bcx.append_ebb_param(start_ebb, cton_type), ty, stack_slot)\n+    }).collect::<Vec<(Local, Value, Ty, StackSlot)>>();\n+\n+    let ret_layout = fx.layout_of(fx.instance.ty(fx.tcx).fn_sig(fx.tcx).skip_binder().output());\n+    fx.local_map.insert(RETURN_PLACE, CPlace::Addr(ret_param, ret_layout));\n+\n+    for (local, ebb_param, ty, stack_slot) in func_params {\n+        let place = CPlace::from_stack_slot(fx, stack_slot, ty);\n+        if fx.cton_type(ty).is_some() {\n+            place.write_cvalue(fx, CValue::ByVal(ebb_param, place.layout()));\n+        } else {\n+            place.write_cvalue(fx, CValue::ByRef(ebb_param, place.layout()));\n+        }\n+        fx.local_map.insert(local, place);\n+    }\n+\n+    for local in fx.mir.vars_and_temps_iter() {\n+        let ty = fx.mir.local_decls[local].ty;\n+        let layout = fx.layout_of(ty);\n+        let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+            kind: StackSlotKind::ExplicitSlot,\n+            size: layout.size.bytes() as u32,\n+            offset: None,\n+        });\n+        let place = CPlace::from_stack_slot(fx, stack_slot, ty);\n+        fx.local_map.insert(local, place);\n+    }\n+}\n+\n+pub fn codegen_call<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx>,\n+    func: &Operand<'tcx>,\n+    args: &[Operand<'tcx>],\n+    destination: &Option<(Place<'tcx>, BasicBlock)>,\n+) -> Inst {\n+    let func = ::base::trans_operand(fx, func);\n+    let func_ty = func.layout().ty;\n+    let return_place = if let Some((place, _)) = destination {\n+        ::base::trans_place(fx, place).expect_addr()\n+    } else {\n+        fx.bcx.ins().iconst(types::I64, 0)\n+    };\n+    let args = Some(return_place)\n+        .into_iter()\n+        .chain(\n+            args\n+                .into_iter()\n+                .map(|arg| {\n+                    let ty = arg.ty(&fx.mir.local_decls, fx.tcx);\n+                    let arg = ::base::trans_operand(fx, arg);\n+                    if let Some(_) = fx.cton_type(ty) {\n+                        arg.load_value(fx)\n+                    } else {\n+                        arg.force_stack(fx)\n+                    }\n+                })\n+        ).collect::<Vec<_>>();\n+    let inst = match func {\n+        CValue::Func(func, _) => {\n+            fx.bcx.ins().call(func, &args)\n+        }\n+        func => {\n+            let func = func.load_value(fx);\n+            let sig = match func_ty.sty {\n+                TypeVariants::TyFnDef(def_id, _substs) => fx.tcx.fn_sig(def_id),\n+                TypeVariants::TyFnPtr(fn_sig) => fn_sig,\n+                _ => bug!(\"Calling non function type {:?}\", func_ty),\n+            };\n+            let sig = fx.bcx.import_signature(cton_sig_from_fn_sig(fx.tcx, sig, fx.param_substs));\n+            fx.bcx.ins().call_indirect(sig, func, &args)\n+        }\n+    };\n+    if let Some((_, dest)) = *destination {\n+        let ret_ebb = fx.get_ebb(dest);\n+        fx.bcx.ins().jump(ret_ebb, &[]);\n+    } else {\n+        fx.bcx.ins().trap(TrapCode::User(!0));\n+    }\n+    inst\n+}"}, {"sha": "aebac3713ae73e84abeba76753a94a9906c8a204", "filename": "src/base.rs", "status": "modified", "additions": 4, "deletions": 89, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/1138d38d870e3915884e88df921588f1d1117644/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1138d38d870e3915884e88df921588f1d1117644/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=1138d38d870e3915884e88df921588f1d1117644", "patch": "@@ -92,49 +92,7 @@ pub fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &\n     };\n     let fx = &mut fx;\n \n-    let ret_param = fx.bcx.append_ebb_param(start_ebb, types::I64);\n-    let _ = fx.bcx.create_stack_slot(StackSlotData {\n-        kind: StackSlotKind::ExplicitSlot,\n-        size: 0,\n-        offset: None,\n-    }); // Dummy stack slot for debugging\n-\n-    let func_params = mir.args_iter().map(|local| {\n-        let layout = fx.layout_of(mir.local_decls[local].ty);\n-        let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n-            kind: StackSlotKind::ExplicitSlot,\n-            size: layout.size.bytes() as u32,\n-            offset: None,\n-        });\n-        let ty = mir.local_decls[local].ty;\n-        let cton_type = fx.cton_type(ty).unwrap_or(types::I64);\n-        (local, fx.bcx.append_ebb_param(start_ebb, cton_type), ty, stack_slot)\n-    }).collect::<Vec<(Local, Value, Ty, StackSlot)>>();\n-\n-    let ret_layout = fx.layout_of(fx.instance.ty(fx.tcx).fn_sig(fx.tcx).skip_binder().output());\n-    fx.local_map.insert(RETURN_PLACE, CPlace::Addr(ret_param, ret_layout));\n-\n-    for (local, ebb_param, ty, stack_slot) in func_params {\n-        let place = CPlace::from_stack_slot(fx, stack_slot, ty);\n-        if fx.cton_type(ty).is_some() {\n-            place.write_cvalue(fx, CValue::ByVal(ebb_param, place.layout()));\n-        } else {\n-            place.write_cvalue(fx, CValue::ByRef(ebb_param, place.layout()));\n-        }\n-        fx.local_map.insert(local, place);\n-    }\n-\n-    for local in mir.vars_and_temps_iter() {\n-        let ty = mir.local_decls[local].ty;\n-        let layout = fx.layout_of(ty);\n-        let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n-            kind: StackSlotKind::ExplicitSlot,\n-            size: layout.size.bytes() as u32,\n-            offset: None,\n-        });\n-        let place = CPlace::from_stack_slot(fx, stack_slot, ty);\n-        fx.local_map.insert(local, place);\n-    }\n+    ::abi::codegen_fn_prelude(fx, start_ebb);\n \n     fx.bcx.ins().jump(*fx.ebb_map.get(&START_BLOCK).unwrap(), &[]);\n \n@@ -180,50 +138,7 @@ pub fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &\n                 inst\n             }\n             TerminatorKind::Call { func, args, destination, cleanup: _ } => {\n-                let func_ty = func.ty(&fx.mir.local_decls, fx.tcx);\n-                let func = trans_operand(fx, func);\n-                let return_place = if let Some((place, _)) = destination {\n-                    trans_place(fx, place).expect_addr()\n-                } else {\n-                    fx.bcx.ins().iconst(types::I64, 0)\n-                };\n-                let args = Some(return_place)\n-                    .into_iter()\n-                    .chain(\n-                        args\n-                            .into_iter()\n-                            .map(|arg| {\n-                                let ty = arg.ty(&fx.mir.local_decls, fx.tcx);\n-                                let arg = trans_operand(fx, arg);\n-                                if let Some(_) = fx.cton_type(ty) {\n-                                    arg.load_value(fx)\n-                                } else {\n-                                    arg.force_stack(fx)\n-                                }\n-                            })\n-                    ).collect::<Vec<_>>();\n-                let inst = match func {\n-                    CValue::Func(func, _) => {\n-                        fx.bcx.ins().call(func, &args)\n-                    }\n-                    func => {\n-                        let func = func.load_value(fx);\n-                        let sig = match func_ty.sty {\n-                            TypeVariants::TyFnDef(def_id, _substs) => fx.tcx.fn_sig(def_id),\n-                            TypeVariants::TyFnPtr(fn_sig) => fn_sig,\n-                            _ => bug!(\"Calling non function type {:?}\", func_ty),\n-                        };\n-                        let sig = fx.bcx.import_signature(cton_sig_from_fn_sig(fx.tcx, sig, fx.param_substs));\n-                        fx.bcx.ins().call_indirect(sig, func, &args)\n-                    }\n-                };\n-                if let Some((_, dest)) = *destination {\n-                    let ret_ebb = fx.get_ebb(dest);\n-                    fx.bcx.ins().jump(ret_ebb, &[]);\n-                } else {\n-                    fx.bcx.ins().trap(TrapCode::User(!0));\n-                }\n-                inst\n+                ::abi::codegen_call(fx, func, args, destination)\n             }\n             TerminatorKind::Resume | TerminatorKind::Abort | TerminatorKind::Unreachable => {\n                 fx.bcx.ins().trap(TrapCode::User(!0))\n@@ -569,7 +484,7 @@ fn trans_ptr_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, l\n     CValue::ByVal(res, fx.layout_of(ty))\n }\n \n-fn trans_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, place: &Place<'tcx>) -> CPlace<'tcx> {\n+pub fn trans_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, place: &Place<'tcx>) -> CPlace<'tcx> {\n     match place {\n         Place::Local(local) => fx.get_local_place(*local),\n         Place::Static(static_) => unimplemented!(\"static place {:?} ty {:?}\", static_.def_id, static_.ty),\n@@ -594,7 +509,7 @@ fn trans_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, place: &Place<'tcx>)\n     }\n }\n \n-fn trans_operand<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx>, operand: &Operand<'tcx>) -> CValue<'tcx> {\n+pub fn trans_operand<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx>, operand: &Operand<'tcx>) -> CValue<'tcx> {\n     match operand {\n         Operand::Move(place) |\n         Operand::Copy(place) => {"}, {"sha": "c09d69c8fdffa560033dc5c9d74e17f84a12c59c", "filename": "src/common.rs", "status": "modified", "additions": 2, "deletions": 43, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1138d38d870e3915884e88df921588f1d1117644/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1138d38d870e3915884e88df921588f1d1117644/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=1138d38d870e3915884e88df921588f1d1117644", "patch": "@@ -6,7 +6,7 @@ use std::fmt;\n use syntax::ast::{IntTy, UintTy};\n use self::rustc_target::spec::{HasTargetSpec, Target};\n \n-use cranelift_module::{Module, Linkage, FuncId, DataId};\n+use cranelift_module::{Module, FuncId, DataId};\n \n use prelude::*;\n \n@@ -25,7 +25,7 @@ impl EntityRef for Variable {\n     }\n }\n \n-fn cton_type_from_ty<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> Option<types::Type> {\n+pub fn cton_type_from_ty<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> Option<types::Type> {\n     Some(match ty.sty {\n         TypeVariants::TyBool => types::I8,\n         TypeVariants::TyUint(size) => {\n@@ -278,37 +278,6 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n     }\n }\n \n-pub fn cton_sig_from_fn_sig<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sig: PolyFnSig<'tcx>, substs: &Substs<'tcx>) -> Signature {\n-    let sig = tcx.subst_and_normalize_erasing_regions(substs, ParamEnv::reveal_all(), &sig);\n-    cton_sig_from_mono_fn_sig(tcx, sig)\n-}\n-\n-pub fn cton_sig_from_instance<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, inst: Instance<'tcx>) -> Signature {\n-    let fn_ty = inst.ty(tcx);\n-    let sig = fn_ty.fn_sig(tcx);\n-    cton_sig_from_mono_fn_sig(tcx, sig)\n-}\n-\n-pub fn cton_sig_from_mono_fn_sig<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sig: PolyFnSig<'tcx>) -> Signature {\n-    // TODO: monomorphize signature\n-\n-    let sig = tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &sig);\n-    let inputs = sig.inputs();\n-    let _output = sig.output();\n-    assert!(!sig.variadic, \"Variadic function are not yet supported\");\n-    let call_conv = match sig.abi {\n-        _ => CallConv::SystemV,\n-    };\n-    Signature {\n-        params: Some(types::I64).into_iter() // First param is place to put return val\n-            .chain(inputs.into_iter().map(|ty| cton_type_from_ty(tcx, ty).unwrap_or(types::I64)))\n-            .map(AbiParam::new).collect(),\n-        returns: vec![],\n-        call_conv,\n-        argument_bytes: None,\n-    }\n-}\n-\n pub fn cton_intcast<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, val: Value, from: Ty<'tcx>, to: Ty<'tcx>, signed: bool) -> Value {\n     let from = fx.cton_type(from).unwrap();\n     let to = fx.cton_type(to).unwrap();\n@@ -409,16 +378,6 @@ impl<'a, 'tcx: 'a> FunctionCx<'a, 'tcx> {\n         *self.local_map.get(&local).unwrap()\n     }\n \n-    pub fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n-        let tcx = self.tcx;\n-        let module = &mut self.module;\n-        let func_id = *self.def_id_fn_id_map.entry(inst).or_insert_with(|| {\n-            let sig = cton_sig_from_instance(tcx, inst);\n-            module.declare_function(&tcx.absolute_item_path_str(inst.def_id()), Linkage::Local, &sig).unwrap()\n-        });\n-        module.declare_func_in_func(func_id, &mut self.bcx.func)\n-    }\n-\n     pub fn add_comment<'s, S: Into<Cow<'s, str>>>(&mut self, inst: Inst, comment: S) {\n         use std::collections::hash_map::Entry;\n         match self.comments.entry(inst) {"}, {"sha": "046af45d0ad54876dd2f2f8b43dd529f37a3b3e7", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1138d38d870e3915884e88df921588f1d1117644/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1138d38d870e3915884e88df921588f1d1117644/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=1138d38d870e3915884e88df921588f1d1117644", "patch": "@@ -33,6 +33,7 @@ use std::sync::{mpsc, Arc};\n use std::fs::File;\n use std::io::Write;\n \n+mod abi;\n mod base;\n mod constant;\n mod common;\n@@ -64,6 +65,7 @@ mod prelude {\n     pub use cranelift_module::{Module, Backend, FuncId, DataId, Linkage};\n     pub use cranelift_simplejit::{SimpleJITBuilder, SimpleJITBackend};\n \n+    pub use abi::*;\n     pub use common::Variable;\n     pub use common::*;\n "}]}