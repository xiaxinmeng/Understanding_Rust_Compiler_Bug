{"sha": "114cdd0816f548f47dbd85628e726663cb681284", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExNGNkZDA4MTZmNTQ4ZjQ3ZGJkODU2MjhlNzI2NjYzY2I2ODEyODQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-13T05:25:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-13T05:29:10Z"}, "message": "nit: improve SCC comments", "tree": {"sha": "8c5b44d9c348ed7e39fa6aabb695e0936f45d241", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c5b44d9c348ed7e39fa6aabb695e0936f45d241"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/114cdd0816f548f47dbd85628e726663cb681284", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/114cdd0816f548f47dbd85628e726663cb681284", "html_url": "https://github.com/rust-lang/rust/commit/114cdd0816f548f47dbd85628e726663cb681284", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/114cdd0816f548f47dbd85628e726663cb681284/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d2999461fbc07a7059363aacf2b0bcf615d322b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d2999461fbc07a7059363aacf2b0bcf615d322b", "html_url": "https://github.com/rust-lang/rust/commit/9d2999461fbc07a7059363aacf2b0bcf615d322b"}], "stats": {"total": 23, "additions": 19, "deletions": 4}, "files": [{"sha": "8976e53578164857559cb0fc3e4a797f067a7d20", "filename": "src/librustc_data_structures/graph/scc/mod.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/114cdd0816f548f47dbd85628e726663cb681284/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/114cdd0816f548f47dbd85628e726663cb681284/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs?ref=114cdd0816f548f47dbd85628e726663cb681284", "patch": "@@ -177,9 +177,6 @@ where\n     /// D' (i.e., D' < D), we know that N, N', and all nodes in\n     /// between them on the stack are part of an SCC.\n     ///\n-    /// For each node, we track the lowest depth of any successor we\n-    /// have found, along with that\n-    ///\n     /// [wikipedia]: https://bit.ly/2EZIx84\n     fn construct(graph: &'c G) -> Sccs<G::Node, S> {\n         let num_nodes = graph.num_nodes();\n@@ -213,6 +210,17 @@ where\n         }\n     }\n \n+    /// Visit a node during the DFS. We first examine its current\n+    /// state -- if it is not yet visited (`NotVisited`), we can push\n+    /// it onto the stack and start walking its successors.\n+    ///\n+    /// If it is already on the DFS stack it will be in the state\n+    /// `BeingVisited`. In that case, we have found a cycle and we\n+    /// return the depth from the stack.\n+    ///\n+    /// Otherwise, we are looking at a node that has already been\n+    /// completely visited. We therefore return `WalkReturn::Complete`\n+    /// with its associated SCC index.\n     fn walk_node(&mut self, depth: usize, node: G::Node) -> WalkReturn<S> {\n         debug!(\"walk_node(depth = {:?}, node = {:?})\", depth, node);\n         match self.find_state(node) {\n@@ -276,6 +284,7 @@ where\n             _ => false,\n         });\n \n+        // Push `node` onto the stack.\n         self.node_states[node] = NodeState::BeingVisited { depth };\n         self.node_stack.push(node);\n \n@@ -294,6 +303,7 @@ where\n                 WalkReturn::Cycle {\n                     min_depth: successor_min_depth,\n                 } => {\n+                    // Track the minimum depth we can reach.\n                     assert!(successor_min_depth <= depth);\n                     if successor_min_depth < min_depth {\n                         debug!(\n@@ -308,6 +318,8 @@ where\n                 WalkReturn::Complete {\n                     scc_index: successor_scc_index,\n                 } => {\n+                    // Push the completed SCC indices onto\n+                    // the `successors_stack` for later.\n                     debug!(\n                         \"walk_unvisited_node: node = {:?} successor_scc_index = {:?}\",\n                         node, successor_scc_index\n@@ -317,9 +329,12 @@ where\n             }\n         }\n \n+        // Completed walk, remove `node` from the stack.\n         let r = self.node_stack.pop();\n         debug_assert_eq!(r, Some(node));\n \n+        // If `min_depth == depth`, then we are the root of the\n+        // cycle: we can't reach anyone further down the stack.\n         if min_depth == depth {\n             // Note that successor stack may have duplicates, so we\n             // want to remove those:\n@@ -335,7 +350,7 @@ where\n             WalkReturn::Complete { scc_index }\n         } else {\n             // We are not the head of the cycle. Return back to our\n-            // caller.  They will take ownership of the\n+            // caller. They will take ownership of the\n             // `self.successors` data that we pushed.\n             self.node_states[node] = NodeState::InCycleWith {\n                 parent: min_cycle_root,"}]}