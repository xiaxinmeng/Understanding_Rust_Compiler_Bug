{"sha": "47e7a05a28c9662159af2d2e0f2b7efc13fa09cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZTdhMDVhMjhjOTY2MjE1OWFmMmQyZTBmMmI3ZWZjMTNmYTA5Y2I=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-03-02T23:47:14Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-03-02T23:47:40Z"}, "message": "Add some utf16 routines for OS API interop.", "tree": {"sha": "e0dd9deac9d76c7a033f14493665ace81f98d454", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0dd9deac9d76c7a033f14493665ace81f98d454"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47e7a05a28c9662159af2d2e0f2b7efc13fa09cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47e7a05a28c9662159af2d2e0f2b7efc13fa09cb", "html_url": "https://github.com/rust-lang/rust/commit/47e7a05a28c9662159af2d2e0f2b7efc13fa09cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47e7a05a28c9662159af2d2e0f2b7efc13fa09cb/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14306756b4a4f5f83043e3c2f91169a151fd54f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/14306756b4a4f5f83043e3c2f91169a151fd54f5", "html_url": "https://github.com/rust-lang/rust/commit/14306756b4a4f5f83043e3c2f91169a151fd54f5"}], "stats": {"total": 128, "additions": 128, "deletions": 0}, "files": [{"sha": "16f5e2370beb9f156d1fff04cfc3549210c06e94", "filename": "src/libcore/str.rs", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/47e7a05a28c9662159af2d2e0f2b7efc13fa09cb/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47e7a05a28c9662159af2d2e0f2b7efc13fa09cb/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=47e7a05a28c9662159af2d2e0f2b7efc13fa09cb", "patch": "@@ -81,6 +81,10 @@ export\n \n    // Misc\n    is_utf8,\n+   is_utf16,\n+   to_utf16,\n+   from_utf16,\n+   utf16_chars,\n    count_chars, count_bytes,\n    utf8_char_width,\n    char_range_at,\n@@ -1060,6 +1064,83 @@ fn is_utf8(v: [u8]) -> bool {\n     ret true;\n }\n \n+\n+fn is_utf16(v: [u16]) -> bool {\n+    let len = v.len();\n+    let i = 0u;\n+    while (i < len) {\n+        let u = v[i];\n+\n+        if  u <= 0xD7FF_u16 || u >= 0xE000_u16 {\n+            i += 1u;\n+\n+        } else {\n+            if i+1u < len { ret false; }\n+            let u2 = v[i+1u];\n+            if u < 0xD7FF_u16 || u > 0xDBFF_u16 { ret false; }\n+            if u2 < 0xDC00_u16 || u2 > 0xDFFF_u16 { ret false; }\n+            i += 2u;\n+        }\n+    }\n+    ret true;\n+}\n+\n+\n+fn to_utf16(s: str) -> [u16] {\n+    let u = [];\n+    chars_iter(s) {|cch|\n+        // Arithmetic with u32 literals is easier on the eyes than chars.\n+        let ch = cch as u32;\n+\n+        if (ch & 0xFFFF_u32) == ch {\n+            // The BMP falls through (assuming non-surrogate, as it should)\n+            assert ch <= 0xD7FF_u32 || ch >= 0xE000_u32;\n+            u += [ch as u16]\n+        } else {\n+            // Supplementary planes break into surrogates.\n+            assert ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32;\n+            ch -= 0x1_0000_u32;\n+            let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n+            let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n+            u += [w1, w2]\n+        }\n+    }\n+    ret u;\n+}\n+\n+fn utf16_chars(v: [u16], f: fn(char)) {\n+    let len = v.len();\n+    let i = 0u;\n+    while (i < len) {\n+        let u = v[i];\n+\n+        if  u <= 0xD7FF_u16 || u >= 0xE000_u16 {\n+            f(u as char);\n+            i += 1u;\n+\n+        } else {\n+            let u2 = v[i+1u];\n+            assert u >= 0xD800_u16 && u <= 0xDBFF_u16;\n+            assert u2 >= 0xDC00_u16 && u2 <= 0xDFFF_u16;\n+            let c = (u - 0xD800_u16) as char;\n+            c = c << 10;\n+            c |= (u2 - 0xDC00_u16) as char;\n+            c |= 0x1_0000_u32 as char;\n+            f(c);\n+            i += 2u;\n+        }\n+    }\n+}\n+\n+\n+fn from_utf16(v: [u16]) -> str {\n+    let buf = \"\";\n+    reserve(buf, v.len());\n+    utf16_chars(v) {|ch| push_char(buf, ch); }\n+    ret buf;\n+}\n+\n+\n /*\n Function: count_chars\n \n@@ -2223,4 +2304,51 @@ mod tests {\n         assert ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m']\n             == chars(ss);\n     }\n+\n+    #[test]\n+    fn test_utf16() {\n+        let pairs =\n+            [(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\",\n+              [0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n+               0xd800_u16, 0xdf3b_u16, 0xd800_u16, 0xdf46_u16,\n+               0xd800_u16, 0xdf39_u16, 0xd800_u16, 0xdf3b_u16,\n+               0xd800_u16, 0xdf30_u16, 0x000a_u16]),\n+\n+             (\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\",\n+              [0xd801_u16, 0xdc12_u16, 0xd801_u16,\n+               0xdc49_u16, 0xd801_u16, 0xdc2e_u16, 0xd801_u16,\n+               0xdc40_u16, 0xd801_u16, 0xdc32_u16, 0xd801_u16,\n+               0xdc4b_u16, 0x0020_u16, 0xd801_u16, 0xdc0f_u16,\n+               0xd801_u16, 0xdc32_u16, 0xd801_u16, 0xdc4d_u16,\n+               0x000a_u16]),\n+\n+             (\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\",\n+              [0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n+               0xd800_u16, 0xdf0b_u16, 0xd800_u16, 0xdf04_u16,\n+               0xd800_u16, 0xdf11_u16, 0xd800_u16, 0xdf09_u16,\n+               0x00b7_u16, 0xd800_u16, 0xdf0c_u16, 0xd800_u16,\n+               0xdf04_u16, 0xd800_u16, 0xdf15_u16, 0xd800_u16,\n+               0xdf04_u16, 0xd800_u16, 0xdf0b_u16, 0xd800_u16,\n+               0xdf09_u16, 0xd800_u16, 0xdf11_u16, 0x000a_u16 ]),\n+\n+             (\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\",\n+              [0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n+               0xd801_u16, 0xdc88_u16, 0xd801_u16, 0xdc91_u16,\n+               0xd801_u16, 0xdc9b_u16, 0xd801_u16, 0xdc92_u16,\n+               0x0020_u16, 0xd801_u16, 0xdc95_u16, 0xd801_u16,\n+               0xdc93_u16, 0x0020_u16, 0xd801_u16, 0xdc88_u16,\n+               0xd801_u16, 0xdc9a_u16, 0xd801_u16, 0xdc8d_u16,\n+               0x0020_u16, 0xd801_u16, 0xdc8f_u16, 0xd801_u16,\n+               0xdc9c_u16, 0xd801_u16, 0xdc92_u16, 0xd801_u16,\n+               0xdc96_u16, 0xd801_u16, 0xdc86_u16, 0x0020_u16,\n+               0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n+               0x000a_u16 ]) ];\n+\n+        for (s, u) in pairs {\n+            assert to_utf16(s) == u;\n+            assert from_utf16(u) == s;\n+            assert from_utf16(to_utf16(s)) == s;\n+            assert to_utf16(from_utf16(u)) == u;\n+        }\n+    }\n }"}]}