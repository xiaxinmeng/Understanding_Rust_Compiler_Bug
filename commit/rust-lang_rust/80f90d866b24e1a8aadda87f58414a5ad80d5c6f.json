{"sha": "80f90d866b24e1a8aadda87f58414a5ad80d5c6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwZjkwZDg2NmIyNGUxYThhYWRkYTg3ZjU4NDE0YTVhZDgwZDVjNmY=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-04-30T22:37:38Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-04-30T22:37:38Z"}, "message": "Pull out some functors for readability", "tree": {"sha": "2a96979de32084a6f765e8c2d3f717ad726fb78f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a96979de32084a6f765e8c2d3f717ad726fb78f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80f90d866b24e1a8aadda87f58414a5ad80d5c6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80f90d866b24e1a8aadda87f58414a5ad80d5c6f", "html_url": "https://github.com/rust-lang/rust/commit/80f90d866b24e1a8aadda87f58414a5ad80d5c6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80f90d866b24e1a8aadda87f58414a5ad80d5c6f/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e709b2910a029ec4f0c640233526e7ed335c26c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e709b2910a029ec4f0c640233526e7ed335c26c", "html_url": "https://github.com/rust-lang/rust/commit/5e709b2910a029ec4f0c640233526e7ed335c26c"}], "stats": {"total": 582, "additions": 293, "deletions": 289}, "files": [{"sha": "f4ebfd79fe1db41f1bfee121dd045a1be2de7569", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 293, "deletions": 289, "changes": 582, "blob_url": "https://github.com/rust-lang/rust/blob/80f90d866b24e1a8aadda87f58414a5ad80d5c6f/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80f90d866b24e1a8aadda87f58414a5ad80d5c6f/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=80f90d866b24e1a8aadda87f58414a5ad80d5c6f", "patch": "@@ -108,6 +108,297 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n     false\n }\n \n+// For `isize` & `usize`, be conservative with the warnings, so that the\n+// warnings are consistent between 32- and 64-bit platforms.\n+fn int_ty_range(int_ty: ast::IntTy) -> (i128, i128) {\n+    match int_ty {\n+        ast::IntTy::Isize => (i64::min_value() as i128, i64::max_value() as i128),\n+        ast::IntTy::I8 => (i8::min_value() as i64 as i128, i8::max_value() as i128),\n+        ast::IntTy::I16 => (i16::min_value() as i64 as i128, i16::max_value() as i128),\n+        ast::IntTy::I32 => (i32::min_value() as i64 as i128, i32::max_value() as i128),\n+        ast::IntTy::I64 => (i64::min_value() as i128, i64::max_value() as i128),\n+        ast::IntTy::I128 =>(i128::min_value() as i128, i128::max_value()),\n+    }\n+}\n+\n+fn uint_ty_range(uint_ty: ast::UintTy) -> (u128, u128) {\n+    match uint_ty {\n+        ast::UintTy::Usize => (u64::min_value() as u128, u64::max_value() as u128),\n+        ast::UintTy::U8 => (u8::min_value() as u128, u8::max_value() as u128),\n+        ast::UintTy::U16 => (u16::min_value() as u128, u16::max_value() as u128),\n+        ast::UintTy::U32 => (u32::min_value() as u128, u32::max_value() as u128),\n+        ast::UintTy::U64 => (u64::min_value() as u128, u64::max_value() as u128),\n+        ast::UintTy::U128 => (u128::min_value(), u128::max_value()),\n+    }\n+}\n+\n+fn get_bin_hex_repr(cx: &LateContext<'_, '_>, lit: &ast::Lit) -> Option<String> {\n+    let src = cx.sess().source_map().span_to_snippet(lit.span).ok()?;\n+    let firstch = src.chars().next()?;\n+\n+    if firstch == '0' {\n+        match src.chars().nth(1) {\n+            Some('x') | Some('b') => return Some(src),\n+            _ => return None,\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn report_bin_hex_error(\n+    cx: &LateContext<'_, '_>,\n+    expr: &hir::Expr,\n+    ty: attr::IntType,\n+    repr_str: String,\n+    val: u128,\n+    negative: bool,\n+) {\n+    let size = layout::Integer::from_attr(&cx.tcx, ty).size();\n+    let (t, actually) = match ty {\n+        attr::IntType::SignedInt(t) => {\n+            let actually = sign_extend(val, size) as i128;\n+            (format!(\"{:?}\", t), actually.to_string())\n+        }\n+        attr::IntType::UnsignedInt(t) => {\n+            let actually = truncate(val, size);\n+            (format!(\"{:?}\", t), actually.to_string())\n+        }\n+    };\n+    let mut err = cx.struct_span_lint(\n+        OVERFLOWING_LITERALS,\n+        expr.span,\n+        &format!(\"literal out of range for {}\", t),\n+    );\n+    err.note(&format!(\n+        \"the literal `{}` (decimal `{}`) does not fit into \\\n+            an `{}` and will become `{}{}`\",\n+        repr_str, val, t, actually, t\n+    ));\n+    if let Some(sugg_ty) =\n+        get_type_suggestion(&cx.tables.node_type(expr.hir_id), val, negative)\n+    {\n+        if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n+            let (sans_suffix, _) = repr_str.split_at(pos);\n+            err.span_suggestion(\n+                expr.span,\n+                &format!(\"consider using `{}` instead\", sugg_ty),\n+                format!(\"{}{}\", sans_suffix, sugg_ty),\n+                Applicability::MachineApplicable\n+            );\n+        } else {\n+            err.help(&format!(\"consider using `{}` instead\", sugg_ty));\n+        }\n+    }\n+\n+    err.emit();\n+}\n+\n+// This function finds the next fitting type and generates a suggestion string.\n+// It searches for fitting types in the following way (`X < Y`):\n+//  - `iX`: if literal fits in `uX` => `uX`, else => `iY`\n+//  - `-iX` => `iY`\n+//  - `uX` => `uY`\n+//\n+// No suggestion for: `isize`, `usize`.\n+fn get_type_suggestion<'a>(\n+    t: Ty<'_>,\n+    val: u128,\n+    negative: bool,\n+) -> Option<String> {\n+    use syntax::ast::IntTy::*;\n+    use syntax::ast::UintTy::*;\n+    macro_rules! find_fit {\n+        ($ty:expr, $val:expr, $negative:expr,\n+         $($type:ident => [$($utypes:expr),*] => [$($itypes:expr),*]),+) => {\n+            {\n+                let _neg = if negative { 1 } else { 0 };\n+                match $ty {\n+                    $($type => {\n+                        $(if !negative && val <= uint_ty_range($utypes).1 {\n+                            return Some(format!(\"{:?}\", $utypes))\n+                        })*\n+                        $(if val <= int_ty_range($itypes).1 as u128 + _neg {\n+                            return Some(format!(\"{:?}\", $itypes))\n+                        })*\n+                        None\n+                    },)*\n+                    _ => None\n+                }\n+            }\n+        }\n+    }\n+    match t.sty {\n+        ty::Int(i) => find_fit!(i, val, negative,\n+                      I8 => [U8] => [I16, I32, I64, I128],\n+                      I16 => [U16] => [I32, I64, I128],\n+                      I32 => [U32] => [I64, I128],\n+                      I64 => [U64] => [I128],\n+                      I128 => [U128] => []),\n+        ty::Uint(u) => find_fit!(u, val, negative,\n+                      U8 => [U8, U16, U32, U64, U128] => [],\n+                      U16 => [U16, U32, U64, U128] => [],\n+                      U32 => [U32, U64, U128] => [],\n+                      U64 => [U64, U128] => [],\n+                      U128 => [U128] => []),\n+        _ => None,\n+    }\n+}\n+\n+fn lint_int_literal<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    type_limits: &TypeLimits,\n+    e: &'tcx hir::Expr,\n+    lit: &ast::Lit,\n+    t: ast::IntTy,\n+    v: u128,\n+) {\n+    let int_type = if let ast::IntTy::Isize = t {\n+        cx.sess().target.isize_ty\n+    } else {\n+        t\n+    };\n+\n+    let (_, max) = int_ty_range(int_type);\n+    let max = max as u128;\n+    let negative = type_limits.negated_expr_id == e.hir_id;\n+\n+    // Detect literal value out of range [min, max] inclusive\n+    // avoiding use of -min to prevent overflow/panic\n+    if (negative && v > max + 1) || (!negative && v > max) {\n+        if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n+            report_bin_hex_error(\n+                cx,\n+                e,\n+                attr::IntType::SignedInt(t),\n+                repr_str,\n+                v,\n+                negative,\n+            );\n+            return;\n+        }\n+\n+        let par_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n+        if let Node::Expr(par_e) = cx.tcx.hir().get_by_hir_id(par_id) {\n+            if let hir::ExprKind::Struct(..) = par_e.node {\n+                if is_range_literal(cx.sess(), par_e)\n+                    && lint_overflowing_range_endpoint(cx, lit, v, max, e, par_e, t)\n+                {\n+                    // The overflowing literal lint was overridden.\n+                    return;\n+                }\n+            }\n+        }\n+\n+        cx.span_lint(\n+            OVERFLOWING_LITERALS,\n+            e.span,\n+            &format!(\"literal out of range for `{:?}`\", t),\n+        );\n+    }\n+}\n+\n+fn lint_uint_literal<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    e: &'tcx hir::Expr,\n+    lit: &ast::Lit,\n+    t: ast::UintTy,\n+) {\n+    let uint_type = if let ast::UintTy::Usize = t {\n+        cx.sess().target.usize_ty\n+    } else {\n+        t\n+    };\n+    let (min, max) = uint_ty_range(uint_type);\n+    let lit_val: u128 = match lit.node {\n+        // _v is u8, within range by definition\n+        ast::LitKind::Byte(_v) => return,\n+        ast::LitKind::Int(v, _) => v,\n+        _ => bug!(),\n+    };\n+    if lit_val < min || lit_val > max {\n+        let parent_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n+        if let Node::Expr(par_e) = cx.tcx.hir().get_by_hir_id(parent_id) {\n+            match par_e.node {\n+                hir::ExprKind::Cast(..) => {\n+                    if let ty::Char = cx.tables.expr_ty(par_e).sty {\n+                        let mut err = cx.struct_span_lint(\n+                            OVERFLOWING_LITERALS,\n+                            par_e.span,\n+                            \"only `u8` can be cast into `char`\",\n+                        );\n+                        err.span_suggestion(\n+                            par_e.span,\n+                            &\"use a `char` literal instead\",\n+                            format!(\"'\\\\u{{{:X}}}'\", lit_val),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        err.emit();\n+                        return;\n+                    }\n+                }\n+                hir::ExprKind::Struct(..)\n+                    if is_range_literal(cx.sess(), par_e) => {\n+                        if lint_overflowing_range_endpoint(cx, lit, lit_val, max, e, par_e, t) {\n+                            // The overflowing literal lint was overridden.\n+                            return;\n+                        }\n+                    }\n+                _ => {}\n+            }\n+        }\n+        if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n+            report_bin_hex_error(cx, e, attr::IntType::UnsignedInt(t), repr_str, lit_val, false);\n+            return;\n+        }\n+        cx.span_lint(\n+            OVERFLOWING_LITERALS,\n+            e.span,\n+            &format!(\"literal out of range for `{:?}`\", t),\n+        );\n+    }\n+}\n+\n+fn lint_literal<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    type_limits: &TypeLimits,\n+    e: &'tcx hir::Expr,\n+    lit: &ast::Lit,\n+) {\n+    match cx.tables.node_type(e.hir_id).sty {\n+        ty::Int(t) => {\n+            match lit.node {\n+                ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n+                ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => {\n+                    lint_int_literal(cx, type_limits, e, lit, t, v)\n+                }\n+                _ => bug!(),\n+            };\n+        }\n+        ty::Uint(t) => {\n+            lint_uint_literal(cx, e, lit, t)\n+        }\n+        ty::Float(t) => {\n+            let is_infinite = match lit.node {\n+                ast::LitKind::Float(v, _) |\n+                ast::LitKind::FloatUnsuffixed(v) => {\n+                    match t {\n+                        ast::FloatTy::F32 => v.as_str().parse().map(f32::is_infinite),\n+                        ast::FloatTy::F64 => v.as_str().parse().map(f64::is_infinite),\n+                    }\n+                }\n+                _ => bug!(),\n+            };\n+            if is_infinite == Ok(true) {\n+                cx.span_lint(OVERFLOWING_LITERALS,\n+                             e.span,\n+                             &format!(\"literal out of range for `{:?}`\", t));\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n         match e.node {\n@@ -124,158 +415,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                  \"comparison is useless due to type limits\");\n                 }\n             }\n-            hir::ExprKind::Lit(ref lit) => {\n-                match cx.tables.node_type(e.hir_id).sty {\n-                    ty::Int(t) => {\n-                        match lit.node {\n-                            ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n-                            ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => {\n-                                let int_type = if let ast::IntTy::Isize = t {\n-                                    cx.sess().target.isize_ty\n-                                } else {\n-                                    t\n-                                };\n-                                let (_, max) = int_ty_range(int_type);\n-                                let max = max as u128;\n-                                let negative = self.negated_expr_id == e.hir_id;\n-\n-                                // Detect literal value out of range [min, max] inclusive\n-                                // avoiding use of -min to prevent overflow/panic\n-                                if (negative && v > max + 1) || (!negative && v > max) {\n-                                    if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n-                                        report_bin_hex_error(\n-                                            cx,\n-                                            e,\n-                                            attr::IntType::SignedInt(t),\n-                                            repr_str,\n-                                            v,\n-                                            negative,\n-                                        );\n-                                        return;\n-                                    }\n-\n-                                    let par_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n-                                    if let Node::Expr(par_e) = cx.tcx.hir().get_by_hir_id(par_id) {\n-                                        if let hir::ExprKind::Struct(..) = par_e.node {\n-                                            if is_range_literal(cx.sess(), par_e)\n-                                                && lint_overflowing_range_endpoint(\n-                                                    cx,\n-                                                    lit,\n-                                                    v,\n-                                                    max,\n-                                                    e,\n-                                                    par_e,\n-                                                    t,\n-                                                )\n-                                            {\n-                                                    // The overflowing literal lint was overridden.\n-                                                    return;\n-                                            }\n-                                        }\n-                                    }\n-\n-                                    cx.span_lint(\n-                                        OVERFLOWING_LITERALS,\n-                                        e.span,\n-                                        &format!(\"literal out of range for `{:?}`\", t),\n-                                    );\n-                                    return;\n-                                }\n-                            }\n-                            _ => bug!(),\n-                        };\n-                    }\n-                    ty::Uint(t) => {\n-                        let uint_type = if let ast::UintTy::Usize = t {\n-                            cx.sess().target.usize_ty\n-                        } else {\n-                            t\n-                        };\n-                        let (min, max) = uint_ty_range(uint_type);\n-                        let lit_val: u128 = match lit.node {\n-                            // _v is u8, within range by definition\n-                            ast::LitKind::Byte(_v) => return,\n-                            ast::LitKind::Int(v, _) => v,\n-                            _ => bug!(),\n-                        };\n-                        if lit_val < min || lit_val > max {\n-                            let parent_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n-                            if let Node::Expr(parent_expr) = cx.tcx.hir().get_by_hir_id(parent_id) {\n-                                match parent_expr.node {\n-                                    hir::ExprKind::Cast(..) => {\n-                                        if let ty::Char = cx.tables.expr_ty(parent_expr).sty {\n-                                            let mut err = cx.struct_span_lint(\n-                                                OVERFLOWING_LITERALS,\n-                                                parent_expr.span,\n-                                                \"only `u8` can be cast into `char`\",\n-                                            );\n-                                            err.span_suggestion(\n-                                                parent_expr.span,\n-                                                &\"use a `char` literal instead\",\n-                                                format!(\"'\\\\u{{{:X}}}'\", lit_val),\n-                                                Applicability::MachineApplicable,\n-                                            );\n-                                            err.emit();\n-                                            return;\n-                                        }\n-                                    }\n-                                    hir::ExprKind::Struct(..)\n-                                        if is_range_literal(cx.sess(), parent_expr) => {\n-                                            if lint_overflowing_range_endpoint(\n-                                                cx,\n-                                                lit,\n-                                                lit_val,\n-                                                max,\n-                                                e,\n-                                                parent_expr,\n-                                                t,\n-                                            ) {\n-                                                // The overflowing literal lint was overridden.\n-                                                return;\n-                                            }\n-                                        }\n-                                    _ => {}\n-                                }\n-                            }\n-                            if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n-                                report_bin_hex_error(\n-                                    cx,\n-                                    e,\n-                                    attr::IntType::UnsignedInt(t),\n-                                    repr_str,\n-                                    lit_val,\n-                                    false,\n-                                );\n-                                return;\n-                            }\n-                            cx.span_lint(\n-                                OVERFLOWING_LITERALS,\n-                                e.span,\n-                                &format!(\"literal out of range for `{:?}`\", t),\n-                            );\n-                        }\n-                    }\n-                    ty::Float(t) => {\n-                        let is_infinite = match lit.node {\n-                            ast::LitKind::Float(v, _) |\n-                            ast::LitKind::FloatUnsuffixed(v) => {\n-                                match t {\n-                                    ast::FloatTy::F32 => v.as_str().parse().map(f32::is_infinite),\n-                                    ast::FloatTy::F64 => v.as_str().parse().map(f64::is_infinite),\n-                                }\n-                            }\n-                            _ => bug!(),\n-                        };\n-                        if is_infinite == Ok(true) {\n-                            cx.span_lint(OVERFLOWING_LITERALS,\n-                                         e.span,\n-                                         &format!(\"literal out of range for `{:?}`\", t));\n-                        }\n-                    }\n-                    _ => (),\n-                };\n-            }\n-            _ => (),\n+            hir::ExprKind::Lit(ref lit) => lint_literal(cx, self, e, lit),\n+            _ => {}\n         };\n \n         fn is_valid<T: cmp::PartialOrd>(binop: hir::BinOp, v: T, min: T, max: T) -> bool {\n@@ -300,30 +441,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             })\n         }\n \n-        // for isize & usize, be conservative with the warnings, so that the\n-        // warnings are consistent between 32- and 64-bit platforms\n-        fn int_ty_range(int_ty: ast::IntTy) -> (i128, i128) {\n-            match int_ty {\n-                ast::IntTy::Isize => (i64::min_value() as i128, i64::max_value() as i128),\n-                ast::IntTy::I8 => (i8::min_value() as i64 as i128, i8::max_value() as i128),\n-                ast::IntTy::I16 => (i16::min_value() as i64 as i128, i16::max_value() as i128),\n-                ast::IntTy::I32 => (i32::min_value() as i64 as i128, i32::max_value() as i128),\n-                ast::IntTy::I64 => (i64::min_value() as i128, i64::max_value() as i128),\n-                ast::IntTy::I128 =>(i128::min_value() as i128, i128::max_value()),\n-            }\n-        }\n-\n-        fn uint_ty_range(uint_ty: ast::UintTy) -> (u128, u128) {\n-            match uint_ty {\n-                ast::UintTy::Usize => (u64::min_value() as u128, u64::max_value() as u128),\n-                ast::UintTy::U8 => (u8::min_value() as u128, u8::max_value() as u128),\n-                ast::UintTy::U16 => (u16::min_value() as u128, u16::max_value() as u128),\n-                ast::UintTy::U32 => (u32::min_value() as u128, u32::max_value() as u128),\n-                ast::UintTy::U64 => (u64::min_value() as u128, u64::max_value() as u128),\n-                ast::UintTy::U128 => (u128::min_value(), u128::max_value()),\n-            }\n-        }\n-\n         fn check_limits(cx: &LateContext<'_, '_>,\n                         binop: hir::BinOp,\n                         l: &hir::Expr,\n@@ -380,119 +497,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 _ => false,\n             }\n         }\n-\n-        fn get_bin_hex_repr(cx: &LateContext<'_, '_>, lit: &ast::Lit) -> Option<String> {\n-            let src = cx.sess().source_map().span_to_snippet(lit.span).ok()?;\n-            let firstch = src.chars().next()?;\n-\n-            if firstch == '0' {\n-                match src.chars().nth(1) {\n-                    Some('x') | Some('b') => return Some(src),\n-                    _ => return None,\n-                }\n-            }\n-\n-            None\n-        }\n-\n-        // This function finds the next fitting type and generates a suggestion string.\n-        // It searches for fitting types in the following way (`X < Y`):\n-        //  - `iX`: if literal fits in `uX` => `uX`, else => `iY`\n-        //  - `-iX` => `iY`\n-        //  - `uX` => `uY`\n-        //\n-        // No suggestion for: `isize`, `usize`.\n-        fn get_type_suggestion<'a>(\n-            t: Ty<'_>,\n-            val: u128,\n-            negative: bool,\n-        ) -> Option<String> {\n-            use syntax::ast::IntTy::*;\n-            use syntax::ast::UintTy::*;\n-            macro_rules! find_fit {\n-                ($ty:expr, $val:expr, $negative:expr,\n-                 $($type:ident => [$($utypes:expr),*] => [$($itypes:expr),*]),+) => {\n-                    {\n-                        let _neg = if negative { 1 } else { 0 };\n-                        match $ty {\n-                            $($type => {\n-                                $(if !negative && val <= uint_ty_range($utypes).1 {\n-                                    return Some(format!(\"{:?}\", $utypes))\n-                                })*\n-                                $(if val <= int_ty_range($itypes).1 as u128 + _neg {\n-                                    return Some(format!(\"{:?}\", $itypes))\n-                                })*\n-                                None\n-                            },)*\n-                            _ => None\n-                        }\n-                    }\n-                }\n-            }\n-            match t.sty {\n-                ty::Int(i) => find_fit!(i, val, negative,\n-                              I8 => [U8] => [I16, I32, I64, I128],\n-                              I16 => [U16] => [I32, I64, I128],\n-                              I32 => [U32] => [I64, I128],\n-                              I64 => [U64] => [I128],\n-                              I128 => [U128] => []),\n-                ty::Uint(u) => find_fit!(u, val, negative,\n-                              U8 => [U8, U16, U32, U64, U128] => [],\n-                              U16 => [U16, U32, U64, U128] => [],\n-                              U32 => [U32, U64, U128] => [],\n-                              U64 => [U64, U128] => [],\n-                              U128 => [U128] => []),\n-                _ => None,\n-            }\n-        }\n-\n-        fn report_bin_hex_error(\n-            cx: &LateContext<'_, '_>,\n-            expr: &hir::Expr,\n-            ty: attr::IntType,\n-            repr_str: String,\n-            val: u128,\n-            negative: bool,\n-        ) {\n-            let size = layout::Integer::from_attr(&cx.tcx, ty).size();\n-            let (t, actually) = match ty {\n-                attr::IntType::SignedInt(t) => {\n-                    let actually = sign_extend(val, size) as i128;\n-                    (format!(\"{:?}\", t), actually.to_string())\n-                }\n-                attr::IntType::UnsignedInt(t) => {\n-                    let actually = truncate(val, size);\n-                    (format!(\"{:?}\", t), actually.to_string())\n-                }\n-            };\n-            let mut err = cx.struct_span_lint(\n-                OVERFLOWING_LITERALS,\n-                expr.span,\n-                &format!(\"literal out of range for {}\", t),\n-            );\n-            err.note(&format!(\n-                \"the literal `{}` (decimal `{}`) does not fit into \\\n-                 an `{}` and will become `{}{}`\",\n-                repr_str, val, t, actually, t\n-            ));\n-            if let Some(sugg_ty) =\n-                get_type_suggestion(&cx.tables.node_type(expr.hir_id), val, negative)\n-            {\n-                if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n-                    let (sans_suffix, _) = repr_str.split_at(pos);\n-                    err.span_suggestion(\n-                        expr.span,\n-                        &format!(\"consider using `{}` instead\", sugg_ty),\n-                        format!(\"{}{}\", sans_suffix, sugg_ty),\n-                        Applicability::MachineApplicable\n-                    );\n-                } else {\n-                    err.help(&format!(\"consider using `{}` instead\", sugg_ty));\n-                }\n-            }\n-\n-            err.emit();\n-        }\n     }\n }\n "}]}