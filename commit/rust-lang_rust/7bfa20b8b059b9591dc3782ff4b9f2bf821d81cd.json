{"sha": "7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiZmEyMGI4YjA1OWI5NTkxZGMzNzgyZmY0YjlmMmJmODIxZDgxY2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-14T10:00:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-14T10:00:41Z"}, "message": "Auto merge of #50648 - nox:volatile-store, r=eddyb\n\nFix volatile_store and nontemporal_store\n\nFixes #50371.", "tree": {"sha": "f850791fbef7e213842acfc9684964f8cdfac32f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f850791fbef7e213842acfc9684964f8cdfac32f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd", "html_url": "https://github.com/rust-lang/rust/commit/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f39dbae8cdc4418d3f79c719bd91d8b4f09c86b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f39dbae8cdc4418d3f79c719bd91d8b4f09c86b", "html_url": "https://github.com/rust-lang/rust/commit/8f39dbae8cdc4418d3f79c719bd91d8b4f09c86b"}, {"sha": "3ebe8679d2eed3caf30d8c6164405916de38ef94", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ebe8679d2eed3caf30d8c6164405916de38ef94", "html_url": "https://github.com/rust-lang/rust/commit/3ebe8679d2eed3caf30d8c6164405916de38ef94"}], "stats": {"total": 156, "additions": 75, "deletions": 81}, "files": [{"sha": "70a230cb7f7ac64890bfb3a7d52e5484da82ca52", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd", "patch": "@@ -2178,6 +2178,7 @@ dependencies = [\n name = \"rustc_trans\"\n version = \"0.0.0\"\n dependencies = [\n+ \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cc 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "64d3a4f4d53be9c0bee5171b0a451d65f5cac42a", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd", "patch": "@@ -10,6 +10,7 @@ crate-type = [\"dylib\"]\n test = false\n \n [dependencies]\n+bitflags = \"1.0.1\"\n cc = \"1.0.1\"\n flate2 = \"1.0\"\n jobserver = \"0.1.5\""}, {"sha": "25c598c532c4897c66d4136c154fa77823ef43bc", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::{self, ValueRef, AttributePlace};\n use base;\n-use builder::Builder;\n+use builder::{Builder, MemFlags};\n use common::{ty_fn_sig, C_usize};\n use context::CodegenCx;\n use mir::place::PlaceRef;\n@@ -220,7 +220,8 @@ impl<'a, 'tcx> ArgTypeExt<'a, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n                                   bx.pointercast(dst.llval, Type::i8p(cx)),\n                                   bx.pointercast(llscratch, Type::i8p(cx)),\n                                   C_usize(cx, self.layout.size.bytes()),\n-                                  self.layout.align.min(scratch_align));\n+                                  self.layout.align.min(scratch_align),\n+                                  MemFlags::empty());\n \n                 bx.lifetime_end(llscratch, scratch_size);\n             }"}, {"sha": "feca36fa6c24355d8f80fee4aa5258ccd294be7a", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd", "patch": "@@ -53,7 +53,7 @@ use rustc_incremental;\n use allocator;\n use mir::place::PlaceRef;\n use attributes;\n-use builder::Builder;\n+use builder::{Builder, MemFlags};\n use callee;\n use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n use rustc_mir::monomorphize::collector::{self, MonoItemCollectionMode};\n@@ -320,7 +320,7 @@ pub fn coerce_unsized_into<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n \n                 if src_f.layout.ty == dst_f.layout.ty {\n                     memcpy_ty(bx, dst_f.llval, src_f.llval, src_f.layout,\n-                        src_f.align.min(dst_f.align));\n+                              src_f.align.min(dst_f.align), MemFlags::empty());\n                 } else {\n                     coerce_unsized_into(bx, src_f, dst_f);\n                 }\n@@ -408,7 +408,15 @@ pub fn call_memcpy(bx: &Builder,\n                    dst: ValueRef,\n                    src: ValueRef,\n                    n_bytes: ValueRef,\n-                   align: Align) {\n+                   align: Align,\n+                   flags: MemFlags) {\n+    if flags.contains(MemFlags::NONTEMPORAL) {\n+        // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n+        let val = bx.load(src, align);\n+        let ptr = bx.pointercast(dst, val_ty(val).ptr_to());\n+        bx.store_with_flags(val, ptr, align, flags);\n+        return;\n+    }\n     let cx = bx.cx;\n     let ptr_width = &cx.sess().target.target.target_pointer_width;\n     let key = format!(\"llvm.memcpy.p0i8.p0i8.i{}\", ptr_width);\n@@ -417,7 +425,7 @@ pub fn call_memcpy(bx: &Builder,\n     let dst_ptr = bx.pointercast(dst, Type::i8p(cx));\n     let size = bx.intcast(n_bytes, cx.isize_ty, false);\n     let align = C_i32(cx, align.abi() as i32);\n-    let volatile = C_bool(cx, false);\n+    let volatile = C_bool(cx, flags.contains(MemFlags::VOLATILE));\n     bx.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n@@ -427,13 +435,14 @@ pub fn memcpy_ty<'a, 'tcx>(\n     src: ValueRef,\n     layout: TyLayout<'tcx>,\n     align: Align,\n+    flags: MemFlags,\n ) {\n     let size = layout.size.bytes();\n     if size == 0 {\n         return;\n     }\n \n-    call_memcpy(bx, dst, src, C_usize(bx.cx, size), align);\n+    call_memcpy(bx, dst, src, C_usize(bx.cx, size), align, flags);\n }\n \n pub fn call_memset<'a, 'tcx>(bx: &Builder<'a, 'tcx>,"}, {"sha": "4153c61e5269a0af6421794ef958de83968b761f", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd", "patch": "@@ -50,6 +50,13 @@ fn noname() -> *const c_char {\n     &CNULL\n }\n \n+bitflags! {\n+    pub struct MemFlags: u8 {\n+        const VOLATILE = 1 << 0;\n+        const NONTEMPORAL = 1 << 1;\n+    }\n+}\n+\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn new_block<'b>(cx: &'a CodegenCx<'a, 'tcx>, llfn: ValueRef, name: &'b str) -> Self {\n         let bx = Builder::with_cx(cx);\n@@ -579,29 +586,39 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     pub fn store(&self, val: ValueRef, ptr: ValueRef, align: Align) -> ValueRef {\n-        debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n+        self.store_with_flags(val, ptr, align, MemFlags::empty())\n+    }\n+\n+    pub fn store_with_flags(\n+        &self,\n+        val: ValueRef,\n+        ptr: ValueRef,\n+        align: Align,\n+        flags: MemFlags,\n+    ) -> ValueRef {\n+        debug!(\"Store {:?} -> {:?} ({:?})\", Value(val), Value(ptr), flags);\n         assert!(!self.llbuilder.is_null());\n         self.count_insn(\"store\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n             let store = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n             llvm::LLVMSetAlignment(store, align.abi() as c_uint);\n+            if flags.contains(MemFlags::VOLATILE) {\n+                llvm::LLVMSetVolatile(store, llvm::True);\n+            }\n+            if flags.contains(MemFlags::NONTEMPORAL) {\n+                // According to LLVM [1] building a nontemporal store must\n+                // *always* point to a metadata value of the integer 1.\n+                //\n+                // [1]: http://llvm.org/docs/LangRef.html#store-instruction\n+                let one = C_i32(self.cx, 1);\n+                let node = llvm::LLVMMDNodeInContext(self.cx.llcx, &one, 1);\n+                llvm::LLVMSetMetadata(store, llvm::MD_nontemporal as c_uint, node);\n+            }\n             store\n         }\n     }\n \n-    pub fn volatile_store(&self, val: ValueRef, ptr: ValueRef) -> ValueRef {\n-        debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n-        assert!(!self.llbuilder.is_null());\n-        self.count_insn(\"store.volatile\");\n-        let ptr = self.check_store(val, ptr);\n-        unsafe {\n-            let insn = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n-            llvm::LLVMSetVolatile(insn, llvm::True);\n-            insn\n-        }\n-    }\n-\n     pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef,\n                         order: AtomicOrdering, align: Align) {\n         debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n@@ -615,29 +632,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn nontemporal_store(&self, val: ValueRef, ptr: ValueRef) -> ValueRef {\n-        debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n-        assert!(!self.llbuilder.is_null());\n-        self.count_insn(\"store.nontemporal\");\n-        let ptr = self.check_store(val, ptr);\n-        unsafe {\n-            let insn = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n-\n-            // According to LLVM [1] building a nontemporal store must *always*\n-            // point to a metadata value of the integer 1. Who knew?\n-            //\n-            // [1]: http://llvm.org/docs/LangRef.html#store-instruction\n-            let one = C_i32(self.cx, 1);\n-            let node = llvm::LLVMMDNodeInContext(self.cx.llcx,\n-                                                 &one,\n-                                                 1);\n-            llvm::LLVMSetMetadata(insn,\n-                                  llvm::MD_nontemporal as c_uint,\n-                                  node);\n-            insn\n-        }\n-    }\n-\n     pub fn gep(&self, ptr: ValueRef, indices: &[ValueRef]) -> ValueRef {\n         self.count_insn(\"gep\");\n         unsafe {"}, {"sha": "86aa48b6a9e4801085f055240956d31dae7160ad", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd", "patch": "@@ -247,26 +247,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             to_immediate(bx, load, cx.layout_of(tp_ty))\n         },\n         \"volatile_store\" => {\n-            let tp_ty = substs.type_at(0);\n             let dst = args[0].deref(bx.cx);\n-            if let OperandValue::Pair(a, b) = args[1].val {\n-                bx.volatile_store(a, dst.project_field(bx, 0).llval);\n-                bx.volatile_store(b, dst.project_field(bx, 1).llval);\n-            } else {\n-                let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n-                    bx.load(ptr, align)\n-                } else {\n-                    if dst.layout.is_zst() {\n-                        return;\n-                    }\n-                    from_immediate(bx, args[1].immediate())\n-                };\n-                let ptr = bx.pointercast(dst.llval, val_ty(val).ptr_to());\n-                let store = bx.volatile_store(val, ptr);\n-                unsafe {\n-                    llvm::LLVMSetAlignment(store, cx.align_of(tp_ty).abi() as u32);\n-                }\n-            }\n+            args[1].val.volatile_store(bx, dst);\n             return;\n         },\n         \"prefetch_read_data\" | \"prefetch_write_data\" |\n@@ -551,19 +533,9 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n         }\n \n         \"nontemporal_store\" => {\n-            let tp_ty = substs.type_at(0);\n             let dst = args[0].deref(bx.cx);\n-            let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n-                bx.load(ptr, align)\n-            } else {\n-                from_immediate(bx, args[1].immediate())\n-            };\n-            let ptr = bx.pointercast(dst.llval, val_ty(val).ptr_to());\n-            let store = bx.nontemporal_store(val, ptr);\n-            unsafe {\n-                llvm::LLVMSetAlignment(store, cx.align_of(tp_ty).abi() as u32);\n-            }\n-            return\n+            args[1].val.nontemporal_store(bx, dst);\n+            return;\n         }\n \n         _ => {"}, {"sha": "6db95657ce058a95fca93d7d8ecbf6f508f241dc", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd", "patch": "@@ -34,6 +34,7 @@\n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n \n+#[macro_use] extern crate bitflags;\n extern crate flate2;\n extern crate libc;\n #[macro_use] extern crate rustc;"}, {"sha": "e4989da36c02673c4bbaec777197eddb2adc671f", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd", "patch": "@@ -17,7 +17,7 @@ use rustc::mir::interpret::EvalErrorKind;\n use abi::{Abi, ArgType, ArgTypeExt, FnType, FnTypeExt, LlvmType, PassMode};\n use base;\n use callee;\n-use builder::Builder;\n+use builder::{Builder, MemFlags};\n use common::{self, C_bool, C_str_slice, C_struct, C_u32, C_uint_big, C_undef};\n use consts;\n use meth;\n@@ -626,7 +626,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     // have scary latent bugs around.\n \n                     let scratch = PlaceRef::alloca(bx, arg.layout, \"arg\");\n-                    base::memcpy_ty(bx, scratch.llval, llval, op.layout, align);\n+                    base::memcpy_ty(bx, scratch.llval, llval, op.layout, align, MemFlags::empty());\n                     (scratch.llval, scratch.align, true)\n                 } else {\n                     (llval, align, true)"}, {"sha": "be14da1a195bf07b8c9a333e60061ba66b2d41d4", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=7bfa20b8b059b9591dc3782ff4b9f2bf821d81cd", "patch": "@@ -18,7 +18,7 @@ use rustc_data_structures::indexed_vec::Idx;\n \n use base;\n use common::{self, CodegenCx, C_null, C_undef, C_usize};\n-use builder::Builder;\n+use builder::{Builder, MemFlags};\n use value::Value;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n@@ -272,18 +272,32 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n impl<'a, 'tcx> OperandValue {\n     pub fn store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+        self.store_with_flags(bx, dest, MemFlags::empty());\n+    }\n+\n+    pub fn volatile_store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+        self.store_with_flags(bx, dest, MemFlags::VOLATILE);\n+    }\n+\n+    pub fn nontemporal_store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+        self.store_with_flags(bx, dest, MemFlags::NONTEMPORAL);\n+    }\n+\n+    fn store_with_flags(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>, flags: MemFlags) {\n         debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n         // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n         // value is through `undef`, and store itself is useless.\n         if dest.layout.is_zst() {\n             return;\n         }\n         match self {\n-            OperandValue::Ref(r, source_align) =>\n+            OperandValue::Ref(r, source_align) => {\n                 base::memcpy_ty(bx, dest.llval, r, dest.layout,\n-                                source_align.min(dest.align)),\n+                                source_align.min(dest.align), flags)\n+            }\n             OperandValue::Immediate(s) => {\n-                bx.store(base::from_immediate(bx, s), dest.llval, dest.align);\n+                let val = base::from_immediate(bx, s);\n+                bx.store_with_flags(val, dest.llval, dest.align, flags);\n             }\n             OperandValue::Pair(a, b) => {\n                 for (i, &x) in [a, b].iter().enumerate() {\n@@ -292,7 +306,8 @@ impl<'a, 'tcx> OperandValue {\n                     if common::val_ty(x) == Type::i1(bx.cx) {\n                         llptr = bx.pointercast(llptr, Type::i8p(bx.cx));\n                     }\n-                    bx.store(base::from_immediate(bx, x), llptr, dest.align);\n+                    let val = base::from_immediate(bx, x);\n+                    bx.store_with_flags(val, llptr, dest.align, flags);\n                 }\n             }\n         }"}]}