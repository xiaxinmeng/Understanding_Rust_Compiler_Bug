{"sha": "cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkM2E4YzFiN2Y2NmY0ZjkxMDliYTM1NTM0YzhjN2FlM2EzMjVkZmQ=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-05-03T18:23:40Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-05-06T19:44:49Z"}, "message": "Removes unneeded check of `#[no_coverage]` in mapgen\n\nAnd adds tests to validate it still works.\n\nThere is an anticipated feature request to support a compiler flag that\nonly adds coverage for specific files (or perhaps mods). As I thought\nabout where that change would need to be supported, I realized that\nchecking the attribute in mapgen (for unused functions) was unnecessary.\nThe unused functions are only synthesized if they have MIR coverage, and\nfunctions with the `no_coverage` attribute will not have been\ninstrumented with MIR coverage statements in the first place.\n\nNew tests confirm this.\n\nAlso, while adding tests, I updated resolved comments and FIXMEs in\nother tests.", "tree": {"sha": "60c3447d364152ac18ed55c352c2f2e043a929b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60c3447d364152ac18ed55c352c2f2e043a929b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd", "html_url": "https://github.com/rust-lang/rust/commit/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "716394d6581b60c75cfdd88b8e5b876f2db88b62", "url": "https://api.github.com/repos/rust-lang/rust/commits/716394d6581b60c75cfdd88b8e5b876f2db88b62", "html_url": "https://github.com/rust-lang/rust/commit/716394d6581b60c75cfdd88b8e5b876f2db88b62"}], "stats": {"total": 151, "additions": 56, "deletions": 95}, "files": [{"sha": "6fb2661ec8ec186621d9e6a93b376852cdb83e3e", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd", "patch": "@@ -8,7 +8,6 @@ use rustc_codegen_ssa::traits::{ConstMethods, CoverageInfoMethods};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_hir::def_id::{DefId, DefIdSet, LOCAL_CRATE};\n use rustc_llvm::RustString;\n-use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::coverage::CodeRegion;\n use rustc_span::Symbol;\n \n@@ -281,11 +280,8 @@ fn add_unused_functions<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n \n     let mut unused_def_ids_by_file: FxHashMap<Symbol, Vec<DefId>> = FxHashMap::default();\n     for &non_codegenned_def_id in all_def_ids.difference(codegenned_def_ids) {\n-        let codegen_fn_attrs = tcx.codegen_fn_attrs(non_codegenned_def_id);\n-        if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NO_COVERAGE) {\n-            continue;\n-        }\n-        // Make sure the non-codegenned (unused) function has a file_name\n+        // Make sure the non-codegenned (unused) function has at least one MIR\n+        // `Coverage` statement with a code region, and return its file name.\n         if let Some(non_codegenned_file_name) = tcx.covered_file_name(non_codegenned_def_id) {\n             let def_ids =\n                 unused_def_ids_by_file.entry(*non_codegenned_file_name).or_insert_with(Vec::new);"}, {"sha": "322f5681b3fd9278243359047748a891ca46fe21", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.async2.txt", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt?ref=cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd", "patch": "@@ -14,9 +14,9 @@\n    14|      1|    }\n    15|      1|}\n    16|       |\n-   17|       |// FIXME(#83985): The auto-generated closure in an async function is failing to include\n-   18|       |// the println!() and `let` assignment lines in the coverage code region(s), as it does in the\n-   19|       |// non-async function above, unless the `println!()` is inside a covered block.\n+   17|       |\n+   18|       |\n+   19|       |\n    20|      1|async fn async_func() {\n    21|      1|    println!(\"async_func was covered\");\n    22|      1|    let b = true;\n@@ -26,9 +26,9 @@\n                    ^0\n    26|      1|}\n    27|       |\n-   28|       |// FIXME(#83985): As above, this async function only has the `println!()` macro call, which is not\n-   29|       |// showing coverage, so the entire async closure _appears_ uncovered; but this is not exactly true.\n-   30|       |// It's only certain kinds of lines and/or their context that results in missing coverage.\n+   28|       |\n+   29|       |\n+   30|       |\n    31|      1|async fn async_func_just_println() {\n    32|      1|    println!(\"async_func_just_println was covered\");\n    33|      1|}"}, {"sha": "324b9138c4d9c10271c007767fbc080d9f061fb1", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.no_cov_crate.txt", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.no_cov_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.no_cov_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.no_cov_crate.txt?ref=cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd", "patch": "@@ -11,8 +11,27 @@\n    11|       |    println!(\"called but not covered\");\n    12|       |}\n    13|       |\n-   14|      1|fn main() {\n-   15|      1|    do_not_add_coverage_1();\n-   16|      1|    do_not_add_coverage_2();\n-   17|      1|}\n+   14|       |#[no_coverage]\n+   15|       |fn do_not_add_coverage_not_called() {\n+   16|       |    println!(\"not called and not covered\");\n+   17|       |}\n+   18|       |\n+   19|      1|fn add_coverage_1() {\n+   20|      1|    println!(\"called and covered\");\n+   21|      1|}\n+   22|       |\n+   23|      1|fn add_coverage_2() {\n+   24|      1|    println!(\"called and covered\");\n+   25|      1|}\n+   26|       |\n+   27|      0|fn add_coverage_not_called() {\n+   28|      0|    println!(\"not called but covered\");\n+   29|      0|}\n+   30|       |\n+   31|      1|fn main() {\n+   32|      1|    do_not_add_coverage_1();\n+   33|      1|    do_not_add_coverage_2();\n+   34|      1|    add_coverage_1();\n+   35|      1|    add_coverage_2();\n+   36|      1|}\n "}, {"sha": "16eaf7c858c19907993b1d788255effb284d0f23", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.no_cov_func.txt", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/716394d6581b60c75cfdd88b8e5b876f2db88b62/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.no_cov_func.txt", "raw_url": "https://github.com/rust-lang/rust/raw/716394d6581b60c75cfdd88b8e5b876f2db88b62/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.no_cov_func.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.no_cov_func.txt?ref=716394d6581b60c75cfdd88b8e5b876f2db88b62", "patch": "@@ -1,19 +0,0 @@\n-    1|       |// Enables `no_coverage` on individual functions\n-    2|       |\n-    3|       |#[feature(no_coverage)]\n-    4|       |#[no_coverage]\n-    5|       |fn do_not_add_coverage_1() {\n-    6|       |    println!(\"called but not covered\");\n-    7|       |}\n-    8|       |\n-    9|       |#[no_coverage]\n-   10|       |#[feature(no_coverage)]\n-   11|       |fn do_not_add_coverage_2() {\n-   12|       |    println!(\"called but not covered\");\n-   13|       |}\n-   14|       |\n-   15|      1|fn main() {\n-   16|      1|    do_not_add_coverage_1();\n-   17|      1|    do_not_add_coverage_2();\n-   18|      1|}\n-"}, {"sha": "114507dc9fd2add172507e4fbfeaa01083c792b1", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.panic_unwind.txt", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.panic_unwind.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.panic_unwind.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.panic_unwind.txt?ref=cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd", "patch": "@@ -29,22 +29,4 @@\n    29|       |//   2. Since the `panic_unwind.rs` test is allowed to unwind, it is also allowed to execute the\n    30|       |//      normal program exit cleanup, including writing out the current values of the coverage\n    31|       |//      counters.\n-   32|       |//   3. The coverage results show (interestingly) that the `panic!()` call did execute, but it does\n-   33|       |//      not show coverage of the `if countdown == 1` branch in `main()` that calls\n-   34|       |//      `might_panic(true)` (causing the call to `panic!()`).\n-   35|       |//   4. The reason `main()`s `if countdown == 1` branch, calling `might_panic(true)`, appears\n-   36|       |//      \"uncovered\" is, InstrumentCoverage (intentionally) treats `TerminatorKind::Call` terminators\n-   37|       |//      as non-branching, because when a program executes normally, they always are. Errors handled\n-   38|       |//      via the try `?` operator produce error handling branches that *are* treated as branches in\n-   39|       |//      coverage results. By treating calls without try `?` operators as non-branching (assumed to\n-   40|       |//      return normally and continue) the coverage graph can be simplified, producing smaller,\n-   41|       |//      faster binaries, and cleaner coverage results.\n-   42|       |//   5. The reason the coverage results actually show `panic!()` was called is most likely because\n-   43|       |//      `panic!()` is a macro, not a simple function call, and there are other `Statement`s and/or\n-   44|       |//      `Terminator`s that execute with a coverage counter before the panic and unwind occur.\n-   45|       |//   6. Since the common practice is not to use `panic!()` for error handling, the coverage\n-   46|       |//      implementation avoids incurring an additional cost (in program size and execution time) to\n-   47|       |//      improve coverage results for an event that is generally not \"supposed\" to happen.\n-   48|       |//   7. FIXME(#78544): This issue describes a feature request for a proposed option to enable\n-   49|       |//      more accurate coverage results for tests that intentionally panic.\n "}, {"sha": "959d48ce9db160540aa5fcfe86f55e9619d111f1", "filename": "src/test/run-make-fulldeps/coverage/async2.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs?ref=cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd", "patch": "@@ -14,9 +14,9 @@ fn non_async_func() {\n     }\n }\n \n-// FIXME(#83985): The auto-generated closure in an async function is failing to include\n-// the println!() and `let` assignment lines in the coverage code region(s), as it does in the\n-// non-async function above, unless the `println!()` is inside a covered block.\n+\n+\n+\n async fn async_func() {\n     println!(\"async_func was covered\");\n     let b = true;\n@@ -25,9 +25,9 @@ async fn async_func() {\n     }\n }\n \n-// FIXME(#83985): As above, this async function only has the `println!()` macro call, which is not\n-// showing coverage, so the entire async closure _appears_ uncovered; but this is not exactly true.\n-// It's only certain kinds of lines and/or their context that results in missing coverage.\n+\n+\n+\n async fn async_func_just_println() {\n     println!(\"async_func_just_println was covered\");\n }"}, {"sha": "6f8586d9f5ca642ec63c25d8c2f99ad739e1c3c1", "filename": "src/test/run-make-fulldeps/coverage/no_cov_crate.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fno_cov_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fno_cov_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fno_cov_crate.rs?ref=cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd", "patch": "@@ -11,7 +11,26 @@ fn do_not_add_coverage_2() {\n     println!(\"called but not covered\");\n }\n \n+#[no_coverage]\n+fn do_not_add_coverage_not_called() {\n+    println!(\"not called and not covered\");\n+}\n+\n+fn add_coverage_1() {\n+    println!(\"called and covered\");\n+}\n+\n+fn add_coverage_2() {\n+    println!(\"called and covered\");\n+}\n+\n+fn add_coverage_not_called() {\n+    println!(\"not called but covered\");\n+}\n+\n fn main() {\n     do_not_add_coverage_1();\n     do_not_add_coverage_2();\n+    add_coverage_1();\n+    add_coverage_2();\n }"}, {"sha": "e19a2c4a87200ceb2dd2f40832567fe6c72f63b1", "filename": "src/test/run-make-fulldeps/coverage/no_cov_func.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/716394d6581b60c75cfdd88b8e5b876f2db88b62/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fno_cov_func.rs", "raw_url": "https://github.com/rust-lang/rust/raw/716394d6581b60c75cfdd88b8e5b876f2db88b62/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fno_cov_func.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fno_cov_func.rs?ref=716394d6581b60c75cfdd88b8e5b876f2db88b62", "patch": "@@ -1,18 +0,0 @@\n-// Enables `no_coverage` on individual functions\n-\n-#[feature(no_coverage)]\n-#[no_coverage]\n-fn do_not_add_coverage_1() {\n-    println!(\"called but not covered\");\n-}\n-\n-#[no_coverage]\n-#[feature(no_coverage)]\n-fn do_not_add_coverage_2() {\n-    println!(\"called but not covered\");\n-}\n-\n-fn main() {\n-    do_not_add_coverage_1();\n-    do_not_add_coverage_2();\n-}"}, {"sha": "03128c2cce6281160e6e67be0022c448825f7dc1", "filename": "src/test/run-make-fulldeps/coverage/panic_unwind.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fpanic_unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fpanic_unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fpanic_unwind.rs?ref=cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd", "patch": "@@ -29,21 +29,3 @@ fn main() -> Result<(), u8> {\n //   2. Since the `panic_unwind.rs` test is allowed to unwind, it is also allowed to execute the\n //      normal program exit cleanup, including writing out the current values of the coverage\n //      counters.\n-//   3. The coverage results show (interestingly) that the `panic!()` call did execute, but it does\n-//      not show coverage of the `if countdown == 1` branch in `main()` that calls\n-//      `might_panic(true)` (causing the call to `panic!()`).\n-//   4. The reason `main()`s `if countdown == 1` branch, calling `might_panic(true)`, appears\n-//      \"uncovered\" is, InstrumentCoverage (intentionally) treats `TerminatorKind::Call` terminators\n-//      as non-branching, because when a program executes normally, they always are. Errors handled\n-//      via the try `?` operator produce error handling branches that *are* treated as branches in\n-//      coverage results. By treating calls without try `?` operators as non-branching (assumed to\n-//      return normally and continue) the coverage graph can be simplified, producing smaller,\n-//      faster binaries, and cleaner coverage results.\n-//   5. The reason the coverage results actually show `panic!()` was called is most likely because\n-//      `panic!()` is a macro, not a simple function call, and there are other `Statement`s and/or\n-//      `Terminator`s that execute with a coverage counter before the panic and unwind occur.\n-//   6. Since the common practice is not to use `panic!()` for error handling, the coverage\n-//      implementation avoids incurring an additional cost (in program size and execution time) to\n-//      improve coverage results for an event that is generally not \"supposed\" to happen.\n-//   7. FIXME(#78544): This issue describes a feature request for a proposed option to enable\n-//      more accurate coverage results for tests that intentionally panic."}]}