{"sha": "2fa2ad59958d0028c856fb68359edb9a7bd9cab8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYTJhZDU5OTU4ZDAwMjhjODU2ZmI2ODM1OWVkYjlhN2JkOWNhYjg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-05T03:43:14Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-05T18:18:36Z"}, "message": "libcore: Implement an `Equiv` trait and use it on hashmaps.\n\n7.3x speedup in string map search speed on a microbenchmark of pure hashmap\nsearching against a constant string, due to the lack of allocations.\n\nI ran into a few snags.\n\n1. The way the coherence check is set up, I can't implement `Equiv<@str>` and\n   `Equiv<~str>` for `&str` simultaneously.\n\n2. I wanted to implement `Equiv<T>` for all `T:Eq` (i.e. every type can be\n   compared to itself if it implements `Eq`), but the coherence check didn't\n   like that either.\n\n3. I couldn't add this to the `Map` trait because `LinearMap` needs special\n   handling for its `Q` type parameter: it must not only implement `Equiv<T>`\n   but also `Hash` and `Eq`.\n\n4. `find_equiv(&&\"foo\")` doesn't parse, because of the double ampersand. It has\n   to be written `find_equiv(& &\"foo\")`. We can probably just fix this.\n\nNevertheless, this is a huge win; it should address a major source of\nperformance problems, including the one here:\n\nhttp://maniagnosis.crsr.net/2013/02/creating-letterpress-cheating-program.html", "tree": {"sha": "7a5c3fec488e6422a4bf34e0d363cd453e297ec6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a5c3fec488e6422a4bf34e0d363cd453e297ec6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fa2ad59958d0028c856fb68359edb9a7bd9cab8", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fa2ad59958d0028c856fb68359edb9a7bd9cab8", "html_url": "https://github.com/rust-lang/rust/commit/2fa2ad59958d0028c856fb68359edb9a7bd9cab8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fa2ad59958d0028c856fb68359edb9a7bd9cab8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4075492ad46a343bd99d6f258e38ed9c2320418", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4075492ad46a343bd99d6f258e38ed9c2320418", "html_url": "https://github.com/rust-lang/rust/commit/c4075492ad46a343bd99d6f258e38ed9c2320418"}], "stats": {"total": 76, "additions": 73, "deletions": 3}, "files": [{"sha": "ac2afc920ff98aefcc787c95191e311f75ef8170", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fa2ad59958d0028c856fb68359edb9a7bd9cab8/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa2ad59958d0028c856fb68359edb9a7bd9cab8/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=2fa2ad59958d0028c856fb68359edb9a7bd9cab8", "patch": "@@ -150,6 +150,14 @@ pub pure fn gt<T:Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).gt(v2)\n }\n \n+/// The equivalence relation. Two values may be equivalent even if they are\n+/// of different types. The most common use case for this relation is\n+/// container types; e.g. it is often desirable to be able to use `&str`\n+/// values to look up entries in a container with `~str` keys.\n+pub trait Equiv<T> {\n+    pure fn equiv(&self, other: &T) -> bool;\n+}\n+\n #[inline(always)]\n pub pure fn min<T:Ord>(v1: T, v2: T) -> T {\n     if v1 < v2 { v1 } else { v2 }"}, {"sha": "d7e05a62c51189ea49c4f15a30a3dfcf07785c2a", "filename": "src/libcore/container.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fa2ad59958d0028c856fb68359edb9a7bd9cab8/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa2ad59958d0028c856fb68359edb9a7bd9cab8/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=2fa2ad59958d0028c856fb68359edb9a7bd9cab8", "patch": "@@ -10,6 +10,7 @@\n \n //! Container traits\n \n+use cmp::Equiv;\n use option::Option;\n \n pub trait Container {"}, {"sha": "43ec6294bdc5b6f7c057c2a35f9f84dd1cd5675c", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2fa2ad59958d0028c856fb68359edb9a7bd9cab8/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa2ad59958d0028c856fb68359edb9a7bd9cab8/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=2fa2ad59958d0028c856fb68359edb9a7bd9cab8", "patch": "@@ -13,7 +13,7 @@\n /// Open addressing with linear probing.\n pub mod linear {\n     use container::{Container, Mutable, Map, Set};\n-    use cmp::Eq;\n+    use cmp::{Eq, Equiv};\n     use hash::Hash;\n     use to_bytes::IterBytes;\n     use iter::BaseIter;\n@@ -107,6 +107,15 @@ pub mod linear {\n             self.bucket_for_key_with_hash(hash, k)\n         }\n \n+        #[inline(always)]\n+        pure fn bucket_for_key_equiv<Q:Hash + IterBytes + Equiv<K>>(\n+                &self,\n+                k: &Q)\n+             -> SearchResult {\n+            let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+            self.bucket_for_key_with_hash_equiv(hash, k)\n+        }\n+\n         #[inline(always)]\n         pure fn bucket_for_key_with_hash(&self,\n                                          hash: uint,\n@@ -122,6 +131,24 @@ pub mod linear {\n             TableFull\n         }\n \n+        #[inline(always)]\n+        pure fn bucket_for_key_with_hash_equiv<Q:Equiv<K>>(&self,\n+                                                           hash: uint,\n+                                                           k: &Q)\n+                                                        -> SearchResult {\n+            let _ = for self.bucket_sequence(hash) |i| {\n+                match self.buckets[i] {\n+                    Some(ref bkt) => {\n+                        if bkt.hash == hash && k.equiv(&bkt.key) {\n+                            return FoundEntry(i);\n+                        }\n+                    },\n+                    None => return FoundHole(i)\n+                }\n+            };\n+            TableFull\n+        }\n+\n         /// Expand the capacity of the array to the next power of two\n         /// and re-insert each of the existing buckets.\n         #[inline(always)]\n@@ -450,6 +477,28 @@ pub mod linear {\n                 None => fail!(fmt!(\"No entry found for key: %?\", k)),\n             }\n         }\n+\n+        /// Return true if the map contains a value for the specified key,\n+        /// using equivalence\n+        pure fn contains_key_equiv<Q:Hash + IterBytes + Equiv<K>>(\n+                &self,\n+                key: &Q)\n+             -> bool {\n+            match self.bucket_for_key_equiv(key) {\n+                FoundEntry(_) => {true}\n+                TableFull | FoundHole(_) => {false}\n+            }\n+        }\n+\n+        /// Return the value corresponding to the key in the map, using\n+        /// equivalence\n+        pure fn find_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, k: &Q)\n+                                                       -> Option<&self/V> {\n+            match self.bucket_for_key_equiv(k) {\n+                FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n+                TableFull | FoundHole(_) => None,\n+            }\n+        }\n     }\n \n     impl<K:Hash + IterBytes + Eq,V:Eq> Eq for LinearMap<K, V> {"}, {"sha": "24b2d8b5813267a6f677d7d8ab90be440b53d994", "filename": "src/libcore/str.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fa2ad59958d0028c856fb68359edb9a7bd9cab8/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa2ad59958d0028c856fb68359edb9a7bd9cab8/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=2fa2ad59958d0028c856fb68359edb9a7bd9cab8", "patch": "@@ -20,7 +20,7 @@\n use at_vec;\n use cast;\n use char;\n-use cmp::{TotalOrd, Ordering, Less, Equal, Greater};\n+use cmp::{Equiv, TotalOrd, Ordering, Less, Equal, Greater};\n use libc;\n use option::{None, Option, Some};\n use ptr;\n@@ -898,6 +898,12 @@ impl Ord for @str {\n     pure fn gt(&self, other: &@str) -> bool { gt((*self), (*other)) }\n }\n \n+#[cfg(notest)]\n+impl Equiv<~str> for &str {\n+    #[inline(always)]\n+    pure fn equiv(&self, other: &~str) -> bool { eq_slice(*self, *other) }\n+}\n+\n /*\n Section: Iterating through strings\n */"}, {"sha": "ab5f04ace79c0035fcae3789d6c69c1971e8ba8e", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fa2ad59958d0028c856fb68359edb9a7bd9cab8/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa2ad59958d0028c856fb68359edb9a7bd9cab8/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=2fa2ad59958d0028c856fb68359edb9a7bd9cab8", "patch": "@@ -14,7 +14,7 @@\n \n use container::{Container, Mutable};\n use cast;\n-use cmp::{Eq, Ord, TotalOrd, Ordering, Less, Equal, Greater};\n+use cmp::{Eq, Equiv, Ord, TotalOrd, Ordering, Less, Equal, Greater};\n use iter::BaseIter;\n use iter;\n use kinds::Copy;\n@@ -1572,6 +1572,12 @@ impl<T:Eq> Eq for @[T] {\n     pure fn ne(&self, other: &@[T]) -> bool { !(*self).eq(other) }\n }\n \n+#[cfg(notest)]\n+impl<T:Eq> Equiv<~[T]> for &[T] {\n+    #[inline(always)]\n+    pure fn equiv(&self, other: &~[T]) -> bool { eq(*self, *other) }\n+}\n+\n // Lexicographical comparison\n \n pure fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {"}]}