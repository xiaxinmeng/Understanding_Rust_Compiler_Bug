{"sha": "565a9bf20b726c5182a6c4c816c1d9a4108c778a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NWE5YmYyMGI3MjZjNTE4MmE2YzRjODE2YzFkOWE0MTA4Yzc3OGE=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-07-21T13:33:40Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-07-21T14:43:06Z"}, "message": "Provide lower level access to the LLVM IR builder\n\nCurrently, the helper functions in the \"build\" module can only append\nat the end of a block. For certain things we'll want to be able to\ninsert code at arbitrary locations inside a block though. Although can\nwe do that by directly calling the LLVM functions, that is rather ugly\nand means that somethings need to be implemented twice. Once in terms\nof the helper functions and once in terms of low level LLVM functions.\n\nInstead of doing that, we should provide a Builder type that provides\nlow level access to the builder, and which can be used by both, the\nhelper functions in the \"build\" module, as well larger units of\nabstractions that combine several LLVM instructions.", "tree": {"sha": "448c6a99b3cc447c2ef2e45ec5b1616f8eb42778", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/448c6a99b3cc447c2ef2e45ec5b1616f8eb42778"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/565a9bf20b726c5182a6c4c816c1d9a4108c778a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/565a9bf20b726c5182a6c4c816c1d9a4108c778a", "html_url": "https://github.com/rust-lang/rust/commit/565a9bf20b726c5182a6c4c816c1d9a4108c778a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/565a9bf20b726c5182a6c4c816c1d9a4108c778a/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cccdbd9ccccd8768caea7cdf03e88a4f26ea301", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cccdbd9ccccd8768caea7cdf03e88a4f26ea301", "html_url": "https://github.com/rust-lang/rust/commit/3cccdbd9ccccd8768caea7cdf03e88a4f26ea301"}], "stats": {"total": 1717, "additions": 1149, "deletions": 568}, "files": [{"sha": "5536fa6daa73aa69f62562bd73699570b3be814c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/565a9bf20b726c5182a6c4c816c1d9a4108c778a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565a9bf20b726c5182a6c4c816c1d9a4108c778a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=565a9bf20b726c5182a6c4c816c1d9a4108c778a", "patch": "@@ -41,6 +41,7 @@ use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::build::*;\n+use middle::trans::builder::noname;\n use middle::trans::callee;\n use middle::trans::common::*;\n use middle::trans::consts;"}, {"sha": "7861f658f53e8689da513b044a044bf73bb67d71", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 193, "deletions": 566, "changes": 759, "blob_url": "https://github.com/rust-lang/rust/blob/565a9bf20b726c5182a6c4c816c1d9a4108c778a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565a9bf20b726c5182a6c4c816c1d9a4108c778a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=565a9bf20b726c5182a6c4c816c1d9a4108c778a", "patch": "@@ -11,21 +11,17 @@\n \n use lib::llvm::llvm;\n use lib::llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};\n-use lib::llvm::{Opcode, IntPredicate, RealPredicate, False};\n-use lib::llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n+use lib::llvm::{Opcode, IntPredicate, RealPredicate};\n+use lib::llvm::{ValueRef, BasicBlockRef};\n use lib;\n use middle::trans::common::*;\n-use middle::trans::machine::llalign_of_min;\n use syntax::codemap::span;\n \n-use middle::trans::base;\n+use middle::trans::builder::Builder;\n use middle::trans::type_::Type;\n \n use std::cast;\n use std::libc::{c_uint, c_ulonglong, c_char};\n-use std::hashmap::HashMap;\n-use std::str;\n-use std::vec;\n \n pub fn terminate(cx: block, _: &str) {\n     cx.terminated = true;\n@@ -37,56 +33,12 @@ pub fn check_not_terminated(cx: block) {\n     }\n }\n \n-pub fn B(cx: block) -> BuilderRef {\n-    unsafe {\n-        let b = cx.fcx.ccx.builder.B;\n-        llvm::LLVMPositionBuilderAtEnd(b, cx.llbb);\n-        return b;\n-    }\n-}\n-\n-pub fn count_insn(cx: block, category: &str) {\n-    if cx.ccx().sess.trans_stats() {\n-        cx.ccx().stats.n_llvm_insns += 1;\n-    }\n-    do base::with_insn_ctxt |v| {\n-        let h = &mut cx.ccx().stats.llvm_insns;\n-\n-        // Build version of path with cycles removed.\n-\n-        // Pass 1: scan table mapping str -> rightmost pos.\n-        let mut mm = HashMap::new();\n-        let len = v.len();\n-        let mut i = 0u;\n-        while i < len {\n-            mm.insert(v[i], i);\n-            i += 1u;\n-        }\n-\n-        // Pass 2: concat strings for each elt, skipping\n-        // forwards over any cycles by advancing to rightmost\n-        // occurrence of each element in path.\n-        let mut s = ~\".\";\n-        i = 0u;\n-        while i < len {\n-            i = *mm.get(&v[i]);\n-            s.push_char('/');\n-            s.push_str(v[i]);\n-            i += 1u;\n-        }\n-\n-        s.push_char('/');\n-        s.push_str(category);\n-\n-        let n = match h.find(&s) {\n-          Some(&n) => n,\n-          _ => 0u\n-        };\n-        h.insert(s, n+1u);\n-    }\n+pub fn B(cx: block) -> Builder {\n+    let b = cx.fcx.ccx.builder();\n+    b.position_at_end(cx.llbb);\n+    b\n }\n \n-\n // The difference between a block being unreachable and being terminated is\n // somewhat obscure, and has to do with error checking. When a block is\n // terminated, we're saying that trying to add any further statements in the\n@@ -96,64 +48,47 @@ pub fn count_insn(cx: block, category: &str) {\n // further instructions to the block should simply be ignored.\n \n pub fn RetVoid(cx: block) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        check_not_terminated(cx);\n-        terminate(cx, \"RetVoid\");\n-        count_insn(cx, \"retvoid\");\n-        llvm::LLVMBuildRetVoid(B(cx));\n-    }\n+    if cx.unreachable { return; }\n+    check_not_terminated(cx);\n+    terminate(cx, \"RetVoid\");\n+    B(cx).ret_void();\n }\n \n pub fn Ret(cx: block, V: ValueRef) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        check_not_terminated(cx);\n-        terminate(cx, \"Ret\");\n-        count_insn(cx, \"ret\");\n-        llvm::LLVMBuildRet(B(cx), V);\n-    }\n+    if cx.unreachable { return; }\n+    check_not_terminated(cx);\n+    terminate(cx, \"Ret\");\n+    B(cx).ret(V);\n }\n \n pub fn AggregateRet(cx: block, RetVals: &[ValueRef]) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"AggregateRet\");\n-    unsafe {\n-        llvm::LLVMBuildAggregateRet(B(cx), vec::raw::to_ptr(RetVals),\n-                                    RetVals.len() as c_uint);\n-    }\n+    B(cx).aggregate_ret(RetVals);\n }\n \n pub fn Br(cx: block, Dest: BasicBlockRef) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        check_not_terminated(cx);\n-        terminate(cx, \"Br\");\n-        count_insn(cx, \"br\");\n-        llvm::LLVMBuildBr(B(cx), Dest);\n-    }\n+    if cx.unreachable { return; }\n+    check_not_terminated(cx);\n+    terminate(cx, \"Br\");\n+    B(cx).br(Dest);\n }\n \n pub fn CondBr(cx: block, If: ValueRef, Then: BasicBlockRef,\n               Else: BasicBlockRef) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        check_not_terminated(cx);\n-        terminate(cx, \"CondBr\");\n-        count_insn(cx, \"condbr\");\n-        llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n-    }\n+    if cx.unreachable { return; }\n+    check_not_terminated(cx);\n+    terminate(cx, \"CondBr\");\n+    B(cx).cond_br(If, Then, Else);\n }\n \n pub fn Switch(cx: block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n     -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(V); }\n-        check_not_terminated(cx);\n-        terminate(cx, \"Switch\");\n-        return llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases as c_uint);\n-    }\n+    if cx.unreachable { return _Undef(V); }\n+    check_not_terminated(cx);\n+    terminate(cx, \"Switch\");\n+    B(cx).switch(V, Else, NumCases)\n }\n \n pub fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n@@ -164,22 +99,10 @@ pub fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n }\n \n pub fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        check_not_terminated(cx);\n-        terminate(cx, \"IndirectBr\");\n-        count_insn(cx, \"indirectbr\");\n-        llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests as c_uint);\n-    }\n-}\n-\n-// This is a really awful way to get a zero-length c-string, but better (and a\n-// lot more efficient) than doing str::as_c_str(\"\", ...) every time.\n-pub fn noname() -> *c_char {\n-    unsafe {\n-        static cnull: uint = 0u;\n-        return cast::transmute(&cnull);\n-    }\n+    if cx.unreachable { return; }\n+    check_not_terminated(cx);\n+    terminate(cx, \"IndirectBr\");\n+    B(cx).indirect_br(Addr, NumDests);\n }\n \n pub fn Invoke(cx: block,\n@@ -196,40 +119,22 @@ pub fn Invoke(cx: block,\n     debug!(\"Invoke(%s with arguments (%s))\",\n            cx.val_to_str(Fn),\n            Args.map(|a| cx.val_to_str(*a)).connect(\", \"));\n-    unsafe {\n-        count_insn(cx, \"invoke\");\n-        llvm::LLVMBuildInvoke(B(cx),\n-                              Fn,\n-                              vec::raw::to_ptr(Args),\n-                              Args.len() as c_uint,\n-                              Then,\n-                              Catch,\n-                              noname())\n-    }\n+    B(cx).invoke(Fn, Args, Then, Catch)\n }\n \n pub fn FastInvoke(cx: block, Fn: ValueRef, Args: &[ValueRef],\n                   Then: BasicBlockRef, Catch: BasicBlockRef) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"FastInvoke\");\n-    unsafe {\n-        count_insn(cx, \"fastinvoke\");\n-        let v = llvm::LLVMBuildInvoke(B(cx), Fn, vec::raw::to_ptr(Args),\n-                                      Args.len() as c_uint,\n-                                      Then, Catch, noname());\n-        lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n-    }\n+    B(cx).fast_invoke(Fn, Args, Then, Catch);\n }\n \n pub fn Unreachable(cx: block) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        cx.unreachable = true;\n-        if !cx.terminated {\n-            count_insn(cx, \"unreachable\");\n-            llvm::LLVMBuildUnreachable(B(cx));\n-        }\n+    if cx.unreachable { return; }\n+    cx.unreachable = true;\n+    if !cx.terminated {\n+        B(cx).unreachable();\n     }\n }\n \n@@ -241,298 +146,192 @@ pub fn _Undef(val: ValueRef) -> ValueRef {\n \n /* Arithmetic */\n pub fn Add(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"add\");\n-        return llvm::LLVMBuildAdd(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).add(LHS, RHS)\n }\n \n pub fn NSWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"nswadd\");\n-        return llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).nswadd(LHS, RHS)\n }\n \n pub fn NUWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"nuwadd\");\n-        return llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).nuwadd(LHS, RHS)\n }\n \n pub fn FAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"fadd\");\n-        return llvm::LLVMBuildFAdd(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).fadd(LHS, RHS)\n }\n \n pub fn Sub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"sub\");\n-        return llvm::LLVMBuildSub(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).sub(LHS, RHS)\n }\n \n pub fn NSWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"nwsub\");\n-        return llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).nswsub(LHS, RHS)\n }\n \n pub fn NUWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"nuwsub\");\n-        return llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).nuwsub(LHS, RHS)\n }\n \n pub fn FSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"sub\");\n-        return llvm::LLVMBuildFSub(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).fsub(LHS, RHS)\n }\n \n pub fn Mul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"mul\");\n-        return llvm::LLVMBuildMul(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).mul(LHS, RHS)\n }\n \n pub fn NSWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"nswmul\");\n-        return llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).nswmul(LHS, RHS)\n }\n \n pub fn NUWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"nuwmul\");\n-        return llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).nuwmul(LHS, RHS)\n }\n \n pub fn FMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"fmul\");\n-        return llvm::LLVMBuildFMul(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).fmul(LHS, RHS)\n }\n \n pub fn UDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"udiv\");\n-        return llvm::LLVMBuildUDiv(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).udiv(LHS, RHS)\n }\n \n pub fn SDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"sdiv\");\n-        return llvm::LLVMBuildSDiv(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).sdiv(LHS, RHS)\n }\n \n pub fn ExactSDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"extractsdiv\");\n-        return llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).exactsdiv(LHS, RHS)\n }\n \n pub fn FDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"fdiv\");\n-        return llvm::LLVMBuildFDiv(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).fdiv(LHS, RHS)\n }\n \n pub fn URem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"urem\");\n-        return llvm::LLVMBuildURem(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).urem(LHS, RHS)\n }\n \n pub fn SRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"srem\");\n-        return llvm::LLVMBuildSRem(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).srem(LHS, RHS)\n }\n \n pub fn FRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"frem\");\n-        return llvm::LLVMBuildFRem(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).frem(LHS, RHS)\n }\n \n pub fn Shl(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"shl\");\n-        return llvm::LLVMBuildShl(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).shl(LHS, RHS)\n }\n \n pub fn LShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"lshr\");\n-        return llvm::LLVMBuildLShr(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).lshr(LHS, RHS)\n }\n \n pub fn AShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"ashr\");\n-        return llvm::LLVMBuildAShr(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).ashr(LHS, RHS)\n }\n \n pub fn And(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"and\");\n-        return llvm::LLVMBuildAnd(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).and(LHS, RHS)\n }\n \n pub fn Or(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"or\");\n-        return llvm::LLVMBuildOr(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).or(LHS, RHS)\n }\n \n pub fn Xor(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"xor\");\n-        return llvm::LLVMBuildXor(B(cx), LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).xor(LHS, RHS)\n }\n \n pub fn BinOp(cx: block, Op: Opcode, LHS: ValueRef, RHS: ValueRef)\n           -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(LHS); }\n-        count_insn(cx, \"binop\");\n-        return llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, noname());\n-    }\n+    if cx.unreachable { return _Undef(LHS); }\n+    B(cx).binop(Op, LHS, RHS)\n }\n \n pub fn Neg(cx: block, V: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(V); }\n-        count_insn(cx, \"neg\");\n-        return llvm::LLVMBuildNeg(B(cx), V, noname());\n-    }\n+    if cx.unreachable { return _Undef(V); }\n+    B(cx).neg(V)\n }\n \n pub fn NSWNeg(cx: block, V: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(V); }\n-        count_insn(cx, \"nswneg\");\n-        return llvm::LLVMBuildNSWNeg(B(cx), V, noname());\n-    }\n+    if cx.unreachable { return _Undef(V); }\n+    B(cx).nswneg(V)\n }\n \n pub fn NUWNeg(cx: block, V: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(V); }\n-        count_insn(cx, \"nuwneg\");\n-        return llvm::LLVMBuildNUWNeg(B(cx), V, noname());\n-    }\n+    if cx.unreachable { return _Undef(V); }\n+    B(cx).nuwneg(V)\n }\n pub fn FNeg(cx: block, V: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(V); }\n-        count_insn(cx, \"fneg\");\n-        return llvm::LLVMBuildFNeg(B(cx), V, noname());\n-    }\n+    if cx.unreachable { return _Undef(V); }\n+    B(cx).fneg(V)\n }\n \n pub fn Not(cx: block, V: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(V); }\n-        count_insn(cx, \"not\");\n-        return llvm::LLVMBuildNot(B(cx), V, noname());\n-    }\n+    if cx.unreachable { return _Undef(V); }\n+    B(cx).not(V)\n }\n \n /* Memory */\n pub fn Malloc(cx: block, Ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n-        count_insn(cx, \"malloc\");\n-        return llvm::LLVMBuildMalloc(B(cx), Ty.to_ref(), noname());\n+        B(cx).malloc(Ty)\n     }\n }\n \n pub fn ArrayMalloc(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n-        count_insn(cx, \"arraymalloc\");\n-        return llvm::LLVMBuildArrayMalloc(B(cx), Ty.to_ref(), Val, noname());\n+        B(cx).array_malloc(Ty, Val)\n     }\n }\n \n pub fn Alloca(cx: block, Ty: Type, name: &str) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n-        count_insn(cx, \"alloca\");\n-        if name.is_empty() {\n-            llvm::LLVMBuildAlloca(B(cx), Ty.to_ref(), noname())\n-        } else {\n-            str::as_c_str(\n-                name,\n-                |c| llvm::LLVMBuildAlloca(B(cx), Ty.to_ref(), c))\n-        }\n+        B(cx).alloca(Ty, name)\n     }\n }\n \n pub fn ArrayAlloca(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n-        count_insn(cx, \"arrayalloca\");\n-        return llvm::LLVMBuildArrayAlloca(B(cx), Ty.to_ref(), Val, noname());\n+        B(cx).array_alloca(Ty, Val)\n     }\n }\n \n pub fn Free(cx: block, PointerVal: ValueRef) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        count_insn(cx, \"free\");\n-        llvm::LLVMBuildFree(B(cx), PointerVal);\n-    }\n+    if cx.unreachable { return; }\n+    B(cx).free(PointerVal)\n }\n \n pub fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n@@ -547,8 +346,7 @@ pub fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n             };\n             return llvm::LLVMGetUndef(eltty.to_ref());\n         }\n-        count_insn(cx, \"load\");\n-        return llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n+        B(cx).load(PointerVal)\n     }\n }\n \n@@ -558,272 +356,216 @@ pub fn AtomicLoad(cx: block, PointerVal: ValueRef, order: AtomicOrdering) -> Val\n         if cx.unreachable {\n             return llvm::LLVMGetUndef(ccx.int_type.to_ref());\n         }\n-        count_insn(cx, \"load.atomic\");\n-        let align = llalign_of_min(ccx, ccx.int_type);\n-        return llvm::LLVMBuildAtomicLoad(B(cx), PointerVal, noname(), order, align as c_uint);\n+        B(cx).atomic_load(PointerVal, order)\n     }\n }\n \n \n pub fn LoadRangeAssert(cx: block, PointerVal: ValueRef, lo: c_ulonglong,\n                        hi: c_ulonglong, signed: lib::llvm::Bool) -> ValueRef {\n-    let value = Load(cx, PointerVal);\n-\n-    if !cx.unreachable {\n+    if cx.unreachable {\n+        let ccx = cx.fcx.ccx;\n+        let ty = val_ty(PointerVal);\n+        let eltty = if ty.kind() == lib::llvm::Array {\n+            ty.element_type()\n+        } else {\n+            ccx.int_type\n+        };\n         unsafe {\n-            let t = llvm::LLVMGetElementType(llvm::LLVMTypeOf(PointerVal));\n-            let min = llvm::LLVMConstInt(t, lo, signed);\n-            let max = llvm::LLVMConstInt(t, hi, signed);\n-\n-            do [min, max].as_imm_buf |ptr, len| {\n-                llvm::LLVMSetMetadata(value, lib::llvm::MD_range as c_uint,\n-                                      llvm::LLVMMDNodeInContext(cx.fcx.ccx.llcx,\n-                                                                ptr, len as c_uint));\n-            }\n+            llvm::LLVMGetUndef(eltty.to_ref())\n         }\n+    } else {\n+        B(cx).load_range_assert(PointerVal, lo, hi, signed)\n     }\n-\n-    value\n }\n \n pub fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        debug!(\"Store %s -> %s\",\n-               cx.val_to_str(Val),\n-               cx.val_to_str(Ptr));\n-        count_insn(cx, \"store\");\n-        llvm::LLVMBuildStore(B(cx), Val, Ptr);\n-    }\n+    if cx.unreachable { return; }\n+    B(cx).store(Val, Ptr)\n }\n \n pub fn AtomicStore(cx: block, Val: ValueRef, Ptr: ValueRef, order: AtomicOrdering) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        debug!(\"Store %s -> %s\",\n-               cx.val_to_str(Val),\n-               cx.val_to_str(Ptr));\n-        count_insn(cx, \"store.atomic\");\n-        let align = llalign_of_min(cx.ccx(), cx.ccx().int_type);\n-        llvm::LLVMBuildAtomicStore(B(cx), Val, Ptr, order, align as c_uint);\n-    }\n+    if cx.unreachable { return; }\n+    B(cx).atomic_store(Val, Ptr, order)\n }\n \n pub fn GEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n-        count_insn(cx, \"gep\");\n-        return llvm::LLVMBuildGEP(B(cx), Pointer, vec::raw::to_ptr(Indices),\n-                                   Indices.len() as c_uint, noname());\n+        B(cx).gep(Pointer, Indices)\n     }\n }\n \n // Simple wrapper around GEP that takes an array of ints and wraps them\n // in C_i32()\n #[inline]\n pub fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n-    // Small vector optimization. This should catch 100% of the cases that\n-    // we care about.\n-    if ixs.len() < 16 {\n-        let mut small_vec = [ C_i32(0), ..16 ];\n-        for small_vec.mut_iter().zip(ixs.iter()).advance |(small_vec_e, &ix)| {\n-            *small_vec_e = C_i32(ix as i32);\n-        }\n-        InBoundsGEP(cx, base, small_vec.slice(0, ixs.len()))\n-    } else {\n-        let v = do ixs.iter().transform |i| { C_i32(*i as i32) }.collect::<~[ValueRef]>();\n-        count_insn(cx, \"gepi\");\n-        InBoundsGEP(cx, base, v)\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        B(cx).gepi(base, ixs)\n     }\n }\n \n pub fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n-        count_insn(cx, \"inboundsgep\");\n-        return llvm::LLVMBuildInBoundsGEP(\n-            B(cx), Pointer, vec::raw::to_ptr(Indices), Indices.len() as c_uint, noname());\n+        B(cx).inbounds_gep(Pointer, Indices)\n     }\n }\n \n pub fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n-        count_insn(cx, \"structgep\");\n-        return llvm::LLVMBuildStructGEP(B(cx),\n-                                        Pointer,\n-                                        Idx as c_uint,\n-                                        noname());\n+        B(cx).struct_gep(Pointer, Idx)\n     }\n }\n \n pub fn GlobalString(cx: block, _Str: *c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n-        count_insn(cx, \"globalstring\");\n-        return llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n+        B(cx).global_string(_Str)\n     }\n }\n \n pub fn GlobalStringPtr(cx: block, _Str: *c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n-        count_insn(cx, \"globalstringptr\");\n-        return llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n+        B(cx).global_string_ptr(_Str)\n     }\n }\n \n /* Casts */\n pub fn Trunc(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"trunc\");\n-        return llvm::LLVMBuildTrunc(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).trunc(Val, DestTy)\n     }\n }\n \n pub fn ZExt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"zext\");\n-        return llvm::LLVMBuildZExt(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).zext(Val, DestTy)\n     }\n }\n \n pub fn SExt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"sext\");\n-        return llvm::LLVMBuildSExt(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).sext(Val, DestTy)\n     }\n }\n \n pub fn FPToUI(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"fptoui\");\n-        return llvm::LLVMBuildFPToUI(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).fptoui(Val, DestTy)\n     }\n }\n \n pub fn FPToSI(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"fptosi\");\n-        return llvm::LLVMBuildFPToSI(B(cx), Val, DestTy.to_ref(),noname());\n+        B(cx).fptosi(Val, DestTy)\n     }\n }\n \n pub fn UIToFP(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"uitofp\");\n-        return llvm::LLVMBuildUIToFP(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).uitofp(Val, DestTy)\n     }\n }\n \n pub fn SIToFP(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"sitofp\");\n-        return llvm::LLVMBuildSIToFP(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).sitofp(Val, DestTy)\n     }\n }\n \n pub fn FPTrunc(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"fptrunc\");\n-        return llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).fptrunc(Val, DestTy)\n     }\n }\n \n pub fn FPExt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"fpext\");\n-        return llvm::LLVMBuildFPExt(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).fpext(Val, DestTy)\n     }\n }\n \n pub fn PtrToInt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"ptrtoint\");\n-        return llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).ptrtoint(Val, DestTy)\n     }\n }\n \n pub fn IntToPtr(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"inttoptr\");\n-        return llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).inttoptr(Val, DestTy)\n     }\n }\n \n pub fn BitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"bitcast\");\n-        return llvm::LLVMBuildBitCast(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).bitcast(Val, DestTy)\n     }\n }\n \n pub fn ZExtOrBitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"zextorbitcast\");\n-        return llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).zext_or_bitcast(Val, DestTy)\n     }\n }\n \n pub fn SExtOrBitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"sextorbitcast\");\n-        return llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).sext_or_bitcast(Val, DestTy)\n     }\n }\n \n pub fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"truncorbitcast\");\n-        return llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).trunc_or_bitcast(Val, DestTy)\n     }\n }\n \n pub fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: Type, _: *u8)\n      -> ValueRef {\n     unsafe {\n-        count_insn(cx, \"cast\");\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        return llvm::LLVMBuildCast(B(cx), Op, Val, DestTy.to_ref(), noname());\n+        B(cx).cast(Op, Val, DestTy)\n     }\n }\n \n pub fn PointerCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"pointercast\");\n-        return llvm::LLVMBuildPointerCast(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).pointercast(Val, DestTy)\n     }\n }\n \n pub fn IntCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"intcast\");\n-        return llvm::LLVMBuildIntCast(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).intcast(Val, DestTy)\n     }\n }\n \n pub fn FPCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        count_insn(cx, \"fpcast\");\n-        return llvm::LLVMBuildFPCast(B(cx), Val, DestTy.to_ref(), noname());\n+        B(cx).fpcast(Val, DestTy)\n     }\n }\n \n@@ -833,40 +575,30 @@ pub fn ICmp(cx: block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n-        count_insn(cx, \"icmp\");\n-        return llvm::LLVMBuildICmp(B(cx), Op as c_uint, LHS, RHS, noname());\n+        B(cx).icmp(Op, LHS, RHS)\n     }\n }\n \n pub fn FCmp(cx: block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n-        count_insn(cx, \"fcmp\");\n-        return llvm::LLVMBuildFCmp(B(cx), Op as c_uint, LHS, RHS, noname());\n+        B(cx).fcmp(Op, LHS, RHS)\n     }\n }\n \n /* Miscellaneous instructions */\n pub fn EmptyPhi(cx: block, Ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n-        count_insn(cx, \"emptyphi\");\n-        return llvm::LLVMBuildPhi(B(cx), Ty.to_ref(), noname());\n+        B(cx).empty_phi(Ty)\n     }\n }\n \n-pub fn Phi(cx: block, Ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef])\n-    -> ValueRef {\n+pub fn Phi(cx: block, Ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n-        assert_eq!(vals.len(), bbs.len());\n-        let phi = EmptyPhi(cx, Ty);\n-        count_insn(cx, \"addincoming\");\n-        llvm::LLVMAddIncoming(phi, vec::raw::to_ptr(vals),\n-                              vec::raw::to_ptr(bbs),\n-                              vals.len() as c_uint);\n-        return phi;\n+        B(cx).phi(Ty, vals, bbs)\n     }\n }\n \n@@ -888,253 +620,148 @@ pub fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n         } else {\n             ccx.int_type\n         };\n-        count_insn(cx, \"ret_undef\");\n-        return llvm::LLVMGetUndef(retty.to_ref());\n+        B(cx).count_insn(\"ret_undef\");\n+        llvm::LLVMGetUndef(retty.to_ref())\n     }\n }\n \n-pub fn add_span_comment(bcx: block, sp: span, text: &str) {\n-    let ccx = bcx.ccx();\n-    if ccx.sess.asm_comments() {\n-        let s = fmt!(\"%s (%s)\", text, ccx.sess.codemap.span_to_str(sp));\n-        debug!(\"%s\", s);\n-        add_comment(bcx, s);\n-    }\n+pub fn add_span_comment(cx: block, sp: span, text: &str) {\n+    B(cx).add_span_comment(sp, text)\n }\n \n-pub fn add_comment(bcx: block, text: &str) {\n-    unsafe {\n-        let ccx = bcx.ccx();\n-        if ccx.sess.asm_comments() {\n-            let sanitized = text.replace(\"$\", \"\");\n-            let comment_text = ~\"# \" +\n-                sanitized.replace(\"\\n\", \"\\n\\t# \");\n-            count_insn(bcx, \"inlineasm\");\n-            let asm = do comment_text.as_c_str |c| {\n-                llvm::LLVMConstInlineAsm(Type::func([], &Type::void()).to_ref(),\n-                                         c, noname(), False, False)\n-            };\n-            Call(bcx, asm, []);\n-        }\n-    }\n+pub fn add_comment(cx: block, text: &str) {\n+    B(cx).add_comment(text)\n }\n \n pub fn InlineAsmCall(cx: block, asm: *c_char, cons: *c_char,\n                      inputs: &[ValueRef], output: Type,\n                      volatile: bool, alignstack: bool,\n                      dia: AsmDialect) -> ValueRef {\n-    unsafe {\n-        count_insn(cx, \"inlineasm\");\n-\n-        let volatile = if volatile { lib::llvm::True }\n-                       else        { lib::llvm::False };\n-        let alignstack = if alignstack { lib::llvm::True }\n-                         else          { lib::llvm::False };\n-\n-        let argtys = do inputs.map |v| {\n-            debug!(\"Asm Input Type: %?\", cx.val_to_str(*v));\n-            val_ty(*v)\n-        };\n-\n-        debug!(\"Asm Output Type: %?\", cx.ccx().tn.type_to_str(output));\n-        let fty = Type::func(argtys, &output);\n-        let v = llvm::LLVMInlineAsm(fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n-\n-        Call(cx, v, inputs)\n-    }\n+    B(cx).inline_asm_call(asm, cons, inputs, output, volatile, alignstack, dia)\n }\n \n pub fn Call(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n-    unsafe {\n-        count_insn(cx, \"call\");\n-\n-        debug!(\"Call(Fn=%s, Args=%?)\",\n-               cx.val_to_str(Fn),\n-               Args.map(|arg| cx.val_to_str(*arg)));\n-\n-        do Args.as_imm_buf |ptr, len| {\n-            llvm::LLVMBuildCall(B(cx), Fn, ptr, len as c_uint, noname())\n-        }\n-    }\n+    B(cx).call(Fn, Args)\n }\n \n pub fn FastCall(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n-    unsafe {\n-        count_insn(cx, \"fastcall\");\n-        let v = llvm::LLVMBuildCall(B(cx), Fn, vec::raw::to_ptr(Args),\n-                                    Args.len() as c_uint, noname());\n-        lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n-        return v;\n-    }\n+    B(cx).call(Fn, Args)\n }\n \n pub fn CallWithConv(cx: block, Fn: ValueRef, Args: &[ValueRef],\n                     Conv: CallConv) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n-    unsafe {\n-        count_insn(cx, \"callwithconv\");\n-        let v = llvm::LLVMBuildCall(B(cx), Fn, vec::raw::to_ptr(Args),\n-                                    Args.len() as c_uint, noname());\n-        lib::llvm::SetInstructionCallConv(v, Conv);\n-        return v;\n-    }\n+    B(cx).call_with_conv(Fn, Args, Conv)\n }\n \n-pub fn Select(cx: block, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n-   ValueRef {\n-    unsafe {\n-        if cx.unreachable { return _Undef(Then); }\n-        count_insn(cx, \"select\");\n-        return llvm::LLVMBuildSelect(B(cx), If, Then, Else, noname());\n-    }\n+pub fn Select(cx: block, If: ValueRef, Then: ValueRef, Else: ValueRef) -> ValueRef {\n+    if cx.unreachable { return _Undef(Then); }\n+    B(cx).select(If, Then, Else)\n }\n \n pub fn VAArg(cx: block, list: ValueRef, Ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n-        count_insn(cx, \"vaarg\");\n-        return llvm::LLVMBuildVAArg(B(cx), list, Ty.to_ref(), noname());\n+        B(cx).va_arg(list, Ty)\n     }\n }\n \n-pub fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) ->\n-   ValueRef {\n+pub fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n-        count_insn(cx, \"extractelement\");\n-        return llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n+        B(cx).extract_element(VecVal, Index)\n     }\n }\n \n pub fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n                      Index: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n-        count_insn(cx, \"insertelement\");\n-        llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, noname())\n+        B(cx).insert_element(VecVal, EltVal, Index)\n     }\n }\n \n pub fn ShuffleVector(cx: block, V1: ValueRef, V2: ValueRef,\n                      Mask: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n-        count_insn(cx, \"shufflevector\");\n-        llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname())\n+        B(cx).shuffle_vector(V1, V2, Mask)\n     }\n }\n \n pub fn VectorSplat(cx: block, NumElts: uint, EltVal: ValueRef) -> ValueRef {\n     unsafe {\n-        let elt_ty = val_ty(EltVal);\n-        let Undef = llvm::LLVMGetUndef(Type::vector(&elt_ty, NumElts as u64).to_ref());\n-        let VecVal = InsertElement(cx, Undef, EltVal, C_i32(0));\n-        ShuffleVector(cx, VecVal, Undef, C_null(Type::vector(&Type::i32(), NumElts as u64)))\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        B(cx).vector_splat(NumElts, EltVal)\n     }\n }\n \n pub fn ExtractValue(cx: block, AggVal: ValueRef, Index: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n-        count_insn(cx, \"extractvalue\");\n-        return llvm::LLVMBuildExtractValue(\n-            B(cx), AggVal, Index as c_uint, noname());\n+        B(cx).extract_value(AggVal, Index)\n     }\n }\n \n-pub fn InsertValue(cx: block, AggVal: ValueRef, EltVal: ValueRef,\n-                   Index: uint) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        count_insn(cx, \"insertvalue\");\n-        llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index as c_uint,\n-                                   noname());\n-    }\n+pub fn InsertValue(cx: block, AggVal: ValueRef, EltVal: ValueRef, Index: uint) {\n+    if cx.unreachable { return; }\n+    B(cx).insert_value(AggVal, EltVal, Index)\n }\n \n pub fn IsNull(cx: block, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n-        count_insn(cx, \"isnull\");\n-        return llvm::LLVMBuildIsNull(B(cx), Val, noname());\n+        B(cx).is_null(Val)\n     }\n }\n \n pub fn IsNotNull(cx: block, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n-        count_insn(cx, \"isnotnull\");\n-        return llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n+        B(cx).is_not_null(Val)\n     }\n }\n \n pub fn PtrDiff(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type.to_ref()); }\n-        count_insn(cx, \"ptrdiff\");\n-        return llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n+        B(cx).ptrdiff(LHS, RHS)\n     }\n }\n \n pub fn Trap(cx: block) {\n-    unsafe {\n-        if cx.unreachable { return; }\n-        let b = B(cx);\n-        let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(b);\n-        let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n-        let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-        let T: ValueRef = str::as_c_str(\"llvm.trap\", |buf| {\n-            llvm::LLVMGetNamedFunction(M, buf)\n-        });\n-        assert!((T as int != 0));\n-        let Args: ~[ValueRef] = ~[];\n-        count_insn(cx, \"trap\");\n-        llvm::LLVMBuildCall(b, T, vec::raw::to_ptr(Args), Args.len() as c_uint, noname());\n-    }\n+    if cx.unreachable { return; }\n+    B(cx).trap();\n }\n \n pub fn LandingPad(cx: block, Ty: Type, PersFn: ValueRef,\n                   NumClauses: uint) -> ValueRef {\n-    unsafe {\n-        check_not_terminated(cx);\n-        assert!(!cx.unreachable);\n-        count_insn(cx, \"landingpad\");\n-        return llvm::LLVMBuildLandingPad(\n-            B(cx), Ty.to_ref(), PersFn, NumClauses as c_uint, noname());\n-    }\n+    check_not_terminated(cx);\n+    assert!(!cx.unreachable);\n+    B(cx).landing_pad(Ty, PersFn, NumClauses)\n }\n \n pub fn SetCleanup(cx: block, LandingPad: ValueRef) {\n-    unsafe {\n-        count_insn(cx, \"setcleanup\");\n-        llvm::LLVMSetCleanup(LandingPad, lib::llvm::True);\n-    }\n+    B(cx).set_cleanup(LandingPad)\n }\n \n pub fn Resume(cx: block, Exn: ValueRef) -> ValueRef {\n-    unsafe {\n-        check_not_terminated(cx);\n-        terminate(cx, \"Resume\");\n-        count_insn(cx, \"resume\");\n-        return llvm::LLVMBuildResume(B(cx), Exn);\n-    }\n+    check_not_terminated(cx);\n+    terminate(cx, \"Resume\");\n+    B(cx).resume(Exn)\n }\n \n // Atomic Operations\n pub fn AtomicCmpXchg(cx: block, dst: ValueRef,\n                      cmp: ValueRef, src: ValueRef,\n                      order: AtomicOrdering) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMBuildAtomicCmpXchg(B(cx), dst, cmp, src, order)\n-    }\n+    B(cx).atomic_cmpxchg(dst, cmp, src, order)\n }\n pub fn AtomicRMW(cx: block, op: AtomicBinOp,\n                  dst: ValueRef, src: ValueRef,\n                  order: AtomicOrdering) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMBuildAtomicRMW(B(cx), op, dst, src, order)\n-    }\n+    B(cx).atomic_rmw(op, dst, src, order)\n }"}, {"sha": "a4a976145b9a5c7eba237813209eea6f97a4ee87", "filename": "src/librustc/middle/trans/builder.rs", "status": "added", "additions": 947, "deletions": 0, "changes": 947, "blob_url": "https://github.com/rust-lang/rust/blob/565a9bf20b726c5182a6c4c816c1d9a4108c778a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565a9bf20b726c5182a6c4c816c1d9a4108c778a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=565a9bf20b726c5182a6c4c816c1d9a4108c778a", "patch": "@@ -0,0 +1,947 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use lib;\n+use lib::llvm::llvm;\n+use lib::llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};\n+use lib::llvm::{Opcode, IntPredicate, RealPredicate, False};\n+use lib::llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n+use middle::trans::base;\n+use middle::trans::common::*;\n+use middle::trans::machine::llalign_of_min;\n+use middle::trans::type_::Type;\n+use std::cast;\n+use std::hashmap::HashMap;\n+use std::libc::{c_uint, c_ulonglong, c_char};\n+use std::str;\n+use std::vec;\n+use syntax::codemap::span;\n+\n+pub struct Builder {\n+    llbuilder: BuilderRef,\n+    ccx: @mut CrateContext,\n+}\n+\n+// This is a really awful way to get a zero-length c-string, but better (and a\n+// lot more efficient) than doing str::as_c_str(\"\", ...) every time.\n+pub fn noname() -> *c_char {\n+    unsafe {\n+        static cnull: uint = 0u;\n+        cast::transmute(&cnull)\n+    }\n+}\n+\n+impl Builder {\n+    pub fn new(ccx: @mut CrateContext) -> Builder {\n+        Builder {\n+            llbuilder: ccx.builder.B,\n+            ccx: ccx,\n+        }\n+    }\n+\n+    pub fn count_insn(&self, category: &str) {\n+        if self.ccx.sess.trans_stats() {\n+            self.ccx.stats.n_llvm_insns += 1;\n+        }\n+        if self.ccx.sess.count_llvm_insns() {\n+            do base::with_insn_ctxt |v| {\n+                let h = &mut self.ccx.stats.llvm_insns;\n+\n+                // Build version of path with cycles removed.\n+\n+                // Pass 1: scan table mapping str -> rightmost pos.\n+                let mut mm = HashMap::new();\n+                let len = v.len();\n+                let mut i = 0u;\n+                while i < len {\n+                    mm.insert(v[i], i);\n+                    i += 1u;\n+                }\n+\n+                // Pass 2: concat strings for each elt, skipping\n+                // forwards over any cycles by advancing to rightmost\n+                // occurrence of each element in path.\n+                let mut s = ~\".\";\n+                i = 0u;\n+                while i < len {\n+                    i = *mm.get(&v[i]);\n+                    s.push_char('/');\n+                    s.push_str(v[i]);\n+                    i += 1u;\n+                }\n+\n+                s.push_char('/');\n+                s.push_str(category);\n+\n+                let n = match h.find(&s) {\n+                    Some(&n) => n,\n+                    _ => 0u\n+                };\n+                h.insert(s, n+1u);\n+            }\n+        }\n+    }\n+\n+    pub fn position_before(&self, insn: ValueRef) {\n+        unsafe {\n+            llvm::LLVMPositionBuilderBefore(self.llbuilder, insn);\n+        }\n+    }\n+\n+    pub fn position_at_end(&self, llbb: BasicBlockRef) {\n+        unsafe {\n+            llvm::LLVMPositionBuilderAtEnd(self.llbuilder, llbb);\n+        }\n+    }\n+\n+    pub fn ret_void(&self) {\n+        self.count_insn(\"retvoid\");\n+        unsafe {\n+            llvm::LLVMBuildRetVoid(self.llbuilder);\n+        }\n+    }\n+\n+    pub fn ret(&self, v: ValueRef) {\n+        self.count_insn(\"ret\");\n+        unsafe {\n+            llvm::LLVMBuildRet(self.llbuilder, v);\n+        }\n+    }\n+\n+    pub fn aggregate_ret(&self, ret_vals: &[ValueRef]) {\n+        unsafe {\n+            llvm::LLVMBuildAggregateRet(self.llbuilder,\n+                                        vec::raw::to_ptr(ret_vals),\n+                                        ret_vals.len() as c_uint);\n+        }\n+    }\n+\n+    pub fn br(&self, dest: BasicBlockRef) {\n+        self.count_insn(\"br\");\n+        unsafe {\n+            llvm::LLVMBuildBr(self.llbuilder, dest);\n+        }\n+    }\n+\n+    pub fn cond_br(&self, cond: ValueRef, then_llbb: BasicBlockRef, else_llbb: BasicBlockRef) {\n+        self.count_insn(\"condbr\");\n+        unsafe {\n+            llvm::LLVMBuildCondBr(self.llbuilder, cond, then_llbb, else_llbb);\n+        }\n+    }\n+\n+    pub fn switch(&self, v: ValueRef, else_llbb: BasicBlockRef, num_cases: uint) -> ValueRef {\n+        unsafe {\n+            llvm::LLVMBuildSwitch(self.llbuilder, v, else_llbb, num_cases as c_uint)\n+        }\n+    }\n+\n+    pub fn indirect_br(&self, addr: ValueRef, num_dests: uint) {\n+        self.count_insn(\"indirectbr\");\n+        unsafe {\n+            llvm::LLVMBuildIndirectBr(self.llbuilder, addr, num_dests as c_uint);\n+        }\n+    }\n+\n+    pub fn invoke(&self,\n+                  llfn: ValueRef,\n+                  args: &[ValueRef],\n+                  then: BasicBlockRef,\n+                  catch: BasicBlockRef)\n+                  -> ValueRef {\n+        self.count_insn(\"invoke\");\n+        unsafe {\n+            llvm::LLVMBuildInvoke(self.llbuilder,\n+                                  llfn,\n+                                  vec::raw::to_ptr(args),\n+                                  args.len() as c_uint,\n+                                  then,\n+                                  catch,\n+                                  noname())\n+        }\n+    }\n+\n+    pub fn fast_invoke(&self,\n+                       llfn: ValueRef,\n+                       args: &[ValueRef],\n+                       then: BasicBlockRef,\n+                       catch: BasicBlockRef) {\n+        self.count_insn(\"fastinvoke\");\n+        let v = self.invoke(llfn, args, then, catch);\n+        lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n+    }\n+\n+    pub fn unreachable(&self) {\n+        self.count_insn(\"unreachable\");\n+        unsafe {\n+            llvm::LLVMBuildUnreachable(self.llbuilder);\n+        }\n+    }\n+\n+    /* Arithmetic */\n+    pub fn add(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"add\");\n+        unsafe {\n+            llvm::LLVMBuildAdd(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn nswadd(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"nswadd\");\n+        unsafe {\n+            llvm::LLVMBuildNSWAdd(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn nuwadd(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"nuwadd\");\n+        unsafe {\n+            llvm::LLVMBuildNUWAdd(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn fadd(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"fadd\");\n+        unsafe {\n+            llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn sub(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"sub\");\n+        unsafe {\n+            llvm::LLVMBuildSub(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn nswsub(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"nwsub\");\n+        unsafe {\n+            llvm::LLVMBuildNSWSub(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn nuwsub(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"nuwsub\");\n+        unsafe {\n+            llvm::LLVMBuildNUWSub(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn fsub(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"sub\");\n+        unsafe {\n+            llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn mul(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"mul\");\n+        unsafe {\n+            llvm::LLVMBuildMul(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn nswmul(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"nswmul\");\n+        unsafe {\n+            llvm::LLVMBuildNSWMul(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn nuwmul(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"nuwmul\");\n+        unsafe {\n+            llvm::LLVMBuildNUWMul(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn fmul(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"fmul\");\n+        unsafe {\n+            llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn udiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"udiv\");\n+        unsafe {\n+            llvm::LLVMBuildUDiv(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn sdiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"sdiv\");\n+        unsafe {\n+            llvm::LLVMBuildSDiv(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn exactsdiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"exactsdiv\");\n+        unsafe {\n+            llvm::LLVMBuildExactSDiv(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn fdiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"fdiv\");\n+        unsafe {\n+            llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn urem(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"urem\");\n+        unsafe {\n+            llvm::LLVMBuildURem(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn srem(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"srem\");\n+        unsafe {\n+            llvm::LLVMBuildSRem(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn frem(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"frem\");\n+        unsafe {\n+            llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn shl(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"shl\");\n+        unsafe {\n+            llvm::LLVMBuildShl(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn lshr(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"lshr\");\n+        unsafe {\n+            llvm::LLVMBuildLShr(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn ashr(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"ashr\");\n+        unsafe {\n+            llvm::LLVMBuildAShr(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn and(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"and\");\n+        unsafe {\n+            llvm::LLVMBuildAnd(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn or(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"or\");\n+        unsafe {\n+            llvm::LLVMBuildOr(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn xor(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"xor\");\n+        unsafe {\n+            llvm::LLVMBuildXor(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn binop(&self, op: Opcode, lhs: ValueRef, rhs: ValueRef)\n+              -> ValueRef {\n+        self.count_insn(\"binop\");\n+        unsafe {\n+            llvm::LLVMBuildBinOp(self.llbuilder, op, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn neg(&self, V: ValueRef) -> ValueRef {\n+        self.count_insn(\"neg\");\n+        unsafe {\n+            llvm::LLVMBuildNeg(self.llbuilder, V, noname())\n+        }\n+    }\n+\n+    pub fn nswneg(&self, V: ValueRef) -> ValueRef {\n+        self.count_insn(\"nswneg\");\n+        unsafe {\n+            llvm::LLVMBuildNSWNeg(self.llbuilder, V, noname())\n+        }\n+    }\n+\n+    pub fn nuwneg(&self, V: ValueRef) -> ValueRef {\n+        self.count_insn(\"nuwneg\");\n+        unsafe {\n+            llvm::LLVMBuildNUWNeg(self.llbuilder, V, noname())\n+        }\n+    }\n+    pub fn fneg(&self, V: ValueRef) -> ValueRef {\n+        self.count_insn(\"fneg\");\n+        unsafe {\n+            llvm::LLVMBuildFNeg(self.llbuilder, V, noname())\n+        }\n+    }\n+\n+    pub fn not(&self, V: ValueRef) -> ValueRef {\n+        self.count_insn(\"not\");\n+        unsafe {\n+            llvm::LLVMBuildNot(self.llbuilder, V, noname())\n+        }\n+    }\n+\n+    /* Memory */\n+    pub fn malloc(&self, ty: Type) -> ValueRef {\n+        self.count_insn(\"malloc\");\n+        unsafe {\n+            llvm::LLVMBuildMalloc(self.llbuilder, ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn array_malloc(&self, ty: Type, val: ValueRef) -> ValueRef {\n+        self.count_insn(\"arraymalloc\");\n+        unsafe {\n+            llvm::LLVMBuildArrayMalloc(self.llbuilder, ty.to_ref(), val, noname())\n+        }\n+    }\n+\n+    pub fn alloca(&self, ty: Type, name: &str) -> ValueRef {\n+        self.count_insn(\"alloca\");\n+        unsafe {\n+            if name.is_empty() {\n+                llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), noname())\n+            } else {\n+                str::as_c_str(\n+                    name,\n+                    |c| llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), c))\n+            }\n+        }\n+    }\n+\n+    pub fn array_alloca(&self, ty: Type, val: ValueRef) -> ValueRef {\n+        self.count_insn(\"arrayalloca\");\n+        unsafe {\n+            llvm::LLVMBuildArrayAlloca(self.llbuilder, ty.to_ref(), val, noname())\n+        }\n+    }\n+\n+    pub fn free(&self, ptr: ValueRef) {\n+        self.count_insn(\"free\");\n+        unsafe {\n+            llvm::LLVMBuildFree(self.llbuilder, ptr);\n+        }\n+    }\n+\n+    pub fn load(&self, ptr: ValueRef) -> ValueRef {\n+        self.count_insn(\"load\");\n+        unsafe {\n+            llvm::LLVMBuildLoad(self.llbuilder, ptr, noname())\n+        }\n+    }\n+\n+    pub fn atomic_load(&self, ptr: ValueRef, order: AtomicOrdering) -> ValueRef {\n+        self.count_insn(\"load.atomic\");\n+        unsafe {\n+            let align = llalign_of_min(self.ccx, self.ccx.int_type);\n+            llvm::LLVMBuildAtomicLoad(self.llbuilder, ptr, noname(), order, align as c_uint)\n+        }\n+    }\n+\n+\n+    pub fn load_range_assert(&self, ptr: ValueRef, lo: c_ulonglong,\n+                           hi: c_ulonglong, signed: lib::llvm::Bool) -> ValueRef {\n+        let value = self.load(ptr);\n+\n+        unsafe {\n+            let t = llvm::LLVMGetElementType(llvm::LLVMTypeOf(ptr));\n+            let min = llvm::LLVMConstInt(t, lo, signed);\n+            let max = llvm::LLVMConstInt(t, hi, signed);\n+\n+            do [min, max].as_imm_buf |ptr, len| {\n+                llvm::LLVMSetMetadata(value, lib::llvm::MD_range as c_uint,\n+                                      llvm::LLVMMDNodeInContext(self.ccx.llcx,\n+                                                                ptr, len as c_uint));\n+            }\n+        }\n+\n+        value\n+    }\n+\n+    pub fn store(&self, val: ValueRef, ptr: ValueRef) {\n+        debug!(\"Store %s -> %s\",\n+               self.ccx.tn.val_to_str(val),\n+               self.ccx.tn.val_to_str(ptr));\n+        self.count_insn(\"store\");\n+        unsafe {\n+            llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n+        }\n+    }\n+\n+    pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n+        debug!(\"Store %s -> %s\",\n+               self.ccx.tn.val_to_str(val),\n+               self.ccx.tn.val_to_str(ptr));\n+        self.count_insn(\"store.atomic\");\n+        let align = llalign_of_min(self.ccx, self.ccx.int_type);\n+        unsafe {\n+            llvm::LLVMBuildAtomicStore(self.llbuilder, val, ptr, order, align as c_uint);\n+        }\n+    }\n+\n+    pub fn gep(&self, ptr: ValueRef, indices: &[ValueRef]) -> ValueRef {\n+        self.count_insn(\"gep\");\n+        unsafe {\n+            llvm::LLVMBuildGEP(self.llbuilder, ptr, vec::raw::to_ptr(indices),\n+                               indices.len() as c_uint, noname())\n+        }\n+    }\n+\n+    // Simple wrapper around GEP that takes an array of ints and wraps them\n+    // in C_i32()\n+    #[inline]\n+    pub fn gepi(&self, base: ValueRef, ixs: &[uint]) -> ValueRef {\n+        // Small vector optimization. This should catch 100% of the cases that\n+        // we care about.\n+        if ixs.len() < 16 {\n+            let mut small_vec = [ C_i32(0), ..16 ];\n+            for small_vec.mut_iter().zip(ixs.iter()).advance |(small_vec_e, &ix)| {\n+                *small_vec_e = C_i32(ix as i32);\n+            }\n+            self.inbounds_gep(base, small_vec.slice(0, ixs.len()))\n+        } else {\n+            let v = do ixs.iter().transform |i| { C_i32(*i as i32) }.collect::<~[ValueRef]>();\n+            self.count_insn(\"gepi\");\n+            self.inbounds_gep(base, v)\n+        }\n+    }\n+\n+    pub fn inbounds_gep(&self, ptr: ValueRef, indices: &[ValueRef]) -> ValueRef {\n+        self.count_insn(\"inboundsgep\");\n+        unsafe {\n+            llvm::LLVMBuildInBoundsGEP(\n+                self.llbuilder, ptr, vec::raw::to_ptr(indices), indices.len() as c_uint, noname())\n+        }\n+    }\n+\n+    pub fn struct_gep(&self, ptr: ValueRef, idx: uint) -> ValueRef {\n+        self.count_insn(\"structgep\");\n+        unsafe {\n+            llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n+        }\n+    }\n+\n+    pub fn global_string(&self, _Str: *c_char) -> ValueRef {\n+        self.count_insn(\"globalstring\");\n+        unsafe {\n+            llvm::LLVMBuildGlobalString(self.llbuilder, _Str, noname())\n+        }\n+    }\n+\n+    pub fn global_string_ptr(&self, _Str: *c_char) -> ValueRef {\n+        self.count_insn(\"globalstringptr\");\n+        unsafe {\n+            llvm::LLVMBuildGlobalStringPtr(self.llbuilder, _Str, noname())\n+        }\n+    }\n+\n+    /* Casts */\n+    pub fn trunc(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"trunc\");\n+        unsafe {\n+            llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn zext(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"zext\");\n+        unsafe {\n+            llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn sext(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"sext\");\n+        unsafe {\n+            llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn fptoui(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"fptoui\");\n+        unsafe {\n+            llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn fptosi(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"fptosi\");\n+        unsafe {\n+            llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty.to_ref(),noname())\n+        }\n+    }\n+\n+    pub fn uitofp(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"uitofp\");\n+        unsafe {\n+            llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn sitofp(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"sitofp\");\n+        unsafe {\n+            llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn fptrunc(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"fptrunc\");\n+        unsafe {\n+            llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn fpext(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"fpext\");\n+        unsafe {\n+            llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn ptrtoint(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"ptrtoint\");\n+        unsafe {\n+            llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn inttoptr(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"inttoptr\");\n+        unsafe {\n+            llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn bitcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"bitcast\");\n+        unsafe {\n+            llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn zext_or_bitcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"zextorbitcast\");\n+        unsafe {\n+            llvm::LLVMBuildZExtOrBitCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn sext_or_bitcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"sextorbitcast\");\n+        unsafe {\n+            llvm::LLVMBuildSExtOrBitCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn trunc_or_bitcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"truncorbitcast\");\n+        unsafe {\n+            llvm::LLVMBuildTruncOrBitCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn cast(&self, op: Opcode, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"cast\");\n+        unsafe {\n+            llvm::LLVMBuildCast(self.llbuilder, op, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn pointercast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"pointercast\");\n+        unsafe {\n+            llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn intcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"intcast\");\n+        unsafe {\n+            llvm::LLVMBuildIntCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn fpcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+        self.count_insn(\"fpcast\");\n+        unsafe {\n+            llvm::LLVMBuildFPCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+        }\n+    }\n+\n+\n+    /* Comparisons */\n+    pub fn icmp(&self, op: IntPredicate, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"icmp\");\n+        unsafe {\n+            llvm::LLVMBuildICmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn fcmp(&self, op: RealPredicate, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"fcmp\");\n+        unsafe {\n+            llvm::LLVMBuildFCmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n+        }\n+    }\n+\n+    /* Miscellaneous instructions */\n+    pub fn empty_phi(&self, ty: Type) -> ValueRef {\n+        self.count_insn(\"emptyphi\");\n+        unsafe {\n+            llvm::LLVMBuildPhi(self.llbuilder, ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn phi(&self, ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n+        assert_eq!(vals.len(), bbs.len());\n+        let phi = self.empty_phi(ty);\n+        self.count_insn(\"addincoming\");\n+        unsafe {\n+            llvm::LLVMAddIncoming(phi, vec::raw::to_ptr(vals),\n+                                  vec::raw::to_ptr(bbs),\n+                                  vals.len() as c_uint);\n+            phi\n+        }\n+    }\n+\n+    pub fn add_span_comment(&self, sp: span, text: &str) {\n+        if self.ccx.sess.asm_comments() {\n+            let s = fmt!(\"%s (%s)\", text, self.ccx.sess.codemap.span_to_str(sp));\n+            debug!(\"%s\", s);\n+            self.add_comment(s);\n+        }\n+    }\n+\n+    pub fn add_comment(&self, text: &str) {\n+        if self.ccx.sess.asm_comments() {\n+            let sanitized = text.replace(\"$\", \"\");\n+            let comment_text = fmt!(\"# %s\", sanitized.replace(\"\\n\", \"\\n\\t# \"));\n+            self.count_insn(\"inlineasm\");\n+            let asm = do comment_text.as_c_str |c| {\n+                unsafe {\n+                    llvm::LLVMConstInlineAsm(Type::func([], &Type::void()).to_ref(),\n+                                             c, noname(), False, False)\n+                }\n+            };\n+            self.call(asm, []);\n+        }\n+    }\n+\n+    pub fn inline_asm_call(&self, asm: *c_char, cons: *c_char,\n+                         inputs: &[ValueRef], output: Type,\n+                         volatile: bool, alignstack: bool,\n+                         dia: AsmDialect) -> ValueRef {\n+        self.count_insn(\"inlineasm\");\n+\n+        let volatile = if volatile { lib::llvm::True }\n+                       else        { lib::llvm::False };\n+        let alignstack = if alignstack { lib::llvm::True }\n+                         else          { lib::llvm::False };\n+\n+        let argtys = do inputs.map |v| {\n+            debug!(\"Asm Input Type: %?\", self.ccx.tn.val_to_str(*v));\n+            val_ty(*v)\n+        };\n+\n+        debug!(\"Asm Output Type: %?\", self.ccx.tn.type_to_str(output));\n+        let fty = Type::func(argtys, &output);\n+        unsafe {\n+            let v = llvm::LLVMInlineAsm(\n+                fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n+            self.call(v, inputs)\n+        }\n+    }\n+\n+    pub fn call(&self, llfn: ValueRef, args: &[ValueRef]) -> ValueRef {\n+        self.count_insn(\"call\");\n+\n+        debug!(\"Call(llfn=%s, args=%?)\",\n+               self.ccx.tn.val_to_str(llfn),\n+               args.map(|arg| self.ccx.tn.val_to_str(*arg)));\n+\n+        do args.as_imm_buf |ptr, len| {\n+            unsafe {\n+            llvm::LLVMBuildCall(self.llbuilder, llfn, ptr, len as c_uint, noname())\n+            }\n+        }\n+    }\n+\n+    pub fn fastcall(&self, llfn: ValueRef, args: &[ValueRef]) -> ValueRef {\n+        self.count_insn(\"fastcall\");\n+        unsafe {\n+            let v = llvm::LLVMBuildCall(self.llbuilder, llfn, vec::raw::to_ptr(args),\n+                                        args.len() as c_uint, noname());\n+            lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n+            v\n+        }\n+    }\n+\n+    pub fn call_with_conv(&self, llfn: ValueRef, args: &[ValueRef],\n+                        conv: CallConv) -> ValueRef {\n+        self.count_insn(\"callwithconv\");\n+        unsafe {\n+            let v = llvm::LLVMBuildCall(self.llbuilder, llfn, vec::raw::to_ptr(args),\n+                                        args.len() as c_uint, noname());\n+            lib::llvm::SetInstructionCallConv(v, conv);\n+            v\n+        }\n+    }\n+\n+    pub fn select(&self, cond: ValueRef, then_val: ValueRef, else_val: ValueRef) -> ValueRef {\n+        self.count_insn(\"select\");\n+        unsafe {\n+            llvm::LLVMBuildSelect(self.llbuilder, cond, then_val, else_val, noname())\n+        }\n+    }\n+\n+    pub fn va_arg(&self, list: ValueRef, ty: Type) -> ValueRef {\n+        self.count_insn(\"vaarg\");\n+        unsafe {\n+            llvm::LLVMBuildVAArg(self.llbuilder, list, ty.to_ref(), noname())\n+        }\n+    }\n+\n+    pub fn extract_element(&self, vec: ValueRef, idx: ValueRef) -> ValueRef {\n+        self.count_insn(\"extractelement\");\n+        unsafe {\n+            llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, noname())\n+        }\n+    }\n+\n+    pub fn insert_element(&self, vec: ValueRef, elt: ValueRef, idx: ValueRef) -> ValueRef {\n+        self.count_insn(\"insertelement\");\n+        unsafe {\n+            llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, noname())\n+        }\n+    }\n+\n+    pub fn shuffle_vector(&self, v1: ValueRef, v2: ValueRef, mask: ValueRef) -> ValueRef {\n+        self.count_insn(\"shufflevector\");\n+        unsafe {\n+            llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n+        }\n+    }\n+\n+    pub fn vector_splat(&self, num_elts: uint, elt: ValueRef) -> ValueRef {\n+        unsafe {\n+            let elt_ty = val_ty(elt);\n+            let Undef = llvm::LLVMGetUndef(Type::vector(&elt_ty, num_elts as u64).to_ref());\n+            let vec = self.insert_element(Undef, elt, C_i32(0));\n+            self.shuffle_vector(vec, Undef, C_null(Type::vector(&Type::i32(), num_elts as u64)))\n+        }\n+    }\n+\n+    pub fn extract_value(&self, agg_val: ValueRef, idx: uint) -> ValueRef {\n+        self.count_insn(\"extractvalue\");\n+        unsafe {\n+            llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n+        }\n+    }\n+\n+    pub fn insert_value(&self, agg_val: ValueRef, elt: ValueRef,\n+                       idx: uint) {\n+        self.count_insn(\"insertvalue\");\n+        unsafe {\n+            llvm::LLVMBuildInsertValue(self.llbuilder, agg_val, elt, idx as c_uint,\n+                                       noname());\n+        }\n+    }\n+\n+    pub fn is_null(&self, val: ValueRef) -> ValueRef {\n+        self.count_insn(\"isnull\");\n+        unsafe {\n+            llvm::LLVMBuildIsNull(self.llbuilder, val, noname())\n+        }\n+    }\n+\n+    pub fn is_not_null(&self, val: ValueRef) -> ValueRef {\n+        self.count_insn(\"isnotnull\");\n+        unsafe {\n+            llvm::LLVMBuildIsNotNull(self.llbuilder, val, noname())\n+        }\n+    }\n+\n+    pub fn ptrdiff(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"ptrdiff\");\n+        unsafe {\n+            llvm::LLVMBuildPtrDiff(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n+    pub fn trap(&self) {\n+        unsafe {\n+            let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(self.llbuilder);\n+            let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n+            let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n+            let T: ValueRef = str::as_c_str(\"llvm.trap\", |buf| {\n+                llvm::LLVMGetNamedFunction(M, buf)\n+            });\n+            assert!((T as int != 0));\n+            let args: &[ValueRef] = [];\n+            self.count_insn(\"trap\");\n+            llvm::LLVMBuildCall(\n+                self.llbuilder, T, vec::raw::to_ptr(args), args.len() as c_uint, noname());\n+        }\n+    }\n+\n+    pub fn landing_pad(&self, ty: Type, pers_fn: ValueRef, num_clauses: uint) -> ValueRef {\n+        self.count_insn(\"landingpad\");\n+        unsafe {\n+            llvm::LLVMBuildLandingPad(\n+                self.llbuilder, ty.to_ref(), pers_fn, num_clauses as c_uint, noname())\n+        }\n+    }\n+\n+    pub fn set_cleanup(&self, landing_pad: ValueRef) {\n+        self.count_insn(\"setcleanup\");\n+        unsafe {\n+            llvm::LLVMSetCleanup(landing_pad, lib::llvm::True);\n+        }\n+    }\n+\n+    pub fn resume(&self, exn: ValueRef) -> ValueRef {\n+        self.count_insn(\"resume\");\n+        unsafe {\n+            llvm::LLVMBuildResume(self.llbuilder, exn)\n+        }\n+    }\n+\n+    // Atomic Operations\n+    pub fn atomic_cmpxchg(&self, dst: ValueRef,\n+                         cmp: ValueRef, src: ValueRef,\n+                         order: AtomicOrdering) -> ValueRef {\n+        unsafe {\n+            llvm::LLVMBuildAtomicCmpXchg(self.llbuilder, dst, cmp, src, order)\n+        }\n+    }\n+    pub fn atomic_rmw(&self, op: AtomicBinOp,\n+                     dst: ValueRef, src: ValueRef,\n+                     order: AtomicOrdering) -> ValueRef {\n+        unsafe {\n+            llvm::LLVMBuildAtomicRMW(self.llbuilder, op, dst, src, order)\n+        }\n+    }\n+}"}, {"sha": "4990e78d524b7ea5107cec59b08455d12e2e6194", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/565a9bf20b726c5182a6c4c816c1d9a4108c778a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565a9bf20b726c5182a6c4c816c1d9a4108c778a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=565a9bf20b726c5182a6c4c816c1d9a4108c778a", "patch": "@@ -19,6 +19,7 @@ use middle::astencode;\n use middle::resolve;\n use middle::trans::adt;\n use middle::trans::base;\n+use middle::trans::builder::Builder;\n use middle::trans::debuginfo;\n use middle::trans::type_use;\n use middle::ty;\n@@ -227,6 +228,10 @@ impl CrateContext {\n             }\n         }\n     }\n+\n+    pub fn builder(@mut self) -> Builder {\n+        Builder::new(self)\n+    }\n }\n \n #[unsafe_destructor]"}, {"sha": "391a1283878fa1ecc22b51f60d2135bfb388e243", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/565a9bf20b726c5182a6c4c816c1d9a4108c778a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565a9bf20b726c5182a6c4c816c1d9a4108c778a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=565a9bf20b726c5182a6c4c816c1d9a4108c778a", "patch": "@@ -188,7 +188,7 @@ pub fn create_local_var_metadata(bcx: block, local: @ast::local) -> DIVariable {\n     set_debug_location(cx, lexical_block_metadata(bcx), loc.line, loc.col.to_uint());\n     unsafe {\n         let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_metadata, bcx.llbb);\n-        llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n+        llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n     }\n \n     return var_metadata;\n@@ -247,7 +247,7 @@ pub fn create_argument_metadata(bcx: block, arg: &ast::arg, span: span) -> Optio\n             unsafe {\n                 let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n                         DIB(cx), llptr, var_metadata, bcx.llbb);\n-                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n+                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n             }\n             return Some(var_metadata);\n         }"}, {"sha": "d47d9a4ff1628b63d5f51a57c7cbb1722595ead5", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/565a9bf20b726c5182a6c4c816c1d9a4108c778a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565a9bf20b726c5182a6c4c816c1d9a4108c778a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=565a9bf20b726c5182a6c4c816c1d9a4108c778a", "patch": "@@ -22,6 +22,7 @@ pub mod context;\n pub mod consts;\n pub mod type_of;\n pub mod build;\n+pub mod builder;\n pub mod base;\n pub mod _match;\n pub mod uniq;"}]}