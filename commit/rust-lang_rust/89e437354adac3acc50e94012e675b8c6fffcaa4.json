{"sha": "89e437354adac3acc50e94012e675b8c6fffcaa4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ZTQzNzM1NGFkYWMzYWNjNTBlOTQwMTJlNjc1YjhjNmZmZmNhYTQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T18:28:52Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T18:33:46Z"}, "message": "rustc_trans: remove primitive_align optimization.", "tree": {"sha": "6fc1571e1c5fac9f7350847faa9abd53c96b799e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fc1571e1c5fac9f7350847faa9abd53c96b799e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89e437354adac3acc50e94012e675b8c6fffcaa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89e437354adac3acc50e94012e675b8c6fffcaa4", "html_url": "https://github.com/rust-lang/rust/commit/89e437354adac3acc50e94012e675b8c6fffcaa4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89e437354adac3acc50e94012e675b8c6fffcaa4/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88e4d2c2918428d55e34cd57c11279ea839c8822", "url": "https://api.github.com/repos/rust-lang/rust/commits/88e4d2c2918428d55e34cd57c11279ea839c8822", "html_url": "https://github.com/rust-lang/rust/commit/88e4d2c2918428d55e34cd57c11279ea839c8822"}], "stats": {"total": 69, "additions": 14, "deletions": 55}, "files": [{"sha": "71bf333a8c6122cffd52110620976a3459792572", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 8, "deletions": 37, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/89e437354adac3acc50e94012e675b8c6fffcaa4/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89e437354adac3acc50e94012e675b8c6fffcaa4/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=89e437354adac3acc50e94012e675b8c6fffcaa4", "patch": "@@ -847,7 +847,6 @@ pub struct LayoutDetails {\n     pub fields: FieldPlacement,\n     pub abi: Abi,\n     pub align: Align,\n-    pub primitive_align: Align,\n     pub size: Size\n }\n \n@@ -861,7 +860,6 @@ impl LayoutDetails {\n             abi: Abi::Scalar(scalar),\n             size,\n             align,\n-            primitive_align: align\n         }\n     }\n \n@@ -872,7 +870,6 @@ impl LayoutDetails {\n             fields: FieldPlacement::Union(field_count),\n             abi: Abi::Uninhabited,\n             align,\n-            primitive_align: align,\n             size: Size::from_bytes(0)\n         }\n     }\n@@ -935,7 +932,6 @@ impl<'a, 'tcx> LayoutDetails {\n                 },\n                 abi: Abi::ScalarPair(a, b),\n                 align,\n-                primitive_align: align,\n                 size\n             }\n         };\n@@ -955,14 +951,12 @@ impl<'a, 'tcx> LayoutDetails {\n                 bug!(\"struct cannot be packed and aligned\");\n             }\n \n-            let base_align = if packed {\n+            let mut align = if packed {\n                 dl.i8_align\n             } else {\n                 dl.aggregate_align\n             };\n \n-            let mut align = base_align;\n-            let mut primitive_align = base_align;\n             let mut sized = true;\n             let mut offsets = vec![Size::from_bytes(0); fields.len()];\n             let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n@@ -1012,7 +1006,6 @@ impl<'a, 'tcx> LayoutDetails {\n                 if !packed {\n                     let discr_align = discr.align(dl);\n                     align = align.max(discr_align);\n-                    primitive_align = primitive_align.max(discr_align);\n                 }\n             }\n \n@@ -1035,7 +1028,6 @@ impl<'a, 'tcx> LayoutDetails {\n                 if !packed {\n                     offset = offset.abi_align(field.align);\n                     align = align.max(field.align);\n-                    primitive_align = primitive_align.max(field.primitive_align);\n                 }\n \n                 debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n@@ -1134,7 +1126,6 @@ impl<'a, 'tcx> LayoutDetails {\n                             if offsets[i] == pair_offsets[0] &&\n                                offsets[j] == pair_offsets[1] &&\n                                align == pair.align &&\n-                               primitive_align == pair.primitive_align &&\n                                size == pair.size {\n                                 // We can use `ScalarPair` only when it matches our\n                                 // already computed layout (including `#[repr(C)]`).\n@@ -1155,7 +1146,6 @@ impl<'a, 'tcx> LayoutDetails {\n                 },\n                 abi,\n                 align,\n-                primitive_align,\n                 size\n             })\n         };\n@@ -1255,7 +1245,6 @@ impl<'a, 'tcx> LayoutDetails {\n                         packed: false\n                     },\n                     align: element.align,\n-                    primitive_align: element.primitive_align,\n                     size\n                 })\n             }\n@@ -1272,7 +1261,6 @@ impl<'a, 'tcx> LayoutDetails {\n                         packed: false\n                     },\n                     align: element.align,\n-                    primitive_align: element.primitive_align,\n                     size: Size::from_bytes(0)\n                 })\n             }\n@@ -1288,7 +1276,6 @@ impl<'a, 'tcx> LayoutDetails {\n                         packed: false\n                     },\n                     align: dl.i8_align,\n-                    primitive_align: dl.i8_align,\n                     size: Size::from_bytes(0)\n                 })\n             }\n@@ -1359,7 +1346,6 @@ impl<'a, 'tcx> LayoutDetails {\n                     abi: Abi::Vector,\n                     size,\n                     align,\n-                    primitive_align: align\n                 })\n             }\n \n@@ -1389,27 +1375,24 @@ impl<'a, 'tcx> LayoutDetails {\n                         bug!(\"Union cannot be packed and aligned\");\n                     }\n \n-                    let mut primitive_align = if def.repr.packed() {\n+                    let mut align = if def.repr.packed() {\n                         dl.i8_align\n                     } else {\n                         dl.aggregate_align\n                     };\n \n-                    let mut align = if def.repr.align > 0 {\n+                    if def.repr.align > 0 {\n                         let repr_align = def.repr.align as u64;\n-                        primitive_align.max(\n-                            Align::from_bytes(repr_align, repr_align).unwrap())\n-                    } else {\n-                        primitive_align\n-                    };\n+                        align = align.max(\n+                            Align::from_bytes(repr_align, repr_align).unwrap());\n+                    }\n \n                     let mut size = Size::from_bytes(0);\n                     for field in &variants[0] {\n                         assert!(!field.is_unsized());\n \n                         if !packed {\n                             align = align.max(field.align);\n-                            primitive_align = primitive_align.max(field.primitive_align);\n                         }\n                         size = cmp::max(size, field.size);\n                     }\n@@ -1422,7 +1405,6 @@ impl<'a, 'tcx> LayoutDetails {\n                             packed\n                         },\n                         align,\n-                        primitive_align,\n                         size: size.abi_align(align)\n                     }));\n                 }\n@@ -1519,12 +1501,7 @@ impl<'a, 'tcx> LayoutDetails {\n                             }).collect::<Result<Vec<_>, _>>()?;\n \n                             let offset = st[i].fields.offset(field_index) + offset;\n-                            let LayoutDetails {\n-                                size,\n-                                mut align,\n-                                mut primitive_align,\n-                                ..\n-                            } = st[i];\n+                            let LayoutDetails { size, mut align, .. } = st[i];\n \n                             let mut niche_align = niche.value.align(dl);\n                             let abi = if offset.bytes() == 0 && niche.value.size(dl) == size {\n@@ -1541,7 +1518,6 @@ impl<'a, 'tcx> LayoutDetails {\n                                 }\n                             };\n                             align = align.max(niche_align);\n-                            primitive_align = primitive_align.max(niche_align);\n \n                             return Ok(tcx.intern_layout(LayoutDetails {\n                                 variants: Variants::NicheFilling {\n@@ -1558,7 +1534,6 @@ impl<'a, 'tcx> LayoutDetails {\n                                 abi,\n                                 size,\n                                 align,\n-                                primitive_align\n                             }));\n                         }\n                     }\n@@ -1577,7 +1552,6 @@ impl<'a, 'tcx> LayoutDetails {\n                 let (min_ity, signed) = Integer::repr_discr(tcx, ty, &def.repr, min, max);\n \n                 let mut align = dl.aggregate_align;\n-                let mut primitive_align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);\n \n                 // We're interested in the smallest alignment, so start large.\n@@ -1599,7 +1573,6 @@ impl<'a, 'tcx> LayoutDetails {\n                     }\n                     size = cmp::max(size, st.size);\n                     align = align.max(st.align);\n-                    primitive_align = primitive_align.max(st.primitive_align);\n                     Ok(st)\n                 }).collect::<Result<Vec<_>, _>>()?;\n \n@@ -1692,7 +1665,6 @@ impl<'a, 'tcx> LayoutDetails {\n                     fields: FieldPlacement::Union(1),\n                     abi,\n                     align,\n-                    primitive_align,\n                     size\n                 })\n             }\n@@ -2465,8 +2437,7 @@ impl_stable_hash_for!(struct ::ty::layout::LayoutDetails {\n     fields,\n     abi,\n     size,\n-    align,\n-    primitive_align\n+    align\n });\n \n impl_stable_hash_for!(enum ::ty::layout::Integer {"}, {"sha": "54828044de670a4636dd0db6b4ead816535aa85f", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89e437354adac3acc50e94012e675b8c6fffcaa4/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89e437354adac3acc50e94012e675b8c6fffcaa4/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=89e437354adac3acc50e94012e675b8c6fffcaa4", "patch": "@@ -585,7 +585,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                 //   bitcasting to the struct type yields invalid cast errors.\n \n                 // We instead thus allocate some scratch space...\n-                let llscratch = bcx.alloca(cast.llvm_type(ccx), \"abi_cast\", None);\n+                let llscratch = bcx.alloca(cast.llvm_type(ccx), \"abi_cast\", cast.align(ccx));\n                 let scratch_size = cast.size(ccx);\n                 bcx.lifetime_start(llscratch, scratch_size);\n "}, {"sha": "50e673bdbfdd77a068b33bb00a2525b7a1c84821", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89e437354adac3acc50e94012e675b8c6fffcaa4/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89e437354adac3acc50e94012e675b8c6fffcaa4/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=89e437354adac3acc50e94012e675b8c6fffcaa4", "patch": "@@ -488,15 +488,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn alloca(&self, ty: Type, name: &str, align: Option<Align>) -> ValueRef {\n+    pub fn alloca(&self, ty: Type, name: &str, align: Align) -> ValueRef {\n         let builder = Builder::with_ccx(self.ccx);\n         builder.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n         builder.dynamic_alloca(ty, name, align)\n     }\n \n-    pub fn dynamic_alloca(&self, ty: Type, name: &str, align: Option<Align>) -> ValueRef {\n+    pub fn dynamic_alloca(&self, ty: Type, name: &str, align: Align) -> ValueRef {\n         self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n@@ -506,9 +506,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(),\n                                       name.as_ptr())\n             };\n-            if let Some(align) = align {\n-                llvm::LLVMSetAlignment(alloca, align.abi() as c_uint);\n-            }\n+            llvm::LLVMSetAlignment(alloca, align.abi() as c_uint);\n             alloca\n         }\n     }"}, {"sha": "adbb45f893b08778d763e5a6e042d01c04437a97", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89e437354adac3acc50e94012e675b8c6fffcaa4/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89e437354adac3acc50e94012e675b8c6fffcaa4/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=89e437354adac3acc50e94012e675b8c6fffcaa4", "patch": "@@ -817,7 +817,7 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         //\n         // More information can be found in libstd's seh.rs implementation.\n         let i64p = Type::i64(ccx).ptr_to();\n-        let slot = bcx.alloca(i64p, \"slot\", None);\n+        let slot = bcx.alloca(i64p, \"slot\", ccx.data_layout().pointer_align);\n         bcx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(),\n             None);\n "}, {"sha": "891d52045c217a2ae99a7de9a17ff90d7dc8378e", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89e437354adac3acc50e94012e675b8c6fffcaa4/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89e437354adac3acc50e94012e675b8c6fffcaa4/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=89e437354adac3acc50e94012e675b8c6fffcaa4", "patch": "@@ -103,8 +103,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     pub fn alloca(bcx: &Builder<'a, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n                   -> LvalueRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n-        let tmp = bcx.alloca(\n-            layout.llvm_type(bcx.ccx), name, layout.over_align());\n+        let tmp = bcx.alloca(layout.llvm_type(bcx.ccx), name, layout.align);\n         Self::new_sized(tmp, layout, Alignment::AbiAligned)\n     }\n "}, {"sha": "9b32c825117ee32d14ee1fd78d90503db554dffb", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89e437354adac3acc50e94012e675b8c6fffcaa4/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89e437354adac3acc50e94012e675b8c6fffcaa4/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=89e437354adac3acc50e94012e675b8c6fffcaa4", "patch": "@@ -185,7 +185,6 @@ pub trait LayoutLlvmExt<'tcx> {\n     fn immediate_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n     fn scalar_pair_element_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n                                          index: usize) -> Type;\n-    fn over_align(&self) -> Option<Align>;\n     fn llvm_field_index(&self, index: usize) -> u64;\n     fn pointee_info_at<'a>(&self, ccx: &CrateContext<'a, 'tcx>, offset: Size)\n                            -> Option<PointeeInfo>;\n@@ -365,14 +364,6 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n-    fn over_align(&self) -> Option<Align> {\n-        if self.align != self.primitive_align {\n-            Some(self.align)\n-        } else {\n-            None\n-        }\n-    }\n-\n     fn llvm_field_index(&self, index: usize) -> u64 {\n         match self.abi {\n             layout::Abi::Scalar(_) |"}]}