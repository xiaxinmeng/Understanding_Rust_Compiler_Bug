{"sha": "b3985190114233861132b0f479731f00380e1342", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzOTg1MTkwMTE0MjMzODYxMTMyYjBmNDc5NzMxZjAwMzgwZTEzNDI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-09T13:34:37Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-09T13:34:37Z"}, "message": "Cleanup diagnostic conversion code", "tree": {"sha": "540821f564832f0f55fabb314fd486728268c33d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/540821f564832f0f55fabb314fd486728268c33d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3985190114233861132b0f479731f00380e1342", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3985190114233861132b0f479731f00380e1342", "html_url": "https://github.com/rust-lang/rust/commit/b3985190114233861132b0f479731f00380e1342", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3985190114233861132b0f479731f00380e1342/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "117392e879f2732aacd029189de844bda286df2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/117392e879f2732aacd029189de844bda286df2c", "html_url": "https://github.com/rust-lang/rust/commit/117392e879f2732aacd029189de844bda286df2c"}], "stats": {"total": 178, "additions": 75, "deletions": 103}, "files": [{"sha": "edf4749de80c7173a79e5a3a26a4cc107fb66736", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3985190114233861132b0f479731f00380e1342/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b3985190114233861132b0f479731f00380e1342/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b3985190114233861132b0f479731f00380e1342", "patch": "@@ -1435,6 +1435,7 @@ dependencies = [\n  \"anyhow\",\n  \"crossbeam-channel\",\n  \"env_logger\",\n+ \"expect\",\n  \"flycheck\",\n  \"globset\",\n  \"insta\","}, {"sha": "6804d9bda08aba669ff950e8d6df8ace4182846f", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3985190114233861132b0f479731f00380e1342/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3985190114233861132b0f479731f00380e1342/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=b3985190114233861132b0f479731f00380e1342", "patch": "@@ -14,7 +14,8 @@ use std::{\n use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n \n pub use cargo_metadata::diagnostic::{\n-    Applicability, Diagnostic, DiagnosticLevel, DiagnosticSpan, DiagnosticSpanMacroExpansion,\n+    Applicability, Diagnostic, DiagnosticCode, DiagnosticLevel, DiagnosticSpan,\n+    DiagnosticSpanMacroExpansion,\n };\n \n #[derive(Clone, Debug, PartialEq, Eq)]"}, {"sha": "0519884fdda71a5918d4fb3ab992f0c07dce46d1", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3985190114233861132b0f479731f00380e1342/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b3985190114233861132b0f479731f00380e1342/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=b3985190114233861132b0f479731f00380e1342", "patch": "@@ -59,6 +59,7 @@ winapi = \"0.3.8\"\n [dev-dependencies]\n tempfile = \"3.1.0\"\n insta = \"0.16.0\"\n+expect = { path = \"../expect\" }\n test_utils = { path = \"../test_utils\" }\n mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }"}, {"sha": "f3a22885e1e920f7e4b7409b83e816387f7b9a04", "filename": "crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 71, "deletions": 102, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/b3985190114233861132b0f479731f00380e1342/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3985190114233861132b0f479731f00380e1342/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=b3985190114233861132b0f479731f00380e1342", "patch": "@@ -2,34 +2,33 @@\n //! `cargo check` json format to the LSP diagnostic format.\n use std::{collections::HashMap, path::Path};\n \n-use flycheck::{Applicability, DiagnosticLevel, DiagnosticSpan, DiagnosticSpanMacroExpansion};\n-use lsp_types::{\n-    Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, Location,\n-    NumberOrString, Position, Range, TextEdit, Url,\n-};\n+use flycheck::{Applicability, DiagnosticLevel, DiagnosticSpan};\n use stdx::format_to;\n \n use crate::{lsp_ext, to_proto::url_from_abs_path};\n \n use super::DiagnosticsConfig;\n \n /// Determines the LSP severity from a diagnostic\n-fn map_diagnostic_to_severity(\n+fn diagnostic_severity(\n     config: &DiagnosticsConfig,\n-    val: &flycheck::Diagnostic,\n-) -> Option<DiagnosticSeverity> {\n-    let res = match val.level {\n-        DiagnosticLevel::Ice => DiagnosticSeverity::Error,\n-        DiagnosticLevel::Error => DiagnosticSeverity::Error,\n-        DiagnosticLevel::Warning => match &val.code {\n-            Some(code) if config.warnings_as_hint.contains(&code.code) => DiagnosticSeverity::Hint,\n+    level: flycheck::DiagnosticLevel,\n+    code: Option<flycheck::DiagnosticCode>,\n+) -> Option<lsp_types::DiagnosticSeverity> {\n+    let res = match level {\n+        DiagnosticLevel::Ice => lsp_types::DiagnosticSeverity::Error,\n+        DiagnosticLevel::Error => lsp_types::DiagnosticSeverity::Error,\n+        DiagnosticLevel::Warning => match &code {\n+            Some(code) if config.warnings_as_hint.contains(&code.code) => {\n+                lsp_types::DiagnosticSeverity::Hint\n+            }\n             Some(code) if config.warnings_as_info.contains(&code.code) => {\n-                DiagnosticSeverity::Information\n+                lsp_types::DiagnosticSeverity::Information\n             }\n-            _ => DiagnosticSeverity::Warning,\n+            _ => lsp_types::DiagnosticSeverity::Warning,\n         },\n-        DiagnosticLevel::Note => DiagnosticSeverity::Information,\n-        DiagnosticLevel::Help => DiagnosticSeverity::Hint,\n+        DiagnosticLevel::Note => lsp_types::DiagnosticSeverity::Information,\n+        DiagnosticLevel::Help => lsp_types::DiagnosticSeverity::Hint,\n         DiagnosticLevel::Unknown => return None,\n     };\n     Some(res)\n@@ -40,90 +39,50 @@ fn is_from_macro(file_name: &str) -> bool {\n     file_name.starts_with('<') && file_name.ends_with('>')\n }\n \n-/// Converts a Rust macro span to a LSP location recursively\n-fn map_macro_span_to_location(\n-    span_macro: &DiagnosticSpanMacroExpansion,\n-    workspace_root: &Path,\n-) -> Option<Location> {\n-    if !is_from_macro(&span_macro.span.file_name) {\n-        return Some(map_span_to_location(&span_macro.span, workspace_root));\n-    }\n-\n-    if let Some(expansion) = &span_macro.span.expansion {\n-        return map_macro_span_to_location(&expansion, workspace_root);\n-    }\n-\n-    None\n-}\n-\n /// Converts a Rust span to a LSP location, resolving macro expansion site if neccesary\n-fn map_span_to_location(span: &DiagnosticSpan, workspace_root: &Path) -> Location {\n-    if span.expansion.is_some() {\n-        let expansion = span.expansion.as_ref().unwrap();\n-        if let Some(macro_range) = map_macro_span_to_location(&expansion, workspace_root) {\n-            return macro_range;\n-        }\n+fn location(workspace_root: &Path, span: &DiagnosticSpan) -> lsp_types::Location {\n+    let mut span = span.clone();\n+    while let Some(expansion) = span.expansion {\n+        span = expansion.span;\n     }\n-\n-    map_span_to_location_naive(span, workspace_root)\n+    return location_naive(workspace_root, &span);\n }\n \n /// Converts a Rust span to a LSP location\n-fn map_span_to_location_naive(span: &DiagnosticSpan, workspace_root: &Path) -> Location {\n-    let mut file_name = workspace_root.to_path_buf();\n-    file_name.push(&span.file_name);\n+fn location_naive(workspace_root: &Path, span: &DiagnosticSpan) -> lsp_types::Location {\n+    let file_name = workspace_root.join(&span.file_name);\n     let uri = url_from_abs_path(&file_name);\n \n     // FIXME: this doesn't handle UTF16 offsets correctly\n-    let range = Range::new(\n-        Position::new(span.line_start as u64 - 1, span.column_start as u64 - 1),\n-        Position::new(span.line_end as u64 - 1, span.column_end as u64 - 1),\n+    let range = lsp_types::Range::new(\n+        lsp_types::Position::new(span.line_start as u64 - 1, span.column_start as u64 - 1),\n+        lsp_types::Position::new(span.line_end as u64 - 1, span.column_end as u64 - 1),\n     );\n \n-    Location { uri, range }\n+    lsp_types::Location { uri, range }\n }\n \n-/// Converts a secondary Rust span to a LSP related information\n+/// Converts a secondary Rust span to a LSP related inflocation(ormation\n ///\n /// If the span is unlabelled this will return `None`.\n-fn map_secondary_span_to_related(\n-    span: &DiagnosticSpan,\n+fn diagnostic_related_information(\n     workspace_root: &Path,\n-) -> Option<DiagnosticRelatedInformation> {\n+    span: &DiagnosticSpan,\n+) -> Option<lsp_types::DiagnosticRelatedInformation> {\n     let message = span.label.clone()?;\n-    let location = map_span_to_location(span, workspace_root);\n-    Some(DiagnosticRelatedInformation { location, message })\n-}\n-\n-/// Determines if diagnostic is related to unused code\n-fn is_unused_or_unnecessary(rd: &flycheck::Diagnostic) -> bool {\n-    match &rd.code {\n-        Some(code) => match code.code.as_str() {\n-            \"dead_code\" | \"unknown_lints\" | \"unreachable_code\" | \"unused_attributes\"\n-            | \"unused_imports\" | \"unused_macros\" | \"unused_variables\" => true,\n-            _ => false,\n-        },\n-        None => false,\n-    }\n-}\n-\n-/// Determines if diagnostic is related to deprecated code\n-fn is_deprecated(rd: &flycheck::Diagnostic) -> bool {\n-    match &rd.code {\n-        Some(code) => code.code.as_str() == \"deprecated\",\n-        None => false,\n-    }\n+    let location = location(workspace_root, span);\n+    Some(lsp_types::DiagnosticRelatedInformation { location, message })\n }\n \n enum MappedRustChildDiagnostic {\n-    Related(DiagnosticRelatedInformation),\n+    Related(lsp_types::DiagnosticRelatedInformation),\n     SuggestedFix(lsp_ext::CodeAction),\n     MessageLine(String),\n }\n \n fn map_rust_child_diagnostic(\n-    rd: &flycheck::Diagnostic,\n     workspace_root: &Path,\n+    rd: &flycheck::Diagnostic,\n ) -> MappedRustChildDiagnostic {\n     let spans: Vec<&DiagnosticSpan> = rd.spans.iter().filter(|s| s.is_primary).collect();\n     if spans.is_empty() {\n@@ -132,21 +91,20 @@ fn map_rust_child_diagnostic(\n         return MappedRustChildDiagnostic::MessageLine(rd.message.clone());\n     }\n \n-    let mut edit_map: HashMap<Url, Vec<TextEdit>> = HashMap::new();\n+    let mut edit_map: HashMap<lsp_types::Url, Vec<lsp_types::TextEdit>> = HashMap::new();\n     for &span in &spans {\n-        match (&span.suggestion_applicability, &span.suggested_replacement) {\n-            (Some(Applicability::MachineApplicable), Some(suggested_replacement)) => {\n-                let location = map_span_to_location(span, workspace_root);\n-                let edit = TextEdit::new(location.range, suggested_replacement.clone());\n-                edit_map.entry(location.uri).or_default().push(edit);\n-            }\n-            _ => {}\n+        if let (Some(Applicability::MachineApplicable), Some(suggested_replacement)) =\n+            (&span.suggestion_applicability, &span.suggested_replacement)\n+        {\n+            let location = location(workspace_root, span);\n+            let edit = lsp_types::TextEdit::new(location.range, suggested_replacement.clone());\n+            edit_map.entry(location.uri).or_default().push(edit);\n         }\n     }\n \n     if edit_map.is_empty() {\n-        MappedRustChildDiagnostic::Related(DiagnosticRelatedInformation {\n-            location: map_span_to_location(spans[0], workspace_root),\n+        MappedRustChildDiagnostic::Related(lsp_types::DiagnosticRelatedInformation {\n+            location: location(workspace_root, spans[0]),\n             message: rd.message.clone(),\n         })\n     } else {\n@@ -167,8 +125,8 @@ fn map_rust_child_diagnostic(\n \n #[derive(Debug)]\n pub(crate) struct MappedRustDiagnostic {\n-    pub(crate) location: Location,\n-    pub(crate) diagnostic: Diagnostic,\n+    pub(crate) location: lsp_types::Location,\n+    pub(crate) diagnostic: lsp_types::Diagnostic,\n     pub(crate) fixes: Vec<lsp_ext::CodeAction>,\n }\n \n@@ -192,7 +150,7 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n         return Vec::new();\n     }\n \n-    let severity = map_diagnostic_to_severity(config, rd);\n+    let severity = diagnostic_severity(config, rd.level.clone(), rd.code.clone());\n \n     let mut source = String::from(\"rustc\");\n     let mut code = rd.code.as_ref().map(|c| c.code.clone());\n@@ -210,7 +168,7 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n     let mut tags = Vec::new();\n \n     for secondary_span in rd.spans.iter().filter(|s| !s.is_primary) {\n-        let related = map_secondary_span_to_related(secondary_span, workspace_root);\n+        let related = diagnostic_related_information(workspace_root, secondary_span);\n         if let Some(related) = related {\n             related_information.push(related);\n         }\n@@ -219,7 +177,7 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n     let mut fixes = Vec::new();\n     let mut message = rd.message.clone();\n     for child in &rd.children {\n-        let child = map_rust_child_diagnostic(&child, workspace_root);\n+        let child = map_rust_child_diagnostic(workspace_root, &child);\n         match child {\n             MappedRustChildDiagnostic::Related(related) => related_information.push(related),\n             MappedRustChildDiagnostic::SuggestedFix(code_action) => fixes.push(code_action),\n@@ -233,18 +191,30 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n         }\n     }\n \n-    if is_unused_or_unnecessary(rd) {\n-        tags.push(DiagnosticTag::Unnecessary);\n-    }\n+    if let Some(code) = &rd.code {\n+        let code = code.code.as_str();\n+        if matches!(\n+            code,\n+            \"dead_code\"\n+                | \"unknown_lints\"\n+                | \"unreachable_code\"\n+                | \"unused_attributes\"\n+                | \"unused_imports\"\n+                | \"unused_macros\"\n+                | \"unused_variables\"\n+        ) {\n+            tags.push(lsp_types::DiagnosticTag::Unnecessary);\n+        }\n \n-    if is_deprecated(rd) {\n-        tags.push(DiagnosticTag::Deprecated);\n+        if matches!(code, \"deprecated\") {\n+            tags.push(lsp_types::DiagnosticTag::Deprecated);\n+        }\n     }\n \n     primary_spans\n         .iter()\n         .map(|primary_span| {\n-            let location = map_span_to_location(&primary_span, workspace_root);\n+            let location = location(workspace_root, &primary_span);\n \n             let mut message = message.clone();\n             if needs_primary_span_label {\n@@ -256,17 +226,16 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n             // If error occurs from macro expansion, add related info pointing to\n             // where the error originated\n             if !is_from_macro(&primary_span.file_name) && primary_span.expansion.is_some() {\n-                let def_loc = map_span_to_location_naive(&primary_span, workspace_root);\n-                related_information.push(DiagnosticRelatedInformation {\n-                    location: def_loc,\n+                related_information.push(lsp_types::DiagnosticRelatedInformation {\n+                    location: location_naive(workspace_root, &primary_span),\n                     message: \"Error originated from macro here\".to_string(),\n                 });\n             }\n \n-            let diagnostic = Diagnostic {\n+            let diagnostic = lsp_types::Diagnostic {\n                 range: location.range,\n                 severity,\n-                code: code.clone().map(NumberOrString::String),\n+                code: code.clone().map(lsp_types::NumberOrString::String),\n                 source: Some(source.clone()),\n                 message,\n                 related_information: if related_information.is_empty() {"}]}