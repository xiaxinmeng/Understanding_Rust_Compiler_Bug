{"sha": "dddeba19d33a1aa2e7681ae84424dbe4d7b510b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkZGViYTE5ZDMzYTFhYTJlNzY4MWFlODQ0MjRkYmU0ZDdiNTEwYjc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-03T00:42:09Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-03T00:42:19Z"}, "message": "Sketch out some more pieces of vec-append.", "tree": {"sha": "6ed714ac6d70933f14143eff4ee8d56c01195a86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ed714ac6d70933f14143eff4ee8d56c01195a86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dddeba19d33a1aa2e7681ae84424dbe4d7b510b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dddeba19d33a1aa2e7681ae84424dbe4d7b510b7", "html_url": "https://github.com/rust-lang/rust/commit/dddeba19d33a1aa2e7681ae84424dbe4d7b510b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dddeba19d33a1aa2e7681ae84424dbe4d7b510b7/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ebb91f24d84391f6c821c54fb8c497964eac6c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ebb91f24d84391f6c821c54fb8c497964eac6c3", "html_url": "https://github.com/rust-lang/rust/commit/5ebb91f24d84391f6c821c54fb8c497964eac6c3"}], "stats": {"total": 146, "additions": 133, "deletions": 13}, "files": [{"sha": "89d6b487644ba12c6e0bf34b2e4c2653769cf89d", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dddeba19d33a1aa2e7681ae84424dbe4d7b510b7/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dddeba19d33a1aa2e7681ae84424dbe4d7b510b7/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=dddeba19d33a1aa2e7681ae84424dbe4d7b510b7", "patch": "@@ -71,6 +71,10 @@ fn bzero_glue_name() -> str {\n     ret \"rust_bzero_glue\";\n }\n \n+fn vec_grow_glue_name() -> str {\n+    ret \"rust_vec_grow_glue\";\n+}\n+\n fn upcall_glue_name(int n) -> str {\n     ret \"rust_upcall_\" + util.common.istr(n);\n }"}, {"sha": "2cd266640e07f2138dab0ecb34e64984919d9d1a", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 119, "deletions": 13, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/dddeba19d33a1aa2e7681ae84424dbe4d7b510b7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dddeba19d33a1aa2e7681ae84424dbe4d7b510b7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=dddeba19d33a1aa2e7681ae84424dbe4d7b510b7", "patch": "@@ -57,7 +57,8 @@ type glue_fns = rec(ValueRef activate_glue,\n                     vec[ValueRef] upcall_glues,\n                     ValueRef no_op_type_glue,\n                     ValueRef memcpy_glue,\n-                    ValueRef bzero_glue);\n+                    ValueRef bzero_glue,\n+                    ValueRef vec_grow_glue);\n \n type tag_info = rec(\n     type_handle th,\n@@ -809,7 +810,7 @@ fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> result {\n }\n \n fn trans_non_gc_free(@block_ctxt cx, ValueRef v) -> result {\n-    ret trans_upcall(cx, \"upcall_free\", vec(cx.build.PtrToInt(v, T_int()),\n+    ret trans_upcall(cx, \"upcall_free\", vec(vp2i(cx, v),\n                                             C_int(0)));\n }\n \n@@ -1065,7 +1066,7 @@ fn trans_malloc_inner(@block_ctxt cx, TypeRef llptr_ty) -> result {\n     auto tydesc = C_int(0);\n     auto sz = llsize_of(llbody_ty);\n     auto sub = trans_upcall(cx, \"upcall_malloc\", vec(sz, tydesc));\n-    sub.val = sub.bcx.build.IntToPtr(sub.val, llptr_ty);\n+    sub.val = vi2p(sub.bcx, sub.val, llptr_ty);\n     ret sub;\n }\n \n@@ -1181,10 +1182,10 @@ fn get_tydesc(&@block_ctxt cx, @ty.t t) -> result {\n                                   sz.val,\n                                   align.val,\n                                   C_int((1u + n_params) as int),\n-                                  bcx.build.PtrToInt(tydescs, T_int())));\n+                                  vp2i(bcx, tydescs)));\n \n-        ret res(v.bcx, v.bcx.build.IntToPtr(v.val,\n-                                            T_ptr(T_tydesc(cx.fcx.ccx.tn))));\n+        ret res(v.bcx, vi2p(v.bcx, v.val,\n+                            T_ptr(T_tydesc(cx.fcx.ccx.tn))));\n     }\n \n     // Otherwise, generate a tydesc if necessary, and return it.\n@@ -1829,9 +1830,9 @@ fn call_tydesc_glue_full(@block_ctxt cx, ValueRef v,\n     // glue-pointer-constants in the tydesc records: They are tydesc-relative\n     // displacements.  This is purely for compatibility with rustboot and\n     // should go when it is discarded.\n-    llfn = cx.build.IntToPtr(cx.build.Add(cx.build.PtrToInt(llfn, T_int()),\n-                                          cx.build.PtrToInt(tydesc, T_int())),\n-                             val_ty(llfn));\n+    llfn = vi2p(cx, cx.build.Add(vp2i(cx, llfn),\n+                                 vp2i(cx, tydesc)),\n+                val_ty(llfn));\n \n     cx.build.FastCall(llfn, vec(C_null(T_ptr(T_nil())),\n                                 cx.fcx.lltaskptr,\n@@ -2221,11 +2222,30 @@ fn trans_integral_compare(@block_ctxt cx, ast.binop op, @ty.t intype,\n     ret cx.build.ICmp(cmp, lhs, rhs);\n }\n \n+fn trans_sequence_append(@block_ctxt cx, @ty.t t,\n+                         ValueRef lhs, ValueRef rhs) -> result {\n+    cx.fcx.ccx.sess.unimpl(\"sequence append\");\n+    fail;\n+}\n+\n+fn trans_sequence_add(@block_ctxt cx, @ty.t t,\n+                      ValueRef lhs, ValueRef rhs) -> result {\n+    auto r = alloc_ty(cx, t);\n+    r = copy_ty(r.bcx, INIT, r.val, lhs, t);\n+    ret trans_sequence_append(r.bcx, t, lhs, rhs);\n+}\n+\n+\n fn trans_eager_binop(@block_ctxt cx, ast.binop op, @ty.t intype,\n                      ValueRef lhs, ValueRef rhs) -> result {\n \n     alt (op) {\n-        case (ast.add) { ret res(cx, cx.build.Add(lhs, rhs)); }\n+        case (ast.add) {\n+            if (ty.type_is_sequence(intype)) {\n+                ret trans_sequence_add(cx, intype, lhs, rhs);\n+            }\n+            ret res(cx, cx.build.Add(lhs, rhs));\n+        }\n         case (ast.sub) { ret res(cx, cx.build.Sub(lhs, rhs)); }\n \n         case (ast.mul) { ret res(cx, cx.build.Mul(lhs, rhs)); }\n@@ -3539,7 +3559,7 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n     bcx = sub.bcx;\n \n     auto llty = type_of(bcx.fcx.ccx, t);\n-    auto vec_val = bcx.build.IntToPtr(sub.val, llty);\n+    auto vec_val = vi2p(bcx, sub.val, llty);\n     find_scope_cx(bcx).cleanups += clean(bind drop_ty(_, vec_val, t));\n \n     auto body = bcx.build.GEP(vec_val, vec(C_int(0),\n@@ -3782,7 +3802,7 @@ fn trans_log(@block_ctxt cx, @ast.expr e) -> result {\n     auto e_ty = ty.expr_ty(e);\n     alt (e_ty.struct) {\n         case (ty.ty_str) {\n-            auto v = sub.bcx.build.PtrToInt(sub.val, T_int());\n+            auto v = vp2i(sub.bcx, sub.val);\n             ret trans_upcall(sub.bcx,\n                              \"upcall_log_str\",\n                              vec(v));\n@@ -4907,6 +4927,16 @@ fn trans_constants(@crate_ctxt cx, @ast.crate crate) {\n     fold.fold_crate[@crate_ctxt](cx, fld, crate);\n }\n \n+\n+fn vp2i(@block_ctxt cx, ValueRef v) -> ValueRef {\n+    ret cx.build.PtrToInt(v, T_int());\n+}\n+\n+\n+fn vi2p(@block_ctxt cx, ValueRef v, TypeRef t) -> ValueRef {\n+    ret cx.build.IntToPtr(v, t);\n+}\n+\n fn p2i(ValueRef v) -> ValueRef {\n     ret llvm.LLVMConstPtrToInt(v, T_int());\n }\n@@ -5172,6 +5202,80 @@ fn make_bzero_glue(ModuleRef llmod) -> ValueRef {\n     ret fun;\n }\n \n+fn make_vec_grow_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n+    /*\n+     * Args to vec_grow_glue:\n+     *\n+     *   0. (Implicit) task ptr\n+     *\n+     *   1. Pointer to the tydesc of the vec, so that we can tell if it's gc\n+     *      mem, and have a tydesc to pass to malloc if we're allocating anew.\n+     *\n+     *   2. Pointer to the tydesc of the vec's stored element type, so that\n+     *      elements can be copied to a newly alloc'ed vec if one must be\n+     *      created.\n+     *\n+     *   3. Alias to vec that needs to grow (i.e. ptr to ptr to rust_vec).\n+     *\n+     *   4. Number of bytes of growth requested\n+     *\n+     */\n+\n+    auto ty = T_fn(vec(T_taskptr(tn),\n+                       T_ptr(T_tydesc(tn)),\n+                       T_ptr(T_tydesc(tn)),\n+                       T_ptr(T_ptr(T_vec(T_int()))), // a lie.\n+                       T_int()), T_void());\n+\n+    auto llfn = decl_fastcall_fn(llmod, abi.vec_grow_glue_name(), ty);\n+    ret llfn;\n+}\n+\n+fn trans_vec_grow_glue(@crate_ctxt cx) {\n+\n+    auto llfn = cx.glues.vec_grow_glue;\n+\n+    let ValueRef lltaskptr = llvm.LLVMGetParam(llfn, 0u);\n+    let ValueRef llvec_tydesc = llvm.LLVMGetParam(llfn, 1u);\n+    let ValueRef llelt_tydesc = llvm.LLVMGetParam(llfn, 2u);\n+    let ValueRef llvec_ptr = llvm.LLVMGetParam(llfn, 3u);\n+    let ValueRef llnbytes = llvm.LLVMGetParam(llfn, 4u);\n+\n+    auto fcx = @rec(llfn=llfn,\n+                    lltaskptr=lltaskptr,\n+                    llenv=C_null(T_ptr(T_nil())),\n+                    llretptr=C_null(T_ptr(T_nil())),\n+                    mutable llself=none[ValueRef],\n+                    mutable lliterbody=none[ValueRef],\n+                    llargs=new_def_hash[ValueRef](),\n+                    llobjfields=new_def_hash[ValueRef](),\n+                    lllocals=new_def_hash[ValueRef](),\n+                    lltydescs=new_def_hash[ValueRef](),\n+                    ccx=cx);\n+\n+    auto bcx = new_top_block_ctxt(fcx);\n+\n+    auto llneed_copy_ptr = bcx.build.Alloca(T_int());\n+\n+    auto llnew_vec_res =\n+        trans_upcall(bcx, \"upcall_vec_grow\",\n+                     vec(vp2i(bcx, bcx.build.Load(llvec_ptr)),\n+                         llnbytes,\n+                         vp2i(bcx, llneed_copy_ptr),\n+                         vp2i(bcx, llvec_tydesc)));\n+\n+    bcx = llnew_vec_res.bcx;\n+    auto llnew_vec = vi2p(bcx,\n+                          llnew_vec_res.val,\n+                          T_ptr(T_vec(T_int())) // a lie.\n+                          );\n+\n+    // FIXME: complete this.\n+\n+    bcx.build.RetVoid();\n+}\n+\n+\n fn make_glues(ModuleRef llmod, type_names tn) -> @glue_fns {\n     ret @rec(activate_glue = decl_glue(llmod, tn, abi.activate_glue_name()),\n              yield_glue = decl_glue(llmod, tn, abi.yield_glue_name()),\n@@ -5197,7 +5301,8 @@ fn make_glues(ModuleRef llmod, type_names tn) -> @glue_fns {\n                                     abi.n_upcall_glues as uint),\n              no_op_type_glue = make_no_op_type_glue(llmod, tn),\n              memcpy_glue = make_memcpy_glue(llmod),\n-             bzero_glue = make_bzero_glue(llmod));\n+             bzero_glue = make_bzero_glue(llmod),\n+             vec_grow_glue = make_vec_grow_glue(llmod, tn));\n }\n \n fn trans_crate(session.session sess, @ast.crate crate, str output,\n@@ -5256,6 +5361,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n \n     trans_mod(cx, crate.node.module);\n     trans_exit_task_glue(cx);\n+    trans_vec_grow_glue(cx);\n     create_crate_constant(cx);\n     if (!shared) {\n         trans_main_fn(cx, cx.crate_ptr);"}, {"sha": "771136da447fa8ec00ee47e0259c16159d5eb571", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dddeba19d33a1aa2e7681ae84424dbe4d7b510b7/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dddeba19d33a1aa2e7681ae84424dbe4d7b510b7/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=dddeba19d33a1aa2e7681ae84424dbe4d7b510b7", "patch": "@@ -395,6 +395,7 @@ fn type_is_nil(@t ty) -> bool {\n     fail;\n }\n \n+\n fn type_is_structural(@t ty) -> bool {\n     alt (ty.struct) {\n         case (ty_tup(_))    { ret true; }\n@@ -407,6 +408,15 @@ fn type_is_structural(@t ty) -> bool {\n     fail;\n }\n \n+fn type_is_sequence(@t ty) -> bool {\n+    alt (ty.struct) {\n+        case (ty_str)    { ret true; }\n+        case (ty_vec(_))    { ret true; }\n+        case (_)            { ret false; }\n+    }\n+    fail;\n+}\n+\n fn type_is_tup_like(@t ty) -> bool {\n     alt (ty.struct) {\n         case (ty_box(_))    { ret true; }"}]}