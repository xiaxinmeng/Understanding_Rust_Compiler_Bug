{"sha": "8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkOWY0YTEyOGM0Y2ZiMTVjZjYxYTVjNGI4N2EwNDJkNDk2ZDExY2Y=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-05-04T00:57:46Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-05-05T15:49:32Z"}, "message": "rustc: rename all occurences of \"freevar\" to \"upvar\".", "tree": {"sha": "b8d0f96b8d98e14165586799c792e1ef944de660", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8d0f96b8d98e14165586799c792e1ef944de660"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "html_url": "https://github.com/rust-lang/rust/commit/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "125dc60dabfdc70a92a757cff9d7d93a5e5376a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/125dc60dabfdc70a92a757cff9d7d93a5e5376a7", "html_url": "https://github.com/rust-lang/rust/commit/125dc60dabfdc70a92a757cff9d7d93a5e5376a7"}], "stats": {"total": 188, "additions": 94, "deletions": 94}, "files": [{"sha": "91256385232a9b32da2de83e6bd50e34650e9e5a", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -140,7 +140,7 @@ pub enum Res<Id = hir::HirId> {\n     SelfCtor(DefId /* impl */),  // `DefId` refers to the impl\n     Local(Id),\n     Upvar(Id,           // `HirId` of closed over local\n-          usize,        // index in the `freevars` list of the closure\n+          usize,        // index in the `upvars` list of the closure\n           ast::NodeId), // expr node that creates the closure\n \n     // Macro namespace"}, {"sha": "1e357e1341710578392e22fab8e635db9cca9be9", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -2476,19 +2476,19 @@ impl ForeignItemKind {\n     }\n }\n \n-/// A free variable referred to in a function.\n+/// A variable captured by a closure.\n #[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct Freevar<Id = HirId> {\n-    /// The variable being accessed free.\n+pub struct Upvar<Id = HirId> {\n+    /// The variable being captured.\n     pub res: Res<Id>,\n \n     // First span where it is accessed (there can be multiple).\n     pub span: Span\n }\n \n-impl<Id: fmt::Debug + Copy> Freevar<Id> {\n-    pub fn map_id<R>(self, map: impl FnMut(Id) -> R) -> Freevar<R> {\n-        Freevar {\n+impl<Id: fmt::Debug + Copy> Upvar<Id> {\n+    pub fn map_id<R>(self, map: impl FnMut(Id) -> R) -> Upvar<R> {\n+        Upvar {\n             res: self.res.map_id(map),\n             span: self.span,\n         }\n@@ -2497,12 +2497,12 @@ impl<Id: fmt::Debug + Copy> Freevar<Id> {\n     pub fn var_id(&self) -> Id {\n         match self.res {\n             Res::Local(id) | Res::Upvar(id, ..) => id,\n-            _ => bug!(\"Freevar::var_id: bad res ({:?})\", self.res)\n+            _ => bug!(\"Upvar::var_id: bad res ({:?})\", self.res)\n         }\n     }\n }\n \n-pub type FreevarMap = NodeMap<Vec<Freevar<ast::NodeId>>>;\n+pub type UpvarMap = NodeMap<Vec<Upvar<ast::NodeId>>>;\n \n pub type CaptureModeMap = NodeMap<CaptureClause>;\n "}, {"sha": "9eb46aa3779d9079d398ec00912b756e773fc04f", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.span_note(span,\n                               \"...so that pointer is not dereferenced outside its lifetime\");\n             }\n-            infer::FreeVariable(span, id) => {\n+            infer::ClosureCapture(span, id) => {\n                 err.span_note(span,\n                               &format!(\"...so that captured variable `{}` does not outlive the \\\n                                         enclosing closure\",\n@@ -214,7 +214,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     \"the reference is only valid for \", sup, \"\");\n                 err\n             }\n-            infer::FreeVariable(span, id) => {\n+            infer::ClosureCapture(span, id) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0474,"}, {"sha": "5846e604cfc09b046d1f0c75a791f199572cac0d", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -264,8 +264,8 @@ pub enum SubregionOrigin<'tcx> {\n     /// Dereference of reference must be within its lifetime\n     DerefPointer(Span),\n \n-    /// Closure bound must not outlive captured free variables\n-    FreeVariable(Span, ast::NodeId),\n+    /// Closure bound must not outlive captured variables\n+    ClosureCapture(Span, ast::NodeId),\n \n     /// Index into slice must be within its lifetime\n     IndexSlice(Span),\n@@ -1660,7 +1660,7 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             InfStackClosure(a) => a,\n             InvokeClosure(a) => a,\n             DerefPointer(a) => a,\n-            FreeVariable(a, _) => a,\n+            ClosureCapture(a, _) => a,\n             IndexSlice(a) => a,\n             RelateObjectBound(a) => a,\n             RelateParamBound(a, _) => a,"}, {"sha": "93ba4241c472540b251a9fcabe15c804377ed336", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -931,32 +931,32 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n         let closure_def_id = self.tcx().hir().local_def_id_from_hir_id(closure_expr.hir_id);\n-        if let Some(freevars) = self.tcx().freevars(closure_def_id) {\n-            for freevar in freevars.iter() {\n-                let var_hir_id = freevar.var_id();\n+        if let Some(upvars) = self.tcx().upvars(closure_def_id) {\n+            for upvar in upvars.iter() {\n+                let var_hir_id = upvar.var_id();\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_hir_id },\n                     closure_expr_id: closure_def_id.to_local(),\n                 };\n                 let upvar_capture = self.mc.tables.upvar_capture(upvar_id);\n                 let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.hir_id,\n                                                                    fn_decl_span,\n-                                                                   freevar));\n+                                                                   upvar));\n                 match upvar_capture {\n                     ty::UpvarCapture::ByValue => {\n                         let mode = copy_or_move(&self.mc,\n                                                 self.param_env,\n                                                 &cmt_var,\n                                                 CaptureMove);\n-                        self.delegate.consume(closure_expr.hir_id, freevar.span, &cmt_var, mode);\n+                        self.delegate.consume(closure_expr.hir_id, upvar.span, &cmt_var, mode);\n                     }\n                     ty::UpvarCapture::ByRef(upvar_borrow) => {\n                         self.delegate.borrow(closure_expr.hir_id,\n                                              fn_decl_span,\n                                              &cmt_var,\n                                              upvar_borrow.region,\n                                              upvar_borrow.kind,\n-                                             ClosureCapture(freevar.span));\n+                                             ClosureCapture(upvar.span));\n                     }\n                 }\n             }\n@@ -966,7 +966,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn cat_captured_var(&mut self,\n                         closure_hir_id: hir::HirId,\n                         closure_span: Span,\n-                        upvar: &hir::Freevar)\n+                        upvar: &hir::Upvar)\n                         -> mc::McResult<mc::cmt_<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective"}, {"sha": "4b458e474b299815c6fd79bff4ebbdd2bad544d7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -144,7 +144,7 @@ impl LiveNode {\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n enum LiveNodeKind {\n-    FreeVarNode(Span),\n+    UpvarNode(Span),\n     ExprNode(Span),\n     VarDefNode(Span),\n     ExitNode\n@@ -153,8 +153,8 @@ enum LiveNodeKind {\n fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_, '_, '_>) -> String {\n     let cm = tcx.sess.source_map();\n     match lnk {\n-        FreeVarNode(s) => {\n-            format!(\"Free var node [{}]\", cm.span_to_string(s))\n+        UpvarNode(s) => {\n+            format!(\"Upvar node [{}]\", cm.span_to_string(s))\n         }\n         ExprNode(s) => {\n             format!(\"Expr node [{}]\", cm.span_to_string(s))\n@@ -484,11 +484,11 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n         // construction site.\n         let mut call_caps = Vec::new();\n         let closure_def_id = ir.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n-        if let Some(freevars) = ir.tcx.freevars(closure_def_id) {\n-            call_caps.extend(freevars.iter().filter_map(|freevar| {\n-                if let Res::Local(rv) = freevar.res {\n-                    let freevar_ln = ir.add_live_node(FreeVarNode(freevar.span));\n-                    Some(CaptureInfo { ln: freevar_ln, var_hid: rv })\n+        if let Some(upvars) = ir.tcx.upvars(closure_def_id) {\n+            call_caps.extend(upvars.iter().filter_map(|upvar| {\n+                if let Res::Local(rv) = upvar.res {\n+                    let upvar_ln = ir.add_live_node(UpvarNode(upvar.span));\n+                    Some(CaptureInfo { ln: upvar_ln, var_hid: rv })\n                 } else {\n                     None\n                 }"}, {"sha": "bd67aabfe8e5f77b5688231077929dad626236f6", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -2572,9 +2572,9 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             };\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n-                            if let Some(freevars) = tcx.freevars(def_id) {\n-                                for (freevar, place) in freevars.iter().zip(places) {\n-                                    let var_name = tcx.hir().name_by_hir_id(freevar.var_id());\n+                            if let Some(upvars) = tcx.upvars(def_id) {\n+                                for (upvar, place) in upvars.iter().zip(places) {\n+                                    let var_name = tcx.hir().name_by_hir_id(upvar.var_id());\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n                             }\n@@ -2591,9 +2591,9 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                                                tcx.hir().span_by_hir_id(hir_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n-                            if let Some(freevars) = tcx.freevars(def_id) {\n-                                for (freevar, place) in freevars.iter().zip(places) {\n-                                    let var_name = tcx.hir().name_by_hir_id(freevar.var_id());\n+                            if let Some(upvars) = tcx.upvars(def_id) {\n+                                for (upvar, place) in upvars.iter().zip(places) {\n+                                    let var_name = tcx.hir().name_by_hir_id(upvar.var_id());\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n                             }"}, {"sha": "0e7b66b744499d595d2812626b8bf0c8735f67d9", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -824,7 +824,7 @@ rustc_queries! {\n             desc { \"generating a postorder list of CrateNums\" }\n         }\n \n-        query freevars(_: DefId) -> Option<Lrc<Vec<hir::Freevar>>> {\n+        query upvars(_: DefId) -> Option<Lrc<Vec<hir::Upvar>>> {\n             eval_always\n         }\n         query maybe_unused_trait_import(_: DefId) -> bool {"}, {"sha": "19440d0bc64ea3456a4d5c8efeab23154034efb0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -1071,10 +1071,10 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub queries: query::Queries<'tcx>,\n \n-    // Records the free variables referenced by every closure\n+    // Records the captured variables referenced by every closure\n     // expression. Do not track deps for this, just recompute it from\n     // scratch every time.\n-    freevars: FxHashMap<DefId, Lrc<Vec<hir::Freevar>>>,\n+    upvars: FxHashMap<DefId, Lrc<Vec<hir::Upvar>>>,\n \n     maybe_unused_trait_imports: FxHashSet<DefId>,\n     maybe_unused_extern_crates: Vec<(DefId, Span)>,\n@@ -1317,7 +1317,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }).collect();\n                 (k, Lrc::new(exports))\n             }).collect(),\n-            freevars: resolutions.freevars.into_iter().map(|(k, v)| {\n+            upvars: resolutions.upvars.into_iter().map(|(k, v)| {\n                 let vars: Vec<_> = v.into_iter().map(|e| {\n                     e.map_id(|id| hir.node_to_hir_id(id))\n                 }).collect();\n@@ -3055,7 +3055,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         assert_eq!(id, LOCAL_CRATE);\n         Lrc::new(middle::lang_items::collect(tcx))\n     };\n-    providers.freevars = |tcx, id| tcx.gcx.freevars.get(&id).cloned();\n+    providers.upvars = |tcx, id| tcx.gcx.upvars.get(&id).cloned();\n     providers.maybe_unused_trait_import = |tcx, id| {\n         tcx.maybe_unused_trait_imports.contains(&id)\n     };"}, {"sha": "cb92e4b7470a58640d2625c44fd61325ea5148e7", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -8,7 +8,7 @@ pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::fold::TypeFoldable;\n \n-use crate::hir::{map as hir_map, FreevarMap, GlobMap, TraitMap};\n+use crate::hir::{map as hir_map, UpvarMap, GlobMap, TraitMap};\n use crate::hir::Node;\n use crate::hir::def::{Res, DefKind, CtorOf, CtorKind, ExportMap};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -122,7 +122,7 @@ mod sty;\n \n #[derive(Clone)]\n pub struct Resolutions {\n-    pub freevars: FreevarMap,\n+    pub upvars: UpvarMap,\n     pub trait_map: TraitMap,\n     pub maybe_unused_trait_imports: NodeSet,\n     pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,"}, {"sha": "8e98d4d85b9cc04d437fc2d24d014575ae819de4", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -582,7 +582,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n                 if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n                     p!(write(\"@{:?}\", self.tcx().hir().span_by_hir_id(hir_id)));\n                     let mut sep = \" \";\n-                    for (freevar, upvar_ty) in self.tcx().freevars(did)\n+                    for (upvar, upvar_ty) in self.tcx().upvars(did)\n                         .as_ref()\n                         .map_or(&[][..], |v| &v[..])\n                         .iter()\n@@ -591,7 +591,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n                         p!(\n                             write(\"{}{}:\",\n                                     sep,\n-                                    self.tcx().hir().name_by_hir_id(freevar.var_id())),\n+                                    self.tcx().hir().name_by_hir_id(upvar.var_id())),\n                             print(upvar_ty));\n                         sep = \", \";\n                     }\n@@ -625,7 +625,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n                         p!(write(\"@{:?}\", self.tcx().hir().span_by_hir_id(hir_id)));\n                     }\n                     let mut sep = \" \";\n-                    for (freevar, upvar_ty) in self.tcx().freevars(did)\n+                    for (upvar, upvar_ty) in self.tcx().upvars(did)\n                         .as_ref()\n                         .map_or(&[][..], |v| &v[..])\n                         .iter()\n@@ -634,7 +634,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n                         p!(\n                             write(\"{}{}:\",\n                                     sep,\n-                                    self.tcx().hir().name_by_hir_id(freevar.var_id())),\n+                                    self.tcx().hir().name_by_hir_id(upvar.var_id())),\n                             print(upvar_ty));\n                         sep = \", \";\n                     }"}, {"sha": "8543cca1dd54502f9131521f67bf0c81d80c40c8", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -180,7 +180,7 @@ impl ExpansionResult {\n         ExpansionResult {\n             defs: Steal::new(resolver.definitions),\n             resolutions: Steal::new(Resolutions {\n-                freevars: resolver.freevars,\n+                upvars: resolver.upvars,\n                 export_map: resolver.export_map,\n                 trait_map: resolver.trait_map,\n                 glob_map: resolver.glob_map,\n@@ -199,7 +199,7 @@ impl ExpansionResult {\n         ExpansionResult {\n             defs: Steal::new(resolver.definitions.clone()),\n             resolutions: Steal::new(Resolutions {\n-                freevars: resolver.freevars.clone(),\n+                upvars: resolver.upvars.clone(),\n                 export_map: resolver.export_map.clone(),\n                 trait_map: resolver.trait_map.clone(),\n                 glob_map: resolver.glob_map.clone(),"}, {"sha": "8aa6456ebe77b8cbeef657d92c82d7238945b26b", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -1814,12 +1814,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 ty::Array(ty, _) | ty::Slice(ty) =>\n                     self.describe_field_from_ty(&ty, field, variant_index),\n                 ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n-                    // `tcx.freevars(def_id)` returns an `Option`, which is `None` in case\n+                    // `tcx.upvars(def_id)` returns an `Option`, which is `None` in case\n                     // the closure comes from another crate. But in that case we wouldn't\n                     // be borrowck'ing it, so we can just unwrap:\n-                    let freevar = self.infcx.tcx.freevars(def_id).unwrap()[field.index()];\n+                    let upvar = self.infcx.tcx.upvars(def_id).unwrap()[field.index()];\n \n-                    self.infcx.tcx.hir().name_by_hir_id(freevar.var_id()).to_string()\n+                    self.infcx.tcx.hir().name_by_hir_id(upvar.var_id()).to_string()\n                 }\n                 _ => {\n                     // Might need a revision when the fields in trait RFC is implemented\n@@ -2609,7 +2609,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if let hir::ExprKind::Closure(\n             .., args_span, _\n         ) = expr {\n-            for (v, place) in self.infcx.tcx.freevars(def_id)?.iter().zip(places) {\n+            for (v, place) in self.infcx.tcx.upvars(def_id)?.iter().zip(places) {\n                 match place {\n                     Operand::Copy(place) |\n                     Operand::Move(place) if target_place == place => {"}, {"sha": "5e646a49e0e4293ed3c70118f3e1e06677c7c723", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -516,10 +516,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n                 }\n             };\n-            let upvars = cx.tcx.freevars(def_id).iter()\n-                .flat_map(|freevars| freevars.iter())\n+            let upvars = cx.tcx.upvars(def_id).iter()\n+                .flat_map(|upvars| upvars.iter())\n                 .zip(substs.upvar_tys(def_id, cx.tcx))\n-                .map(|(freevar, ty)| capture_freevar(cx, expr, freevar, ty))\n+                .map(|(upvar, ty)| capture_upvar(cx, expr, upvar, ty))\n                 .collect();\n             ExprKind::Closure {\n                 closure_id: def_id,\n@@ -1184,12 +1184,12 @@ fn overloaded_place<'a, 'gcx, 'tcx>(\n     ExprKind::Deref { arg: ref_expr.to_ref() }\n }\n \n-fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+fn capture_upvar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    closure_expr: &'tcx hir::Expr,\n-                                   freevar: &hir::Freevar,\n-                                   freevar_ty: Ty<'tcx>)\n+                                   upvar: &hir::Upvar,\n+                                   upvar_ty: Ty<'tcx>)\n                                    -> ExprRef<'tcx> {\n-    let var_hir_id = freevar.var_id();\n+    let var_hir_id = upvar.var_id();\n     let upvar_id = ty::UpvarId {\n         var_path: ty::UpvarPath { hir_id: var_hir_id },\n         closure_expr_id: cx.tcx.hir().local_def_id_from_hir_id(closure_expr.hir_id).to_local(),\n@@ -1201,7 +1201,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         temp_lifetime,\n         ty: var_ty,\n         span: closure_expr.span,\n-        kind: convert_var(cx, closure_expr, freevar.res),\n+        kind: convert_var(cx, closure_expr, upvar.res),\n     };\n     match upvar_capture {\n         ty::UpvarCapture::ByValue => captured_var.to_ref(),\n@@ -1213,7 +1213,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             };\n             Expr {\n                 temp_lifetime,\n-                ty: freevar_ty,\n+                ty: upvar_ty,\n                 span: closure_expr.span,\n                 kind: ExprKind::Borrow {\n                     borrow_kind,"}, {"sha": "3bc6ec0564c60fbaca93048b9c13907d807794f6", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -170,7 +170,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, '\n                 if def_id.is_local() {\n                     let tables = self.ecx.tcx.typeck_tables_of(def_id);\n                     if let Some(upvars) = tables.upvar_list.get(&def_id) {\n-                        // Sometimes the index is beyond the number of freevars (seen\n+                        // Sometimes the index is beyond the number of upvars (seen\n                         // for a generator).\n                         if let Some(upvar_id) = upvars.get(field) {\n                             let var_hir_id = upvar_id.var_path.hir_id;"}, {"sha": "0f651fafcd2ac487bf92d6871e3854dacb34fce5", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -450,7 +450,7 @@ fn check_expr_kind<'a, 'tcx>(\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n             let closure_def_id = v.tcx.hir().local_def_id_from_hir_id(e.hir_id);\n-            if !v.tcx.freevars(closure_def_id).map_or(true, |v| v.is_empty()) {\n+            if !v.tcx.upvars(closure_def_id).map_or(true, |v| v.is_empty()) {\n                 NotPromotable\n             } else {\n                 nested_body_promotable"}, {"sha": "f8f6e5b1cd012f2d338f9d891108e5ef1f7164cd", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -29,7 +29,7 @@ use rustc::hir::def::{\n };\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n-use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n+use rustc::hir::{Upvar, UpvarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::ty::{self, DefIdTree};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n use rustc::{bug, span_bug};\n@@ -1668,8 +1668,8 @@ pub struct Resolver<'a> {\n     /// Resolutions for labels (node IDs of their corresponding blocks or loops).\n     label_res_map: NodeMap<NodeId>,\n \n-    pub freevars: FreevarMap,\n-    freevars_seen: NodeMap<NodeMap<usize>>,\n+    pub upvars: UpvarMap,\n+    upvars_seen: NodeMap<NodeMap<usize>>,\n     pub export_map: ExportMap<NodeId>,\n     pub trait_map: TraitMap,\n \n@@ -2033,8 +2033,8 @@ impl<'a> Resolver<'a> {\n             partial_res_map: Default::default(),\n             import_res_map: Default::default(),\n             label_res_map: Default::default(),\n-            freevars: Default::default(),\n-            freevars_seen: Default::default(),\n+            upvars: Default::default(),\n+            upvars_seen: Default::default(),\n             export_map: FxHashMap::default(),\n             trait_map: Default::default(),\n             module_map,\n@@ -4054,21 +4054,21 @@ impl<'a> Resolver<'a> {\n                         ClosureRibKind(function_id) => {\n                             let prev_res = res;\n \n-                            let seen = self.freevars_seen\n+                            let seen = self.upvars_seen\n                                            .entry(function_id)\n                                            .or_default();\n                             if let Some(&index) = seen.get(&node_id) {\n                                 res = Res::Upvar(node_id, index, function_id);\n                                 continue;\n                             }\n-                            let vec = self.freevars\n+                            let vec = self.upvars\n                                           .entry(function_id)\n                                           .or_default();\n                             let depth = vec.len();\n                             res = Res::Upvar(node_id, depth, function_id);\n \n                             if record_used {\n-                                vec.push(Freevar {\n+                                vec.push(Upvar {\n                                     res: prev_res,\n                                     span,\n                                 });"}, {"sha": "d21ceb983f8f4cf6f2ef0843a2199ef68270a822", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -722,7 +722,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         let b = self.shallow_resolve(b);\n \n         match b.sty {\n-            ty::FnPtr(fn_ty) if self.tcx.freevars(def_id_a).map_or(true, |v| v.is_empty()) => {\n+            ty::FnPtr(fn_ty) if self.tcx.upvars(def_id_a).map_or(true, |v| v.is_empty()) => {\n                 // We coerce the closure, which has fn type\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n                 // to"}, {"sha": "c3861f964e4534dfe39e7363ea07a2ec73ed0463", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -121,28 +121,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             None\n         };\n \n-        if let Some(freevars) = self.tcx.freevars(closure_def_id) {\n-            let mut freevar_list: Vec<ty::UpvarId> = Vec::with_capacity(freevars.len());\n-            for freevar in freevars.iter() {\n+        if let Some(upvars) = self.tcx.upvars(closure_def_id) {\n+            let mut upvar_list: Vec<ty::UpvarId> = Vec::with_capacity(upvars.len());\n+            for upvar in upvars.iter() {\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath {\n-                        hir_id: freevar.var_id(),\n+                        hir_id: upvar.var_id(),\n                     },\n                     closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n                 };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n                 // Adding the upvar Id to the list of Upvars, which will be added\n                 // to the map for the closure at the end of the for loop.\n-                freevar_list.push(upvar_id);\n+                upvar_list.push(upvar_id);\n \n                 let capture_kind = match capture_clause {\n                     hir::CaptureByValue => ty::UpvarCapture::ByValue,\n                     hir::CaptureByRef => {\n                         let origin = UpvarRegion(upvar_id, span);\n-                        let freevar_region = self.next_region_var(origin);\n+                        let upvar_region = self.next_region_var(origin);\n                         let upvar_borrow = ty::UpvarBorrow {\n                             kind: ty::ImmBorrow,\n-                            region: freevar_region,\n+                            region: upvar_region,\n                         };\n                         ty::UpvarCapture::ByRef(upvar_borrow)\n                     }\n@@ -153,14 +153,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     .upvar_capture_map\n                     .insert(upvar_id, capture_kind);\n             }\n-            // Add the vector of freevars to the map keyed with the closure id.\n+            // Add the vector of upvars to the map keyed with the closure id.\n             // This gives us an easier access to them without having to call\n-            // tcx.freevars again..\n-            if !freevar_list.is_empty() {\n+            // tcx.upvars again..\n+            if !upvar_list.is_empty() {\n                 self.tables\n                     .borrow_mut()\n                     .upvar_list\n-                    .insert(closure_def_id, freevar_list);\n+                    .insert(closure_def_id, upvar_list);\n             }\n         }\n \n@@ -246,29 +246,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n         let closure_def_id = tcx.hir().local_def_id_from_hir_id(closure_id);\n \n-        tcx.freevars(closure_def_id).iter().flat_map(|freevars| {\n-            freevars\n+        tcx.upvars(closure_def_id).iter().flat_map(|upvars| {\n+            upvars\n                 .iter()\n-                .map(|freevar| {\n-                    let var_hir_id = freevar.var_id();\n-                    let freevar_ty = self.node_ty(var_hir_id);\n+                .map(|upvar| {\n+                    let var_hir_id = upvar.var_id();\n+                    let upvar_ty = self.node_ty(var_hir_id);\n                     let upvar_id = ty::UpvarId {\n                         var_path: ty::UpvarPath { hir_id: var_hir_id },\n                         closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n                     };\n                     let capture = self.tables.borrow().upvar_capture(upvar_id);\n \n                     debug!(\n-                        \"var_id={:?} freevar_ty={:?} capture={:?}\",\n-                        var_hir_id, freevar_ty, capture\n+                        \"var_id={:?} upvar_ty={:?} capture={:?}\",\n+                        var_hir_id, upvar_ty, capture\n                     );\n \n                     match capture {\n-                        ty::UpvarCapture::ByValue => freevar_ty,\n+                        ty::UpvarCapture::ByValue => upvar_ty,\n                         ty::UpvarCapture::ByRef(borrow) => tcx.mk_ref(\n                             borrow.region,\n                             ty::TypeAndMut {\n-                                ty: freevar_ty,\n+                                ty: upvar_ty,\n                                 mutbl: borrow.kind.to_mutbl_lossy(),\n                             },\n                         ),"}, {"sha": "4185999fdd6d734e8c9acae0ff4d1df9dbb4826d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "patch": "@@ -1093,8 +1093,8 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n                 }),\n         );\n \n-        if let Some(freevars) = tcx.freevars(def_id) {\n-            params.extend(freevars.iter().zip((dummy_args.len() as u32)..).map(|(_, i)| {\n+        if let Some(upvars) = tcx.upvars(def_id) {\n+            params.extend(upvars.iter().zip((dummy_args.len() as u32)..).map(|(_, i)| {\n                 ty::GenericParamDef {\n                     index: type_start + i,\n                     name: Symbol::intern(\"<upvar>\").as_interned_str(),"}]}