{"sha": "975f2649839c945660339b8929a04432b1562635", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NWYyNjQ5ODM5Yzk0NTY2MDMzOWI4OTI5YTA0NDMyYjE1NjI2MzU=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-05-17T00:41:47Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-05-20T18:49:20Z"}, "message": "refactoring test functions", "tree": {"sha": "48129d76172ad71e454637e01326c2232053ce20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48129d76172ad71e454637e01326c2232053ce20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/975f2649839c945660339b8929a04432b1562635", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/975f2649839c945660339b8929a04432b1562635", "html_url": "https://github.com/rust-lang/rust/commit/975f2649839c945660339b8929a04432b1562635", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/975f2649839c945660339b8929a04432b1562635/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3b458b5c5a555067e9d013066fac9c8de50c3f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3b458b5c5a555067e9d013066fac9c8de50c3f8", "html_url": "https://github.com/rust-lang/rust/commit/f3b458b5c5a555067e9d013066fac9c8de50c3f8"}], "stats": {"total": 175, "additions": 105, "deletions": 70}, "files": [{"sha": "f9cf421429cfd3da4d37f3ed6b017ffa88469e67", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 7, "deletions": 70, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/975f2649839c945660339b8929a04432b1562635/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975f2649839c945660339b8929a04432b1562635/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=975f2649839c945660339b8929a04432b1562635", "patch": "@@ -357,65 +357,18 @@ mod test {\n     use abi;\n     use ast_util::mk_ident;\n     use parse::parser::Parser;\n-    use parse::token::{ident_interner, mk_fresh_ident_interner};\n-    use diagnostic::{mk_span_handler, mk_handler};\n-\n-    // add known names to interner for testing\n-    fn mk_testing_interner() -> @ident_interner {\n-        let i = mk_fresh_ident_interner();\n-        // baby hack; in order to put the identifiers\n-        // 'a' and 'b' at known locations, we're going\n-        // to fill up the interner to length 100. If\n-        // the # of preloaded items on the interner\n-        // ever gets larger than 100, we'll have to\n-        // adjust this number (say, to 200) and\n-        // change the numbers in the identifier\n-        // test cases below.\n-\n-        assert!(i.len() < 100);\n-        for int::range(0,100-((i.len()).to_int())) |_dc| {\n-            i.gensym(\"dontcare\");\n-        }\n-        i.intern(\"a\");\n-        i.intern(\"b\");\n-        i.intern(\"c\");\n-        i.intern(\"d\");\n-        i.intern(\"return\");\n-        assert_eq!(i.get(ast::ident{repr:101,ctxt:0}), @~\"b\");\n-        i\n-    }\n-\n-    // make a parse_sess that's closed over a\n-    // testing interner (where a -> 100, b -> 101)\n-    fn mk_testing_parse_sess() -> @mut ParseSess {\n-        let interner = mk_testing_interner();\n-        let cm = @CodeMap::new();\n-        @mut ParseSess {\n-            cm: cm,\n-            next_id: 1,\n-            span_diagnostic: mk_span_handler(mk_handler(None), cm),\n-            interner: interner,\n-        }\n-    }\n-\n-    // map a string to tts, using a made-up filename: return both the token_trees\n-    // and the ParseSess\n-    fn string_to_tts_t (source_str : @~str) -> (~[ast::token_tree],@mut ParseSess) {\n-        let ps = mk_testing_parse_sess();\n-        (filemap_to_tts(ps,string_to_filemap(ps,source_str,~\"bogofile\")),ps)\n-    }\n+    use parse::token::{ident_interner, mk_ident_interner, mk_fresh_ident_interner};\n+    use diagnostic::{span_handler, mk_span_handler, mk_handler, Emitter};\n+    use util::parser_testing::{string_to_tts_and_sess,string_to_parser};\n+    use util::parser_testing::{string_to_crate, string_to_expr, string_to_item};\n+    use util::parser_testing::{string_to_stmt};\n \n     // map a string to tts, return the tt without its parsesess\n     fn string_to_tts_only(source_str : @~str) -> ~[ast::token_tree] {\n-        let (tts,_ps) = string_to_tts_t(source_str);\n+        let (tts,_ps) = string_to_tts_and_sess(source_str);\n         tts\n     }\n \n-    // map string to parser (via tts)\n-    fn string_to_parser(source_str: @~str) -> Parser {\n-        let ps = mk_testing_parse_sess();\n-        new_parser_from_source_str(ps,~[],~\"bogofile\",source_str)\n-    }\n \n     #[cfg(test)] fn to_json_str<E : Encodable<std::json::Encoder>>(val: @E) -> ~str {\n         do io::with_str_writer |writer| {\n@@ -424,22 +377,6 @@ mod test {\n         }\n     }\n \n-    fn string_to_crate (source_str : @~str) -> @ast::crate {\n-        string_to_parser(source_str).parse_crate_mod()\n-    }\n-\n-    fn string_to_expr (source_str : @~str) -> @ast::expr {\n-        string_to_parser(source_str).parse_expr()\n-    }\n-\n-    fn string_to_item (source_str : @~str) -> Option<@ast::item> {\n-        string_to_parser(source_str).parse_item(~[])\n-    }\n-\n-    fn string_to_stmt (source_str : @~str) -> @ast::stmt {\n-        string_to_parser(source_str).parse_stmt(~[])\n-    }\n-\n     // produce a codemap::span\n     fn sp (a: uint, b: uint) -> span {\n         span{lo:BytePos(a),hi:BytePos(b),expn_info:None}\n@@ -482,7 +419,7 @@ mod test {\n     }*/\n \n     #[test] fn string_to_tts_1 () {\n-        let (tts,_ps) = string_to_tts_t(@~\"fn a (b : int) { b; }\");\n+        let (tts,_ps) = string_to_tts_and_sess(@~\"fn a (b : int) { b; }\");\n         assert_eq!(to_json_str(@tts),\n                    ~\"[\\\n                 [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"fn\\\",false]],\\"}, {"sha": "7ac8c08b25d8a9f5ff2d75efe2a70f469315e646", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/975f2649839c945660339b8929a04432b1562635/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/975f2649839c945660339b8929a04432b1562635/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=975f2649839c945660339b8929a04432b1562635", "patch": "@@ -30,6 +30,8 @@ extern mod std;\n #[macro_escape]\n pub mod util {\n     pub mod interner;\n+    #[cfg(test)]\n+    pub mod parser_testing;\n }\n \n pub mod syntax {"}, {"sha": "9ab77803576e04dc22e47d20b314c23f08e28635", "filename": "src/libsyntax/util/parser_testing.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/975f2649839c945660339b8929a04432b1562635/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975f2649839c945660339b8929a04432b1562635/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=975f2649839c945660339b8929a04432b1562635", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::serialize::Encodable;\n+use std;\n+use core::io;\n+use core::option::{Option,None};\n+use core::int;\n+use core::num::NumCast;\n+use codemap::{dummy_sp, CodeMap, BytePos, spanned};\n+use opt_vec;\n+use ast;\n+use abi;\n+use ast_util::mk_ident;\n+use parse::parser::Parser;\n+use parse::token::{ident_interner, mk_ident_interner, mk_fresh_ident_interner};\n+use diagnostic::{span_handler, mk_span_handler, mk_handler, Emitter};\n+\n+use syntax::parse::{ParseSess,new_parse_sess,string_to_filemap,filemap_to_tts};\n+use syntax::parse::{new_parser_from_source_str};\n+\n+// add known names to interner for testing\n+fn mk_testing_interner() -> @ident_interner {\n+    let i = mk_fresh_ident_interner();\n+    // baby hack; in order to put the identifiers\n+    // 'a' and 'b' at known locations, we're going\n+    // to fill up the interner to length 100. If\n+    // the # of preloaded items on the interner\n+    // ever gets larger than 100, we'll have to\n+    // adjust this number (say, to 200) and\n+    // change the numbers in the identifier\n+    // test cases below.\n+\n+    assert!(i.len() < 100);\n+    for int::range(0,100-((i.len()).to_int())) |_dc| {\n+        i.gensym(~\"dontcare\");\n+    }\n+    i.intern(\"a\");\n+    i.intern(\"b\");\n+    i.intern(\"c\");\n+    i.intern(\"d\");\n+    i.intern(\"return\");\n+    assert!(i.get(ast::ident{repr:101,ctxt:0}) == @~\"b\");\n+    i\n+}\n+\n+// make a parse_sess that's closed over a\n+// testing interner (where a -> 100, b -> 101)\n+fn mk_testing_parse_sess() -> @mut ParseSess {\n+    let interner = mk_testing_interner();\n+    let cm = @CodeMap::new();\n+    @mut ParseSess {\n+        cm: cm,\n+        next_id: 1,\n+        span_diagnostic: mk_span_handler(mk_handler(None), cm),\n+        interner: interner,\n+    }\n+}\n+\n+// map a string to tts, using a made-up filename: return both the token_trees\n+// and the ParseSess\n+pub fn string_to_tts_and_sess (source_str : @~str) -> (~[ast::token_tree],@mut ParseSess) {\n+    let ps = mk_testing_parse_sess();\n+    (filemap_to_tts(ps,string_to_filemap(ps,source_str,~\"bogofile\")),ps)\n+}\n+\n+// map string to parser (via tts)\n+pub fn string_to_parser(source_str: @~str) -> Parser {\n+    let ps = mk_testing_parse_sess();\n+    new_parser_from_source_str(ps,~[],~\"bogofile\",source_str)\n+}\n+\n+pub fn string_to_crate (source_str : @~str) -> @ast::crate {\n+    string_to_parser(source_str).parse_crate_mod()\n+}\n+\n+// parse a string, return an expr\n+pub fn string_to_expr (source_str : @~str) -> @ast::expr {\n+    string_to_parser(source_str).parse_expr()\n+}\n+\n+pub fn string_to_item (source_str : @~str) -> Option<@ast::item> {\n+    string_to_parser(source_str).parse_item(~[])\n+}\n+\n+pub fn string_to_stmt (source_str : @~str) -> @ast::stmt {\n+    string_to_parser(source_str).parse_stmt(~[])\n+}\n+"}]}