{"sha": "1cd97cad6e5f85bed455f505f330ead1d5cd8432", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZDk3Y2FkNmU1Zjg1YmVkNDU1ZjUwNWYzMzBlYWQxZDVjZDg0MzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-26T04:34:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-26T04:34:46Z"}, "message": "Auto merge of #78387 - Dylan-DPC:rollup-ch0st6z, r=Dylan-DPC\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #74477 (`#[deny(unsafe_op_in_unsafe_fn)]` in sys/wasm)\n - #77836 (transmute_copy: explain that alignment is handled correctly)\n - #78126 (Properly define va_arg and va_list for aarch64-apple-darwin)\n - #78137 (Initialize tracing subscriber in compiletest tool)\n - #78161 (Add issue template link to IRLO)\n - #78214 (Tweak match arm semicolon removal suggestion to account for futures)\n - #78247 (Fix #78192)\n - #78252 (Add codegen test for #45964)\n - #78268 (Do not try to report on closures to avoid ICE)\n - #78295 (Add some regression tests)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "7713c2e1b72df2e80cebedfacf98a4d85aab2720", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7713c2e1b72df2e80cebedfacf98a4d85aab2720"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cd97cad6e5f85bed455f505f330ead1d5cd8432", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cd97cad6e5f85bed455f505f330ead1d5cd8432", "html_url": "https://github.com/rust-lang/rust/commit/1cd97cad6e5f85bed455f505f330ead1d5cd8432", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cd97cad6e5f85bed455f505f330ead1d5cd8432/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16e9ed0b1c58e0327eb37eb6f70e9b9ef1844591", "url": "https://api.github.com/repos/rust-lang/rust/commits/16e9ed0b1c58e0327eb37eb6f70e9b9ef1844591", "html_url": "https://github.com/rust-lang/rust/commit/16e9ed0b1c58e0327eb37eb6f70e9b9ef1844591"}, {"sha": "c8e0f4d90b474492485e869be81b0d452dbe1926", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8e0f4d90b474492485e869be81b0d452dbe1926", "html_url": "https://github.com/rust-lang/rust/commit/c8e0f4d90b474492485e869be81b0d452dbe1926"}], "stats": {"total": 1281, "additions": 913, "deletions": 368}, "files": [{"sha": "7d4cfaece448155bed48792cb8c81342ed81b3d5", "filename": ".github/ISSUE_TEMPLATE/config.yml", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/.github%2FISSUE_TEMPLATE%2Fconfig.yml", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/.github%2FISSUE_TEMPLATE%2Fconfig.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fconfig.yml?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -1,5 +1,8 @@\n blank_issues_enabled: true\n contact_links:\n-  - name: Rust Programming Language Forum\n+  - name: Question\n     url: https://users.rust-lang.org\n-    about: Please ask and answer questions about Rust here.\n+    about: Please ask and answer questions about Rust on the user forum.\n+  - name: Feature Request\n+    url: https://internals.rust-lang.org/\n+    about: Please discuss language feature requests on the internals forum."}, {"sha": "65d20190c0db5430aa31df321de6e34da7693400", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -649,7 +649,6 @@ name = \"compiletest\"\n version = \"0.0.0\"\n dependencies = [\n  \"diff\",\n- \"env_logger 0.7.1\",\n  \"getopts\",\n  \"glob\",\n  \"lazy_static\",\n@@ -660,6 +659,7 @@ dependencies = [\n  \"serde\",\n  \"serde_json\",\n  \"tracing\",\n+ \"tracing-subscriber\",\n  \"walkdir\",\n  \"winapi 0.3.9\",\n ]"}, {"sha": "b6a0516b8bc9cb1a44f1af9a4ce15a89af539c27", "filename": "compiler/rustc_codegen_llvm/src/va_arg.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -173,26 +173,24 @@ pub(super) fn emit_va_arg(\n     // is lacking in some instances, so we should only use it as a fallback.\n     let target = &bx.cx.tcx.sess.target;\n     let arch = &bx.cx.tcx.sess.target.arch;\n-    match (&**arch, target.options.is_like_windows) {\n+    match &**arch {\n         // Windows x86\n-        (\"x86\", true) => {\n+        \"x86\" if target.options.is_like_windows => {\n             emit_ptr_va_arg(bx, addr, target_ty, false, Align::from_bytes(4).unwrap(), false)\n         }\n         // Generic x86\n-        (\"x86\", _) => {\n-            emit_ptr_va_arg(bx, addr, target_ty, false, Align::from_bytes(4).unwrap(), true)\n-        }\n+        \"x86\" => emit_ptr_va_arg(bx, addr, target_ty, false, Align::from_bytes(4).unwrap(), true),\n         // Windows AArch64\n-        (\"aarch64\", true) => {\n+        \"aarch64\" if target.options.is_like_windows => {\n             emit_ptr_va_arg(bx, addr, target_ty, false, Align::from_bytes(8).unwrap(), false)\n         }\n-        // iOS AArch64\n-        (\"aarch64\", _) if target.target_os == \"ios\" => {\n+        // macOS / iOS AArch64\n+        \"aarch64\" if target.options.is_like_osx => {\n             emit_ptr_va_arg(bx, addr, target_ty, false, Align::from_bytes(8).unwrap(), true)\n         }\n-        (\"aarch64\", _) => emit_aapcs_va_arg(bx, addr, target_ty),\n+        \"aarch64\" => emit_aapcs_va_arg(bx, addr, target_ty),\n         // Windows x86_64\n-        (\"x86_64\", true) => {\n+        \"x86_64\" if target.options.is_like_windows => {\n             let target_ty_size = bx.cx.size_of(target_ty).bytes();\n             let indirect: bool = target_ty_size > 8 || !target_ty_size.is_power_of_two();\n             emit_ptr_va_arg(bx, addr, target_ty, indirect, Align::from_bytes(8).unwrap(), false)"}, {"sha": "f7e4ace8fc5fcadf499d65fc81c56c58702c2aa9", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 171, "deletions": 52, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -50,10 +50,10 @@ use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n \n use crate::infer;\n-use crate::infer::OriginalQueryValues;\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n+    StatementAsExpression,\n };\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -64,7 +64,6 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Item, ItemKind, Node};\n use rustc_middle::ty::error::TypeError;\n-use rustc_middle::ty::ParamEnvAnd;\n use rustc_middle::ty::{\n     self,\n     subst::{Subst, SubstsRef},\n@@ -688,13 +687,36 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     };\n                     let msg = \"`match` arms have incompatible types\";\n                     err.span_label(outer_error_span, msg);\n-                    if let Some(sp) = semi_span {\n-                        err.span_suggestion_short(\n-                            sp,\n-                            \"consider removing this semicolon\",\n-                            String::new(),\n-                            Applicability::MachineApplicable,\n-                        );\n+                    if let Some((sp, boxed)) = semi_span {\n+                        if let (StatementAsExpression::NeedsBoxing, [.., prior_arm]) =\n+                            (boxed, &prior_arms[..])\n+                        {\n+                            err.multipart_suggestion(\n+                                \"consider removing this semicolon and boxing the expressions\",\n+                                vec![\n+                                    (prior_arm.shrink_to_lo(), \"Box::new(\".to_string()),\n+                                    (prior_arm.shrink_to_hi(), \")\".to_string()),\n+                                    (arm_span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                                    (arm_span.shrink_to_hi(), \")\".to_string()),\n+                                    (sp, String::new()),\n+                                ],\n+                                Applicability::HasPlaceholders,\n+                            );\n+                        } else if matches!(boxed, StatementAsExpression::NeedsBoxing) {\n+                            err.span_suggestion_short(\n+                                sp,\n+                                \"consider removing this semicolon and boxing the expressions\",\n+                                String::new(),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            err.span_suggestion_short(\n+                                sp,\n+                                \"consider removing this semicolon\",\n+                                String::new(),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n                     }\n                     if let Some(ret_sp) = opt_suggest_box_span {\n                         // Get return type span and point to it.\n@@ -717,13 +739,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 if let Some(sp) = outer {\n                     err.span_label(sp, \"`if` and `else` have incompatible types\");\n                 }\n-                if let Some(sp) = semicolon {\n-                    err.span_suggestion_short(\n-                        sp,\n-                        \"consider removing this semicolon\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    );\n+                if let Some((sp, boxed)) = semicolon {\n+                    if matches!(boxed, StatementAsExpression::NeedsBoxing) {\n+                        err.multipart_suggestion(\n+                            \"consider removing this semicolon and boxing the expression\",\n+                            vec![\n+                                (then.shrink_to_lo(), \"Box::new(\".to_string()),\n+                                (then.shrink_to_hi(), \")\".to_string()),\n+                                (else_sp.shrink_to_lo(), \"Box::new(\".to_string()),\n+                                (else_sp.shrink_to_hi(), \")\".to_string()),\n+                                (sp, String::new()),\n+                            ],\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else {\n+                        err.span_suggestion_short(\n+                            sp,\n+                            \"consider removing this semicolon\",\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n                 }\n                 if let Some(ret_sp) = opt_suggest_box_span {\n                     self.suggest_boxing_for_return_impl_trait(\n@@ -1602,6 +1638,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             Mismatch::Variable(exp_found) => Some(exp_found),\n             Mismatch::Fixed(_) => None,\n         };\n+        let exp_found = match terr {\n+            // `terr` has more accurate type information than `exp_found` in match expressions.\n+            ty::error::TypeError::Sorts(terr)\n+                if exp_found.map_or(false, |ef| terr.found == ef.found) =>\n+            {\n+                Some(*terr)\n+            }\n+            _ => exp_found,\n+        };\n+        debug!(\"exp_found {:?} terr {:?}\", exp_found, terr);\n         if let Some(exp_found) = exp_found {\n             self.suggest_as_ref_where_appropriate(span, &exp_found, diag);\n             self.suggest_await_on_expect_found(cause, span, &exp_found, diag);\n@@ -1623,6 +1669,53 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.note_error_origin(diag, cause, exp_found);\n     }\n \n+    fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+        if let ty::Opaque(def_id, substs) = ty.kind() {\n+            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n+            // Future::Output\n+            let item_def_id = self\n+                .tcx\n+                .associated_items(future_trait)\n+                .in_definition_order()\n+                .next()\n+                .unwrap()\n+                .def_id;\n+\n+            let bounds = self.tcx.explicit_item_bounds(*def_id);\n+\n+            for (predicate, _) in bounds {\n+                let predicate = predicate.subst(self.tcx, substs);\n+                if let ty::PredicateAtom::Projection(projection_predicate) =\n+                    predicate.skip_binders()\n+                {\n+                    if projection_predicate.projection_ty.item_def_id == item_def_id {\n+                        // We don't account for multiple `Future::Output = Ty` contraints.\n+                        return Some(projection_predicate.ty);\n+                    }\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    /// A possible error is to forget to add `.await` when using futures:\n+    ///\n+    /// ```\n+    /// async fn make_u32() -> u32 {\n+    ///     22\n+    /// }\n+    ///\n+    /// fn take_u32(x: u32) {}\n+    ///\n+    /// async fn foo() {\n+    ///     let x = make_u32();\n+    ///     take_u32(x);\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n+    /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n+    /// `.await` to the tail of the expression.\n     fn suggest_await_on_expect_found(\n         &self,\n         cause: &ObligationCause<'tcx>,\n@@ -1632,50 +1725,76 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) {\n         debug!(\n             \"suggest_await_on_expect_found: exp_span={:?}, expected_ty={:?}, found_ty={:?}\",\n-            exp_span, exp_found.expected, exp_found.found\n+            exp_span, exp_found.expected, exp_found.found,\n         );\n \n-        if let ty::Opaque(def_id, _) = *exp_found.expected.kind() {\n-            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n-            // Future::Output\n-            let item_def_id = self\n-                .tcx\n-                .associated_items(future_trait)\n-                .in_definition_order()\n-                .next()\n-                .unwrap()\n-                .def_id;\n+        if let ObligationCauseCode::CompareImplMethodObligation { .. } = &cause.code {\n+            return;\n+        }\n \n-            let projection_ty = self.tcx.projection_ty_from_predicates((def_id, item_def_id));\n-            if let Some(projection_ty) = projection_ty {\n-                let projection_query = self.canonicalize_query(\n-                    &ParamEnvAnd { param_env: self.tcx.param_env(def_id), value: projection_ty },\n-                    &mut OriginalQueryValues::default(),\n-                );\n-                if let Ok(resp) = self.tcx.normalize_projection_ty(projection_query) {\n-                    let normalized_ty = resp.value.value.normalized_ty;\n-                    debug!(\"suggest_await_on_expect_found: normalized={:?}\", normalized_ty);\n-                    if ty::TyS::same_type(normalized_ty, exp_found.found) {\n-                        let span = if let ObligationCauseCode::Pattern {\n-                            span,\n-                            origin_expr: _,\n-                            root_ty: _,\n-                        } = cause.code\n-                        {\n-                            // scrutinee's span\n-                            span.unwrap_or(exp_span)\n-                        } else {\n-                            exp_span\n-                        };\n-                        diag.span_suggestion_verbose(\n-                            span.shrink_to_hi(),\n-                            \"consider awaiting on the future\",\n-                            \".await\".to_string(),\n+        match (\n+            self.get_impl_future_output_ty(exp_found.expected),\n+            self.get_impl_future_output_ty(exp_found.found),\n+        ) {\n+            (Some(exp), Some(found)) if ty::TyS::same_type(exp, found) => match &cause.code {\n+                ObligationCauseCode::IfExpression(box IfExpressionCause { then, .. }) => {\n+                    diag.multipart_suggestion(\n+                        \"consider `await`ing on both `Future`s\",\n+                        vec![\n+                            (then.shrink_to_hi(), \".await\".to_string()),\n+                            (exp_span.shrink_to_hi(), \".await\".to_string()),\n+                        ],\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                    prior_arms,\n+                    ..\n+                }) => {\n+                    if let [.., arm_span] = &prior_arms[..] {\n+                        diag.multipart_suggestion(\n+                            \"consider `await`ing on both `Future`s\",\n+                            vec![\n+                                (arm_span.shrink_to_hi(), \".await\".to_string()),\n+                                (exp_span.shrink_to_hi(), \".await\".to_string()),\n+                            ],\n                             Applicability::MaybeIncorrect,\n                         );\n+                    } else {\n+                        diag.help(\"consider `await`ing on both `Future`s\");\n                     }\n                 }\n+                _ => {\n+                    diag.help(\"consider `await`ing on both `Future`s\");\n+                }\n+            },\n+            (_, Some(ty)) if ty::TyS::same_type(exp_found.expected, ty) => {\n+                let span = match cause.code {\n+                    // scrutinee's span\n+                    ObligationCauseCode::Pattern { span: Some(span), .. } => span,\n+                    _ => exp_span,\n+                };\n+                diag.span_suggestion_verbose(\n+                    span.shrink_to_hi(),\n+                    \"consider `await`ing on the `Future`\",\n+                    \".await\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            (Some(ty), _) if ty::TyS::same_type(ty, exp_found.found) => {\n+                let span = match cause.code {\n+                    // scrutinee's span\n+                    ObligationCauseCode::Pattern { span: Some(span), .. } => span,\n+                    _ => exp_span,\n+                };\n+                diag.span_suggestion_verbose(\n+                    span.shrink_to_hi(),\n+                    \"consider `await`ing on the `Future`\",\n+                    \".await\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n             }\n+            _ => {}\n         }\n     }\n "}, {"sha": "e9d5ebad7de03b4aedc103d8d425dd45936d2833", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -39,6 +39,14 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             ) if **sub_r == RegionKind::ReStatic => {\n                 // This is for an implicit `'static` requirement coming from `impl dyn Trait {}`.\n                 if let ObligationCauseCode::UnifyReceiver(ctxt) = &cause.code {\n+                    // This may have a closure and it would cause ICE\n+                    // through `find_param_with_region` (#78262).\n+                    let anon_reg_sup = tcx.is_suitable_region(sup_r)?;\n+                    let fn_returns = tcx.return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n+                    if fn_returns.is_empty() {\n+                        return None;\n+                    }\n+\n                     let param = self.find_param_with_region(sup_r, sub_r)?;\n                     let lifetime = if sup_r.has_name() {\n                         format!(\"lifetime `{}`\", sup_r)"}, {"sha": "4deb7225dcb61db4e6cb7a1b0f28181a5c8d8f4c", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -340,11 +340,24 @@ impl ObligationCauseCode<'_> {\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(ObligationCauseCode<'_>, 32);\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum StatementAsExpression {\n+    CorrectType,\n+    NeedsBoxing,\n+}\n+\n+impl<'tcx> ty::Lift<'tcx> for StatementAsExpression {\n+    type Lifted = StatementAsExpression;\n+    fn lift_to_tcx(self, _tcx: TyCtxt<'tcx>) -> Option<StatementAsExpression> {\n+        Some(self)\n+    }\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct MatchExpressionArmCause<'tcx> {\n     pub arm_span: Span,\n     pub scrut_span: Span,\n-    pub semi_span: Option<Span>,\n+    pub semi_span: Option<(Span, StatementAsExpression)>,\n     pub source: hir::MatchSource,\n     pub prior_arms: Vec<Span>,\n     pub last_ty: Ty<'tcx>,\n@@ -357,7 +370,7 @@ pub struct IfExpressionCause {\n     pub then: Span,\n     pub else_sp: Span,\n     pub outer: Option<Span>,\n-    pub semicolon: Option<Span>,\n+    pub semicolon: Option<(Span, StatementAsExpression)>,\n     pub opt_suggest_box_span: Option<Span>,\n }\n "}, {"sha": "5ec0ec0c56ad64b25d1effd7be08cd76139d08d7", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -334,26 +334,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         debug!(\"note_and_explain_type_err err={:?} cause={:?}\", err, cause);\n         match err {\n             Sorts(values) => {\n-                let expected_str = values.expected.sort_string(self);\n-                let found_str = values.found.sort_string(self);\n-                if expected_str == found_str && expected_str == \"closure\" {\n-                    db.note(\"no two closures, even if identical, have the same type\");\n-                    db.help(\"consider boxing your closure and/or using it as a trait object\");\n-                }\n-                if expected_str == found_str && expected_str == \"opaque type\" {\n-                    // Issue #63167\n-                    db.note(\"distinct uses of `impl Trait` result in different opaque types\");\n-                    let e_str = values.expected.to_string();\n-                    let f_str = values.found.to_string();\n-                    if e_str == f_str && &e_str == \"impl std::future::Future\" {\n-                        // FIXME: use non-string based check.\n-                        db.help(\n-                            \"if both `Future`s have the same `Output` type, consider \\\n-                                 `.await`ing on both of them\",\n-                        );\n-                    }\n-                }\n                 match (values.expected.kind(), values.found.kind()) {\n+                    (ty::Closure(..), ty::Closure(..)) => {\n+                        db.note(\"no two closures, even if identical, have the same type\");\n+                        db.help(\"consider boxing your closure and/or using it as a trait object\");\n+                    }\n+                    (ty::Opaque(..), ty::Opaque(..)) => {\n+                        // Issue #63167\n+                        db.note(\"distinct uses of `impl Trait` result in different opaque types\");\n+                    }\n                     (ty::Float(_), ty::Infer(ty::IntVar(_))) => {\n                         if let Ok(\n                             // Issue #53280\n@@ -382,12 +371,12 @@ impl<'tcx> TyCtxt<'tcx> {\n                         }\n                         db.note(\n                             \"a type parameter was expected, but a different one was found; \\\n-                                 you might be missing a type parameter or trait bound\",\n+                             you might be missing a type parameter or trait bound\",\n                         );\n                         db.note(\n                             \"for more information, visit \\\n-                                 https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-                                 #traits-as-parameters\",\n+                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                             #traits-as-parameters\",\n                         );\n                     }\n                     (ty::Projection(_), ty::Projection(_)) => {\n@@ -471,8 +460,8 @@ impl<T> Trait<T> for X {\n                         }\n                         db.note(\n                             \"for more information, visit \\\n-                                 https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-                                 #traits-as-parameters\",\n+                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                             #traits-as-parameters\",\n                         );\n                     }\n                     (ty::Param(p), ty::Closure(..) | ty::Generator(..)) => {"}, {"sha": "c5c14ca7caeb522c05cd6d297b8817c65922c7f0", "filename": "compiler/rustc_mir/src/transform/instcombine.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -119,11 +119,6 @@ impl OptimizationFinder<'b, 'tcx> {\n     }\n \n     fn find_deref_of_address(&mut self, rvalue: &Rvalue<'tcx>, location: Location) -> Option<()> {\n-        // FIXME(#78192): This optimization can result in unsoundness.\n-        if !self.tcx.sess.opts.debugging_opts.unsound_mir_opts {\n-            return None;\n-        }\n-\n         // Look for the sequence\n         //\n         // _2 = &_1;\n@@ -137,6 +132,8 @@ impl OptimizationFinder<'b, 'tcx> {\n                 _ => None,\n             }?;\n \n+            let mut dead_locals_seen = vec![];\n+\n             let stmt_index = location.statement_index;\n             // Look behind for statement that assigns the local from a address of operator.\n             // 6 is chosen as a heuristic determined by seeing the number of times\n@@ -160,6 +157,11 @@ impl OptimizationFinder<'b, 'tcx> {\n                                 BorrowKind::Shared,\n                                 place_taken_address_of,\n                             ) => {\n+                                // Make sure that the place has not been marked dead\n+                                if dead_locals_seen.contains(&place_taken_address_of.local) {\n+                                    return None;\n+                                }\n+\n                                 self.optimizations\n                                     .unneeded_deref\n                                     .insert(location, *place_taken_address_of);\n@@ -178,13 +180,19 @@ impl OptimizationFinder<'b, 'tcx> {\n                     // Inline asm can do anything, so bail out of the optimization.\n                     rustc_middle::mir::StatementKind::LlvmInlineAsm(_) => return None,\n \n+                    // Remember `StorageDead`s, as the local being marked dead could be the\n+                    // place RHS we are looking for, in which case we need to abort to avoid UB\n+                    // using an uninitialized place\n+                    rustc_middle::mir::StatementKind::StorageDead(dead) => {\n+                        dead_locals_seen.push(*dead)\n+                    }\n+\n                     // Check that `local_being_deref` is not being used in a mutating way which can cause misoptimization.\n                     rustc_middle::mir::StatementKind::Assign(box (_, _))\n                     | rustc_middle::mir::StatementKind::Coverage(_)\n                     | rustc_middle::mir::StatementKind::Nop\n                     | rustc_middle::mir::StatementKind::FakeRead(_, _)\n                     | rustc_middle::mir::StatementKind::StorageLive(_)\n-                    | rustc_middle::mir::StatementKind::StorageDead(_)\n                     | rustc_middle::mir::StatementKind::Retag(_, _)\n                     | rustc_middle::mir::StatementKind::AscribeUserType(_, _)\n                     | rustc_middle::mir::StatementKind::SetDiscriminant { .. } => {"}, {"sha": "39e1256a578353840630c91e8fe9a18170785faa", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -1207,7 +1207,13 @@ impl<'a> Parser<'a> {\n             self.recover_await_prefix(await_sp)?\n         };\n         let sp = self.error_on_incorrect_await(lo, hi, &expr, is_question);\n-        let expr = self.mk_expr(lo.to(sp), ExprKind::Await(expr), attrs);\n+        let kind = match expr.kind {\n+            // Avoid knock-down errors as we don't know whether to interpret this as `foo().await?`\n+            // or `foo()?.await` (the very reason we went with postfix syntax \ud83d\ude05).\n+            ExprKind::Try(_) => ExprKind::Err,\n+            _ => ExprKind::Await(expr),\n+        };\n+        let expr = self.mk_expr(lo.to(sp), kind, attrs);\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n "}, {"sha": "fa837e04db35eaa4c42cb8351703ffb8d982f757", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -21,7 +21,7 @@ use rustc_middle::ty::{\n };\n use rustc_middle::ty::{TypeAndMut, TypeckResults};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use std::fmt;\n \n@@ -2114,10 +2114,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 if self.predicate_may_hold(&try_obligation) && impls_future {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         if snippet.ends_with('?') {\n-                            err.span_suggestion(\n-                                span,\n-                                \"consider using `.await` here\",\n-                                format!(\"{}.await?\", snippet.trim_end_matches('?')),\n+                            err.span_suggestion_verbose(\n+                                span.with_hi(span.hi() - BytePos(1)).shrink_to_hi(),\n+                                \"consider `await`ing on the `Future`\",\n+                                \".await\".to_string(),\n                                 Applicability::MaybeIncorrect,\n                             );\n                         }"}, {"sha": "e8eea65137ff7041757fabc4c66ccb5c0053f833", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -9,6 +9,7 @@ use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n+    StatementAsExpression,\n };\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -188,11 +189,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             } else {\n-                let (arm_span, semi_span) = if let hir::ExprKind::Block(blk, _) = &arm.body.kind {\n-                    self.find_block_span(blk, prior_arm_ty)\n-                } else {\n-                    (arm.body.span, None)\n-                };\n+                let (arm_span, semi_span) =\n+                    self.get_appropriate_arm_semicolon_removal_span(&arms, i, prior_arm_ty, arm_ty);\n                 let (span, code) = match i {\n                     // The reason for the first arm to fail is not that the match arms diverge,\n                     // but rather that there's a prior obligation that doesn't hold.\n@@ -242,6 +240,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         coercion.complete(self)\n     }\n \n+    fn get_appropriate_arm_semicolon_removal_span(\n+        &self,\n+        arms: &'tcx [hir::Arm<'tcx>],\n+        i: usize,\n+        prior_arm_ty: Option<Ty<'tcx>>,\n+        arm_ty: Ty<'tcx>,\n+    ) -> (Span, Option<(Span, StatementAsExpression)>) {\n+        let arm = &arms[i];\n+        let (arm_span, mut semi_span) = if let hir::ExprKind::Block(blk, _) = &arm.body.kind {\n+            self.find_block_span(blk, prior_arm_ty)\n+        } else {\n+            (arm.body.span, None)\n+        };\n+        if semi_span.is_none() && i > 0 {\n+            if let hir::ExprKind::Block(blk, _) = &arms[i - 1].body.kind {\n+                let (_, semi_span_prev) = self.find_block_span(blk, Some(arm_ty));\n+                semi_span = semi_span_prev;\n+            }\n+        }\n+        (arm_span, semi_span)\n+    }\n+\n     /// When the previously checked expression (the scrutinee) diverges,\n     /// warn the user about the match arms being unreachable.\n     fn warn_arms_when_scrutinee_diverges(\n@@ -514,7 +534,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         block: &'tcx hir::Block<'tcx>,\n         expected_ty: Option<Ty<'tcx>>,\n-    ) -> (Span, Option<Span>) {\n+    ) -> (Span, Option<(Span, StatementAsExpression)>) {\n         if let Some(expr) = &block.expr {\n             (expr.span, None)\n         } else if let Some(stmt) = block.stmts.last() {"}, {"sha": "241803fab1e68b7b8b994057b45fa3386bd6cae5", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -33,7 +33,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n         self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty);\n-        self.suggest_missing_await(err, expr, expected, expr_ty);\n         self.suggest_missing_parentheses(err, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);"}, {"sha": "f87e6b607d46e5d168dd1b709301e88ce0a62bbc", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 52, "deletions": 5, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -33,7 +33,9 @@ use rustc_span::{self, BytePos, MultiSpan, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n-use rustc_trait_selection::traits::{self, ObligationCauseCode, TraitEngine, TraitEngineExt};\n+use rustc_trait_selection::traits::{\n+    self, ObligationCauseCode, StatementAsExpression, TraitEngine, TraitEngineExt,\n+};\n \n use std::collections::hash_map::Entry;\n use std::slice;\n@@ -1061,7 +1063,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         blk: &'tcx hir::Block<'tcx>,\n         expected_ty: Ty<'tcx>,\n-    ) -> Option<Span> {\n+    ) -> Option<(Span, StatementAsExpression)> {\n         // Be helpful when the user wrote `{... expr;}` and\n         // taking the `;` off is enough to fix the error.\n         let last_stmt = blk.stmts.last()?;\n@@ -1070,13 +1072,58 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => return None,\n         };\n         let last_expr_ty = self.node_ty(last_expr.hir_id);\n-        if matches!(last_expr_ty.kind(), ty::Error(_))\n-            || self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err()\n+        let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n+            (ty::Opaque(last_def_id, last_bounds), ty::Opaque(exp_def_id, exp_bounds)) => {\n+                debug!(\n+                    \"both opaque, likely future {:?} {:?} {:?} {:?}\",\n+                    last_def_id, last_bounds, exp_def_id, exp_bounds\n+                );\n+                let last_hir_id = self.tcx.hir().local_def_id_to_hir_id(last_def_id.expect_local());\n+                let exp_hir_id = self.tcx.hir().local_def_id_to_hir_id(exp_def_id.expect_local());\n+                match (\n+                    &self.tcx.hir().expect_item(last_hir_id).kind,\n+                    &self.tcx.hir().expect_item(exp_hir_id).kind,\n+                ) {\n+                    (\n+                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: last_bounds, .. }),\n+                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: exp_bounds, .. }),\n+                    ) if last_bounds.iter().zip(exp_bounds.iter()).all(|(left, right)| {\n+                        match (left, right) {\n+                            (\n+                                hir::GenericBound::Trait(tl, ml),\n+                                hir::GenericBound::Trait(tr, mr),\n+                            ) if tl.trait_ref.trait_def_id() == tr.trait_ref.trait_def_id()\n+                                && ml == mr =>\n+                            {\n+                                true\n+                            }\n+                            (\n+                                hir::GenericBound::LangItemTrait(langl, _, _, argsl),\n+                                hir::GenericBound::LangItemTrait(langr, _, _, argsr),\n+                            ) if langl == langr => {\n+                                // FIXME: consider the bounds!\n+                                debug!(\"{:?} {:?}\", argsl, argsr);\n+                                true\n+                            }\n+                            _ => false,\n+                        }\n+                    }) =>\n+                    {\n+                        StatementAsExpression::NeedsBoxing\n+                    }\n+                    _ => StatementAsExpression::CorrectType,\n+                }\n+            }\n+            _ => StatementAsExpression::CorrectType,\n+        };\n+        if (matches!(last_expr_ty.kind(), ty::Error(_))\n+            || self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err())\n+            && matches!(needs_box, StatementAsExpression::CorrectType)\n         {\n             return None;\n         }\n         let original_span = original_sp(last_stmt.span, blk.span);\n-        Some(original_span.with_lo(original_span.hi() - BytePos(1)))\n+        Some((original_span.with_lo(original_span.hi() - BytePos(1)), needs_box))\n     }\n \n     // Instantiates the given path, which must refer to an item with the given"}, {"sha": "a820661d8432a0d17b0ac50d9c66ed0b5eda813f", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::ty::{self, Ty};\n use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{self, MultiSpan, Span};\n-use rustc_trait_selection::traits::{self, ObligationCauseCode};\n+use rustc_trait_selection::traits::{self, ObligationCauseCode, StatementAsExpression};\n \n use std::mem::replace;\n use std::slice;\n@@ -758,13 +758,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty: Ty<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {\n-        if let Some(span_semi) = self.could_remove_semicolon(blk, expected_ty) {\n-            err.span_suggestion(\n-                span_semi,\n-                \"consider removing this semicolon\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n-            );\n+        if let Some((span_semi, boxed)) = self.could_remove_semicolon(blk, expected_ty) {\n+            if let StatementAsExpression::NeedsBoxing = boxed {\n+                err.span_suggestion_verbose(\n+                    span_semi,\n+                    \"consider removing this semicolon and boxing the expression\",\n+                    String::new(),\n+                    Applicability::HasPlaceholders,\n+                );\n+            } else {\n+                err.span_suggestion_short(\n+                    span_semi,\n+                    \"consider removing this semicolon\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n         }\n     }\n "}, {"sha": "a8ad9f4fdf8af01ac6031e56ca57c1b7079a502a", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -3,7 +3,6 @@ use crate::astconv::AstConv;\n \n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_span::{self, Span};\n-use rustc_trait_selection::traits;\n \n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -13,7 +12,6 @@ use rustc_hir::{ExprKind, ItemKind, Node};\n use rustc_infer::infer;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::kw;\n-use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n use std::iter;\n \n@@ -433,87 +431,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// A possible error is to forget to add `.await` when using futures:\n-    ///\n-    /// ```\n-    /// async fn make_u32() -> u32 {\n-    ///     22\n-    /// }\n-    ///\n-    /// fn take_u32(x: u32) {}\n-    ///\n-    /// async fn foo() {\n-    ///     let x = make_u32();\n-    ///     take_u32(x);\n-    /// }\n-    /// ```\n-    ///\n-    /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n-    /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n-    /// `.await` to the tail of the expression.\n-    pub(in super::super) fn suggest_missing_await(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr<'_>,\n-        expected: Ty<'tcx>,\n-        found: Ty<'tcx>,\n-    ) {\n-        debug!(\"suggest_missing_await: expr={:?} expected={:?}, found={:?}\", expr, expected, found);\n-        // `.await` is not permitted outside of `async` bodies, so don't bother to suggest if the\n-        // body isn't `async`.\n-        let item_id = self.tcx().hir().get_parent_node(self.body_id);\n-        if let Some(body_id) = self.tcx().hir().maybe_body_owned_by(item_id) {\n-            let body = self.tcx().hir().body(body_id);\n-            if let Some(hir::GeneratorKind::Async(_)) = body.generator_kind {\n-                let sp = expr.span;\n-                // Check for `Future` implementations by constructing a predicate to\n-                // prove: `<T as Future>::Output == U`\n-                let future_trait = self.tcx.require_lang_item(LangItem::Future, Some(sp));\n-                let item_def_id = self\n-                    .tcx\n-                    .associated_items(future_trait)\n-                    .in_definition_order()\n-                    .next()\n-                    .unwrap()\n-                    .def_id;\n-                // `<T as Future>::Output`\n-                let projection_ty = ty::ProjectionTy {\n-                    // `T`\n-                    substs: self\n-                        .tcx\n-                        .mk_substs_trait(found, self.fresh_substs_for_item(sp, item_def_id)),\n-                    // `Future::Output`\n-                    item_def_id,\n-                };\n-\n-                let predicate = ty::PredicateAtom::Projection(ty::ProjectionPredicate {\n-                    projection_ty,\n-                    ty: expected,\n-                })\n-                .potentially_quantified(self.tcx, ty::PredicateKind::ForAll);\n-                let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n-\n-                debug!(\"suggest_missing_await: trying obligation {:?}\", obligation);\n-\n-                if self.infcx.predicate_may_hold(&obligation) {\n-                    debug!(\"suggest_missing_await: obligation held: {:?}\", obligation);\n-                    if let Ok(code) = self.sess().source_map().span_to_snippet(sp) {\n-                        err.span_suggestion(\n-                            sp,\n-                            \"consider using `.await` here\",\n-                            format!(\"{}.await\", code),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        debug!(\"suggest_missing_await: no snippet for {:?}\", sp);\n-                    }\n-                } else {\n-                    debug!(\"suggest_missing_await: obligation did not hold: {:?}\", obligation)\n-                }\n-            }\n-        }\n-    }\n-\n     pub(in super::super) fn suggest_missing_parentheses(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,"}, {"sha": "4b303acfd3bfb922cd5da041e97c600d620d1d46", "filename": "library/core/src/ffi.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/library%2Fcore%2Fsrc%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/library%2Fcore%2Fsrc%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -62,7 +62,7 @@ impl fmt::Debug for c_void {\n // The name is WIP, using `VaListImpl` for now.\n #[cfg(any(\n     all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n-    all(target_arch = \"aarch64\", target_os = \"ios\"),\n+    all(target_arch = \"aarch64\", any(target_os = \"macos\", target_os = \"ios\")),\n     target_arch = \"wasm32\",\n     target_arch = \"asmjs\",\n     windows\n@@ -85,7 +85,7 @@ pub struct VaListImpl<'f> {\n \n #[cfg(any(\n     all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n-    all(target_arch = \"aarch64\", target_os = \"ios\"),\n+    all(target_arch = \"aarch64\", any(target_os = \"macos\", target_os = \"ios\")),\n     target_arch = \"wasm32\",\n     target_arch = \"asmjs\",\n     windows\n@@ -107,7 +107,11 @@ impl<'f> fmt::Debug for VaListImpl<'f> {\n ///\n /// [AArch64 Procedure Call Standard]:\n /// http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf\n-#[cfg(all(target_arch = \"aarch64\", not(target_os = \"ios\"), not(windows)))]\n+#[cfg(all(\n+    target_arch = \"aarch64\",\n+    not(any(target_os = \"macos\", target_os = \"ios\")),\n+    not(windows)\n+))]\n #[repr(C)]\n #[derive(Debug)]\n #[unstable(\n@@ -181,7 +185,7 @@ pub struct VaList<'a, 'f: 'a> {\n             not(target_arch = \"powerpc\"),\n             not(target_arch = \"x86_64\")\n         ),\n-        all(target_arch = \"aarch64\", target_os = \"ios\"),\n+        all(target_arch = \"aarch64\", any(target_os = \"macos\", target_os = \"ios\")),\n         target_arch = \"wasm32\",\n         target_arch = \"asmjs\",\n         windows\n@@ -190,7 +194,7 @@ pub struct VaList<'a, 'f: 'a> {\n \n     #[cfg(all(\n         any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n-        any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n+        any(not(target_arch = \"aarch64\"), not(any(target_os = \"macos\", target_os = \"ios\"))),\n         not(target_arch = \"wasm32\"),\n         not(target_arch = \"asmjs\"),\n         not(windows)\n@@ -202,7 +206,7 @@ pub struct VaList<'a, 'f: 'a> {\n \n #[cfg(any(\n     all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n-    all(target_arch = \"aarch64\", target_os = \"ios\"),\n+    all(target_arch = \"aarch64\", any(target_os = \"macos\", target_os = \"ios\")),\n     target_arch = \"wasm32\",\n     target_arch = \"asmjs\",\n     windows\n@@ -223,7 +227,7 @@ impl<'f> VaListImpl<'f> {\n \n #[cfg(all(\n     any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n-    any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n+    any(not(target_arch = \"aarch64\"), not(any(target_os = \"macos\", target_os = \"ios\"))),\n     not(target_arch = \"wasm32\"),\n     not(target_arch = \"asmjs\"),\n     not(windows)"}, {"sha": "e84014c68a6760a9be112b9c5cbb5917e3b077fd", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -884,10 +884,10 @@ pub fn drop<T>(_x: T) {}\n /// Interprets `src` as having type `&U`, and then reads `src` without moving\n /// the contained value.\n ///\n-/// This function will unsafely assume the pointer `src` is valid for\n-/// [`size_of::<U>`][size_of] bytes by transmuting `&T` to `&U` and then reading\n-/// the `&U`. It will also unsafely create a copy of the contained value instead of\n-/// moving out of `src`.\n+/// This function will unsafely assume the pointer `src` is valid for [`size_of::<U>`][size_of]\n+/// bytes by transmuting `&T` to `&U` and then reading the `&U` (except that this is done in a way\n+/// that is correct even when `&U` makes stricter alignment requirements than `&T`). It will also\n+/// unsafely create a copy of the contained value instead of moving out of `src`.\n ///\n /// It is not a compile-time error if `T` and `U` have different sizes, but it\n /// is highly encouraged to only invoke this function where `T` and `U` have the"}, {"sha": "b61a7872265f350a8b82a3779bc2b8cc64dd2281", "filename": "library/std/src/sys/wasm/alloc.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Falloc.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -24,26 +24,34 @@ static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n unsafe impl GlobalAlloc for System {\n     #[inline]\n     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        // SAFETY: DLMALLOC access is guranteed to be safe because the lock gives us unique and non-reentrant access.\n+        // Calling malloc() is safe because preconditions on this function match the trait method preconditions.\n         let _lock = lock::lock();\n-        DLMALLOC.malloc(layout.size(), layout.align())\n+        unsafe { DLMALLOC.malloc(layout.size(), layout.align()) }\n     }\n \n     #[inline]\n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        // SAFETY: DLMALLOC access is guranteed to be safe because the lock gives us unique and non-reentrant access.\n+        // Calling calloc() is safe because preconditions on this function match the trait method preconditions.\n         let _lock = lock::lock();\n-        DLMALLOC.calloc(layout.size(), layout.align())\n+        unsafe { DLMALLOC.calloc(layout.size(), layout.align()) }\n     }\n \n     #[inline]\n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+        // SAFETY: DLMALLOC access is guranteed to be safe because the lock gives us unique and non-reentrant access.\n+        // Calling free() is safe because preconditions on this function match the trait method preconditions.\n         let _lock = lock::lock();\n-        DLMALLOC.free(ptr, layout.size(), layout.align())\n+        unsafe { DLMALLOC.free(ptr, layout.size(), layout.align()) }\n     }\n \n     #[inline]\n     unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        // SAFETY: DLMALLOC access is guranteed to be safe because the lock gives us unique and non-reentrant access.\n+        // Calling realloc() is safe because preconditions on this function match the trait method preconditions.\n         let _lock = lock::lock();\n-        DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n+        unsafe { DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size) }\n     }\n }\n "}, {"sha": "0c1c076cc914241baa16f13bce8a9e057500842d", "filename": "library/std/src/sys/wasm/condvar_atomics.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fcondvar_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fcondvar_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fcondvar_atomics.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -44,13 +44,19 @@ impl Condvar {\n \n     pub unsafe fn notify_one(&self) {\n         self.cnt.fetch_add(1, SeqCst);\n-        wasm32::memory_atomic_notify(self.ptr(), 1);\n+        // SAFETY: ptr() is always valid\n+        unsafe {\n+            wasm32::memory_atomic_notify(self.ptr(), 1);\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn notify_all(&self) {\n         self.cnt.fetch_add(1, SeqCst);\n-        wasm32::memory_atomic_notify(self.ptr(), u32::MAX); // -1 == \"wake everyone\"\n+        // SAFETY: ptr() is always valid\n+        unsafe {\n+            wasm32::memory_atomic_notify(self.ptr(), u32::MAX); // -1 == \"wake everyone\"\n+        }\n     }\n \n     pub unsafe fn wait(&self, mutex: &Mutex) {"}, {"sha": "82683c0f624cf88487ca777b748493eb5a4d4d4a", "filename": "library/std/src/sys/wasm/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -14,6 +14,8 @@\n //! compiling for wasm. That way it's a compile time error for something that's\n //! guaranteed to be a runtime error!\n \n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n pub mod alloc;\n pub mod args;\n #[path = \"../unsupported/cmath.rs\"]"}, {"sha": "479182ffa44d5eec624d026a1bc8f786cf5ba1b4", "filename": "library/std/src/sys/wasm/mutex_atomics.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -28,11 +28,14 @@ impl Mutex {\n \n     pub unsafe fn lock(&self) {\n         while !self.try_lock() {\n-            let val = wasm32::memory_atomic_wait32(\n-                self.ptr(),\n-                1,  // we expect our mutex is locked\n-                -1, // wait infinitely\n-            );\n+            // SAFETY: the caller must uphold the safety contract for `memory_atomic_wait32`.\n+            let val = unsafe {\n+                wasm32::memory_atomic_wait32(\n+                    self.ptr(),\n+                    1,  // we expect our mutex is locked\n+                    -1, // wait infinitely\n+                )\n+            };\n             // we should have either woke up (0) or got a not-equal due to a\n             // race (1). We should never time out (2)\n             debug_assert!(val == 0 || val == 1);\n@@ -93,19 +96,20 @@ impl ReentrantMutex {\n     pub unsafe fn lock(&self) {\n         let me = thread::my_id();\n         while let Err(owner) = self._try_lock(me) {\n-            let val = wasm32::memory_atomic_wait32(self.ptr(), owner as i32, -1);\n+            // SAFETY: the caller must gurantee that `self.ptr()` and `owner` are valid i32.\n+            let val = unsafe { wasm32::memory_atomic_wait32(self.ptr(), owner as i32, -1) };\n             debug_assert!(val == 0 || val == 1);\n         }\n     }\n \n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        self._try_lock(thread::my_id()).is_ok()\n+        unsafe { self._try_lock(thread::my_id()).is_ok() }\n     }\n \n     #[inline]\n     unsafe fn _try_lock(&self, id: u32) -> Result<(), u32> {\n-        let id = id.checked_add(1).unwrap(); // make sure `id` isn't 0\n+        let id = id.checked_add(1).unwrap();\n         match self.owner.compare_exchange(0, id, SeqCst, SeqCst) {\n             // we transitioned from unlocked to locked\n             Ok(_) => {\n@@ -132,7 +136,10 @@ impl ReentrantMutex {\n         match *self.recursions.get() {\n             0 => {\n                 self.owner.swap(0, SeqCst);\n-                wasm32::memory_atomic_notify(self.ptr() as *mut i32, 1); // wake up one waiter, if any\n+                // SAFETY: the caller must gurantee that `self.ptr()` is valid i32.\n+                unsafe {\n+                    wasm32::atomic_notify(self.ptr() as *mut i32, 1);\n+                } // wake up one waiter, if any\n             }\n             ref mut n => *n -= 1,\n         }"}, {"sha": "aa59c713b7846dabbb55cce82be977b148eb91f8", "filename": "src/test/codegen/issue-45964-bounds-check-slice-pos.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fcodegen%2Fissue-45964-bounds-check-slice-pos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fcodegen%2Fissue-45964-bounds-check-slice-pos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-45964-bounds-check-slice-pos.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -0,0 +1,38 @@\n+// This test case checks that slice::{r}position functions do not\n+// prevent optimizing away bounds checks\n+\n+// compile-flags: -O\n+\n+#![crate_type=\"rlib\"]\n+\n+// CHECK-LABEL: @test\n+#[no_mangle]\n+pub fn test(y: &[u32], x: &u32, z: &u32) -> bool {\n+    let result = match y.iter().position(|a| a == x) {\n+        Some(p) => Ok(p),\n+        None => Err(()),\n+    };\n+\n+    if let Ok(p) = result {\n+        // CHECK-NOT: panic\n+        y[p] == *z\n+    } else {\n+        false\n+    }\n+}\n+\n+// CHECK-LABEL: @rtest\n+#[no_mangle]\n+pub fn rtest(y: &[u32], x: &u32, z: &u32) -> bool {\n+    let result = match y.iter().rposition(|a| a == x) {\n+        Some(p) => Ok(p),\n+        None => Err(()),\n+    };\n+\n+    if let Ok(p) = result {\n+        // CHECK-NOT: panic\n+        y[p] == *z\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "feef65f52ebe0f6d830d04a437d75fa13a96c1f7", "filename": "src/test/mir-opt/const_prop/ref_deref.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref.main.ConstProp.diff?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -19,7 +19,7 @@\n                                            // + span: $DIR/ref_deref.rs:5:6: 5:10\n                                            // + literal: Const { ty: &i32, val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ ref_deref[317d]::main), const_param_did: None }, [], Some(promoted[0])) }\n           _2 = _4;                         // scope 0 at $DIR/ref_deref.rs:5:6: 5:10\n--         _1 = (*_2);                      // scope 0 at $DIR/ref_deref.rs:5:5: 5:10\n+-         _1 = (*_4);                      // scope 0 at $DIR/ref_deref.rs:5:5: 5:10\n +         _1 = const 4_i32;                // scope 0 at $DIR/ref_deref.rs:5:5: 5:10\n           StorageDead(_2);                 // scope 0 at $DIR/ref_deref.rs:5:10: 5:11\n           StorageDead(_1);                 // scope 0 at $DIR/ref_deref.rs:5:10: 5:11"}, {"sha": "7ec0751263fb13b8e8214b4029d1b4d4fad736aa", "filename": "src/test/mir-opt/const_prop/ref_deref_project.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.main.ConstProp.diff?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -19,7 +19,7 @@\n                                            // + span: $DIR/ref_deref_project.rs:5:6: 5:17\n                                            // + literal: Const { ty: &(i32, i32), val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ ref_deref_project[317d]::main), const_param_did: None }, [], Some(promoted[0])) }\n           _2 = &((*_4).1: i32);            // scope 0 at $DIR/ref_deref_project.rs:5:6: 5:17\n-          _1 = (*_2);                      // scope 0 at $DIR/ref_deref_project.rs:5:5: 5:17\n+          _1 = ((*_4).1: i32);             // scope 0 at $DIR/ref_deref_project.rs:5:5: 5:17\n           StorageDead(_2);                 // scope 0 at $DIR/ref_deref_project.rs:5:17: 5:18\n           StorageDead(_1);                 // scope 0 at $DIR/ref_deref_project.rs:5:17: 5:18\n           _0 = const ();                   // scope 0 at $DIR/ref_deref_project.rs:4:11: 6:2"}, {"sha": "3be8c2f3ac732c8d9e71c2ef83cfcb1091bd21b9", "filename": "src/test/mir-opt/inst_combine_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fmir-opt%2Finst_combine_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fmir-opt%2Finst_combine_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finst_combine_deref.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -O -Zunsound-mir-opts\n+// compile-flags: -O\n // EMIT_MIR inst_combine_deref.simple_opt.InstCombine.diff\n fn simple_opt() -> u64 {\n     let x = 5;"}, {"sha": "906d094f72b4a1b45b838babfc42698c8a3e67de", "filename": "src/test/mir-opt/issue-78192.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fmir-opt%2Fissue-78192.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fmir-opt%2Fissue-78192.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-78192.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -0,0 +1,9 @@\n+// EMIT_MIR issue_78192.f.InstCombine.diff\n+pub fn f<T>(a: &T) -> *const T {\n+    let b: &*const T = &(a as *const T);\n+    *b\n+}\n+\n+fn main() {\n+    f(&2);\n+}"}, {"sha": "ec3be78525802eea27f0fec6a03e4068e67629a0", "filename": "src/test/mir-opt/issue_78192.f.InstCombine.diff", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fmir-opt%2Fissue_78192.f.InstCombine.diff", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fmir-opt%2Fissue_78192.f.InstCombine.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_78192.f.InstCombine.diff?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -0,0 +1,29 @@\n+- // MIR for `f` before InstCombine\n++ // MIR for `f` after InstCombine\n+  \n+  fn f(_1: &T) -> *const T {\n+      debug a => _1;                       // in scope 0 at $DIR/issue-78192.rs:2:13: 2:14\n+      let mut _0: *const T;                // return place in scope 0 at $DIR/issue-78192.rs:2:23: 2:31\n+      let _2: &*const T;                   // in scope 0 at $DIR/issue-78192.rs:3:9: 3:10\n+      let _3: &*const T;                   // in scope 0 at $DIR/issue-78192.rs:3:24: 3:40\n+      let _4: *const T;                    // in scope 0 at $DIR/issue-78192.rs:3:25: 3:40\n+      scope 1 {\n+          debug b => _2;                   // in scope 1 at $DIR/issue-78192.rs:3:9: 3:10\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/issue-78192.rs:3:9: 3:10\n+          StorageLive(_3);                 // scope 0 at $DIR/issue-78192.rs:3:24: 3:40\n+          StorageLive(_4);                 // scope 0 at $DIR/issue-78192.rs:3:25: 3:40\n+          _4 = &raw const (*_1);           // scope 0 at $DIR/issue-78192.rs:3:26: 3:27\n+          _3 = &_4;                        // scope 0 at $DIR/issue-78192.rs:3:24: 3:40\n+-         _2 = &(*_3);                     // scope 0 at $DIR/issue-78192.rs:3:24: 3:40\n++         _2 = _3;                         // scope 0 at $DIR/issue-78192.rs:3:24: 3:40\n+          StorageDead(_3);                 // scope 0 at $DIR/issue-78192.rs:3:40: 3:41\n+          _0 = (*_2);                      // scope 1 at $DIR/issue-78192.rs:4:5: 4:7\n+          StorageDead(_4);                 // scope 0 at $DIR/issue-78192.rs:5:1: 5:2\n+          StorageDead(_2);                 // scope 0 at $DIR/issue-78192.rs:5:1: 5:2\n+          return;                          // scope 0 at $DIR/issue-78192.rs:5:2: 5:2\n+      }\n+  }\n+  "}, {"sha": "554ac673d515599a4a230ed1f04110d806116a4d", "filename": "src/test/ui/async-await/await-keyword/incorrect-syntax-suggestions.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -14,7 +14,6 @@ async fn foo2() -> Result<(), ()> {\n }\n async fn foo3() -> Result<(), ()> {\n     let _ = await bar()?; //~ ERROR incorrect use of `await`\n-    //~^ ERROR the `?` operator can only be applied to values that implement `Try`\n     Ok(())\n }\n async fn foo21() -> Result<(), ()> {\n@@ -60,9 +59,7 @@ fn foo10() -> Result<(), ()> {\n     Ok(())\n }\n fn foo11() -> Result<(), ()> {\n-    let _ = await bar()?; //~ ERROR `await` is only allowed inside `async` functions and blocks\n-    //~^ ERROR incorrect use of `await`\n-    //~| ERROR the `?` operator can only be applied to values that implement `Try`\n+    let _ = await bar()?; //~ ERROR incorrect use of `await`\n     Ok(())\n }\n fn foo12() -> Result<(), ()> {"}, {"sha": "52615df6008ffbcdbc75d7f0152d52536aa5e036", "filename": "src/test/ui/async-await/await-keyword/incorrect-syntax-suggestions.stderr", "status": "modified", "additions": 32, "deletions": 62, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -17,117 +17,117 @@ LL |     let _ = await bar()?;\n    |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar()?.await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:21:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:20:13\n    |\n LL |     let _ = await { bar() };\n    |             ^^^^^^^^^^^^^^^ help: `await` is a postfix operation: `{ bar() }.await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:25:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:24:13\n    |\n LL |     let _ = await(bar());\n    |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `(bar()).await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:29:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:28:13\n    |\n LL |     let _ = await { bar() }?;\n    |             ^^^^^^^^^^^^^^^ help: `await` is a postfix operation: `{ bar() }.await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:33:14\n+  --> $DIR/incorrect-syntax-suggestions.rs:32:14\n    |\n LL |     let _ = (await bar())?;\n    |              ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:37:24\n+  --> $DIR/incorrect-syntax-suggestions.rs:36:24\n    |\n LL |     let _ = bar().await();\n    |                        ^^ help: `await` is not a method call, remove the parentheses\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:41:24\n+  --> $DIR/incorrect-syntax-suggestions.rs:40:24\n    |\n LL |     let _ = bar().await()?;\n    |                        ^^ help: `await` is not a method call, remove the parentheses\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:53:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:52:13\n    |\n LL |     let _ = await bar();\n    |             ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:58:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:57:13\n    |\n LL |     let _ = await? bar();\n    |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await?`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:63:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:62:13\n    |\n LL |     let _ = await bar()?;\n    |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar()?.await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:69:14\n+  --> $DIR/incorrect-syntax-suggestions.rs:66:14\n    |\n LL |     let _ = (await bar())?;\n    |              ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:74:24\n+  --> $DIR/incorrect-syntax-suggestions.rs:71:24\n    |\n LL |     let _ = bar().await();\n    |                        ^^ help: `await` is not a method call, remove the parentheses\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:79:24\n+  --> $DIR/incorrect-syntax-suggestions.rs:76:24\n    |\n LL |     let _ = bar().await()?;\n    |                        ^^ help: `await` is not a method call, remove the parentheses\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:107:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:104:13\n    |\n LL |     let _ = await!(bar());\n    |             ^^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:111:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:108:13\n    |\n LL |     let _ = await!(bar())?;\n    |             ^^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:116:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:113:17\n    |\n LL |         let _ = await!(bar())?;\n    |                 ^^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:124:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:121:17\n    |\n LL |         let _ = await!(bar())?;\n    |                 ^^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n \n error: expected expression, found `=>`\n-  --> $DIR/incorrect-syntax-suggestions.rs:132:25\n+  --> $DIR/incorrect-syntax-suggestions.rs:129:25\n    |\n LL |     match await { await => () }\n    |                   ----- ^^ expected expression\n    |                   |\n    |                   while parsing this incorrect await expression\n \n error: incorrect use of `await`\n-  --> $DIR/incorrect-syntax-suggestions.rs:132:11\n+  --> $DIR/incorrect-syntax-suggestions.rs:129:11\n    |\n LL |     match await { await => () }\n    |           ^^^^^^^^^^^^^^^^^^^^^ help: `await` is a postfix operation: `{ await => () }.await`\n \n error: expected one of `.`, `?`, `{`, or an operator, found `}`\n-  --> $DIR/incorrect-syntax-suggestions.rs:135:1\n+  --> $DIR/incorrect-syntax-suggestions.rs:132:1\n    |\n LL |     match await { await => () }\n    |     -----                      - expected one of `.`, `?`, `{`, or an operator\n@@ -138,123 +138,93 @@ LL | }\n    | ^ unexpected token\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:53:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:52:13\n    |\n LL | fn foo9() -> Result<(), ()> {\n    |    ---- this is not `async`\n LL |     let _ = await bar();\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:58:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:57:13\n    |\n LL | fn foo10() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = await? bar();\n    |             ^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:63:13\n-   |\n-LL | fn foo11() -> Result<(), ()> {\n-   |    ----- this is not `async`\n-LL |     let _ = await bar()?;\n-   |             ^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n-\n-error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:69:14\n+  --> $DIR/incorrect-syntax-suggestions.rs:66:14\n    |\n LL | fn foo12() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = (await bar())?;\n    |              ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:74:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:71:13\n    |\n LL | fn foo13() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = bar().await();\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:79:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:76:13\n    |\n LL | fn foo14() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = bar().await()?;\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:84:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:81:13\n    |\n LL | fn foo15() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = bar().await;\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:88:13\n+  --> $DIR/incorrect-syntax-suggestions.rs:85:13\n    |\n LL | fn foo16() -> Result<(), ()> {\n    |    ----- this is not `async`\n LL |     let _ = bar().await?;\n    |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:93:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:90:17\n    |\n LL |     fn foo() -> Result<(), ()> {\n    |        --- this is not `async`\n LL |         let _ = bar().await?;\n    |                 ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:100:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:97:17\n    |\n LL |     let foo = || {\n    |               -- this is not `async`\n LL |         let _ = bar().await?;\n    |                 ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:116:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:113:17\n    |\n LL |     fn foo() -> Result<(), ()> {\n    |        --- this is not `async`\n LL |         let _ = await!(bar())?;\n    |                 ^^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error[E0728]: `await` is only allowed inside `async` functions and blocks\n-  --> $DIR/incorrect-syntax-suggestions.rs:124:17\n+  --> $DIR/incorrect-syntax-suggestions.rs:121:17\n    |\n LL |     let foo = || {\n    |               -- this is not `async`\n LL |         let _ = await!(bar())?;\n    |                 ^^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n-error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/incorrect-syntax-suggestions.rs:16:19\n-   |\n-LL |     let _ = await bar()?;\n-   |                   ^^^^^^\n-   |                   |\n-   |                   the `?` operator cannot be applied to type `impl Future`\n-   |                   help: consider using `.await` here: `bar().await?`\n-   |\n-   = help: the trait `Try` is not implemented for `impl Future`\n-   = note: required by `into_result`\n-\n-error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/incorrect-syntax-suggestions.rs:63:19\n-   |\n-LL |     let _ = await bar()?;\n-   |                   ^^^^^^ the `?` operator cannot be applied to type `impl Future`\n-   |\n-   = help: the trait `Try` is not implemented for `impl Future`\n-   = note: required by `into_result`\n-\n-error: aborting due to 36 previous errors\n+error: aborting due to 33 previous errors\n \n-Some errors have detailed explanations: E0277, E0728.\n-For more information about an error, try `rustc --explain E0277`.\n+For more information about this error, try `rustc --explain E0728`."}, {"sha": "14e72c2b1e7e2a757a514dc33db3aaaffb7a618c", "filename": "src/test/ui/async-await/dont-suggest-missing-await.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -9,6 +9,10 @@ LL |         take_u32(x)\n    |\n    = note:     expected type `u32`\n            found opaque type `impl Future`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |         take_u32(x.await)\n+   |                   ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "df54ac88acee1e427a388ee09ee974438a7b37ae", "filename": "src/test/ui/async-await/issue-61076.stderr", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -2,25 +2,27 @@ error[E0277]: the `?` operator can only be applied to values that implement `Try\n   --> $DIR/issue-61076.rs:42:5\n    |\n LL |     foo()?;\n-   |     ^^^^^^\n-   |     |\n-   |     the `?` operator cannot be applied to type `impl Future`\n-   |     help: consider using `.await` here: `foo().await?`\n+   |     ^^^^^^ the `?` operator cannot be applied to type `impl Future`\n    |\n    = help: the trait `Try` is not implemented for `impl Future`\n    = note: required by `into_result`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |     foo().await?;\n+   |          ^^^^^^\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n   --> $DIR/issue-61076.rs:56:5\n    |\n LL |     t?;\n-   |     ^^\n-   |     |\n-   |     the `?` operator cannot be applied to type `T`\n-   |     help: consider using `.await` here: `t.await?`\n+   |     ^^ the `?` operator cannot be applied to type `T`\n    |\n    = help: the trait `Try` is not implemented for `T`\n    = note: required by `into_result`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |     t.await?;\n+   |      ^^^^^^\n \n error[E0609]: no field `0` on type `impl Future`\n   --> $DIR/issue-61076.rs:58:26\n@@ -51,6 +53,10 @@ LL |         Tuple(_) => {}\n    |\n    = note: expected opaque type `impl Future`\n                    found struct `Tuple`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |     match tuple().await {\n+   |                  ^^^^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "febcd0218426199e16831bc29e3c711437d0b18a", "filename": "src/test/ui/async-await/suggest-missing-await-closure.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.fixed?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -15,8 +15,8 @@ async fn suggest_await_in_async_closure() {\n         let x = make_u32();\n         take_u32(x.await)\n         //~^ ERROR mismatched types [E0308]\n-        //~| HELP consider using `.await` here\n-        //~| SUGGESTION x.await\n+        //~| HELP consider `await`ing on the `Future`\n+        //~| SUGGESTION .await\n     };\n }\n "}, {"sha": "faabf6ee3f16f1c06e19747d209d45df389254b1", "filename": "src/test/ui/async-await/suggest-missing-await-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -15,8 +15,8 @@ async fn suggest_await_in_async_closure() {\n         let x = make_u32();\n         take_u32(x)\n         //~^ ERROR mismatched types [E0308]\n-        //~| HELP consider using `.await` here\n-        //~| SUGGESTION x.await\n+        //~| HELP consider `await`ing on the `Future`\n+        //~| SUGGESTION .await\n     };\n }\n "}, {"sha": "2151057aa7fc0a8c70f908e9ba3d4b8622db0f12", "filename": "src/test/ui/async-await/suggest-missing-await-closure.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -5,13 +5,14 @@ LL | async fn make_u32() -> u32 {\n    |                        --- the `Output` of this `async fn`'s found opaque type\n ...\n LL |         take_u32(x)\n-   |                  ^\n-   |                  |\n-   |                  expected `u32`, found opaque type\n-   |                  help: consider using `.await` here: `x.await`\n+   |                  ^ expected `u32`, found opaque type\n    |\n    = note:     expected type `u32`\n            found opaque type `impl Future`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |         take_u32(x.await)\n+   |                   ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "1ec59d906206eada93ce9282dfd81e12afef9517", "filename": "src/test/ui/async-await/suggest-missing-await.fixed", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/16e9ed0b1c58e0327eb37eb6f70e9b9ef1844591/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/16e9ed0b1c58e0327eb37eb6f70e9b9ef1844591/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed?ref=16e9ed0b1c58e0327eb37eb6f70e9b9ef1844591", "patch": "@@ -1,30 +0,0 @@\n-// edition:2018\n-// run-rustfix\n-\n-fn take_u32(_x: u32) {}\n-\n-async fn make_u32() -> u32 {\n-    22\n-}\n-\n-#[allow(unused)]\n-async fn suggest_await_in_async_fn() {\n-    let x = make_u32();\n-    take_u32(x.await)\n-    //~^ ERROR mismatched types [E0308]\n-    //~| HELP consider using `.await` here\n-    //~| SUGGESTION x.await\n-}\n-\n-async fn dummy() {}\n-\n-#[allow(unused)]\n-async fn suggest_await_in_async_fn_return() {\n-    dummy().await;\n-    //~^ ERROR mismatched types [E0308]\n-    //~| HELP try adding a semicolon\n-    //~| HELP consider using `.await` here\n-    //~| SUGGESTION dummy().await\n-}\n-\n-fn main() {}"}, {"sha": "d629054911dac16e7326d3c307c48da7c9fa9bfb", "filename": "src/test/ui/async-await/suggest-missing-await.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -1,5 +1,4 @@\n // edition:2018\n-// run-rustfix\n \n fn take_u32(_x: u32) {}\n \n@@ -12,8 +11,8 @@ async fn suggest_await_in_async_fn() {\n     let x = make_u32();\n     take_u32(x)\n     //~^ ERROR mismatched types [E0308]\n-    //~| HELP consider using `.await` here\n-    //~| SUGGESTION x.await\n+    //~| HELP consider `await`ing on the `Future`\n+    //~| SUGGESTION .await\n }\n \n async fn dummy() {}\n@@ -23,8 +22,8 @@ async fn suggest_await_in_async_fn_return() {\n     dummy()\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP try adding a semicolon\n-    //~| HELP consider using `.await` here\n-    //~| SUGGESTION dummy().await\n+    //~| HELP consider `await`ing on the `Future`\n+    //~| SUGGESTION .await\n }\n \n fn main() {}"}, {"sha": "46615dae7e2ba3b43c48505fac9baa0e10446ddb", "filename": "src/test/ui/async-await/suggest-missing-await.stderr", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -1,20 +1,21 @@\n error[E0308]: mismatched types\n-  --> $DIR/suggest-missing-await.rs:13:14\n+  --> $DIR/suggest-missing-await.rs:12:14\n    |\n LL | async fn make_u32() -> u32 {\n    |                        --- the `Output` of this `async fn`'s found opaque type\n ...\n LL |     take_u32(x)\n-   |              ^\n-   |              |\n-   |              expected `u32`, found opaque type\n-   |              help: consider using `.await` here: `x.await`\n+   |              ^ expected `u32`, found opaque type\n    |\n    = note:     expected type `u32`\n            found opaque type `impl Future`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |     take_u32(x.await)\n+   |               ^^^^^^\n \n error[E0308]: mismatched types\n-  --> $DIR/suggest-missing-await.rs:23:5\n+  --> $DIR/suggest-missing-await.rs:22:5\n    |\n LL | async fn dummy() {}\n    |                  - the `Output` of this `async fn`'s found opaque type\n@@ -24,14 +25,14 @@ LL |     dummy()\n    |\n    = note: expected unit type `()`\n             found opaque type `impl Future`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |     dummy().await\n+   |            ^^^^^^\n help: try adding a semicolon\n    |\n LL |     dummy();\n    |            ^\n-help: consider using `.await` here\n-   |\n-LL |     dummy().await\n-   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9e5897b98925aa3b0d63d72de0224f50096fa573", "filename": "src/test/ui/issues/issue-56229.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fissues%2Fissue-56229.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fissues%2Fissue-56229.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56229.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -0,0 +1,35 @@\n+// check-pass\n+\n+trait Mirror {\n+    type Other;\n+}\n+\n+#[derive(Debug)]\n+struct Even(usize);\n+struct Odd;\n+\n+impl Mirror for Even {\n+    type Other = Odd;\n+}\n+\n+impl Mirror for Odd {\n+    type Other = Even;\n+}\n+\n+trait Dyn<T: Mirror>: AsRef<<T as Mirror>::Other> {}\n+\n+impl Dyn<Odd> for Even {}\n+\n+impl AsRef<Even> for Even {\n+    fn as_ref(&self) -> &Even {\n+        self\n+    }\n+}\n+\n+fn code<T: Mirror>(d: &dyn Dyn<T>) -> &T::Other {\n+    d.as_ref()\n+}\n+\n+fn main() {\n+    println!(\"{:?}\", code(&Even(22)));\n+}"}, {"sha": "06b8eb777c035198993ad7573cbf24b6f7ee7ddc", "filename": "src/test/ui/issues/issue-59494.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fissues%2Fissue-59494.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fissues%2Fissue-59494.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59494.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -0,0 +1,23 @@\n+fn t7p<A, B, C>(f: impl Fn(B) -> C, g: impl Fn(A) -> B) -> impl Fn(A) -> C {\n+    move |a: A| -> C { f(g(a)) }\n+}\n+\n+fn t8n<A, B, C>(f: impl Fn(A) -> B, g: impl Fn(A) -> C) -> impl Fn(A) -> (B, C)\n+where\n+    A: Copy,\n+{\n+    move |a: A| -> (B, C) {\n+        let b = a;\n+        let fa = f(a);\n+        let ga = g(b);\n+        (fa, ga)\n+    }\n+}\n+\n+fn main() {\n+    let f = |(_, _)| {};\n+    let g = |(a, _)| a;\n+    let t7 = |env| |a| |b| t7p(f, g)(((env, a), b));\n+    let t8 = t8n(t7, t7p(f, g));\n+    //~^ ERROR: expected a `Fn<(_,)>` closure, found `impl Fn<(((_, _), _),)>\n+}"}, {"sha": "e2ac5d94da1088b7c9464704a2d9a07db0cd6ba8", "filename": "src/test/ui/issues/issue-59494.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fissues%2Fissue-59494.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fissues%2Fissue-59494.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59494.stderr?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: expected a `Fn<(_,)>` closure, found `impl Fn<(((_, _), _),)>`\n+  --> $DIR/issue-59494.rs:21:22\n+   |\n+LL | fn t8n<A, B, C>(f: impl Fn(A) -> B, g: impl Fn(A) -> C) -> impl Fn(A) -> (B, C)\n+   |                                             ---------- required by this bound in `t8n`\n+...\n+LL |     let t8 = t8n(t7, t7p(f, g));\n+   |                      ^^^^^^^^^ expected an `Fn<(_,)>` closure, found `impl Fn<(((_, _), _),)>`\n+   |\n+   = help: the trait `Fn<(_,)>` is not implemented for `impl Fn<(((_, _), _),)>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "8930c15f57edcacf9d38c1a2f28f1d99d3a20814", "filename": "src/test/ui/issues/issue-70746.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fissues%2Fissue-70746.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fissues%2Fissue-70746.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-70746.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -0,0 +1,29 @@\n+// check-pass\n+\n+pub trait Trait1 {\n+    type C;\n+}\n+\n+struct T1;\n+impl Trait1 for T1 {\n+    type C = usize;\n+}\n+pub trait Callback<T: Trait1>: FnMut(<T as Trait1>::C) {}\n+impl<T: Trait1, F: FnMut(<T as Trait1>::C)> Callback<T> for F {}\n+\n+pub struct State<T: Trait1> {\n+    callback: Option<Box<dyn Callback<T>>>,\n+}\n+impl<T: Trait1> State<T> {\n+    fn new() -> Self {\n+        Self { callback: None }\n+    }\n+    fn test_cb(&mut self, d: <T as Trait1>::C) {\n+        (self.callback.as_mut().unwrap())(d)\n+    }\n+}\n+\n+fn main() {\n+    let mut s = State::<T1>::new();\n+    s.test_cb(1);\n+}"}, {"sha": "35346199add927b76d35cd2087e245942db0d7ba", "filename": "src/test/ui/issues/issue-73229.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fissues%2Fissue-73229.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fissues%2Fissue-73229.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-73229.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -0,0 +1,33 @@\n+// check-pass\n+\n+fn any<T>() -> T {\n+    loop {}\n+}\n+\n+trait Foo {\n+    type V;\n+}\n+\n+trait Callback<T: Foo>: Fn(&T, &T::V) {}\n+impl<T: Foo, F: Fn(&T, &T::V)> Callback<T> for F {}\n+\n+struct Bar<T: Foo> {\n+    callback: Box<dyn Callback<T>>,\n+}\n+\n+impl<T: Foo> Bar<T> {\n+    fn event(&self) {\n+        (self.callback)(any(), any());\n+    }\n+}\n+\n+struct A;\n+struct B;\n+impl Foo for A {\n+    type V = B;\n+}\n+\n+fn main() {\n+    let foo = Bar::<A> { callback: Box::new(|_: &A, _: &B| ()) };\n+    foo.event();\n+}"}, {"sha": "e97b8eca94892bf1d959640251616f5ee2834f9d", "filename": "src/test/ui/regions/issue-78262.default.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fregions%2Fissue-78262.default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fregions%2Fissue-78262.default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fissue-78262.default.stderr?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -0,0 +1,18 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-78262.rs:12:28\n+   |\n+LL |     let f = |x: &dyn TT| x.func();\n+   |                            ^^^^ lifetime mismatch\n+   |\n+   = note: expected reference `&(dyn TT + 'static)`\n+              found reference `&dyn TT`\n+note: the anonymous lifetime #1 defined on the body at 12:13...\n+  --> $DIR/issue-78262.rs:12:13\n+   |\n+LL |     let f = |x: &dyn TT| x.func();\n+   |             ^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "4607dbad4220b7eff50bb8523e05ea0ae3e34c12", "filename": "src/test/ui/regions/issue-78262.nll.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fregions%2Fissue-78262.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fregions%2Fissue-78262.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fissue-78262.nll.stderr?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -0,0 +1,10 @@\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/issue-78262.rs:12:26\n+   |\n+LL |     let f = |x: &dyn TT| x.func();\n+   |              -           ^^^^^^^^ `x` escapes the closure body here\n+   |              |\n+   |              `x` is a reference that is only valid in the closure body\n+\n+error: aborting due to previous error\n+"}, {"sha": "0bdb0abac307dddff2db21dd530a91dd33f2de2a", "filename": "src/test/ui/regions/issue-78262.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fregions%2Fissue-78262.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fregions%2Fissue-78262.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fissue-78262.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -0,0 +1,14 @@\n+// revisions: nll default\n+// ignore-compare-mode-nll\n+//[nll]compile-flags: -Z borrowck=mir\n+\n+trait TT {}\n+\n+impl dyn TT {\n+    fn func(&self) {}\n+}\n+\n+fn main() {\n+    let f = |x: &dyn TT| x.func(); //[default]~ ERROR: mismatched types\n+    //[nll]~^ ERROR: borrowed data escapes outside of closure\n+}"}, {"sha": "5c9c549fa0779ca0c7d78350938e907b3309f6ca", "filename": "src/test/ui/suggestions/issue-72766.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fsuggestions%2Fissue-72766.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fsuggestions%2Fissue-72766.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-72766.stderr?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -2,13 +2,14 @@ error[E0277]: the `?` operator can only be applied to values that implement `Try\n   --> $DIR/issue-72766.rs:14:5\n    |\n LL |     SadGirl {}.call()?;\n-   |     ^^^^^^^^^^^^^^^^^^\n-   |     |\n-   |     the `?` operator cannot be applied to type `impl Future`\n-   |     help: consider using `.await` here: `SadGirl {}.call().await?`\n+   |     ^^^^^^^^^^^^^^^^^^ the `?` operator cannot be applied to type `impl Future`\n    |\n    = help: the trait `Try` is not implemented for `impl Future`\n    = note: required by `into_result`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |     SadGirl {}.call().await?;\n+   |                      ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b8ac030b0bbbee86be6414265964c513aceb46c3", "filename": "src/test/ui/suggestions/match-prev-arm-needing-semi.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -0,0 +1,57 @@\n+// edition:2018\n+\n+fn dummy() -> i32 { 42 }\n+\n+fn extra_semicolon() {\n+    let _ = match true { //~ NOTE `match` arms have incompatible types\n+        true => {\n+            dummy(); //~ NOTE this is found to be\n+            //~^ HELP consider removing this semicolon\n+        }\n+        false => dummy(), //~ ERROR `match` arms have incompatible types\n+        //~^ NOTE expected `()`, found `i32`\n+    };\n+}\n+\n+async fn async_dummy() {} //~ NOTE the `Output` of this `async fn`'s found opaque type\n+async fn async_dummy2() {} //~ NOTE the `Output` of this `async fn`'s found opaque type\n+//~^ NOTE the `Output` of this `async fn`'s found opaque type\n+\n+async fn async_extra_semicolon_same() {\n+    let _ = match true { //~ NOTE `match` arms have incompatible types\n+        true => {\n+            async_dummy(); //~ NOTE this is found to be\n+            //~^ HELP consider removing this semicolon\n+        }\n+        false => async_dummy(), //~ ERROR `match` arms have incompatible types\n+        //~^ NOTE expected `()`, found opaque type\n+        //~| NOTE expected type `()`\n+        //~| HELP consider `await`ing on the `Future`\n+    };\n+}\n+\n+async fn async_extra_semicolon_different() {\n+    let _ = match true { //~ NOTE `match` arms have incompatible types\n+        true => {\n+            async_dummy(); //~ NOTE this is found to be\n+            //~^ HELP consider removing this semicolon\n+        }\n+        false => async_dummy2(), //~ ERROR `match` arms have incompatible types\n+        //~^ NOTE expected `()`, found opaque type\n+        //~| NOTE expected type `()`\n+        //~| HELP consider `await`ing on the `Future`\n+    };\n+}\n+\n+async fn async_different_futures() {\n+    let _ = match true { //~ NOTE `match` arms have incompatible types\n+        true => async_dummy(), //~ NOTE this is found to be\n+        //~| HELP consider `await`ing on both `Future`s\n+        false => async_dummy2(), //~ ERROR `match` arms have incompatible types\n+        //~^ NOTE expected opaque type, found a different opaque type\n+        //~| NOTE expected type `impl Future`\n+        //~| NOTE distinct uses of `impl Trait` result in different opaque types\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "e9803a78f94b3c3571813648083bc03542b7d64e", "filename": "src/test/ui/suggestions/match-prev-arm-needing-semi.stderr", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -0,0 +1,118 @@\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/match-prev-arm-needing-semi.rs:26:18\n+   |\n+LL |   async fn async_dummy() {}\n+   |                          - the `Output` of this `async fn`'s found opaque type\n+...\n+LL |       let _ = match true {\n+   |  _____________-\n+LL | |         true => {\n+LL | |             async_dummy();\n+   | |             -------------- this is found to be of type `()`\n+LL | |\n+LL | |         }\n+LL | |         false => async_dummy(),\n+   | |                  ^^^^^^^^^^^^^ expected `()`, found opaque type\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note:     expected type `()`\n+           found opaque type `impl Future`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |         false => async_dummy().await,\n+   |                               ^^^^^^\n+help: consider removing this semicolon and boxing the expressions\n+   |\n+LL |             Box::new(async_dummy())\n+LL |\n+LL |         }\n+LL |         false => Box::new(async_dummy()),\n+   |\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/match-prev-arm-needing-semi.rs:39:18\n+   |\n+LL |   async fn async_dummy2() {}\n+   |                           - the `Output` of this `async fn`'s found opaque type\n+...\n+LL |       let _ = match true {\n+   |  _____________-\n+LL | |         true => {\n+LL | |             async_dummy();\n+   | |             -------------- this is found to be of type `()`\n+LL | |\n+LL | |         }\n+LL | |         false => async_dummy2(),\n+   | |                  ^^^^^^^^^^^^^^ expected `()`, found opaque type\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note:     expected type `()`\n+           found opaque type `impl Future`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |         false => async_dummy2().await,\n+   |                                ^^^^^^\n+help: consider removing this semicolon and boxing the expressions\n+   |\n+LL |             Box::new(async_dummy())\n+LL |\n+LL |         }\n+LL |         false => Box::new(async_dummy2()),\n+   |\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/match-prev-arm-needing-semi.rs:50:18\n+   |\n+LL |   async fn async_dummy2() {}\n+   |                           - the `Output` of this `async fn`'s found opaque type\n+...\n+LL |       let _ = match true {\n+   |  _____________-\n+LL | |         true => async_dummy(),\n+   | |                 ------------- this is found to be of type `impl Future`\n+LL | |\n+LL | |         false => async_dummy2(),\n+   | |                  ^^^^^^^^^^^^^^ expected opaque type, found a different opaque type\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note:     expected type `impl Future` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:16:24>)\n+           found opaque type `impl Future` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:17:25>)\n+   = note: distinct uses of `impl Trait` result in different opaque types\n+help: consider `await`ing on both `Future`s\n+   |\n+LL |         true => async_dummy().await,\n+LL |\n+LL |         false => async_dummy2().await,\n+   |\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/match-prev-arm-needing-semi.rs:11:18\n+   |\n+LL |       let _ = match true {\n+   |  _____________-\n+LL | |         true => {\n+LL | |             dummy();\n+   | |             --------\n+   | |             |      |\n+   | |             |      help: consider removing this semicolon\n+   | |             this is found to be of type `()`\n+LL | |\n+LL | |         }\n+LL | |         false => dummy(),\n+   | |                  ^^^^^^^ expected `()`, found `i32`\n+LL | |\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "d74076cbc9b8e1bad1564cffb12f3316214d1583", "filename": "src/test/ui/suggestions/opaque-type-error.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -16,6 +16,12 @@ LL | |     }.await\n    = note:     expected type `impl Future` (opaque type at <$DIR/opaque-type-error.rs:8:19>)\n            found opaque type `impl Future` (opaque type at <$DIR/opaque-type-error.rs:12:19>)\n    = note: distinct uses of `impl Trait` result in different opaque types\n+help: consider `await`ing on both `Future`s\n+   |\n+LL |         thing_one().await\n+LL |     } else {\n+LL |         thing_two().await\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "209254a5d5e2f1d1525ee16ad243d082b14e97d3", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -6,9 +6,9 @@ edition = \"2018\"\n \n [dependencies]\n diff = \"0.1.10\"\n-env_logger = { version = \"0.7\", default-features = false }\n getopts = \"0.2\"\n tracing = \"0.1\"\n+tracing-subscriber = { version = \"0.2.13\", default-features = false, features = [\"fmt\", \"env-filter\", \"smallvec\", \"parking_lot\", \"ansi\"] }\n regex = \"1.0\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = \"1.0\""}, {"sha": "2b2a6cfa8bd6f45c2ccac52a5ca9042342544a32", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cd97cad6e5f85bed455f505f330ead1d5cd8432/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=1cd97cad6e5f85bed455f505f330ead1d5cd8432", "patch": "@@ -35,7 +35,7 @@ pub mod runtest;\n pub mod util;\n \n fn main() {\n-    env_logger::init();\n+    tracing_subscriber::fmt::init();\n \n     let config = parse_config(env::args().collect());\n "}]}