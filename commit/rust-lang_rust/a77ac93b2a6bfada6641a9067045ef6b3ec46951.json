{"sha": "a77ac93b2a6bfada6641a9067045ef6b3ec46951", "node_id": "C_kwDOAAsO6NoAKGE3N2FjOTNiMmE2YmZhZGE2NjQxYTkwNjcwNDVlZjZiM2VjNDY5NTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-19T21:53:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-19T21:53:19Z"}, "message": "Auto merge of #13128 - Veykril:invocation-strategy, r=Veykril\n\nImplement invocation strategy config\n\nFixes https://github.com/rust-lang/rust-analyzer/issues/10793\n\nThis allows to change how we run build scripts (and `checkOnSave`), exposing two configs:\n- `once`: run the specified command once in the project root (the working dir of the server)\n- `per_workspace`: run the specified command per workspace in the corresponding workspace\n\nThis also applies to `checkOnSave` likewise, though `once_in_root` is useless there currently, due to https://github.com/rust-lang/cargo/issues/11007", "tree": {"sha": "249512395424a91e5bbbfe141f77d2f28e990252", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/249512395424a91e5bbbfe141f77d2f28e990252"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a77ac93b2a6bfada6641a9067045ef6b3ec46951", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a77ac93b2a6bfada6641a9067045ef6b3ec46951", "html_url": "https://github.com/rust-lang/rust/commit/a77ac93b2a6bfada6641a9067045ef6b3ec46951", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a77ac93b2a6bfada6641a9067045ef6b3ec46951/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82ac6f7d4835c5cc27b5be92fee00200dbba43bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/82ac6f7d4835c5cc27b5be92fee00200dbba43bb", "html_url": "https://github.com/rust-lang/rust/commit/82ac6f7d4835c5cc27b5be92fee00200dbba43bb"}, {"sha": "46732369f4b8246e6dc764ef1aa01d03ab5f52b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/46732369f4b8246e6dc764ef1aa01d03ab5f52b7", "html_url": "https://github.com/rust-lang/rust/commit/46732369f4b8246e6dc764ef1aa01d03ab5f52b7"}], "stats": {"total": 630, "additions": 447, "deletions": 183}, "files": [{"sha": "0debf3270f61791182150d435e34420cf2c71ef4", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a77ac93b2a6bfada6641a9067045ef6b3ec46951/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77ac93b2a6bfada6641a9067045ef6b3ec46951/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=a77ac93b2a6bfada6641a9067045ef6b3ec46951", "patch": "@@ -21,6 +21,13 @@ pub use cargo_metadata::diagnostic::{\n     DiagnosticSpanMacroExpansion,\n };\n \n+#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]\n+pub enum InvocationStrategy {\n+    Once,\n+    #[default]\n+    PerWorkspace,\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum FlycheckConfig {\n     CargoCommand {\n@@ -32,11 +39,13 @@ pub enum FlycheckConfig {\n         features: Vec<String>,\n         extra_args: Vec<String>,\n         extra_env: FxHashMap<String, String>,\n+        invocation_strategy: InvocationStrategy,\n     },\n     CustomCommand {\n         command: String,\n         args: Vec<String>,\n         extra_env: FxHashMap<String, String>,\n+        invocation_strategy: InvocationStrategy,\n     },\n }\n \n@@ -136,11 +145,15 @@ enum Restart {\n     No,\n }\n \n+/// A [`FlycheckActor`] is a single check instance of a workspace.\n struct FlycheckActor {\n+    /// The workspace id of this flycheck instance.\n     id: usize,\n     sender: Box<dyn Fn(Message) + Send>,\n     config: FlycheckConfig,\n-    workspace_root: AbsPathBuf,\n+    /// Either the workspace root of the workspace we are flychecking,\n+    /// or the project root of the project.\n+    root: AbsPathBuf,\n     /// CargoHandle exists to wrap around the communication needed to be able to\n     /// run `cargo check` without blocking. Currently the Rust standard library\n     /// doesn't provide a way to read sub-process output without blocking, so we\n@@ -162,11 +175,13 @@ impl FlycheckActor {\n         workspace_root: AbsPathBuf,\n     ) -> FlycheckActor {\n         tracing::info!(%id, ?workspace_root, \"Spawning flycheck\");\n-        FlycheckActor { id, sender, config, workspace_root, cargo_handle: None }\n+        FlycheckActor { id, sender, config, root: workspace_root, cargo_handle: None }\n     }\n-    fn progress(&self, progress: Progress) {\n+\n+    fn report_progress(&self, progress: Progress) {\n         self.send(Message::Progress { id: self.id, progress });\n     }\n+\n     fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n         let check_chan = self.cargo_handle.as_ref().map(|cargo| &cargo.receiver);\n         if let Ok(msg) = inbox.try_recv() {\n@@ -178,6 +193,7 @@ impl FlycheckActor {\n             recv(check_chan.unwrap_or(&never())) -> msg => Some(Event::CheckEvent(msg.ok())),\n         }\n     }\n+\n     fn run(mut self, inbox: Receiver<Restart>) {\n         'event: while let Some(event) = self.next_event(&inbox) {\n             match event {\n@@ -203,10 +219,10 @@ impl FlycheckActor {\n                                 \"did  restart flycheck\"\n                             );\n                             self.cargo_handle = Some(cargo_handle);\n-                            self.progress(Progress::DidStart);\n+                            self.report_progress(Progress::DidStart);\n                         }\n                         Err(error) => {\n-                            self.progress(Progress::DidFailToRestart(format!(\n+                            self.report_progress(Progress::DidFailToRestart(format!(\n                                 \"Failed to run the following command: {:?} error={}\",\n                                 self.check_command(),\n                                 error\n@@ -226,17 +242,17 @@ impl FlycheckActor {\n                             self.check_command()\n                         );\n                     }\n-                    self.progress(Progress::DidFinish(res));\n+                    self.report_progress(Progress::DidFinish(res));\n                 }\n                 Event::CheckEvent(Some(message)) => match message {\n                     CargoMessage::CompilerArtifact(msg) => {\n-                        self.progress(Progress::DidCheckCrate(msg.target.name));\n+                        self.report_progress(Progress::DidCheckCrate(msg.target.name));\n                     }\n \n                     CargoMessage::Diagnostic(msg) => {\n                         self.send(Message::AddDiagnostic {\n                             id: self.id,\n-                            workspace_root: self.workspace_root.clone(),\n+                            workspace_root: self.root.clone(),\n                             diagnostic: msg,\n                         });\n                     }\n@@ -254,12 +270,12 @@ impl FlycheckActor {\n                 \"did  cancel flycheck\"\n             );\n             cargo_handle.cancel();\n-            self.progress(Progress::DidCancel);\n+            self.report_progress(Progress::DidCancel);\n         }\n     }\n \n     fn check_command(&self) -> Command {\n-        let mut cmd = match &self.config {\n+        let (mut cmd, args, invocation_strategy) = match &self.config {\n             FlycheckConfig::CargoCommand {\n                 command,\n                 target_triple,\n@@ -269,12 +285,11 @@ impl FlycheckActor {\n                 extra_args,\n                 features,\n                 extra_env,\n+                invocation_strategy,\n             } => {\n                 let mut cmd = Command::new(toolchain::cargo());\n                 cmd.arg(command);\n-                cmd.current_dir(&self.workspace_root);\n-                cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n-                    .arg(self.workspace_root.join(\"Cargo.toml\").as_os_str());\n+                cmd.args(&[\"--workspace\", \"--message-format=json\"]);\n \n                 if let Some(target) = target_triple {\n                     cmd.args(&[\"--target\", target.as_str()]);\n@@ -293,18 +308,19 @@ impl FlycheckActor {\n                         cmd.arg(features.join(\" \"));\n                     }\n                 }\n-                cmd.args(extra_args);\n                 cmd.envs(extra_env);\n-                cmd\n+                (cmd, extra_args, invocation_strategy)\n             }\n-            FlycheckConfig::CustomCommand { command, args, extra_env } => {\n+            FlycheckConfig::CustomCommand { command, args, extra_env, invocation_strategy } => {\n                 let mut cmd = Command::new(command);\n-                cmd.args(args);\n                 cmd.envs(extra_env);\n-                cmd\n+                (cmd, args, invocation_strategy)\n             }\n         };\n-        cmd.current_dir(&self.workspace_root);\n+        match invocation_strategy {\n+            InvocationStrategy::PerWorkspace => cmd.current_dir(&self.root),\n+            InvocationStrategy::Once => cmd.args(args),\n+        };\n         cmd\n     }\n "}, {"sha": "0bb9bd65dccf49bf309072dab0ab432766358211", "filename": "crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 226, "deletions": 127, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/a77ac93b2a6bfada6641a9067045ef6b3ec46951/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77ac93b2a6bfada6641a9067045ef6b3ec46951/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=a77ac93b2a6bfada6641a9067045ef6b3ec46951", "patch": "@@ -6,7 +6,12 @@\n //! This module implements this second part. We use \"build script\" terminology\n //! here, but it covers procedural macros as well.\n \n-use std::{cell::RefCell, io, path::PathBuf, process::Command};\n+use std::{\n+    cell::RefCell,\n+    io, mem,\n+    path::{self, PathBuf},\n+    process::Command,\n+};\n \n use cargo_metadata::{camino::Utf8Path, Message};\n use la_arena::ArenaMap;\n@@ -15,11 +20,13 @@ use rustc_hash::FxHashMap;\n use semver::Version;\n use serde::Deserialize;\n \n-use crate::{cfg_flag::CfgFlag, CargoConfig, CargoFeatures, CargoWorkspace, Package};\n+use crate::{\n+    cfg_flag::CfgFlag, CargoConfig, CargoFeatures, CargoWorkspace, InvocationStrategy, Package,\n+};\n \n #[derive(Debug, Default, Clone, PartialEq, Eq)]\n pub struct WorkspaceBuildScripts {\n-    outputs: ArenaMap<Package, Option<BuildScriptOutput>>,\n+    outputs: ArenaMap<Package, BuildScriptOutput>,\n     error: Option<String>,\n }\n \n@@ -38,98 +45,212 @@ pub(crate) struct BuildScriptOutput {\n     pub(crate) proc_macro_dylib_path: Option<AbsPathBuf>,\n }\n \n+impl BuildScriptOutput {\n+    fn is_unchanged(&self) -> bool {\n+        self.cfgs.is_empty()\n+            && self.envs.is_empty()\n+            && self.out_dir.is_none()\n+            && self.proc_macro_dylib_path.is_none()\n+    }\n+}\n+\n impl WorkspaceBuildScripts {\n-    fn build_command(config: &CargoConfig) -> Command {\n-        if let Some([program, args @ ..]) = config.run_build_script_command.as_deref() {\n-            let mut cmd = Command::new(program);\n-            cmd.args(args);\n-            cmd.envs(&config.extra_env);\n-            return cmd;\n-        }\n+    fn build_command(\n+        config: &CargoConfig,\n+        workspace_root: Option<&path::Path>,\n+    ) -> io::Result<Command> {\n+        let mut cmd = match config.run_build_script_command.as_deref() {\n+            Some([program, args @ ..]) => {\n+                let mut cmd = Command::new(program);\n+                cmd.args(args);\n+                cmd\n+            }\n+            _ => {\n+                let mut cmd = Command::new(toolchain::cargo());\n \n-        let mut cmd = Command::new(toolchain::cargo());\n-        cmd.envs(&config.extra_env);\n-        cmd.args(&[\"check\", \"--quiet\", \"--workspace\", \"--message-format=json\"]);\n+                cmd.args(&[\"check\", \"--quiet\", \"--workspace\", \"--message-format=json\"]);\n \n-        // --all-targets includes tests, benches and examples in addition to the\n-        // default lib and bins. This is an independent concept from the --targets\n-        // flag below.\n-        cmd.arg(\"--all-targets\");\n+                // --all-targets includes tests, benches and examples in addition to the\n+                // default lib and bins. This is an independent concept from the --targets\n+                // flag below.\n+                cmd.arg(\"--all-targets\");\n \n-        if let Some(target) = &config.target {\n-            cmd.args(&[\"--target\", target]);\n-        }\n+                if let Some(target) = &config.target {\n+                    cmd.args(&[\"--target\", target]);\n+                }\n \n-        match &config.features {\n-            CargoFeatures::All => {\n-                cmd.arg(\"--all-features\");\n-            }\n-            CargoFeatures::Selected { features, no_default_features } => {\n-                if *no_default_features {\n-                    cmd.arg(\"--no-default-features\");\n+                match &config.features {\n+                    CargoFeatures::All => {\n+                        cmd.arg(\"--all-features\");\n+                    }\n+                    CargoFeatures::Selected { features, no_default_features } => {\n+                        if *no_default_features {\n+                            cmd.arg(\"--no-default-features\");\n+                        }\n+                        if !features.is_empty() {\n+                            cmd.arg(\"--features\");\n+                            cmd.arg(features.join(\" \"));\n+                        }\n+                    }\n                 }\n-                if !features.is_empty() {\n-                    cmd.arg(\"--features\");\n-                    cmd.arg(features.join(\" \"));\n+\n+                if let Some(workspace_root) = workspace_root {\n+                    cmd.current_dir(workspace_root);\n                 }\n+\n+                cmd\n             }\n+        };\n+\n+        cmd.envs(&config.extra_env);\n+        if config.wrap_rustc_in_build_scripts {\n+            // Setup RUSTC_WRAPPER to point to `rust-analyzer` binary itself. We use\n+            // that to compile only proc macros and build scripts during the initial\n+            // `cargo check`.\n+            let myself = std::env::current_exe()?;\n+            cmd.env(\"RUSTC_WRAPPER\", myself);\n+            cmd.env(\"RA_RUSTC_WRAPPER\", \"1\");\n         }\n \n-        cmd\n+        Ok(cmd)\n     }\n \n-    pub(crate) fn run(\n+    /// Runs the build scripts for the given workspace\n+    pub(crate) fn run_for_workspace(\n         config: &CargoConfig,\n         workspace: &CargoWorkspace,\n         progress: &dyn Fn(String),\n         toolchain: &Option<Version>,\n     ) -> io::Result<WorkspaceBuildScripts> {\n         const RUST_1_62: Version = Version::new(1, 62, 0);\n \n-        match Self::run_(Self::build_command(config), config, workspace, progress) {\n+        let workspace_root: &path::Path = &workspace.workspace_root().as_ref();\n+\n+        match Self::run_per_ws(\n+            Self::build_command(config, Some(workspace_root))?,\n+            workspace,\n+            progress,\n+        ) {\n             Ok(WorkspaceBuildScripts { error: Some(error), .. })\n                 if toolchain.as_ref().map_or(false, |it| *it >= RUST_1_62) =>\n             {\n                 // building build scripts failed, attempt to build with --keep-going so\n                 // that we potentially get more build data\n-                let mut cmd = Self::build_command(config);\n+                let mut cmd = Self::build_command(config, Some(workspace_root))?;\n                 cmd.args(&[\"-Z\", \"unstable-options\", \"--keep-going\"]).env(\"RUSTC_BOOTSTRAP\", \"1\");\n-                let mut res = Self::run_(cmd, config, workspace, progress)?;\n+                let mut res = Self::run_per_ws(cmd, workspace, progress)?;\n                 res.error = Some(error);\n                 Ok(res)\n             }\n             res => res,\n         }\n     }\n \n-    fn run_(\n-        mut cmd: Command,\n+    /// Runs the build scripts by invoking the configured command *once*.\n+    /// This populates the outputs for all passed in workspaces.\n+    pub(crate) fn run_once(\n         config: &CargoConfig,\n-        workspace: &CargoWorkspace,\n+        workspaces: &[&CargoWorkspace],\n         progress: &dyn Fn(String),\n-    ) -> io::Result<WorkspaceBuildScripts> {\n-        if config.wrap_rustc_in_build_scripts {\n-            // Setup RUSTC_WRAPPER to point to `rust-analyzer` binary itself. We use\n-            // that to compile only proc macros and build scripts during the initial\n-            // `cargo check`.\n-            let myself = std::env::current_exe()?;\n-            cmd.env(\"RUSTC_WRAPPER\", myself);\n-            cmd.env(\"RA_RUSTC_WRAPPER\", \"1\");\n+    ) -> io::Result<Vec<WorkspaceBuildScripts>> {\n+        assert_eq!(config.invocation_strategy, InvocationStrategy::Once);\n+        let cmd = Self::build_command(config, None)?;\n+        // NB: Cargo.toml could have been modified between `cargo metadata` and\n+        // `cargo check`. We shouldn't assume that package ids we see here are\n+        // exactly those from `config`.\n+        let mut by_id = FxHashMap::default();\n+        let mut res: Vec<_> = workspaces\n+            .iter()\n+            .enumerate()\n+            .map(|(idx, workspace)| {\n+                let mut res = WorkspaceBuildScripts::default();\n+                for package in workspace.packages() {\n+                    res.outputs.insert(package, BuildScriptOutput::default());\n+                    by_id.insert(workspace[package].id.clone(), (package, idx));\n+                }\n+                res\n+            })\n+            .collect();\n+\n+        let errors = Self::run_command(\n+            cmd,\n+            |package, cb| {\n+                if let Some(&(package, workspace)) = by_id.get(package) {\n+                    cb(&workspaces[workspace][package].name, &mut res[workspace].outputs[package]);\n+                }\n+            },\n+            progress,\n+        )?;\n+        res.iter_mut().for_each(|it| it.error = errors.clone());\n+\n+        if tracing::enabled!(tracing::Level::INFO) {\n+            for (idx, workspace) in workspaces.iter().enumerate() {\n+                for package in workspace.packages() {\n+                    let package_build_data = &mut res[idx].outputs[package];\n+                    if !package_build_data.is_unchanged() {\n+                        tracing::info!(\n+                            \"{}: {:?}\",\n+                            workspace[package].manifest.parent().display(),\n+                            package_build_data,\n+                        );\n+                    }\n+                }\n+            }\n         }\n \n-        cmd.current_dir(workspace.workspace_root());\n+        Ok(res)\n+    }\n \n+    fn run_per_ws(\n+        cmd: Command,\n+        workspace: &CargoWorkspace,\n+        progress: &dyn Fn(String),\n+    ) -> io::Result<WorkspaceBuildScripts> {\n         let mut res = WorkspaceBuildScripts::default();\n         let outputs = &mut res.outputs;\n         // NB: Cargo.toml could have been modified between `cargo metadata` and\n         // `cargo check`. We shouldn't assume that package ids we see here are\n         // exactly those from `config`.\n         let mut by_id: FxHashMap<String, Package> = FxHashMap::default();\n         for package in workspace.packages() {\n-            outputs.insert(package, None);\n+            outputs.insert(package, BuildScriptOutput::default());\n             by_id.insert(workspace[package].id.clone(), package);\n         }\n \n+        res.error = Self::run_command(\n+            cmd,\n+            |package, cb| {\n+                if let Some(&package) = by_id.get(package) {\n+                    cb(&workspace[package].name, &mut outputs[package]);\n+                }\n+            },\n+            progress,\n+        )?;\n+\n+        if tracing::enabled!(tracing::Level::INFO) {\n+            for package in workspace.packages() {\n+                let package_build_data = &mut outputs[package];\n+                if !package_build_data.is_unchanged() {\n+                    tracing::info!(\n+                        \"{}: {:?}\",\n+                        workspace[package].manifest.parent().display(),\n+                        package_build_data,\n+                    );\n+                }\n+            }\n+        }\n+\n+        Ok(res)\n+    }\n+\n+    fn run_command(\n+        cmd: Command,\n+        // ideally this would be something like:\n+        // with_output_for: impl FnMut(&str, dyn FnOnce(&mut BuildScriptOutput)),\n+        // but owned trait objects aren't a thing\n+        mut with_output_for: impl FnMut(&str, &mut dyn FnMut(&str, &mut BuildScriptOutput)),\n+        progress: &dyn Fn(String),\n+    ) -> io::Result<Option<String>> {\n         let errors = RefCell::new(String::new());\n         let push_err = |err: &str| {\n             let mut e = errors.borrow_mut();\n@@ -149,61 +270,58 @@ impl WorkspaceBuildScripts {\n                     .unwrap_or_else(|_| Message::TextLine(line.to_string()));\n \n                 match message {\n-                    Message::BuildScriptExecuted(message) => {\n-                        let package = match by_id.get(&message.package_id.repr) {\n-                            Some(&it) => it,\n-                            None => return,\n-                        };\n-                        progress(format!(\"running build-script: {}\", workspace[package].name));\n-\n-                        let cfgs = {\n-                            let mut acc = Vec::new();\n-                            for cfg in message.cfgs {\n-                                match cfg.parse::<CfgFlag>() {\n-                                    Ok(it) => acc.push(it),\n-                                    Err(err) => {\n-                                        push_err(&format!(\n-                                            \"invalid cfg from cargo-metadata: {}\",\n-                                            err\n-                                        ));\n-                                        return;\n-                                    }\n-                                };\n+                    Message::BuildScriptExecuted(mut message) => {\n+                        with_output_for(&message.package_id.repr, &mut |name, data| {\n+                            progress(format!(\"running build-script: {}\", name));\n+                            let cfgs = {\n+                                let mut acc = Vec::new();\n+                                for cfg in &message.cfgs {\n+                                    match cfg.parse::<CfgFlag>() {\n+                                        Ok(it) => acc.push(it),\n+                                        Err(err) => {\n+                                            push_err(&format!(\n+                                                \"invalid cfg from cargo-metadata: {}\",\n+                                                err\n+                                            ));\n+                                            return;\n+                                        }\n+                                    };\n+                                }\n+                                acc\n+                            };\n+                            if !message.env.is_empty() {\n+                                data.envs = mem::take(&mut message.env);\n                             }\n-                            acc\n-                        };\n-                        // cargo_metadata crate returns default (empty) path for\n-                        // older cargos, which is not absolute, so work around that.\n-                        let out_dir = message.out_dir.into_os_string();\n-                        if !out_dir.is_empty() {\n-                            let data = outputs[package].get_or_insert_with(Default::default);\n-                            data.out_dir = Some(AbsPathBuf::assert(PathBuf::from(out_dir)));\n-                            data.cfgs = cfgs;\n-                        }\n-                        if !message.env.is_empty() {\n-                            outputs[package].get_or_insert_with(Default::default).envs =\n-                                message.env;\n-                        }\n+                            // cargo_metadata crate returns default (empty) path for\n+                            // older cargos, which is not absolute, so work around that.\n+                            let out_dir = mem::take(&mut message.out_dir).into_os_string();\n+                            if !out_dir.is_empty() {\n+                                let out_dir = AbsPathBuf::assert(PathBuf::from(out_dir));\n+                                // inject_cargo_env(package, package_build_data);\n+                                // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n+                                if let Some(out_dir) =\n+                                    out_dir.as_os_str().to_str().map(|s| s.to_owned())\n+                                {\n+                                    data.envs.push((\"OUT_DIR\".to_string(), out_dir));\n+                                }\n+                                data.out_dir = Some(out_dir);\n+                                data.cfgs = cfgs;\n+                            }\n+                        });\n                     }\n                     Message::CompilerArtifact(message) => {\n-                        let package = match by_id.get(&message.package_id.repr) {\n-                            Some(it) => *it,\n-                            None => return,\n-                        };\n-\n-                        progress(format!(\"building proc-macros: {}\", message.target.name));\n-\n-                        if message.target.kind.iter().any(|k| k == \"proc-macro\") {\n-                            // Skip rmeta file\n-                            if let Some(filename) =\n-                                message.filenames.iter().find(|name| is_dylib(name))\n-                            {\n-                                let filename = AbsPathBuf::assert(PathBuf::from(&filename));\n-                                outputs[package]\n-                                    .get_or_insert_with(Default::default)\n-                                    .proc_macro_dylib_path = Some(filename);\n+                        with_output_for(&message.package_id.repr, &mut |name, data| {\n+                            progress(format!(\"building proc-macros: {}\", name));\n+                            if message.target.kind.iter().any(|k| k == \"proc-macro\") {\n+                                // Skip rmeta file\n+                                if let Some(filename) =\n+                                    message.filenames.iter().find(|name| is_dylib(name))\n+                                {\n+                                    let filename = AbsPathBuf::assert(PathBuf::from(&filename));\n+                                    data.proc_macro_dylib_path = Some(filename);\n+                                }\n                             }\n-                        }\n+                        });\n                     }\n                     Message::CompilerMessage(message) => {\n                         progress(message.target.name);\n@@ -222,44 +340,25 @@ impl WorkspaceBuildScripts {\n             },\n         )?;\n \n-        for package in workspace.packages() {\n-            if let Some(package_build_data) = &mut outputs[package] {\n-                tracing::info!(\n-                    \"{}: {:?}\",\n-                    workspace[package].manifest.parent().display(),\n-                    package_build_data,\n-                );\n-                // inject_cargo_env(package, package_build_data);\n-                if let Some(out_dir) = &package_build_data.out_dir {\n-                    // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n-                    if let Some(out_dir) = out_dir.as_os_str().to_str().map(|s| s.to_owned()) {\n-                        package_build_data.envs.push((\"OUT_DIR\".to_string(), out_dir));\n-                    }\n-                }\n-            }\n-        }\n-\n-        let mut errors = errors.into_inner();\n-        if !output.status.success() {\n-            if errors.is_empty() {\n-                errors = \"cargo check failed\".to_string();\n-            }\n-            res.error = Some(errors);\n-        }\n-\n-        Ok(res)\n+        let errors = if !output.status.success() {\n+            let errors = errors.into_inner();\n+            Some(if errors.is_empty() { \"cargo check failed\".to_string() } else { errors })\n+        } else {\n+            None\n+        };\n+        Ok(errors)\n     }\n \n     pub fn error(&self) -> Option<&str> {\n         self.error.as_deref()\n     }\n \n     pub(crate) fn get_output(&self, idx: Package) -> Option<&BuildScriptOutput> {\n-        self.outputs.get(idx)?.as_ref()\n+        self.outputs.get(idx)\n     }\n }\n \n-// FIXME: File a better way to know if it is a dylib.\n+// FIXME: Find a better way to know if it is a dylib.\n fn is_dylib(path: &Utf8Path) -> bool {\n     match path.extension().map(|e| e.to_string().to_lowercase()) {\n         None => false,"}, {"sha": "d8f6d62349eb73ea30ff38a3f06ef5196918a436", "filename": "crates/project-model/src/cargo_workspace.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a77ac93b2a6bfada6641a9067045ef6b3ec46951/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77ac93b2a6bfada6641a9067045ef6b3ec46951/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs?ref=a77ac93b2a6bfada6641a9067045ef6b3ec46951", "patch": "@@ -14,8 +14,8 @@ use rustc_hash::FxHashMap;\n use serde::Deserialize;\n use serde_json::from_value;\n \n-use crate::CfgOverrides;\n use crate::{utf8_stdout, ManifestPath};\n+use crate::{CfgOverrides, InvocationStrategy};\n \n /// [`CargoWorkspace`] represents the logical structure of, well, a Cargo\n /// workspace. It pretty closely mirrors `cargo metadata` output.\n@@ -106,6 +106,7 @@ pub struct CargoConfig {\n     pub run_build_script_command: Option<Vec<String>>,\n     /// Extra env vars to set when invoking the cargo command\n     pub extra_env: FxHashMap<String, String>,\n+    pub invocation_strategy: InvocationStrategy,\n }\n \n impl CargoConfig {"}, {"sha": "d116ff3c0104cc7b8ba0ade9be0858c525749666", "filename": "crates/project-model/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a77ac93b2a6bfada6641a9067045ef6b3ec46951/crates%2Fproject-model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77ac93b2a6bfada6641a9067045ef6b3ec46951/crates%2Fproject-model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Flib.rs?ref=a77ac93b2a6bfada6641a9067045ef6b3ec46951", "patch": "@@ -157,3 +157,10 @@ fn utf8_stdout(mut cmd: Command) -> Result<String> {\n     let stdout = String::from_utf8(output.stdout)?;\n     Ok(stdout.trim().to_string())\n }\n+\n+#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]\n+pub enum InvocationStrategy {\n+    Once,\n+    #[default]\n+    PerWorkspace,\n+}"}, {"sha": "01180fcf4c3e4794d1ad3612734e1e71a24df1b0", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a77ac93b2a6bfada6641a9067045ef6b3ec46951/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77ac93b2a6bfada6641a9067045ef6b3ec46951/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=a77ac93b2a6bfada6641a9067045ef6b3ec46951", "patch": "@@ -2,7 +2,7 @@\n //! metadata` or `rust-project.json`) into representation stored in the salsa\n //! database -- `CrateGraph`.\n \n-use std::{collections::VecDeque, fmt, fs, process::Command};\n+use std::{collections::VecDeque, fmt, fs, process::Command, sync::Arc};\n \n use anyhow::{format_err, Context, Result};\n use base_db::{\n@@ -21,8 +21,8 @@ use crate::{\n     cfg_flag::CfgFlag,\n     rustc_cfg,\n     sysroot::SysrootCrate,\n-    utf8_stdout, CargoConfig, CargoWorkspace, ManifestPath, Package, ProjectJson, ProjectManifest,\n-    Sysroot, TargetKind, WorkspaceBuildScripts,\n+    utf8_stdout, CargoConfig, CargoWorkspace, InvocationStrategy, ManifestPath, Package,\n+    ProjectJson, ProjectManifest, Sysroot, TargetKind, WorkspaceBuildScripts,\n };\n \n /// A set of cfg-overrides per crate.\n@@ -303,23 +303,69 @@ impl ProjectWorkspace {\n         Ok(ProjectWorkspace::DetachedFiles { files: detached_files, sysroot, rustc_cfg })\n     }\n \n+    /// Runs the build scripts for this [`ProjectWorkspace`].\n     pub fn run_build_scripts(\n         &self,\n         config: &CargoConfig,\n         progress: &dyn Fn(String),\n     ) -> Result<WorkspaceBuildScripts> {\n         match self {\n             ProjectWorkspace::Cargo { cargo, toolchain, .. } => {\n-                WorkspaceBuildScripts::run(config, cargo, progress, toolchain).with_context(|| {\n-                    format!(\"Failed to run build scripts for {}\", &cargo.workspace_root().display())\n-                })\n+                WorkspaceBuildScripts::run_for_workspace(config, cargo, progress, toolchain)\n+                    .with_context(|| {\n+                        format!(\n+                            \"Failed to run build scripts for {}\",\n+                            &cargo.workspace_root().display()\n+                        )\n+                    })\n             }\n             ProjectWorkspace::Json { .. } | ProjectWorkspace::DetachedFiles { .. } => {\n                 Ok(WorkspaceBuildScripts::default())\n             }\n         }\n     }\n \n+    /// Runs the build scripts for the given [`ProjectWorkspace`]s. Depending on the invocation\n+    /// strategy this may run a single build process for all project workspaces.\n+    pub fn run_all_build_scripts(\n+        workspaces: &[ProjectWorkspace],\n+        config: &CargoConfig,\n+        progress: &dyn Fn(String),\n+    ) -> Vec<Result<WorkspaceBuildScripts>> {\n+        if let InvocationStrategy::PerWorkspace = config.invocation_strategy {\n+            return workspaces.iter().map(|it| it.run_build_scripts(config, progress)).collect();\n+        }\n+\n+        let cargo_ws: Vec<_> = workspaces\n+            .iter()\n+            .filter_map(|it| match it {\n+                ProjectWorkspace::Cargo { cargo, .. } => Some(cargo),\n+                _ => None,\n+            })\n+            .collect();\n+        let ref mut outputs = match WorkspaceBuildScripts::run_once(config, &cargo_ws, progress) {\n+            Ok(it) => Ok(it.into_iter()),\n+            // io::Error is not Clone?\n+            Err(e) => Err(Arc::new(e)),\n+        };\n+\n+        workspaces\n+            .iter()\n+            .map(|it| match it {\n+                ProjectWorkspace::Cargo { cargo, .. } => match outputs {\n+                    Ok(outputs) => Ok(outputs.next().unwrap()),\n+                    Err(e) => Err(e.clone()).with_context(|| {\n+                        format!(\n+                            \"Failed to run build scripts for {}\",\n+                            &cargo.workspace_root().display()\n+                        )\n+                    }),\n+                },\n+                _ => Ok(WorkspaceBuildScripts::default()),\n+            })\n+            .collect()\n+    }\n+\n     pub fn set_build_scripts(&mut self, bs: WorkspaceBuildScripts) {\n         match self {\n             ProjectWorkspace::Cargo { build_scripts, .. } => *build_scripts = bs,"}, {"sha": "3669fda926a743ba894ab30219376f158d52d360", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a77ac93b2a6bfada6641a9067045ef6b3ec46951/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77ac93b2a6bfada6641a9067045ef6b3ec46951/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=a77ac93b2a6bfada6641a9067045ef6b3ec46951", "patch": "@@ -69,6 +69,13 @@ config_data! {\n         cargo_autoreload: bool           = \"true\",\n         /// Run build scripts (`build.rs`) for more precise code analysis.\n         cargo_buildScripts_enable: bool  = \"true\",\n+        /// Specifies the invocation strategy to use when running the build scripts command.\n+        /// If `per_workspace` is set, the command will be executed for each workspace from the\n+        /// corresponding workspace root.\n+        /// If `once` is set, the command will be executed once in the project root.\n+        /// This config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\n+        /// is set.\n+        cargo_buildScripts_invocationStrategy: InvocationStrategy = \"\\\"per_workspace\\\"\",\n         /// Override the command rust-analyzer uses to run build scripts and\n         /// build procedural macros. The command is required to output json\n         /// and should therefore include `--message-format=json` or a similar\n@@ -122,6 +129,13 @@ config_data! {\n         ///\n         /// Set to `\"all\"` to pass `--all-features` to Cargo.\n         checkOnSave_features: Option<CargoFeaturesDef>      = \"null\",\n+        /// Specifies the invocation strategy to use when running the checkOnSave command.\n+        /// If `per_workspace` is set, the command will be executed for each workspace from the\n+        /// corresponding workspace root.\n+        /// If `once` is set, the command will be executed once in the project root.\n+        /// This config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\n+        /// is set.\n+        checkOnSave_invocationStrategy: InvocationStrategy = \"\\\"per_workspace\\\"\",\n         /// Whether to pass `--no-default-features` to Cargo. Defaults to\n         /// `#rust-analyzer.cargo.noDefaultFeatures#`.\n         checkOnSave_noDefaultFeatures: Option<bool>      = \"null\",\n@@ -1056,6 +1070,10 @@ impl Config {\n             rustc_source,\n             unset_test_crates: UnsetTestCrates::Only(self.data.cargo_unsetTest.clone()),\n             wrap_rustc_in_build_scripts: self.data.cargo_buildScripts_useRustcWrapper,\n+            invocation_strategy: match self.data.cargo_buildScripts_invocationStrategy {\n+                InvocationStrategy::Once => project_model::InvocationStrategy::Once,\n+                InvocationStrategy::PerWorkspace => project_model::InvocationStrategy::PerWorkspace,\n+            },\n             run_build_script_command: self.data.cargo_buildScripts_overrideCommand.clone(),\n             extra_env: self.data.cargo_extraEnv.clone(),\n         }\n@@ -1079,6 +1097,10 @@ impl Config {\n         if !self.data.checkOnSave_enable {\n             return None;\n         }\n+        let invocation_strategy = match self.data.checkOnSave_invocationStrategy {\n+            InvocationStrategy::Once => flycheck::InvocationStrategy::Once,\n+            InvocationStrategy::PerWorkspace => flycheck::InvocationStrategy::PerWorkspace,\n+        };\n         let flycheck_config = match &self.data.checkOnSave_overrideCommand {\n             Some(args) if !args.is_empty() => {\n                 let mut args = args.clone();\n@@ -1087,6 +1109,7 @@ impl Config {\n                     command,\n                     args,\n                     extra_env: self.check_on_save_extra_env(),\n+                    invocation_strategy,\n                 }\n             }\n             Some(_) | None => FlycheckConfig::CargoCommand {\n@@ -1116,6 +1139,7 @@ impl Config {\n                 },\n                 extra_args: self.data.checkOnSave_extraArgs.clone(),\n                 extra_env: self.check_on_save_extra_env(),\n+                invocation_strategy,\n             },\n         };\n         Some(flycheck_config)\n@@ -1587,6 +1611,13 @@ enum CargoFeaturesDef {\n     Selected(Vec<String>),\n }\n \n+#[derive(Deserialize, Debug, Clone)]\n+#[serde(rename_all = \"snake_case\")]\n+enum InvocationStrategy {\n+    Once,\n+    PerWorkspace,\n+}\n+\n #[derive(Deserialize, Debug, Clone)]\n #[serde(untagged)]\n enum LifetimeElisionDef {\n@@ -2001,6 +2032,14 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 \"Render annotations above the whole item, including documentation comments and attributes.\"\n             ],\n         },\n+        \"InvocationStrategy\" => set! {\n+            \"type\": \"string\",\n+            \"enum\": [\"per_workspace\", \"once\"],\n+            \"enumDescriptions\": [\n+                \"The command will be executed for each workspace from the corresponding workspace root.\",\n+                \"The command will be executed once in the project root.\"\n+            ],\n+        },\n         _ => panic!(\"missing entry for {}: {}\", ty, default),\n     }\n "}, {"sha": "f7db62baf2c1636087aafae562f22329b3557865", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 40, "deletions": 30, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a77ac93b2a6bfada6641a9067045ef6b3ec46951/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77ac93b2a6bfada6641a9067045ef6b3ec46951/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=a77ac93b2a6bfada6641a9067045ef6b3ec46951", "patch": "@@ -175,10 +175,8 @@ impl GlobalState {\n                     sender.send(Task::FetchBuildData(BuildDataProgress::Report(msg))).unwrap()\n                 }\n             };\n-            let mut res = Vec::new();\n-            for ws in workspaces.iter() {\n-                res.push(ws.run_build_scripts(&config, &progress));\n-            }\n+            let res = ProjectWorkspace::run_all_build_scripts(&workspaces, &config, &progress);\n+\n             sender.send(Task::FetchBuildData(BuildDataProgress::End((workspaces, res)))).unwrap();\n         });\n     }\n@@ -475,32 +473,44 @@ impl GlobalState {\n         };\n \n         let sender = self.flycheck_sender.clone();\n-        self.flycheck = self\n-            .workspaces\n-            .iter()\n-            .enumerate()\n-            .filter_map(|(id, w)| match w {\n-                ProjectWorkspace::Cargo { cargo, .. } => Some((id, cargo.workspace_root())),\n-                ProjectWorkspace::Json { project, .. } => {\n-                    // Enable flychecks for json projects if a custom flycheck command was supplied\n-                    // in the workspace configuration.\n-                    match config {\n-                        FlycheckConfig::CustomCommand { .. } => Some((id, project.path())),\n-                        _ => None,\n-                    }\n-                }\n-                ProjectWorkspace::DetachedFiles { .. } => None,\n-            })\n-            .map(|(id, root)| {\n-                let sender = sender.clone();\n-                FlycheckHandle::spawn(\n-                    id,\n-                    Box::new(move |msg| sender.send(msg).unwrap()),\n-                    config.clone(),\n-                    root.to_path_buf(),\n-                )\n-            })\n-            .collect();\n+        let (FlycheckConfig::CargoCommand { invocation_strategy, .. }\n+        | FlycheckConfig::CustomCommand { invocation_strategy, .. }) = config;\n+\n+        self.flycheck = match invocation_strategy {\n+            flycheck::InvocationStrategy::Once => vec![FlycheckHandle::spawn(\n+                0,\n+                Box::new(move |msg| sender.send(msg).unwrap()),\n+                config.clone(),\n+                self.config.root_path().clone(),\n+            )],\n+            flycheck::InvocationStrategy::PerWorkspace => {\n+                self.workspaces\n+                    .iter()\n+                    .enumerate()\n+                    .filter_map(|(id, w)| match w {\n+                        ProjectWorkspace::Cargo { cargo, .. } => Some((id, cargo.workspace_root())),\n+                        ProjectWorkspace::Json { project, .. } => {\n+                            // Enable flychecks for json projects if a custom flycheck command was supplied\n+                            // in the workspace configuration.\n+                            match config {\n+                                FlycheckConfig::CustomCommand { .. } => Some((id, project.path())),\n+                                _ => None,\n+                            }\n+                        }\n+                        ProjectWorkspace::DetachedFiles { .. } => None,\n+                    })\n+                    .map(|(id, root)| {\n+                        let sender = sender.clone();\n+                        FlycheckHandle::spawn(\n+                            id,\n+                            Box::new(move |msg| sender.send(msg).unwrap()),\n+                            config.clone(),\n+                            root.to_path_buf(),\n+                        )\n+                    })\n+                    .collect()\n+            }\n+        };\n     }\n }\n "}, {"sha": "e5d4395c345cc936553b0664799a1446fd00c6e1", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a77ac93b2a6bfada6641a9067045ef6b3ec46951/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/a77ac93b2a6bfada6641a9067045ef6b3ec46951/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=a77ac93b2a6bfada6641a9067045ef6b3ec46951", "patch": "@@ -24,6 +24,16 @@ Automatically refresh project info via `cargo metadata` on\n --\n Run build scripts (`build.rs`) for more precise code analysis.\n --\n+[[rust-analyzer.cargo.buildScripts.invocationStrategy]]rust-analyzer.cargo.buildScripts.invocationStrategy (default: `\"per_workspace\"`)::\n++\n+--\n+Specifies the invocation strategy to use when running the build scripts command.\n+If `per_workspace` is set, the command will be executed for each workspace from the\n+corresponding workspace root.\n+If `once` is set, the command will be executed once in the project root.\n+This config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\n+is set.\n+--\n [[rust-analyzer.cargo.buildScripts.overrideCommand]]rust-analyzer.cargo.buildScripts.overrideCommand (default: `null`)::\n +\n --\n@@ -118,6 +128,16 @@ List of features to activate. Defaults to\n \n Set to `\"all\"` to pass `--all-features` to Cargo.\n --\n+[[rust-analyzer.checkOnSave.invocationStrategy]]rust-analyzer.checkOnSave.invocationStrategy (default: `\"per_workspace\"`)::\n++\n+--\n+Specifies the invocation strategy to use when running the checkOnSave command.\n+If `per_workspace` is set, the command will be executed for each workspace from the\n+corresponding workspace root.\n+If `once` is set, the command will be executed once in the project root.\n+This config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\n+is set.\n+--\n [[rust-analyzer.checkOnSave.noDefaultFeatures]]rust-analyzer.checkOnSave.noDefaultFeatures (default: `null`)::\n +\n --"}, {"sha": "62ac1e60b00a89ce005259f948edc216e3eadfc9", "filename": "editors/code/package.json", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a77ac93b2a6bfada6641a9067045ef6b3ec46951/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/a77ac93b2a6bfada6641a9067045ef6b3ec46951/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=a77ac93b2a6bfada6641a9067045ef6b3ec46951", "patch": "@@ -432,6 +432,19 @@\n                     \"default\": true,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.cargo.buildScripts.invocationStrategy\": {\n+                    \"markdownDescription\": \"Specifies the invocation strategy to use when running the build scripts command.\\nIf `per_workspace` is set, the command will be executed for each workspace from the\\ncorresponding workspace root.\\nIf `once` is set, the command will be executed once in the project root.\\nThis config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\\nis set.\",\n+                    \"default\": \"per_workspace\",\n+                    \"type\": \"string\",\n+                    \"enum\": [\n+                        \"per_workspace\",\n+                        \"once\"\n+                    ],\n+                    \"enumDescriptions\": [\n+                        \"The command will be executed for each workspace from the corresponding workspace root.\",\n+                        \"The command will be executed once in the project root.\"\n+                    ]\n+                },\n                 \"rust-analyzer.cargo.buildScripts.overrideCommand\": {\n                     \"markdownDescription\": \"Override the command rust-analyzer uses to run build scripts and\\nbuild procedural macros. The command is required to output json\\nand should therefore include `--message-format=json` or a similar\\noption.\\n\\nBy default, a cargo invocation will be constructed for the configured\\ntargets and features, with the following base command line:\\n\\n```bash\\ncargo check --quiet --workspace --message-format=json --all-targets\\n```\\n.\",\n                     \"default\": null,\n@@ -557,6 +570,19 @@\n                         }\n                     ]\n                 },\n+                \"rust-analyzer.checkOnSave.invocationStrategy\": {\n+                    \"markdownDescription\": \"Specifies the invocation strategy to use when running the checkOnSave command.\\nIf `per_workspace` is set, the command will be executed for each workspace from the\\ncorresponding workspace root.\\nIf `once` is set, the command will be executed once in the project root.\\nThis config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`\\nis set.\",\n+                    \"default\": \"per_workspace\",\n+                    \"type\": \"string\",\n+                    \"enum\": [\n+                        \"per_workspace\",\n+                        \"once\"\n+                    ],\n+                    \"enumDescriptions\": [\n+                        \"The command will be executed for each workspace from the corresponding workspace root.\",\n+                        \"The command will be executed once in the project root.\"\n+                    ]\n+                },\n                 \"rust-analyzer.checkOnSave.noDefaultFeatures\": {\n                     \"markdownDescription\": \"Whether to pass `--no-default-features` to Cargo. Defaults to\\n`#rust-analyzer.cargo.noDefaultFeatures#`.\",\n                     \"default\": null,"}]}