{"sha": "387cacf76bdee1af073f53948af382ca78d046e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4N2NhY2Y3NmJkZWUxYWYwNzNmNTM5NDhhZjM4MmNhNzhkMDQ2ZTY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-12-10T10:59:08Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T07:26:13Z"}, "message": "rustc: remove ty::item_path::RootMode by moving local logic into the printer.", "tree": {"sha": "dcd3a590bdd60b825951784b94674c52f02828af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcd3a590bdd60b825951784b94674c52f02828af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/387cacf76bdee1af073f53948af382ca78d046e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/387cacf76bdee1af073f53948af382ca78d046e6", "html_url": "https://github.com/rust-lang/rust/commit/387cacf76bdee1af073f53948af382ca78d046e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/387cacf76bdee1af073f53948af382ca78d046e6/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d211e5b1287f9140418c4e46461c451d1da42e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d211e5b1287f9140418c4e46461c451d1da42e1", "html_url": "https://github.com/rust-lang/rust/commit/7d211e5b1287f9140418c4e46461c451d1da42e1"}], "stats": {"total": 629, "additions": 273, "deletions": 356}, "files": [{"sha": "6f8d0d19103eac598b262e3a2798ec1fcf72a517", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 230, "deletions": 313, "changes": 543, "blob_url": "https://github.com/rust-lang/rust/blob/387cacf76bdee1af073f53948af382ca78d046e6/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/387cacf76bdee1af073f53948af382ca78d046e6/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=387cacf76bdee1af073f53948af382ca78d046e6", "patch": "@@ -2,11 +2,11 @@ use crate::hir::map::DefPathData;\n use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n+use ty::print::PrintCx;\n use syntax::ast;\n-use syntax::symbol::{keywords, LocalInternedString, Symbol};\n+use syntax::symbol::{keywords, Symbol};\n \n use std::cell::Cell;\n-use std::fmt::Debug;\n \n thread_local! {\n     static FORCE_ABSOLUTE: Cell<bool> = Cell::new(false);\n@@ -58,16 +58,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// suitable for user output. It is relative to the current crate\n     /// root, unless with_forced_absolute_paths was used.\n     pub fn item_path_str(self, def_id: DefId) -> String {\n-        let mode = FORCE_ABSOLUTE.with(|force| {\n-            if force.get() {\n-                RootMode::Absolute\n-            } else {\n-                RootMode::Local\n-            }\n-        });\n-        let mut printer = LocalPathPrinter::new(mode);\n-        debug!(\"item_path_str: printer={:?} def_id={:?}\", printer, def_id);\n-        self.print_item_path(&mut printer, def_id)\n+        debug!(\"item_path_str: def_id={:?}\", def_id);\n+        let mut cx = PrintCx::new(self);\n+        if FORCE_ABSOLUTE.with(|force| force.get()) {\n+            AbsolutePathPrinter::print_item_path(&mut cx, def_id)\n+        } else {\n+            LocalPathPrinter::print_item_path(&mut cx, def_id)\n+        }\n     }\n \n     /// Returns a string identifying this local node-id.\n@@ -78,246 +75,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns a string identifying this def-id. This string is\n     /// suitable for user output. It always begins with a crate identifier.\n     pub fn absolute_item_path_str(self, def_id: DefId) -> String {\n-        let mut printer = LocalPathPrinter::new(RootMode::Absolute);\n-        debug!(\"absolute_item_path_str: printer={:?} def_id={:?}\", printer, def_id);\n-        self.print_item_path(&mut printer, def_id)\n-    }\n-\n-    /// Returns the \"path\" to a particular crate. This can proceed in\n-    /// various ways, depending on the `root_mode` of the `printer`.\n-    /// (See `RootMode` enum for more details.)\n-    fn print_krate_path<P>(\n-        self,\n-        printer: &mut P,\n-        cnum: CrateNum,\n-    ) -> P::Path\n-        where P: ItemPathPrinter + Debug\n-    {\n-        debug!(\n-            \"print_krate_path: printer={:?} cnum={:?} LOCAL_CRATE={:?}\",\n-            printer, cnum, LOCAL_CRATE\n-        );\n-        match printer.root_mode() {\n-            RootMode::Local => {\n-                // In local mode, when we encounter a crate other than\n-                // LOCAL_CRATE, execution proceeds in one of two ways:\n-                //\n-                // 1. for a direct dependency, where user added an\n-                //    `extern crate` manually, we put the `extern\n-                //    crate` as the parent. So you wind up with\n-                //    something relative to the current crate.\n-                // 2. for an extern inferred from a path or an indirect crate,\n-                //    where there is no explicit `extern crate`, we just prepend\n-                //    the crate name.\n-                //\n-                // Returns `None` for the local crate.\n-                if cnum != LOCAL_CRATE {\n-                    match *self.extern_crate(cnum.as_def_id()) {\n-                        Some(ExternCrate {\n-                            src: ExternCrateSource::Extern(def_id),\n-                            direct: true,\n-                            span,\n-                            ..\n-                        }) if !span.is_dummy() => {\n-                            debug!(\"print_krate_path: def_id={:?}\", def_id);\n-                            self.print_item_path(printer, def_id)\n-                        }\n-                        _ => {\n-                            let name = self.crate_name(cnum).as_str();\n-                            debug!(\"print_krate_path: name={:?}\", name);\n-                            printer.path_crate(Some(&name))\n-                        }\n-                    }\n-                } else if self.sess.rust_2018() {\n-                    // We add the `crate::` keyword on Rust 2018, only when desired.\n-                    if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n-                        printer.path_crate(Some(&keywords::Crate.name().as_str()))\n-                    } else {\n-                        printer.path_crate(None)\n-                    }\n-                } else {\n-                    printer.path_crate(None)\n-                }\n-            }\n-            RootMode::Absolute => {\n-                // In absolute mode, just write the crate name\n-                // unconditionally.\n-                let name = self.original_crate_name(cnum).as_str();\n-                debug!(\"print_krate_path: original_name={:?}\", name);\n-                printer.path_crate(Some(&name))\n-            }\n-        }\n-    }\n-\n-    /// If possible, this returns a global path resolving to `external_def_id` that is visible\n-    /// from at least one local module and returns true. If the crate defining `external_def_id` is\n-    /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n-    fn try_print_visible_item_path<P>(\n-        self,\n-        printer: &mut P,\n-        external_def_id: DefId,\n-    ) -> Option<P::Path>\n-        where P: ItemPathPrinter + Debug\n-    {\n-        debug!(\n-            \"try_print_visible_item_path: printer={:?} external_def_id={:?}\",\n-            printer, external_def_id\n-        );\n-        let visible_parent_map = self.visible_parent_map(LOCAL_CRATE);\n-\n-        let (mut cur_def, mut cur_path) = (external_def_id, Vec::<LocalInternedString>::new());\n-        loop {\n-            debug!(\n-                \"try_print_visible_item_path: cur_def={:?} cur_path={:?} CRATE_DEF_INDEX={:?}\",\n-                cur_def, cur_path, CRATE_DEF_INDEX,\n-            );\n-            // If `cur_def` is a direct or injected extern crate, return the path to the crate\n-            // followed by the path to the item within the crate.\n-            if cur_def.index == CRATE_DEF_INDEX {\n-                match *self.extern_crate(cur_def) {\n-                    Some(ExternCrate {\n-                        src: ExternCrateSource::Extern(def_id),\n-                        direct: true,\n-                        span,\n-                        ..\n-                    }) => {\n-                        debug!(\"try_print_visible_item_path: def_id={:?}\", def_id);\n-                        let path = if !span.is_dummy() {\n-                            self.print_item_path(printer, def_id)\n-                        } else {\n-                            printer.path_crate(Some(\n-                                &self.crate_name(cur_def.krate).as_str(),\n-                            ))\n-                        };\n-                        return Some(cur_path.iter().rev().fold(path, |path, segment| {\n-                            printer.path_append(path, &segment)\n-                        }));\n-                    }\n-                    None => {\n-                        let path = printer.path_crate(Some(\n-                            &self.crate_name(cur_def.krate).as_str(),\n-                        ));\n-                        return Some(cur_path.iter().rev().fold(path, |path, segment| {\n-                            printer.path_append(path, &segment)\n-                        }));\n-                    }\n-                    _ => {},\n-                }\n-            }\n-\n-            let mut cur_def_key = self.def_key(cur_def);\n-            debug!(\"try_print_visible_item_path: cur_def_key={:?}\", cur_def_key);\n-\n-            // For a UnitStruct or TupleStruct we want the name of its parent rather than <unnamed>.\n-            if let DefPathData::StructCtor = cur_def_key.disambiguated_data.data {\n-                let parent = DefId {\n-                    krate: cur_def.krate,\n-                    index: cur_def_key.parent.expect(\"DefPathData::StructCtor missing a parent\"),\n-                };\n-\n-                cur_def_key = self.def_key(parent);\n-            }\n-\n-            let visible_parent = visible_parent_map.get(&cur_def).cloned();\n-            let actual_parent = self.parent(cur_def);\n-\n-            let data = cur_def_key.disambiguated_data.data;\n-            debug!(\n-                \"try_print_visible_item_path: data={:?} visible_parent={:?} actual_parent={:?}\",\n-                data, visible_parent, actual_parent,\n-            );\n-            let symbol = match data {\n-                // In order to output a path that could actually be imported (valid and visible),\n-                // we need to handle re-exports correctly.\n-                //\n-                // For example, take `std::os::unix::process::CommandExt`, this trait is actually\n-                // defined at `std::sys::unix::ext::process::CommandExt` (at time of writing).\n-                //\n-                // `std::os::unix` rexports the contents of `std::sys::unix::ext`. `std::sys` is\n-                // private so the \"true\" path to `CommandExt` isn't accessible.\n-                //\n-                // In this case, the `visible_parent_map` will look something like this:\n-                //\n-                // (child) -> (parent)\n-                // `std::sys::unix::ext::process::CommandExt` -> `std::sys::unix::ext::process`\n-                // `std::sys::unix::ext::process` -> `std::sys::unix::ext`\n-                // `std::sys::unix::ext` -> `std::os`\n-                //\n-                // This is correct, as the visible parent of `std::sys::unix::ext` is in fact\n-                // `std::os`.\n-                //\n-                // When printing the path to `CommandExt` and looking at the `cur_def_key` that\n-                // corresponds to `std::sys::unix::ext`, we would normally print `ext` and then go\n-                // to the parent - resulting in a mangled path like\n-                // `std::os::ext::process::CommandExt`.\n-                //\n-                // Instead, we must detect that there was a re-export and instead print `unix`\n-                // (which is the name `std::sys::unix::ext` was re-exported as in `std::os`). To\n-                // do this, we compare the parent of `std::sys::unix::ext` (`std::sys::unix`) with\n-                // the visible parent (`std::os`). If these do not match, then we iterate over\n-                // the children of the visible parent (as was done when computing\n-                // `visible_parent_map`), looking for the specific child we currently have and then\n-                // have access to the re-exported name.\n-                DefPathData::Module(actual_name) |\n-                DefPathData::TypeNs(actual_name) if visible_parent != actual_parent => {\n-                    visible_parent\n-                        .and_then(|parent| {\n-                            self.item_children(parent)\n-                                .iter()\n-                                .find(|child| child.def.def_id() == cur_def)\n-                                .map(|child| child.ident.as_str())\n-                        })\n-                        .unwrap_or_else(|| actual_name.as_str())\n-                },\n-                _ => {\n-                    data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {\n-                        // Re-exported `extern crate` (#43189).\n-                        if let DefPathData::CrateRoot = data {\n-                            self.original_crate_name(cur_def.krate).as_str()\n-                        } else {\n-                            Symbol::intern(\"<unnamed>\").as_str()\n-                        }\n-                    })\n-                },\n-            };\n-            debug!(\"try_print_visible_item_path: symbol={:?}\", symbol);\n-            cur_path.push(symbol);\n-\n-            cur_def = visible_parent?;\n-        }\n+        debug!(\"absolute_item_path_str: def_id={:?}\", def_id);\n+        let mut cx = PrintCx::new(self);\n+        AbsolutePathPrinter::print_item_path(&mut cx, def_id)\n     }\n+}\n \n-    pub fn print_item_path<P>(\n-        self,\n-        printer: &mut P,\n-        def_id: DefId,\n-    ) -> P::Path\n-        where P: ItemPathPrinter + Debug\n+impl PrintCx<'a, 'gcx, 'tcx> {\n+    pub fn default_print_item_path<P>(&mut self, def_id: DefId) -> P::Path\n+        where P: ItemPathPrinter\n     {\n-        debug!(\n-            \"print_item_path: printer={:?} def_id={:?}\",\n-            printer, def_id\n-        );\n-        match printer.root_mode() {\n-            RootMode::Local if !def_id.is_local() => {\n-                match self.try_print_visible_item_path(printer, def_id) {\n-                    Some(path) => return path,\n-                    None => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        let key = self.def_key(def_id);\n-        debug!(\"print_item_path: key={:?}\", key);\n+        debug!(\"default_print_item_path: def_id={:?}\", def_id);\n+        let key = self.tcx.def_key(def_id);\n+        debug!(\"default_print_item_path: key={:?}\", key);\n         match key.disambiguated_data.data {\n             DefPathData::CrateRoot => {\n                 assert!(key.parent.is_none());\n-                self.print_krate_path(printer, def_id.krate)\n+                P::path_crate(self, def_id.krate)\n             }\n \n             DefPathData::Impl => {\n-                self.print_impl_path(printer, def_id)\n+                self.default_print_impl_path::<P>(def_id)\n             }\n \n             // Unclear if there is any value in distinguishing these.\n@@ -342,27 +120,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::ClosureExpr |\n             data @ DefPathData::ImplTrait |\n             data @ DefPathData::GlobalMetaData(..) => {\n-                let parent_did = self.parent_def_id(def_id).unwrap();\n-                let path = self.print_item_path(printer, parent_did);\n-                printer.path_append(path, &data.as_interned_str().as_symbol().as_str())\n+                let parent_did = self.tcx.parent_def_id(def_id).unwrap();\n+                let path = P::print_item_path(self, parent_did);\n+                P::path_append(path, &data.as_interned_str().as_symbol().as_str())\n             },\n \n             DefPathData::StructCtor => { // present `X` instead of `X::{{constructor}}`\n-                let parent_def_id = self.parent_def_id(def_id).unwrap();\n-                self.print_item_path(printer, parent_def_id)\n+                let parent_def_id = self.tcx.parent_def_id(def_id).unwrap();\n+                P::print_item_path(self, parent_def_id)\n             }\n         }\n     }\n \n-    fn print_impl_path<P>(\n-        self,\n-        printer: &mut P,\n-        impl_def_id: DefId,\n-    ) -> P::Path\n-        where P: ItemPathPrinter + Debug\n+    fn default_print_impl_path<P>(&mut self, impl_def_id: DefId) -> P::Path\n+        where P: ItemPathPrinter\n     {\n-        debug!(\"print_impl_path: printer={:?} impl_def_id={:?}\", printer, impl_def_id);\n-        let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n+        debug!(\"default_print_impl_path: impl_def_id={:?}\", impl_def_id);\n+        let parent_def_id = self.tcx.parent_def_id(impl_def_id).unwrap();\n \n         // Always use types for non-local impls, where types are always\n         // available, and filename/line-number is mostly uninteresting.\n@@ -373,35 +147,35 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         if !use_types {\n-            return self.print_impl_path_fallback(printer, impl_def_id);\n+            return self.default_print_impl_path_fallback::<P>(impl_def_id);\n         }\n \n         // Decide whether to print the parent path for the impl.\n         // Logically, since impls are global, it's never needed, but\n         // users may find it useful. Currently, we omit the parent if\n         // the impl is either in the same module as the self-type or\n         // as the trait.\n-        let self_ty = self.type_of(impl_def_id);\n+        let self_ty = self.tcx.type_of(impl_def_id);\n         let in_self_mod = match characteristic_def_id_of_type(self_ty) {\n             None => false,\n-            Some(ty_def_id) => self.parent_def_id(ty_def_id) == Some(parent_def_id),\n+            Some(ty_def_id) => self.tcx.parent_def_id(ty_def_id) == Some(parent_def_id),\n         };\n \n-        let impl_trait_ref = self.impl_trait_ref(impl_def_id);\n+        let impl_trait_ref = self.tcx.impl_trait_ref(impl_def_id);\n         let in_trait_mod = match impl_trait_ref {\n             None => false,\n-            Some(trait_ref) => self.parent_def_id(trait_ref.def_id) == Some(parent_def_id),\n+            Some(trait_ref) => self.tcx.parent_def_id(trait_ref.def_id) == Some(parent_def_id),\n         };\n \n         if !in_self_mod && !in_trait_mod {\n             // If the impl is not co-located with either self-type or\n             // trait-type, then fallback to a format that identifies\n             // the module more clearly.\n-            let path = self.print_item_path(printer, parent_def_id);\n+            let path = P::print_item_path(self, parent_def_id);\n             if let Some(trait_ref) = impl_trait_ref {\n-                return printer.path_append(path, &format!(\"<impl {} for {}>\", trait_ref, self_ty));\n+                return P::path_append(path, &format!(\"<impl {} for {}>\", trait_ref, self_ty));\n             } else {\n-                return printer.path_append(path, &format!(\"<impl {}>\", self_ty));\n+                return P::path_append(path, &format!(\"<impl {}>\", self_ty));\n             }\n         }\n \n@@ -410,7 +184,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some(trait_ref) = impl_trait_ref {\n             // Trait impls.\n-            return printer.path_impl(&format!(\"<{} as {}>\", self_ty, trait_ref));\n+            return P::path_impl(self, &format!(\"<{} as {}>\", self_ty, trait_ref));\n         }\n \n         // Inherent impls. Try to print `Foo::bar` for an inherent\n@@ -420,47 +194,46 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::Adt(adt_def, substs) => {\n                 // FIXME(eddyb) always print without <> here.\n                 if substs.types().next().is_none() { // ignore regions\n-                    self.print_item_path(printer, adt_def.did)\n+                    P::print_item_path(self, adt_def.did)\n                 } else {\n-                    printer.path_impl(&format!(\"<{}>\", self_ty))\n+                    P::path_impl(self, &format!(\"<{}>\", self_ty))\n                 }\n             }\n \n-            ty::Foreign(did) => self.print_item_path(printer, did),\n+            ty::Foreign(did) => P::print_item_path(self, did),\n \n             ty::Bool |\n             ty::Char |\n             ty::Int(_) |\n             ty::Uint(_) |\n             ty::Float(_) |\n             ty::Str => {\n-                printer.path_impl(&self_ty.to_string())\n+                P::path_impl(self, &self_ty.to_string())\n             }\n \n             _ => {\n-                printer.path_impl(&format!(\"<{}>\", self_ty))\n+                P::path_impl(self, &format!(\"<{}>\", self_ty))\n             }\n         }\n     }\n \n-    fn print_impl_path_fallback<P>(\n-        self,\n-        printer: &mut P,\n-        impl_def_id: DefId,\n-    ) -> P::Path\n-        where P: ItemPathPrinter + Debug\n+    fn default_print_impl_path_fallback<P>(&mut self, impl_def_id: DefId) -> P::Path\n+        where P: ItemPathPrinter\n     {\n         // If no type info is available, fall back to\n         // pretty printing some span information. This should\n         // only occur very early in the compiler pipeline.\n-        let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n-        let path = self.print_item_path(printer, parent_def_id);\n-        let hir_id = self.hir().as_local_hir_id(impl_def_id).unwrap();\n-        let item = self.hir().expect_item_by_hir_id(hir_id);\n-        let span_str = self.sess.source_map().span_to_string(item.span);\n-        printer.path_append(path, &format!(\"<impl at {}>\", span_str))\n+        // FIXME(eddyb) this should just be using `tcx.def_span(impl_def_id)`\n+        let parent_def_id = self.tcx.parent_def_id(impl_def_id).unwrap();\n+        let path = P::print_item_path(self, parent_def_id);\n+        let hir_id = self.tcx.hir().as_local_hir_id(impl_def_id).unwrap();\n+        let item = self.tcx.hir().expect_item_by_hir_id(hir_id);\n+        let span_str = self.tcx.sess.source_map().span_to_string(item.span);\n+        P::path_append(path, &format!(\"<impl at {}>\", span_str))\n     }\n+}\n \n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns the `DefId` of `def_id`'s parent in the def tree. If\n     /// this returns `None`, then `def_id` represents a crate root or\n     /// inlined root.\n@@ -519,58 +292,202 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n }\n \n /// Unifying Trait for different kinds of item paths we might\n-/// construct. The basic interface is that components get pushed: the\n-/// instance can also customize how we handle the root of a crate.\n-pub trait ItemPathPrinter {\n+/// construct. The basic interface is that components get appended.\n+pub trait ItemPathPrinter: Sized {\n     type Path;\n \n-    fn root_mode(&self) -> RootMode;\n+    fn print_item_path(cx: &mut PrintCx<'_, '_, '_>, def_id: DefId) -> Self::Path {\n+        cx.default_print_item_path::<Self>(def_id)\n+    }\n \n-    fn path_crate(&self, name: Option<&str>) -> Self::Path;\n-    fn path_impl(&self, text: &str) -> Self::Path;\n-    fn path_append(&self, path: Self::Path, text: &str) -> Self::Path;\n+    fn path_crate(cx: &mut PrintCx<'_, '_, '_>, cnum: CrateNum) -> Self::Path;\n+    fn path_impl(cx: &mut PrintCx<'_, '_, '_>, text: &str) -> Self::Path;\n+    fn path_append(path: Self::Path, text: &str) -> Self::Path;\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub enum RootMode {\n-    /// Try to make a path relative to the local crate. In\n-    /// particular, local paths have no prefix, and if the path comes\n-    /// from an extern crate, start with the path to the `extern\n-    /// crate` declaration.\n-    Local,\n-\n-    /// Always prepend the crate name to the path, forming an absolute\n-    /// path from within a given set of crates.\n-    Absolute,\n-}\n+struct AbsolutePathPrinter;\n+\n+impl ItemPathPrinter for AbsolutePathPrinter {\n+    type Path = String;\n \n-#[derive(Debug)]\n-struct LocalPathPrinter {\n-    root_mode: RootMode,\n+    fn path_crate(cx: &mut PrintCx<'_, '_, '_>, cnum: CrateNum) -> Self::Path {\n+        cx.tcx.original_crate_name(cnum).to_string()\n+    }\n+    fn path_impl(_cx: &mut PrintCx<'_, '_, '_>, text: &str) -> Self::Path {\n+        text.to_string()\n+    }\n+    fn path_append(mut path: Self::Path, text: &str) -> Self::Path {\n+        if !path.is_empty() {\n+            path.push_str(\"::\");\n+        }\n+        path.push_str(text);\n+        path\n+    }\n }\n \n+struct LocalPathPrinter;\n+\n impl LocalPathPrinter {\n-    fn new(root_mode: RootMode) -> LocalPathPrinter {\n-        LocalPathPrinter {\n-            root_mode,\n+    /// If possible, this returns a global path resolving to `def_id` that is visible\n+    /// from at least one local module and returns true. If the crate defining `def_id` is\n+    /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n+    fn try_print_visible_item_path(\n+        cx: &mut PrintCx<'_, '_, '_>,\n+        def_id: DefId,\n+    ) -> Option<<Self as ItemPathPrinter>::Path> {\n+        debug!(\"try_print_visible_item_path: def_id={:?}\", def_id);\n+\n+        // If `def_id` is a direct or injected extern crate, return the\n+        // path to the crate followed by the path to the item within the crate.\n+        if def_id.index == CRATE_DEF_INDEX {\n+            let cnum = def_id.krate;\n+\n+            if cnum == LOCAL_CRATE {\n+                return Some(Self::path_crate(cx, cnum));\n+            }\n+\n+            // In local mode, when we encounter a crate other than\n+            // LOCAL_CRATE, execution proceeds in one of two ways:\n+            //\n+            // 1. for a direct dependency, where user added an\n+            //    `extern crate` manually, we put the `extern\n+            //    crate` as the parent. So you wind up with\n+            //    something relative to the current crate.\n+            // 2. for an extern inferred from a path or an indirect crate,\n+            //    where there is no explicit `extern crate`, we just prepend\n+            //    the crate name.\n+            match *cx.tcx.extern_crate(def_id) {\n+                Some(ExternCrate {\n+                    src: ExternCrateSource::Extern(def_id),\n+                    direct: true,\n+                    span,\n+                    ..\n+                }) => {\n+                    debug!(\"try_print_visible_item_path: def_id={:?}\", def_id);\n+                    let path = if !span.is_dummy() {\n+                        Self::print_item_path(cx, def_id)\n+                    } else {\n+                        Self::path_crate(cx, cnum)\n+                    };\n+                    return Some(path);\n+                }\n+                None => {\n+                    return Some(Self::path_crate(cx, cnum));\n+                }\n+                _ => {},\n+            }\n         }\n+\n+        if def_id.is_local() {\n+            return None;\n+        }\n+\n+        let visible_parent_map = cx.tcx.visible_parent_map(LOCAL_CRATE);\n+\n+        let mut cur_def_key = cx.tcx.def_key(def_id);\n+        debug!(\"try_print_visible_item_path: cur_def_key={:?}\", cur_def_key);\n+\n+        // For a UnitStruct or TupleStruct we want the name of its parent rather than <unnamed>.\n+        if let DefPathData::StructCtor = cur_def_key.disambiguated_data.data {\n+            let parent = DefId {\n+                krate: def_id.krate,\n+                index: cur_def_key.parent.expect(\"DefPathData::StructCtor missing a parent\"),\n+            };\n+\n+            cur_def_key = cx.tcx.def_key(parent);\n+        }\n+\n+        let visible_parent = visible_parent_map.get(&def_id).cloned()?;\n+        let path = Self::try_print_visible_item_path(cx, visible_parent)?;\n+        let actual_parent = cx.tcx.parent(def_id);\n+\n+        let data = cur_def_key.disambiguated_data.data;\n+        debug!(\n+            \"try_print_visible_item_path: data={:?} visible_parent={:?} actual_parent={:?}\",\n+            data, visible_parent, actual_parent,\n+        );\n+\n+        let symbol = match data {\n+            // In order to output a path that could actually be imported (valid and visible),\n+            // we need to handle re-exports correctly.\n+            //\n+            // For example, take `std::os::unix::process::CommandExt`, this trait is actually\n+            // defined at `std::sys::unix::ext::process::CommandExt` (at time of writing).\n+            //\n+            // `std::os::unix` rexports the contents of `std::sys::unix::ext`. `std::sys` is\n+            // private so the \"true\" path to `CommandExt` isn't accessible.\n+            //\n+            // In this case, the `visible_parent_map` will look something like this:\n+            //\n+            // (child) -> (parent)\n+            // `std::sys::unix::ext::process::CommandExt` -> `std::sys::unix::ext::process`\n+            // `std::sys::unix::ext::process` -> `std::sys::unix::ext`\n+            // `std::sys::unix::ext` -> `std::os`\n+            //\n+            // This is correct, as the visible parent of `std::sys::unix::ext` is in fact\n+            // `std::os`.\n+            //\n+            // When printing the path to `CommandExt` and looking at the `cur_def_key` that\n+            // corresponds to `std::sys::unix::ext`, we would normally print `ext` and then go\n+            // to the parent - resulting in a mangled path like\n+            // `std::os::ext::process::CommandExt`.\n+            //\n+            // Instead, we must detect that there was a re-export and instead print `unix`\n+            // (which is the name `std::sys::unix::ext` was re-exported as in `std::os`). To\n+            // do this, we compare the parent of `std::sys::unix::ext` (`std::sys::unix`) with\n+            // the visible parent (`std::os`). If these do not match, then we iterate over\n+            // the children of the visible parent (as was done when computing\n+            // `visible_parent_map`), looking for the specific child we currently have and then\n+            // have access to the re-exported name.\n+            DefPathData::Module(actual_name) |\n+            DefPathData::TypeNs(actual_name) if Some(visible_parent) != actual_parent => {\n+                cx.tcx.item_children(visible_parent)\n+                    .iter()\n+                    .find(|child| child.def.def_id() == def_id)\n+                    .map(|child| child.ident.as_str())\n+                    .unwrap_or_else(|| actual_name.as_str())\n+            }\n+            _ => {\n+                data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {\n+                    // Re-exported `extern crate` (#43189).\n+                    if let DefPathData::CrateRoot = data {\n+                        cx.tcx.original_crate_name(def_id.krate).as_str()\n+                    } else {\n+                        Symbol::intern(\"<unnamed>\").as_str()\n+                    }\n+                })\n+            },\n+        };\n+        debug!(\"try_print_visible_item_path: symbol={:?}\", symbol);\n+        Some(Self::path_append(path, &symbol))\n     }\n }\n \n impl ItemPathPrinter for LocalPathPrinter {\n     type Path = String;\n \n-    fn root_mode(&self) -> RootMode {\n-        self.root_mode\n+    fn print_item_path(cx: &mut PrintCx<'_, '_, '_>, def_id: DefId) -> Self::Path {\n+        Self::try_print_visible_item_path(cx, def_id)\n+            .unwrap_or_else(|| cx.default_print_item_path::<Self>(def_id))\n     }\n \n-    fn path_crate(&self, name: Option<&str>) -> Self::Path {\n-        name.unwrap_or(\"\").to_string()\n+    fn path_crate(cx: &mut PrintCx<'_, '_, '_>, cnum: CrateNum) -> Self::Path {\n+        if cnum == LOCAL_CRATE {\n+            if cx.tcx.sess.rust_2018() {\n+                // We add the `crate::` keyword on Rust 2018, only when desired.\n+                if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n+                    return keywords::Crate.name().to_string();\n+                }\n+            }\n+            String::new()\n+        } else {\n+            cx.tcx.crate_name(cnum).to_string()\n+        }\n     }\n-    fn path_impl(&self, text: &str) -> Self::Path {\n+    fn path_impl(_cx: &mut PrintCx<'_, '_, '_>, text: &str) -> Self::Path {\n         text.to_string()\n     }\n-    fn path_append(&self, mut path: Self::Path, text: &str) -> Self::Path {\n+    fn path_append(mut path: Self::Path, text: &str) -> Self::Path {\n         if !path.is_empty() {\n             path.push_str(\"::\");\n         }"}, {"sha": "81101740a4cc962d508590f91bbeed51b338eadd", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/387cacf76bdee1af073f53948af382ca78d046e6/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/387cacf76bdee1af073f53948af382ca78d046e6/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=387cacf76bdee1af073f53948af382ca78d046e6", "patch": "@@ -22,7 +22,7 @@ impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector {\n }\n \n pub struct PrintCx<'a, 'gcx, 'tcx> {\n-    pub(crate) tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub(crate) is_debug: bool,\n     pub(crate) is_verbose: bool,\n     pub(crate) identify_regions: bool,\n@@ -32,18 +32,20 @@ pub struct PrintCx<'a, 'gcx, 'tcx> {\n }\n \n impl PrintCx<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        PrintCx {\n+            tcx,\n+            is_debug: false,\n+            is_verbose: tcx.sess.verbose(),\n+            identify_regions: tcx.sess.opts.debugging_opts.identify_regions,\n+            used_region_names: None,\n+            region_index: 0,\n+            binder_depth: 0,\n+        }\n+    }\n+\n     pub(crate) fn with<R>(f: impl FnOnce(PrintCx<'_, '_, '_>) -> R) -> R {\n-        ty::tls::with(|tcx| {\n-            f(PrintCx {\n-                tcx,\n-                is_debug: false,\n-                is_verbose: tcx.sess.verbose(),\n-                identify_regions: tcx.sess.opts.debugging_opts.identify_regions,\n-                used_region_names: None,\n-                region_index: 0,\n-                binder_depth: 0,\n-            })\n-        })\n+        ty::tls::with(|tcx| f(PrintCx::new(tcx)))\n     }\n     pub(crate) fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<T>)\n     where T: TypeFoldable<'tcx>"}, {"sha": "56ef15b12a0a9585bd7076a58854f65cffb03f3a", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/387cacf76bdee1af073f53948af382ca78d046e6/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/387cacf76bdee1af073f53948af382ca78d046e6/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=387cacf76bdee1af073f53948af382ca78d046e6", "patch": "@@ -87,12 +87,13 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::ich::NodeIdHashingMode;\n-use rustc::ty::item_path::{self, ItemPathPrinter, RootMode};\n+use rustc::ty::item_path::{self, ItemPathPrinter};\n+use rustc::ty::print::PrintCx;\n use rustc::ty::query::Providers;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -224,7 +225,8 @@ fn get_symbol_hash<'a, 'tcx>(\n \n fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n     item_path::with_forced_absolute_paths(|| {\n-        tcx.push_item_path(&mut SymbolPath::new(tcx), def_id).into_interned()\n+        let mut cx = PrintCx::new(tcx);\n+        SymbolPathPrinter::print_item_path(&mut cx, def_id).into_interned()\n     })\n }\n \n@@ -394,29 +396,22 @@ impl SymbolPath {\n     }\n }\n \n-#[derive(Debug)]\n struct SymbolPathPrinter;\n \n impl ItemPathPrinter for SymbolPathPrinter {\n     type Path = SymbolPath;\n \n-    fn root_mode(&self) ->RootMode {\n-        RootMode::Absolute\n-    }\n-\n-    fn path_crate(&self, name: Option<&str>) -> Self::Path {\n-        let mut path = SymbolPath::new();\n-        if let Some(name) = name {\n-            path.push(name);\n-        }\n+    fn path_crate(cx: &mut PrintCx<'_, '_, '_>, cnum: CrateNum) -> Self::Path {\n+        let mut path = SymbolPath::new(cx.tcx);\n+        path.push(&cx.tcx.original_crate_name(cnum).as_str());\n         path\n     }\n-    fn path_impl(&self, text: &str) -> Self::Path {\n-        let mut path = SymbolPath::new();\n+    fn path_impl(cx: &mut PrintCx<'_, '_, '_>, text: &str) -> Self::Path {\n+        let mut path = SymbolPath::new(cx.tcx);\n         path.push(text);\n         path\n     }\n-    fn path_append(&self, mut path: Self::Path, text: &str) -> Self::Path {\n+    fn path_append(mut path: Self::Path, text: &str) -> Self::Path {\n         path.push(text);\n         path\n     }"}, {"sha": "ed7f1bbe7e6ac7f74bccc12fcaceda61dd580434", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/387cacf76bdee1af073f53948af382ca78d046e6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/387cacf76bdee1af073f53948af382ca78d046e6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=387cacf76bdee1af073f53948af382ca78d046e6", "patch": "@@ -4225,30 +4225,33 @@ pub fn path_to_def(tcx: &TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n \n pub fn get_path_for_type<F>(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, def_ctor: F) -> hir::Path\n where F: Fn(DefId) -> Def {\n-    #[derive(Debug)]\n-    struct AbsolutePathBuffer {\n-        names: Vec<String>,\n-    }\n+    use rustc::ty::item_path::ItemPathPrinter;\n+    use rustc::ty::print::PrintCx;\n \n-    impl ty::item_path::ItemPathBuffer for AbsolutePathBuffer {\n-        fn root_mode(&self) -> &ty::item_path::RootMode {\n-            const ABSOLUTE: &'static ty::item_path::RootMode = &ty::item_path::RootMode::Absolute;\n-            ABSOLUTE\n-        }\n+    struct AbsolutePathPrinter;\n+\n+    impl ItemPathPrinter for AbsolutePathPrinter {\n+        type Path = Vec<String>;\n \n-        fn push(&mut self, text: &str) {\n-            self.names.push(text.to_owned());\n+        fn path_crate(cx: &mut PrintCx<'_, '_, '_>, cnum: CrateNum) -> Self::Path {\n+            vec![cx.tcx.original_crate_name(cnum).to_string()]\n+        }\n+        fn path_impl(_: &mut PrintCx<'_, '_, '_>, text: &str) -> Self::Path {\n+            vec![text.to_string()]\n+        }\n+        fn path_append(mut path: Self::Path, text: &str) -> Self::Path {\n+            path.push(text.to_string());\n+            path\n         }\n     }\n \n-    let mut apb = AbsolutePathBuffer { names: vec![] };\n-\n-    tcx.push_item_path(&mut apb, def_id);\n+    let mut cx = PrintCx::new(tcx);\n+    let names = AbsolutePathPrinter::print_item_path(&mut cx, def_id);\n \n     hir::Path {\n         span: DUMMY_SP,\n         def: def_ctor(def_id),\n-        segments: hir::HirVec::from_vec(apb.names.iter().map(|s| hir::PathSegment {\n+        segments: hir::HirVec::from_vec(names.iter().map(|s| hir::PathSegment {\n             ident: ast::Ident::from_str(&s),\n             hir_id: None,\n             def: None,"}]}