{"sha": "3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkZDdjNDlmYWY1YWUzYTkxNThhYjI0MmEyNjRjMGYwZWI5OWY2NTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-04T06:36:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-04T06:36:53Z"}, "message": "auto merge of #11251 : pcwalton/rust/remove-at-mut, r=pcwalton\n\nr? @nikomatsakis \r\n\r\nfor the borrow checker changes. Write guards are now eliminated.", "tree": {"sha": "0393c0b2e10c7579d86c222071bb9c64b0451b60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0393c0b2e10c7579d86c222071bb9c64b0451b60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "html_url": "https://github.com/rust-lang/rust/commit/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ff6c12ce94993dae702d597a213eee6b969231a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ff6c12ce94993dae702d597a213eee6b969231a", "html_url": "https://github.com/rust-lang/rust/commit/0ff6c12ce94993dae702d597a213eee6b969231a"}, {"sha": "80921536343e87d2f7d7f19ad90d63f50b557e06", "url": "https://api.github.com/repos/rust-lang/rust/commits/80921536343e87d2f7d7f19ad90d63f50b557e06", "html_url": "https://github.com/rust-lang/rust/commit/80921536343e87d2f7d7f19ad90d63f50b557e06"}], "stats": {"total": 5908, "additions": 2431, "deletions": 3477}, "files": [{"sha": "4edbf171065e6ddb9e445343a093704322da7e4a", "filename": "doc/tutorial.md", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -1431,8 +1431,8 @@ For a more in-depth explanation of borrowed pointers, read the\n ## Freezing\n \n Lending an immutable pointer to an object freezes it and prevents mutation.\n-`Freeze` objects have freezing enforced statically at compile-time. Examples\n-of non-`Freeze` types are `@mut` and [`RefCell<T>`][refcell].\n+`Freeze` objects have freezing enforced statically at compile-time. An example\n+of a non-`Freeze` type is [`RefCell<T>`][refcell].\n \n ~~~~\n let mut x = 5;\n@@ -1443,20 +1443,6 @@ let mut x = 5;\n # x = 3;\n ~~~~\n \n-Mutable managed boxes handle freezing dynamically when any of their contents\n-are borrowed, and the task will fail if an attempt to modify them is made while\n-they are frozen:\n-\n-~~~~\n-let x = @mut 5;\n-let y = x;\n-{\n-    let z = &*y; // the managed box is now frozen\n-    // modifying it through x or y will cause a task failure\n-}\n-// the box is now unfrozen again\n-~~~~\n-\n [refcell]: http://static.rust-lang.org/doc/master/std/cell/struct.RefCell.html\n \n # Dereferencing pointers\n@@ -1477,13 +1463,12 @@ assignments. Such an assignment modifies the value that the pointer\n points to.\n \n ~~~\n-let managed = @mut 10;\n+let managed = @10;\n let mut owned = ~20;\n \n let mut value = 30;\n let borrowed = &mut value;\n \n-*managed = *owned + 10;\n *owned = *borrowed + 100;\n *borrowed = *managed + 1000;\n ~~~\n@@ -2113,8 +2098,7 @@ unless they contain managed boxes, managed closures, or borrowed pointers.\n \n * `Freeze` - Constant (immutable) types.\n These are types that do not contain anything intrinsically mutable.\n-Intrinsically mutable values include `@mut`\n-and `Cell` in the standard library.\n+Intrinsically mutable values include `Cell` in the standard library.\n \n * `'static` - Non-borrowed types.\n These are types that do not contain any data whose lifetime is bound to"}, {"sha": "5ee0099561a21945369b7f78f36bbff44f315d88", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -35,11 +35,13 @@\n #[allow(missing_doc)];\n \n \n-use list::{MutList, MutCons, MutNil};\n+use list::{List, Cons, Nil};\n+use list;\n \n use std::at_vec;\n use std::cast::{transmute, transmute_mut, transmute_mut_region};\n use std::cast;\n+use std::cell::{Cell, RefCell};\n use std::num;\n use std::ptr;\n use std::mem;\n@@ -50,10 +52,11 @@ use std::unstable::intrinsics::{TyDesc, get_tydesc};\n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n+#[deriving(Clone)]\n struct Chunk {\n-    data: @[u8],\n-    fill: uint,\n-    is_pod: bool,\n+    data: RefCell<@[u8]>,\n+    fill: Cell<uint>,\n+    is_pod: Cell<bool>,\n }\n \n #[no_freeze]\n@@ -63,7 +66,7 @@ pub struct Arena {\n     // access the head.\n     priv head: Chunk,\n     priv pod_head: Chunk,\n-    priv chunks: @mut MutList<Chunk>,\n+    priv chunks: RefCell<@List<Chunk>>,\n }\n \n impl Arena {\n@@ -75,7 +78,7 @@ impl Arena {\n         Arena {\n             head: chunk(initial_size, false),\n             pod_head: chunk(initial_size, true),\n-            chunks: @mut MutNil,\n+            chunks: RefCell::new(@Nil),\n         }\n     }\n }\n@@ -84,9 +87,9 @@ fn chunk(size: uint, is_pod: bool) -> Chunk {\n     let mut v: @[u8] = @[];\n     unsafe { at_vec::raw::reserve(&mut v, size); }\n     Chunk {\n-        data: unsafe { cast::transmute(v) },\n-        fill: 0u,\n-        is_pod: is_pod,\n+        data: RefCell::new(unsafe { cast::transmute(v) }),\n+        fill: Cell::new(0u),\n+        is_pod: Cell::new(is_pod),\n     }\n }\n \n@@ -95,8 +98,9 @@ impl Drop for Arena {\n     fn drop(&mut self) {\n         unsafe {\n             destroy_chunk(&self.head);\n-            self.chunks.each(|chunk| {\n-                if !chunk.is_pod {\n+\n+            list::each(self.chunks.get(), |chunk| {\n+                if !chunk.is_pod.get() {\n                     destroy_chunk(chunk);\n                 }\n                 true\n@@ -114,8 +118,11 @@ fn round_up_to(base: uint, align: uint) -> uint {\n // in it.\n unsafe fn destroy_chunk(chunk: &Chunk) {\n     let mut idx = 0;\n-    let buf = chunk.data.as_ptr();\n-    let fill = chunk.fill;\n+    let buf = {\n+        let data = chunk.data.borrow();\n+        data.get().as_ptr()\n+    };\n+    let fill = chunk.fill.get();\n \n     while idx < fill {\n         let tydesc_data: *uint = transmute(ptr::offset(buf, idx as int));\n@@ -155,9 +162,9 @@ impl Arena {\n     // Functions for the POD part of the arena\n     fn alloc_pod_grow(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n-        let chunk_size = at_vec::capacity(self.pod_head.data);\n+        let chunk_size = at_vec::capacity(self.pod_head.data.get());\n         let new_min_chunk_size = num::max(n_bytes, chunk_size);\n-        self.chunks = @mut MutCons(self.pod_head, self.chunks);\n+        self.chunks.set(@Cons(self.pod_head.clone(), self.chunks.get()));\n         self.pod_head =\n             chunk(uint::next_power_of_two(new_min_chunk_size + 1u), true);\n \n@@ -168,17 +175,17 @@ impl Arena {\n     fn alloc_pod_inner(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         unsafe {\n             let this = transmute_mut_region(self);\n-            let start = round_up_to(this.pod_head.fill, align);\n+            let start = round_up_to(this.pod_head.fill.get(), align);\n             let end = start + n_bytes;\n-            if end > at_vec::capacity(this.pod_head.data) {\n+            if end > at_vec::capacity(this.pod_head.data.get()) {\n                 return this.alloc_pod_grow(n_bytes, align);\n             }\n-            this.pod_head.fill = end;\n+            this.pod_head.fill.set(end);\n \n             //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n-            //       start, n_bytes, align, head.fill);\n+            //       start, n_bytes, align, head.fill.get());\n \n-            ptr::offset(this.pod_head.data.as_ptr(), start as int)\n+            ptr::offset(this.pod_head.data.get().as_ptr(), start as int)\n         }\n     }\n \n@@ -197,9 +204,9 @@ impl Arena {\n     fn alloc_nonpod_grow(&mut self, n_bytes: uint, align: uint)\n                          -> (*u8, *u8) {\n         // Allocate a new chunk.\n-        let chunk_size = at_vec::capacity(self.head.data);\n+        let chunk_size = at_vec::capacity(self.head.data.get());\n         let new_min_chunk_size = num::max(n_bytes, chunk_size);\n-        self.chunks = @mut MutCons(self.head, self.chunks);\n+        self.chunks.set(@Cons(self.head.clone(), self.chunks.get()));\n         self.head =\n             chunk(uint::next_power_of_two(new_min_chunk_size + 1u), false);\n \n@@ -218,23 +225,23 @@ impl Arena {\n             {\n                 let head = transmute_mut_region(&mut self.head);\n \n-                tydesc_start = head.fill;\n-                after_tydesc = head.fill + mem::size_of::<*TyDesc>();\n+                tydesc_start = head.fill.get();\n+                after_tydesc = head.fill.get() + mem::size_of::<*TyDesc>();\n                 start = round_up_to(after_tydesc, align);\n                 end = start + n_bytes;\n             }\n \n-            if end > at_vec::capacity(self.head.data) {\n+            if end > at_vec::capacity(self.head.data.get()) {\n                 return self.alloc_nonpod_grow(n_bytes, align);\n             }\n \n             let head = transmute_mut_region(&mut self.head);\n-            head.fill = round_up_to(end, mem::pref_align_of::<*TyDesc>());\n+            head.fill.set(round_up_to(end, mem::pref_align_of::<*TyDesc>()));\n \n             //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n \n-            let buf = self.head.data.as_ptr();\n+            let buf = self.head.data.get().as_ptr();\n             return (ptr::offset(buf, tydesc_start as int), ptr::offset(buf, start as int));\n         }\n     }"}, {"sha": "b530d9c9bc1d8483f599f0fc2a144bb743e9a997", "filename": "src/libextra/list.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -19,13 +19,6 @@ pub enum List<T> {\n     Nil,\n }\n \n-#[deriving(Eq)]\n-#[allow(missing_doc)]\n-pub enum MutList<T> {\n-    MutCons(T, @mut MutList<T>),\n-    MutNil,\n-}\n-\n /// Create a list from a vector\n pub fn from_vec<T:Clone + 'static>(v: &[T]) -> @List<T> {\n     v.rev_iter().fold(@Nil::<T>, |t, h| @Cons((*h).clone(), t))\n@@ -158,26 +151,6 @@ pub fn each<T>(l: @List<T>, f: |&T| -> bool) -> bool {\n     }\n }\n \n-impl<T> MutList<T> {\n-    /// Iterate over a mutable list\n-    pub fn each(@mut self, f: |&mut T| -> bool) -> bool {\n-        let mut cur = self;\n-        loop {\n-            let borrowed = &mut *cur;\n-            cur = match *borrowed {\n-                MutCons(ref mut hd, tl) => {\n-                    if !f(hd) {\n-                        return false;\n-                    }\n-                    tl\n-                }\n-                MutNil => break\n-            }\n-        }\n-        return true;\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use list::*;"}, {"sha": "e7ccb91fb752b0ec376ac404cb879a95d1c8481c", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -426,18 +426,6 @@ impl<D:Decoder,T:Decodable<D> + 'static> Decodable<D> for @T {\n     }\n }\n \n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for @mut T {\n-    fn encode(&self, s: &mut S) {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<D:Decoder,T:Decodable<D> + 'static> Decodable<D> for @mut T {\n-    fn decode(d: &mut D) -> @mut T {\n-        @mut Decodable::decode(d)\n-    }\n-}\n-\n impl<'a, S:Encoder,T:Encodable<S>> Encodable<S> for &'a [T] {\n     fn encode(&self, s: &mut S) {\n         s.emit_seq(self.len(), |s| {"}, {"sha": "1f119ca9db4a47b04cfde6010b24139129b29d0f", "filename": "src/libextra/term.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -113,7 +113,8 @@ impl<T: Writer> Terminal<T> {\n             return Err(entry.unwrap_err());\n         }\n \n-        let ti = parse(entry.unwrap(), false);\n+        let mut file = entry.unwrap();\n+        let ti = parse(&mut file, false);\n         if ti.is_err() {\n             return Err(ti.unwrap_err());\n         }"}, {"sha": "8cbb090269783c16f3697b95d5bf0f4576365cff", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -11,10 +11,9 @@\n /// Implement ncurses-compatible database discovery\n /// Does not support hashed database, only filesystem!\n \n-use std::{os, str};\n-use std::os::getenv;\n-use std::io;\n use std::io::File;\n+use std::os::getenv;\n+use std::{os, str};\n \n /// Return path to database entry for `term`\n pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n@@ -74,9 +73,14 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n }\n \n /// Return open file for `term`\n-pub fn open(term: &str) -> Result<@mut io::Reader, ~str> {\n+pub fn open(term: &str) -> Result<File, ~str> {\n     match get_dbpath_for_term(term) {\n-        Some(x) => Ok(@mut File::open(x) as @mut io::Reader),\n+        Some(x) => {\n+            match File::open(x) {\n+                Some(file) => Ok(file),\n+                None => Err(~\"error opening file\"),\n+            }\n+        }\n         None => Err(format!(\"could not find terminfo entry for {}\", term))\n     }\n }"}, {"sha": "79fb9e3935a9942bc645ca97f03ddcb011597295", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -949,7 +949,8 @@ impl MetricMap {\n \n     /// Write MetricDiff to a file.\n     pub fn save(&self, p: &Path) {\n-        self.to_json().to_pretty_writer(@mut File::create(p) as @mut io::Writer);\n+        let mut file = File::create(p);\n+        self.to_json().to_pretty_writer(&mut file)\n     }\n \n     /// Compare against another MetricMap. Optionally compare all"}, {"sha": "ef6c9e7f9cd5e35dc23b8051e40d3a0fd725c40d", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -796,8 +796,8 @@ mod test {\n         use serialize::{Encodable, Decodable};\n \n         let u = Uuid::new_v4();\n-        let wr = @mut MemWriter::new();\n-        u.encode(&mut ebml::writer::Encoder(wr));\n+        let mut wr = MemWriter::new();\n+        u.encode(&mut ebml::writer::Encoder(&mut wr));\n         let doc = ebml::reader::Doc(wr.inner_ref().as_slice());\n         let u2 = Decodable::decode(&mut ebml::reader::Decoder(doc));\n         assert_eq!(u, u2);"}, {"sha": "874e3c70af046e7e3be38f9fb5b4d78e7b751a3a", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -173,8 +173,8 @@ impl Database {\n \n     // FIXME #4330: This should have &mut self and should set self.db_dirty to false.\n     fn save(&self) {\n-        let f = @mut File::create(&self.db_filename);\n-        self.db_cache.to_json().to_pretty_writer(f as @mut io::Writer);\n+        let mut f = File::create(&self.db_filename);\n+        self.db_cache.to_json().to_pretty_writer(&mut f);\n     }\n \n     fn load(&mut self) {\n@@ -184,14 +184,16 @@ impl Database {\n             Err(e) => fail!(\"Couldn't load workcache database {}: {}\",\n                             self.db_filename.display(),\n                             e.desc),\n-            Ok(r) =>\n-                match json::from_reader(@mut r.unwrap() as @mut io::Reader) {\n+            Ok(r) => {\n+                let mut stream = r.unwrap();\n+                match json::from_reader(&mut stream) {\n                     Err(e) => fail!(\"Couldn't parse workcache database (from file {}): {}\",\n                                     self.db_filename.display(), e.to_str()),\n                     Ok(r) => {\n                         let mut decoder = json::Decoder::new(r);\n                         self.db_cache = Decodable::decode(&mut decoder);\n                     }\n+                }\n             }\n         }\n     }"}, {"sha": "c185b5cda34b7b136b2b5572cc88f124fe3c68b7", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -295,7 +295,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n          middle::liveness::check_crate(ty_cx, method_map,\n                                        capture_map, crate));\n \n-    let (root_map, write_guard_map) =\n+    let root_map =\n         time(time_passes, \"borrow checking\", (), |_|\n              middle::borrowck::check_crate(ty_cx, method_map,\n                                            moves_map, moved_variables_set,\n@@ -330,7 +330,6 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n             root_map: root_map,\n             method_map: method_map,\n             vtable_map: vtable_map,\n-            write_guard_map: write_guard_map,\n             capture_map: capture_map\n         },\n         reachable: reachable_map\n@@ -464,9 +463,19 @@ fn write_out_deps(sess: Session, input: &input, outputs: &OutputFilenames, crate\n \n     // Build a list of files used to compile the output and\n     // write Makefile-compatible dependency rules\n-    let files: ~[@str] = sess.codemap.files.iter()\n-        .filter_map(|fmap| if fmap.is_real_file() { Some(fmap.name) } else { None })\n-        .collect();\n+    let files: ~[@str] = {\n+        let files = sess.codemap.files.borrow();\n+        files.get()\n+             .iter()\n+             .filter_map(|fmap| {\n+                 if fmap.is_real_file() {\n+                     Some(fmap.name)\n+                 } else {\n+                     None\n+                 }\n+             })\n+             .collect()\n+    };\n     let mut file = io::File::create(&deps_filename);\n     for path in out_filenames.iter() {\n         write!(&mut file as &mut Writer,\n@@ -517,20 +526,20 @@ impl pprust::pp_ann for IdentifiedAnnotation {\n     fn post(&self, node: pprust::ann_node) {\n         match node {\n             pprust::node_item(s, item) => {\n-                pp::space(s.s);\n+                pp::space(&mut s.s);\n                 pprust::synth_comment(s, item.id.to_str());\n             }\n-            pprust::node_block(s, ref blk) => {\n-                pp::space(s.s);\n+            pprust::node_block(s, blk) => {\n+                pp::space(&mut s.s);\n                 pprust::synth_comment(s, ~\"block \" + blk.id.to_str());\n             }\n             pprust::node_expr(s, expr) => {\n-                pp::space(s.s);\n+                pp::space(&mut s.s);\n                 pprust::synth_comment(s, expr.id.to_str());\n                 pprust::pclose(s);\n             }\n             pprust::node_pat(s, pat) => {\n-                pp::space(s.s);\n+                pp::space(&mut s.s);\n                 pprust::synth_comment(s, ~\"pat \" + pat.id.to_str());\n             }\n         }\n@@ -552,10 +561,10 @@ impl pprust::pp_ann for TypedAnnotation {\n         let tcx = self.analysis.ty_cx;\n         match node {\n             pprust::node_expr(s, expr) => {\n-                pp::space(s.s);\n-                pp::word(s.s, \"as\");\n-                pp::space(s.s);\n-                pp::word(s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n+                pp::space(&mut s.s);\n+                pp::word(&mut s.s, \"as\");\n+                pp::space(&mut s.s);\n+                pp::word(&mut s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n                 pprust::pclose(s);\n             }\n             _ => ()\n@@ -592,15 +601,15 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let src = sess.codemap.get_filemap(source_name(input)).src;\n-    let rdr = @mut MemReader::new(src.as_bytes().to_owned());\n+    let mut rdr = MemReader::new(src.as_bytes().to_owned());\n     let stdout = io::stdout();\n     pprust::print_crate(sess.codemap,\n                         token::get_ident_interner(),\n                         sess.span_diagnostic,\n                         &crate,\n                         source_name(input),\n-                        rdr as @mut io::Reader,\n-                        @mut stdout as @mut io::Writer,\n+                        &mut rdr,\n+                        ~stdout as ~io::Writer,\n                         annotation,\n                         is_expanded);\n }\n@@ -883,7 +892,7 @@ pub fn build_session(sopts: @session::options, demitter: @diagnostic::Emitter)\n pub fn build_session_(sopts: @session::options,\n                       cm: @codemap::CodeMap,\n                       demitter: @diagnostic::Emitter,\n-                      span_diagnostic_handler: @mut diagnostic::SpanHandler)\n+                      span_diagnostic_handler: @diagnostic::SpanHandler)\n                       -> Session {\n     let target_cfg = build_target_config(sopts, demitter);\n     let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler,"}, {"sha": "4295d14441eea37b2ff6e4b84c157933c4ede001", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -204,12 +204,12 @@ pub struct Session_ {\n     targ_cfg: @config,\n     opts: @options,\n     cstore: @metadata::cstore::CStore,\n-    parse_sess: @mut ParseSess,\n+    parse_sess: @ParseSess,\n     codemap: @codemap::CodeMap,\n     // For a library crate, this is always none\n     entry_fn: RefCell<Option<(NodeId, codemap::Span)>>,\n     entry_type: Cell<Option<EntryFnType>>,\n-    span_diagnostic: @mut diagnostic::SpanHandler,\n+    span_diagnostic: @diagnostic::SpanHandler,\n     filesearch: @filesearch::FileSearch,\n     building_library: Cell<bool>,\n     working_dir: Path,\n@@ -292,7 +292,7 @@ impl Session_ {\n \n         v\n     }\n-    pub fn diagnostic(&self) -> @mut diagnostic::SpanHandler {\n+    pub fn diagnostic(&self) -> @diagnostic::SpanHandler {\n         self.span_diagnostic\n     }\n     pub fn debugging_opt(&self, opt: uint) -> bool {"}, {"sha": "fa0be72b83036570afa3fd0fe9d6f674588475b5", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -189,9 +189,8 @@ impl Visitor<()> for Context {\n \n     fn visit_expr(&mut self, e: @ast::Expr, _: ()) {\n         match e.node {\n-            ast::ExprUnary(_, ast::UnBox(..), _) |\n-            ast::ExprVstore(_, ast::ExprVstoreBox) |\n-            ast::ExprVstore(_, ast::ExprVstoreMutBox) => {\n+            ast::ExprUnary(_, ast::UnBox, _) |\n+            ast::ExprVstore(_, ast::ExprVstoreBox) => {\n                 self.gate_box(e.span);\n             }\n             _ => {}"}, {"sha": "cb6d5e3c99ce71db38ca05923024700d7a703901", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -86,7 +86,7 @@ fn dump_crates(crate_cache: &[cache_entry]) {\n }\n \n fn warn_if_multiple_versions(e: &mut Env,\n-                             diag: @mut SpanHandler,\n+                             diag: @SpanHandler,\n                              crate_cache: &[cache_entry]) {\n     if crate_cache.len() != 0u {\n         let name = crate_cache[crate_cache.len() - 1].crateid.name.clone();"}, {"sha": "4592b88a0fa083fc51a7a8dc2637152b0e0ee265", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -57,7 +57,7 @@ pub type encode_inlined_item<'a> = 'a |ecx: &EncodeContext,\n                                              ii: ast::inlined_item|;\n \n pub struct EncodeParams<'a> {\n-    diag: @mut SpanHandler,\n+    diag: @SpanHandler,\n     tcx: ty::ctxt,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: &'a RefCell<HashMap<ast::NodeId, ~str>>,\n@@ -83,7 +83,7 @@ struct Stats {\n }\n \n pub struct EncodeContext<'a> {\n-    diag: @mut SpanHandler,\n+    diag: @SpanHandler,\n     tcx: ty::ctxt,\n     stats: @Stats,\n     reexports2: middle::resolve::ExportMap2,\n@@ -489,7 +489,8 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n                                     ebml_w: &mut writer::Encoder,\n                                     mod_path: &[ast_map::path_elt],\n                                     exp: &middle::resolve::Export2) {\n-    match ecx.tcx.items.find(&exp.def_id.node) {\n+    let items = ecx.tcx.items.borrow();\n+    match items.get().find(&exp.def_id.node) {\n         Some(&ast_map::node_item(item, path)) => {\n             let original_name = ecx.tcx.sess.str_of(item.ident);\n \n@@ -1338,7 +1339,8 @@ fn my_visit_item(i: @item,\n                  ebml_w: &mut writer::Encoder,\n                  ecx_ptr: *int,\n                  index: @RefCell<~[entry<i64>]>) {\n-    match items.get_copy(&i.id) {\n+    let items = items.borrow();\n+    match items.get().get_copy(&i.id) {\n         ast_map::node_item(_, pt) => {\n             let mut ebml_w = unsafe {\n                 ebml_w.unsafe_clone()\n@@ -1356,7 +1358,8 @@ fn my_visit_foreign_item(ni: @foreign_item,\n                          ebml_w: &mut writer::Encoder,\n                          ecx_ptr:*int,\n                          index: @RefCell<~[entry<i64>]>) {\n-    match items.get_copy(&ni.id) {\n+    let items = items.borrow();\n+    match items.get().get_copy(&ni.id) {\n         ast_map::node_foreign_item(_, abi, _, pt) => {\n             debug!(\"writing foreign item {}::{}\",\n                    ast_map::path_to_str("}, {"sha": "d4f940ab486083497baaf3568b7c362af0220131", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -231,8 +231,7 @@ impl Context {\n     }\n }\n \n-pub fn note_crateid_attr(diag: @mut SpanHandler,\n-                         crateid: &CrateId) {\n+pub fn note_crateid_attr(diag: @SpanHandler, crateid: &CrateId) {\n     diag.handler().note(format!(\"crate_id: {}\", crateid.to_str()));\n }\n "}, {"sha": "f0cb4533968855352a5d13f352aea658ce68b60f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -342,7 +342,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         let did = parse_def(st, TypeParameter, |x,y| conv(x,y));\n         return ty::mk_self(st.tcx, did);\n       }\n-      '@' => return ty::mk_box(st.tcx, parse_mt(st, |x,y| conv(x,y))),\n+      '@' => return ty::mk_box(st.tcx, parse_ty(st, |x,y| conv(x,y))),\n       '~' => return ty::mk_uniq(st.tcx, parse_mt(st, |x,y| conv(x,y))),\n       '*' => return ty::mk_ptr(st.tcx, parse_mt(st, |x,y| conv(x,y))),\n       '&' => {"}, {"sha": "2ba4038e5b4404a89e6b9143f8eeb911baa07929", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -32,7 +32,7 @@ macro_rules! mywrite( ($wr:expr, $($arg:tt)*) => (\n ) )\n \n pub struct ctxt {\n-    diag: @mut SpanHandler,\n+    diag: @SpanHandler,\n     // Def -> str Callback:\n     ds: extern \"Rust\" fn(DefId) -> ~str,\n     // The type context.\n@@ -292,7 +292,7 @@ fn enc_sty(w: &mut MemWriter, cx: @ctxt, st: &ty::sty) {\n             for t in ts.iter() { enc_ty(w, cx, *t); }\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_box(mt) => { mywrite!(w, \"@\"); enc_mt(w, cx, mt); }\n+        ty::ty_box(typ) => { mywrite!(w, \"@\"); enc_ty(w, cx, typ); }\n         ty::ty_uniq(mt) => { mywrite!(w, \"~\"); enc_mt(w, cx, mt); }\n         ty::ty_ptr(mt) => { mywrite!(w, \"*\"); enc_mt(w, cx, mt); }\n         ty::ty_rptr(r, mt) => {"}, {"sha": "2e18b9a7244822581e705a1b397d76f937519389", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -55,7 +55,6 @@ pub struct Maps {\n     root_map: middle::borrowck::root_map,\n     method_map: middle::typeck::method_map,\n     vtable_map: middle::typeck::vtable_map,\n-    write_guard_map: middle::borrowck::write_guard_map,\n     capture_map: middle::moves::CaptureMap,\n }\n \n@@ -1429,18 +1428,18 @@ fn decode_item_ast(par_doc: ebml::Doc) -> @ast::item {\n #[cfg(test)]\n trait fake_ext_ctxt {\n     fn cfg(&self) -> ast::CrateConfig;\n-    fn parse_sess(&self) -> @mut parse::ParseSess;\n+    fn parse_sess(&self) -> @parse::ParseSess;\n     fn call_site(&self) -> Span;\n     fn ident_of(&self, st: &str) -> ast::Ident;\n }\n \n #[cfg(test)]\n-type fake_session = @mut parse::ParseSess;\n+type fake_session = @parse::ParseSess;\n \n #[cfg(test)]\n impl fake_ext_ctxt for fake_session {\n     fn cfg(&self) -> ast::CrateConfig { ~[] }\n-    fn parse_sess(&self) -> @mut parse::ParseSess { *self }\n+    fn parse_sess(&self) -> @parse::ParseSess { *self }\n     fn call_site(&self) -> Span {\n         codemap::Span {\n             lo: codemap::BytePos(0),"}, {"sha": "c26efbcb498962e29b7d16274d9b05f37e31fe7d", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -368,11 +368,15 @@ impl<'a> CheckLoanCtxt<'a> {\n                         cmt = b;\n                     }\n \n+                    mc::cat_deref(_, _, mc::gc_ptr) => {\n+                        assert_eq!(cmt.mutbl, mc::McImmutable);\n+                        return;\n+                    }\n+\n                     mc::cat_rvalue(..) |\n                     mc::cat_static_item |\n                     mc::cat_copied_upvar(..) |\n                     mc::cat_deref(_, _, mc::unsafe_ptr(..)) |\n-                    mc::cat_deref(_, _, mc::gc_ptr(..)) |\n                     mc::cat_deref(_, _, mc::region_ptr(..)) => {\n                         assert_eq!(cmt.mutbl, mc::McDeclared);\n                         return;\n@@ -411,20 +415,6 @@ impl<'a> CheckLoanCtxt<'a> {\n                     check_for_aliasability_violation(this, expr, b);\n                 }\n \n-                mc::cat_deref(_, deref_count, mc::gc_ptr(ast::MutMutable)) => {\n-                    // Dynamically check writes to `@mut`\n-\n-                    let key = root_map_key {\n-                        id: guarantor.id,\n-                        derefs: deref_count\n-                    };\n-                    debug!(\"Inserting write guard at {:?}\", key);\n-                    let mut write_guard_map = this.bccx\n-                                                  .write_guard_map\n-                                                  .borrow_mut();\n-                    write_guard_map.get().insert(key);\n-                }\n-\n                 _ => {}\n             }\n \n@@ -455,7 +445,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                     mc::cat_self(..) |\n                     mc::cat_deref(_, _, mc::unsafe_ptr(..)) |\n                     mc::cat_static_item(..) |\n-                    mc::cat_deref(_, _, mc::gc_ptr(_)) |\n+                    mc::cat_deref(_, _, mc::gc_ptr) |\n                     mc::cat_deref(_, _, mc::region_ptr(MutImmutable, _)) => {\n                         // Aliasability is independent of base cmt\n                         match cmt.freely_aliasable() {"}, {"sha": "3b16d7e7e1c63c4eba7748729391f9cbf2e0d855", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -102,7 +102,7 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n                                cmt: mc::cmt) -> bool {\n     match cmt.cat {\n         mc::cat_deref(_, _, mc::region_ptr(..)) |\n-        mc::cat_deref(_, _, mc::gc_ptr(..)) |\n+        mc::cat_deref(_, _, mc::gc_ptr) |\n         mc::cat_deref(_, _, mc::unsafe_ptr(..)) |\n         mc::cat_stack_upvar(..) |\n         mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Many, .. }) => {"}, {"sha": "9a56ec52cce289140cd6a27f49b51f9e4a13ae12", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 5, "deletions": 40, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -16,10 +16,8 @@\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;\n-use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;\n-use util::ppaux::{note_and_explain_region};\n \n type R = Result<(),()>;\n \n@@ -89,12 +87,11 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n                 Ok(())\n             }\n \n-            mc::cat_deref(base, derefs, mc::gc_ptr(ptr_mutbl)) => {\n+            mc::cat_deref(base, derefs, mc::gc_ptr) => {\n                 let base_scope = self.scope(base);\n \n                 // L-Deref-Managed-Imm-User-Root\n                 let omit_root = (\n-                    ptr_mutbl == MutImmutable &&\n                     self.bccx.is_subregion_of(self.loan_region, base_scope) &&\n                     self.is_rvalue_or_immutable(base) &&\n                     !self.is_moved(base)\n@@ -103,7 +100,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n                 if !omit_root {\n                     // L-Deref-Managed-Imm-Compiler-Root\n                     // L-Deref-Managed-Mut-Compiler-Root\n-                    self.check_root(cmt, base, derefs, ptr_mutbl, discr_scope)\n+                    self.check_root(cmt, base, derefs, discr_scope)\n                 } else {\n                     debug!(\"omitting root, base={}, base_scope={:?}\",\n                            base.repr(self.tcx()), base_scope);\n@@ -192,14 +189,12 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n                   cmt_deref: mc::cmt,\n                   cmt_base: mc::cmt,\n                   derefs: uint,\n-                  ptr_mutbl: ast::Mutability,\n                   discr_scope: Option<ast::NodeId>) -> R {\n-        debug!(\"check_root(cmt_deref={}, cmt_base={}, derefs={:?}, ptr_mutbl={:?}, \\\n+        debug!(\"check_root(cmt_deref={}, cmt_base={}, derefs={:?}, \\\n                 discr_scope={:?})\",\n                cmt_deref.repr(self.tcx()),\n                cmt_base.repr(self.tcx()),\n                derefs,\n-               ptr_mutbl,\n                discr_scope);\n \n         // Make sure that the loan does not exceed the maximum time\n@@ -235,19 +230,6 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             }\n         };\n \n-        // If we are borrowing the inside of an `@mut` box,\n-        // we need to dynamically mark it to prevent incompatible\n-        // borrows from happening later.\n-        let opt_dyna = match ptr_mutbl {\n-            MutImmutable => None,\n-            MutMutable => {\n-                match self.loan_mutbl {\n-                    MutableMutability => Some(DynaMut),\n-                    ImmutableMutability | ConstMutability => Some(DynaImm)\n-                }\n-            }\n-        };\n-\n         // FIXME(#3511) grow to the nearest cleanup scope---this can\n         // cause observable errors if freezing!\n         if !self.bccx.tcx.region_maps.is_cleanup_scope(root_scope) {\n@@ -256,29 +238,12 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             let cleanup_scope =\n                 self.bccx.tcx.region_maps.cleanup_scope(root_scope);\n \n-            if opt_dyna.is_some() {\n-                self.tcx().sess.span_warn(\n-                    self.span,\n-                    format!(\"Dynamic freeze scope artifically extended \\\n-                          (see Issue \\\\#6248)\"));\n-                note_and_explain_region(\n-                    self.bccx.tcx,\n-                    \"managed value only needs to be frozen for \",\n-                    ty::ReScope(root_scope),\n-                    \"...\");\n-                note_and_explain_region(\n-                    self.bccx.tcx,\n-                    \"...but due to Issue #6248, it will be frozen for \",\n-                    ty::ReScope(cleanup_scope),\n-                    \"\");\n-            }\n-\n             root_scope = cleanup_scope;\n         }\n \n         // Add a record of what is required\n         let rm_key = root_map_key {id: cmt_deref.id, derefs: derefs};\n-        let root_info = RootInfo {scope: root_scope, freeze: opt_dyna};\n+        let root_info = RootInfo {scope: root_scope};\n \n         let mut root_map = self.bccx.root_map.borrow_mut();\n         root_map.get().insert(rm_key, root_info);\n@@ -357,7 +322,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             }\n             mc::cat_downcast(cmt) |\n             mc::cat_deref(cmt, _, mc::uniq_ptr) |\n-            mc::cat_deref(cmt, _, mc::gc_ptr(..)) |\n+            mc::cat_deref(cmt, _, mc::gc_ptr) |\n             mc::cat_interior(cmt, _) |\n             mc::cat_stack_upvar(cmt) |\n             mc::cat_discr(cmt, _) => {"}, {"sha": "50b437e95d5d16f5e94064a99b6fb9f6bd556bf7", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 49, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -132,59 +132,11 @@ impl<'a> RestrictionsContext<'a> {\n                 Safe\n             }\n \n-            mc::cat_deref(_, _, mc::gc_ptr(MutImmutable)) => {\n+            mc::cat_deref(_, _, mc::gc_ptr) => {\n                 // R-Deref-Imm-Managed\n                 Safe\n             }\n \n-            mc::cat_deref(cmt_base, _, pk @ mc::gc_ptr(MutMutable)) => {\n-                // R-Deref-Managed-Borrowed\n-                //\n-                // Technically, no restrictions are *necessary* here.\n-                // The validity of the borrow is guaranteed\n-                // dynamically.  However, nonetheless we add a\n-                // restriction to make a \"best effort\" to report\n-                // static errors. For example, if there is code like\n-                //\n-                //    let v = @mut ~[1, 2, 3];\n-                //    for e in v.iter() {\n-                //        v.push(e + 1);\n-                //    }\n-                //\n-                // Then the code below would add restrictions on `*v`,\n-                // which means that an error would be reported\n-                // here. This of course is not perfect. For example,\n-                // a function like the following would not report an error\n-                // at compile-time but would fail dynamically:\n-                //\n-                //    let v = @mut ~[1, 2, 3];\n-                //    let w = v;\n-                //    for e in v.iter() {\n-                //        w.push(e + 1);\n-                //    }\n-                //\n-                // In addition, we only add a restriction for those cases\n-                // where we can construct a sensible loan path, so an\n-                // example like the following will fail dynamically:\n-                //\n-                //    impl V {\n-                //      fn get_list(&self) -> @mut ~[int];\n-                //    }\n-                //    ...\n-                //    let v: &V = ...;\n-                //    for e in v.get_list().iter() {\n-                //        v.get_list().push(e + 1);\n-                //    }\n-                match opt_loan_path(cmt_base) {\n-                    None => Safe,\n-                    Some(lp_base) => {\n-                        let lp = @LpExtend(lp_base, cmt.mutbl, LpDeref(pk));\n-                        SafeIf(lp, ~[Restriction {loan_path: lp,\n-                                                  set: restrictions}])\n-                    }\n-                }\n-            }\n-\n             mc::cat_deref(cmt_base, _, pk @ mc::region_ptr(MutMutable, lt)) => {\n                 // R-Deref-Mut-Borrowed\n                 if !self.bccx.is_subregion_of(self.loan_region, lt) {"}, {"sha": "6193c6fc898822c24874d41e5f9a0a78bd1ec35c", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 14, "deletions": 46, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -20,7 +20,7 @@ use middle::dataflow::DataFlowOperator;\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n use std::cell::{Cell, RefCell};\n-use std::hashmap::{HashSet, HashMap};\n+use std::hashmap::HashMap;\n use std::ops::{BitOr, BitAnd};\n use std::result::{Result};\n use syntax::ast;\n@@ -67,22 +67,20 @@ impl Visitor<()> for BorrowckCtxt {\n     }\n }\n \n-pub fn check_crate(\n-    tcx: ty::ctxt,\n-    method_map: typeck::method_map,\n-    moves_map: moves::MovesMap,\n-    moved_variables_set: moves::MovedVariablesSet,\n-    capture_map: moves::CaptureMap,\n-    crate: &ast::Crate) -> (root_map, write_guard_map)\n-{\n+pub fn check_crate(tcx: ty::ctxt,\n+                   method_map: typeck::method_map,\n+                   moves_map: moves::MovesMap,\n+                   moved_variables_set: moves::MovedVariablesSet,\n+                   capture_map: moves::CaptureMap,\n+                   crate: &ast::Crate)\n+                   -> root_map {\n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n         method_map: method_map,\n         moves_map: moves_map,\n         moved_variables_set: moved_variables_set,\n         capture_map: capture_map,\n         root_map: root_map(),\n-        write_guard_map: @RefCell::new(HashSet::new()),\n         stats: @BorrowStats {\n             loaned_paths_same: Cell::new(0),\n             loaned_paths_imm: Cell::new(0),\n@@ -106,7 +104,7 @@ pub fn check_crate(\n                  make_stat(bccx, bccx.stats.stable_paths.get()));\n     }\n \n-    return (bccx.root_map, bccx.write_guard_map);\n+    return bccx.root_map;\n \n     fn make_stat(bccx: &mut BorrowckCtxt, stat: uint) -> ~str {\n         let stat_f = stat as f64;\n@@ -171,7 +169,6 @@ pub struct BorrowckCtxt {\n     moved_variables_set: moves::MovedVariablesSet,\n     capture_map: moves::CaptureMap,\n     root_map: root_map,\n-    write_guard_map: write_guard_map,\n \n     // Statistics:\n     stats: @BorrowStats\n@@ -213,10 +210,6 @@ pub struct root_map_key {\n     derefs: uint\n }\n \n-// A set containing IDs of expressions of gc'd type that need to have a write\n-// guard.\n-pub type write_guard_map = @RefCell<HashSet<root_map_key>>;\n-\n pub type BckResult<T> = Result<T, BckError>;\n \n #[deriving(Eq)]\n@@ -402,7 +395,6 @@ impl BitAnd<RestrictionSet,RestrictionSet> for RestrictionSet {\n \n pub struct RootInfo {\n     scope: ast::NodeId,\n-    freeze: Option<DynaFreezeKind> // Some() if we should freeze box at runtime\n }\n \n pub type root_map = @RefCell<HashMap<root_map_key, RootInfo>>;\n@@ -411,20 +403,6 @@ pub fn root_map() -> root_map {\n     return @RefCell::new(HashMap::new());\n }\n \n-pub enum DynaFreezeKind {\n-    DynaImm,\n-    DynaMut\n-}\n-\n-impl ToStr for DynaFreezeKind {\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-            DynaMut => ~\"mutable\",\n-            DynaImm => ~\"immutable\"\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Errors\n \n@@ -691,20 +669,9 @@ impl BorrowckCtxt {\n                     span,\n                     format!(\"{} in an aliasable location\", prefix));\n             }\n-            mc::AliasableManaged(ast::MutMutable) => {\n-                // FIXME(#6269) reborrow @mut to &mut\n-                self.tcx.sess.span_err(\n-                    span,\n-                    format!(\"{} in a `@mut` pointer; \\\n-                          try borrowing as `&mut` first\", prefix));\n-            }\n-            mc::AliasableManaged(m) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    format!(\"{} in a `@{}` pointer; \\\n-                          try an `@mut` instead\",\n-                         prefix,\n-                         self.mut_to_keyword(m)));\n+            mc::AliasableManaged => {\n+                self.tcx.sess.span_err(span, format!(\"{} in a `@` pointer\",\n+                                                     prefix))\n             }\n             mc::AliasableBorrowed(m) => {\n                 self.tcx.sess.span_err(\n@@ -788,7 +755,8 @@ impl BorrowckCtxt {\n                                    out: &mut ~str) {\n         match *loan_path {\n             LpVar(id) => {\n-                match self.tcx.items.find(&id) {\n+                let items = self.tcx.items.borrow();\n+                match items.get().find(&id) {\n                     Some(&ast_map::node_local(ref ident)) => {\n                         out.push_str(token::ident_to_str(ident));\n                     }"}, {"sha": "c56a268c48fd318f43bb83090a1367c8604776ab", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -116,7 +116,7 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n     if is_const {\n         match e.node {\n           ExprUnary(_, UnDeref, _) => { }\n-          ExprUnary(_, UnBox(_), _) | ExprUnary(_, UnUniq, _) => {\n+          ExprUnary(_, UnBox, _) | ExprUnary(_, UnUniq, _) => {\n             sess.span_err(e.span,\n                           \"cannot do allocations in constant expressions\");\n             return;\n@@ -197,8 +197,7 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n                      immutable values\");\n           },\n           ExprVstore(_, ExprVstoreUniq) |\n-          ExprVstore(_, ExprVstoreBox) |\n-          ExprVstore(_, ExprVstoreMutBox) => {\n+          ExprVstore(_, ExprVstoreBox) => {\n               sess.span_err(e.span, \"cannot allocate vectors in constant expressions\")\n           },\n \n@@ -266,13 +265,15 @@ impl Visitor<()> for CheckItemRecursionVisitor {\n                 let def_map = self.env.def_map.borrow();\n                 match def_map.get().find(&e.id) {\n                     Some(&DefStatic(def_id, _)) if\n-                            ast_util::is_local(def_id) =>\n-                        match self.env.ast_map.get_copy(&def_id.node) {\n+                            ast_util::is_local(def_id) => {\n+                        let ast_map = self.env.ast_map.borrow();\n+                        match ast_map.get().get_copy(&def_id.node) {\n                             ast_map::node_item(it, _) => {\n                                 self.visit_item(it, ());\n                             }\n                             _ => fail!(\"const not bound to an item\")\n-                        },\n+                        }\n+                    }\n                     _ => ()\n                 }\n             },"}, {"sha": "20db51861d670b7f977020999f953a67502cb4fb", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -20,7 +20,7 @@ use syntax::visit::Visitor;\n use syntax::ast::*;\n \n use std::cell::RefCell;\n-use std::hashmap::{HashMap, HashSet};\n+use std::hashmap::HashMap;\n \n //\n // This pass classifies expressions by their constant-ness.\n@@ -107,15 +107,18 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n     }\n \n     if ast_util::is_local(enum_def) {\n-        match tcx.items.find(&enum_def.node) {\n-            None => None,\n-            Some(&ast_map::node_item(it, _)) => match it.node {\n-                item_enum(ast::enum_def { variants: ref variants }, _) => {\n-                    variant_expr(*variants, variant_def.node)\n-                }\n-                _ => None\n-            },\n-            Some(_) => None\n+        {\n+            let items = tcx.items.borrow();\n+            match items.get().find(&enum_def.node) {\n+                None => None,\n+                Some(&ast_map::node_item(it, _)) => match it.node {\n+                    item_enum(ast::enum_def { variants: ref variants }, _) => {\n+                        variant_expr(*variants, variant_def.node)\n+                    }\n+                    _ => None\n+                },\n+                Some(_) => None\n+            }\n         }\n     } else {\n         {\n@@ -129,7 +132,6 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n             root_map: @RefCell::new(HashMap::new()),\n             method_map: @RefCell::new(HashMap::new()),\n             vtable_map: @RefCell::new(HashMap::new()),\n-            write_guard_map: @RefCell::new(HashSet::new()),\n             capture_map: @RefCell::new(HashMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, enum_def,\n@@ -155,17 +157,21 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n     }\n }\n \n-pub fn lookup_const_by_id(tcx: ty::ctxt,\n-                          def_id: ast::DefId)\n-                       -> Option<@Expr> {\n+pub fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::DefId)\n+                          -> Option<@Expr> {\n     if ast_util::is_local(def_id) {\n-        match tcx.items.find(&def_id.node) {\n-            None => None,\n-            Some(&ast_map::node_item(it, _)) => match it.node {\n-                item_static(_, ast::MutImmutable, const_expr) => Some(const_expr),\n-                _ => None\n-            },\n-            Some(_) => None\n+        {\n+            let items = tcx.items.borrow();\n+            match items.get().find(&def_id.node) {\n+                None => None,\n+                Some(&ast_map::node_item(it, _)) => match it.node {\n+                    item_static(_, ast::MutImmutable, const_expr) => {\n+                        Some(const_expr)\n+                    }\n+                    _ => None\n+                },\n+                Some(_) => None\n+            }\n         }\n     } else {\n         {\n@@ -179,7 +185,6 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n             root_map: @RefCell::new(HashMap::new()),\n             method_map: @RefCell::new(HashMap::new()),\n             vtable_map: @RefCell::new(HashMap::new()),\n-            write_guard_map: @RefCell::new(HashSet::new()),\n             capture_map: @RefCell::new(HashMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, def_id,\n@@ -234,7 +239,6 @@ impl ConstEvalVisitor {\n                     ast::ExprVstoreSlice => self.classify(e),\n                     ast::ExprVstoreUniq |\n                     ast::ExprVstoreBox |\n-                    ast::ExprVstoreMutBox |\n                     ast::ExprVstoreMutSlice => non_const\n                 }\n             }"}, {"sha": "b0ca03181f8d1a1a203f2095be93238a2f34bdd3", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -118,7 +118,7 @@ impl<O:DataFlowOperator> pprust::pp_ann for DataFlowContext<O> {\n             let comment_str = format!(\"id {}: {}{}{}\",\n                                       id, entry_str, gens_str, kills_str);\n             pprust::synth_comment(ps, comment_str);\n-            pp::space(ps.s);\n+            pp::space(&mut ps.s);\n         }\n     }\n }\n@@ -347,19 +347,19 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n         debug!(\"Dataflow result:\");\n         debug!(\"{}\", {\n             let this = @(*self).clone();\n-            this.pretty_print_to(@mut io::stderr() as @mut io::Writer, blk);\n+            this.pretty_print_to(~io::stderr() as ~io::Writer, blk);\n             \"\"\n         });\n     }\n \n-    fn pretty_print_to(@self, wr: @mut io::Writer, blk: &ast::Block) {\n-        let ps = pprust::rust_printer_annotated(wr,\n-                                                self.tcx.sess.intr(),\n-                                                self as @pprust::pp_ann);\n-        pprust::cbox(ps, pprust::indent_unit);\n-        pprust::ibox(ps, 0u);\n-        pprust::print_block(ps, blk);\n-        pp::eof(ps.s);\n+    fn pretty_print_to(@self, wr: ~io::Writer, blk: &ast::Block) {\n+        let mut ps = pprust::rust_printer_annotated(wr,\n+                                                    self.tcx.sess.intr(),\n+                                                    self as @pprust::pp_ann);\n+        pprust::cbox(&mut ps, pprust::indent_unit);\n+        pprust::ibox(&mut ps, 0u);\n+        pprust::print_block(&mut ps, blk);\n+        pp::eof(&mut ps.s);\n     }\n }\n "}, {"sha": "2bdbce9b763c567a022e06f77e160886eca25e2c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -34,7 +34,9 @@ fn should_explore(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n     if !is_local(def_id) {\n         return false;\n     }\n-    match tcx.items.find(&def_id.node) {\n+\n+    let items = tcx.items.borrow();\n+    match items.get().find(&def_id.node) {\n         Some(&ast_map::node_item(..))\n         | Some(&ast_map::node_method(..))\n         | Some(&ast_map::node_foreign_item(..))\n@@ -130,7 +132,9 @@ impl MarkSymbolVisitor {\n                 continue\n             }\n             scanned.insert(id);\n-            match self.tcx.items.find(&id) {\n+\n+            let items = self.tcx.items.borrow();\n+            match items.get().find(&id) {\n                 Some(node) => {\n                     self.live_symbols.insert(id);\n                     self.visit_node(node);"}, {"sha": "89cb902cf1064c6c14ce15e99f1101e334e85efe", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -74,23 +74,26 @@ fn find_item(item: @item, ctxt: &mut EntryContext) {\n     match item.node {\n         item_fn(..) => {\n             if item.ident.name == special_idents::main.name {\n-                match ctxt.ast_map.find(&item.id) {\n-                    Some(&ast_map::node_item(_, path)) => {\n-                        if path.len() == 0 {\n-                            // This is a top-level function so can be 'main'\n-                            if ctxt.main_fn.is_none() {\n-                                ctxt.main_fn = Some((item.id, item.span));\n+                {\n+                    let ast_map = ctxt.ast_map.borrow();\n+                    match ast_map.get().find(&item.id) {\n+                        Some(&ast_map::node_item(_, path)) => {\n+                            if path.len() == 0 {\n+                                // This is a top-level function so can be 'main'\n+                                if ctxt.main_fn.is_none() {\n+                                    ctxt.main_fn = Some((item.id, item.span));\n+                                } else {\n+                                    ctxt.session.span_err(\n+                                        item.span,\n+                                        \"multiple 'main' functions\");\n+                                }\n                             } else {\n-                                ctxt.session.span_err(\n-                                    item.span,\n-                                    \"multiple 'main' functions\");\n+                                // This isn't main\n+                                ctxt.non_main_fns.push((item.id, item.span));\n                             }\n-                        } else {\n-                            // This isn't main\n-                            ctxt.non_main_fns.push((item.id, item.span));\n                         }\n+                        _ => unreachable!()\n                     }\n-                    _ => unreachable!()\n                 }\n             }\n "}, {"sha": "49e57306c1216eda24f64cca2e9c96e3d333f774", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -306,7 +306,7 @@ pub fn check_expr(cx: &mut Context, e: @Expr) {\n     }\n \n     match e.node {\n-        ExprUnary(_, UnBox(_), interior) => {\n+        ExprUnary(_, UnBox, interior) => {\n             let interior_type = ty::expr_ty(cx.tcx, interior);\n             let _ = check_durable(cx.tcx, interior_type, interior.span);\n         }"}, {"sha": "8e86fa4611f2b15f4a7def3fbc870221ba864aa7", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -207,7 +207,7 @@ pub fn collect_language_items(crate: &ast::Crate,\n }\n \n lets_do_this! {\n-    There are 43 lang items.\n+    There are 37 lang items.\n \n //  ID, Variant name,                    Name,                      Method name;\n     0,  FreezeTraitLangItem,             \"freeze\",                  freeze_trait;\n@@ -243,24 +243,18 @@ lets_do_this! {\n     26, ExchangeFreeFnLangItem,          \"exchange_free\",           exchange_free_fn;\n     27, MallocFnLangItem,                \"malloc\",                  malloc_fn;\n     28, FreeFnLangItem,                  \"free\",                    free_fn;\n-    29, BorrowAsImmFnLangItem,           \"borrow_as_imm\",           borrow_as_imm_fn;\n-    30, BorrowAsMutFnLangItem,           \"borrow_as_mut\",           borrow_as_mut_fn;\n-    31, ReturnToMutFnLangItem,           \"return_to_mut\",           return_to_mut_fn;\n-    32, CheckNotBorrowedFnLangItem,      \"check_not_borrowed\",      check_not_borrowed_fn;\n-    33, StrDupUniqFnLangItem,            \"strdup_uniq\",             strdup_uniq_fn;\n-    34, RecordBorrowFnLangItem,          \"record_borrow\",           record_borrow_fn;\n-    35, UnrecordBorrowFnLangItem,        \"unrecord_borrow\",         unrecord_borrow_fn;\n+    29, StrDupUniqFnLangItem,            \"strdup_uniq\",             strdup_uniq_fn;\n \n-    36, StartFnLangItem,                 \"start\",                   start_fn;\n+    30, StartFnLangItem,                 \"start\",                   start_fn;\n \n-    37, TyDescStructLangItem,            \"ty_desc\",                 ty_desc;\n-    38, TyVisitorTraitLangItem,          \"ty_visitor\",              ty_visitor;\n-    39, OpaqueStructLangItem,            \"opaque\",                  opaque;\n+    31, TyDescStructLangItem,            \"ty_desc\",                 ty_desc;\n+    32, TyVisitorTraitLangItem,          \"ty_visitor\",              ty_visitor;\n+    33, OpaqueStructLangItem,            \"opaque\",                  opaque;\n \n-    40, EventLoopFactoryLangItem,        \"event_loop_factory\",      event_loop_factory;\n+    34, EventLoopFactoryLangItem,        \"event_loop_factory\",      event_loop_factory;\n \n-    41, TypeIdLangItem,                  \"type_id\",                 type_id;\n+    35, TypeIdLangItem,                  \"type_id\",                 type_id;\n \n-    42, EhPersonalityLangItem,           \"eh_personality\",          eh_personality_fn;\n+    36, EhPersonalityLangItem,           \"eh_personality\",          eh_personality_fn;\n }\n "}, {"sha": "666c7d84a9a90e192760325fcf0091e1baa93137", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -1076,7 +1076,7 @@ fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n             }\n         }\n         ast::ExprUnary(_, ast::UnUniq, _) |\n-        ast::ExprUnary(_, ast::UnBox(..), _) => BoxAllocation,\n+        ast::ExprUnary(_, ast::UnBox, _) => BoxAllocation,\n \n         _ => return\n     };\n@@ -1246,7 +1246,8 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n \n     let stability = if ast_util::is_local(id) {\n         // this crate\n-        match cx.tcx.items.find(&id.node) {\n+        let items = cx.tcx.items.borrow();\n+        match items.get().find(&id.node) {\n             Some(ast_node) => {\n                 let s = ast_node.with_attrs(|attrs| {\n                     attrs.map(|a| {"}, {"sha": "8459581dba49ab4db0861f6fb2ad86ede35ef82b", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -85,7 +85,7 @@ pub struct CopiedUpvar {\n #[deriving(Eq, IterBytes)]\n pub enum PointerKind {\n     uniq_ptr,\n-    gc_ptr(ast::Mutability),\n+    gc_ptr,\n     region_ptr(ast::Mutability, ty::Region),\n     unsafe_ptr(ast::Mutability)\n }\n@@ -178,17 +178,11 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n             Some(deref_ptr(region_ptr(ast::MutImmutable, r)))\n         }\n \n-        ty::ty_box(ref mt) |\n-        ty::ty_evec(ref mt, ty::vstore_box) => {\n-            Some(deref_ptr(gc_ptr(mt.mutbl)))\n-        }\n-\n-        ty::ty_trait(_, _, ty::BoxTraitStore, m, _) => {\n-            Some(deref_ptr(gc_ptr(m)))\n-        }\n-\n+        ty::ty_box(_) |\n+        ty::ty_evec(_, ty::vstore_box) |\n+        ty::ty_trait(_, _, ty::BoxTraitStore, _, _) |\n         ty::ty_estr(ty::vstore_box) => {\n-            Some(deref_ptr(gc_ptr(ast::MutImmutable)))\n+            Some(deref_ptr(gc_ptr))\n         }\n \n         ty::ty_ptr(ref mt) => {\n@@ -681,7 +675,10 @@ impl mem_categorization_ctxt {\n                     uniq_ptr => {\n                         base_cmt.mutbl.inherit()\n                     }\n-                    gc_ptr(m) | region_ptr(m, _) | unsafe_ptr(m) => {\n+                    gc_ptr => {\n+                        McImmutable\n+                    }\n+                    region_ptr(m, _) | unsafe_ptr(m) => {\n                         MutabilityCategory::from_mutbl(m)\n                     }\n                 };\n@@ -759,12 +756,15 @@ impl mem_categorization_ctxt {\n             // for unique ptrs, we inherit mutability from the\n             // owning reference.\n             let m = match ptr {\n-              uniq_ptr => {\n-                base_cmt.mutbl.inherit()\n-              }\n-              gc_ptr(m) | region_ptr(m, _) | unsafe_ptr(m) => {\n-                MutabilityCategory::from_mutbl(m)\n-              }\n+                uniq_ptr => {\n+                    base_cmt.mutbl.inherit()\n+                }\n+                gc_ptr => {\n+                    McImmutable\n+                }\n+                region_ptr(m, _) | unsafe_ptr(m) => {\n+                    MutabilityCategory::from_mutbl(m)\n+                }\n             };\n \n             // the deref is explicit in the resulting cmt\n@@ -1103,7 +1103,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n }\n \n pub enum AliasableReason {\n-    AliasableManaged(ast::Mutability),\n+    AliasableManaged,\n     AliasableBorrowed(ast::Mutability),\n     AliasableOther\n }\n@@ -1122,7 +1122,7 @@ impl cmt_ {\n             cat_self(..) |\n             cat_arg(..) |\n             cat_deref(_, _, unsafe_ptr(..)) |\n-            cat_deref(_, _, gc_ptr(..)) |\n+            cat_deref(_, _, gc_ptr) |\n             cat_deref(_, _, region_ptr(..)) => {\n                 self\n             }\n@@ -1166,8 +1166,8 @@ impl cmt_ {\n                 Some(AliasableOther)\n             }\n \n-            cat_deref(_, _, gc_ptr(m)) => {\n-                Some(AliasableManaged(m))\n+            cat_deref(_, _, gc_ptr) => {\n+                Some(AliasableManaged)\n             }\n \n             cat_deref(_, _, region_ptr(m @ MutImmutable, _)) => {\n@@ -1229,7 +1229,7 @@ impl Repr for categorization {\n pub fn ptr_sigil(ptr: PointerKind) -> ~str {\n     match ptr {\n         uniq_ptr => ~\"~\",\n-        gc_ptr(_) => ~\"@\",\n+        gc_ptr => ~\"@\",\n         region_ptr(_, _) => ~\"&\",\n         unsafe_ptr(_) => ~\"*\"\n     }"}, {"sha": "435bdcc260747da1a660a48603358eaa5d983ae1", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -413,7 +413,8 @@ impl<'a> PrivacyVisitor<'a> {\n         let mut closest_private_id = did.node;\n         loop {\n             debug!(\"privacy - examining {}\", self.nodestr(closest_private_id));\n-            let vis = match self.tcx.items.find(&closest_private_id) {\n+            let items = self.tcx.items.borrow();\n+            let vis = match items.get().find(&closest_private_id) {\n                 // If this item is a method, then we know for sure that it's an\n                 // actual method and not a static method. The reason for this is\n                 // that these cases are only hit in the ExprMethodCall\n@@ -519,7 +520,8 @@ impl<'a> PrivacyVisitor<'a> {\n                     self.tcx.sess.span_err(span, format!(\"{} is inaccessible\",\n                                                          msg));\n                 }\n-                match self.tcx.items.find(&id) {\n+                let items = self.tcx.items.borrow();\n+                match items.get().find(&id) {\n                     Some(&ast_map::node_item(item, _)) => {\n                         let desc = match item.node {\n                             ast::item_mod(..) => \"module\","}, {"sha": "5e50017b93edda7478c5ddd7da08f81396ab61f2", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -65,10 +65,15 @@ fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::method,\n         return true\n     }\n     if is_local(impl_src) {\n-        match tcx.items.find(&impl_src.node) {\n-            Some(&ast_map::node_item(item, _)) => item_might_be_inlined(item),\n-            Some(..) | None => {\n-                tcx.sess.span_bug(method.span, \"impl did is not an item\")\n+        {\n+            let items = tcx.items.borrow();\n+            match items.get().find(&impl_src.node) {\n+                Some(&ast_map::node_item(item, _)) => {\n+                    item_might_be_inlined(item)\n+                }\n+                Some(..) | None => {\n+                    tcx.sess.span_bug(method.span, \"impl did is not an item\")\n+                }\n             }\n         }\n     } else {\n@@ -208,7 +213,8 @@ impl ReachableContext {\n         }\n \n         let node_id = def_id.node;\n-        match tcx.items.find(&node_id) {\n+        let items = tcx.items.borrow();\n+        match items.get().find(&node_id) {\n             Some(&ast_map::node_item(item, _)) => {\n                 match item.node {\n                     ast::item_fn(..) => item_might_be_inlined(item),\n@@ -229,7 +235,7 @@ impl ReachableContext {\n                     // Check the impl. If the generics on the self type of the\n                     // impl require inlining, this method does too.\n                     assert!(impl_did.crate == ast::LOCAL_CRATE);\n-                    match tcx.items.find(&impl_did.node) {\n+                    match items.get().find(&impl_did.node) {\n                         Some(&ast_map::node_item(item, _)) => {\n                             match item.node {\n                                 ast::item_impl(ref generics, _, _, _) => {\n@@ -288,7 +294,8 @@ impl ReachableContext {\n             };\n \n             scanned.insert(search_item);\n-            match self.tcx.items.find(&search_item) {\n+            let items = self.tcx.items.borrow();\n+            match items.get().find(&search_item) {\n                 Some(item) => self.propagate_node(item, search_item,\n                                                   &mut visitor),\n                 None if search_item == ast::CRATE_NODE_ID => {}"}, {"sha": "59f6fede198c8250efcea18baae9b7dd704b9f57", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -2210,10 +2210,13 @@ impl Visitor<()> for TransItemVisitor {\n \n pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n     let _icx = push_ctxt(\"trans_item\");\n-    let path = match ccx.tcx.items.get_copy(&item.id) {\n-        ast_map::node_item(_, p) => p,\n-        // tjc: ?\n-        _ => fail!(\"trans_item\"),\n+    let path = {\n+        let items = ccx.tcx.items.borrow();\n+        match items.get().get_copy(&item.id) {\n+            ast_map::node_item(_, p) => p,\n+            // tjc: ?\n+            _ => fail!(\"trans_item\"),\n+        }\n     };\n     match item.node {\n       ast::item_fn(decl, purity, _abis, ref generics, body) => {\n@@ -2508,7 +2511,10 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n         Some(v) => v,\n         None => {\n             let mut foreign = false;\n-            let item = ccx.tcx.items.get_copy(&id);\n+            let item = {\n+                let items = ccx.tcx.items.borrow();\n+                items.get().get_copy(&id)\n+            };\n             let val = match item {\n                 ast_map::node_item(i, pth) => {\n "}, {"sha": "05b3e8275a3a49f4b9a0c2e703180f2d3aa2aabf", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -360,17 +360,20 @@ pub fn trans_fn_ref_with_vtables(\n     if type_params.len() > 0 || is_default {\n         must_monomorphise = true;\n     } else if def_id.crate == ast::LOCAL_CRATE {\n-        let map_node = session::expect(\n-            ccx.sess,\n-            ccx.tcx.items.find(&def_id.node),\n-            || format!(\"local item should be in ast map\"));\n-\n-        match *map_node {\n-            ast_map::node_foreign_item(_, abis, _, _) => {\n-                must_monomorphise = abis.is_intrinsic()\n-            }\n-            _ => {\n-                must_monomorphise = false;\n+        {\n+            let items = ccx.tcx.items.borrow();\n+            let map_node = session::expect(\n+                ccx.sess,\n+                items.get().find(&def_id.node),\n+                || format!(\"local item should be in ast map\"));\n+\n+            match *map_node {\n+                ast_map::node_foreign_item(_, abis, _, _) => {\n+                    must_monomorphise = abis.is_intrinsic()\n+                }\n+                _ => {\n+                    must_monomorphise = false;\n+                }\n             }\n         }\n     } else {"}, {"sha": "973d2003ecb99b763eda789adb546deffb103e7a", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 59, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -22,12 +22,10 @@ use middle::trans::base;\n use middle::trans::build;\n use middle::trans::datum;\n use middle::trans::glue;\n-use middle::trans::write_guard;\n use middle::trans::debuginfo;\n use middle::ty::substs;\n use middle::ty;\n use middle::typeck;\n-use middle::borrowck::root_map_key;\n use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n@@ -363,27 +361,6 @@ impl CleanupFunction for ImmediateTypeDroppingCleanupFunction {\n     }\n }\n \n-/// A cleanup function that releases a write guard, returning a value to\n-/// mutable status.\n-pub struct WriteGuardReleasingCleanupFunction {\n-    root_key: root_map_key,\n-    frozen_val_ref: ValueRef,\n-    bits_val_ref: ValueRef,\n-    filename_val: ValueRef,\n-    line_val: ValueRef,\n-}\n-\n-impl CleanupFunction for WriteGuardReleasingCleanupFunction {\n-    fn clean(&self, bcx: @Block) -> @Block {\n-        write_guard::return_to_mut(bcx,\n-                                   self.root_key,\n-                                   self.frozen_val_ref,\n-                                   self.bits_val_ref,\n-                                   self.filename_val,\n-                                   self.line_val)\n-    }\n-}\n-\n /// A cleanup function that frees some memory in the garbage-collected heap.\n pub struct GCHeapFreeingCleanupFunction {\n     ptr: ValueRef,\n@@ -527,42 +504,7 @@ pub fn add_clean_temp_mem_in_scope_(bcx: @Block, scope_id: Option<ast::NodeId>,\n         grow_scope_clean(scope_info);\n     })\n }\n-pub fn add_clean_return_to_mut(bcx: @Block,\n-                               scope_id: ast::NodeId,\n-                               root_key: root_map_key,\n-                               frozen_val_ref: ValueRef,\n-                               bits_val_ref: ValueRef,\n-                               filename_val: ValueRef,\n-                               line_val: ValueRef) {\n-    //! When an `@mut` has been frozen, we have to\n-    //! call the lang-item `return_to_mut` when the\n-    //! freeze goes out of scope. We need to pass\n-    //! in both the value which was frozen (`frozen_val`) and\n-    //! the value (`bits_val_ref`) which was returned when the\n-    //! box was frozen initially. Here, both `frozen_val_ref` and\n-    //! `bits_val_ref` are in fact pointers to stack slots.\n-\n-    debug!(\"add_clean_return_to_mut({}, {}, {})\",\n-           bcx.to_str(),\n-           bcx.val_to_str(frozen_val_ref),\n-           bcx.val_to_str(bits_val_ref));\n-    in_scope_cx(bcx, Some(scope_id), |scope_info| {\n-        {\n-            let mut cleanups = scope_info.cleanups.borrow_mut();\n-            cleanups.get().push(clean_temp(\n-                    frozen_val_ref,\n-                    @WriteGuardReleasingCleanupFunction {\n-                        root_key: root_key,\n-                        frozen_val_ref: frozen_val_ref,\n-                        bits_val_ref: bits_val_ref,\n-                        filename_val: filename_val,\n-                        line_val: line_val,\n-                    } as @CleanupFunction,\n-                    normal_exit_only));\n-        }\n-        grow_scope_clean(scope_info);\n-    })\n-}\n+\n pub fn add_clean_free(cx: @Block, ptr: ValueRef, heap: heap) {\n     let free_fn = match heap {\n         heap_managed | heap_managed_unique => {"}, {"sha": "9c3a7f4f671c8d2132ca7e5bbed706587a147a23", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -165,7 +165,13 @@ pub fn get_const_val(cx: @CrateContext,\n         if !ast_util::is_local(def_id) {\n             def_id = inline::maybe_instantiate_inline(cx, def_id);\n         }\n-        match cx.tcx.items.get_copy(&def_id.node) {\n+\n+        let opt_item = {\n+            let items = cx.tcx.items.borrow();\n+            items.get().get_copy(&def_id.node)\n+        };\n+\n+        match opt_item {\n             ast_map::node_item(@ast::item {\n                 node: ast::item_static(_, ast::MutImmutable, _), ..\n             }, _) => {\n@@ -371,9 +377,7 @@ fn const_expr_unadjusted(cx: @CrateContext,\n             let ty = ty::expr_ty(cx.tcx, e);\n             let is_float = ty::type_is_fp(ty);\n             return (match u {\n-              ast::UnBox(_)  |\n-              ast::UnUniq |\n-              ast::UnDeref  => {\n+              ast::UnBox | ast::UnUniq | ast::UnDeref => {\n                 let (dv, _dt) = const_deref(cx, te, ty, true);\n                 dv\n               }"}, {"sha": "f57f31a56f458aa90269dd6aa035487895ca2cf6", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -552,7 +552,7 @@ impl Datum {\n          * by-ref datum of type T, pointing at the contents. */\n \n         let (content_ty, header) = match ty::get(self.ty).sty {\n-            ty::ty_box(mt) => (mt.ty, true),\n+            ty::ty_box(typ) => (typ, true),\n             ty::ty_uniq(mt) => (mt.ty, false),\n             ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n                 let unit_ty = ty::sequence_element_type(bcx.tcx(), self.ty);"}, {"sha": "49577a1395390bd12fea4e8125cd2662a850fb7c", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -323,7 +323,10 @@ pub fn create_captured_var_metadata(bcx: @Block,\n \n     let cx = bcx.ccx();\n \n-    let ast_item = cx.tcx.items.find_copy(&node_id);\n+    let ast_item = {\n+        let items = cx.tcx.items.borrow();\n+        items.get().find_copy(&node_id)\n+    };\n     let variable_ident = match ast_item {\n         None => {\n             cx.sess.span_bug(span, \"debuginfo::create_captured_var_metadata() - NodeId not found\");\n@@ -422,7 +425,10 @@ pub fn create_self_argument_metadata(bcx: @Block,\n     }\n \n     // Extract the span of the self argument from the method's AST\n-    let fnitem = bcx.ccx().tcx.items.get_copy(&bcx.fcx.id);\n+    let fnitem = {\n+        let items = bcx.ccx().tcx.items.borrow();\n+        items.get().get_copy(&bcx.fcx.id)\n+    };\n     let span = match fnitem {\n         ast_map::node_method(@ast::method { explicit_self: explicit_self, .. }, _, _) => {\n             explicit_self.span\n@@ -609,7 +615,10 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n     let empty_generics = ast::Generics { lifetimes: opt_vec::Empty, ty_params: opt_vec::Empty };\n \n-    let fnitem = cx.tcx.items.get_copy(&fn_ast_id);\n+    let fnitem = {\n+        let items = cx.tcx.items.borrow();\n+        items.get().get_copy(&fn_ast_id)\n+    };\n     let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n         ast_map::node_item(ref item, _) => {\n             match item.node {\n@@ -1092,7 +1101,8 @@ fn scope_metadata(fcx: &FunctionContext,\n     match scope_map.get().find_copy(&node_id) {\n         Some(scope_metadata) => scope_metadata,\n         None => {\n-            let node = fcx.ccx.tcx.items.get_copy(&node_id);\n+            let items = fcx.ccx.tcx.items.borrow();\n+            let node = items.get().get_copy(&node_id);\n \n             fcx.ccx.sess.span_bug(span,\n                 format!(\"debuginfo: Could not find scope info for node {:?}\", node));\n@@ -1411,13 +1421,17 @@ fn describe_enum_variant(cx: &CrateContext,\n \n     // Find the source code location of the variant's definition\n     let variant_definition_span = if variant_info.id.crate == ast::LOCAL_CRATE {\n-        match cx.tcx.items.find(&variant_info.id.node) {\n-            Some(&ast_map::node_variant(ref variant, _, _)) => variant.span,\n-            ref node => {\n-                cx.sess.span_warn(span,\n-                    format!(\"debuginfo::enum_metadata()::adt_struct_metadata() - Unexpected node \\\n-                          type: {:?}. This is a bug.\", node));\n-                codemap::DUMMY_SP\n+        {\n+            let items = cx.tcx.items.borrow();\n+            match items.get().find(&variant_info.id.node) {\n+                Some(&ast_map::node_variant(ref variant, _, _)) => variant.span,\n+                ref node => {\n+                    cx.sess.span_warn(span,\n+                        format!(\"debuginfo::enum_metadata()::\\\n+                                 adt_struct_metadata() - Unexpected node \\\n+                                 type: {:?}. This is a bug.\", node));\n+                    codemap::DUMMY_SP\n+                }\n             }\n         }\n     } else {\n@@ -2128,8 +2142,8 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_enum(def_id, _) => {\n             prepare_enum_metadata(cx, t, def_id, usage_site_span).finalize(cx)\n         },\n-        ty::ty_box(ref mt) => {\n-            create_pointer_to_box_metadata(cx, t, mt.ty)\n+        ty::ty_box(typ) => {\n+            create_pointer_to_box_metadata(cx, t, typ)\n         },\n         ty::ty_evec(ref mt, ref vstore) => {\n             match *vstore {\n@@ -2296,16 +2310,20 @@ fn get_namespace_and_span_for_item(cx: &CrateContext,\n                                 -> (DIScope, Span) {\n     let containing_scope = namespace_for_item(cx, def_id, warning_span).scope;\n     let definition_span = if def_id.crate == ast::LOCAL_CRATE {\n-        let definition_span = match cx.tcx.items.find(&def_id.node) {\n-            Some(&ast_map::node_item(@ast::item { span, .. }, _)) => span,\n-            ref node => {\n-                cx.sess.span_warn(warning_span,\n-                    format!(\"debuginfo::get_namespace_and_span_for_item() \\\n-                             - Unexpected node type: {:?}\", *node));\n-                codemap::DUMMY_SP\n-            }\n-        };\n-        definition_span\n+        {\n+            let items = cx.tcx.items.borrow();\n+            let definition_span = match items.get().find(&def_id.node) {\n+                Some(&ast_map::node_item(@ast::item { span, .. }, _)) => span,\n+                ref node => {\n+                    cx.sess.span_warn(warning_span,\n+                        format!(\"debuginfo::\\\n+                                 get_namespace_and_span_for_item() \\\n+                                 - Unexpected node type: {:?}\", *node));\n+                    codemap::DUMMY_SP\n+                }\n+            };\n+            definition_span\n+        }\n     } else {\n         // For external items there is no span information\n         codemap::DUMMY_SP"}, {"sha": "640f9339a7d12cac173c6e8969b6c78485ed183a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -378,18 +378,12 @@ pub fn trans_to_datum(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n         let source_data = Load(bcx, source_data_ptr); // always a ptr\n         let target_data = match source_store {\n             ty::BoxTraitStore(..) => {\n-                // For deref of @T or @mut T, create a dummy datum and\n-                // use the datum's deref method. This is more work\n-                // than just calling GEPi ourselves, but it ensures\n-                // that any write guards will be appropriate\n-                // processed.  Note that we don't know the type T, so\n+                // For deref of @T, create a dummy datum and use the datum's\n+                // deref method. This is more work than just calling GEPi\n+                // ourselves. Note that we don't know the type T, so\n                 // just substitute `i8`-- it doesn't really matter for\n                 // our purposes right now.\n-                let source_ty =\n-                    ty::mk_box(tcx,\n-                               ty::mt {\n-                                   ty: ty::mk_i8(),\n-                                   mutbl: source_mutbl});\n+                let source_ty = ty::mk_box(tcx, ty::mk_i8());\n                 let source_datum =\n                     Datum {val: source_data,\n                            ty: source_ty,\n@@ -596,8 +590,7 @@ fn trans_rvalue_datum_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n         ast::ExprPath(_) | ast::ExprSelf => {\n             return trans_def_datum_unadjusted(bcx, expr, bcx.def(expr.id));\n         }\n-        ast::ExprVstore(contents, ast::ExprVstoreBox) |\n-        ast::ExprVstore(contents, ast::ExprVstoreMutBox) => {\n+        ast::ExprVstore(contents, ast::ExprVstoreBox) => {\n             return tvec::trans_uniq_or_managed_vstore(bcx, heap_managed,\n                                                       expr, contents);\n         }\n@@ -1412,9 +1405,8 @@ fn trans_unary_datum(bcx: @Block,\n             };\n             immediate_rvalue_bcx(bcx, llneg, un_ty)\n         }\n-        ast::UnBox(_) => {\n-            trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty,\n-                             heap_managed)\n+        ast::UnBox => {\n+            trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty, heap_managed)\n         }\n         ast::UnUniq => {\n             let heap  = heap_for_unique(bcx, un_ty);"}, {"sha": "7c4c9f8937f05b0497f675989d50f1afb69958fd", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -355,10 +355,17 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n     for &foreign_item in foreign_mod.items.iter() {\n         match foreign_item.node {\n             ast::foreign_item_fn(..) => {\n-                let (abis, mut path) = match ccx.tcx.items.get_copy(&foreign_item.id) {\n-                    ast_map::node_foreign_item(_, abis, _, path) => (abis, (*path).clone()),\n-                    _ => fail!(\"Unable to find foreign item in tcx.items table.\")\n-                };\n+                let items = ccx.tcx.items.borrow();\n+                let (abis, mut path) =\n+                    match items.get().get_copy(&foreign_item.id) {\n+                        ast_map::node_foreign_item(_, abis, _, path) => {\n+                            (abis, (*path).clone())\n+                        }\n+                        _ => {\n+                            fail!(\"Unable to find foreign item in tcx.items \\\n+                                   table.\")\n+                        }\n+                    };\n                 if !(abis.is_rust() || abis.is_intrinsic()) {\n                     path.push(ast_map::path_name(foreign_item.ident));\n                     register_foreign_item_fn(ccx, abis, &path, foreign_item);"}, {"sha": "85efd2d40d045e8edf78fe4fe68cdfdd0822e685", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -157,7 +157,10 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n     if (field == abi::tydesc_field_free_glue ||\n         field == abi::tydesc_field_drop_glue) {\n         match ty::get(t).sty {\n-          ty::ty_box(mt) |\n+          ty::ty_box(typ)\n+          if ! ty::type_needs_drop(tcx, typ) =>\n+          return ty::mk_imm_box(tcx, ty::mk_u32()),\n+\n           ty::ty_evec(mt, ty::vstore_box)\n           if ! ty::type_needs_drop(tcx, mt.ty) =>\n           return ty::mk_imm_box(tcx, ty::mk_u32()),\n@@ -356,10 +359,10 @@ pub fn make_free_glue(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_free_glue\");\n     match ty::get(t).sty {\n-      ty::ty_box(body_mt) => {\n+      ty::ty_box(body_ty) => {\n         let v = Load(bcx, v);\n         let body = GEPi(bcx, v, [0u, abi::box_field_body]);\n-        let bcx = drop_ty(bcx, body, body_mt.ty);\n+        let bcx = drop_ty(bcx, body, body_ty);\n         trans_free(bcx, v)\n       }\n       ty::ty_opaque_box => {"}, {"sha": "c1096f7332235d84f9c792f8ed644895f2971c64", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -346,9 +346,12 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n             let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n             if in_type_size != out_type_size {\n-                let sp = match ccx.tcx.items.get_copy(&ref_id.unwrap()) {\n-                    ast_map::node_expr(e) => e.span,\n-                    _ => fail!(\"transmute has non-expr arg\"),\n+                let sp = {\n+                    let items = ccx.tcx.items.borrow();\n+                    match items.get().get_copy(&ref_id.unwrap()) {\n+                        ast_map::node_expr(e) => e.span,\n+                        _ => fail!(\"transmute has non-expr arg\"),\n+                    }\n                 };\n                 let pluralize = |n| if 1u == n { \"\" } else { \"s\" };\n                 ccx.sess.span_fatal(sp,"}, {"sha": "d54dd23af96a68bd0ca68ce130a5d55dd17bb2ff", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -246,11 +246,14 @@ pub fn trans_static_method_callee(bcx: @Block,\n         generics.type_param_defs.len();\n \n     let mname = if method_id.crate == ast::LOCAL_CRATE {\n-        match bcx.tcx().items.get_copy(&method_id.node) {\n-            ast_map::node_trait_method(trait_method, _, _) => {\n-                ast_util::trait_method_to_ty_method(trait_method).ident\n+        {\n+            let items = bcx.tcx().items.borrow();\n+            match items.get().get_copy(&method_id.node) {\n+                ast_map::node_trait_method(trait_method, _, _) => {\n+                    ast_util::trait_method_to_ty_method(trait_method).ident\n+                }\n+                _ => fail!(\"callee is not a trait method\")\n             }\n-            _ => fail!(\"callee is not a trait method\")\n         }\n     } else {\n         let path = csearch::get_item_path(bcx.tcx(), method_id);"}, {"sha": "a60ddc9d8b61fc494ebbbefc0c559a092fdd8915", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -95,12 +95,16 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     // calling a static provided method. This is sort of unfortunate.\n     let mut is_static_provided = None;\n \n-    let map_node = session::expect(\n-        ccx.sess,\n-        ccx.tcx.items.find_copy(&fn_id.node),\n-        || format!(\"While monomorphizing {:?}, couldn't find it in the item map \\\n-                 (may have attempted to monomorphize an item \\\n-                 defined in a different crate?)\", fn_id));\n+    let map_node = {\n+        let items = ccx.tcx.items.borrow();\n+        session::expect(\n+            ccx.sess,\n+            items.get().find_copy(&fn_id.node),\n+            || format!(\"While monomorphizing {:?}, couldn't find it in the \\\n+                        item map (may have attempted to monomorphize an item \\\n+                        defined in a different crate?)\", fn_id))\n+    };\n+\n     // Get the path so that we can create a symbol\n     let (pt, name, span) = match map_node {\n       ast_map::node_item(i, pt) => (pt, i.ident, i.span),"}, {"sha": "f0ec7fb75dd82bf7a2e43d7d5bcd5f01de9b37b4", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -189,8 +189,11 @@ impl Reflector {\n                   self.visit(~\"evec_\" + name, extra)\n               }\n           }\n-          ty::ty_box(ref mt) => {\n-              let extra = self.c_mt(mt);\n+          ty::ty_box(typ) => {\n+              let extra = self.c_mt(&ty::mt {\n+                  ty: typ,\n+                  mutbl: ast::MutImmutable,\n+              });\n               self.visit(\"box\", extra)\n           }\n           ty::ty_uniq(ref mt) => {"}, {"sha": "e5f946213f321579bebeb408f11ebfc38a0455de", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -236,8 +236,8 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           let v_ty = Type::vec(cx.sess.targ_cfg.arch, &e_ty);\n           Type::smart_ptr(cx, &v_ty).ptr_to()\n       }\n-      ty::ty_box(ref mt) => {\n-          let ty = type_of(cx, mt.ty);\n+      ty::ty_box(typ) => {\n+          let ty = type_of(cx, typ);\n           Type::smart_ptr(cx, &ty).ptr_to()\n       }\n       ty::ty_opaque_box => Type::opaque_box(cx).ptr_to(),"}, {"sha": "d7c952a38f681968c348269b3c1106f0afc85a96", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 8, "deletions": 139, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -15,26 +15,15 @@\n //! `RUST_LOG=rustc::middle::trans::write_guard`).\n \n \n-use lib::llvm::ValueRef;\n-use middle::borrowck::{RootInfo, root_map_key, DynaImm, DynaMut};\n-use middle::lang_items::CheckNotBorrowedFnLangItem;\n-use middle::lang_items::{BorrowAsImmFnLangItem, BorrowAsMutFnLangItem};\n-use middle::lang_items::{RecordBorrowFnLangItem, UnrecordBorrowFnLangItem};\n-use middle::lang_items::ReturnToMutFnLangItem;\n+use middle::borrowck::{RootInfo, root_map_key};\n use middle::trans::base::*;\n-use middle::trans::build::*;\n-use middle::trans::callee;\n use middle::trans::common::*;\n use middle::trans::datum::*;\n-use middle::trans::expr;\n-use middle::ty;\n use syntax::codemap::Span;\n use syntax::ast;\n \n-use middle::trans::type_::Type;\n-\n pub fn root_and_write_guard(datum: &Datum,\n-                            mut bcx: @Block,\n+                            bcx: @Block,\n                             span: Span,\n                             expr_id: ast::NodeId,\n                             derefs: uint) -> @Block {\n@@ -45,69 +34,16 @@ pub fn root_and_write_guard(datum: &Datum,\n     //\n     // (Note: root'd values are always boxes)\n     let ccx = bcx.ccx();\n-    bcx = {\n-        let root_map = ccx.maps.root_map.borrow();\n-        match root_map.get().find(&key) {\n-            None => bcx,\n-            Some(&root_info) => root(datum, bcx, span, key, root_info)\n-        }\n-    };\n-\n-    // Perform the write guard, if necessary.\n-    //\n-    // (Note: write-guarded values are always boxes)\n-    let write_guard_map = ccx.maps.write_guard_map.borrow();\n-    if write_guard_map.get().contains(&key) {\n-        perform_write_guard(datum, bcx, span)\n-    } else {\n-        bcx\n+    let root_map = ccx.maps.root_map.borrow();\n+    match root_map.get().find(&key) {\n+        None => bcx,\n+        Some(&root_info) => root(datum, bcx, span, key, root_info)\n     }\n }\n \n-pub fn return_to_mut(mut bcx: @Block,\n-                     root_key: root_map_key,\n-                     frozen_val_ref: ValueRef,\n-                     bits_val_ref: ValueRef,\n-                     filename_val: ValueRef,\n-                     line_val: ValueRef) -> @Block {\n-    debug!(\"write_guard::return_to_mut(root_key={:?}, {}, {}, {})\",\n-           root_key,\n-           bcx.to_str(),\n-           bcx.val_to_str(frozen_val_ref),\n-           bcx.val_to_str(bits_val_ref));\n-\n-    let box_ptr = Load(bcx, PointerCast(bcx, frozen_val_ref, Type::i8p().ptr_to()));\n-\n-    let bits_val = Load(bcx, bits_val_ref);\n-\n-    if bcx.tcx().sess.debug_borrows() {\n-        bcx = callee::trans_lang_call( bcx,\n-            langcall(bcx, None, \"unborrow\", UnrecordBorrowFnLangItem),\n-            [\n-                box_ptr,\n-                bits_val,\n-                filename_val,\n-                line_val\n-            ],\n-            Some(expr::Ignore)).bcx;\n-    }\n-\n-    callee::trans_lang_call(\n-        bcx,\n-        langcall(bcx, None, \"unborrow\", ReturnToMutFnLangItem),\n-        [\n-            box_ptr,\n-            bits_val,\n-            filename_val,\n-            line_val\n-        ],\n-        Some(expr::Ignore)\n-    ).bcx\n-}\n-\n fn root(datum: &Datum,\n-        mut bcx: @Block,\n-        span: Span,\n+        bcx: @Block,\n+        _: Span,\n         root_key: root_map_key,\n         root_info: RootInfo) -> @Block {\n     //! In some cases, borrowck will decide that an @T/@[]/@str\n@@ -129,73 +65,6 @@ fn root(datum: &Datum,\n                                 scratch.val,\n                                 scratch.ty);\n \n-    // Now, consider also freezing it.\n-    match root_info.freeze {\n-        None => {}\n-        Some(freeze_kind) => {\n-            let (filename, line) = filename_and_line_num_from_span(bcx, span);\n-\n-            // in this case, we don't have to zero, because\n-            // scratch.val will be NULL should the cleanup get\n-            // called without the freezing actually occurring, and\n-            // return_to_mut checks for this condition.\n-            let scratch_bits = scratch_datum(bcx, ty::mk_uint(),\n-                                             \"__write_guard_bits\", false);\n-\n-            let freeze_item = match freeze_kind {\n-                DynaImm => BorrowAsImmFnLangItem,\n-                DynaMut => BorrowAsMutFnLangItem,\n-            };\n-\n-            let box_ptr = Load(bcx, PointerCast(bcx, scratch.val, Type::i8p().ptr_to()));\n-\n-            let llresult = unpack_result!(bcx, callee::trans_lang_call(\n-                bcx,\n-                langcall(bcx, Some(span), \"freeze\", freeze_item),\n-                [\n-                    box_ptr,\n-                    filename,\n-                    line\n-                ],\n-                Some(expr::SaveIn(scratch_bits.val))));\n-\n-            if bcx.tcx().sess.debug_borrows() {\n-                bcx = callee::trans_lang_call(\n-                    bcx,\n-                    langcall(bcx, Some(span), \"freeze\", RecordBorrowFnLangItem),\n-                    [\n-                        box_ptr,\n-                        llresult,\n-                        filename,\n-                        line\n-                    ],\n-                    Some(expr::Ignore)).bcx;\n-            }\n-\n-            add_clean_return_to_mut(cleanup_bcx,\n-                                    root_info.scope,\n-                                    root_key,\n-                                    scratch.val,\n-                                    scratch_bits.val,\n-                                    filename,\n-                                    line);\n-        }\n-    }\n-\n     bcx\n }\n \n-fn perform_write_guard(datum: &Datum,\n-                       bcx: @Block,\n-                       span: Span) -> @Block {\n-    debug!(\"perform_write_guard\");\n-\n-    let llval = datum.to_value_llval(bcx);\n-    let (filename, line) = filename_and_line_num_from_span(bcx, span);\n-\n-    callee::trans_lang_call(\n-        bcx,\n-        langcall(bcx, Some(span), \"write guard\", CheckNotBorrowedFnLangItem),\n-        [PointerCast(bcx, llval, Type::i8p()), filename, line],\n-        Some(expr::Ignore)).bcx\n-}"}, {"sha": "3ae29eade7778a69aa14bc870fc7f27a8c1ceae0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 176, "deletions": 146, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -267,7 +267,7 @@ pub type ctxt = @ctxt_;\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n struct ctxt_ {\n-    diag: @mut syntax::diagnostic::SpanHandler,\n+    diag: @syntax::diagnostic::SpanHandler,\n     interner: RefCell<HashMap<intern_key, ~t_box_>>,\n     next_id: Cell<uint>,\n     cstore: @metadata::cstore::CStore,\n@@ -637,7 +637,7 @@ pub enum sty {\n     ty_float(ast::float_ty),\n     ty_estr(vstore),\n     ty_enum(DefId, substs),\n-    ty_box(mt),\n+    ty_box(t),\n     ty_uniq(mt),\n     ty_evec(mt, vstore),\n     ty_ptr(mt),\n@@ -1102,8 +1102,9 @@ pub fn mk_t(cx: ctxt, st: sty) -> t {\n               _ => {}\n           }\n       }\n-      &ty_box(ref m) | &ty_uniq(ref m) | &ty_evec(ref m, _) |\n-      &ty_ptr(ref m) | &ty_unboxed_vec(ref m) => {\n+      &ty_box(ref tt) => flags |= get(*tt).flags,\n+      &ty_uniq(ref m) | &ty_evec(ref m, _) | &ty_ptr(ref m) |\n+      &ty_unboxed_vec(ref m) => {\n         flags |= get(m.ty).flags;\n       }\n       &ty_rptr(r, ref m) => {\n@@ -1242,10 +1243,10 @@ pub fn mk_enum(cx: ctxt, did: ast::DefId, substs: substs) -> t {\n     mk_t(cx, ty_enum(did, substs))\n }\n \n-pub fn mk_box(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_box(tm)) }\n+pub fn mk_box(cx: ctxt, ty: t) -> t { mk_t(cx, ty_box(ty)) }\n \n pub fn mk_imm_box(cx: ctxt, ty: t) -> t {\n-    mk_box(cx, mt {ty: ty, mutbl: ast::MutImmutable})\n+    mk_box(cx, ty)\n }\n \n pub fn mk_uniq(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_uniq(tm)) }\n@@ -1368,8 +1369,11 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n       ty_estr(_) | ty_type | ty_opaque_box | ty_self(_) |\n       ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) | ty_err => {\n       }\n-      ty_box(ref tm) | ty_evec(ref tm, _) | ty_unboxed_vec(ref tm) |\n-      ty_ptr(ref tm) | ty_rptr(_, ref tm) | ty_uniq(ref tm) => {\n+      ty_box(ref ty) => {\n+        maybe_walk_ty(*ty, f);\n+      }\n+      ty_evec(ref tm, _) | ty_unboxed_vec(ref tm) | ty_ptr(ref tm) |\n+      ty_rptr(_, ref tm) | ty_uniq(ref tm) => {\n         maybe_walk_ty(tm.ty, f);\n       }\n       ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n@@ -2035,8 +2039,8 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 closure_contents(cx, c)\n             }\n \n-            ty_box(mt) => {\n-                tc_mt(cx, mt, cache).managed_pointer()\n+            ty_box(typ) => {\n+                tc_ty(cx, typ, cache).managed_pointer()\n             }\n \n             ty_trait(_, _, store, mutbl, bounds) => {\n@@ -2334,7 +2338,9 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_unboxed_vec(_) => {\n                 false\n             }\n-            ty_box(ref mt) |\n+            ty_box(typ) => {\n+                type_requires(cx, seen, r_ty, typ)\n+            }\n             ty_uniq(ref mt) |\n             ty_rptr(_, ref mt) => {\n                 type_requires(cx, seen, r_ty, mt.ty)\n@@ -2610,7 +2616,14 @@ pub fn deref(cx: ctxt, t: t, explicit: bool) -> Option<mt> {\n \n pub fn deref_sty(cx: ctxt, sty: &sty, explicit: bool) -> Option<mt> {\n     match *sty {\n-      ty_rptr(_, mt) | ty_box(mt) | ty_uniq(mt) => {\n+      ty_box(typ) => {\n+        Some(mt {\n+          ty: typ,\n+          mutbl: ast::MutImmutable,\n+        })\n+      }\n+\n+      ty_rptr(_, mt) | ty_uniq(mt) => {\n         Some(mt)\n       }\n \n@@ -3244,7 +3257,6 @@ pub fn expr_kind(tcx: ctxt,\n         ast::ExprAddrOf(..) |\n         ast::ExprBinary(..) |\n         ast::ExprVstore(_, ast::ExprVstoreBox) |\n-        ast::ExprVstore(_, ast::ExprVstoreMutBox) |\n         ast::ExprVstore(_, ast::ExprVstoreUniq) => {\n             RvalueDatumExpr\n         }\n@@ -3556,16 +3568,19 @@ pub fn provided_source(cx: ctxt, id: ast::DefId) -> Option<ast::DefId> {\n \n pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n     if is_local(id) {\n-        match cx.items.find(&id.node) {\n-            Some(&ast_map::node_item(@ast::item {\n-                        node: item_trait(_, _, ref ms),\n-                        ..\n-                    }, _)) =>\n-                match ast_util::split_trait_methods(*ms) {\n-                   (_, p) => p.map(|m| method(cx, ast_util::local_def(m.id)))\n-                },\n-            _ => cx.sess.bug(format!(\"provided_trait_methods: {:?} is not a trait\",\n-                                  id))\n+        {\n+            let items = cx.items.borrow();\n+            match items.get().find(&id.node) {\n+                Some(&ast_map::node_item(@ast::item {\n+                            node: item_trait(_, _, ref ms),\n+                            ..\n+                        }, _)) =>\n+                    match ast_util::split_trait_methods(*ms) {\n+                       (_, p) => p.map(|m| method(cx, ast_util::local_def(m.id)))\n+                    },\n+                _ => cx.sess.bug(format!(\"provided_trait_methods: {:?} is not a trait\",\n+                                      id))\n+            }\n         }\n     } else {\n         csearch::get_provided_trait_methods(cx, id)\n@@ -3675,17 +3690,20 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n \n     let ret = if id.crate == ast::LOCAL_CRATE {\n         debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n-        match cx.items.find(&id.node) {\n-            Some(&ast_map::node_item(@ast::item {\n-                                     node: ast::item_impl(_, ref opt_trait, _, _),\n-                                     ..},\n-                                     _)) => {\n-                match opt_trait {\n-                    &Some(ref t) => Some(ty::node_id_to_trait_ref(cx, t.ref_id)),\n-                    &None => None\n+        {\n+            let items = cx.items.borrow();\n+            match items.get().find(&id.node) {\n+                Some(&ast_map::node_item(@ast::item {\n+                     node: ast::item_impl(_, ref opt_trait, _, _),\n+                     ..},\n+                     _)) => {\n+                    match opt_trait {\n+                        &Some(ref t) => Some(ty::node_id_to_trait_ref(cx, t.ref_id)),\n+                        &None => None\n+                    }\n                 }\n+                _ => None\n             }\n-            _ => None\n         }\n     } else {\n         csearch::get_impl_trait(cx, id)\n@@ -3857,54 +3875,55 @@ pub fn has_dtor(cx: ctxt, struct_id: DefId) -> bool {\n \n pub fn item_path(cx: ctxt, id: ast::DefId) -> ast_map::path {\n     if id.crate != ast::LOCAL_CRATE {\n-        csearch::get_item_path(cx, id)\n-    } else {\n-        // FIXME (#5521): uncomment this code and don't have a catch-all at the\n-        //                end of the match statement. Favor explicitly listing\n-        //                each variant.\n-        // let node = cx.items.get(&id.node);\n-        // match *node {\n-        match *cx.items.get(&id.node) {\n-          ast_map::node_item(item, path) => {\n-            let item_elt = match item.node {\n-              item_mod(_) | item_foreign_mod(_) => {\n-                ast_map::path_mod(item.ident)\n-              }\n-              _ => {\n-                ast_map::path_name(item.ident)\n-              }\n-            };\n-            vec::append_one((*path).clone(), item_elt)\n+        return csearch::get_item_path(cx, id)\n+    }\n+\n+    // FIXME (#5521): uncomment this code and don't have a catch-all at the\n+    //                end of the match statement. Favor explicitly listing\n+    //                each variant.\n+    // let node = cx.items.get(&id.node);\n+    // match *node {\n+    let items = cx.items.borrow();\n+    match *items.get().get(&id.node) {\n+      ast_map::node_item(item, path) => {\n+        let item_elt = match item.node {\n+          item_mod(_) | item_foreign_mod(_) => {\n+            ast_map::path_mod(item.ident)\n           }\n-\n-          ast_map::node_foreign_item(nitem, _, _, path) => {\n-            vec::append_one((*path).clone(),\n-                            ast_map::path_name(nitem.ident))\n+          _ => {\n+            ast_map::path_name(item.ident)\n           }\n+        };\n+        vec::append_one((*path).clone(), item_elt)\n+      }\n \n-          ast_map::node_method(method, _, path) => {\n-            vec::append_one((*path).clone(),\n-                            ast_map::path_name(method.ident))\n-          }\n-          ast_map::node_trait_method(trait_method, _, path) => {\n-            let method = ast_util::trait_method_to_ty_method(&*trait_method);\n-            vec::append_one((*path).clone(),\n-                            ast_map::path_name(method.ident))\n-          }\n+      ast_map::node_foreign_item(nitem, _, _, path) => {\n+        vec::append_one((*path).clone(),\n+                        ast_map::path_name(nitem.ident))\n+      }\n \n-          ast_map::node_variant(ref variant, _, path) => {\n-            vec::append_one(path.init().to_owned(),\n-                            ast_map::path_name((*variant).node.name))\n-          }\n+      ast_map::node_method(method, _, path) => {\n+        vec::append_one((*path).clone(),\n+                        ast_map::path_name(method.ident))\n+      }\n+      ast_map::node_trait_method(trait_method, _, path) => {\n+        let method = ast_util::trait_method_to_ty_method(&*trait_method);\n+        vec::append_one((*path).clone(),\n+                        ast_map::path_name(method.ident))\n+      }\n \n-          ast_map::node_struct_ctor(_, item, path) => {\n-            vec::append_one((*path).clone(), ast_map::path_name(item.ident))\n-          }\n+      ast_map::node_variant(ref variant, _, path) => {\n+        vec::append_one(path.init().to_owned(),\n+                        ast_map::path_name((*variant).node.name))\n+      }\n \n-          ref node => {\n-            cx.sess.bug(format!(\"cannot find item_path for node {:?}\", node));\n-          }\n-        }\n+      ast_map::node_struct_ctor(_, item, path) => {\n+        vec::append_one((*path).clone(), ast_map::path_name(item.ident))\n+      }\n+\n+      ref node => {\n+        cx.sess.bug(format!(\"cannot find item_path for node {:?}\", node));\n+      }\n     }\n }\n \n@@ -3936,40 +3955,43 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n           call eval_const_expr, it should never get called twice for the same\n           expr, since check_enum_variants also updates the enum_var_cache\n          */\n-        match cx.items.get_copy(&id.node) {\n-          ast_map::node_item(@ast::item {\n-                    node: ast::item_enum(ref enum_definition, _),\n-                    ..\n-                }, _) => {\n-            let mut last_discriminant: Option<Disr> = None;\n-            @enum_definition.variants.iter().map(|&variant| {\n-\n-                let mut discriminant = match last_discriminant {\n-                    Some(val) => val + 1,\n-                    None => INITIAL_DISCRIMINANT_VALUE\n-                };\n-\n-                match variant.node.disr_expr {\n-                    Some(e) => match const_eval::eval_const_expr_partial(&cx, e) {\n-                        Ok(const_eval::const_int(val)) => discriminant = val as Disr,\n-                        Ok(const_eval::const_uint(val)) => discriminant = val as Disr,\n-                        Ok(_) => {\n-                            cx.sess.span_err(e.span, \"expected signed integer constant\");\n-                        }\n-                        Err(ref err) => {\n-                            cx.sess.span_err(e.span, format!(\"expected constant: {}\", (*err)));\n-                        }\n-                    },\n-                    None => {}\n-                };\n-\n-                let variant_info = @VariantInfo::from_ast_variant(cx, variant, discriminant);\n-                last_discriminant = Some(discriminant);\n-                variant_info\n-\n-            }).collect()\n-          }\n-          _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n+        {\n+            let items = cx.items.borrow();\n+            match items.get().get_copy(&id.node) {\n+              ast_map::node_item(@ast::item {\n+                        node: ast::item_enum(ref enum_definition, _),\n+                        ..\n+                    }, _) => {\n+                let mut last_discriminant: Option<Disr> = None;\n+                @enum_definition.variants.iter().map(|&variant| {\n+\n+                    let mut discriminant = match last_discriminant {\n+                        Some(val) => val + 1,\n+                        None => INITIAL_DISCRIMINANT_VALUE\n+                    };\n+\n+                    match variant.node.disr_expr {\n+                        Some(e) => match const_eval::eval_const_expr_partial(&cx, e) {\n+                            Ok(const_eval::const_int(val)) => discriminant = val as Disr,\n+                            Ok(const_eval::const_uint(val)) => discriminant = val as Disr,\n+                            Ok(_) => {\n+                                cx.sess.span_err(e.span, \"expected signed integer constant\");\n+                            }\n+                            Err(ref err) => {\n+                                cx.sess.span_err(e.span, format!(\"expected constant: {}\", (*err)));\n+                            }\n+                        },\n+                        None => {}\n+                    };\n+\n+                    let variant_info = @VariantInfo::from_ast_variant(cx, variant, discriminant);\n+                    last_discriminant = Some(discriminant);\n+                    variant_info\n+\n+                }).collect()\n+              }\n+              _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n+            }\n         }\n     };\n \n@@ -4040,11 +4062,17 @@ pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n // decoder to use iterators instead of higher-order functions.)\n pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n     if is_local(did) {\n-        match tcx.items.find(&did.node) {\n-            Some(&ast_map::node_item(@ast::item {attrs: ref attrs, ..}, _)) =>\n-                attrs.iter().advance(|attr| f(attr.node.value)),\n-            _ => tcx.sess.bug(format!(\"has_attr: {:?} is not an item\",\n-                                      did))\n+        {\n+            let items = tcx.items.borrow();\n+            match items.get().find(&did.node) {\n+                Some(&ast_map::node_item(@ast::item {\n+                    attrs: ref attrs,\n+                    ..\n+                }, _)) =>\n+                    attrs.iter().advance(|attr| f(attr.node.value)),\n+                _ => tcx.sess.bug(format!(\"has_attr: {:?} is not an item\",\n+                                          did))\n+            }\n         }\n     } else {\n         let mut cont = true;\n@@ -4120,37 +4148,39 @@ pub fn lookup_field_type(tcx: ctxt,\n // Fails if the id is not bound to a struct.\n pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> ~[field_ty] {\n   if did.crate == ast::LOCAL_CRATE {\n-    match cx.items.find(&did.node) {\n-       Some(&ast_map::node_item(i,_)) => {\n-         match i.node {\n-            ast::item_struct(struct_def, _) => {\n-               struct_field_tys(struct_def.fields)\n-            }\n-            _ => cx.sess.bug(\"struct ID bound to non-struct\")\n-         }\n-       }\n-       Some(&ast_map::node_variant(ref variant, _, _)) => {\n-          match (*variant).node.kind {\n-            ast::struct_variant_kind(struct_def) => {\n-              struct_field_tys(struct_def.fields)\n-            }\n-            _ => {\n-              cx.sess.bug(\"struct ID bound to enum variant that isn't \\\n-                           struct-like\")\n-            }\n+      {\n+          let items = cx.items.borrow();\n+          match items.get().find(&did.node) {\n+           Some(&ast_map::node_item(i,_)) => {\n+             match i.node {\n+                ast::item_struct(struct_def, _) => {\n+                   struct_field_tys(struct_def.fields)\n+                }\n+                _ => cx.sess.bug(\"struct ID bound to non-struct\")\n+             }\n+           }\n+           Some(&ast_map::node_variant(ref variant, _, _)) => {\n+              match (*variant).node.kind {\n+                ast::struct_variant_kind(struct_def) => {\n+                  struct_field_tys(struct_def.fields)\n+                }\n+                _ => {\n+                  cx.sess.bug(\"struct ID bound to enum variant that isn't \\\n+                               struct-like\")\n+                }\n+              }\n+           }\n+           _ => {\n+               cx.sess.bug(\n+                   format!(\"struct ID not bound to an item: {}\",\n+                        ast_map::node_id_to_str(cx.items, did.node,\n+                                                token::get_ident_interner())));\n+           }\n           }\n-       }\n-       _ => {\n-           cx.sess.bug(\n-               format!(\"struct ID not bound to an item: {}\",\n-                    ast_map::node_id_to_str(cx.items, did.node,\n-                                            token::get_ident_interner())));\n-       }\n-    }\n-        }\n-  else {\n-        return csearch::get_struct_fields(cx.sess.cstore, did);\n-    }\n+      }\n+  } else {\n+    return csearch::get_struct_fields(cx.sess.cstore, did);\n+  }\n }\n \n pub fn lookup_struct_field(cx: ctxt,\n@@ -4658,7 +4688,8 @@ pub fn populate_implementations_for_trait_if_necessary(\n /// If it implements no trait, return `None`.\n pub fn trait_id_of_impl(tcx: ctxt,\n                         def_id: ast::DefId) -> Option<ast::DefId> {\n-    let node = match tcx.items.find(&def_id.node) {\n+    let items = tcx.items.borrow();\n+    let node = match items.get().find(&def_id.node) {\n         Some(node) => node,\n         None => return None\n     };\n@@ -4799,9 +4830,8 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n                 hash.input([8]);\n                 did(&mut hash, d);\n             }\n-            ty_box(m) => {\n+            ty_box(_) => {\n                 hash.input([9]);\n-                mt(&mut hash, m);\n             }\n             ty_uniq(m) => {\n                 hash.input([10]);"}, {"sha": "06a3152056fb1d5c96cb33772f794ede4d6b6946", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -140,8 +140,8 @@ pub fn super_fold_mt<T:TypeFolder>(this: &mut T,\n pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n                                     sty: &ty::sty) -> ty::sty {\n     match *sty {\n-        ty::ty_box(ref tm) => {\n-            ty::ty_box(this.fold_mt(tm))\n+        ty::ty_box(typ) => {\n+            ty::ty_box(this.fold_ty(typ))\n         }\n         ty::ty_uniq(ref tm) => {\n             ty::ty_uniq(this.fold_mt(tm))"}, {"sha": "746389c604429b3e324a8fdf620640e812f2ef5c", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -401,9 +401,10 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n     let typ = match ast_ty.node {\n       ast::ty_nil => ty::mk_nil(),\n       ast::ty_bot => ty::mk_bot(),\n-      ast::ty_box(ref mt) => {\n-        mk_pointer(this, rscope, mt, ty::vstore_box,\n-                   |tmt| ty::mk_box(tcx, tmt))\n+      ast::ty_box(ty) => {\n+        let mt = ast::mt { ty: ty, mutbl: ast::MutImmutable };\n+        mk_pointer(this, rscope, &mt, ty::vstore_box,\n+                   |tmt| ty::mk_box(tcx, tmt.ty))\n       }\n       ast::ty_uniq(ty) => {\n         let mt = ast::mt { ty: ty, mutbl: ast::MutImmutable };\n@@ -689,10 +690,8 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(\n                                  ty::mt {ty: self_info.untransformed_self_ty,\n                                          mutbl: mutability}))\n             }\n-            ast::sty_box(mutability) => {\n-                Some(ty::mk_box(this.tcx(),\n-                                ty::mt {ty: self_info.untransformed_self_ty,\n-                                        mutbl: mutability}))\n+            ast::sty_box(_) => {\n+                Some(ty::mk_box(this.tcx(), self_info.untransformed_self_ty))\n             }\n             ast::sty_uniq(_) => {\n                 Some(ty::mk_uniq(this.tcx(),"}, {"sha": "a7f83a41da675aed894193273db22ff0412703f4", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -667,19 +667,19 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n                          span: Span,\n                          expected: ty::t) {\n     let fcx = pcx.fcx;\n-    let check_inner: |ty::mt| = |e_inner| {\n-        check_pat(pcx, inner, e_inner.ty);\n+    let check_inner: |ty::t| = |e_inner| {\n+        check_pat(pcx, inner, e_inner);\n         fcx.write_ty(pat_id, expected);\n     };\n     match *structure_of(fcx, span, expected) {\n         ty::ty_box(e_inner) if pointer_kind == Managed => {\n             check_inner(e_inner);\n         }\n         ty::ty_uniq(e_inner) if pointer_kind == Send => {\n-            check_inner(e_inner);\n+            check_inner(e_inner.ty);\n         }\n         ty::ty_rptr(_, e_inner) if pointer_kind == Borrowed => {\n-            check_inner(e_inner);\n+            check_inner(e_inner.ty);\n         }\n         _ => {\n             check_pat(pcx, inner, ty::mk_err());"}, {"sha": "e1ecd919da8187f683bf30de4fb9b1c0fff1dd70", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -1092,9 +1092,9 @@ impl<'a> LookupContext<'a> {\n                                      substs, RegionTraitStore(r), mt.mutbl,\n                                      ty::EmptyBuiltinBounds())\n                     }\n-                    ty::ty_box(mt) => { // must be sty_box\n+                    ty::ty_box(_) => { // must be sty_box\n                         ty::mk_trait(self.tcx(), trait_def_id,\n-                                     substs, BoxTraitStore, mt.mutbl,\n+                                     substs, BoxTraitStore, ast::MutImmutable,\n                                      ty::EmptyBuiltinBounds())\n                     }\n                     ty::ty_uniq(mt) => { // must be sty_uniq\n@@ -1224,9 +1224,8 @@ impl<'a> LookupContext<'a> {\n             sty_box(m) => {\n                 debug!(\"(is relevant?) explicit self is a box\");\n                 match ty::get(rcvr_ty).sty {\n-                    ty::ty_box(mt) => {\n-                        mutability_matches(mt.mutbl, m) &&\n-                        rcvr_matches_ty(self.fcx, mt.ty, candidate)\n+                    ty::ty_box(typ) => {\n+                        rcvr_matches_ty(self.fcx, typ, candidate)\n                     }\n \n                     ty::ty_trait(self_did, _, BoxTraitStore, self_m, _) => {\n@@ -1309,10 +1308,17 @@ impl<'a> LookupContext<'a> {\n \n     fn report_static_candidate(&self, idx: uint, did: DefId) {\n         let span = if did.crate == ast::LOCAL_CRATE {\n-            match self.tcx().items.find(&did.node) {\n-              Some(&ast_map::node_method(m, _, _))\n-              | Some(&ast_map::node_trait_method(@ast::provided(m), _, _)) => m.span,\n-              _ => fail!(\"report_static_candidate: bad item {:?}\", did)\n+            {\n+                let items = self.tcx().items.borrow();\n+                match items.get().find(&did.node) {\n+                  Some(&ast_map::node_method(m, _, _))\n+                  | Some(&ast_map::node_trait_method(@ast::provided(m),\n+                                                     _,\n+                                                     _)) => {\n+                      m.span\n+                  }\n+                  _ => fail!(\"report_static_candidate: bad item {:?}\", did)\n+                }\n             }\n         } else {\n             self.expr.span"}, {"sha": "088104e84ef4184cbe88c9e30249edb2c313aa4f", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -1330,8 +1330,7 @@ pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n \n         // Some extra checks to detect weird cycles and so forth:\n         match *sty {\n-            ty::ty_box(inner) | ty::ty_uniq(inner) |\n-            ty::ty_rptr(_, inner) => {\n+            ty::ty_box(inner) => {\n                 match ty::get(t1).sty {\n                     ty::ty_infer(ty::TyVar(v1)) => {\n                         ty::occurs_check(fcx.ccx.tcx, sp, v1,\n@@ -1340,6 +1339,15 @@ pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n                     _ => ()\n                 }\n             }\n+            ty::ty_uniq(inner) | ty::ty_rptr(_, inner) => {\n+                match ty::get(t1).sty {\n+                    ty::ty_infer(ty::TyVar(v1)) => {\n+                        ty::occurs_check(fcx.ccx.tcx, sp, v1,\n+                                         ty::mk_box(fcx.ccx.tcx, inner.ty));\n+                    }\n+                    _ => ()\n+                }\n+            }\n             ty::ty_enum(ref did, _) => {\n                 // Watch out for a type like `enum t = @t`.  Such a\n                 // type would otherwise infinitely auto-deref.  Only\n@@ -2620,15 +2628,12 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n           }\n           ast::ExprVec(ref args, mutbl) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n-            let mutability;\n             let mut any_error = false;\n             let mut any_bot = false;\n-            match vst {\n-                ast::ExprVstoreMutBox | ast::ExprVstoreMutSlice => {\n-                    mutability = ast::MutMutable\n-                }\n-                _ => mutability = mutbl\n-            }\n+            let mutability = match vst {\n+                ast::ExprVstoreMutSlice => ast::MutMutable,\n+                _ => mutbl,\n+            };\n             let t: ty::t = fcx.infcx().next_ty_var();\n             for e in args.iter() {\n                 check_expr_has_type(fcx, *e, t);\n@@ -2642,11 +2647,9 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n             }\n             if any_error {\n                 ty::mk_err()\n-            }\n-            else if any_bot {\n+            } else if any_bot {\n                 ty::mk_bot()\n-            }\n-            else {\n+            } else {\n                 ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n             }\n           }\n@@ -2655,10 +2658,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n             let _ = ty::eval_repeat_count(fcx, count_expr);\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             let mutability = match vst {\n-                ast::ExprVstoreMutBox | ast::ExprVstoreMutSlice => {\n-                    ast::MutMutable\n-                }\n-                _ => mutbl\n+                ast::ExprVstoreMutSlice => ast::MutMutable,\n+                _ => mutbl,\n             };\n             let t: ty::t = fcx.infcx().next_ty_var();\n             check_expr_has_type(fcx, element, t);\n@@ -2733,8 +2734,9 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n       ast::ExprUnary(callee_id, unop, oprnd) => {\n         let exp_inner = unpack_expected(fcx, expected, |sty| {\n             match unop {\n-              ast::UnBox(_) | ast::UnUniq => match *sty {\n-                ty::ty_box(ref mt) | ty::ty_uniq(ref mt) => Some(mt.ty),\n+              ast::UnBox | ast::UnUniq => match *sty {\n+                ty::ty_box(ty) => Some(ty),\n+                ty::ty_uniq(ref mt) => Some(mt.ty),\n                 _ => None\n               },\n               ast::UnNot | ast::UnNeg => expected,\n@@ -2746,9 +2748,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         if !ty::type_is_error(oprnd_t) &&\n               !ty::type_is_bot(oprnd_t) {\n             match unop {\n-                ast::UnBox(mutbl) => {\n-                    oprnd_t = ty::mk_box(tcx,\n-                                         ty::mt {ty: oprnd_t, mutbl: mutbl});\n+                ast::UnBox => {\n+                    oprnd_t = ty::mk_box(tcx, oprnd_t)\n                 }\n                 ast::UnUniq => {\n                     oprnd_t = ty::mk_uniq(tcx,\n@@ -3912,7 +3913,7 @@ pub fn ast_expr_vstore_to_vstore(fcx: @FnCtxt,\n                               -> ty::vstore {\n     match v {\n         ast::ExprVstoreUniq => ty::vstore_uniq,\n-        ast::ExprVstoreBox | ast::ExprVstoreMutBox => ty::vstore_box,\n+        ast::ExprVstoreBox => ty::vstore_box,\n         ast::ExprVstoreSlice | ast::ExprVstoreMutSlice => {\n             let r = fcx.infcx().next_region_var(infer::AddrOfSlice(e.span));\n             ty::vstore_slice(r)"}, {"sha": "fcf219323e1ccffab64a9bb995802458a16a3e37", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -582,17 +582,29 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n               let ty = structurally_resolved_type(fcx, ex.span,\n                                                   fcx.expr_ty(src));\n               match (&ty::get(ty).sty, store) {\n-                  (&ty::ty_box(mt), ty::BoxTraitStore) |\n+                  (&ty::ty_box(..), ty::BoxTraitStore)\n+                    if !mutability_allowed(ast::MutImmutable,\n+                                           target_mutbl) => {\n+                      fcx.tcx().sess.span_err(ex.span,\n+                                              format!(\"types differ in mutability\"));\n+                  }\n+\n                   (&ty::ty_uniq(mt), ty::UniqTraitStore) |\n                   (&ty::ty_rptr(_, mt), ty::RegionTraitStore(..))\n                     if !mutability_allowed(mt.mutbl, target_mutbl) => {\n                       fcx.tcx().sess.span_err(ex.span,\n                                               format!(\"types differ in mutability\"));\n                   }\n \n-                  (&ty::ty_box(mt), ty::BoxTraitStore) |\n-                  (&ty::ty_uniq(mt), ty::UniqTraitStore) |\n-                  (&ty::ty_rptr(_, mt), ty::RegionTraitStore(..)) => {\n+                  (&ty::ty_box(..), ty::BoxTraitStore) |\n+                  (&ty::ty_uniq(..), ty::UniqTraitStore) |\n+                  (&ty::ty_rptr(..), ty::RegionTraitStore(..)) => {\n+                    let typ = match (&ty::get(ty).sty) {\n+                        &ty::ty_box(typ) => typ,\n+                        &ty::ty_uniq(mt) | &ty::ty_rptr(_, mt) => mt.ty,\n+                        _ => fail!(\"shouldn't get here\"),\n+                    };\n+\n                       let location_info =\n                           &location_info_for_expr(ex);\n                       let vcx = fcx.vtable_context();\n@@ -601,7 +613,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n                           substs: ty::substs {\n                               tps: target_substs.tps.clone(),\n                               regions: target_substs.regions.clone(),\n-                              self_ty: Some(mt.ty)\n+                              self_ty: Some(typ)\n                           }\n                       };\n \n@@ -614,7 +626,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n                                                      location_info,\n                                                      None,\n                                                      &param_bounds,\n-                                                     mt.ty,\n+                                                     typ,\n                                                      is_early);\n \n                       if !is_early {"}, {"sha": "d18c2419735d4770d9d4e1a67945a550dd0643c4", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -568,10 +568,8 @@ impl CoherenceChecker {\n \n                         // Make sure that this type precisely names a nominal\n                         // type.\n-                        match self.crate_context\n-                                  .tcx\n-                                  .items\n-                                  .find(&def_id.node) {\n+                        let items = self.crate_context.tcx.items.borrow();\n+                        match items.get().find(&def_id.node) {\n                             None => {\n                                 self.crate_context.tcx.sess.span_bug(\n                                     original_type.span,\n@@ -628,7 +626,8 @@ impl CoherenceChecker {\n \n     pub fn span_of_impl(&self, implementation: @Impl) -> Span {\n         assert_eq!(implementation.did.crate, LOCAL_CRATE);\n-        match self.crate_context.tcx.items.find(&implementation.did.node) {\n+        let items = self.crate_context.tcx.items.borrow();\n+        match items.get().find(&implementation.did.node) {\n             Some(&node_item(item, _)) => {\n                 return item.span;\n             }\n@@ -732,14 +731,19 @@ impl CoherenceChecker {\n                 _ => {\n                     // Destructors only work on nominal types.\n                     if impl_info.did.crate == ast::LOCAL_CRATE {\n-                        match tcx.items.find(&impl_info.did.node) {\n-                            Some(&ast_map::node_item(@ref item, _)) => {\n-                                tcx.sess.span_err((*item).span,\n-                                                  \"the Drop trait may only be implemented on \\\n-                                                   structures\");\n-                            }\n-                            _ => {\n-                                tcx.sess.bug(\"didn't find impl in ast map\");\n+                        {\n+                            let items = tcx.items.borrow();\n+                            match items.get().find(&impl_info.did.node) {\n+                                Some(&ast_map::node_item(@ref item, _)) => {\n+                                    tcx.sess.span_err((*item).span,\n+                                                      \"the Drop trait may \\\n+                                                       only be implemented \\\n+                                                       on structures\");\n+                                }\n+                                _ => {\n+                                    tcx.sess.bug(\"didn't find impl in ast \\\n+                                                  map\");\n+                                }\n                             }\n                         }\n                     } else {"}, {"sha": "410c94a9a67f3676b187603596b18d566a2dcade", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -106,19 +106,18 @@ impl AstConv for CrateCtxt {\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n         if id.crate != ast::LOCAL_CRATE {\n-            csearch::get_type(self.tcx, id)\n-        } else {\n-            match self.tcx.items.find(&id.node) {\n-              Some(&ast_map::node_item(item, _)) => {\n-                ty_of_item(self, item)\n-              }\n-              Some(&ast_map::node_foreign_item(foreign_item, abis, _, _)) => {\n+            return csearch::get_type(self.tcx, id)\n+        }\n+\n+        let items = self.tcx.items.borrow();\n+        match items.get().find(&id.node) {\n+            Some(&ast_map::node_item(item, _)) => ty_of_item(self, item),\n+            Some(&ast_map::node_foreign_item(foreign_item, abis, _, _)) => {\n                 ty_of_foreign_item(self, foreign_item, abis)\n-              }\n-              ref x => {\n+            }\n+            ref x => {\n                 self.tcx.sess.bug(format!(\"unexpected sort of item \\\n-                                        in get_item_ty(): {:?}\", (*x)));\n-              }\n+                                           in get_item_ty(): {:?}\", (*x)));\n             }\n         }\n     }\n@@ -187,7 +186,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                             trait_id: ast::NodeId)\n {\n     let tcx = ccx.tcx;\n-    match tcx.items.get_copy(&trait_id) {\n+    let items = tcx.items.borrow();\n+    match items.get().get_copy(&trait_id) {\n         ast_map::node_item(@ast::item {\n             node: ast::item_trait(ref generics, _, ref ms),\n             ..\n@@ -715,7 +715,8 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::foreign_item) {\n     // map, and I regard each time that I use it as a personal and\n     // moral failing, but at the moment it seems like the only\n     // convenient way to extract the ABI. - ndm\n-    let abis = match ccx.tcx.items.find(&i.id) {\n+    let items = ccx.tcx.items.borrow();\n+    let abis = match items.get().find(&i.id) {\n         Some(&ast_map::node_foreign_item(_, abis, _, _)) => abis,\n         ref x => {\n             ccx.tcx.sess.bug(format!(\"unexpected sort of item \\\n@@ -765,13 +766,14 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n \n fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> @ty::TraitDef {\n     if trait_id.crate != ast::LOCAL_CRATE {\n-        ty::lookup_trait_def(ccx.tcx, trait_id)\n-    } else {\n-        match ccx.tcx.items.get(&trait_id.node) {\n-            &ast_map::node_item(item, _) => trait_def_of_item(ccx, item),\n-            _ => ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n-                                       trait_id.node))\n-        }\n+        return ty::lookup_trait_def(ccx.tcx, trait_id)\n+    }\n+\n+    let items = ccx.tcx.items.borrow();\n+    match items.get().get(&trait_id.node) {\n+        &ast_map::node_item(item, _) => trait_def_of_item(ccx, item),\n+        _ => ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n+                                   trait_id.node))\n     }\n }\n "}, {"sha": "6e82456e95dbfc2469a59b102b638f1fa4f46cd2", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -241,7 +241,7 @@ impl Coerce {\n         let r_borrow = self.infcx.next_region_var(Coercion(self.trace));\n \n         let inner_ty = match *sty_a {\n-            ty::ty_box(mt_a) => mt_a.ty,\n+            ty::ty_box(typ) => typ,\n             ty::ty_uniq(mt_a) => mt_a.ty,\n             ty::ty_rptr(_, mt_a) => mt_a.ty,\n             _ => {"}, {"sha": "8d949cc1bc909e45a27337f56891128f6ed60e98", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -515,8 +515,8 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n             Ok(ty::mk_struct(tcx, a_id, substs))\n       }\n \n-      (&ty::ty_box(ref a_mt), &ty::ty_box(ref b_mt)) => {\n-        this.mts(a_mt, b_mt).and_then(|mt| Ok(ty::mk_box(tcx, mt)))\n+      (&ty::ty_box(a_inner), &ty::ty_box(b_inner)) => {\n+        this.tys(a_inner, b_inner).and_then(|typ| Ok(ty::mk_box(tcx, typ)))\n       }\n \n       (&ty::ty_uniq(ref a_mt), &ty::ty_uniq(ref b_mt)) => {"}, {"sha": "982e2ca0685b278cb3e91915ca79ca9785edb05a", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -350,7 +350,8 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     match ty::get(main_t).sty {\n         ty::ty_bare_fn(..) => {\n-            match tcx.items.find(&main_id) {\n+            let items = tcx.items.borrow();\n+            match items.get().find(&main_id) {\n                 Some(&ast_map::node_item(it,_)) => {\n                     match it.node {\n                         ast::item_fn(_, _, _, ref ps, _)\n@@ -395,7 +396,8 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n     let start_t = ty::node_id_to_type(tcx, start_id);\n     match ty::get(start_t).sty {\n         ty::ty_bare_fn(_) => {\n-            match tcx.items.find(&start_id) {\n+            let items = tcx.items.borrow();\n+            match items.get().find(&start_id) {\n                 Some(&ast_map::node_item(it,_)) => {\n                     match it.node {\n                         ast::item_fn(_,_,_,ref ps,_)"}, {"sha": "7be5791c074060425fd7d0beea313a2e6d819ea1", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -637,7 +637,10 @@ impl<'a> ConstraintContext<'a> {\n                 self.add_constraints_from_mt(mt, variance);\n             }\n \n-            ty::ty_box(ref mt) |\n+            ty::ty_box(typ) => {\n+                self.add_constraints_from_ty(typ, variance);\n+            }\n+\n             ty::ty_uniq(ref mt) |\n             ty::ty_ptr(ref mt) => {\n                 self.add_constraints_from_mt(mt, variance);"}, {"sha": "6a346eac425b71b56d514542fa2f9208d3f81332", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -72,7 +72,8 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n                             -> (~str, Option<Span>) {\n     return match region {\n       ReScope(node_id) => {\n-        match cx.items.find(&node_id) {\n+        let items = cx.items.borrow();\n+        match items.get().find(&node_id) {\n           Some(&ast_map::node_block(ref blk)) => {\n             explain_span(cx, \"block\", blk.span)\n           }\n@@ -113,7 +114,8 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n                     bound_region_ptr_to_str(cx, fr.bound_region))\n         };\n \n-        match cx.items.find(&fr.scope_id) {\n+        let items = cx.items.borrow();\n+        match items.get().find(&fr.scope_id) {\n           Some(&ast_map::node_block(ref blk)) => {\n             let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n             (format!(\"{} {}\", prefix, msg), opt_span)\n@@ -172,7 +174,8 @@ pub fn bound_region_to_str(cx: ctxt,\n }\n \n pub fn ReScope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n-    match cx.items.find(&node_id) {\n+    let items = cx.items.borrow();\n+    match items.get().find(&node_id) {\n       Some(&ast_map::node_block(ref blk)) => {\n         format!(\"<block at {}>\",\n              cx.sess.codemap.span_to_str(blk.span))\n@@ -451,7 +454,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_uint(ast::ty_u) => ~\"uint\",\n       ty_uint(t) => ast_util::uint_ty_to_str(t),\n       ty_float(t) => ast_util::float_ty_to_str(t),\n-      ty_box(ref tm) => ~\"@\" + mt_to_str(cx, tm),\n+      ty_box(typ) => ~\"@\" + ty_to_str(cx, typ),\n       ty_uniq(ref tm) => ~\"~\" + mt_to_str(cx, tm),\n       ty_ptr(ref tm) => ~\"*\" + mt_to_str(cx, tm),\n       ty_rptr(r, ref tm) => {\n@@ -740,16 +743,21 @@ impl Repr for ast::DefId {\n         // a path for a def-id, so I'll just make a best effort for now\n         // and otherwise fallback to just printing the crate/node pair\n         if self.crate == ast::LOCAL_CRATE {\n-            match tcx.items.find(&self.node) {\n-                Some(&ast_map::node_item(..)) |\n-                Some(&ast_map::node_foreign_item(..)) |\n-                Some(&ast_map::node_method(..)) |\n-                Some(&ast_map::node_trait_method(..)) |\n-                Some(&ast_map::node_variant(..)) |\n-                Some(&ast_map::node_struct_ctor(..)) => {\n-                    return format!(\"{:?}:{}\", *self, ty::item_path_str(tcx, *self));\n+            {\n+                let items = tcx.items.borrow();\n+                match items.get().find(&self.node) {\n+                    Some(&ast_map::node_item(..)) |\n+                    Some(&ast_map::node_foreign_item(..)) |\n+                    Some(&ast_map::node_method(..)) |\n+                    Some(&ast_map::node_trait_method(..)) |\n+                    Some(&ast_map::node_variant(..)) |\n+                    Some(&ast_map::node_struct_ctor(..)) => {\n+                        return format!(\"{:?}:{}\",\n+                                       *self,\n+                                       ty::item_path_str(tcx, *self));\n+                    }\n+                    _ => {}\n                 }\n-                _ => {}\n             }\n         }\n         return format!(\"{:?}\", *self);"}, {"sha": "52dbba13ea8f5f6437f1eb0b3bb59487413d4586", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -594,7 +594,7 @@ pub enum Type {\n     /// aka ty_bot\n     Bottom,\n     Unique(~Type),\n-    Managed(Mutability, ~Type),\n+    Managed(~Type),\n     RawPointer(Mutability, ~Type),\n     BorrowedRef { lifetime: Option<Lifetime>, mutability: Mutability, type_: ~Type},\n     // region, raw, other boxes, mutable\n@@ -620,7 +620,7 @@ impl Clean<Type> for ast::Ty {\n             ty_rptr(ref l, ref m) =>\n                 BorrowedRef {lifetime: l.clean(), mutability: m.mutbl.clean(),\n                              type_: ~m.ty.clean()},\n-            ty_box(ref m) => Managed(m.mutbl.clean(), ~m.ty.clean()),\n+            ty_box(ty) => Managed(~ty.clean()),\n             ty_uniq(ty) => Unique(~ty.clean()),\n             ty_vec(ty) => Vector(~ty.clean()),\n             ty_fixed_length_vec(ty, ref e) => FixedVector(~ty.clean(),"}, {"sha": "42d888dbbe85b442f4c88ea8da47ef0a7d9b7851", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -88,7 +88,7 @@ pub fn run_core (libs: HashSet<Path>, cfgs: ~[~str], path: &Path) -> (clean::Cra\n     let ctxt = @ctxt;\n     local_data::set(super::ctxtkey, ctxt);\n \n-    let v = @mut RustdocVisitor::new();\n+    let mut v = RustdocVisitor::new();\n     v.visit(&ctxt.crate);\n \n     (v.clean(), analysis)"}, {"sha": "b32ca03726103046e12939947969c25c13493961", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -340,13 +340,7 @@ impl fmt::Default for clean::Type {\n             clean::Unit => f.buf.write(\"()\".as_bytes()),\n             clean::Bottom => f.buf.write(\"!\".as_bytes()),\n             clean::Unique(ref t) => write!(f.buf, \"~{}\", **t),\n-            clean::Managed(m, ref t) => {\n-                write!(f.buf, \"@{}{}\",\n-                       match m {\n-                           clean::Mutable => \"mut \",\n-                           clean::Immutable => \"\",\n-                       }, **t)\n-            }\n+            clean::Managed(ref t) => write!(f.buf, \"@{}\", **t),\n             clean::RawPointer(m, ref t) => {\n                 write!(f.buf, \"*{}{}\",\n                        match m {"}, {"sha": "36caed437f511e07cdab913954f7c8af5594bcaf", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -267,11 +267,11 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n /// This input format purely deserializes the json output file. No passes are\n /// run over the deserialized output.\n fn json_input(input: &str) -> Result<Output, ~str> {\n-    let input = match File::open(&Path::new(input)) {\n+    let mut input = match File::open(&Path::new(input)) {\n         Some(f) => f,\n         None => return Err(format!(\"couldn't open {} for reading\", input)),\n     };\n-    match json::from_reader(@mut input as @mut io::Reader) {\n+    match json::from_reader(&mut input) {\n         Err(s) => Err(s.to_str()),\n         Ok(json::Object(obj)) => {\n             let mut obj = obj;\n@@ -332,6 +332,6 @@ fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n     json.insert(~\"crate\", crate_json);\n     json.insert(~\"plugins\", json::Object(plugins_json));\n \n-    let file = @mut File::create(&dst).unwrap();\n-    json::Object(json).to_writer(file as @mut io::Writer);\n+    let mut file = File::create(&dst).unwrap();\n+    json::Object(json).to_writer(&mut file);\n }"}, {"sha": "0fbe585b9bf4513c4b8afe3b2b313bf397fe1fdf", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -67,7 +67,7 @@ pub fn run(input: &str, matches: &getopts::Matches) -> int {\n     };\n     local_data::set(super::ctxtkey, ctx);\n \n-    let v = @mut RustdocVisitor::new();\n+    let mut v = RustdocVisitor::new();\n     v.visit(&ctx.crate);\n     let crate = v.clean();\n     let (crate, _) = passes::unindent_comments(crate);"}, {"sha": "9b6e809f8351f936592d949fa8ac9b58c830d16d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -32,7 +32,7 @@ impl RustdocVisitor {\n }\n \n impl RustdocVisitor {\n-    pub fn visit(@mut self, crate: &ast::Crate) {\n+    pub fn visit(&mut self, crate: &ast::Crate) {\n         self.attrs = crate.attrs.clone();\n         fn visit_struct_def(item: &ast::item, sd: @ast::struct_def, generics:\n                             &ast::Generics) -> Struct {"}, {"sha": "7e43fde7b32359e197afd317ee5b14cf4d58aee9", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -80,8 +80,7 @@ struct ReadyCtx {\n     fns: ~[ListenerFn]\n }\n \n-fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod, fold: &mut CrateSetup)\n-            -> ast::_mod {\n+fn fold_mod(m: &ast::_mod, fold: &mut CrateSetup) -> ast::_mod {\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n             attrs: item.attrs.iter().filter_map(|attr| {\n@@ -101,9 +100,9 @@ fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod, fold: &mut CrateSetup)\n     }, fold)\n }\n \n-fn fold_item(ctx: @mut ReadyCtx, item: @ast::item, fold: &mut CrateSetup)\n+fn fold_item(item: @ast::item, fold: &mut CrateSetup)\n              -> SmallVector<@ast::item> {\n-    ctx.path.push(item.ident);\n+    fold.ctx.path.push(item.ident);\n \n     let mut cmds = ~[];\n     let mut had_pkg_do = false;\n@@ -126,44 +125,44 @@ fn fold_item(ctx: @mut ReadyCtx, item: @ast::item, fold: &mut CrateSetup)\n     }\n \n     if had_pkg_do {\n-        ctx.fns.push(ListenerFn {\n+        fold.ctx.fns.push(ListenerFn {\n             cmds: cmds,\n             span: item.span,\n-            path: /*bad*/ctx.path.clone()\n+            path: /*bad*/fold.ctx.path.clone()\n         });\n     }\n \n     let res = fold::noop_fold_item(item, fold);\n \n-    ctx.path.pop();\n+    fold.ctx.path.pop();\n \n     res\n }\n \n-struct CrateSetup {\n-    ctx: @mut ReadyCtx,\n+struct CrateSetup<'a> {\n+    ctx: &'a mut ReadyCtx,\n }\n \n-impl fold::ast_fold for CrateSetup {\n+impl<'a> fold::ast_fold for CrateSetup<'a> {\n     fn fold_item(&mut self, item: @ast::item) -> SmallVector<@ast::item> {\n-        fold_item(self.ctx, item, self)\n+        fold_item(item, self)\n     }\n     fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n-        fold_mod(self.ctx, module, self)\n+        fold_mod(module, self)\n     }\n }\n \n /// Generate/filter main function, add the list of commands, etc.\n pub fn ready_crate(sess: session::Session,\n                    crate: ast::Crate) -> ast::Crate {\n-    let ctx = @mut ReadyCtx {\n+    let mut ctx = ReadyCtx {\n         sess: sess,\n         ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone()),\n         path: ~[],\n         fns: ~[]\n     };\n     let mut fold = CrateSetup {\n-        ctx: ctx,\n+        ctx: &mut ctx,\n     };\n     fold.fold_crate(crate)\n }"}, {"sha": "b26ceb799a7b683df8f8001d7f99afcf873630f8", "filename": "src/libstd/clone.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibstd%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibstd%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fclone.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -58,12 +58,6 @@ impl<T> Clone for @T {\n     fn clone(&self) -> @T { *self }\n }\n \n-impl<T> Clone for @mut T {\n-    /// Return a shallow copy of the managed box.\n-    #[inline]\n-    fn clone(&self) -> @mut T { *self }\n-}\n-\n impl<'a, T> Clone for &'a T {\n     /// Return a shallow copy of the borrowed pointer.\n     #[inline]\n@@ -168,14 +162,6 @@ impl<T: Freeze + DeepClone + 'static> DeepClone for @T {\n     fn deep_clone(&self) -> @T { @(**self).deep_clone() }\n }\n \n-// FIXME: #6525: should also be implemented for `T: Send + DeepClone`\n-impl<T: Freeze + DeepClone + 'static> DeepClone for @mut T {\n-    /// Return a deep copy of the managed box. The `Freeze` trait is required to prevent performing\n-    /// a deep clone of a potentially cyclical type.\n-    #[inline]\n-    fn deep_clone(&self) -> @mut T { @mut (**self).deep_clone() }\n-}\n-\n macro_rules! deep_clone_impl(\n     ($t:ty) => {\n         impl DeepClone for $t {\n@@ -239,23 +225,6 @@ fn test_managed_clone() {\n     assert_eq!(a, b);\n }\n \n-#[test]\n-fn test_managed_mut_deep_clone() {\n-    let x = @mut 5i;\n-    let y: @mut int = x.deep_clone();\n-    *x = 20;\n-    assert_eq!(*y, 5);\n-}\n-\n-#[test]\n-fn test_managed_mut_clone() {\n-    let a = @mut 5i;\n-    let b: @mut int = a.clone();\n-    assert_eq!(a, b);\n-    *b = 10;\n-    assert_eq!(a, b);\n-}\n-\n #[test]\n fn test_borrowed_clone() {\n     let x = 5i;"}, {"sha": "60f38e3b3defaed163c333ba9053487c2aad7fa7", "filename": "src/libstd/default.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibstd%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibstd%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdefault.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -16,10 +16,6 @@ pub trait Default {\n     fn default() -> Self;\n }\n \n-impl<T: Default + 'static> Default for @mut T {\n-    fn default() -> @mut T { @mut Default::default() }\n-}\n-\n impl<T: Default + 'static> Default for @T {\n     fn default() -> @T { @Default::default() }\n }"}, {"sha": "1b6d1171a52e6504cca04151a382817259ce21b0", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -371,15 +371,17 @@ mod test {\n \n     #[test]\n     #[should_fail]\n+    #[ignore] // borrow issues with RefCell\n     fn push_bytes_fail_reset_len() {\n         // push_bytes unsafely sets the vector length. This is testing that\n         // upon failure the length is reset correctly.\n         let mut reader = ErroringLaterReader {\n             count: 0,\n         };\n-        let buf = @mut ~[8, 9];\n+        // FIXME (#7049): Figure out some other way to do this.\n+        //let buf = @mut ~[8, 9];\n         (|| {\n-            reader.push_bytes(&mut *buf, 4);\n+            //reader.push_bytes(&mut *buf, 4);\n         }).finally(|| {\n             // NB: Using rtassert here to trigger abort on failure since this is a should_fail test\n             // FIXME: #7049 This fails because buf is still borrowed"}, {"sha": "c5705665896f1022258a562f6de57064c507e25f", "filename": "src/libstd/managed.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibstd%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibstd%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmanaged.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -31,13 +31,6 @@ pub fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     a_ptr == b_ptr\n }\n \n-/// Determine if two mutable shared boxes point to the same object\n-#[inline]\n-pub fn mut_ptr_eq<T>(a: @mut T, b: @mut T) -> bool {\n-    let (a_ptr, b_ptr): (*T, *T) = (to_unsafe_ptr(&*a), to_unsafe_ptr(&*b));\n-    a_ptr == b_ptr\n-}\n-\n #[cfg(not(test))]\n impl<T:Eq> Eq for @T {\n     #[inline]\n@@ -46,14 +39,6 @@ impl<T:Eq> Eq for @T {\n     fn ne(&self, other: &@T) -> bool { *(*self) != *(*other) }\n }\n \n-#[cfg(not(test))]\n-impl<T:Eq> Eq for @mut T {\n-    #[inline]\n-    fn eq(&self, other: &@mut T) -> bool { *(*self) == *(*other) }\n-    #[inline]\n-    fn ne(&self, other: &@mut T) -> bool { *(*self) != *(*other) }\n-}\n-\n #[cfg(not(test))]\n impl<T:Ord> Ord for @T {\n     #[inline]\n@@ -66,41 +51,18 @@ impl<T:Ord> Ord for @T {\n     fn gt(&self, other: &@T) -> bool { *(*self) > *(*other) }\n }\n \n-#[cfg(not(test))]\n-impl<T:Ord> Ord for @mut T {\n-    #[inline]\n-    fn lt(&self, other: &@mut T) -> bool { *(*self) < *(*other) }\n-    #[inline]\n-    fn le(&self, other: &@mut T) -> bool { *(*self) <= *(*other) }\n-    #[inline]\n-    fn ge(&self, other: &@mut T) -> bool { *(*self) >= *(*other) }\n-    #[inline]\n-    fn gt(&self, other: &@mut T) -> bool { *(*self) > *(*other) }\n-}\n-\n #[cfg(not(test))]\n impl<T: TotalOrd> TotalOrd for @T {\n     #[inline]\n     fn cmp(&self, other: &@T) -> Ordering { (**self).cmp(*other) }\n }\n \n-#[cfg(not(test))]\n-impl<T: TotalOrd> TotalOrd for @mut T {\n-    #[inline]\n-    fn cmp(&self, other: &@mut T) -> Ordering { (**self).cmp(*other) }\n-}\n-\n #[cfg(not(test))]\n impl<T: TotalEq> TotalEq for @T {\n     #[inline]\n     fn equals(&self, other: &@T) -> bool { (**self).equals(*other) }\n }\n \n-#[cfg(not(test))]\n-impl<T: TotalEq> TotalEq for @mut T {\n-    #[inline]\n-    fn equals(&self, other: &@mut T) -> bool { (**self).equals(*other) }\n-}\n #[test]\n fn test() {\n     let x = @3;"}, {"sha": "d66d13657fc6477861184f708e0e40a5885970c9", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -1079,11 +1079,6 @@ pub fn pow_with_uint<T:NumCast+One+Zero+Div<T,T>+Mul<T,T>>(radix: uint, pow: uin\n     total\n }\n \n-impl<T: Zero + 'static> Zero for @mut T {\n-    fn zero() -> @mut T { @mut Zero::zero() }\n-    fn is_zero(&self) -> bool { (**self).is_zero() }\n-}\n-\n impl<T: Zero + 'static> Zero for @T {\n     fn zero() -> @T { @Zero::zero() }\n     fn is_zero(&self) -> bool { (**self).is_zero() }"}, {"sha": "e60abed42f2545076fe657977936918978595c1f", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -655,13 +655,10 @@ fn test_repr() {\n     exact_test(&(~\"he\\u10f3llo\"), \"~\\\"he\\\\u10f3llo\\\"\");\n \n     exact_test(&(@10), \"@10\");\n-    exact_test(&(@mut 10), \"@mut 10\");\n-    exact_test(&((@mut 10, 2)), \"(@mut 10, 2)\");\n     exact_test(&(~10), \"~10\");\n     exact_test(&(&10), \"&10\");\n     let mut x = 10;\n     exact_test(&(&mut x), \"&mut 10\");\n-    exact_test(&(@mut [1, 2]), \"@mut [1, 2]\");\n \n     exact_test(&(0 as *()), \"(0x0 as *())\");\n     exact_test(&(0 as *mut ()), \"(0x0 as *mut ())\");"}, {"sha": "ae12f944f9c30ad37dc32d4ec3f2f6cf94f30818", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -444,16 +444,20 @@ mod test {\n \n     #[test]\n     fn heap_cycles() {\n+        use cell::RefCell;\n         use option::{Option, Some, None};\n \n         struct List {\n-            next: Option<@mut List>,\n+            next: Option<@RefCell<List>>,\n         }\n \n-        let a = @mut List { next: None };\n-        let b = @mut List { next: Some(a) };\n+        let a = @RefCell::new(List { next: None });\n+        let b = @RefCell::new(List { next: Some(a) });\n \n-        a.next = Some(b);\n+        {\n+            let mut a = a.borrow_mut();\n+            a.get().next = Some(b);\n+        }\n     }\n \n     #[test]"}, {"sha": "bd1c49c6c241fd8c558cfb4d652464634b4eb5f4", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -319,13 +319,6 @@ impl<A:IterBytes> IterBytes for @A {\n     }\n }\n \n-impl<A:IterBytes> IterBytes for @mut A {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        (**self).iter_bytes(lsb0, f)\n-    }\n-}\n-\n impl<A:IterBytes> IterBytes for Rc<A> {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {"}, {"sha": "3523d63ef60dec88b3eb76f86390a4587391cc8f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -15,6 +15,7 @@ use abi::AbiSet;\n use opt_vec::OptVec;\n use parse::token::{interner_get, str_to_ident};\n \n+use std::cell::RefCell;\n use std::hashmap::HashMap;\n use std::option::Option;\n use std::to_str::ToStr;\n@@ -88,9 +89,9 @@ pub type SyntaxContext = u32;\n // it should cut down on memory use *a lot*; applying a mark\n // to a tree containing 50 identifiers would otherwise generate\n pub struct SCTable {\n-    table : ~[SyntaxContext_],\n-    mark_memo : HashMap<(SyntaxContext,Mrk),SyntaxContext>,\n-    rename_memo : HashMap<(SyntaxContext,Ident,Name),SyntaxContext>\n+    table: RefCell<~[SyntaxContext_]>,\n+    mark_memo: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n+    rename_memo: RefCell<HashMap<(SyntaxContext,Ident,Name),SyntaxContext>>,\n }\n \n // NB: these must be placed in any SCTable...\n@@ -414,7 +415,6 @@ pub enum Vstore {\n pub enum ExprVstore {\n     ExprVstoreUniq,                 // ~[1,2,3,4]\n     ExprVstoreBox,                  // @[1,2,3,4]\n-    ExprVstoreMutBox,               // @mut [1,2,3,4]\n     ExprVstoreSlice,                // &[1,2,3,4]\n     ExprVstoreMutSlice,             // &mut [1,2,3,4]\n }\n@@ -443,7 +443,7 @@ pub enum BinOp {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum UnOp {\n-    UnBox(Mutability),\n+    UnBox,\n     UnUniq,\n     UnDeref,\n     UnNot,\n@@ -874,7 +874,7 @@ pub struct TyBareFn {\n pub enum ty_ {\n     ty_nil,\n     ty_bot, /* bottom type */\n-    ty_box(mt),\n+    ty_box(P<Ty>),\n     ty_uniq(P<Ty>),\n     ty_vec(P<Ty>),\n     ty_fixed_length_vec(P<Ty>, @Expr),"}, {"sha": "8a5a1d2426cb6f51805f8c15cec6b25677788df2", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 94, "deletions": 53, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -23,6 +23,7 @@ use print::pprust;\n use visit::{Visitor, fn_kind};\n use visit;\n \n+use std::cell::RefCell;\n use std::hashmap::HashMap;\n use std::vec;\n \n@@ -94,7 +95,7 @@ pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n fn pretty_ty(ty: &Ty, itr: @ident_interner, out: &mut ~str) {\n     let (prefix, subty) = match ty.node {\n         ty_uniq(ty) => (\"$UP$\", &*ty),\n-        ty_box(mt { ty, .. }) => (\"$SP$\", &*ty),\n+        ty_box(ty) => (\"$SP$\", &*ty),\n         ty_ptr(mt { ty, mutbl }) => (if mutbl == MutMutable {\"$RPmut$\"} else {\"$RP$\"},\n                                      &*ty),\n         ty_rptr(_, mt { ty, mutbl }) => (if mutbl == MutMutable {\"$BPmut$\"} else {\"$BP$\"},\n@@ -192,17 +193,17 @@ impl ast_node {\n     }\n }\n \n-pub type map = @mut HashMap<NodeId, ast_node>;\n+pub type map = @RefCell<HashMap<NodeId, ast_node>>;\n \n pub struct Ctx {\n     map: map,\n-    path: path,\n-    diag: @mut SpanHandler,\n+    path: RefCell<path>,\n+    diag: @SpanHandler,\n }\n \n impl Ctx {\n     fn extend(&self, elt: path_elt) -> @path {\n-        @vec::append(self.path.clone(), [elt])\n+        @vec::append(self.path.get(), [elt])\n     }\n \n     fn map_method(&mut self,\n@@ -215,8 +216,10 @@ impl Ctx {\n         } else {\n             node_method(m, impl_did, impl_path)\n         };\n-        self.map.insert(m.id, entry);\n-        self.map.insert(m.self_id, node_local(special_idents::self_));\n+\n+        let mut map = self.map.borrow_mut();\n+        map.get().insert(m.id, entry);\n+        map.get().insert(m.self_id, node_local(special_idents::self_));\n     }\n \n     fn map_struct_def(&mut self,\n@@ -231,10 +234,11 @@ impl Ctx {\n             Some(ctor_id) => {\n                 match parent_node {\n                     node_item(item, _) => {\n-                        self.map.insert(ctor_id,\n-                                        node_struct_ctor(struct_def,\n-                                                         item,\n-                                                         p));\n+                        let mut map = self.map.borrow_mut();\n+                        map.get().insert(ctor_id,\n+                                         node_struct_ctor(struct_def,\n+                                                          item,\n+                                                          p));\n                     }\n                     _ => fail!(\"struct def parent wasn't an item\")\n                 }\n@@ -243,13 +247,17 @@ impl Ctx {\n     }\n \n     fn map_expr(&mut self, ex: @Expr) {\n-        self.map.insert(ex.id, node_expr(ex));\n+        {\n+            let mut map = self.map.borrow_mut();\n+            map.get().insert(ex.id, node_expr(ex));\n+        }\n \n         // Expressions which are or might be calls:\n         {\n             let r = ex.get_callee_id();\n             for callee_id in r.iter() {\n-                self.map.insert(*callee_id, node_callee_scope(ex));\n+                let mut map = self.map.borrow_mut();\n+                map.get().insert(*callee_id, node_callee_scope(ex));\n             }\n         }\n \n@@ -263,35 +271,50 @@ impl Ctx {\n               sp: codemap::Span,\n               id: NodeId) {\n         for a in decl.inputs.iter() {\n-            self.map.insert(a.id, node_arg(a.pat));\n+            let mut map = self.map.borrow_mut();\n+            map.get().insert(a.id, node_arg(a.pat));\n         }\n         match *fk {\n-            visit::fk_method(name, _, _) => { self.path.push(path_name(name)) }\n+            visit::fk_method(name, _, _) => {\n+                let mut path = self.path.borrow_mut();\n+                path.get().push(path_name(name))\n+            }\n             _ => {}\n         }\n         visit::walk_fn(self, fk, decl, body, sp, id, ());\n         match *fk {\n-            visit::fk_method(..) => { self.path.pop(); }\n+            visit::fk_method(..) => {\n+                let mut path = self.path.borrow_mut();\n+                path.get().pop();\n+            }\n             _ => {}\n         }\n     }\n \n     fn map_stmt(&mut self, stmt: @Stmt) {\n-        self.map.insert(stmt_id(stmt), node_stmt(stmt));\n+        {\n+            let mut map = self.map.borrow_mut();\n+            map.get().insert(stmt_id(stmt), node_stmt(stmt));\n+        }\n         visit::walk_stmt(self, stmt, ());\n     }\n \n     fn map_block(&mut self, b: P<Block>) {\n-        self.map.insert(b.id, node_block(b));\n+        {\n+            let mut map = self.map.borrow_mut();\n+            map.get().insert(b.id, node_block(b));\n+        }\n+\n         visit::walk_block(self, b, ());\n     }\n \n     fn map_pat(&mut self, pat: &Pat) {\n         match pat.node {\n             PatIdent(_, ref path, _) => {\n                 // Note: this is at least *potentially* a pattern...\n-                self.map.insert(pat.id,\n-                                node_local(ast_util::path_to_ident(path)));\n+                let mut map = self.map.borrow_mut();\n+                map.get().insert(pat.id,\n+                                 node_local(ast_util::path_to_ident(path)));\n             }\n             _ => ()\n         }\n@@ -303,8 +326,11 @@ impl Ctx {\n impl Visitor<()> for Ctx {\n     fn visit_item(&mut self, i: @item, _: ()) {\n         // clone is FIXME #2543\n-        let item_path = @self.path.clone();\n-        self.map.insert(i.id, node_item(i, item_path));\n+        let item_path = @self.path.get();\n+        {\n+            let mut map = self.map.borrow_mut();\n+            map.get().insert(i.id, node_item(i, item_path));\n+        }\n         match i.node {\n             item_impl(_, ref maybe_trait, ty, ref ms) => {\n                 // Right now the ident on impls is __extensions__ which isn't\n@@ -318,13 +344,15 @@ impl Visitor<()> for Ctx {\n                     self.map_method(impl_did, extended, *m, false)\n                 }\n \n-                self.path.push(elt);\n+                let mut path = self.path.borrow_mut();\n+                path.get().push(elt);\n             }\n             item_enum(ref enum_definition, _) => {\n                 for &v in enum_definition.variants.iter() {\n                     let elt = path_name(i.ident);\n-                    self.map.insert(v.node.id,\n-                                    node_variant(v, i, self.extend(elt)));\n+                    let mut map = self.map.borrow_mut();\n+                    map.get().insert(v.node.id,\n+                                     node_variant(v, i, self.extend(elt)));\n                 }\n             }\n             item_foreign_mod(ref nm) => {\n@@ -336,16 +364,17 @@ impl Visitor<()> for Ctx {\n                         inherited => i.vis\n                     };\n \n-                    self.map.insert(nitem.id,\n-                                    node_foreign_item(*nitem,\n-                                                      nm.abis,\n-                                                      visibility,\n-                                                      // FIXME (#2543)\n+                    let mut map = self.map.borrow_mut();\n+                    map.get().insert(nitem.id,\n+                                     node_foreign_item(*nitem,\n+                                                       nm.abis,\n+                                                       visibility,\n+                                                       // FIXME (#2543)\n                                                         // Anonymous extern\n                                                         // mods go in the\n                                                         // parent scope.\n-                                                        @self.path.clone()\n-                                                      ));\n+                                                        @self.path.get()\n+                                                       ));\n                 }\n             }\n             item_struct(struct_def, _) => {\n@@ -355,7 +384,8 @@ impl Visitor<()> for Ctx {\n             }\n             item_trait(_, ref traits, ref methods) => {\n                 for p in traits.iter() {\n-                    self.map.insert(p.ref_id, node_item(i, item_path));\n+                    let mut map = self.map.borrow_mut();\n+                    map.get().insert(p.ref_id, node_item(i, item_path));\n                 }\n                 for tm in methods.iter() {\n                     let ext = { self.extend(path_name(i.ident)) };\n@@ -364,7 +394,8 @@ impl Visitor<()> for Ctx {\n                         required(ref m) => {\n                             let entry =\n                                 node_trait_method(@(*tm).clone(), d_id, ext);\n-                            self.map.insert(m.id, entry);\n+                            let mut map = self.map.borrow_mut();\n+                            map.get().insert(m.id, entry);\n                         }\n                         provided(m) => {\n                             self.map_method(d_id, ext, m, true);\n@@ -377,13 +408,19 @@ impl Visitor<()> for Ctx {\n \n         match i.node {\n             item_mod(_) | item_foreign_mod(_) => {\n-                self.path.push(path_mod(i.ident));\n+                let mut path = self.path.borrow_mut();\n+                path.get().push(path_mod(i.ident));\n             }\n             item_impl(..) => {} // this was guessed above.\n-            _ => self.path.push(path_name(i.ident))\n+            _ => {\n+                let mut path = self.path.borrow_mut();\n+                path.get().push(path_name(i.ident))\n+            }\n         }\n         visit::walk_item(self, i, ());\n-        self.path.pop();\n+\n+        let mut path = self.path.borrow_mut();\n+        path.get().pop();\n     }\n \n     fn visit_pat(&mut self, pat: &Pat, _: ()) {\n@@ -418,29 +455,29 @@ impl Visitor<()> for Ctx {\n     }\n }\n \n-pub fn map_crate(diag: @mut SpanHandler, c: &Crate) -> map {\n-    let cx = @mut Ctx {\n-        map: @mut HashMap::new(),\n-        path: ~[],\n+pub fn map_crate(diag: @SpanHandler, c: &Crate) -> map {\n+    let mut cx = Ctx {\n+        map: @RefCell::new(HashMap::new()),\n+        path: RefCell::new(~[]),\n         diag: diag,\n     };\n-    visit::walk_crate(cx, c, ());\n+    visit::walk_crate(&mut cx, c, ());\n     cx.map\n }\n \n // Used for items loaded from external crate that are being inlined into this\n // crate.  The `path` should be the path to the item but should not include\n // the item itself.\n-pub fn map_decoded_item(diag: @mut SpanHandler,\n+pub fn map_decoded_item(diag: @SpanHandler,\n                         map: map,\n                         path: path,\n                         ii: &inlined_item) {\n     // I believe it is ok for the local IDs of inlined items from other crates\n     // to overlap with the local ids from this crate, so just generate the ids\n     // starting from 0.\n-    let cx = @mut Ctx {\n+    let mut cx = Ctx {\n         map: map,\n-        path: path.clone(),\n+        path: RefCell::new(path.clone()),\n         diag: diag,\n     };\n \n@@ -450,22 +487,24 @@ pub fn map_decoded_item(diag: @mut SpanHandler,\n     match *ii {\n         ii_item(..) => {} // fallthrough\n         ii_foreign(i) => {\n-            cx.map.insert(i.id, node_foreign_item(i,\n-                                                  AbiSet::Intrinsic(),\n-                                                  i.vis,    // Wrong but OK\n-                                                  @path));\n+            let mut map = cx.map.borrow_mut();\n+            map.get().insert(i.id, node_foreign_item(i,\n+                                                     AbiSet::Intrinsic(),\n+                                                     i.vis,    // Wrong but OK\n+                                                     @path));\n         }\n         ii_method(impl_did, is_provided, m) => {\n             cx.map_method(impl_did, @path, m, is_provided);\n         }\n     }\n \n     // visit the item / method contents and add those to the map:\n-    ii.accept((), cx);\n+    ii.accept((), &mut cx);\n }\n \n pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n-    match map.find(&id) {\n+    let map = map.borrow();\n+    match map.get().find(&id) {\n       None => {\n         format!(\"unknown node (id={})\", id)\n       }\n@@ -529,7 +568,8 @@ pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n \n pub fn node_item_query<Result>(items: map, id: NodeId, query: |@item| -> Result, error_msg: ~str)\n                        -> Result {\n-    match items.find(&id) {\n+    let items = items.borrow();\n+    match items.get().find(&id) {\n         Some(&node_item(it, _)) => query(it),\n         _ => fail!(\"{}\", error_msg)\n     }\n@@ -538,7 +578,8 @@ pub fn node_item_query<Result>(items: map, id: NodeId, query: |@item| -> Result,\n pub fn node_span(items: map,\n                  id: ast::NodeId)\n                  -> Span {\n-    match items.find(&id) {\n+    let items = items.borrow();\n+    match items.get().find(&id) {\n         Some(&node_item(item, _)) => item.span,\n         Some(&node_foreign_item(foreign_item, _, _, _)) => foreign_item.span,\n         Some(&node_trait_method(@required(ref type_method), _, _)) => type_method.span,"}, {"sha": "f99fed517b18c58d1e37921038de8a49fb8ae3d8", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 83, "deletions": 49, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -17,6 +17,7 @@ use parse::token;\n use visit::Visitor;\n use visit;\n \n+use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n use std::u32;\n use std::local_data;\n@@ -136,13 +137,13 @@ pub fn is_shift_binop(b: BinOp) -> bool {\n     }\n }\n \n-pub fn unop_to_str(op: UnOp) -> ~str {\n+pub fn unop_to_str(op: UnOp) -> &'static str {\n     match op {\n-      UnBox(mt) => if mt == MutMutable { ~\"@mut \" } else { ~\"@\" },\n-      UnUniq => ~\"~\",\n-      UnDeref => ~\"*\",\n-      UnNot => ~\"!\",\n-      UnNeg => ~\"-\"\n+      UnBox => \"@\",\n+      UnUniq => \"~\",\n+      UnDeref => \"*\",\n+      UnNot => \"!\",\n+      UnNeg => \"-\",\n     }\n }\n \n@@ -601,21 +602,23 @@ pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &inlined_item,\n }\n \n struct IdRangeComputingVisitor {\n-    result: @mut id_range,\n+    result: Cell<id_range>,\n }\n \n impl IdVisitingOperation for IdRangeComputingVisitor {\n     fn visit_id(&self, id: NodeId) {\n-        self.result.add(id)\n+        let mut id_range = self.result.get();\n+        id_range.add(id);\n+        self.result.set(id_range)\n     }\n }\n \n pub fn compute_id_range_for_inlined_item(item: &inlined_item) -> id_range {\n-    let result = @mut id_range::max();\n-    visit_ids_for_inlined_item(item, &IdRangeComputingVisitor {\n-        result: result,\n-    });\n-    *result\n+    let visitor = IdRangeComputingVisitor {\n+        result: Cell::new(id_range::max())\n+    };\n+    visit_ids_for_inlined_item(item, &visitor);\n+    visitor.result.get()\n }\n \n pub fn is_item_impl(item: @ast::item) -> bool {\n@@ -709,21 +712,25 @@ pub fn new_mark(m:Mrk, tail:SyntaxContext) -> SyntaxContext {\n \n // Extend a syntax context with a given mark and table\n // FIXME #8215 : currently pub to allow testing\n-pub fn new_mark_internal(m:Mrk, tail:SyntaxContext,table:&mut SCTable)\n-    -> SyntaxContext {\n+pub fn new_mark_internal(m: Mrk, tail: SyntaxContext, table: &SCTable)\n+                         -> SyntaxContext {\n     let key = (tail,m);\n     // FIXME #5074 : can't use more natural style because we're missing\n     // flow-sensitivity. Results in two lookups on a hash table hit.\n     // also applies to new_rename_internal, below.\n     // let try_lookup = table.mark_memo.find(&key);\n-    match table.mark_memo.contains_key(&key) {\n+    let mut mark_memo = table.mark_memo.borrow_mut();\n+    match mark_memo.get().contains_key(&key) {\n         false => {\n-            let new_idx = idx_push(&mut table.table,Mark(m,tail));\n-            table.mark_memo.insert(key,new_idx);\n+            let new_idx = {\n+                let mut table = table.table.borrow_mut();\n+                idx_push(table.get(), Mark(m,tail))\n+            };\n+            mark_memo.get().insert(key,new_idx);\n             new_idx\n         }\n         true => {\n-            match table.mark_memo.find(&key) {\n+            match mark_memo.get().find(&key) {\n                 None => fail!(\"internal error: key disappeared 2013042901\"),\n                 Some(idxptr) => {*idxptr}\n             }\n@@ -738,19 +745,26 @@ pub fn new_rename(id:Ident, to:Name, tail:SyntaxContext) -> SyntaxContext {\n \n // Extend a syntax context with a given rename and sctable\n // FIXME #8215 : currently pub to allow testing\n-pub fn new_rename_internal(id:Ident, to:Name, tail:SyntaxContext, table: &mut SCTable)\n-    -> SyntaxContext {\n+pub fn new_rename_internal(id: Ident,\n+                           to: Name,\n+                           tail: SyntaxContext,\n+                           table: &SCTable)\n+                           -> SyntaxContext {\n     let key = (tail,id,to);\n     // FIXME #5074\n     //let try_lookup = table.rename_memo.find(&key);\n-    match table.rename_memo.contains_key(&key) {\n+    let mut rename_memo = table.rename_memo.borrow_mut();\n+    match rename_memo.get().contains_key(&key) {\n         false => {\n-            let new_idx = idx_push(&mut table.table,Rename(id,to,tail));\n-            table.rename_memo.insert(key,new_idx);\n+            let new_idx = {\n+                let mut table = table.table.borrow_mut();\n+                idx_push(table.get(), Rename(id,to,tail))\n+            };\n+            rename_memo.get().insert(key,new_idx);\n             new_idx\n         }\n         true => {\n-            match table.rename_memo.find(&key) {\n+            match rename_memo.get().find(&key) {\n                 None => fail!(\"internal error: key disappeared 2013042902\"),\n                 Some(idxptr) => {*idxptr}\n             }\n@@ -763,18 +777,18 @@ pub fn new_rename_internal(id:Ident, to:Name, tail:SyntaxContext, table: &mut SC\n // FIXME #8215 : currently pub to allow testing\n pub fn new_sctable_internal() -> SCTable {\n     SCTable {\n-        table: ~[EmptyCtxt,IllegalCtxt],\n-        mark_memo: HashMap::new(),\n-        rename_memo: HashMap::new()\n+        table: RefCell::new(~[EmptyCtxt,IllegalCtxt]),\n+        mark_memo: RefCell::new(HashMap::new()),\n+        rename_memo: RefCell::new(HashMap::new()),\n     }\n }\n \n // fetch the SCTable from TLS, create one if it doesn't yet exist.\n-pub fn get_sctable() -> @mut SCTable {\n-    local_data_key!(sctable_key: @@mut SCTable)\n+pub fn get_sctable() -> @SCTable {\n+    local_data_key!(sctable_key: @@SCTable)\n     match local_data::get(sctable_key, |k| k.map(|k| *k)) {\n         None => {\n-            let new_table = @@mut new_sctable_internal();\n+            let new_table = @@new_sctable_internal();\n             local_data::set(sctable_key,new_table);\n             *new_table\n         },\n@@ -785,7 +799,8 @@ pub fn get_sctable() -> @mut SCTable {\n /// print out an SCTable for debugging\n pub fn display_sctable(table : &SCTable) {\n     error!(\"SC table:\");\n-    for (idx,val) in table.table.iter().enumerate() {\n+    let table = table.table.borrow();\n+    for (idx,val) in table.get().iter().enumerate() {\n         error!(\"{:4u} : {:?}\",idx,val);\n     }\n }\n@@ -799,20 +814,22 @@ fn idx_push<T>(vec: &mut ~[T], val: T) -> u32 {\n \n /// Resolve a syntax object to a name, per MTWT.\n pub fn mtwt_resolve(id : Ident) -> Name {\n-    resolve_internal(id, get_sctable(), get_resolve_table())\n+    let resolve_table = get_resolve_table();\n+    let mut resolve_table = resolve_table.borrow_mut();\n+    resolve_internal(id, get_sctable(), resolve_table.get())\n }\n \n // FIXME #8215: must be pub for testing\n pub type ResolveTable = HashMap<(Name,SyntaxContext),Name>;\n \n // okay, I admit, putting this in TLS is not so nice:\n // fetch the SCTable from TLS, create one if it doesn't yet exist.\n-pub fn get_resolve_table() -> @mut ResolveTable {\n-    local_data_key!(resolve_table_key: @@mut ResolveTable)\n+pub fn get_resolve_table() -> @RefCell<ResolveTable> {\n+    local_data_key!(resolve_table_key: @@RefCell<ResolveTable>)\n     match local_data::get(resolve_table_key, |k| k.map(|k| *k)) {\n         None => {\n-            let new_table = @@mut HashMap::new();\n-            local_data::set(resolve_table_key,new_table);\n+            let new_table = @@RefCell::new(HashMap::new());\n+            local_data::set(resolve_table_key, new_table);\n             *new_table\n         },\n         Some(intr) => *intr\n@@ -823,13 +840,17 @@ pub fn get_resolve_table() -> @mut ResolveTable {\n // adding memoization to possibly resolve 500+ seconds in resolve for librustc (!)\n // FIXME #8215 : currently pub to allow testing\n pub fn resolve_internal(id : Ident,\n-                        table : &mut SCTable,\n+                        table : &SCTable,\n                         resolve_table : &mut ResolveTable) -> Name {\n     let key = (id.name,id.ctxt);\n     match resolve_table.contains_key(&key) {\n         false => {\n             let resolved = {\n-                match table.table[id.ctxt] {\n+                let result = {\n+                    let table = table.table.borrow();\n+                    table.get()[id.ctxt]\n+                };\n+                match result {\n                     EmptyCtxt => id.name,\n                     // ignore marks here:\n                     Mark(_,subctxt) =>\n@@ -874,7 +895,11 @@ pub fn marksof(ctxt: SyntaxContext, stopname: Name, table: &SCTable) -> ~[Mrk] {\n     let mut result = ~[];\n     let mut loopvar = ctxt;\n     loop {\n-        match table.table[loopvar] {\n+        let table_entry = {\n+            let table = table.table.borrow();\n+            table.get()[loopvar]\n+        };\n+        match table_entry {\n             EmptyCtxt => {return result;},\n             Mark(mark,tl) => {\n                 xorPush(&mut result,mark);\n@@ -898,7 +923,8 @@ pub fn marksof(ctxt: SyntaxContext, stopname: Name, table: &SCTable) -> ~[Mrk] {\n /// FAILS when outside is not a mark.\n pub fn mtwt_outer_mark(ctxt: SyntaxContext) -> Mrk {\n     let sctable = get_sctable();\n-    match sctable.table[ctxt] {\n+    let table = sctable.table.borrow();\n+    match table.get()[ctxt] {\n         ast::Mark(mrk,_) => mrk,\n         _ => fail!(\"can't retrieve outer mark when outside is not a mark\")\n     }\n@@ -1003,7 +1029,7 @@ mod test {\n \n     // unfold a vector of TestSC values into a SCTable,\n     // returning the resulting index\n-    fn unfold_test_sc(tscs : ~[TestSC], tail: SyntaxContext, table : &mut SCTable)\n+    fn unfold_test_sc(tscs : ~[TestSC], tail: SyntaxContext, table: &SCTable)\n         -> SyntaxContext {\n         tscs.rev_iter().fold(tail, |tail : SyntaxContext, tsc : &TestSC|\n                   {match *tsc {\n@@ -1015,7 +1041,8 @@ mod test {\n     fn refold_test_sc(mut sc: SyntaxContext, table : &SCTable) -> ~[TestSC] {\n         let mut result = ~[];\n         loop {\n-            match table.table[sc] {\n+            let table = table.table.borrow();\n+            match table.get()[sc] {\n                 EmptyCtxt => {return result;},\n                 Mark(mrk,tail) => {\n                     result.push(M(mrk));\n@@ -1037,15 +1064,19 @@ mod test {\n \n         let test_sc = ~[M(3),R(id(101,0),14),M(9)];\n         assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),4);\n-        assert_eq!(t.table[2],Mark(9,0));\n-        assert_eq!(t.table[3],Rename(id(101,0),14,2));\n-        assert_eq!(t.table[4],Mark(3,3));\n+        {\n+            let table = t.table.borrow();\n+            assert_eq!(table.get()[2],Mark(9,0));\n+            assert_eq!(table.get()[3],Rename(id(101,0),14,2));\n+            assert_eq!(table.get()[4],Mark(3,3));\n+        }\n         assert_eq!(refold_test_sc(4,&t),test_sc);\n     }\n \n     // extend a syntax context with a sequence of marks given\n     // in a vector. v[0] will be the outermost mark.\n-    fn unfold_marks(mrks:~[Mrk],tail:SyntaxContext,table: &mut SCTable) -> SyntaxContext {\n+    fn unfold_marks(mrks: ~[Mrk], tail: SyntaxContext, table: &SCTable)\n+                    -> SyntaxContext {\n         mrks.rev_iter().fold(tail, |tail:SyntaxContext, mrk:&Mrk|\n                    {new_mark_internal(*mrk,tail,table)})\n     }\n@@ -1054,8 +1085,11 @@ mod test {\n         let mut t = new_sctable_internal();\n \n         assert_eq!(unfold_marks(~[3,7],EMPTY_CTXT,&mut t),3);\n-        assert_eq!(t.table[2],Mark(7,0));\n-        assert_eq!(t.table[3],Mark(3,2));\n+        {\n+            let table = t.table.borrow();\n+            assert_eq!(table.get()[2],Mark(7,0));\n+            assert_eq!(table.get()[3],Mark(3,2));\n+        }\n     }\n \n     #[test] fn test_marksof () {"}, {"sha": "df8b45dbcf5489d266bab933b4c35cfd222f5d8e", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -355,8 +355,7 @@ pub fn find_stability<AM: AttrMetaMethods, It: Iterator<AM>>(mut metas: It) -> O\n     None\n }\n \n-pub fn require_unique_names(diagnostic: @mut SpanHandler,\n-                            metas: &[@MetaItem]) {\n+pub fn require_unique_names(diagnostic: @SpanHandler, metas: &[@MetaItem]) {\n     let mut set = HashSet::new();\n     for meta in metas.iter() {\n         let name = meta.name();\n@@ -381,7 +380,7 @@ pub fn require_unique_names(diagnostic: @mut SpanHandler,\n  * present (before fields, if any) with that type; reprensentation\n  * optimizations which would remove it will not be done.\n  */\n-pub fn find_repr_attr(diagnostic: @mut SpanHandler, attr: @ast::MetaItem, acc: ReprAttr)\n+pub fn find_repr_attr(diagnostic: @SpanHandler, attr: @ast::MetaItem, acc: ReprAttr)\n     -> ReprAttr {\n     let mut acc = acc;\n     match attr.node {"}, {"sha": "c0aee7fc634b38e541ef899636456b67ac7b2437", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 48, "deletions": 30, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -21,6 +21,7 @@ source code snippets, etc.\n \n */\n \n+use std::cell::RefCell;\n use std::cmp;\n use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -220,9 +221,9 @@ pub struct FileMap {\n     /// The start position of this source in the CodeMap\n     start_pos: BytePos,\n     /// Locations of lines beginnings in the source code\n-    lines: @mut ~[BytePos],\n+    lines: RefCell<~[BytePos]>,\n     /// Locations of multi-byte characters in the source code\n-    multibyte_chars: @mut ~[MultiByteChar],\n+    multibyte_chars: RefCell<~[MultiByteChar]>,\n }\n \n impl FileMap {\n@@ -233,14 +234,16 @@ impl FileMap {\n     // about what ends a line between this file and parse.rs\n     pub fn next_line(&self, pos: BytePos) {\n         // the new charpos must be > the last one (or it's the first one).\n-        let lines = &mut *self.lines;\n-        assert!((lines.len() == 0) || (lines[lines.len() - 1] < pos))\n-        lines.push(pos);\n+        let mut lines = self.lines.borrow_mut();;\n+        let line_len = lines.get().len();\n+        assert!(line_len == 0 || (lines.get()[line_len - 1] < pos))\n+        lines.get().push(pos);\n     }\n \n     // get a line from the list of pre-computed line-beginnings\n     pub fn get_line(&self, line: int) -> ~str {\n-        let begin: BytePos = self.lines[line] - self.start_pos;\n+        let mut lines = self.lines.borrow_mut();\n+        let begin: BytePos = lines.get()[line] - self.start_pos;\n         let begin = begin.to_uint();\n         let slice = self.src.slice_from(begin);\n         match slice.find('\\n') {\n@@ -255,7 +258,8 @@ impl FileMap {\n             pos: pos,\n             bytes: bytes,\n         };\n-        self.multibyte_chars.push(mbc);\n+        let mut multibyte_chars = self.multibyte_chars.borrow_mut();\n+        multibyte_chars.get().push(mbc);\n     }\n \n     pub fn is_real_file(&self) -> bool {\n@@ -264,13 +268,13 @@ impl FileMap {\n }\n \n pub struct CodeMap {\n-    files: @mut ~[@FileMap]\n+    files: RefCell<~[@FileMap]>\n }\n \n impl CodeMap {\n     pub fn new() -> CodeMap {\n         CodeMap {\n-            files: @mut ~[],\n+            files: RefCell::new(~[]),\n         }\n     }\n \n@@ -284,23 +288,23 @@ impl CodeMap {\n                                 substr: FileSubstr,\n                                 src: @str)\n                                 -> @FileMap {\n-        let files = &mut *self.files;\n-        let start_pos = if files.len() == 0 {\n+        let mut files = self.files.borrow_mut();\n+        let start_pos = if files.get().len() == 0 {\n             0\n         } else {\n-            let last_start = files.last().start_pos.to_uint();\n-            let last_len = files.last().src.len();\n+            let last_start = files.get().last().start_pos.to_uint();\n+            let last_len = files.get().last().src.len();\n             last_start + last_len\n         };\n \n         let filemap = @FileMap {\n             name: filename, substr: substr, src: src,\n             start_pos: Pos::from_uint(start_pos),\n-            lines: @mut ~[],\n-            multibyte_chars: @mut ~[],\n+            lines: RefCell::new(~[]),\n+            multibyte_chars: RefCell::new(~[]),\n         };\n \n-        files.push(filemap);\n+        files.get().push(filemap);\n \n         return filemap;\n     }\n@@ -346,9 +350,11 @@ impl CodeMap {\n     }\n \n     pub fn span_to_str(&self, sp: Span) -> ~str {\n-        let files = &*self.files;\n-        if files.len() == 0 && sp == DUMMY_SP {\n-            return ~\"no-location\";\n+        {\n+            let files = self.files.borrow();\n+            if files.get().len() == 0 && sp == DUMMY_SP {\n+                return ~\"no-location\";\n+            }\n         }\n \n         let lo = self.lookup_char_pos_adj(sp.lo);\n@@ -388,7 +394,12 @@ impl CodeMap {\n     }\n \n     pub fn get_filemap(&self, filename: &str) -> @FileMap {\n-        for fm in self.files.iter() { if filename == fm.name { return *fm; } }\n+        let files = self.files.borrow();\n+        for fm in files.get().iter() {\n+            if filename == fm.name {\n+                return *fm\n+            }\n+        }\n         //XXjdm the following triggers a mismatched type bug\n         //      (or expected function, found _|_)\n         fail!(); // (\"asking for \" + filename + \" which we don't know about\");\n@@ -397,13 +408,14 @@ impl CodeMap {\n \n impl CodeMap {\n     fn lookup_filemap_idx(&self, pos: BytePos) -> uint {\n-        let files = &*self.files;\n+        let files = self.files.borrow();\n+        let files = files.get();\n         let len = files.len();\n         let mut a = 0u;\n         let mut b = len;\n         while b - a > 1u {\n             let m = (a + b) / 2u;\n-            if self.files[m].start_pos > pos {\n+            if files[m].start_pos > pos {\n                 b = m;\n             } else {\n                 a = m;\n@@ -419,13 +431,15 @@ impl CodeMap {\n     fn lookup_line(&self, pos: BytePos) -> FileMapAndLine\n     {\n         let idx = self.lookup_filemap_idx(pos);\n-        let f = self.files[idx];\n+\n+        let files = self.files.borrow();\n+        let f = files.get()[idx];\n         let mut a = 0u;\n-        let lines = &*f.lines;\n-        let mut b = lines.len();\n+        let mut lines = f.lines.borrow_mut();\n+        let mut b = lines.get().len();\n         while b - a > 1u {\n             let m = (a + b) / 2u;\n-            if lines[m] > pos { b = m; } else { a = m; }\n+            if lines.get()[m] > pos { b = m; } else { a = m; }\n         }\n         return FileMapAndLine {fm: f, line: a};\n     }\n@@ -434,7 +448,8 @@ impl CodeMap {\n         let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n         let line = a + 1u; // Line numbers start at 1\n         let chpos = self.bytepos_to_local_charpos(pos);\n-        let linebpos = f.lines[a];\n+        let mut lines = f.lines.borrow_mut();\n+        let linebpos = lines.get()[a];\n         let linechpos = self.bytepos_to_local_charpos(linebpos);\n         debug!(\"codemap: byte pos {:?} is on the line at byte pos {:?}\",\n                pos, linebpos);\n@@ -452,7 +467,8 @@ impl CodeMap {\n     fn lookup_byte_offset(&self, bpos: BytePos)\n         -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n-        let fm = self.files[idx];\n+        let files = self.files.borrow();\n+        let fm = files.get()[idx];\n         let offset = bpos - fm.start_pos;\n         return FileMapAndBytePos {fm: fm, pos: offset};\n     }\n@@ -462,12 +478,14 @@ impl CodeMap {\n     fn bytepos_to_local_charpos(&self, bpos: BytePos) -> CharPos {\n         debug!(\"codemap: converting {:?} to char pos\", bpos);\n         let idx = self.lookup_filemap_idx(bpos);\n-        let map = self.files[idx];\n+        let files = self.files.borrow();\n+        let map = files.get()[idx];\n \n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n \n-        for mbc in map.multibyte_chars.iter() {\n+        let multibyte_chars = map.multibyte_chars.borrow();\n+        for mbc in multibyte_chars.get().iter() {\n             debug!(\"codemap: {:?}-byte char at {:?}\", mbc.bytes, mbc.pos);\n             if mbc.pos < bpos {\n                 total_extra_bytes += mbc.bytes;"}, {"sha": "76327c27898f99b671efe3ac744896926e3eb0aa", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -11,6 +11,7 @@\n use codemap::{Pos, Span};\n use codemap;\n \n+use std::cell::Cell;\n use std::io;\n use std::io::stdio::StdWriter;\n use std::local_data;\n@@ -30,32 +31,32 @@ pub trait Emitter {\n // accepts span information for source-location\n // reporting.\n pub struct SpanHandler {\n-    handler: @mut Handler,\n+    handler: @Handler,\n     cm: @codemap::CodeMap,\n }\n \n impl SpanHandler {\n-    pub fn span_fatal(@mut self, sp: Span, msg: &str) -> ! {\n+    pub fn span_fatal(@self, sp: Span, msg: &str) -> ! {\n         self.handler.emit(Some((&*self.cm, sp)), msg, fatal);\n         fail!();\n     }\n-    pub fn span_err(@mut self, sp: Span, msg: &str) {\n+    pub fn span_err(@self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&*self.cm, sp)), msg, error);\n         self.handler.bump_err_count();\n     }\n-    pub fn span_warn(@mut self, sp: Span, msg: &str) {\n+    pub fn span_warn(@self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&*self.cm, sp)), msg, warning);\n     }\n-    pub fn span_note(@mut self, sp: Span, msg: &str) {\n+    pub fn span_note(@self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&*self.cm, sp)), msg, note);\n     }\n-    pub fn span_bug(@mut self, sp: Span, msg: &str) -> ! {\n+    pub fn span_bug(@self, sp: Span, msg: &str) -> ! {\n         self.span_fatal(sp, ice_msg(msg));\n     }\n-    pub fn span_unimpl(@mut self, sp: Span, msg: &str) -> ! {\n+    pub fn span_unimpl(@self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp, ~\"unimplemented \" + msg);\n     }\n-    pub fn handler(@mut self) -> @mut Handler {\n+    pub fn handler(@self) -> @Handler {\n         self.handler\n     }\n }\n@@ -64,53 +65,53 @@ impl SpanHandler {\n // (fatal, bug, unimpl) may cause immediate exit,\n // others log errors for later reporting.\n pub struct Handler {\n-    err_count: uint,\n+    err_count: Cell<uint>,\n     emit: @Emitter,\n }\n \n impl Handler {\n-    pub fn fatal(@mut self, msg: &str) -> ! {\n+    pub fn fatal(@self, msg: &str) -> ! {\n         self.emit.emit(None, msg, fatal);\n         fail!();\n     }\n-    pub fn err(@mut self, msg: &str) {\n+    pub fn err(@self, msg: &str) {\n         self.emit.emit(None, msg, error);\n         self.bump_err_count();\n     }\n-    pub fn bump_err_count(@mut self) {\n-        self.err_count += 1u;\n+    pub fn bump_err_count(@self) {\n+        self.err_count.set(self.err_count.get() + 1u);\n     }\n-    pub fn err_count(@mut self) -> uint {\n-        self.err_count\n+    pub fn err_count(@self) -> uint {\n+        self.err_count.get()\n     }\n-    pub fn has_errors(@mut self) -> bool {\n-        self.err_count > 0u\n+    pub fn has_errors(@self) -> bool {\n+        self.err_count.get()> 0u\n     }\n-    pub fn abort_if_errors(@mut self) {\n+    pub fn abort_if_errors(@self) {\n         let s;\n-        match self.err_count {\n+        match self.err_count.get() {\n           0u => return,\n           1u => s = ~\"aborting due to previous error\",\n           _  => {\n             s = format!(\"aborting due to {} previous errors\",\n-                     self.err_count);\n+                     self.err_count.get());\n           }\n         }\n         self.fatal(s);\n     }\n-    pub fn warn(@mut self, msg: &str) {\n+    pub fn warn(@self, msg: &str) {\n         self.emit.emit(None, msg, warning);\n     }\n-    pub fn note(@mut self, msg: &str) {\n+    pub fn note(@self, msg: &str) {\n         self.emit.emit(None, msg, note);\n     }\n-    pub fn bug(@mut self, msg: &str) -> ! {\n+    pub fn bug(@self, msg: &str) -> ! {\n         self.fatal(ice_msg(msg));\n     }\n-    pub fn unimpl(@mut self, msg: &str) -> ! {\n+    pub fn unimpl(@self, msg: &str) -> ! {\n         self.bug(~\"unimplemented \" + msg);\n     }\n-    pub fn emit(@mut self,\n+    pub fn emit(@self,\n             cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str,\n             lvl: level) {\n@@ -123,22 +124,22 @@ pub fn ice_msg(msg: &str) -> ~str {\n             \\nWe would appreciate a bug report: {}\", msg, BUG_REPORT_URL)\n }\n \n-pub fn mk_span_handler(handler: @mut Handler, cm: @codemap::CodeMap)\n-                    -> @mut SpanHandler {\n-    @mut SpanHandler {\n+pub fn mk_span_handler(handler: @Handler, cm: @codemap::CodeMap)\n+                       -> @SpanHandler {\n+    @SpanHandler {\n         handler: handler,\n         cm: cm,\n     }\n }\n \n-pub fn mk_handler(emitter: Option<@Emitter>) -> @mut Handler {\n+pub fn mk_handler(emitter: Option<@Emitter>) -> @Handler {\n     let emit: @Emitter = match emitter {\n         Some(e) => e,\n         None => @DefaultEmitter as @Emitter\n     };\n \n-    @mut Handler {\n-        err_count: 0,\n+    @Handler {\n+        err_count: Cell::new(0),\n         emit: emit,\n     }\n }\n@@ -327,10 +328,7 @@ fn print_macro_backtrace(cm: &codemap::CodeMap, sp: Span) {\n     }\n }\n \n-pub fn expect<T:Clone>(\n-              diag: @mut SpanHandler,\n-              opt: Option<T>,\n-              msg: || -> ~str)\n+pub fn expect<T:Clone>(diag: @SpanHandler, opt: Option<T>, msg: || -> ~str)\n               -> T {\n     match opt {\n        Some(ref t) => (*t).clone(),"}, {"sha": "b4888f1092f52f385587d3f828c03039dbd1b53e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -284,7 +284,7 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n // when a macro expansion occurs, the resulting nodes have the backtrace()\n // -> expn_info of their expansion context stored into their span.\n pub struct ExtCtxt {\n-    parse_sess: @mut parse::ParseSess,\n+    parse_sess: @parse::ParseSess,\n     cfg: ast::CrateConfig,\n     backtrace: Option<@ExpnInfo>,\n \n@@ -293,7 +293,7 @@ pub struct ExtCtxt {\n }\n \n impl ExtCtxt {\n-    pub fn new(parse_sess: @mut parse::ParseSess, cfg: ast::CrateConfig)\n+    pub fn new(parse_sess: @parse::ParseSess, cfg: ast::CrateConfig)\n                -> ExtCtxt {\n         ExtCtxt {\n             parse_sess: parse_sess,\n@@ -320,7 +320,7 @@ impl ExtCtxt {\n     }\n \n     pub fn codemap(&self) -> @CodeMap { self.parse_sess.cm }\n-    pub fn parse_sess(&self) -> @mut parse::ParseSess { self.parse_sess }\n+    pub fn parse_sess(&self) -> @parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n     pub fn call_site(&self) -> Span {\n         match self.backtrace {"}, {"sha": "481472e8f0b1246a8da1cc3d17b75f0ddf202d37", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -54,7 +54,7 @@ pub trait AstBuilder {\n                lifetime: Option<ast::Lifetime>,\n                mutbl: ast::Mutability) -> P<ast::Ty>;\n     fn ty_uniq(&self, span: Span, ty: P<ast::Ty>) -> P<ast::Ty>;\n-    fn ty_box(&self, span: Span, ty: P<ast::Ty>, mutbl: ast::Mutability) -> P<ast::Ty>;\n+    fn ty_box(&self, span: Span, ty: P<ast::Ty>) -> P<ast::Ty>;\n \n     fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty>;\n     fn ty_infer(&self, sp: Span) -> P<ast::Ty>;\n@@ -311,12 +311,13 @@ impl AstBuilder for ExtCtxt {\n         self.ty(span,\n                 ast::ty_rptr(lifetime, self.ty_mt(ty, mutbl)))\n     }\n+\n     fn ty_uniq(&self, span: Span, ty: P<ast::Ty>) -> P<ast::Ty> {\n         self.ty(span, ast::ty_uniq(ty))\n     }\n-    fn ty_box(&self, span: Span,\n-                 ty: P<ast::Ty>, mutbl: ast::Mutability) -> P<ast::Ty> {\n-        self.ty(span, ast::ty_box(self.ty_mt(ty, mutbl)))\n+\n+    fn ty_box(&self, span: Span, ty: P<ast::Ty>) -> P<ast::Ty> {\n+        self.ty(span, ast::ty_box(ty))\n     }\n \n     fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty> {\n@@ -494,7 +495,7 @@ impl AstBuilder for ExtCtxt {\n     }\n \n     fn expr_managed(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n-        self.expr_unary(sp, ast::UnBox(ast::MutImmutable), e)\n+        self.expr_unary(sp, ast::UnBox, e)\n     }\n \n     fn expr_field_access(&self, sp: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr {"}, {"sha": "89bed626c1ed4d61e375ce5db5c238f591814beb", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -24,7 +24,7 @@ use opt_vec::OptVec;\n /// The types of pointers\n pub enum PtrTy<'a> {\n     Send, // ~\n-    Managed(ast::Mutability), // @[mut]\n+    Managed, // @\n     Borrowed(Option<&'a str>, ast::Mutability), // &['lifetime] [mut]\n }\n \n@@ -138,8 +138,8 @@ impl<'a> Ty<'a> {\n                     Send => {\n                         cx.ty_uniq(span, raw_ty)\n                     }\n-                    Managed(mutbl) => {\n-                        cx.ty_box(span, raw_ty, mutbl)\n+                    Managed => {\n+                        cx.ty_box(span, raw_ty)\n                     }\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = mk_lifetime(cx, span, lt);\n@@ -251,7 +251,7 @@ pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n                 span,\n                 match *ptr {\n                     Send => ast::sty_uniq(ast::MutImmutable),\n-                    Managed(mutbl) => ast::sty_box(mutbl),\n+                    Managed => ast::sty_box(ast::MutImmutable),\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s)));\n                         ast::sty_region(lt, mutbl)"}, {"sha": "aa7c26805c367159602e2a94d22df5198eb0b1f8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -493,13 +493,14 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n             let mut name_finder = new_name_finder(~[]);\n             name_finder.visit_pat(expanded_pat,());\n             // generate fresh names, push them to a new pending list\n-            let new_pending_renames = @mut ~[];\n+            let mut new_pending_renames = ~[];\n             for ident in name_finder.ident_accumulator.iter() {\n                 let new_name = fresh_name(ident);\n                 new_pending_renames.push((*ident,new_name));\n             }\n             let rewritten_pat = {\n-                let mut rename_fld = renames_to_fold(new_pending_renames);\n+                let mut rename_fld =\n+                    renames_to_fold(&mut new_pending_renames);\n                 // rewrite the pattern using the new names (the old ones\n                 // have already been applied):\n                 rename_fld.fold_pat(expanded_pat)\n@@ -889,7 +890,7 @@ impl ast_fold for Injector {\n \n // add a bunch of macros as though they were placed at the head of the\n // program (ick). This should run before cfg stripping.\n-pub fn inject_std_macros(parse_sess: @mut parse::ParseSess,\n+pub fn inject_std_macros(parse_sess: @parse::ParseSess,\n                          cfg: ast::CrateConfig,\n                          c: Crate)\n                          -> Crate {\n@@ -939,7 +940,7 @@ impl<'a> ast_fold for MacroExpander<'a> {\n     }\n }\n \n-pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n+pub fn expand_crate(parse_sess: @parse::ParseSess,\n                     cfg: ast::CrateConfig,\n                     c: Crate) -> Crate {\n     let mut cx = ExtCtxt::new(parse_sess, cfg.clone());\n@@ -981,21 +982,6 @@ impl CtxtFn for Renamer {\n     }\n }\n \n-// a renamer that performs a whole bunch of renames\n-pub struct MultiRenamer {\n-    renames : @mut ~[(ast::Ident,ast::Name)]\n-}\n-\n-impl CtxtFn for MultiRenamer {\n-    fn f(&self, starting_ctxt : ast::SyntaxContext) -> ast::SyntaxContext {\n-        // the individual elements are memoized... it would\n-        // also be possible to memoize on the whole list at once.\n-        self.renames.iter().fold(starting_ctxt,|ctxt,&(from,to)| {\n-            new_rename(from,to,ctxt)\n-        })\n-    }\n-}\n-\n // a marker adds the given mark to the syntax context\n pub struct Marker { mark : Mrk }\n \n@@ -1306,9 +1292,11 @@ mod test {\n         let a3_name = gensym(\"a3\");\n         // a context that renames from (\"a\",empty) to \"a2\" :\n         let ctxt2 = new_rename(ast::Ident::new(a_name),a2_name,EMPTY_CTXT);\n-        let pending_renames = @mut ~[(ast::Ident::new(a_name),a2_name),\n-                                     (ast::Ident{name:a_name,ctxt:ctxt2},a3_name)];\n-        let double_renamed = renames_to_fold(pending_renames).fold_crate(item_ast);\n+        let mut pending_renames = ~[\n+            (ast::Ident::new(a_name),a2_name),\n+            (ast::Ident{name:a_name,ctxt:ctxt2},a3_name)\n+        ];\n+        let double_renamed = renames_to_fold(&mut pending_renames).fold_crate(item_ast);\n         let mut path_finder = new_path_finder(~[]);\n         visit::walk_crate(&mut path_finder, &double_renamed, ());\n         match path_finder.path_accumulator {\n@@ -1318,11 +1306,11 @@ mod test {\n         }\n     }\n \n-    fn fake_print_crate(crate: &ast::Crate) {\n-        let out = @mut std::io::stderr() as @mut std::io::Writer;\n-        let s = pprust::rust_printer(out, get_ident_interner());\n-        pprust::print_crate_(s, crate);\n-    }\n+    //fn fake_print_crate(crate: &ast::Crate) {\n+    //    let mut out = ~std::io::stderr() as ~std::io::Writer;\n+    //    let mut s = pprust::rust_printer(out, get_ident_interner());\n+    //    pprust::print_crate_(&mut s, crate);\n+    //}\n \n     fn expand_crate_str(crate_str: @str) -> ast::Crate {\n         let (crate_ast,ps) = string_to_crate_and_sess(crate_str);\n@@ -1516,8 +1504,12 @@ foo_module!()\n                          mtwt_resolve(v.segments[0].identifier));\n                 let table = get_sctable();\n                 println(\"SC table:\");\n-                for (idx,val) in table.table.iter().enumerate() {\n-                    println!(\"{:4u} : {:?}\",idx,val);\n+\n+                {\n+                    let table = table.table.borrow();\n+                    for (idx,val) in table.get().iter().enumerate() {\n+                        println!(\"{:4u} : {:?}\",idx,val);\n+                    }\n                 }\n             }\n             assert_eq!(mtwt_resolve(v.segments[0].identifier),resolved_binding);"}, {"sha": "5f634f7f054e27b3f69530baad85601ab721075d", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -19,6 +19,7 @@ use parse;\n use parse::token::{get_ident_interner};\n use print::pprust;\n \n+use std::cell::RefCell;\n use std::io;\n use std::io::File;\n use std::str;\n@@ -108,13 +109,14 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n             let s = s.to_managed();\n             // Add this input file to the code map to make it available as\n             // dependency information\n-            cx.parse_sess.cm.files.push(@codemap::FileMap {\n+            let mut files = cx.parse_sess.cm.files.borrow_mut();\n+            files.get().push(@codemap::FileMap {\n                 name: file.display().to_str().to_managed(),\n                 substr: codemap::FssNone,\n                 src: s,\n                 start_pos: codemap::BytePos(0),\n-                lines: @mut ~[],\n-                multibyte_chars: @mut ~[],\n+                lines: RefCell::new(~[]),\n+                multibyte_chars: RefCell::new(~[]),\n             });\n             base::MRExpr(cx.expr_str(sp, s))\n         }"}, {"sha": "a7d1d8fb3663d581644300c7482453347f5755d7", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -25,7 +25,7 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt,\n     let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n                                None,\n                                tt.to_owned());\n-    let rdr = tt_rdr as @mut reader;\n+    let rdr = tt_rdr as @reader;\n     let mut rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n \n     if rust_parser.is_keyword(keywords::True) {"}, {"sha": "8b22e32262b642d1614e9a7e983caca698e6136e", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -188,9 +188,9 @@ pub enum named_match {\n \n pub type earley_item = ~MatcherPos;\n \n-pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n+pub fn nameize(p_s: @ParseSess, ms: &[matcher], res: &[@named_match])\n             -> HashMap<Ident,@named_match> {\n-    fn n_rec(p_s: @mut ParseSess, m: &matcher, res: &[@named_match],\n+    fn n_rec(p_s: @ParseSess, m: &matcher, res: &[@named_match],\n              ret_val: &mut HashMap<Ident, @named_match>) {\n         match *m {\n           codemap::Spanned {node: match_tok(_), .. } => (),\n@@ -221,12 +221,11 @@ pub enum parse_result {\n     error(codemap::Span, ~str)\n }\n \n-pub fn parse_or_else(\n-    sess: @mut ParseSess,\n-    cfg: ast::CrateConfig,\n-    rdr: @mut reader,\n-    ms: ~[matcher]\n-) -> HashMap<Ident, @named_match> {\n+pub fn parse_or_else(sess: @ParseSess,\n+                     cfg: ast::CrateConfig,\n+                     rdr: @reader,\n+                     ms: ~[matcher])\n+                     -> HashMap<Ident, @named_match> {\n     match parse(sess, cfg, rdr, ms) {\n       success(m) => m,\n       failure(sp, str) => sess.span_diagnostic.span_fatal(sp, str),\n@@ -243,12 +242,11 @@ pub fn token_name_eq(t1 : &Token, t2 : &Token) -> bool {\n     }\n }\n \n-pub fn parse(\n-    sess: @mut ParseSess,\n-    cfg: ast::CrateConfig,\n-    rdr: @mut reader,\n-    ms: &[matcher]\n-) -> parse_result {\n+pub fn parse(sess: @ParseSess,\n+             cfg: ast::CrateConfig,\n+             rdr: @reader,\n+             ms: &[matcher])\n+             -> parse_result {\n     let mut cur_eis = ~[];\n     cur_eis.push(initial_matcher_pos(ms.to_owned(), None, rdr.peek().sp.lo));\n "}, {"sha": "32d9ed1238b1dbf5ee5e237813905a8a9f8a0940", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -130,11 +130,7 @@ fn generic_extension(cx: &ExtCtxt,\n         match *lhs {\n           @matched_nonterminal(nt_matchers(ref mtcs)) => {\n             // `none` is because we're not interpolating\n-            let arg_rdr = new_tt_reader(\n-                s_d,\n-                None,\n-                arg.to_owned()\n-            ) as @mut reader;\n+            let arg_rdr = new_tt_reader(s_d, None, arg.to_owned()) as @reader;\n             match parse(cx.parse_sess(), cx.cfg(), arg_rdr, *mtcs) {\n               success(named_matches) => {\n                 let rhs = match rhses[i] {\n@@ -154,10 +150,7 @@ fn generic_extension(cx: &ExtCtxt,\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n                 let trncbr = new_tt_reader(s_d, Some(named_matches),\n                                            rhs);\n-                let p = Parser(cx.parse_sess(),\n-                               cx.cfg(),\n-                               trncbr as @mut reader);\n-\n+                let p = Parser(cx.parse_sess(), cx.cfg(), trncbr as @reader);\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n                 return MRAny(@ParserAnyMacro {\n@@ -218,7 +211,7 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n                                    arg.clone());\n     let argument_map = parse_or_else(cx.parse_sess(),\n                                      cx.cfg(),\n-                                     arg_reader as @mut reader,\n+                                     arg_reader as @reader,\n                                      argument_gram);\n \n     // Extract the arguments:"}, {"sha": "060f6b8a8b92b384c85cf92e30ad6c0a880433d2", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 100, "deletions": 79, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -17,65 +17,66 @@ use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident};\n use parse::token::{ident_to_str};\n use parse::lexer::TokenAndSpan;\n \n+use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n use std::option;\n \n ///an unzipping of `token_tree`s\n struct TtFrame {\n     forest: @~[ast::token_tree],\n-    idx: uint,\n+    idx: Cell<uint>,\n     dotdotdoted: bool,\n     sep: Option<Token>,\n-    up: Option<@mut TtFrame>,\n+    up: Option<@TtFrame>,\n }\n \n pub struct TtReader {\n-    sp_diag: @mut SpanHandler,\n+    sp_diag: @SpanHandler,\n     // the unzipped tree:\n-    stack: @mut TtFrame,\n+    priv stack: RefCell<@TtFrame>,\n     /* for MBE-style macro transcription */\n-    interpolations: HashMap<Ident, @named_match>,\n-    repeat_idx: ~[uint],\n-    repeat_len: ~[uint],\n+    priv interpolations: RefCell<HashMap<Ident, @named_match>>,\n+    priv repeat_idx: RefCell<~[uint]>,\n+    priv repeat_len: RefCell<~[uint]>,\n     /* cached: */\n-    cur_tok: Token,\n-    cur_span: Span\n+    cur_tok: RefCell<Token>,\n+    cur_span: RefCell<Span>,\n }\n \n /** This can do Macro-By-Example transcription. On the other hand, if\n  *  `src` contains no `tt_seq`s and `tt_nonterminal`s, `interp` can (and\n  *  should) be none. */\n-pub fn new_tt_reader(sp_diag: @mut SpanHandler,\n+pub fn new_tt_reader(sp_diag: @SpanHandler,\n                      interp: Option<HashMap<Ident,@named_match>>,\n                      src: ~[ast::token_tree])\n-                  -> @mut TtReader {\n-    let r = @mut TtReader {\n+                     -> @TtReader {\n+    let r = @TtReader {\n         sp_diag: sp_diag,\n-        stack: @mut TtFrame {\n+        stack: RefCell::new(@TtFrame {\n             forest: @src,\n-            idx: 0u,\n+            idx: Cell::new(0u),\n             dotdotdoted: false,\n             sep: None,\n             up: option::None\n-        },\n+        }),\n         interpolations: match interp { /* just a convienience */\n-            None => HashMap::new(),\n-            Some(x) => x\n+            None => RefCell::new(HashMap::new()),\n+            Some(x) => RefCell::new(x),\n         },\n-        repeat_idx: ~[],\n-        repeat_len: ~[],\n+        repeat_idx: RefCell::new(~[]),\n+        repeat_len: RefCell::new(~[]),\n         /* dummy values, never read: */\n-        cur_tok: EOF,\n-        cur_span: DUMMY_SP\n+        cur_tok: RefCell::new(EOF),\n+        cur_span: RefCell::new(DUMMY_SP),\n     };\n     tt_next_token(r); /* get cur_tok and cur_span set up */\n     return r;\n }\n \n-fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n-    @mut TtFrame {\n+fn dup_tt_frame(f: @TtFrame) -> @TtFrame {\n+    @TtFrame {\n         forest: @(*f.forest).clone(),\n-        idx: f.idx,\n+        idx: f.idx.clone(),\n         dotdotdoted: f.dotdotdoted,\n         sep: f.sep.clone(),\n         up: match f.up {\n@@ -85,22 +86,21 @@ fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n     }\n }\n \n-pub fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n-    @mut TtReader {\n+pub fn dup_tt_reader(r: @TtReader) -> @TtReader {\n+    @TtReader {\n         sp_diag: r.sp_diag,\n-        stack: dup_tt_frame(r.stack),\n+        stack: RefCell::new(dup_tt_frame(r.stack.get())),\n         repeat_idx: r.repeat_idx.clone(),\n         repeat_len: r.repeat_len.clone(),\n         cur_tok: r.cur_tok.clone(),\n-        cur_span: r.cur_span,\n+        cur_span: r.cur_span.clone(),\n         interpolations: r.interpolations.clone(),\n     }\n }\n \n \n-fn lookup_cur_matched_by_matched(r: &mut TtReader,\n-                                      start: @named_match)\n-                                   -> @named_match {\n+fn lookup_cur_matched_by_matched(r: &TtReader, start: @named_match)\n+                                 -> @named_match {\n     fn red(ad: @named_match, idx: &uint) -> @named_match {\n         match *ad {\n           matched_nonterminal(_) => {\n@@ -110,15 +110,21 @@ fn lookup_cur_matched_by_matched(r: &mut TtReader,\n           matched_seq(ref ads, _) => ads[*idx]\n         }\n     }\n-    r.repeat_idx.iter().fold(start, red)\n+    let repeat_idx = r.repeat_idx.borrow();\n+    repeat_idx.get().iter().fold(start, red)\n }\n \n-fn lookup_cur_matched(r: &mut TtReader, name: Ident) -> @named_match {\n-    match r.interpolations.find_copy(&name) {\n+fn lookup_cur_matched(r: &TtReader, name: Ident) -> @named_match {\n+    let matched_opt = {\n+        let interpolations = r.interpolations.borrow();\n+        interpolations.get().find_copy(&name)\n+    };\n+    match matched_opt {\n         Some(s) => lookup_cur_matched_by_matched(r, s),\n         None => {\n-            r.sp_diag.span_fatal(r.cur_span, format!(\"unknown macro variable `{}`\",\n-                                                  ident_to_str(&name)));\n+            r.sp_diag.span_fatal(r.cur_span.get(),\n+                                 format!(\"unknown macro variable `{}`\",\n+                                         ident_to_str(&name)));\n         }\n     }\n }\n@@ -130,7 +136,7 @@ enum lis {\n     lis_contradiction(~str),\n }\n \n-fn lockstep_iter_size(t: &token_tree, r: &mut TtReader) -> lis {\n+fn lockstep_iter_size(t: &token_tree, r: &TtReader) -> lis {\n     fn lis_merge(lhs: lis, rhs: lis) -> lis {\n         match lhs {\n           lis_unconstrained => rhs.clone(),\n@@ -166,46 +172,56 @@ fn lockstep_iter_size(t: &token_tree, r: &mut TtReader) -> lis {\n \n // return the next token from the TtReader.\n // EFFECT: advances the reader's token field\n-pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n+pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n     // XXX(pcwalton): Bad copy?\n     let ret_val = TokenAndSpan {\n-        tok: r.cur_tok.clone(),\n-        sp: r.cur_span,\n+        tok: r.cur_tok.get(),\n+        sp: r.cur_span.get(),\n     };\n     loop {\n         {\n-            let stack = &mut *r.stack;\n-            if stack.idx < stack.forest.len() {\n+            let mut stack = r.stack.borrow_mut();\n+            if stack.get().idx.get() < stack.get().forest.len() {\n                 break;\n             }\n         }\n \n         /* done with this set; pop or repeat? */\n-        if ! r.stack.dotdotdoted\n-            || { *r.repeat_idx.last() == *r.repeat_len.last() - 1 } {\n+        if !r.stack.get().dotdotdoted || {\n+                let repeat_idx = r.repeat_idx.borrow();\n+                let repeat_len = r.repeat_len.borrow();\n+                *repeat_idx.get().last() == *repeat_len.get().last() - 1\n+            } {\n \n-            match r.stack.up {\n+            match r.stack.get().up {\n               None => {\n-                r.cur_tok = EOF;\n+                r.cur_tok.set(EOF);\n                 return ret_val;\n               }\n               Some(tt_f) => {\n-                if r.stack.dotdotdoted {\n-                    r.repeat_idx.pop();\n-                    r.repeat_len.pop();\n+                if r.stack.get().dotdotdoted {\n+                    {\n+                        let mut repeat_idx = r.repeat_idx.borrow_mut();\n+                        let mut repeat_len = r.repeat_len.borrow_mut();\n+                        repeat_idx.get().pop();\n+                        repeat_len.get().pop();\n+                    }\n                 }\n \n-                r.stack = tt_f;\n-                r.stack.idx += 1u;\n+                r.stack.set(tt_f);\n+                r.stack.get().idx.set(r.stack.get().idx.get() + 1u);\n               }\n             }\n \n         } else { /* repeat */\n-            r.stack.idx = 0u;\n-            r.repeat_idx[r.repeat_idx.len() - 1u] += 1u;\n-            match r.stack.sep.clone() {\n+            r.stack.get().idx.set(0u);\n+            {\n+                let mut repeat_idx = r.repeat_idx.borrow_mut();\n+                repeat_idx.get()[repeat_idx.get().len() - 1u] += 1u;\n+            }\n+            match r.stack.get().sep.clone() {\n               Some(tk) => {\n-                r.cur_tok = tk; /* repeat same span, I guess */\n+                r.cur_tok.set(tk); /* repeat same span, I guess */\n                 return ret_val;\n               }\n               None => ()\n@@ -215,21 +231,21 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n     loop { /* because it's easiest, this handles `tt_delim` not starting\n     with a `tt_tok`, even though it won't happen */\n         // XXX(pcwalton): Bad copy.\n-        match r.stack.forest[r.stack.idx].clone() {\n+        match r.stack.get().forest[r.stack.get().idx.get()].clone() {\n           tt_delim(tts) => {\n-            r.stack = @mut TtFrame {\n+            r.stack.set(@TtFrame {\n                 forest: tts,\n-                idx: 0u,\n+                idx: Cell::new(0u),\n                 dotdotdoted: false,\n                 sep: None,\n-                up: option::Some(r.stack)\n-            };\n+                up: option::Some(r.stack.get())\n+            });\n             // if this could be 0-length, we'd need to potentially recur here\n           }\n           tt_tok(sp, tok) => {\n-            r.cur_span = sp;\n-            r.cur_tok = tok;\n-            r.stack.idx += 1u;\n+            r.cur_span.set(sp);\n+            r.cur_tok.set(tok);\n+            r.stack.get().idx.set(r.stack.get().idx.get() + 1u);\n             return ret_val;\n           }\n           tt_seq(sp, tts, sep, zerok) => {\n@@ -256,18 +272,22 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                                               once\");\n                           }\n \n-                    r.stack.idx += 1u;\n+                    r.stack.get().idx.set(r.stack.get().idx.get() + 1u);\n                     return tt_next_token(r);\n                 } else {\n-                    r.repeat_len.push(len);\n-                    r.repeat_idx.push(0u);\n-                    r.stack = @mut TtFrame {\n-                        forest: tts,\n-                        idx: 0u,\n-                        dotdotdoted: true,\n-                        sep: sep,\n-                        up: Some(r.stack)\n-                    };\n+                    {\n+                        let mut repeat_idx = r.repeat_idx.borrow_mut();\n+                        let mut repeat_len = r.repeat_len.borrow_mut();\n+                        repeat_len.get().push(len);\n+                        repeat_idx.get().push(0u);\n+                        r.stack.set(@TtFrame {\n+                            forest: tts,\n+                            idx: Cell::new(0u),\n+                            dotdotdoted: true,\n+                            sep: sep,\n+                            up: Some(r.stack.get())\n+                        });\n+                    }\n                 }\n               }\n             }\n@@ -279,20 +299,21 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n               (a) idents can be in lots of places, so it'd be a pain\n               (b) we actually can, since it's a token. */\n               matched_nonterminal(nt_ident(~sn,b)) => {\n-                r.cur_span = sp; r.cur_tok = IDENT(sn,b);\n-                r.stack.idx += 1u;\n+                r.cur_span.set(sp);\n+                r.cur_tok.set(IDENT(sn,b));\n+                r.stack.get().idx.set(r.stack.get().idx.get() + 1u);\n                 return ret_val;\n               }\n               matched_nonterminal(ref other_whole_nt) => {\n                 // XXX(pcwalton): Bad copy.\n-                r.cur_span = sp;\n-                r.cur_tok = INTERPOLATED((*other_whole_nt).clone());\n-                r.stack.idx += 1u;\n+                r.cur_span.set(sp);\n+                r.cur_tok.set(INTERPOLATED((*other_whole_nt).clone()));\n+                r.stack.get().idx.set(r.stack.get().idx.get() + 1u);\n                 return ret_val;\n               }\n               matched_seq(..) => {\n                 r.sp_diag.span_fatal(\n-                    r.cur_span, /* blame the macro writer */\n+                    r.cur_span.get(), /* blame the macro writer */\n                     format!(\"variable '{}' is still repeating at this depth\",\n                          ident_to_str(&ident)));\n               }"}, {"sha": "47130a8e355e8e548cb9dd5a2c11f950f2df16d0", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -238,7 +238,7 @@ pub trait ast_fold {\n     fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n         let node = match t.node {\n             ty_nil | ty_bot | ty_infer => t.node.clone(),\n-            ty_box(ref mt) => ty_box(fold_mt(mt, self)),\n+            ty_box(ty) => ty_box(self.fold_ty(ty)),\n             ty_uniq(ty) => ty_uniq(self.fold_ty(ty)),\n             ty_vec(ty) => ty_vec(self.fold_ty(ty)),\n             ty_ptr(ref mt) => ty_ptr(fold_mt(mt, self)),\n@@ -866,7 +866,7 @@ mod test {\n     use super::*;\n \n     // this version doesn't care about getting comments or docstrings in.\n-    fn fake_print_crate(s: @pprust::ps, crate: &ast::Crate) {\n+    fn fake_print_crate(s: &mut pprust::ps, crate: &ast::Crate) {\n         pprust::print_mod(s, &crate.module, crate.attrs);\n     }\n "}, {"sha": "e0ab7f1535d02a9c7313c85f8cd2cfd1e6db88e6", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -135,50 +135,55 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n     fail!(\"not a doc-comment: {}\", comment);\n }\n \n-fn read_to_eol(rdr: @mut StringReader) -> ~str {\n+fn read_to_eol(rdr: @StringReader) -> ~str {\n     let mut val = ~\"\";\n-    while rdr.curr != '\\n' && !is_eof(rdr) {\n-        val.push_char(rdr.curr);\n+    while rdr.curr.get() != '\\n' && !is_eof(rdr) {\n+        val.push_char(rdr.curr.get());\n         bump(rdr);\n     }\n-    if rdr.curr == '\\n' { bump(rdr); }\n+    if rdr.curr.get() == '\\n' { bump(rdr); }\n     return val;\n }\n \n-fn read_one_line_comment(rdr: @mut StringReader) -> ~str {\n+fn read_one_line_comment(rdr: @StringReader) -> ~str {\n     let val = read_to_eol(rdr);\n     assert!((val[0] == '/' as u8 && val[1] == '/' as u8) ||\n                  (val[0] == '#' as u8 && val[1] == '!' as u8));\n     return val;\n }\n \n-fn consume_non_eol_whitespace(rdr: @mut StringReader) {\n-    while is_whitespace(rdr.curr) && rdr.curr != '\\n' && !is_eof(rdr) {\n+fn consume_non_eol_whitespace(rdr: @StringReader) {\n+    while is_whitespace(rdr.curr.get()) && rdr.curr.get() != '\\n' &&\n+            !is_eof(rdr) {\n         bump(rdr);\n     }\n }\n \n-fn push_blank_line_comment(rdr: @mut StringReader, comments: &mut ~[cmnt]) {\n+fn push_blank_line_comment(rdr: @StringReader, comments: &mut ~[cmnt]) {\n     debug!(\">>> blank-line comment\");\n     let v: ~[~str] = ~[];\n-    comments.push(cmnt {style: blank_line, lines: v, pos: rdr.last_pos});\n+    comments.push(cmnt {\n+        style: blank_line,\n+        lines: v,\n+        pos: rdr.last_pos.get(),\n+    });\n }\n \n-fn consume_whitespace_counting_blank_lines(rdr: @mut StringReader,\n+fn consume_whitespace_counting_blank_lines(rdr: @StringReader,\n                                            comments: &mut ~[cmnt]) {\n-    while is_whitespace(rdr.curr) && !is_eof(rdr) {\n-        if rdr.col == CharPos(0u) && rdr.curr == '\\n' {\n+    while is_whitespace(rdr.curr.get()) && !is_eof(rdr) {\n+        if rdr.col.get() == CharPos(0u) && rdr.curr.get() == '\\n' {\n             push_blank_line_comment(rdr, &mut *comments);\n         }\n         bump(rdr);\n     }\n }\n \n \n-fn read_shebang_comment(rdr: @mut StringReader, code_to_the_left: bool,\n+fn read_shebang_comment(rdr: @StringReader, code_to_the_left: bool,\n                                             comments: &mut ~[cmnt]) {\n     debug!(\">>> shebang comment\");\n-    let p = rdr.last_pos;\n+    let p = rdr.last_pos.get();\n     debug!(\"<<< shebang comment\");\n     comments.push(cmnt {\n         style: if code_to_the_left { trailing } else { isolated },\n@@ -187,12 +192,12 @@ fn read_shebang_comment(rdr: @mut StringReader, code_to_the_left: bool,\n     });\n }\n \n-fn read_line_comments(rdr: @mut StringReader, code_to_the_left: bool,\n+fn read_line_comments(rdr: @StringReader, code_to_the_left: bool,\n                                           comments: &mut ~[cmnt]) {\n     debug!(\">>> line comments\");\n-    let p = rdr.last_pos;\n+    let p = rdr.last_pos.get();\n     let mut lines: ~[~str] = ~[];\n-    while rdr.curr == '/' && nextch(rdr) == '/' {\n+    while rdr.curr.get() == '/' && nextch(rdr) == '/' {\n         let line = read_one_line_comment(rdr);\n         debug!(\"{}\", line);\n         if is_doc_comment(line) { // doc-comments are not put in comments\n@@ -244,22 +249,22 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n     lines.push(s1);\n }\n \n-fn read_block_comment(rdr: @mut StringReader,\n+fn read_block_comment(rdr: @StringReader,\n                       code_to_the_left: bool,\n                       comments: &mut ~[cmnt]) {\n     debug!(\">>> block comment\");\n-    let p = rdr.last_pos;\n+    let p = rdr.last_pos.get();\n     let mut lines: ~[~str] = ~[];\n-    let col: CharPos = rdr.col;\n+    let col: CharPos = rdr.col.get();\n     bump(rdr);\n     bump(rdr);\n \n     let mut curr_line = ~\"/*\";\n \n     // doc-comments are not really comments, they are attributes\n-    if rdr.curr == '*' || rdr.curr == '!' {\n-        while !(rdr.curr == '*' && nextch(rdr) == '/') && !is_eof(rdr) {\n-            curr_line.push_char(rdr.curr);\n+    if rdr.curr.get() == '*' || rdr.curr.get() == '!' {\n+        while !(rdr.curr.get() == '*' && nextch(rdr) == '/') && !is_eof(rdr) {\n+            curr_line.push_char(rdr.curr.get());\n             bump(rdr);\n         }\n         if !is_eof(rdr) {\n@@ -275,22 +280,22 @@ fn read_block_comment(rdr: @mut StringReader,\n         while level > 0 {\n             debug!(\"=== block comment level {}\", level);\n             if is_eof(rdr) {\n-                (rdr as @mut reader).fatal(~\"unterminated block comment\");\n+                (rdr as @reader).fatal(~\"unterminated block comment\");\n             }\n-            if rdr.curr == '\\n' {\n+            if rdr.curr.get() == '\\n' {\n                 trim_whitespace_prefix_and_push_line(&mut lines, curr_line,\n                                                      col);\n                 curr_line = ~\"\";\n                 bump(rdr);\n             } else {\n-                curr_line.push_char(rdr.curr);\n-                if rdr.curr == '/' && nextch(rdr) == '*' {\n+                curr_line.push_char(rdr.curr.get());\n+                if rdr.curr.get() == '/' && nextch(rdr) == '*' {\n                     bump(rdr);\n                     bump(rdr);\n                     curr_line.push_char('*');\n                     level += 1;\n                 } else {\n-                    if rdr.curr == '*' && nextch(rdr) == '/' {\n+                    if rdr.curr.get() == '*' && nextch(rdr) == '/' {\n                         bump(rdr);\n                         bump(rdr);\n                         curr_line.push_char('/');\n@@ -306,28 +311,28 @@ fn read_block_comment(rdr: @mut StringReader,\n \n     let mut style = if code_to_the_left { trailing } else { isolated };\n     consume_non_eol_whitespace(rdr);\n-    if !is_eof(rdr) && rdr.curr != '\\n' && lines.len() == 1u {\n+    if !is_eof(rdr) && rdr.curr.get() != '\\n' && lines.len() == 1u {\n         style = mixed;\n     }\n     debug!(\"<<< block comment\");\n     comments.push(cmnt {style: style, lines: lines, pos: p});\n }\n \n-fn peeking_at_comment(rdr: @mut StringReader) -> bool {\n-    return ((rdr.curr == '/' && nextch(rdr) == '/') ||\n-         (rdr.curr == '/' && nextch(rdr) == '*')) ||\n-         (rdr.curr == '#' && nextch(rdr) == '!');\n+fn peeking_at_comment(rdr: @StringReader) -> bool {\n+    return ((rdr.curr.get() == '/' && nextch(rdr) == '/') ||\n+         (rdr.curr.get() == '/' && nextch(rdr) == '*')) ||\n+         (rdr.curr.get() == '#' && nextch(rdr) == '!');\n }\n \n-fn consume_comment(rdr: @mut StringReader,\n+fn consume_comment(rdr: @StringReader,\n                    code_to_the_left: bool,\n                    comments: &mut ~[cmnt]) {\n     debug!(\">>> consume comment\");\n-    if rdr.curr == '/' && nextch(rdr) == '/' {\n+    if rdr.curr.get() == '/' && nextch(rdr) == '/' {\n         read_line_comments(rdr, code_to_the_left, comments);\n-    } else if rdr.curr == '/' && nextch(rdr) == '*' {\n+    } else if rdr.curr.get() == '/' && nextch(rdr) == '*' {\n         read_block_comment(rdr, code_to_the_left, comments);\n-    } else if rdr.curr == '#' && nextch(rdr) == '!' {\n+    } else if rdr.curr.get() == '#' && nextch(rdr) == '!' {\n         read_shebang_comment(rdr, code_to_the_left, comments);\n     } else { fail!(); }\n     debug!(\"<<< consume comment\");\n@@ -342,7 +347,7 @@ pub struct lit {\n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n pub fn gather_comments_and_literals(span_diagnostic:\n-                                    @mut diagnostic::SpanHandler,\n+                                        @diagnostic::SpanHandler,\n                                     path: @str,\n                                     srdr: &mut io::Reader)\n                                  -> (~[cmnt], ~[lit]) {\n@@ -358,7 +363,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n         loop {\n             let mut code_to_the_left = !first_read;\n             consume_non_eol_whitespace(rdr);\n-            if rdr.curr == '\\n' {\n+            if rdr.curr.get() == '\\n' {\n                 code_to_the_left = false;\n                 consume_whitespace_counting_blank_lines(rdr, &mut comments);\n             }\n@@ -370,7 +375,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n         }\n \n \n-        let bstart = rdr.last_pos;\n+        let bstart = rdr.last_pos.get();\n         rdr.next_token();\n         //discard, and look ahead; we're working with internal state\n         let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();"}, {"sha": "3b81b09112b8d8d4e41b9bdd3cf44e5a708195cc", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 194, "deletions": 179, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -18,19 +18,20 @@ use parse::token;\n use parse::token::{str_to_ident};\n \n use std::cast::transmute;\n+use std::cell::{Cell, RefCell};\n use std::char;\n use std::num::from_str_radix;\n use std::util;\n \n pub use ext::tt::transcribe::{TtReader, new_tt_reader};\n \n pub trait reader {\n-    fn is_eof(@mut self) -> bool;\n-    fn next_token(@mut self) -> TokenAndSpan;\n-    fn fatal(@mut self, ~str) -> !;\n-    fn span_diag(@mut self) -> @mut SpanHandler;\n-    fn peek(@mut self) -> TokenAndSpan;\n-    fn dup(@mut self) -> @mut reader;\n+    fn is_eof(@self) -> bool;\n+    fn next_token(@self) -> TokenAndSpan;\n+    fn fatal(@self, ~str) -> !;\n+    fn span_diag(@self) -> @SpanHandler;\n+    fn peek(@self) -> TokenAndSpan;\n+    fn dup(@self) -> @reader;\n }\n \n #[deriving(Clone, Eq)]\n@@ -40,47 +41,47 @@ pub struct TokenAndSpan {\n }\n \n pub struct StringReader {\n-    span_diagnostic: @mut SpanHandler,\n+    span_diagnostic: @SpanHandler,\n     src: @str,\n     // The absolute offset within the codemap of the next character to read\n-    pos: BytePos,\n+    pos: Cell<BytePos>,\n     // The absolute offset within the codemap of the last character read(curr)\n-    last_pos: BytePos,\n+    last_pos: Cell<BytePos>,\n     // The column of the next character to read\n-    col: CharPos,\n+    col: Cell<CharPos>,\n     // The last character to be read\n-    curr: char,\n+    curr: Cell<char>,\n     filemap: @codemap::FileMap,\n     /* cached: */\n-    peek_tok: token::Token,\n-    peek_span: Span\n+    peek_tok: RefCell<token::Token>,\n+    peek_span: RefCell<Span>,\n }\n \n-pub fn new_string_reader(span_diagnostic: @mut SpanHandler,\n+pub fn new_string_reader(span_diagnostic: @SpanHandler,\n                          filemap: @codemap::FileMap)\n-                      -> @mut StringReader {\n+                      -> @StringReader {\n     let r = new_low_level_string_reader(span_diagnostic, filemap);\n     string_advance_token(r); /* fill in peek_* */\n     return r;\n }\n \n /* For comments.rs, which hackily pokes into 'pos' and 'curr' */\n-pub fn new_low_level_string_reader(span_diagnostic: @mut SpanHandler,\n+pub fn new_low_level_string_reader(span_diagnostic: @SpanHandler,\n                                    filemap: @codemap::FileMap)\n-                                -> @mut StringReader {\n+                                -> @StringReader {\n     // Force the initial reader bump to start on a fresh line\n     let initial_char = '\\n';\n-    let r = @mut StringReader {\n+    let r = @StringReader {\n         span_diagnostic: span_diagnostic,\n         src: filemap.src,\n-        pos: filemap.start_pos,\n-        last_pos: filemap.start_pos,\n-        col: CharPos(0),\n-        curr: initial_char,\n+        pos: Cell::new(filemap.start_pos),\n+        last_pos: Cell::new(filemap.start_pos),\n+        col: Cell::new(CharPos(0)),\n+        curr: Cell::new(initial_char),\n         filemap: filemap,\n         /* dummy values; not read */\n-        peek_tok: token::EOF,\n-        peek_span: codemap::DUMMY_SP\n+        peek_tok: RefCell::new(token::EOF),\n+        peek_span: RefCell::new(codemap::DUMMY_SP),\n     };\n     bump(r);\n     return r;\n@@ -89,78 +90,84 @@ pub fn new_low_level_string_reader(span_diagnostic: @mut SpanHandler,\n // duplicating the string reader is probably a bad idea, in\n // that using them will cause interleaved pushes of line\n // offsets to the underlying filemap...\n-fn dup_string_reader(r: @mut StringReader) -> @mut StringReader {\n-    @mut StringReader {\n+fn dup_string_reader(r: @StringReader) -> @StringReader {\n+    @StringReader {\n         span_diagnostic: r.span_diagnostic,\n         src: r.src,\n-        pos: r.pos,\n-        last_pos: r.last_pos,\n-        col: r.col,\n-        curr: r.curr,\n+        pos: Cell::new(r.pos.get()),\n+        last_pos: Cell::new(r.last_pos.get()),\n+        col: Cell::new(r.col.get()),\n+        curr: Cell::new(r.curr.get()),\n         filemap: r.filemap,\n         peek_tok: r.peek_tok.clone(),\n-        peek_span: r.peek_span\n+        peek_span: r.peek_span.clone(),\n     }\n }\n \n impl reader for StringReader {\n-    fn is_eof(@mut self) -> bool { is_eof(self) }\n+    fn is_eof(@self) -> bool { is_eof(self) }\n     // return the next token. EFFECT: advances the string_reader.\n-    fn next_token(@mut self) -> TokenAndSpan {\n-        let ret_val = TokenAndSpan {\n-            tok: util::replace(&mut self.peek_tok, token::UNDERSCORE),\n-            sp: self.peek_span,\n+    fn next_token(@self) -> TokenAndSpan {\n+        let ret_val = {\n+            let mut peek_tok = self.peek_tok.borrow_mut();\n+            TokenAndSpan {\n+                tok: util::replace(peek_tok.get(), token::UNDERSCORE),\n+                sp: self.peek_span.get(),\n+            }\n         };\n         string_advance_token(self);\n         ret_val\n     }\n-    fn fatal(@mut self, m: ~str) -> ! {\n-        self.span_diagnostic.span_fatal(self.peek_span, m)\n+    fn fatal(@self, m: ~str) -> ! {\n+        self.span_diagnostic.span_fatal(self.peek_span.get(), m)\n     }\n-    fn span_diag(@mut self) -> @mut SpanHandler { self.span_diagnostic }\n-    fn peek(@mut self) -> TokenAndSpan {\n+    fn span_diag(@self) -> @SpanHandler { self.span_diagnostic }\n+    fn peek(@self) -> TokenAndSpan {\n         // XXX(pcwalton): Bad copy!\n         TokenAndSpan {\n-            tok: self.peek_tok.clone(),\n-            sp: self.peek_span,\n+            tok: self.peek_tok.get(),\n+            sp: self.peek_span.get(),\n         }\n     }\n-    fn dup(@mut self) -> @mut reader { dup_string_reader(self) as @mut reader }\n+    fn dup(@self) -> @reader { dup_string_reader(self) as @reader }\n }\n \n impl reader for TtReader {\n-    fn is_eof(@mut self) -> bool { self.cur_tok == token::EOF }\n-    fn next_token(@mut self) -> TokenAndSpan {\n+    fn is_eof(@self) -> bool {\n+        let cur_tok = self.cur_tok.borrow();\n+        *cur_tok.get() == token::EOF\n+    }\n+    fn next_token(@self) -> TokenAndSpan {\n         let r = tt_next_token(self);\n         debug!(\"TtReader: r={:?}\", r);\n         return r;\n     }\n-    fn fatal(@mut self, m: ~str) -> ! {\n-        self.sp_diag.span_fatal(self.cur_span, m);\n+    fn fatal(@self, m: ~str) -> ! {\n+        self.sp_diag.span_fatal(self.cur_span.get(), m);\n     }\n-    fn span_diag(@mut self) -> @mut SpanHandler { self.sp_diag }\n-    fn peek(@mut self) -> TokenAndSpan {\n+    fn span_diag(@self) -> @SpanHandler { self.sp_diag }\n+    fn peek(@self) -> TokenAndSpan {\n         TokenAndSpan {\n-            tok: self.cur_tok.clone(),\n-            sp: self.cur_span,\n+            tok: self.cur_tok.get(),\n+            sp: self.cur_span.get(),\n         }\n     }\n-    fn dup(@mut self) -> @mut reader { dup_tt_reader(self) as @mut reader }\n+    fn dup(@self) -> @reader { dup_tt_reader(self) as @reader }\n }\n \n // report a lexical error spanning [`from_pos`, `to_pos`)\n-fn fatal_span(rdr: @mut StringReader,\n+fn fatal_span(rdr: @StringReader,\n               from_pos: BytePos,\n               to_pos: BytePos,\n               m: ~str)\n            -> ! {\n-    rdr.peek_span = codemap::mk_sp(from_pos, to_pos);\n+    rdr.peek_span.set(codemap::mk_sp(from_pos, to_pos));\n     rdr.fatal(m);\n }\n \n // report a lexical error spanning [`from_pos`, `to_pos`), appending an\n // escaped character to the error message\n-fn fatal_span_char(rdr: @mut StringReader,\n+fn fatal_span_char(rdr: @StringReader,\n                    from_pos: BytePos,\n                    to_pos: BytePos,\n                    m: ~str,\n@@ -174,7 +181,7 @@ fn fatal_span_char(rdr: @mut StringReader,\n \n // report a lexical error spanning [`from_pos`, `to_pos`), appending the\n // offending string to the error message\n-fn fatal_span_verbose(rdr: @mut StringReader,\n+fn fatal_span_verbose(rdr: @StringReader,\n                       from_pos: BytePos,\n                       to_pos: BytePos,\n                       m: ~str)\n@@ -190,19 +197,20 @@ fn fatal_span_verbose(rdr: @mut StringReader,\n \n // EFFECT: advance peek_tok and peek_span to refer to the next token.\n // EFFECT: update the interner, maybe.\n-fn string_advance_token(r: @mut StringReader) {\n+fn string_advance_token(r: @StringReader) {\n     match (consume_whitespace_and_comments(r)) {\n         Some(comment) => {\n-            r.peek_span = comment.sp;\n-            r.peek_tok = comment.tok;\n+            r.peek_span.set(comment.sp);\n+            r.peek_tok.set(comment.tok);\n         },\n         None => {\n             if is_eof(r) {\n-                r.peek_tok = token::EOF;\n+                r.peek_tok.set(token::EOF);\n             } else {\n-                let start_bytepos = r.last_pos;\n-                r.peek_tok = next_token_inner(r);\n-                r.peek_span = codemap::mk_sp(start_bytepos, r.last_pos);\n+                let start_bytepos = r.last_pos.get();\n+                r.peek_tok.set(next_token_inner(r));\n+                r.peek_span.set(codemap::mk_sp(start_bytepos,\n+                                               r.last_pos.get()));\n             };\n         }\n     }\n@@ -216,17 +224,17 @@ fn byte_offset(rdr: &StringReader, pos: BytePos) -> BytePos {\n /// up to but excluding `rdr.last_pos`, meaning the slice does not include\n /// the character `rdr.curr`.\n pub fn with_str_from<T>(\n-                     rdr: @mut StringReader,\n+                     rdr: @StringReader,\n                      start: BytePos,\n                      f: |s: &str| -> T)\n                      -> T {\n-    with_str_from_to(rdr, start, rdr.last_pos, f)\n+    with_str_from_to(rdr, start, rdr.last_pos.get(), f)\n }\n \n /// Calls `f` with astring slice of the source text spanning from `start`\n /// up to but excluding `end`.\n fn with_str_from_to<T>(\n-                    rdr: @mut StringReader,\n+                    rdr: @StringReader,\n                     start: BytePos,\n                     end: BytePos,\n                     f: |s: &str| -> T)\n@@ -238,35 +246,37 @@ fn with_str_from_to<T>(\n \n // EFFECT: advance the StringReader by one character. If a newline is\n // discovered, add it to the FileMap's list of line start offsets.\n-pub fn bump(rdr: &mut StringReader) {\n-    rdr.last_pos = rdr.pos;\n-    let current_byte_offset = byte_offset(rdr, rdr.pos).to_uint();\n+pub fn bump(rdr: &StringReader) {\n+    rdr.last_pos.set(rdr.pos.get());\n+    let current_byte_offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n     if current_byte_offset < (rdr.src).len() {\n-        assert!(rdr.curr != unsafe { transmute(-1u32) }); // FIXME: #8971: unsound\n-        let last_char = rdr.curr;\n+        assert!(rdr.curr.get() != unsafe {\n+            transmute(-1u32)\n+        }); // FIXME: #8971: unsound\n+        let last_char = rdr.curr.get();\n         let next = rdr.src.char_range_at(current_byte_offset);\n         let byte_offset_diff = next.next - current_byte_offset;\n-        rdr.pos = rdr.pos + Pos::from_uint(byte_offset_diff);\n-        rdr.curr = next.ch;\n-        rdr.col = rdr.col + CharPos(1u);\n+        rdr.pos.set(rdr.pos.get() + Pos::from_uint(byte_offset_diff));\n+        rdr.curr.set(next.ch);\n+        rdr.col.set(rdr.col.get() + CharPos(1u));\n         if last_char == '\\n' {\n-            rdr.filemap.next_line(rdr.last_pos);\n-            rdr.col = CharPos(0u);\n+            rdr.filemap.next_line(rdr.last_pos.get());\n+            rdr.col.set(CharPos(0u));\n         }\n \n         if byte_offset_diff > 1 {\n             rdr.filemap.record_multibyte_char(\n                 Pos::from_uint(current_byte_offset), byte_offset_diff);\n         }\n     } else {\n-        rdr.curr = unsafe { transmute(-1u32) }; // FIXME: #8971: unsound\n+        rdr.curr.set(unsafe { transmute(-1u32) }); // FIXME: #8971: unsound\n     }\n }\n-pub fn is_eof(rdr: @mut StringReader) -> bool {\n-    rdr.curr == unsafe { transmute(-1u32) } // FIXME: #8971: unsound\n+pub fn is_eof(rdr: @StringReader) -> bool {\n+    rdr.curr.get() == unsafe { transmute(-1u32) } // FIXME: #8971: unsound\n }\n-pub fn nextch(rdr: @mut StringReader) -> char {\n-    let offset = byte_offset(rdr, rdr.pos).to_uint();\n+pub fn nextch(rdr: @StringReader) -> char {\n+    let offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n     if offset < (rdr.src).len() {\n         return rdr.src.char_at(offset);\n     } else { return unsafe { transmute(-1u32) }; } // FIXME: #8971: unsound\n@@ -296,9 +306,9 @@ fn is_hex_digit(c: char) -> bool {\n \n // EFFECT: eats whitespace and comments.\n // returns a Some(sugared-doc-attr) if one exists, None otherwise.\n-fn consume_whitespace_and_comments(rdr: @mut StringReader)\n+fn consume_whitespace_and_comments(rdr: @StringReader)\n                                 -> Option<TokenAndSpan> {\n-    while is_whitespace(rdr.curr) { bump(rdr); }\n+    while is_whitespace(rdr.curr.get()) { bump(rdr); }\n     return consume_any_line_comment(rdr);\n }\n \n@@ -309,25 +319,25 @@ pub fn is_line_non_doc_comment(s: &str) -> bool {\n // PRECONDITION: rdr.curr is not whitespace\n // EFFECT: eats any kind of comment.\n // returns a Some(sugared-doc-attr) if one exists, None otherwise\n-fn consume_any_line_comment(rdr: @mut StringReader)\n+fn consume_any_line_comment(rdr: @StringReader)\n                          -> Option<TokenAndSpan> {\n-    if rdr.curr == '/' {\n+    if rdr.curr.get() == '/' {\n         match nextch(rdr) {\n           '/' => {\n             bump(rdr);\n             bump(rdr);\n             // line comments starting with \"///\" or \"//!\" are doc-comments\n-            if rdr.curr == '/' || rdr.curr == '!' {\n-                let start_bpos = rdr.pos - BytePos(3);\n-                while rdr.curr != '\\n' && !is_eof(rdr) {\n+            if rdr.curr.get() == '/' || rdr.curr.get() == '!' {\n+                let start_bpos = rdr.pos.get() - BytePos(3);\n+                while rdr.curr.get() != '\\n' && !is_eof(rdr) {\n                     bump(rdr);\n                 }\n                 let ret = with_str_from(rdr, start_bpos, |string| {\n                     // but comments with only more \"/\"s are not\n                     if !is_line_non_doc_comment(string) {\n                         Some(TokenAndSpan{\n                             tok: token::DOC_COMMENT(str_to_ident(string)),\n-                            sp: codemap::mk_sp(start_bpos, rdr.pos)\n+                            sp: codemap::mk_sp(start_bpos, rdr.pos.get())\n                         })\n                     } else {\n                         None\n@@ -338,23 +348,26 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n                     return ret;\n                 }\n             } else {\n-                while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n+                while rdr.curr.get() != '\\n' && !is_eof(rdr) { bump(rdr); }\n             }\n             // Restart whitespace munch.\n             return consume_whitespace_and_comments(rdr);\n           }\n           '*' => { bump(rdr); bump(rdr); return consume_block_comment(rdr); }\n           _ => ()\n         }\n-    } else if rdr.curr == '#' {\n+    } else if rdr.curr.get() == '#' {\n         if nextch(rdr) == '!' {\n             // I guess this is the only way to figure out if\n             // we're at the beginning of the file...\n             let cmap = @CodeMap::new();\n-            (*cmap).files.push(rdr.filemap);\n-            let loc = cmap.lookup_char_pos_adj(rdr.last_pos);\n+            {\n+                let mut files = cmap.files.borrow_mut();\n+                files.get().push(rdr.filemap);\n+            }\n+            let loc = cmap.lookup_char_pos_adj(rdr.last_pos.get());\n             if loc.line == 1u && loc.col == CharPos(0u) {\n-                while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n+                while rdr.curr.get() != '\\n' && !is_eof(rdr) { bump(rdr); }\n                 return consume_whitespace_and_comments(rdr);\n             }\n         }\n@@ -367,11 +380,10 @@ pub fn is_block_non_doc_comment(s: &str) -> bool {\n }\n \n // might return a sugared-doc-attr\n-fn consume_block_comment(rdr: @mut StringReader)\n-                      -> Option<TokenAndSpan> {\n+fn consume_block_comment(rdr: @StringReader) -> Option<TokenAndSpan> {\n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n-    let is_doc_comment = rdr.curr == '*' || rdr.curr == '!';\n-    let start_bpos = rdr.pos - BytePos(if is_doc_comment {3} else {2});\n+    let is_doc_comment = rdr.curr.get() == '*' || rdr.curr.get() == '!';\n+    let start_bpos = rdr.pos.get() - BytePos(if is_doc_comment {3} else {2});\n \n     let mut level: int = 1;\n     while level > 0 {\n@@ -381,12 +393,12 @@ fn consume_block_comment(rdr: @mut StringReader)\n             } else {\n                 ~\"unterminated block comment\"\n             };\n-            fatal_span(rdr, start_bpos, rdr.last_pos, msg);\n-        } else if rdr.curr == '/' && nextch(rdr) == '*' {\n+            fatal_span(rdr, start_bpos, rdr.last_pos.get(), msg);\n+        } else if rdr.curr.get() == '/' && nextch(rdr) == '*' {\n             level += 1;\n             bump(rdr);\n             bump(rdr);\n-        } else if rdr.curr == '*' && nextch(rdr) == '/' {\n+        } else if rdr.curr.get() == '*' && nextch(rdr) == '/' {\n             level -= 1;\n             bump(rdr);\n             bump(rdr);\n@@ -401,7 +413,7 @@ fn consume_block_comment(rdr: @mut StringReader)\n             if !is_block_non_doc_comment(string) {\n                 Some(TokenAndSpan{\n                         tok: token::DOC_COMMENT(str_to_ident(string)),\n-                        sp: codemap::mk_sp(start_bpos, rdr.pos)\n+                        sp: codemap::mk_sp(start_bpos, rdr.pos.get())\n                     })\n             } else {\n                 None\n@@ -415,13 +427,13 @@ fn consume_block_comment(rdr: @mut StringReader)\n     if res.is_some() { res } else { consume_whitespace_and_comments(rdr) }\n }\n \n-fn scan_exponent(rdr: @mut StringReader, start_bpos: BytePos) -> Option<~str> {\n-    let mut c = rdr.curr;\n+fn scan_exponent(rdr: @StringReader, start_bpos: BytePos) -> Option<~str> {\n+    let mut c = rdr.curr.get();\n     let mut rslt = ~\"\";\n     if c == 'e' || c == 'E' {\n         rslt.push_char(c);\n         bump(rdr);\n-        c = rdr.curr;\n+        c = rdr.curr.get();\n         if c == '-' || c == '+' {\n             rslt.push_char(c);\n             bump(rdr);\n@@ -430,16 +442,16 @@ fn scan_exponent(rdr: @mut StringReader, start_bpos: BytePos) -> Option<~str> {\n         if exponent.len() > 0u {\n             return Some(rslt + exponent);\n         } else {\n-            fatal_span(rdr, start_bpos, rdr.last_pos,\n+            fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                        ~\"scan_exponent: bad fp literal\");\n         }\n     } else { return None::<~str>; }\n }\n \n-fn scan_digits(rdr: @mut StringReader, radix: uint) -> ~str {\n+fn scan_digits(rdr: @StringReader, radix: uint) -> ~str {\n     let mut rslt = ~\"\";\n     loop {\n-        let c = rdr.curr;\n+        let c = rdr.curr.get();\n         if c == '_' { bump(rdr); continue; }\n         match char::to_digit(c, radix) {\n           Some(_) => {\n@@ -451,12 +463,12 @@ fn scan_digits(rdr: @mut StringReader, radix: uint) -> ~str {\n     };\n }\n \n-fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n+fn scan_number(c: char, rdr: @StringReader) -> token::Token {\n     let mut num_str;\n     let mut base = 10u;\n     let mut c = c;\n     let mut n = nextch(rdr);\n-    let start_bpos = rdr.last_pos;\n+    let start_bpos = rdr.last_pos.get();\n     if c == '0' && n == 'x' {\n         bump(rdr);\n         bump(rdr);\n@@ -471,7 +483,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         base = 2u;\n     }\n     num_str = scan_digits(rdr, base);\n-    c = rdr.curr;\n+    c = rdr.curr.get();\n     nextch(rdr);\n     if c == 'u' || c == 'i' {\n         enum Result { Signed(ast::int_ty), Unsigned(ast::uint_ty) }\n@@ -481,7 +493,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n             else { Unsigned(ast::ty_u) }\n         };\n         bump(rdr);\n-        c = rdr.curr;\n+        c = rdr.curr.get();\n         if c == '8' {\n             bump(rdr);\n             tp = if signed { Signed(ast::ty_i8) }\n@@ -505,12 +517,12 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n                       else { Unsigned(ast::ty_u64) };\n         }\n         if num_str.len() == 0u {\n-            fatal_span(rdr, start_bpos, rdr.last_pos,\n+            fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                        ~\"no valid digits found for number\");\n         }\n         let parsed = match from_str_radix::<u64>(num_str, base as uint) {\n             Some(p) => p,\n-            None => fatal_span(rdr, start_bpos, rdr.last_pos,\n+            None => fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                                ~\"int literal is too large\")\n         };\n \n@@ -520,7 +532,8 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         }\n     }\n     let mut is_float = false;\n-    if rdr.curr == '.' && !(ident_start(nextch(rdr)) || nextch(rdr) == '.') {\n+    if rdr.curr.get() == '.' && !(ident_start(nextch(rdr)) || nextch(rdr) ==\n+                                  '.') {\n         is_float = true;\n         bump(rdr);\n         let dec_part = scan_digits(rdr, 10u);\n@@ -529,11 +542,11 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n     }\n     if is_float {\n         match base {\n-          16u => fatal_span(rdr, start_bpos, rdr.last_pos,\n+          16u => fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                             ~\"hexadecimal float literal is not supported\"),\n-          8u => fatal_span(rdr, start_bpos, rdr.last_pos,\n+          8u => fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"octal float literal is not supported\"),\n-          2u => fatal_span(rdr, start_bpos, rdr.last_pos,\n+          2u => fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"binary float literal is not supported\"),\n           _ => ()\n         }\n@@ -546,9 +559,9 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n       None => ()\n     }\n \n-    if rdr.curr == 'f' {\n+    if rdr.curr.get() == 'f' {\n         bump(rdr);\n-        c = rdr.curr;\n+        c = rdr.curr.get();\n         n = nextch(rdr);\n         if c == '3' && n == '2' {\n             bump(rdr);\n@@ -564,19 +577,20 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n             32-bit or 64-bit float, it won't be noticed till the\n             back-end.  */\n         } else {\n-            fatal_span(rdr, start_bpos, rdr.last_pos, ~\"expected `f32` or `f64` suffix\");\n+            fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n+                       ~\"expected `f32` or `f64` suffix\");\n         }\n     }\n     if is_float {\n         return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(num_str));\n     } else {\n         if num_str.len() == 0u {\n-            fatal_span(rdr, start_bpos, rdr.last_pos,\n+            fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                        ~\"no valid digits found for number\");\n         }\n         let parsed = match from_str_radix::<u64>(num_str, base as uint) {\n             Some(p) => p,\n-            None => fatal_span(rdr, start_bpos, rdr.last_pos,\n+            None => fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                                ~\"int literal is too large\")\n         };\n \n@@ -585,14 +599,14 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n     }\n }\n \n-fn scan_numeric_escape(rdr: @mut StringReader, n_hex_digits: uint) -> char {\n+fn scan_numeric_escape(rdr: @StringReader, n_hex_digits: uint) -> char {\n     let mut accum_int = 0;\n     let mut i = n_hex_digits;\n-    let start_bpos = rdr.last_pos;\n+    let start_bpos = rdr.last_pos.get();\n     while i != 0u {\n-        let n = rdr.curr;\n+        let n = rdr.curr.get();\n         if !is_hex_digit(n) {\n-            fatal_span_char(rdr, rdr.last_pos, rdr.pos,\n+            fatal_span_char(rdr, rdr.last_pos.get(), rdr.pos.get(),\n                             ~\"illegal character in numeric character escape\",\n                             n);\n         }\n@@ -603,7 +617,7 @@ fn scan_numeric_escape(rdr: @mut StringReader, n_hex_digits: uint) -> char {\n     }\n     match char::from_u32(accum_int as u32) {\n         Some(x) => x,\n-        None => fatal_span(rdr, start_bpos, rdr.last_pos,\n+        None => fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"illegal numeric character escape\")\n     }\n }\n@@ -626,22 +640,22 @@ fn ident_continue(c: char) -> bool {\n // return the next token from the string\n // EFFECT: advances the input past that token\n // EFFECT: updates the interner\n-fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n-    let c = rdr.curr;\n+fn next_token_inner(rdr: @StringReader) -> token::Token {\n+    let c = rdr.curr.get();\n     if ident_start(c) && nextch(rdr) != '\"' && nextch(rdr) != '#' {\n         // Note: r as in r\" or r#\" is part of a raw string literal,\n         // not an identifier, and is handled further down.\n \n-        let start = rdr.last_pos;\n-        while ident_continue(rdr.curr) {\n+        let start = rdr.last_pos.get();\n+        while ident_continue(rdr.curr.get()) {\n             bump(rdr);\n         }\n \n         return with_str_from(rdr, start, |string| {\n             if string == \"_\" {\n                 token::UNDERSCORE\n             } else {\n-                let is_mod_name = rdr.curr == ':' && nextch(rdr) == ':';\n+                let is_mod_name = rdr.curr.get() == ':' && nextch(rdr) == ':';\n \n                 // FIXME: perform NFKC normalization here. (Issue #2253)\n                 token::IDENT(str_to_ident(string), is_mod_name)\n@@ -651,9 +665,9 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n     if is_dec_digit(c) {\n         return scan_number(c, rdr);\n     }\n-    fn binop(rdr: @mut StringReader, op: token::binop) -> token::Token {\n+    fn binop(rdr: @StringReader, op: token::binop) -> token::Token {\n         bump(rdr);\n-        if rdr.curr == '=' {\n+        if rdr.curr.get() == '=' {\n             bump(rdr);\n             return token::BINOPEQ(op);\n         } else { return token::BINOP(op); }\n@@ -669,9 +683,9 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       ',' => { bump(rdr); return token::COMMA; }\n       '.' => {\n           bump(rdr);\n-          return if rdr.curr == '.' {\n+          return if rdr.curr.get() == '.' {\n               bump(rdr);\n-              if rdr.curr == '.' {\n+              if rdr.curr.get() == '.' {\n                   bump(rdr);\n                   token::DOTDOTDOT\n               } else {\n@@ -692,7 +706,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       '~' => { bump(rdr); return token::TILDE; }\n       ':' => {\n         bump(rdr);\n-        if rdr.curr == ':' {\n+        if rdr.curr.get() == ':' {\n             bump(rdr);\n             return token::MOD_SEP;\n         } else { return token::COLON; }\n@@ -707,10 +721,10 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       // Multi-byte tokens.\n       '=' => {\n         bump(rdr);\n-        if rdr.curr == '=' {\n+        if rdr.curr.get() == '=' {\n             bump(rdr);\n             return token::EQEQ;\n-        } else if rdr.curr == '>' {\n+        } else if rdr.curr.get() == '>' {\n             bump(rdr);\n             return token::FAT_ARROW;\n         } else {\n@@ -719,19 +733,19 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       }\n       '!' => {\n         bump(rdr);\n-        if rdr.curr == '=' {\n+        if rdr.curr.get() == '=' {\n             bump(rdr);\n             return token::NE;\n         } else { return token::NOT; }\n       }\n       '<' => {\n         bump(rdr);\n-        match rdr.curr {\n+        match rdr.curr.get() {\n           '=' => { bump(rdr); return token::LE; }\n           '<' => { return binop(rdr, token::SHL); }\n           '-' => {\n             bump(rdr);\n-            match rdr.curr {\n+            match rdr.curr.get() {\n               '>' => { bump(rdr); return token::DARROW; }\n               _ => { return token::LARROW; }\n             }\n@@ -741,7 +755,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       }\n       '>' => {\n         bump(rdr);\n-        match rdr.curr {\n+        match rdr.curr.get() {\n           '=' => { bump(rdr); return token::GE; }\n           '>' => { return binop(rdr, token::SHR); }\n           _ => { return token::GT; }\n@@ -750,26 +764,27 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       '\\'' => {\n         // Either a character constant 'a' OR a lifetime name 'abc\n         bump(rdr);\n-        let start = rdr.last_pos;\n-        let mut c2 = rdr.curr;\n+        let start = rdr.last_pos.get();\n+        let mut c2 = rdr.curr.get();\n         bump(rdr);\n \n         // If the character is an ident start not followed by another single\n         // quote, then this is a lifetime name:\n-        if ident_start(c2) && rdr.curr != '\\'' {\n-            while ident_continue(rdr.curr) {\n+        if ident_start(c2) && rdr.curr.get() != '\\'' {\n+            while ident_continue(rdr.curr.get()) {\n                 bump(rdr);\n             }\n             return with_str_from(rdr, start, |lifetime_name| {\n                 let ident = str_to_ident(lifetime_name);\n                 let tok = &token::IDENT(ident, false);\n \n                 if token::is_keyword(token::keywords::Self, tok) {\n-                    fatal_span(rdr, start, rdr.last_pos,\n+                    fatal_span(rdr, start, rdr.last_pos.get(),\n                                ~\"invalid lifetime name: 'self is no longer a special lifetime\");\n                 } else if token::is_any_keyword(tok) &&\n                     !token::is_keyword(token::keywords::Static, tok) {\n-                    fatal_span(rdr, start, rdr.last_pos, ~\"invalid lifetime name\");\n+                    fatal_span(rdr, start, rdr.last_pos.get(),\n+                               ~\"invalid lifetime name\");\n                 } else {\n                     token::LIFETIME(ident)\n                 }\n@@ -780,8 +795,8 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n         match c2 {\n             '\\\\' => {\n                 // '\\X' for some X must be a character constant:\n-                let escaped = rdr.curr;\n-                let escaped_pos = rdr.last_pos;\n+                let escaped = rdr.curr.get();\n+                let escaped_pos = rdr.last_pos.get();\n                 bump(rdr);\n                 match escaped {\n                     'n' => { c2 = '\\n'; }\n@@ -795,45 +810,45 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                     'u' => { c2 = scan_numeric_escape(rdr, 4u); }\n                     'U' => { c2 = scan_numeric_escape(rdr, 8u); }\n                     c2 => {\n-                        fatal_span_char(rdr, escaped_pos, rdr.last_pos,\n+                        fatal_span_char(rdr, escaped_pos, rdr.last_pos.get(),\n                                         ~\"unknown character escape\", c2);\n                     }\n                 }\n             }\n             '\\t' | '\\n' | '\\r' | '\\'' => {\n-                fatal_span_char(rdr, start, rdr.last_pos,\n+                fatal_span_char(rdr, start, rdr.last_pos.get(),\n                                 ~\"character constant must be escaped\", c2);\n             }\n             _ => {}\n         }\n-        if rdr.curr != '\\'' {\n+        if rdr.curr.get() != '\\'' {\n             fatal_span_verbose(rdr,\n                                // Byte offsetting here is okay because the\n                                // character before position `start` is an\n                                // ascii single quote.\n                                start - BytePos(1),\n-                               rdr.last_pos,\n+                               rdr.last_pos.get(),\n                                ~\"unterminated character constant\");\n         }\n         bump(rdr); // advance curr past token\n         return token::LIT_CHAR(c2 as u32);\n       }\n       '\"' => {\n         let mut accum_str = ~\"\";\n-        let start_bpos = rdr.last_pos;\n+        let start_bpos = rdr.last_pos.get();\n         bump(rdr);\n-        while rdr.curr != '\"' {\n+        while rdr.curr.get() != '\"' {\n             if is_eof(rdr) {\n-                fatal_span(rdr, start_bpos, rdr.last_pos,\n+                fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"unterminated double quote string\");\n             }\n \n-            let ch = rdr.curr;\n+            let ch = rdr.curr.get();\n             bump(rdr);\n             match ch {\n               '\\\\' => {\n-                let escaped = rdr.curr;\n-                let escaped_pos = rdr.last_pos;\n+                let escaped = rdr.curr.get();\n+                let escaped_pos = rdr.last_pos.get();\n                 bump(rdr);\n                 match escaped {\n                   'n' => accum_str.push_char('\\n'),\n@@ -854,7 +869,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                     accum_str.push_char(scan_numeric_escape(rdr, 8u));\n                   }\n                   c2 => {\n-                    fatal_span_char(rdr, escaped_pos, rdr.last_pos,\n+                    fatal_span_char(rdr, escaped_pos, rdr.last_pos.get(),\n                                     ~\"unknown string escape\", c2);\n                   }\n                 }\n@@ -866,32 +881,32 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n         return token::LIT_STR(str_to_ident(accum_str));\n       }\n       'r' => {\n-        let start_bpos = rdr.last_pos;\n+        let start_bpos = rdr.last_pos.get();\n         bump(rdr);\n         let mut hash_count = 0u;\n-        while rdr.curr == '#' {\n+        while rdr.curr.get() == '#' {\n             bump(rdr);\n             hash_count += 1;\n         }\n-        if rdr.curr != '\"' {\n-            fatal_span_char(rdr, start_bpos, rdr.last_pos,\n+        if rdr.curr.get() != '\"' {\n+            fatal_span_char(rdr, start_bpos, rdr.last_pos.get(),\n                             ~\"only `#` is allowed in raw string delimitation; \\\n                               found illegal character\",\n-                            rdr.curr);\n+                            rdr.curr.get());\n         }\n         bump(rdr);\n-        let content_start_bpos = rdr.last_pos;\n+        let content_start_bpos = rdr.last_pos.get();\n         let mut content_end_bpos;\n         'outer: loop {\n             if is_eof(rdr) {\n-                fatal_span(rdr, start_bpos, rdr.last_pos,\n+                fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"unterminated raw string\");\n             }\n-            if rdr.curr == '\"' {\n-                content_end_bpos = rdr.last_pos;\n+            if rdr.curr.get() == '\"' {\n+                content_end_bpos = rdr.last_pos.get();\n                 for _ in range(0, hash_count) {\n                     bump(rdr);\n-                    if rdr.curr != '#' {\n+                    if rdr.curr.get() != '#' {\n                         continue 'outer;\n                     }\n                 }\n@@ -932,14 +947,14 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       '^' => { return binop(rdr, token::CARET); }\n       '%' => { return binop(rdr, token::PERCENT); }\n       c => {\n-          fatal_span_char(rdr, rdr.last_pos, rdr.pos,\n+          fatal_span_char(rdr, rdr.last_pos.get(), rdr.pos.get(),\n                           ~\"unknown start of token\", c);\n       }\n     }\n }\n \n-fn consume_whitespace(rdr: @mut StringReader) {\n-    while is_whitespace(rdr.curr) && !is_eof(rdr) { bump(rdr); }\n+fn consume_whitespace(rdr: @StringReader) {\n+    while is_whitespace(rdr.curr.get()) && !is_eof(rdr) { bump(rdr); }\n }\n \n #[cfg(test)]\n@@ -953,7 +968,7 @@ mod test {\n \n     // represents a testing reader (incl. both reader and interner)\n     struct Env {\n-        string_reader: @mut StringReader\n+        string_reader: @StringReader\n     }\n \n     // open a string reader for the given string\n@@ -978,15 +993,15 @@ mod test {\n             sp:Span {lo:BytePos(21),hi:BytePos(23),expn_info: None}};\n         assert_eq!(tok1,tok2);\n         // the 'main' id is already read:\n-        assert_eq!(string_reader.last_pos.clone(), BytePos(28));\n+        assert_eq!(string_reader.last_pos.get().clone(), BytePos(28));\n         // read another token:\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan{\n             tok:token::IDENT(str_to_ident(\"main\"), false),\n             sp:Span {lo:BytePos(24),hi:BytePos(28),expn_info: None}};\n         assert_eq!(tok3,tok4);\n         // the lparen is already read:\n-        assert_eq!(string_reader.last_pos.clone(), BytePos(29))\n+        assert_eq!(string_reader.last_pos.get().clone(), BytePos(29))\n     }\n \n     // check that the given reader produces the desired stream"}, {"sha": "c20e7f4aaec64b1d2751c0782df74214970db4d6", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -19,6 +19,7 @@ use parse::attr::parser_attr;\n use parse::lexer::reader;\n use parse::parser::Parser;\n \n+use std::cell::RefCell;\n use std::io;\n use std::io::File;\n use std::str;\n@@ -41,27 +42,27 @@ pub mod obsolete;\n // info about a parsing session.\n pub struct ParseSess {\n     cm: @codemap::CodeMap, // better be the same as the one in the reader!\n-    span_diagnostic: @mut SpanHandler, // better be the same as the one in the reader!\n+    span_diagnostic: @SpanHandler, // better be the same as the one in the reader!\n     /// Used to determine and report recursive mod inclusions\n-    included_mod_stack: ~[Path],\n+    included_mod_stack: RefCell<~[Path]>,\n }\n \n-pub fn new_parse_sess(demitter: Option<@Emitter>) -> @mut ParseSess {\n+pub fn new_parse_sess(demitter: Option<@Emitter>) -> @ParseSess {\n     let cm = @CodeMap::new();\n-    @mut ParseSess {\n+    @ParseSess {\n         cm: cm,\n         span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n-        included_mod_stack: ~[],\n+        included_mod_stack: RefCell::new(~[]),\n     }\n }\n \n-pub fn new_parse_sess_special_handler(sh: @mut SpanHandler,\n+pub fn new_parse_sess_special_handler(sh: @SpanHandler,\n                                       cm: @codemap::CodeMap)\n-                                   -> @mut ParseSess {\n-    @mut ParseSess {\n+                                      -> @ParseSess {\n+    @ParseSess {\n         cm: cm,\n         span_diagnostic: sh,\n-        included_mod_stack: ~[],\n+        included_mod_stack: RefCell::new(~[]),\n     }\n }\n \n@@ -73,7 +74,7 @@ pub fn new_parse_sess_special_handler(sh: @mut SpanHandler,\n pub fn parse_crate_from_file(\n     input: &Path,\n     cfg: ast::CrateConfig,\n-    sess: @mut ParseSess\n+    sess: @ParseSess\n ) -> ast::Crate {\n     new_parser_from_file(sess, /*bad*/ cfg.clone(), input).parse_crate_mod()\n     // why is there no p.abort_if_errors here?\n@@ -82,7 +83,7 @@ pub fn parse_crate_from_file(\n pub fn parse_crate_attrs_from_file(\n     input: &Path,\n     cfg: ast::CrateConfig,\n-    sess: @mut ParseSess\n+    sess: @ParseSess\n ) -> ~[ast::Attribute] {\n     let mut parser = new_parser_from_file(sess, cfg, input);\n     let (inner, _) = parser.parse_inner_attrs_and_next();\n@@ -93,7 +94,7 @@ pub fn parse_crate_from_source_str(\n     name: @str,\n     source: @str,\n     cfg: ast::CrateConfig,\n-    sess: @mut ParseSess\n+    sess: @ParseSess\n ) -> ast::Crate {\n     let mut p = new_parser_from_source_str(sess,\n                                            /*bad*/ cfg.clone(),\n@@ -106,7 +107,7 @@ pub fn parse_crate_attrs_from_source_str(\n     name: @str,\n     source: @str,\n     cfg: ast::CrateConfig,\n-    sess: @mut ParseSess\n+    sess: @ParseSess\n ) -> ~[ast::Attribute] {\n     let mut p = new_parser_from_source_str(sess,\n                                            /*bad*/ cfg.clone(),\n@@ -120,7 +121,7 @@ pub fn parse_expr_from_source_str(\n     name: @str,\n     source: @str,\n     cfg: ast::CrateConfig,\n-    sess: @mut ParseSess\n+    sess: @ParseSess\n ) -> @ast::Expr {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_expr(), p)\n@@ -131,7 +132,7 @@ pub fn parse_item_from_source_str(\n     source: @str,\n     cfg: ast::CrateConfig,\n     attrs: ~[ast::Attribute],\n-    sess: @mut ParseSess\n+    sess: @ParseSess\n ) -> Option<@ast::item> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_item(attrs),p)\n@@ -141,7 +142,7 @@ pub fn parse_meta_from_source_str(\n     name: @str,\n     source: @str,\n     cfg: ast::CrateConfig,\n-    sess: @mut ParseSess\n+    sess: @ParseSess\n ) -> @ast::MetaItem {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_meta_item(),p)\n@@ -152,7 +153,7 @@ pub fn parse_stmt_from_source_str(\n     source: @str,\n     cfg: ast::CrateConfig,\n     attrs: ~[ast::Attribute],\n-    sess: @mut ParseSess\n+    sess: @ParseSess\n ) -> @ast::Stmt {\n     let mut p = new_parser_from_source_str(\n         sess,\n@@ -167,7 +168,7 @@ pub fn parse_tts_from_source_str(\n     name: @str,\n     source: @str,\n     cfg: ast::CrateConfig,\n-    sess: @mut ParseSess\n+    sess: @ParseSess\n ) -> ~[ast::token_tree] {\n     let mut p = new_parser_from_source_str(\n         sess,\n@@ -191,7 +192,7 @@ pub fn parse_from_source_str<T>(\n                              ss: codemap::FileSubstr,\n                              source: @str,\n                              cfg: ast::CrateConfig,\n-                             sess: @mut ParseSess)\n+                             sess: @ParseSess)\n                              -> T {\n     let mut p = new_parser_from_source_substr(sess, cfg, name, ss, source);\n     let r = f(&mut p);\n@@ -202,7 +203,7 @@ pub fn parse_from_source_str<T>(\n }\n \n // Create a new parser from a source string\n-pub fn new_parser_from_source_str(sess: @mut ParseSess,\n+pub fn new_parser_from_source_str(sess: @ParseSess,\n                                   cfg: ast::CrateConfig,\n                                   name: @str,\n                                   source: @str)\n@@ -212,7 +213,7 @@ pub fn new_parser_from_source_str(sess: @mut ParseSess,\n \n // Create a new parser from a source string where the origin\n // is specified as a substring of another file.\n-pub fn new_parser_from_source_substr(sess: @mut ParseSess,\n+pub fn new_parser_from_source_substr(sess: @ParseSess,\n                                   cfg: ast::CrateConfig,\n                                   name: @str,\n                                   ss: codemap::FileSubstr,\n@@ -224,7 +225,7 @@ pub fn new_parser_from_source_substr(sess: @mut ParseSess,\n /// Create a new parser, handling errors as appropriate\n /// if the file doesn't exist\n pub fn new_parser_from_file(\n-    sess: @mut ParseSess,\n+    sess: @ParseSess,\n     cfg: ast::CrateConfig,\n     path: &Path\n ) -> Parser {\n@@ -235,7 +236,7 @@ pub fn new_parser_from_file(\n /// the file at the given path to the codemap, and return a parser.\n /// On an error, use the given span as the source of the problem.\n pub fn new_sub_parser_from_file(\n-    sess: @mut ParseSess,\n+    sess: @ParseSess,\n     cfg: ast::CrateConfig,\n     path: &Path,\n     sp: Span\n@@ -244,15 +245,15 @@ pub fn new_sub_parser_from_file(\n }\n \n /// Given a filemap and config, return a parser\n-pub fn filemap_to_parser(sess: @mut ParseSess,\n+pub fn filemap_to_parser(sess: @ParseSess,\n                          filemap: @FileMap,\n                          cfg: ast::CrateConfig) -> Parser {\n     tts_to_parser(sess,filemap_to_tts(sess,filemap),cfg)\n }\n \n // must preserve old name for now, because quote! from the *existing*\n // compiler expands into it\n-pub fn new_parser_from_tts(sess: @mut ParseSess,\n+pub fn new_parser_from_tts(sess: @ParseSess,\n                      cfg: ast::CrateConfig,\n                      tts: ~[ast::token_tree]) -> Parser {\n     tts_to_parser(sess,tts,cfg)\n@@ -263,7 +264,7 @@ pub fn new_parser_from_tts(sess: @mut ParseSess,\n \n /// Given a session and a path and an optional span (for error reporting),\n /// add the path to the session's codemap and return the new filemap.\n-pub fn file_to_filemap(sess: @mut ParseSess, path: &Path, spanopt: Option<Span>)\n+pub fn file_to_filemap(sess: @ParseSess, path: &Path, spanopt: Option<Span>)\n     -> @FileMap {\n     let err = |msg: &str| {\n         match spanopt {\n@@ -292,35 +293,35 @@ pub fn file_to_filemap(sess: @mut ParseSess, path: &Path, spanopt: Option<Span>)\n \n // given a session and a string, add the string to\n // the session's codemap and return the new filemap\n-pub fn string_to_filemap(sess: @mut ParseSess, source: @str, path: @str)\n+pub fn string_to_filemap(sess: @ParseSess, source: @str, path: @str)\n     -> @FileMap {\n     sess.cm.new_filemap(path, source)\n }\n \n // given a session and a string and a path and a FileSubStr, add\n // the string to the CodeMap and return the new FileMap\n-pub fn substring_to_filemap(sess: @mut ParseSess, source: @str, path: @str,\n+pub fn substring_to_filemap(sess: @ParseSess, source: @str, path: @str,\n                            filesubstr: FileSubstr) -> @FileMap {\n     sess.cm.new_filemap_w_substr(path,filesubstr,source)\n }\n \n // given a filemap, produce a sequence of token-trees\n-pub fn filemap_to_tts(sess: @mut ParseSess, filemap: @FileMap)\n+pub fn filemap_to_tts(sess: @ParseSess, filemap: @FileMap)\n     -> ~[ast::token_tree] {\n     // it appears to me that the cfg doesn't matter here... indeed,\n     // parsing tt's probably shouldn't require a parser at all.\n     let cfg = ~[];\n     let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap);\n-    let mut p1 = Parser(sess, cfg, srdr as @mut reader);\n+    let mut p1 = Parser(sess, cfg, srdr as @reader);\n     p1.parse_all_token_trees()\n }\n \n // given tts and cfg, produce a parser\n-pub fn tts_to_parser(sess: @mut ParseSess,\n+pub fn tts_to_parser(sess: @ParseSess,\n                      tts: ~[ast::token_tree],\n                      cfg: ast::CrateConfig) -> Parser {\n     let trdr = lexer::new_tt_reader(sess.span_diagnostic, None, tts);\n-    Parser(sess, cfg, trdr as @mut reader)\n+    Parser(sess, cfg, trdr as @reader)\n }\n \n // abort if necessary"}, {"sha": "40a2ef86e4fb96306f512b90ee7ca322225dea33", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -29,8 +29,7 @@ use ast::{ExprField, ExprFnBlock, ExprIf, ExprIndex};\n use ast::{ExprLit, ExprLogLevel, ExprLoop, ExprMac};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc, ExprRepeat};\n use ast::{ExprRet, ExprSelf, ExprStruct, ExprTup, ExprUnary};\n-use ast::{ExprVec, ExprVstore, ExprVstoreMutBox};\n-use ast::{ExprVstoreSlice, ExprVstoreBox};\n+use ast::{ExprVec, ExprVstore, ExprVstoreSlice, ExprVstoreBox};\n use ast::{ExprVstoreMutSlice, ExprWhile, ExprForLoop, extern_fn, Field, fn_decl};\n use ast::{ExprVstoreUniq, Onceness, Once, Many};\n use ast::{foreign_item, foreign_item_static, foreign_item_fn, foreign_mod};\n@@ -81,6 +80,7 @@ use parse::{new_sub_parser_from_file, ParseSess};\n use opt_vec;\n use opt_vec::OptVec;\n \n+use std::cell::Cell;\n use std::hashmap::HashSet;\n use std::util;\n use std::vec;\n@@ -286,8 +286,8 @@ struct ParsedItemsAndViewItems {\n \n /* ident is handled by common.rs */\n \n-pub fn Parser(sess: @mut ParseSess, cfg: ast::CrateConfig, rdr: @mut reader)\n-           -> Parser {\n+pub fn Parser(sess: @ParseSess, cfg: ast::CrateConfig, rdr: @reader)\n+              -> Parser {\n     let tok0 = rdr.next_token();\n     let interner = get_ident_interner();\n     let span = tok0.sp;\n@@ -324,7 +324,7 @@ pub fn Parser(sess: @mut ParseSess, cfg: ast::CrateConfig, rdr: @mut reader)\n }\n \n pub struct Parser {\n-    sess: @mut ParseSess,\n+    sess: @ParseSess,\n     cfg: CrateConfig,\n     // the current token:\n     token: token::Token,\n@@ -340,7 +340,7 @@ pub struct Parser {\n     tokens_consumed: uint,\n     restriction: restriction,\n     quote_depth: uint, // not (yet) related to the quasiquoter\n-    reader: @mut reader,\n+    reader: @reader,\n     interner: @token::ident_interner,\n     /// The set of seen errors about obsolete syntax. Used to suppress\n     /// extra detail when the same error is seen twice\n@@ -1299,7 +1299,7 @@ impl Parser {\n         if sigil == OwnedSigil {\n             ty_uniq(self.parse_ty(false))\n         } else {\n-            ty_box(self.parse_mt())\n+            ty_box(self.parse_ty(false))\n         }\n     }\n \n@@ -2185,7 +2185,7 @@ impl Parser {\n         // unification of matchers and token_trees would vastly improve\n         // the interpolation of matchers\n         maybe_whole!(self, nt_matchers);\n-        let name_idx = @mut 0u;\n+        let name_idx = @Cell::new(0u);\n         match self.token {\n             token::LBRACE | token::LPAREN | token::LBRACKET => {\n                 let other_delimiter = token::flip_delimiter(&self.token);\n@@ -2200,7 +2200,7 @@ impl Parser {\n     // Otherwise, `$( ( )` would be a valid matcher, and `$( () )` would be\n     // invalid. It's similar to common::parse_seq.\n     pub fn parse_matcher_subseq_upto(&mut self,\n-                                     name_idx: @mut uint,\n+                                     name_idx: @Cell<uint>,\n                                      ket: &token::Token)\n                                      -> ~[matcher] {\n         let mut ret_val = ~[];\n@@ -2217,27 +2217,27 @@ impl Parser {\n         return ret_val;\n     }\n \n-    pub fn parse_matcher(&mut self, name_idx: @mut uint) -> matcher {\n+    pub fn parse_matcher(&mut self, name_idx: @Cell<uint>) -> matcher {\n         let lo = self.span.lo;\n \n         let m = if self.token == token::DOLLAR {\n             self.bump();\n             if self.token == token::LPAREN {\n-                let name_idx_lo = *name_idx;\n+                let name_idx_lo = name_idx.get();\n                 self.bump();\n                 let ms = self.parse_matcher_subseq_upto(name_idx,\n                                                         &token::RPAREN);\n                 if ms.len() == 0u {\n                     self.fatal(\"repetition body must be nonempty\");\n                 }\n                 let (sep, zerok) = self.parse_sep_and_zerok();\n-                match_seq(ms, sep, zerok, name_idx_lo, *name_idx)\n+                match_seq(ms, sep, zerok, name_idx_lo, name_idx.get())\n             } else {\n                 let bound_to = self.parse_ident();\n                 self.expect(&token::COLON);\n                 let nt_name = self.parse_ident();\n-                let m = match_nonterminal(bound_to, nt_name, *name_idx);\n-                *name_idx += 1u;\n+                let m = match_nonterminal(bound_to, nt_name, name_idx.get());\n+                name_idx.set(name_idx.get() + 1u);\n                 m\n             }\n         } else {\n@@ -2299,17 +2299,14 @@ impl Parser {\n           }\n           token::AT => {\n             self.bump();\n-            let m = self.parse_mutability();\n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n             // HACK: turn @[...] into a @-evec\n             ex = match e.node {\n-              ExprVec(..) | ExprRepeat(..) if m == MutMutable =>\n-                ExprVstore(e, ExprVstoreMutBox),\n               ExprVec(..) |\n               ExprLit(@codemap::Spanned { node: lit_str(..), span: _}) |\n-              ExprRepeat(..) if m == MutImmutable => ExprVstore(e, ExprVstoreBox),\n-              _ => self.mk_unary(UnBox(m), e)\n+              ExprRepeat(..) => ExprVstore(e, ExprVstoreBox),\n+              _ => self.mk_unary(UnBox, e)\n             };\n           }\n           token::TILDE => {\n@@ -4264,21 +4261,28 @@ impl Parser {\n                               path: Path,\n                               outer_attrs: ~[ast::Attribute],\n                               id_sp: Span) -> (ast::item_, ~[ast::Attribute]) {\n-        let maybe_i = self.sess.included_mod_stack.iter().position(|p| *p == path);\n-        match maybe_i {\n-            Some(i) => {\n-                let stack = &self.sess.included_mod_stack;\n-                let mut err = ~\"circular modules: \";\n-                for p in stack.slice(i, stack.len()).iter() {\n-                    p.display().with_str(|s| err.push_str(s));\n-                    err.push_str(\" -> \");\n+        {\n+            let mut included_mod_stack = self.sess\n+                                             .included_mod_stack\n+                                             .borrow_mut();\n+            let maybe_i = included_mod_stack.get()\n+                                            .iter()\n+                                            .position(|p| *p == path);\n+            match maybe_i {\n+                Some(i) => {\n+                    let mut err = ~\"circular modules: \";\n+                    let len = included_mod_stack.get().len();\n+                    for p in included_mod_stack.get().slice(i, len).iter() {\n+                        p.display().with_str(|s| err.push_str(s));\n+                        err.push_str(\" -> \");\n+                    }\n+                    path.display().with_str(|s| err.push_str(s));\n+                    self.span_fatal(id_sp, err);\n                 }\n-                path.display().with_str(|s| err.push_str(s));\n-                self.span_fatal(id_sp, err);\n+                None => ()\n             }\n-            None => ()\n+            included_mod_stack.get().push(path.clone());\n         }\n-        self.sess.included_mod_stack.push(path.clone());\n \n         let mut p0 =\n             new_sub_parser_from_file(self.sess,\n@@ -4289,7 +4293,12 @@ impl Parser {\n         let mod_attrs = vec::append(outer_attrs, inner);\n         let first_item_outer_attrs = next;\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n-        self.sess.included_mod_stack.pop();\n+        {\n+            let mut included_mod_stack = self.sess\n+                                             .included_mod_stack\n+                                             .borrow_mut();\n+            included_mod_stack.get().pop();\n+        }\n         return (ast::item_mod(m0), mod_attrs);\n     }\n "}, {"sha": "a6239ab38068b18c5354a6ec8e8235d650f86eea", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -148,15 +148,15 @@ pub struct print_stack_elt {\n \n pub static size_infinity: int = 0xffff;\n \n-pub fn mk_printer(out: @mut io::Writer, linewidth: uint) -> @mut Printer {\n+pub fn mk_printer(out: ~io::Writer, linewidth: uint) -> Printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n     let n: uint = 3 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n     let token: ~[token] = vec::from_elem(n, EOF);\n     let size: ~[int] = vec::from_elem(n, 0);\n     let scan_stack: ~[uint] = vec::from_elem(n, 0u);\n-    @mut Printer {\n+    Printer {\n         out: out,\n         buf_len: n,\n         margin: linewidth as int,\n@@ -171,7 +171,7 @@ pub fn mk_printer(out: @mut io::Writer, linewidth: uint) -> @mut Printer {\n         scan_stack_empty: true,\n         top: 0,\n         bottom: 0,\n-        print_stack: @mut ~[],\n+        print_stack: ~[],\n         pending_indentation: 0\n     }\n }\n@@ -255,7 +255,7 @@ pub fn mk_printer(out: @mut io::Writer, linewidth: uint) -> @mut Printer {\n  * called 'print'.\n  */\n pub struct Printer {\n-    out: @mut io::Writer,\n+    out: ~io::Writer,\n     buf_len: uint,\n     margin: int, // width of lines we're constrained to\n     space: int, // number of spaces left on line\n@@ -276,7 +276,7 @@ pub struct Printer {\n     top: uint, // index of top of scan_stack\n     bottom: uint, // index of bottom of scan_stack\n     // stack of blocks-in-progress being flushed by print\n-    print_stack: @mut ~[print_stack_elt],\n+    print_stack: ~[print_stack_elt],\n     // buffered indentation to avoid writing trailing whitespace\n     pending_indentation: int,\n }\n@@ -461,7 +461,7 @@ impl Printer {\n         self.pending_indentation += amount;\n     }\n     pub fn get_top(&mut self) -> print_stack_elt {\n-        let print_stack = &mut *self.print_stack;\n+        let print_stack = &mut self.print_stack;\n         let n = print_stack.len();\n         if n != 0u {\n             print_stack[n - 1u]\n@@ -506,7 +506,7 @@ impl Printer {\n           }\n           END => {\n             debug!(\"print END -> pop END\");\n-            let print_stack = &mut *self.print_stack;\n+            let print_stack = &mut self.print_stack;\n             assert!((print_stack.len() != 0u));\n             print_stack.pop();\n           }\n@@ -557,47 +557,47 @@ impl Printer {\n // Convenience functions to talk to the printer.\n //\n // \"raw box\"\n-pub fn rbox(p: @mut Printer, indent: uint, b: breaks) {\n+pub fn rbox(p: &mut Printer, indent: uint, b: breaks) {\n     p.pretty_print(BEGIN(begin_t {\n         offset: indent as int,\n         breaks: b\n     }));\n }\n \n-pub fn ibox(p: @mut Printer, indent: uint) { rbox(p, indent, inconsistent); }\n+pub fn ibox(p: &mut Printer, indent: uint) { rbox(p, indent, inconsistent); }\n \n-pub fn cbox(p: @mut Printer, indent: uint) { rbox(p, indent, consistent); }\n+pub fn cbox(p: &mut Printer, indent: uint) { rbox(p, indent, consistent); }\n \n-pub fn break_offset(p: @mut Printer, n: uint, off: int) {\n+pub fn break_offset(p: &mut Printer, n: uint, off: int) {\n     p.pretty_print(BREAK(break_t {\n         offset: off,\n         blank_space: n as int\n     }));\n }\n \n-pub fn end(p: @mut Printer) { p.pretty_print(END); }\n+pub fn end(p: &mut Printer) { p.pretty_print(END); }\n \n-pub fn eof(p: @mut Printer) { p.pretty_print(EOF); }\n+pub fn eof(p: &mut Printer) { p.pretty_print(EOF); }\n \n-pub fn word(p: @mut Printer, wrd: &str) {\n+pub fn word(p: &mut Printer, wrd: &str) {\n     p.pretty_print(STRING(/* bad */ wrd.to_managed(), wrd.len() as int));\n }\n \n-pub fn huge_word(p: @mut Printer, wrd: &str) {\n+pub fn huge_word(p: &mut Printer, wrd: &str) {\n     p.pretty_print(STRING(/* bad */ wrd.to_managed(), size_infinity));\n }\n \n-pub fn zero_word(p: @mut Printer, wrd: &str) {\n+pub fn zero_word(p: &mut Printer, wrd: &str) {\n     p.pretty_print(STRING(/* bad */ wrd.to_managed(), 0));\n }\n \n-pub fn spaces(p: @mut Printer, n: uint) { break_offset(p, n, 0); }\n+pub fn spaces(p: &mut Printer, n: uint) { break_offset(p, n, 0); }\n \n-pub fn zerobreak(p: @mut Printer) { spaces(p, 0u); }\n+pub fn zerobreak(p: &mut Printer) { spaces(p, 0u); }\n \n-pub fn space(p: @mut Printer) { spaces(p, 1u); }\n+pub fn space(p: &mut Printer) { spaces(p, 1u); }\n \n-pub fn hardbreak(p: @mut Printer) { spaces(p, size_infinity as uint); }\n+pub fn hardbreak(p: &mut Printer) { spaces(p, size_infinity as uint); }\n \n pub fn hardbreak_tok_offset(off: int) -> token {\n     BREAK(break_t {offset: off, blank_space: size_infinity})"}, {"sha": "9725d6e38deee1ba705c198f8c87701e42b7ef28", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 454, "deletions": 410, "changes": 864, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -27,18 +27,20 @@ use print::pp::{breaks, consistent, inconsistent, eof};\n use print::pp;\n use print::pprust;\n \n+use std::cast;\n+use std::cell::RefCell;\n use std::char;\n use std::str;\n use std::io;\n use std::io::Decorator;\n use std::io::mem::MemWriter;\n \n-// The @ps is stored here to prevent recursive type.\n-pub enum ann_node<'a> {\n-    node_block(@ps, &'a ast::Block),\n-    node_item(@ps, &'a ast::item),\n-    node_expr(@ps, &'a ast::Expr),\n-    node_pat(@ps, &'a ast::Pat),\n+// The &mut ps is stored here to prevent recursive type.\n+pub enum ann_node<'a,'b> {\n+    node_block(&'b mut ps, &'a ast::Block),\n+    node_item(&'b mut ps, &'a ast::item),\n+    node_expr(&'b mut ps, &'a ast::Expr),\n+    node_pat(&'b mut ps, &'a ast::Pat),\n }\n \n pub trait pp_ann {\n@@ -66,45 +68,51 @@ pub struct CurrentCommentAndLiteral {\n }\n \n pub struct ps {\n-    s: @mut pp::Printer,\n+    s: pp::Printer,\n     cm: Option<@CodeMap>,\n     intr: @token::ident_interner,\n     comments: Option<~[comments::cmnt]>,\n     literals: Option<~[comments::lit]>,\n-    cur_cmnt_and_lit: @mut CurrentCommentAndLiteral,\n-    boxes: @mut ~[pp::breaks],\n+    cur_cmnt_and_lit: CurrentCommentAndLiteral,\n+    boxes: RefCell<~[pp::breaks]>,\n     ann: @pp_ann\n }\n \n-pub fn ibox(s: @ps, u: uint) {\n-    s.boxes.push(pp::inconsistent);\n-    pp::ibox(s.s, u);\n+pub fn ibox(s: &mut ps, u: uint) {\n+    {\n+        let mut boxes = s.boxes.borrow_mut();\n+        boxes.get().push(pp::inconsistent);\n+    }\n+    pp::ibox(&mut s.s, u);\n }\n \n-pub fn end(s: @ps) {\n-    s.boxes.pop();\n-    pp::end(s.s);\n+pub fn end(s: &mut ps) {\n+    {\n+        let mut boxes = s.boxes.borrow_mut();\n+        boxes.get().pop();\n+    }\n+    pp::end(&mut s.s);\n }\n \n-pub fn rust_printer(writer: @mut io::Writer, intr: @ident_interner) -> @ps {\n+pub fn rust_printer(writer: ~io::Writer, intr: @ident_interner) -> ps {\n     return rust_printer_annotated(writer, intr, @no_ann::new() as @pp_ann);\n }\n \n-pub fn rust_printer_annotated(writer: @mut io::Writer,\n+pub fn rust_printer_annotated(writer: ~io::Writer,\n                               intr: @ident_interner,\n                               ann: @pp_ann)\n-                              -> @ps {\n-    return @ps {\n+                              -> ps {\n+    return ps {\n         s: pp::mk_printer(writer, default_columns),\n         cm: None::<@CodeMap>,\n         intr: intr,\n         comments: None::<~[comments::cmnt]>,\n         literals: None::<~[comments::lit]>,\n-        cur_cmnt_and_lit: @mut CurrentCommentAndLiteral {\n+        cur_cmnt_and_lit: CurrentCommentAndLiteral {\n             cur_cmnt: 0,\n             cur_lit: 0\n         },\n-        boxes: @mut ~[],\n+        boxes: RefCell::new(~[]),\n         ann: ann\n     };\n }\n@@ -118,19 +126,19 @@ pub static default_columns: uint = 78u;\n // copy forward.\n pub fn print_crate(cm: @CodeMap,\n                    intr: @ident_interner,\n-                   span_diagnostic: @mut diagnostic::SpanHandler,\n+                   span_diagnostic: @diagnostic::SpanHandler,\n                    crate: &ast::Crate,\n                    filename: @str,\n-                   input: @mut io::Reader,\n-                   out: @mut io::Writer,\n+                   input: &mut io::Reader,\n+                   out: ~io::Writer,\n                    ann: @pp_ann,\n                    is_expanded: bool) {\n     let (cmnts, lits) = comments::gather_comments_and_literals(\n         span_diagnostic,\n         filename,\n         input\n     );\n-    let s = @ps {\n+    let mut s = ps {\n         s: pp::mk_printer(out, default_columns),\n         cm: Some(cm),\n         intr: intr,\n@@ -143,20 +151,20 @@ pub fn print_crate(cm: @CodeMap,\n         } else {\n             Some(lits)\n         },\n-        cur_cmnt_and_lit: @mut CurrentCommentAndLiteral {\n+        cur_cmnt_and_lit: CurrentCommentAndLiteral {\n             cur_cmnt: 0,\n             cur_lit: 0\n         },\n-        boxes: @mut ~[],\n+        boxes: RefCell::new(~[]),\n         ann: ann\n     };\n-    print_crate_(s, crate);\n+    print_crate_(&mut s, crate);\n }\n \n-pub fn print_crate_(s: @ps, crate: &ast::Crate) {\n+pub fn print_crate_(s: &mut ps, crate: &ast::Crate) {\n     print_mod(s, &crate.module, crate.attrs);\n     print_remaining_comments(s);\n-    eof(s.s);\n+    eof(&mut s.s);\n }\n \n pub fn ty_to_str(ty: &ast::Ty, intr: @ident_interner) -> ~str {\n@@ -203,26 +211,30 @@ pub fn path_to_str(p: &ast::Path, intr: @ident_interner) -> ~str {\n pub fn fun_to_str(decl: &ast::fn_decl, purity: ast::purity, name: ast::Ident,\n                   opt_explicit_self: Option<ast::explicit_self_>,\n                   generics: &ast::Generics, intr: @ident_interner) -> ~str {\n-    let wr = @mut MemWriter::new();\n-    let s = rust_printer(wr as @mut io::Writer, intr);\n-    print_fn(s, decl, Some(purity), AbiSet::Rust(),\n+    let wr = ~MemWriter::new();\n+    let mut s = rust_printer(wr as ~io::Writer, intr);\n+    print_fn(&mut s, decl, Some(purity), AbiSet::Rust(),\n              name, generics, opt_explicit_self, ast::inherited);\n-    end(s); // Close the head box\n-    end(s); // Close the outer box\n-    eof(s.s);\n-    str::from_utf8_owned(wr.inner_ref().to_owned())\n+    end(&mut s); // Close the head box\n+    end(&mut s); // Close the outer box\n+    eof(&mut s.s);\n+    unsafe {\n+        get_mem_writer(&mut s.s.out)\n+    }\n }\n \n pub fn block_to_str(blk: &ast::Block, intr: @ident_interner) -> ~str {\n-    let wr = @mut MemWriter::new();\n-    let s = rust_printer(wr as @mut io::Writer, intr);\n+    let wr = ~MemWriter::new();\n+    let mut s = rust_printer(wr as ~io::Writer, intr);\n     // containing cbox, will be closed by print-block at }\n-    cbox(s, indent_unit);\n+    cbox(&mut s, indent_unit);\n     // head-ibox, will be closed by print-block after {\n-    ibox(s, 0u);\n-    print_block(s, blk);\n-    eof(s.s);\n-    str::from_utf8_owned(wr.inner_ref().to_owned())\n+    ibox(&mut s, 0u);\n+    print_block(&mut s, blk);\n+    eof(&mut s.s);\n+    unsafe {\n+        get_mem_writer(&mut s.s.out)\n+    }\n }\n \n pub fn meta_item_to_str(mi: &ast::MetaItem, intr: @ident_interner) -> ~str {\n@@ -237,28 +249,34 @@ pub fn variant_to_str(var: &ast::variant, intr: @ident_interner) -> ~str {\n     to_str(var, print_variant, intr)\n }\n \n-pub fn cbox(s: @ps, u: uint) {\n-    s.boxes.push(pp::consistent);\n-    pp::cbox(s.s, u);\n+pub fn cbox(s: &mut ps, u: uint) {\n+    {\n+        let mut boxes = s.boxes.borrow_mut();\n+        boxes.get().push(pp::consistent);\n+    }\n+    pp::cbox(&mut s.s, u);\n }\n \n // \"raw box\"\n-pub fn rbox(s: @ps, u: uint, b: pp::breaks) {\n-    s.boxes.push(b);\n-    pp::rbox(s.s, u, b);\n+pub fn rbox(s: &mut ps, u: uint, b: pp::breaks) {\n+    {\n+        let mut boxes = s.boxes.borrow_mut();\n+        boxes.get().push(b);\n+    }\n+    pp::rbox(&mut s.s, u, b);\n }\n \n-pub fn nbsp(s: @ps) { word(s.s, \" \"); }\n+pub fn nbsp(s: &mut ps) { word(&mut s.s, \" \"); }\n \n-pub fn word_nbsp(s: @ps, w: &str) { word(s.s, w); nbsp(s); }\n+pub fn word_nbsp(s: &mut ps, w: &str) { word(&mut s.s, w); nbsp(s); }\n \n-pub fn word_space(s: @ps, w: &str) { word(s.s, w); space(s.s); }\n+pub fn word_space(s: &mut ps, w: &str) { word(&mut s.s, w); space(&mut s.s); }\n \n-pub fn popen(s: @ps) { word(s.s, \"(\"); }\n+pub fn popen(s: &mut ps) { word(&mut s.s, \"(\"); }\n \n-pub fn pclose(s: @ps) { word(s.s, \")\"); }\n+pub fn pclose(s: &mut ps) { word(&mut s.s, \")\"); }\n \n-pub fn head(s: @ps, w: &str) {\n+pub fn head(s: &mut ps, w: &str) {\n     // outer-box is consistent\n     cbox(s, indent_unit);\n     // head-box is inconsistent\n@@ -269,49 +287,53 @@ pub fn head(s: @ps, w: &str) {\n     }\n }\n \n-pub fn bopen(s: @ps) {\n-    word(s.s, \"{\");\n+pub fn bopen(s: &mut ps) {\n+    word(&mut s.s, \"{\");\n     end(s); // close the head-box\n }\n \n-pub fn bclose_(s: @ps, span: codemap::Span, indented: uint) {\n+pub fn bclose_(s: &mut ps, span: codemap::Span, indented: uint) {\n     bclose_maybe_open(s, span, indented, true);\n }\n-pub fn bclose_maybe_open (s: @ps, span: codemap::Span, indented: uint,\n+pub fn bclose_maybe_open (s: &mut ps, span: codemap::Span, indented: uint,\n                           close_box: bool) {\n     maybe_print_comment(s, span.hi);\n     break_offset_if_not_bol(s, 1u, -(indented as int));\n-    word(s.s, \"}\");\n+    word(&mut s.s, \"}\");\n     if close_box {\n         end(s); // close the outer-box\n     }\n }\n-pub fn bclose(s: @ps, span: codemap::Span) { bclose_(s, span, indent_unit); }\n+pub fn bclose(s: &mut ps, span: codemap::Span) { bclose_(s, span, indent_unit); }\n \n-pub fn is_begin(s: @ps) -> bool {\n+pub fn is_begin(s: &mut ps) -> bool {\n     match s.s.last_token() { pp::BEGIN(_) => true, _ => false }\n }\n \n-pub fn is_end(s: @ps) -> bool {\n+pub fn is_end(s: &mut ps) -> bool {\n     match s.s.last_token() { pp::END => true, _ => false }\n }\n \n-pub fn is_bol(s: @ps) -> bool {\n+pub fn is_bol(s: &mut ps) -> bool {\n     return s.s.last_token().is_eof() || s.s.last_token().is_hardbreak_tok();\n }\n \n-pub fn in_cbox(s: @ps) -> bool {\n-    let boxes = &*s.boxes;\n-    let len = boxes.len();\n+pub fn in_cbox(s: &mut ps) -> bool {\n+    let boxes = s.boxes.borrow();\n+    let len = boxes.get().len();\n     if len == 0u { return false; }\n-    return boxes[len - 1u] == pp::consistent;\n+    return boxes.get()[len - 1u] == pp::consistent;\n }\n \n-pub fn hardbreak_if_not_bol(s: @ps) { if !is_bol(s) { hardbreak(s.s); } }\n-pub fn space_if_not_bol(s: @ps) { if !is_bol(s) { space(s.s); } }\n-pub fn break_offset_if_not_bol(s: @ps, n: uint, off: int) {\n+pub fn hardbreak_if_not_bol(s: &mut ps) {\n     if !is_bol(s) {\n-        break_offset(s.s, n, off);\n+        hardbreak(&mut s.s)\n+    }\n+}\n+pub fn space_if_not_bol(s: &mut ps) { if !is_bol(s) { space(&mut s.s); } }\n+pub fn break_offset_if_not_bol(s: &mut ps, n: uint, off: int) {\n+    if !is_bol(s) {\n+        break_offset(&mut s.s, n, off);\n     } else {\n         if off != 0 && s.s.last_token().is_hardbreak_tok() {\n             // We do something pretty sketchy here: tuck the nonzero\n@@ -324,15 +346,15 @@ pub fn break_offset_if_not_bol(s: @ps, n: uint, off: int) {\n \n // Synthesizes a comment that was not textually present in the original source\n // file.\n-pub fn synth_comment(s: @ps, text: ~str) {\n-    word(s.s, \"/*\");\n-    space(s.s);\n-    word(s.s, text);\n-    space(s.s);\n-    word(s.s, \"*/\");\n+pub fn synth_comment(s: &mut ps, text: ~str) {\n+    word(&mut s.s, \"/*\");\n+    space(&mut s.s);\n+    word(&mut s.s, text);\n+    space(&mut s.s);\n+    word(&mut s.s, \"*/\");\n }\n \n-pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: |@ps, &T|) {\n+pub fn commasep<T>(s: &mut ps, b: breaks, elts: &[T], op: |&mut ps, &T|) {\n     rbox(s, 0u, b);\n     let mut first = true;\n     for elt in elts.iter() {\n@@ -344,10 +366,10 @@ pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: |@ps, &T|) {\n \n \n pub fn commasep_cmnt<T>(\n-                     s: @ps,\n+                     s: &mut ps,\n                      b: breaks,\n                      elts: &[T],\n-                     op: |@ps, &T|,\n+                     op: |&mut ps, &T|,\n                      get_span: |&T| -> codemap::Span) {\n     rbox(s, 0u, b);\n     let len = elts.len();\n@@ -357,7 +379,7 @@ pub fn commasep_cmnt<T>(\n         op(s, elt);\n         i += 1u;\n         if i < len {\n-            word(s.s, \",\");\n+            word(&mut s.s, \",\");\n             maybe_print_trailing_comment(s, get_span(elt),\n                                          Some(get_span(&elts[i]).hi));\n             space_if_not_bol(s);\n@@ -366,19 +388,19 @@ pub fn commasep_cmnt<T>(\n     end(s);\n }\n \n-pub fn commasep_exprs(s: @ps, b: breaks, exprs: &[@ast::Expr]) {\n+pub fn commasep_exprs(s: &mut ps, b: breaks, exprs: &[@ast::Expr]) {\n     commasep_cmnt(s, b, exprs, |p, &e| print_expr(p, e), |e| e.span);\n }\n \n-pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: &[ast::Attribute]) {\n+pub fn print_mod(s: &mut ps, _mod: &ast::_mod, attrs: &[ast::Attribute]) {\n     print_inner_attributes(s, attrs);\n     for vitem in _mod.view_items.iter() {\n         print_view_item(s, vitem);\n     }\n     for item in _mod.items.iter() { print_item(s, *item); }\n }\n \n-pub fn print_foreign_mod(s: @ps, nmod: &ast::foreign_mod,\n+pub fn print_foreign_mod(s: &mut ps, nmod: &ast::foreign_mod,\n                          attrs: &[ast::Attribute]) {\n     print_inner_attributes(s, attrs);\n     for vitem in nmod.view_items.iter() {\n@@ -387,37 +409,37 @@ pub fn print_foreign_mod(s: @ps, nmod: &ast::foreign_mod,\n     for item in nmod.items.iter() { print_foreign_item(s, *item); }\n }\n \n-pub fn print_opt_lifetime(s: @ps, lifetime: &Option<ast::Lifetime>) {\n+pub fn print_opt_lifetime(s: &mut ps, lifetime: &Option<ast::Lifetime>) {\n     for l in lifetime.iter() {\n         print_lifetime(s, l);\n         nbsp(s);\n     }\n }\n \n-pub fn print_type(s: @ps, ty: &ast::Ty) {\n+pub fn print_type(s: &mut ps, ty: &ast::Ty) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     match ty.node {\n-      ast::ty_nil => word(s.s, \"()\"),\n-      ast::ty_bot => word(s.s, \"!\"),\n-      ast::ty_box(ref mt) => { word(s.s, \"@\"); print_mt(s, mt); }\n-      ast::ty_uniq(ty) => { word(s.s, \"~\"); print_type(s, ty); }\n+      ast::ty_nil => word(&mut s.s, \"()\"),\n+      ast::ty_bot => word(&mut s.s, \"!\"),\n+      ast::ty_box(ty) => { word(&mut s.s, \"@\"); print_type(s, ty); }\n+      ast::ty_uniq(ty) => { word(&mut s.s, \"~\"); print_type(s, ty); }\n       ast::ty_vec(ty) => {\n-        word(s.s, \"[\");\n+        word(&mut s.s, \"[\");\n         print_type(s, ty);\n-        word(s.s, \"]\");\n+        word(&mut s.s, \"]\");\n       }\n-      ast::ty_ptr(ref mt) => { word(s.s, \"*\"); print_mt(s, mt); }\n+      ast::ty_ptr(ref mt) => { word(&mut s.s, \"*\"); print_mt(s, mt); }\n       ast::ty_rptr(ref lifetime, ref mt) => {\n-          word(s.s, \"&\");\n+          word(&mut s.s, \"&\");\n           print_opt_lifetime(s, lifetime);\n           print_mt(s, mt);\n       }\n       ast::ty_tup(ref elts) => {\n         popen(s);\n         commasep(s, inconsistent, *elts, print_type_ref);\n         if elts.len() == 1 {\n-            word(s.s, \",\");\n+            word(&mut s.s, \",\");\n         }\n         pclose(s);\n       }\n@@ -441,16 +463,16 @@ pub fn print_type(s: @ps, ty: &ast::Ty) {\n       }\n       ast::ty_path(ref path, ref bounds, _) => print_bounded_path(s, path, bounds),\n       ast::ty_fixed_length_vec(ty, v) => {\n-        word(s.s, \"[\");\n+        word(&mut s.s, \"[\");\n         print_type(s, ty);\n-        word(s.s, \", ..\");\n+        word(&mut s.s, \", ..\");\n         print_expr(s, v);\n-        word(s.s, \"]\");\n+        word(&mut s.s, \"]\");\n       }\n       ast::ty_typeof(e) => {\n-          word(s.s, \"typeof(\");\n+          word(&mut s.s, \"typeof(\");\n           print_expr(s, e);\n-          word(s.s, \")\");\n+          word(&mut s.s, \")\");\n       }\n       ast::ty_infer => {\n           fail!(\"print_type shouldn't see a ty_infer\");\n@@ -460,11 +482,11 @@ pub fn print_type(s: @ps, ty: &ast::Ty) {\n     end(s);\n }\n \n-pub fn print_type_ref(s: @ps, ty: &P<ast::Ty>) {\n+pub fn print_type_ref(s: &mut ps, ty: &P<ast::Ty>) {\n     print_type(s, *ty);\n }\n \n-pub fn print_foreign_item(s: @ps, item: &ast::foreign_item) {\n+pub fn print_foreign_item(s: &mut ps, item: &ast::foreign_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -473,7 +495,7 @@ pub fn print_foreign_item(s: @ps, item: &ast::foreign_item) {\n         print_fn(s, decl, None, AbiSet::Rust(), item.ident, generics, None,\n                  item.vis);\n         end(s); // end head-ibox\n-        word(s.s, \";\");\n+        word(&mut s.s, \";\");\n         end(s); // end the outer fn box\n       }\n       ast::foreign_item_static(t, m) => {\n@@ -484,19 +506,21 @@ pub fn print_foreign_item(s: @ps, item: &ast::foreign_item) {\n         print_ident(s, item.ident);\n         word_space(s, \":\");\n         print_type(s, t);\n-        word(s.s, \";\");\n+        word(&mut s.s, \";\");\n         end(s); // end the head-ibox\n         end(s); // end the outer cbox\n       }\n     }\n }\n \n-pub fn print_item(s: @ps, item: &ast::item) {\n+pub fn print_item(s: &mut ps, item: &ast::item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n-    let ann_node = node_item(s, item);\n-    s.ann.pre(ann_node);\n+    {\n+        let ann_node = node_item(s, item);\n+        s.ann.pre(ann_node);\n+    }\n     match item.node {\n       ast::item_static(ty, m, expr) => {\n         head(s, visibility_qualified(item.vis, \"static\"));\n@@ -506,12 +530,12 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         print_ident(s, item.ident);\n         word_space(s, \":\");\n         print_type(s, ty);\n-        space(s.s);\n+        space(&mut s.s);\n         end(s); // end the head-ibox\n \n         word_space(s, \"=\");\n         print_expr(s, expr);\n-        word(s.s, \";\");\n+        word(&mut s.s, \";\");\n         end(s); // end the outer cbox\n \n       }\n@@ -526,7 +550,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n             None,\n             item.vis\n         );\n-        word(s.s, \" \");\n+        word(&mut s.s, \" \");\n         print_block_with_attrs(s, body, item.attrs);\n       }\n       ast::item_mod(ref _mod) => {\n@@ -552,10 +576,10 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         print_generics(s, params);\n         end(s); // end the inner ibox\n \n-        space(s.s);\n+        space(&mut s.s);\n         word_space(s, \"=\");\n         print_type(s, ty);\n-        word(s.s, \";\");\n+        word(&mut s.s, \";\");\n         end(s); // end the outer ibox\n       }\n       ast::item_enum(ref enum_definition, ref params) => {\n@@ -577,21 +601,21 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         head(s, visibility_qualified(item.vis, \"impl\"));\n         if generics.is_parameterized() {\n             print_generics(s, generics);\n-            space(s.s);\n+            space(&mut s.s);\n         }\n \n         match opt_trait {\n             &Some(ref t) => {\n                 print_trait_ref(s, t);\n-                space(s.s);\n+                space(&mut s.s);\n                 word_space(s, \"for\");\n             }\n             &None => ()\n         };\n \n         print_type(s, ty);\n \n-        space(s.s);\n+        space(&mut s.s);\n         bopen(s);\n         print_inner_attributes(s, item.attrs);\n         for meth in methods.iter() {\n@@ -604,7 +628,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         print_ident(s, item.ident);\n         print_generics(s, generics);\n         if traits.len() != 0u {\n-            word(s.s, \":\");\n+            word(&mut s.s, \":\");\n             for (i, trait_) in traits.iter().enumerate() {\n                 nbsp(s);\n                 if i != 0 {\n@@ -613,7 +637,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n                 print_path(s, &trait_.path, false);\n             }\n         }\n-        word(s.s, \" \");\n+        word(&mut s.s, \" \");\n         bopen(s);\n         for meth in methods.iter() {\n             print_trait_method(s, meth);\n@@ -625,7 +649,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n                                    ..}) => {\n         print_visibility(s, item.vis);\n         print_path(s, pth, false);\n-        word(s.s, \"! \");\n+        word(&mut s.s, \"! \");\n         print_ident(s, item.ident);\n         cbox(s, indent_unit);\n         popen(s);\n@@ -634,24 +658,27 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         end(s);\n       }\n     }\n-    s.ann.post(ann_node);\n+    {\n+        let ann_node = node_item(s, item);\n+        s.ann.post(ann_node);\n+    }\n }\n \n-fn print_trait_ref(s: @ps, t: &ast::trait_ref) {\n+fn print_trait_ref(s: &mut ps, t: &ast::trait_ref) {\n     print_path(s, &t.path, false);\n }\n \n-pub fn print_enum_def(s: @ps, enum_definition: &ast::enum_def,\n+pub fn print_enum_def(s: &mut ps, enum_definition: &ast::enum_def,\n                       generics: &ast::Generics, ident: ast::Ident,\n                       span: codemap::Span, visibility: ast::visibility) {\n     head(s, visibility_qualified(visibility, \"enum\"));\n     print_ident(s, ident);\n     print_generics(s, generics);\n-    space(s.s);\n+    space(&mut s.s);\n     print_variants(s, enum_definition.variants, span);\n }\n \n-pub fn print_variants(s: @ps,\n+pub fn print_variants(s: &mut ps,\n                       variants: &[P<ast::variant>],\n                       span: codemap::Span) {\n     bopen(s);\n@@ -661,7 +688,7 @@ pub fn print_variants(s: @ps,\n         print_outer_attributes(s, v.node.attrs);\n         ibox(s, indent_unit);\n         print_variant(s, v);\n-        word(s.s, \",\");\n+        word(&mut s.s, \",\");\n         end(s);\n         maybe_print_trailing_comment(s, v.span, None);\n     }\n@@ -683,15 +710,15 @@ pub fn visibility_qualified(vis: ast::visibility, s: &str) -> ~str {\n     }\n }\n \n-pub fn print_visibility(s: @ps, vis: ast::visibility) {\n+pub fn print_visibility(s: &mut ps, vis: ast::visibility) {\n     match vis {\n         ast::private | ast::public =>\n         word_nbsp(s, visibility_to_str(vis)),\n         ast::inherited => ()\n     }\n }\n \n-pub fn print_struct(s: @ps,\n+pub fn print_struct(s: &mut ps,\n                     struct_def: &ast::struct_def,\n                     generics: &ast::Generics,\n                     ident: ast::Ident,\n@@ -712,7 +739,7 @@ pub fn print_struct(s: @ps,\n             });\n             pclose(s);\n         }\n-        word(s.s, \";\");\n+        word(&mut s.s, \";\");\n         end(s);\n         end(s); // close the outer-box\n     } else {\n@@ -731,7 +758,7 @@ pub fn print_struct(s: @ps,\n                     print_ident(s, ident);\n                     word_nbsp(s, \":\");\n                     print_type(s, field.node.ty);\n-                    word(s.s, \",\");\n+                    word(&mut s.s, \",\");\n                 }\n             }\n         }\n@@ -747,48 +774,48 @@ pub fn print_struct(s: @ps,\n /// appropriate macro, transcribe back into the grammar we just parsed from,\n /// and then pretty-print the resulting AST nodes (so, e.g., we print\n /// expression arguments as expressions). It can be done! I think.\n-pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n+pub fn print_tt(s: &mut ps, tt: &ast::token_tree) {\n     match *tt {\n       ast::tt_delim(ref tts) => print_tts(s, &(tts.as_slice())),\n       ast::tt_tok(_, ref tk) => {\n-          word(s.s, parse::token::to_str(s.intr, tk));\n+          word(&mut s.s, parse::token::to_str(s.intr, tk));\n       }\n       ast::tt_seq(_, ref tts, ref sep, zerok) => {\n-        word(s.s, \"$(\");\n+        word(&mut s.s, \"$(\");\n         for tt_elt in (*tts).iter() { print_tt(s, tt_elt); }\n-        word(s.s, \")\");\n+        word(&mut s.s, \")\");\n         match (*sep) {\n-          Some(ref tk) => word(s.s, parse::token::to_str(s.intr, tk)),\n+          Some(ref tk) => word(&mut s.s, parse::token::to_str(s.intr, tk)),\n           None => ()\n         }\n-        word(s.s, if zerok { \"*\" } else { \"+\" });\n+        word(&mut s.s, if zerok { \"*\" } else { \"+\" });\n       }\n       ast::tt_nonterminal(_, name) => {\n-        word(s.s, \"$\");\n+        word(&mut s.s, \"$\");\n         print_ident(s, name);\n       }\n     }\n }\n \n-pub fn print_tts(s: @ps, tts: & &[ast::token_tree]) {\n+pub fn print_tts(s: &mut ps, tts: & &[ast::token_tree]) {\n     ibox(s, 0);\n     for (i, tt) in tts.iter().enumerate() {\n         if i != 0 {\n-            space(s.s);\n+            space(&mut s.s);\n         }\n         print_tt(s, tt);\n     }\n     end(s);\n }\n \n-pub fn print_variant(s: @ps, v: &ast::variant) {\n+pub fn print_variant(s: &mut ps, v: &ast::variant) {\n     print_visibility(s, v.node.vis);\n     match v.node.kind {\n         ast::tuple_variant_kind(ref args) => {\n             print_ident(s, v.node.name);\n             if !args.is_empty() {\n                 popen(s);\n-                fn print_variant_arg(s: @ps, arg: &ast::variant_arg) {\n+                fn print_variant_arg(s: &mut ps, arg: &ast::variant_arg) {\n                     print_type(s, arg.ty);\n                 }\n                 commasep(s, consistent, *args, print_variant_arg);\n@@ -803,15 +830,15 @@ pub fn print_variant(s: @ps, v: &ast::variant) {\n     }\n     match v.node.disr_expr {\n       Some(d) => {\n-        space(s.s);\n+        space(&mut s.s);\n         word_space(s, \"=\");\n         print_expr(s, d);\n       }\n       _ => ()\n     }\n }\n \n-pub fn print_ty_method(s: @ps, m: &ast::TypeMethod) {\n+pub fn print_ty_method(s: &mut ps, m: &ast::TypeMethod) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n@@ -826,28 +853,28 @@ pub fn print_ty_method(s: @ps, m: &ast::TypeMethod) {\n                 &None,\n                 Some(&m.generics),\n                 Some(m.explicit_self.node));\n-    word(s.s, \";\");\n+    word(&mut s.s, \";\");\n }\n \n-pub fn print_trait_method(s: @ps, m: &ast::trait_method) {\n+pub fn print_trait_method(s: &mut ps, m: &ast::trait_method) {\n     match *m {\n         required(ref ty_m) => print_ty_method(s, ty_m),\n         provided(m) => print_method(s, m)\n     }\n }\n \n-pub fn print_method(s: @ps, meth: &ast::method) {\n+pub fn print_method(s: &mut ps, meth: &ast::method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n     print_fn(s, meth.decl, Some(meth.purity), AbiSet::Rust(),\n              meth.ident, &meth.generics, Some(meth.explicit_self.node),\n              meth.vis);\n-    word(s.s, \" \");\n+    word(&mut s.s, \" \");\n     print_block_with_attrs(s, meth.body, meth.attrs);\n }\n \n-pub fn print_outer_attributes(s: @ps, attrs: &[ast::Attribute]) {\n+pub fn print_outer_attributes(s: &mut ps, attrs: &[ast::Attribute]) {\n     let mut count = 0;\n     for attr in attrs.iter() {\n         match attr.node.style {\n@@ -858,14 +885,14 @@ pub fn print_outer_attributes(s: @ps, attrs: &[ast::Attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-pub fn print_inner_attributes(s: @ps, attrs: &[ast::Attribute]) {\n+pub fn print_inner_attributes(s: &mut ps, attrs: &[ast::Attribute]) {\n     let mut count = 0;\n     for attr in attrs.iter() {\n         match attr.node.style {\n           ast::AttrInner => {\n             print_attribute(s, attr);\n             if !attr.node.is_sugared_doc {\n-                word(s.s, \";\");\n+                word(&mut s.s, \";\");\n             }\n             count += 1;\n           }\n@@ -875,21 +902,21 @@ pub fn print_inner_attributes(s: @ps, attrs: &[ast::Attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-pub fn print_attribute(s: @ps, attr: &ast::Attribute) {\n+pub fn print_attribute(s: &mut ps, attr: &ast::Attribute) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, attr.span.lo);\n     if attr.node.is_sugared_doc {\n         let comment = attr.value_str().unwrap();\n-        word(s.s, comment);\n+        word(&mut s.s, comment);\n     } else {\n-        word(s.s, \"#[\");\n+        word(&mut s.s, \"#[\");\n         print_meta_item(s, attr.meta());\n-        word(s.s, \"]\");\n+        word(&mut s.s, \"]\");\n     }\n }\n \n \n-pub fn print_stmt(s: @ps, st: &ast::Stmt) {\n+pub fn print_stmt(s: &mut ps, st: &ast::Stmt) {\n     maybe_print_comment(s, st.span.lo);\n     match st.node {\n       ast::StmtDecl(decl, _) => {\n@@ -902,33 +929,33 @@ pub fn print_stmt(s: @ps, st: &ast::Stmt) {\n       ast::StmtSemi(expr, _) => {\n         space_if_not_bol(s);\n         print_expr(s, expr);\n-        word(s.s, \";\");\n+        word(&mut s.s, \";\");\n       }\n       ast::StmtMac(ref mac, semi) => {\n         space_if_not_bol(s);\n         print_mac(s, mac);\n-        if semi { word(s.s, \";\"); }\n+        if semi { word(&mut s.s, \";\"); }\n       }\n     }\n-    if parse::classify::stmt_ends_with_semi(st) { word(s.s, \";\"); }\n+    if parse::classify::stmt_ends_with_semi(st) { word(&mut s.s, \";\"); }\n     maybe_print_trailing_comment(s, st.span, None);\n }\n \n-pub fn print_block(s: @ps, blk: &ast::Block) {\n+pub fn print_block(s: &mut ps, blk: &ast::Block) {\n     print_possibly_embedded_block(s, blk, block_normal, indent_unit);\n }\n \n-pub fn print_block_unclosed(s: @ps, blk: &ast::Block) {\n+pub fn print_block_unclosed(s: &mut ps, blk: &ast::Block) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, &[],\n                                  false);\n }\n \n-pub fn print_block_unclosed_indent(s: @ps, blk: &ast::Block, indented: uint) {\n+pub fn print_block_unclosed_indent(s: &mut ps, blk: &ast::Block, indented: uint) {\n     print_possibly_embedded_block_(s, blk, block_normal, indented, &[],\n                                    false);\n }\n \n-pub fn print_block_with_attrs(s: @ps,\n+pub fn print_block_with_attrs(s: &mut ps,\n                               blk: &ast::Block,\n                               attrs: &[ast::Attribute]) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, attrs,\n@@ -937,15 +964,15 @@ pub fn print_block_with_attrs(s: @ps,\n \n pub enum embed_type { block_block_fn, block_normal, }\n \n-pub fn print_possibly_embedded_block(s: @ps,\n+pub fn print_possibly_embedded_block(s: &mut ps,\n                                      blk: &ast::Block,\n                                      embedded: embed_type,\n                                      indented: uint) {\n     print_possibly_embedded_block_(\n         s, blk, embedded, indented, &[], true);\n }\n \n-pub fn print_possibly_embedded_block_(s: @ps,\n+pub fn print_possibly_embedded_block_(s: &mut ps,\n                                       blk: &ast::Block,\n                                       embedded: embed_type,\n                                       indented: uint,\n@@ -956,8 +983,10 @@ pub fn print_possibly_embedded_block_(s: @ps,\n       ast::DefaultBlock => ()\n     }\n     maybe_print_comment(s, blk.span.lo);\n-    let ann_node = node_block(s, blk);\n-    s.ann.pre(ann_node);\n+    {\n+        let ann_node = node_block(s, blk);\n+        s.ann.pre(ann_node);\n+    }\n     match embedded {\n       block_block_fn => end(s),\n       block_normal => bopen(s)\n@@ -978,35 +1007,38 @@ pub fn print_possibly_embedded_block_(s: @ps,\n       _ => ()\n     }\n     bclose_maybe_open(s, blk.span, indented, close_box);\n-    s.ann.post(ann_node);\n+    {\n+        let ann_node = node_block(s, blk);\n+        s.ann.post(ann_node);\n+    }\n }\n \n-pub fn print_if(s: @ps, test: &ast::Expr, blk: &ast::Block,\n+pub fn print_if(s: &mut ps, test: &ast::Expr, blk: &ast::Block,\n                 elseopt: Option<@ast::Expr>, chk: bool) {\n     head(s, \"if\");\n     if chk { word_nbsp(s, \"check\"); }\n     print_expr(s, test);\n-    space(s.s);\n+    space(&mut s.s);\n     print_block(s, blk);\n-    fn do_else(s: @ps, els: Option<@ast::Expr>) {\n+    fn do_else(s: &mut ps, els: Option<@ast::Expr>) {\n         match els {\n           Some(_else) => {\n             match _else.node {\n               // \"another else-if\"\n               ast::ExprIf(i, t, e) => {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n-                word(s.s, \" else if \");\n+                word(&mut s.s, \" else if \");\n                 print_expr(s, i);\n-                space(s.s);\n+                space(&mut s.s);\n                 print_block(s, t);\n                 do_else(s, e);\n               }\n               // \"final else\"\n               ast::ExprBlock(b) => {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n-                word(s.s, \" else \");\n+                word(&mut s.s, \" else \");\n                 print_block(s, b);\n               }\n               // BLEAH, constraints would be great here\n@@ -1021,49 +1053,45 @@ pub fn print_if(s: @ps, test: &ast::Expr, blk: &ast::Block,\n     do_else(s, elseopt);\n }\n \n-pub fn print_mac(s: @ps, m: &ast::mac) {\n+pub fn print_mac(s: &mut ps, m: &ast::mac) {\n     match m.node {\n       // I think it's reasonable to hide the ctxt here:\n       ast::mac_invoc_tt(ref pth, ref tts, _) => {\n         print_path(s, pth, false);\n-        word(s.s, \"!\");\n+        word(&mut s.s, \"!\");\n         popen(s);\n         print_tts(s, &tts.as_slice());\n         pclose(s);\n       }\n     }\n }\n \n-pub fn print_vstore(s: @ps, t: ast::Vstore) {\n+pub fn print_vstore(s: &mut ps, t: ast::Vstore) {\n     match t {\n-        ast::VstoreFixed(Some(i)) => word(s.s, format!(\"{}\", i)),\n-        ast::VstoreFixed(None) => word(s.s, \"_\"),\n-        ast::VstoreUniq => word(s.s, \"~\"),\n-        ast::VstoreBox => word(s.s, \"@\"),\n+        ast::VstoreFixed(Some(i)) => word(&mut s.s, format!(\"{}\", i)),\n+        ast::VstoreFixed(None) => word(&mut s.s, \"_\"),\n+        ast::VstoreUniq => word(&mut s.s, \"~\"),\n+        ast::VstoreBox => word(&mut s.s, \"@\"),\n         ast::VstoreSlice(ref r) => {\n-            word(s.s, \"&\");\n+            word(&mut s.s, \"&\");\n             print_opt_lifetime(s, r);\n         }\n     }\n }\n \n-pub fn print_expr_vstore(s: @ps, t: ast::ExprVstore) {\n+pub fn print_expr_vstore(s: &mut ps, t: ast::ExprVstore) {\n     match t {\n-      ast::ExprVstoreUniq => word(s.s, \"~\"),\n-      ast::ExprVstoreBox => word(s.s, \"@\"),\n-      ast::ExprVstoreMutBox => {\n-        word(s.s, \"@\");\n-        word(s.s, \"mut\");\n-      }\n-      ast::ExprVstoreSlice => word(s.s, \"&\"),\n+      ast::ExprVstoreUniq => word(&mut s.s, \"~\"),\n+      ast::ExprVstoreBox => word(&mut s.s, \"@\"),\n+      ast::ExprVstoreSlice => word(&mut s.s, \"&\"),\n       ast::ExprVstoreMutSlice => {\n-        word(s.s, \"&\");\n-        word(s.s, \"mut\");\n+        word(&mut s.s, \"&\");\n+        word(&mut s.s, \"mut\");\n       }\n     }\n }\n \n-pub fn print_call_pre(s: @ps,\n+pub fn print_call_pre(s: &mut ps,\n                       sugar: ast::CallSugar,\n                       base_args: &mut ~[@ast::Expr])\n                    -> Option<@ast::Expr> {\n@@ -1080,7 +1108,7 @@ pub fn print_call_pre(s: @ps,\n     }\n }\n \n-pub fn print_call_post(s: @ps,\n+pub fn print_call_post(s: &mut ps,\n                        sugar: ast::CallSugar,\n                        blk: &Option<@ast::Expr>,\n                        base_args: &mut ~[@ast::Expr]) {\n@@ -1107,8 +1135,8 @@ pub fn print_call_post(s: @ps,\n     }\n }\n \n-pub fn print_expr(s: @ps, expr: &ast::Expr) {\n-    fn print_field(s: @ps, field: &ast::Field) {\n+pub fn print_expr(s: &mut ps, expr: &ast::Expr) {\n+    fn print_field(s: &mut ps, field: &ast::Field) {\n         ibox(s, indent_unit);\n         print_ident(s, field.ident.node);\n         word_space(s, \":\");\n@@ -1119,62 +1147,64 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n \n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n-    let ann_node = node_expr(s, expr);\n-    s.ann.pre(ann_node);\n+    {\n+        let ann_node = node_expr(s, expr);\n+        s.ann.pre(ann_node);\n+    }\n     match expr.node {\n         ast::ExprVstore(e, v) => {\n             print_expr_vstore(s, v);\n             print_expr(s, e);\n         },\n       ast::ExprVec(ref exprs, mutbl) => {\n         ibox(s, indent_unit);\n-        word(s.s, \"[\");\n+        word(&mut s.s, \"[\");\n         if mutbl == ast::MutMutable {\n-            word(s.s, \"mut\");\n+            word(&mut s.s, \"mut\");\n             if exprs.len() > 0u { nbsp(s); }\n         }\n         commasep_exprs(s, inconsistent, *exprs);\n-        word(s.s, \"]\");\n+        word(&mut s.s, \"]\");\n         end(s);\n       }\n \n       ast::ExprRepeat(element, count, mutbl) => {\n         ibox(s, indent_unit);\n-        word(s.s, \"[\");\n+        word(&mut s.s, \"[\");\n         if mutbl == ast::MutMutable {\n-            word(s.s, \"mut\");\n+            word(&mut s.s, \"mut\");\n             nbsp(s);\n         }\n         print_expr(s, element);\n-        word(s.s, \",\");\n-        word(s.s, \"..\");\n+        word(&mut s.s, \",\");\n+        word(&mut s.s, \"..\");\n         print_expr(s, count);\n-        word(s.s, \"]\");\n+        word(&mut s.s, \"]\");\n         end(s);\n       }\n \n       ast::ExprStruct(ref path, ref fields, wth) => {\n         print_path(s, path, true);\n-        word(s.s, \"{\");\n+        word(&mut s.s, \"{\");\n         commasep_cmnt(s, consistent, (*fields), print_field, get_span);\n         match wth {\n             Some(expr) => {\n                 ibox(s, indent_unit);\n-                word(s.s, \",\");\n-                space(s.s);\n-                word(s.s, \"..\");\n+                word(&mut s.s, \",\");\n+                space(&mut s.s);\n+                word(&mut s.s, \"..\");\n                 print_expr(s, expr);\n                 end(s);\n             }\n-            _ => (word(s.s, \",\"))\n+            _ => (word(&mut s.s, \",\"))\n         }\n-        word(s.s, \"}\");\n+        word(&mut s.s, \"}\");\n       }\n       ast::ExprTup(ref exprs) => {\n         popen(s);\n         commasep_exprs(s, inconsistent, *exprs);\n         if exprs.len() == 1 {\n-            word(s.s, \",\");\n+            word(&mut s.s, \",\");\n         }\n         pclose(s);\n       }\n@@ -1188,39 +1218,39 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n         let mut base_args = (*args).clone();\n         let blk = print_call_pre(s, sugar, &mut base_args);\n         print_expr(s, func);\n-        word(s.s, \".\");\n+        word(&mut s.s, \".\");\n         print_ident(s, ident);\n         if tys.len() > 0u {\n-            word(s.s, \"::<\");\n+            word(&mut s.s, \"::<\");\n             commasep(s, inconsistent, *tys, print_type_ref);\n-            word(s.s, \">\");\n+            word(&mut s.s, \">\");\n         }\n         print_call_post(s, sugar, &blk, &mut base_args);\n       }\n       ast::ExprBinary(_, op, lhs, rhs) => {\n         print_expr(s, lhs);\n-        space(s.s);\n+        space(&mut s.s);\n         word_space(s, ast_util::binop_to_str(op));\n         print_expr(s, rhs);\n       }\n       ast::ExprUnary(_, op, expr) => {\n-        word(s.s, ast_util::unop_to_str(op));\n+        word(&mut s.s, ast_util::unop_to_str(op));\n         print_expr(s, expr);\n       }\n       ast::ExprAddrOf(m, expr) => {\n-        word(s.s, \"&\");\n+        word(&mut s.s, \"&\");\n         print_mutability(s, m);\n         // Avoid `& &e` => `&&e`.\n         match (m, &expr.node) {\n-            (ast::MutImmutable, &ast::ExprAddrOf(..)) => space(s.s),\n+            (ast::MutImmutable, &ast::ExprAddrOf(..)) => space(&mut s.s),\n             _ => { }\n         }\n         print_expr(s, expr);\n       }\n       ast::ExprLit(lit) => print_literal(s, lit),\n       ast::ExprCast(expr, ty) => {\n         print_expr(s, expr);\n-        space(s.s);\n+        space(&mut s.s);\n         word_space(s, \"as\");\n         print_type(s, ty);\n       }\n@@ -1230,58 +1260,58 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n       ast::ExprWhile(test, blk) => {\n         head(s, \"while\");\n         print_expr(s, test);\n-        space(s.s);\n+        space(&mut s.s);\n         print_block(s, blk);\n       }\n       ast::ExprForLoop(pat, iter, blk, opt_ident) => {\n         for ident in opt_ident.iter() {\n-            word(s.s, \"'\");\n+            word(&mut s.s, \"'\");\n             print_ident(s, *ident);\n             word_space(s, \":\");\n         }\n         head(s, \"for\");\n         print_pat(s, pat);\n-        space(s.s);\n+        space(&mut s.s);\n         word_space(s, \"in\");\n         print_expr(s, iter);\n-        space(s.s);\n+        space(&mut s.s);\n         print_block(s, blk);\n       }\n       ast::ExprLoop(blk, opt_ident) => {\n         for ident in opt_ident.iter() {\n-            word(s.s, \"'\");\n+            word(&mut s.s, \"'\");\n             print_ident(s, *ident);\n             word_space(s, \":\");\n         }\n         head(s, \"loop\");\n-        space(s.s);\n+        space(&mut s.s);\n         print_block(s, blk);\n       }\n       ast::ExprMatch(expr, ref arms) => {\n         cbox(s, indent_unit);\n         ibox(s, 4);\n         word_nbsp(s, \"match\");\n         print_expr(s, expr);\n-        space(s.s);\n+        space(&mut s.s);\n         bopen(s);\n         let len = arms.len();\n         for (i, arm) in arms.iter().enumerate() {\n-            space(s.s);\n+            space(&mut s.s);\n             cbox(s, indent_unit);\n             ibox(s, 0u);\n             let mut first = true;\n             for p in arm.pats.iter() {\n                 if first {\n                     first = false;\n-                } else { space(s.s); word_space(s, \"|\"); }\n+                } else { space(&mut s.s); word_space(s, \"|\"); }\n                 print_pat(s, *p);\n             }\n-            space(s.s);\n+            space(&mut s.s);\n             match arm.guard {\n               Some(e) => {\n                 word_space(s, \"if\");\n                 print_expr(s, e);\n-                space(s.s);\n+                space(&mut s.s);\n               }\n               None => ()\n             }\n@@ -1309,7 +1339,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n                         }\n                         if !expr_is_simple_block(expr)\n                             && i < len - 1 {\n-                            word(s.s, \",\");\n+                            word(&mut s.s, \",\");\n                         }\n                         end(s); // close enclosing cbox\n                     }\n@@ -1329,7 +1359,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n         //\n         // if !decl.inputs.is_empty() {\n         print_fn_block_args(s, decl);\n-        space(s.s);\n+        space(&mut s.s);\n         // }\n         assert!(body.stmts.is_empty());\n         assert!(body.expr.is_some());\n@@ -1356,7 +1386,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n         //\n         // if !decl.inputs.is_empty() {\n         print_proc_args(s, decl);\n-        space(s.s);\n+        space(&mut s.s);\n         // }\n         assert!(body.stmts.is_empty());\n         assert!(body.expr.is_some());\n@@ -1388,70 +1418,70 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n       }\n       ast::ExprAssign(lhs, rhs) => {\n         print_expr(s, lhs);\n-        space(s.s);\n+        space(&mut s.s);\n         word_space(s, \"=\");\n         print_expr(s, rhs);\n       }\n       ast::ExprAssignOp(_, op, lhs, rhs) => {\n         print_expr(s, lhs);\n-        space(s.s);\n-        word(s.s, ast_util::binop_to_str(op));\n+        space(&mut s.s);\n+        word(&mut s.s, ast_util::binop_to_str(op));\n         word_space(s, \"=\");\n         print_expr(s, rhs);\n       }\n       ast::ExprField(expr, id, ref tys) => {\n         print_expr(s, expr);\n-        word(s.s, \".\");\n+        word(&mut s.s, \".\");\n         print_ident(s, id);\n         if tys.len() > 0u {\n-            word(s.s, \"::<\");\n+            word(&mut s.s, \"::<\");\n             commasep(s, inconsistent, *tys, print_type_ref);\n-            word(s.s, \">\");\n+            word(&mut s.s, \">\");\n         }\n       }\n       ast::ExprIndex(_, expr, index) => {\n         print_expr(s, expr);\n-        word(s.s, \"[\");\n+        word(&mut s.s, \"[\");\n         print_expr(s, index);\n-        word(s.s, \"]\");\n+        word(&mut s.s, \"]\");\n       }\n       ast::ExprPath(ref path) => print_path(s, path, true),\n-      ast::ExprSelf => word(s.s, \"self\"),\n+      ast::ExprSelf => word(&mut s.s, \"self\"),\n       ast::ExprBreak(opt_ident) => {\n-        word(s.s, \"break\");\n-        space(s.s);\n+        word(&mut s.s, \"break\");\n+        space(&mut s.s);\n         for ident in opt_ident.iter() {\n-            word(s.s, \"'\");\n+            word(&mut s.s, \"'\");\n             print_name(s, *ident);\n-            space(s.s);\n+            space(&mut s.s);\n         }\n       }\n       ast::ExprAgain(opt_ident) => {\n-        word(s.s, \"continue\");\n-        space(s.s);\n+        word(&mut s.s, \"continue\");\n+        space(&mut s.s);\n         for ident in opt_ident.iter() {\n-            word(s.s, \"'\");\n+            word(&mut s.s, \"'\");\n             print_name(s, *ident);\n-            space(s.s)\n+            space(&mut s.s)\n         }\n       }\n       ast::ExprRet(result) => {\n-        word(s.s, \"return\");\n+        word(&mut s.s, \"return\");\n         match result {\n-          Some(expr) => { word(s.s, \" \"); print_expr(s, expr); }\n+          Some(expr) => { word(&mut s.s, \" \"); print_expr(s, expr); }\n           _ => ()\n         }\n       }\n       ast::ExprLogLevel => {\n-        word(s.s, \"__log_level\");\n+        word(&mut s.s, \"__log_level\");\n         popen(s);\n         pclose(s);\n       }\n       ast::ExprInlineAsm(ref a) => {\n         if a.volatile {\n-            word(s.s, \"__volatile__ asm!\");\n+            word(&mut s.s, \"__volatile__ asm!\");\n         } else {\n-            word(s.s, \"asm!\");\n+            word(&mut s.s, \"asm!\");\n         }\n         popen(s);\n         print_string(s, a.asm, a.asm_str_style);\n@@ -1482,27 +1512,30 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n           pclose(s);\n       }\n     }\n-    s.ann.post(ann_node);\n+    {\n+        let ann_node = node_expr(s, expr);\n+        s.ann.post(ann_node);\n+    }\n     end(s);\n }\n \n-pub fn print_local_decl(s: @ps, loc: &ast::Local) {\n+pub fn print_local_decl(s: &mut ps, loc: &ast::Local) {\n     print_pat(s, loc.pat);\n     match loc.ty.node {\n       ast::ty_infer => (),\n       _ => { word_space(s, \":\"); print_type(s, loc.ty); }\n     }\n }\n \n-pub fn print_decl(s: @ps, decl: &ast::Decl) {\n+pub fn print_decl(s: &mut ps, decl: &ast::Decl) {\n     maybe_print_comment(s, decl.span.lo);\n     match decl.node {\n       ast::DeclLocal(ref loc) => {\n         space_if_not_bol(s);\n         ibox(s, indent_unit);\n         word_nbsp(s, \"let\");\n \n-        fn print_local(s: @ps, loc: &ast::Local) {\n+        fn print_local(s: &mut ps, loc: &ast::Local) {\n             ibox(s, indent_unit);\n             print_local_decl(s, loc);\n             end(s);\n@@ -1523,36 +1556,36 @@ pub fn print_decl(s: @ps, decl: &ast::Decl) {\n     }\n }\n \n-pub fn print_ident(s: @ps, ident: ast::Ident) {\n-    word(s.s, ident_to_str(&ident));\n+pub fn print_ident(s: &mut ps, ident: ast::Ident) {\n+    word(&mut s.s, ident_to_str(&ident));\n }\n \n-pub fn print_name(s: @ps, name: ast::Name) {\n-    word(s.s, interner_get(name));\n+pub fn print_name(s: &mut ps, name: ast::Name) {\n+    word(&mut s.s, interner_get(name));\n }\n \n-pub fn print_for_decl(s: @ps, loc: &ast::Local, coll: &ast::Expr) {\n+pub fn print_for_decl(s: &mut ps, loc: &ast::Local, coll: &ast::Expr) {\n     print_local_decl(s, loc);\n-    space(s.s);\n+    space(&mut s.s);\n     word_space(s, \"in\");\n     print_expr(s, coll);\n }\n \n-fn print_path_(s: @ps,\n+fn print_path_(s: &mut ps,\n                path: &ast::Path,\n                colons_before_params: bool,\n                opt_bounds: &Option<OptVec<ast::TyParamBound>>) {\n     maybe_print_comment(s, path.span.lo);\n     if path.global {\n-        word(s.s, \"::\");\n+        word(&mut s.s, \"::\");\n     }\n \n     let mut first = true;\n     for (i, segment) in path.segments.iter().enumerate() {\n         if first {\n             first = false\n         } else {\n-            word(s.s, \"::\")\n+            word(&mut s.s, \"::\")\n         }\n \n         print_ident(s, segment.identifier);\n@@ -1567,9 +1600,9 @@ fn print_path_(s: @ps,\n \n         if !segment.lifetimes.is_empty() || !segment.types.is_empty() {\n             if colons_before_params {\n-                word(s.s, \"::\")\n+                word(&mut s.s, \"::\")\n             }\n-            word(s.s, \"<\");\n+            word(&mut s.s, \"<\");\n \n             let mut comma = false;\n             for lifetime in segment.lifetimes.iter() {\n@@ -1590,29 +1623,31 @@ fn print_path_(s: @ps,\n                          print_type_ref);\n             }\n \n-            word(s.s, \">\")\n+            word(&mut s.s, \">\")\n         }\n     }\n }\n \n-pub fn print_path(s: @ps, path: &ast::Path, colons_before_params: bool) {\n+pub fn print_path(s: &mut ps, path: &ast::Path, colons_before_params: bool) {\n     print_path_(s, path, colons_before_params, &None)\n }\n \n-pub fn print_bounded_path(s: @ps, path: &ast::Path,\n+pub fn print_bounded_path(s: &mut ps, path: &ast::Path,\n                           bounds: &Option<OptVec<ast::TyParamBound>>) {\n     print_path_(s, path, false, bounds)\n }\n \n-pub fn print_pat(s: @ps, pat: &ast::Pat) {\n+pub fn print_pat(s: &mut ps, pat: &ast::Pat) {\n     maybe_print_comment(s, pat.span.lo);\n-    let ann_node = node_pat(s, pat);\n-    s.ann.pre(ann_node);\n+    {\n+        let ann_node = node_pat(s, pat);\n+        s.ann.pre(ann_node);\n+    }\n     /* Pat isn't normalized, but the beauty of it\n      is that it doesn't matter */\n     match pat.node {\n-      ast::PatWild => word(s.s, \"_\"),\n-      ast::PatWildMulti => word(s.s, \"..\"),\n+      ast::PatWild => word(&mut s.s, \"_\"),\n+      ast::PatWildMulti => word(&mut s.s, \"..\"),\n       ast::PatIdent(binding_mode, ref path, sub) => {\n           match binding_mode {\n               ast::BindByRef(mutbl) => {\n@@ -1627,7 +1662,7 @@ pub fn print_pat(s: @ps, pat: &ast::Pat) {\n           print_path(s, path, true);\n           match sub {\n               Some(p) => {\n-                  word(s.s, \"@\");\n+                  word(&mut s.s, \"@\");\n                   print_pat(s, p);\n               }\n               None => ()\n@@ -1636,7 +1671,7 @@ pub fn print_pat(s: @ps, pat: &ast::Pat) {\n       ast::PatEnum(ref path, ref args_) => {\n         print_path(s, path, true);\n         match *args_ {\n-          None => word(s.s, \"(..)\"),\n+          None => word(&mut s.s, \"(..)\"),\n           Some(ref args) => {\n             if !args.is_empty() {\n               popen(s);\n@@ -1649,8 +1684,8 @@ pub fn print_pat(s: @ps, pat: &ast::Pat) {\n       }\n       ast::PatStruct(ref path, ref fields, etc) => {\n         print_path(s, path, true);\n-        word(s.s, \"{\");\n-        fn print_field(s: @ps, f: &ast::FieldPat) {\n+        word(&mut s.s, \"{\");\n+        fn print_field(s: &mut ps, f: &ast::FieldPat) {\n             cbox(s, indent_unit);\n             print_ident(s, f.ident);\n             word_space(s, \":\");\n@@ -1663,88 +1698,91 @@ pub fn print_pat(s: @ps, pat: &ast::Pat) {\n                       get_span);\n         if etc {\n             if fields.len() != 0u { word_space(s, \",\"); }\n-            word(s.s, \"..\");\n+            word(&mut s.s, \"..\");\n         }\n-        word(s.s, \"}\");\n+        word(&mut s.s, \"}\");\n       }\n       ast::PatTup(ref elts) => {\n         popen(s);\n         commasep(s, inconsistent, *elts, |s, &p| print_pat(s, p));\n         if elts.len() == 1 {\n-            word(s.s, \",\");\n+            word(&mut s.s, \",\");\n         }\n         pclose(s);\n       }\n       ast::PatBox(inner) => {\n-          word(s.s, \"@\");\n+          word(&mut s.s, \"@\");\n           print_pat(s, inner);\n       }\n       ast::PatUniq(inner) => {\n-          word(s.s, \"~\");\n+          word(&mut s.s, \"~\");\n           print_pat(s, inner);\n       }\n       ast::PatRegion(inner) => {\n-          word(s.s, \"&\");\n+          word(&mut s.s, \"&\");\n           print_pat(s, inner);\n       }\n       ast::PatLit(e) => print_expr(s, e),\n       ast::PatRange(begin, end) => {\n         print_expr(s, begin);\n-        space(s.s);\n-        word(s.s, \"..\");\n+        space(&mut s.s);\n+        word(&mut s.s, \"..\");\n         print_expr(s, end);\n       }\n       ast::PatVec(ref before, slice, ref after) => {\n-        word(s.s, \"[\");\n+        word(&mut s.s, \"[\");\n         commasep(s, inconsistent, *before, |s, &p| print_pat(s, p));\n         for &p in slice.iter() {\n             if !before.is_empty() { word_space(s, \",\"); }\n             match p {\n                 @ast::Pat { node: ast::PatWildMulti, .. } => {\n                     // this case is handled by print_pat\n                 }\n-                _ => word(s.s, \"..\"),\n+                _ => word(&mut s.s, \"..\"),\n             }\n             print_pat(s, p);\n             if !after.is_empty() { word_space(s, \",\"); }\n         }\n         commasep(s, inconsistent, *after, |s, &p| print_pat(s, p));\n-        word(s.s, \"]\");\n+        word(&mut s.s, \"]\");\n       }\n     }\n-    s.ann.post(ann_node);\n+    {\n+        let ann_node = node_pat(s, pat);\n+        s.ann.post(ann_node);\n+    }\n }\n \n pub fn explicit_self_to_str(explicit_self: &ast::explicit_self_, intr: @ident_interner) -> ~str {\n     to_str(explicit_self, |a, &b| { print_explicit_self(a, b); () }, intr)\n }\n \n // Returns whether it printed anything\n-pub fn print_explicit_self(s: @ps, explicit_self: ast::explicit_self_) -> bool {\n+pub fn print_explicit_self(s: &mut ps, explicit_self: ast::explicit_self_) -> bool {\n     match explicit_self {\n         ast::sty_static => { return false; }\n         ast::sty_value(m) => {\n             print_mutability(s, m);\n-            word(s.s, \"self\");\n+            word(&mut s.s, \"self\");\n         }\n         ast::sty_uniq(m) => {\n             print_mutability(s, m);\n-            word(s.s, \"~self\");\n+            word(&mut s.s, \"~self\");\n         }\n         ast::sty_region(ref lt, m) => {\n-            word(s.s, \"&\");\n+            word(&mut s.s, \"&\");\n             print_opt_lifetime(s, lt);\n             print_mutability(s, m);\n-            word(s.s, \"self\");\n+            word(&mut s.s, \"self\");\n         }\n         ast::sty_box(m) => {\n-            word(s.s, \"@\"); print_mutability(s, m); word(s.s, \"self\");\n+            word(&mut s.s, \"@\"); print_mutability(s, m); word(&mut s.s, \"self\");\n         }\n     }\n     return true;\n }\n \n-pub fn print_fn(s: @ps,\n+pub fn print_fn(s: &mut ps,\n                 decl: &ast::fn_decl,\n                 purity: Option<ast::purity>,\n                 abis: AbiSet,\n@@ -1760,7 +1798,7 @@ pub fn print_fn(s: @ps,\n     print_fn_args_and_ret(s, decl, opt_explicit_self);\n }\n \n-pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n+pub fn print_fn_args(s: &mut ps, decl: &ast::fn_decl,\n                  opt_explicit_self: Option<ast::explicit_self_>) {\n     // It is unfortunate to duplicate the commasep logic, but we want the\n     // self type and the args all in the same box.\n@@ -1778,12 +1816,12 @@ pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n     end(s);\n }\n \n-pub fn print_fn_args_and_ret(s: @ps, decl: &ast::fn_decl,\n+pub fn print_fn_args_and_ret(s: &mut ps, decl: &ast::fn_decl,\n                              opt_explicit_self: Option<ast::explicit_self_>) {\n     popen(s);\n     print_fn_args(s, decl, opt_explicit_self);\n     if decl.variadic {\n-        word(s.s, \", ...\");\n+        word(&mut s.s, \", ...\");\n     }\n     pclose(s);\n \n@@ -1798,10 +1836,10 @@ pub fn print_fn_args_and_ret(s: @ps, decl: &ast::fn_decl,\n     }\n }\n \n-pub fn print_fn_block_args(s: @ps, decl: &ast::fn_decl) {\n-    word(s.s, \"|\");\n+pub fn print_fn_block_args(s: &mut ps, decl: &ast::fn_decl) {\n+    word(&mut s.s, \"|\");\n     print_fn_args(s, decl, None);\n-    word(s.s, \"|\");\n+    word(&mut s.s, \"|\");\n \n     match decl.output.node {\n         ast::ty_infer => {}\n@@ -1815,11 +1853,11 @@ pub fn print_fn_block_args(s: @ps, decl: &ast::fn_decl) {\n     maybe_print_comment(s, decl.output.span.lo);\n }\n \n-pub fn print_proc_args(s: @ps, decl: &ast::fn_decl) {\n-    word(s.s, \"proc\");\n-    word(s.s, \"(\");\n+pub fn print_proc_args(s: &mut ps, decl: &ast::fn_decl) {\n+    word(&mut s.s, \"proc\");\n+    word(&mut s.s, \"(\");\n     print_fn_args(s, decl, None);\n-    word(s.s, \")\");\n+    word(&mut s.s, \")\");\n \n     match decl.output.node {\n         ast::ty_infer => {}\n@@ -1833,10 +1871,10 @@ pub fn print_proc_args(s: @ps, decl: &ast::fn_decl) {\n     maybe_print_comment(s, decl.output.span.lo);\n }\n \n-pub fn print_bounds(s: @ps, bounds: &OptVec<ast::TyParamBound>,\n+pub fn print_bounds(s: &mut ps, bounds: &OptVec<ast::TyParamBound>,\n                     print_colon_anyway: bool) {\n     if !bounds.is_empty() {\n-        word(s.s, \":\");\n+        word(&mut s.s, \":\");\n         let mut first = true;\n         for bound in bounds.iter() {\n             nbsp(s);\n@@ -1848,24 +1886,24 @@ pub fn print_bounds(s: @ps, bounds: &OptVec<ast::TyParamBound>,\n \n             match *bound {\n                 TraitTyParamBound(ref tref) => print_trait_ref(s, tref),\n-                RegionTyParamBound => word(s.s, \"'static\"),\n+                RegionTyParamBound => word(&mut s.s, \"'static\"),\n             }\n         }\n     } else if print_colon_anyway {\n-        word(s.s, \":\");\n+        word(&mut s.s, \":\");\n     }\n }\n \n-pub fn print_lifetime(s: @ps, lifetime: &ast::Lifetime) {\n-    word(s.s, \"'\");\n+pub fn print_lifetime(s: &mut ps, lifetime: &ast::Lifetime) {\n+    word(&mut s.s, \"'\");\n     print_ident(s, lifetime.ident);\n }\n \n-pub fn print_generics(s: @ps, generics: &ast::Generics) {\n+pub fn print_generics(s: &mut ps, generics: &ast::Generics) {\n     let total = generics.lifetimes.len() + generics.ty_params.len();\n     if total > 0 {\n-        word(s.s, \"<\");\n-        fn print_item(s: @ps, generics: &ast::Generics, idx: uint) {\n+        word(&mut s.s, \"<\");\n+        fn print_item(s: &mut ps, generics: &ast::Generics, idx: uint) {\n             if idx < generics.lifetimes.len() {\n                 let lifetime = generics.lifetimes.get(idx);\n                 print_lifetime(s, lifetime);\n@@ -1884,21 +1922,21 @@ pub fn print_generics(s: @ps, generics: &ast::Generics) {\n \n         commasep(s, inconsistent, ints,\n                  |s, &i| print_item(s, generics, i));\n-        word(s.s, \">\");\n+        word(&mut s.s, \">\");\n     }\n }\n \n-pub fn print_meta_item(s: @ps, item: &ast::MetaItem) {\n+pub fn print_meta_item(s: &mut ps, item: &ast::MetaItem) {\n     ibox(s, indent_unit);\n     match item.node {\n-      ast::MetaWord(name) => word(s.s, name),\n+      ast::MetaWord(name) => word(&mut s.s, name),\n       ast::MetaNameValue(name, value) => {\n         word_space(s, name);\n         word_space(s, \"=\");\n         print_literal(s, &value);\n       }\n       ast::MetaList(name, ref items) => {\n-        word(s.s, name);\n+        word(&mut s.s, name);\n         popen(s);\n         commasep(s,\n                  consistent,\n@@ -1910,43 +1948,43 @@ pub fn print_meta_item(s: @ps, item: &ast::MetaItem) {\n     end(s);\n }\n \n-pub fn print_view_path(s: @ps, vp: &ast::view_path) {\n+pub fn print_view_path(s: &mut ps, vp: &ast::view_path) {\n     match vp.node {\n       ast::view_path_simple(ident, ref path, _) => {\n         // FIXME(#6993) can't compare identifiers directly here\n         if path.segments.last().identifier.name != ident.name {\n             print_ident(s, ident);\n-            space(s.s);\n+            space(&mut s.s);\n             word_space(s, \"=\");\n         }\n         print_path(s, path, false);\n       }\n \n       ast::view_path_glob(ref path, _) => {\n         print_path(s, path, false);\n-        word(s.s, \"::*\");\n+        word(&mut s.s, \"::*\");\n       }\n \n       ast::view_path_list(ref path, ref idents, _) => {\n         if path.segments.is_empty() {\n-            word(s.s, \"{\");\n+            word(&mut s.s, \"{\");\n         } else {\n             print_path(s, path, false);\n-            word(s.s, \"::{\");\n+            word(&mut s.s, \"::{\");\n         }\n         commasep(s, inconsistent, (*idents), |s, w| {\n             print_ident(s, w.node.name);\n         });\n-        word(s.s, \"}\");\n+        word(&mut s.s, \"}\");\n       }\n     }\n }\n \n-pub fn print_view_paths(s: @ps, vps: &[@ast::view_path]) {\n+pub fn print_view_paths(s: &mut ps, vps: &[@ast::view_path]) {\n     commasep(s, inconsistent, vps, |p, &vp| print_view_path(p, vp));\n }\n \n-pub fn print_view_item(s: @ps, item: &ast::view_item) {\n+pub fn print_view_item(s: &mut ps, item: &ast::view_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -1956,9 +1994,9 @@ pub fn print_view_item(s: @ps, item: &ast::view_item) {\n             head(s, \"extern mod\");\n             print_ident(s, id);\n             for &(ref p, style) in optional_path.iter() {\n-                space(s.s);\n-                word(s.s, \"=\");\n-                space(s.s);\n+                space(&mut s.s);\n+                word(&mut s.s, \"=\");\n+                space(&mut s.s);\n                 print_string(s, *p, style);\n             }\n         }\n@@ -1968,24 +2006,24 @@ pub fn print_view_item(s: @ps, item: &ast::view_item) {\n             print_view_paths(s, *vps);\n         }\n     }\n-    word(s.s, \";\");\n+    word(&mut s.s, \";\");\n     end(s); // end inner head-block\n     end(s); // end outer head-block\n }\n \n-pub fn print_mutability(s: @ps, mutbl: ast::Mutability) {\n+pub fn print_mutability(s: &mut ps, mutbl: ast::Mutability) {\n     match mutbl {\n       ast::MutMutable => word_nbsp(s, \"mut\"),\n       ast::MutImmutable => {/* nothing */ }\n     }\n }\n \n-pub fn print_mt(s: @ps, mt: &ast::mt) {\n+pub fn print_mt(s: &mut ps, mt: &ast::mt) {\n     print_mutability(s, mt.mutbl);\n     print_type(s, mt.ty);\n }\n \n-pub fn print_arg(s: @ps, input: &ast::arg) {\n+pub fn print_arg(s: &mut ps, input: &ast::arg) {\n     ibox(s, indent_unit);\n     match input.ty.node {\n       ast::ty_infer => print_pat(s, input.pat),\n@@ -1999,8 +2037,8 @@ pub fn print_arg(s: @ps, input: &ast::arg) {\n             }\n             _ => {\n                 print_pat(s, input.pat);\n-                word(s.s, \":\");\n-                space(s.s);\n+                word(&mut s.s, \":\");\n+                space(&mut s.s);\n             }\n         }\n         print_type(s, input.ty);\n@@ -2009,7 +2047,7 @@ pub fn print_arg(s: @ps, input: &ast::arg) {\n     end(s);\n }\n \n-pub fn print_ty_fn(s: @ps,\n+pub fn print_ty_fn(s: &mut ps,\n                    opt_abis: Option<AbiSet>,\n                    opt_sigil: Option<ast::Sigil>,\n                    opt_region: &Option<ast::Lifetime>,\n@@ -2025,7 +2063,7 @@ pub fn print_ty_fn(s: @ps,\n     // Duplicates the logic in `print_fn_header_info()`.  This is because that\n     // function prints the sigil in the wrong place.  That should be fixed.\n     if opt_sigil == Some(ast::OwnedSigil) && onceness == ast::Once {\n-        word(s.s, \"proc\");\n+        word(&mut s.s, \"proc\");\n     } else if opt_sigil == Some(ast::BorrowedSigil) {\n         print_extern_opt_abis(s, opt_abis);\n         for lifetime in opt_region.iter() {\n@@ -2039,20 +2077,20 @@ pub fn print_ty_fn(s: @ps,\n         print_opt_lifetime(s, opt_region);\n         print_purity(s, purity);\n         print_onceness(s, onceness);\n-        word(s.s, \"fn\");\n+        word(&mut s.s, \"fn\");\n     }\n \n-    match id { Some(id) => { word(s.s, \" \"); print_ident(s, id); } _ => () }\n+    match id { Some(id) => { word(&mut s.s, \" \"); print_ident(s, id); } _ => () }\n \n     if opt_sigil != Some(ast::BorrowedSigil) {\n         opt_bounds.as_ref().map(|bounds| print_bounds(s, bounds, true));\n     }\n \n     match generics { Some(g) => print_generics(s, g), _ => () }\n-    zerobreak(s.s);\n+    zerobreak(&mut s.s);\n \n     if opt_sigil == Some(ast::BorrowedSigil) {\n-        word(s.s, \"|\");\n+        word(&mut s.s, \"|\");\n     } else {\n         popen(s);\n     }\n@@ -2071,12 +2109,12 @@ pub fn print_ty_fn(s: @ps,\n     end(s);\n \n     if opt_sigil == Some(ast::BorrowedSigil) {\n-        word(s.s, \"|\");\n+        word(&mut s.s, \"|\");\n \n         opt_bounds.as_ref().map(|bounds| print_bounds(s, bounds, true));\n     } else {\n         if decl.variadic {\n-            word(s.s, \", ...\");\n+            word(&mut s.s, \", ...\");\n         }\n         pclose(s);\n     }\n@@ -2098,7 +2136,7 @@ pub fn print_ty_fn(s: @ps,\n     end(s);\n }\n \n-pub fn maybe_print_trailing_comment(s: @ps, span: codemap::Span,\n+pub fn maybe_print_trailing_comment(s: &mut ps, span: codemap::Span,\n                                     next_pos: Option<BytePos>) {\n     let cm;\n     match s.cm { Some(ccm) => cm = ccm, _ => return }\n@@ -2119,10 +2157,10 @@ pub fn maybe_print_trailing_comment(s: @ps, span: codemap::Span,\n     }\n }\n \n-pub fn print_remaining_comments(s: @ps) {\n+pub fn print_remaining_comments(s: &mut ps) {\n     // If there aren't any remaining comments, then we need to manually\n     // make sure there is a line break at the end.\n-    if next_comment(s).is_none() { hardbreak(s.s); }\n+    if next_comment(s).is_none() { hardbreak(&mut s.s); }\n     loop {\n         match next_comment(s) {\n           Some(ref cmnt) => {\n@@ -2134,11 +2172,11 @@ pub fn print_remaining_comments(s: @ps) {\n     }\n }\n \n-pub fn print_literal(s: @ps, lit: &ast::lit) {\n+pub fn print_literal(s: &mut ps, lit: &ast::lit) {\n     maybe_print_comment(s, lit.span.lo);\n     match next_lit(s, lit.span.lo) {\n       Some(ref ltrl) => {\n-        word(s.s, (*ltrl).lit);\n+        word(&mut s.s, (*ltrl).lit);\n         return;\n       }\n       _ => ()\n@@ -2149,45 +2187,45 @@ pub fn print_literal(s: @ps, lit: &ast::lit) {\n           let mut res = ~\"'\";\n           char::from_u32(ch).unwrap().escape_default(|c| res.push_char(c));\n           res.push_char('\\'');\n-          word(s.s, res);\n+          word(&mut s.s, res);\n       }\n       ast::lit_int(i, t) => {\n         if i < 0_i64 {\n-            word(s.s,\n+            word(&mut s.s,\n                  ~\"-\" + (-i as u64).to_str_radix(10u)\n                  + ast_util::int_ty_to_str(t));\n         } else {\n-            word(s.s,\n+            word(&mut s.s,\n                  (i as u64).to_str_radix(10u)\n                  + ast_util::int_ty_to_str(t));\n         }\n       }\n       ast::lit_uint(u, t) => {\n-        word(s.s,\n+        word(&mut s.s,\n              u.to_str_radix(10u)\n              + ast_util::uint_ty_to_str(t));\n       }\n       ast::lit_int_unsuffixed(i) => {\n         if i < 0_i64 {\n-            word(s.s, ~\"-\" + (-i as u64).to_str_radix(10u));\n+            word(&mut s.s, ~\"-\" + (-i as u64).to_str_radix(10u));\n         } else {\n-            word(s.s, (i as u64).to_str_radix(10u));\n+            word(&mut s.s, (i as u64).to_str_radix(10u));\n         }\n       }\n       ast::lit_float(f, t) => {\n-        word(s.s, f.to_owned() + ast_util::float_ty_to_str(t));\n+        word(&mut s.s, f.to_owned() + ast_util::float_ty_to_str(t));\n       }\n-      ast::lit_float_unsuffixed(f) => word(s.s, f),\n-      ast::lit_nil => word(s.s, \"()\"),\n+      ast::lit_float_unsuffixed(f) => word(&mut s.s, f),\n+      ast::lit_nil => word(&mut s.s, \"()\"),\n       ast::lit_bool(val) => {\n-        if val { word(s.s, \"true\"); } else { word(s.s, \"false\"); }\n+        if val { word(&mut s.s, \"true\"); } else { word(&mut s.s, \"false\"); }\n       }\n       ast::lit_binary(arr) => {\n         ibox(s, indent_unit);\n-        word(s.s, \"[\");\n-        commasep_cmnt(s, inconsistent, arr, |s, u| word(s.s, format!(\"{}\", *u)),\n+        word(&mut s.s, \"[\");\n+        commasep_cmnt(s, inconsistent, arr, |s, u| word(&mut s.s, format!(\"{}\", *u)),\n                       |_| lit.span);\n-        word(s.s, \"]\");\n+        word(&mut s.s, \"]\");\n         end(s);\n       }\n     }\n@@ -2197,7 +2235,7 @@ pub fn lit_to_str(l: &ast::lit) -> ~str {\n     return to_str(l, print_literal, parse::token::mk_fake_ident_interner());\n }\n \n-pub fn next_lit(s: @ps, pos: BytePos) -> Option<comments::lit> {\n+pub fn next_lit(s: &mut ps, pos: BytePos) -> Option<comments::lit> {\n     match s.literals {\n       Some(ref lits) => {\n         while s.cur_cmnt_and_lit.cur_lit < lits.len() {\n@@ -2212,7 +2250,7 @@ pub fn next_lit(s: @ps, pos: BytePos) -> Option<comments::lit> {\n     }\n }\n \n-pub fn maybe_print_comment(s: @ps, pos: BytePos) {\n+pub fn maybe_print_comment(s: &mut ps, pos: BytePos) {\n     loop {\n         match next_comment(s) {\n           Some(ref cmnt) => {\n@@ -2226,33 +2264,33 @@ pub fn maybe_print_comment(s: @ps, pos: BytePos) {\n     }\n }\n \n-pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n+pub fn print_comment(s: &mut ps, cmnt: &comments::cmnt) {\n     match cmnt.style {\n       comments::mixed => {\n         assert_eq!(cmnt.lines.len(), 1u);\n-        zerobreak(s.s);\n-        word(s.s, cmnt.lines[0]);\n-        zerobreak(s.s);\n+        zerobreak(&mut s.s);\n+        word(&mut s.s, cmnt.lines[0]);\n+        zerobreak(&mut s.s);\n       }\n       comments::isolated => {\n         pprust::hardbreak_if_not_bol(s);\n         for line in cmnt.lines.iter() {\n             // Don't print empty lines because they will end up as trailing\n             // whitespace\n-            if !line.is_empty() { word(s.s, *line); }\n-            hardbreak(s.s);\n+            if !line.is_empty() { word(&mut s.s, *line); }\n+            hardbreak(&mut s.s);\n         }\n       }\n       comments::trailing => {\n-        word(s.s, \" \");\n+        word(&mut s.s, \" \");\n         if cmnt.lines.len() == 1u {\n-            word(s.s, cmnt.lines[0]);\n-            hardbreak(s.s);\n+            word(&mut s.s, cmnt.lines[0]);\n+            hardbreak(&mut s.s);\n         } else {\n             ibox(s, 0u);\n             for line in cmnt.lines.iter() {\n-                if !line.is_empty() { word(s.s, *line); }\n-                hardbreak(s.s);\n+                if !line.is_empty() { word(&mut s.s, *line); }\n+                hardbreak(&mut s.s);\n             }\n             end(s);\n         }\n@@ -2264,30 +2302,42 @@ pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n               pp::STRING(s, _) => \";\" == s,\n               _ => false\n             };\n-        if is_semi || is_begin(s) || is_end(s) { hardbreak(s.s); }\n-        hardbreak(s.s);\n+        if is_semi || is_begin(s) || is_end(s) { hardbreak(&mut s.s); }\n+        hardbreak(&mut s.s);\n       }\n     }\n }\n \n-pub fn print_string(s: @ps, st: &str, style: ast::StrStyle) {\n+pub fn print_string(s: &mut ps, st: &str, style: ast::StrStyle) {\n     let st = match style {\n         ast::CookedStr => format!(\"\\\"{}\\\"\", st.escape_default()),\n         ast::RawStr(n) => format!(\"r{delim}\\\"{string}\\\"{delim}\",\n                                   delim=\"#\".repeat(n), string=st)\n     };\n-    word(s.s, st);\n+    word(&mut s.s, st);\n }\n \n-pub fn to_str<T>(t: &T, f: |@ps, &T|, intr: @ident_interner) -> ~str {\n-    let wr = @mut MemWriter::new();\n-    let s = rust_printer(wr as @mut io::Writer, intr);\n-    f(s, t);\n-    eof(s.s);\n-    str::from_utf8_owned(wr.inner_ref().to_owned())\n+// XXX(pcwalton): A nasty function to extract the string from an `io::Writer`\n+// that we \"know\" to be a `MemWriter` that works around the lack of checked\n+// downcasts.\n+unsafe fn get_mem_writer(writer: &mut ~io::Writer) -> ~str {\n+    let (_, wr): (uint, ~MemWriter) = cast::transmute_copy(writer);\n+    let result = str::from_utf8_owned(wr.inner_ref().to_owned());\n+    cast::forget(wr);\n+    result\n }\n \n-pub fn next_comment(s: @ps) -> Option<comments::cmnt> {\n+pub fn to_str<T>(t: &T, f: |&mut ps, &T|, intr: @ident_interner) -> ~str {\n+    let wr = ~MemWriter::new();\n+    let mut s = rust_printer(wr as ~io::Writer, intr);\n+    f(&mut s, t);\n+    eof(&mut s.s);\n+    unsafe {\n+        get_mem_writer(&mut s.s.out)\n+    }\n+}\n+\n+pub fn next_comment(s: &mut ps) -> Option<comments::cmnt> {\n     match s.comments {\n       Some(ref cmnts) => {\n         if s.cur_cmnt_and_lit.cur_cmnt < cmnts.len() {\n@@ -2300,7 +2350,7 @@ pub fn next_comment(s: @ps) -> Option<comments::cmnt> {\n     }\n }\n \n-pub fn print_opt_purity(s: @ps, opt_purity: Option<ast::purity>) {\n+pub fn print_opt_purity(s: &mut ps, opt_purity: Option<ast::purity>) {\n     match opt_purity {\n         Some(ast::impure_fn) => { }\n         Some(purity) => {\n@@ -2310,7 +2360,7 @@ pub fn print_opt_purity(s: @ps, opt_purity: Option<ast::purity>) {\n     }\n }\n \n-pub fn print_opt_abis_and_extern_if_nondefault(s: @ps,\n+pub fn print_opt_abis_and_extern_if_nondefault(s: &mut ps,\n                                                opt_abis: Option<AbiSet>) {\n     match opt_abis {\n         Some(abis) if !abis.is_rust() => {\n@@ -2321,7 +2371,7 @@ pub fn print_opt_abis_and_extern_if_nondefault(s: @ps,\n     };\n }\n \n-pub fn print_extern_opt_abis(s: @ps, opt_abis: Option<AbiSet>) {\n+pub fn print_extern_opt_abis(s: &mut ps, opt_abis: Option<AbiSet>) {\n     match opt_abis {\n         Some(abis) => {\n             word_nbsp(s, \"extern\");\n@@ -2331,23 +2381,23 @@ pub fn print_extern_opt_abis(s: @ps, opt_abis: Option<AbiSet>) {\n     };\n }\n \n-pub fn print_opt_sigil(s: @ps, opt_sigil: Option<ast::Sigil>) {\n+pub fn print_opt_sigil(s: &mut ps, opt_sigil: Option<ast::Sigil>) {\n     match opt_sigil {\n-        Some(ast::BorrowedSigil) => { word(s.s, \"&\"); }\n-        Some(ast::OwnedSigil) => { word(s.s, \"~\"); }\n-        Some(ast::ManagedSigil) => { word(s.s, \"@\"); }\n+        Some(ast::BorrowedSigil) => { word(&mut s.s, \"&\"); }\n+        Some(ast::OwnedSigil) => { word(&mut s.s, \"~\"); }\n+        Some(ast::ManagedSigil) => { word(&mut s.s, \"@\"); }\n         None => {}\n     };\n }\n \n-pub fn print_fn_header_info(s: @ps,\n+pub fn print_fn_header_info(s: &mut ps,\n                             _opt_explicit_self: Option<ast::explicit_self_>,\n                             opt_purity: Option<ast::purity>,\n                             abis: AbiSet,\n                             onceness: ast::Onceness,\n                             opt_sigil: Option<ast::Sigil>,\n                             vis: ast::visibility) {\n-    word(s.s, visibility_qualified(vis, \"\"));\n+    word(&mut s.s, visibility_qualified(vis, \"\"));\n \n     if abis != AbiSet::Rust() {\n         word_nbsp(s, \"extern\");\n@@ -2361,7 +2411,7 @@ pub fn print_fn_header_info(s: @ps,\n     }\n \n     print_onceness(s, onceness);\n-    word(s.s, \"fn\");\n+    word(&mut s.s, \"fn\");\n     print_opt_sigil(s, opt_sigil);\n }\n \n@@ -2380,14 +2430,14 @@ pub fn onceness_to_str(o: ast::Onceness) -> &'static str {\n     }\n }\n \n-pub fn print_purity(s: @ps, p: ast::purity) {\n+pub fn print_purity(s: &mut ps, p: ast::purity) {\n     match p {\n       ast::impure_fn => (),\n       _ => word_nbsp(s, purity_to_str(p))\n     }\n }\n \n-pub fn print_onceness(s: @ps, o: ast::Onceness) {\n+pub fn print_onceness(s: &mut ps, o: ast::Onceness) {\n     match o {\n         ast::Once => { word_nbsp(s, \"once\"); }\n         ast::Many => {}\n@@ -2403,12 +2453,6 @@ mod test {\n     use codemap;\n     use parse::token;\n \n-    fn string_check<T:Eq> (given : &T, expected: &T) {\n-        if !(given == expected) {\n-            fail!(\"given {:?}, expected {:?}\", given, expected);\n-        }\n-    }\n-\n     #[test]\n     fn test_fun_to_str() {\n         let abba_ident = token::str_to_ident(\"abba\");"}, {"sha": "b694e1f702b4ea30a225c6539affbfa74b7a253b", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 46, "deletions": 29, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -14,20 +14,21 @@\n \n use ast::Name;\n \n+use std::cell::RefCell;\n use std::cmp::Equiv;\n use std::hashmap::HashMap;\n \n pub struct Interner<T> {\n-    priv map: @mut HashMap<T, Name>,\n-    priv vect: @mut ~[T],\n+    priv map: @RefCell<HashMap<T, Name>>,\n+    priv vect: @RefCell<~[T]>,\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n impl<T:Eq + IterBytes + Hash + Freeze + Clone + 'static> Interner<T> {\n     pub fn new() -> Interner<T> {\n         Interner {\n-            map: @mut HashMap::new(),\n-            vect: @mut ~[],\n+            map: @RefCell::new(HashMap::new()),\n+            vect: @RefCell::new(~[]),\n         }\n     }\n \n@@ -40,37 +41,41 @@ impl<T:Eq + IterBytes + Hash + Freeze + Clone + 'static> Interner<T> {\n     }\n \n     pub fn intern(&self, val: T) -> Name {\n-        match self.map.find(&val) {\n+        let mut map = self.map.borrow_mut();\n+        match map.get().find(&val) {\n             Some(&idx) => return idx,\n             None => (),\n         }\n \n-        let vect = &mut *self.vect;\n-        let new_idx = vect.len() as Name;\n-        self.map.insert(val.clone(), new_idx);\n-        vect.push(val);\n+        let mut vect = self.vect.borrow_mut();\n+        let new_idx = vect.get().len() as Name;\n+        map.get().insert(val.clone(), new_idx);\n+        vect.get().push(val);\n         new_idx\n     }\n \n     pub fn gensym(&self, val: T) -> Name {\n-        let new_idx = {\n-            let vect = &*self.vect;\n-            vect.len() as Name\n-        };\n+        let mut vect = self.vect.borrow_mut();\n+        let new_idx = vect.get().len() as Name;\n         // leave out of .map to avoid colliding\n-        self.vect.push(val);\n+        vect.get().push(val);\n         new_idx\n     }\n \n     pub fn get(&self, idx: Name) -> T {\n-        self.vect[idx].clone()\n+        let vect = self.vect.borrow();\n+        vect.get()[idx].clone()\n     }\n \n-    pub fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n+    pub fn len(&self) -> uint {\n+        let vect = self.vect.borrow();\n+        vect.get().len()\n+    }\n \n     pub fn find_equiv<Q:Hash + IterBytes + Equiv<T>>(&self, val: &Q)\n                                               -> Option<Name> {\n-        match self.map.find_equiv(val) {\n+        let map = self.map.borrow();\n+        match map.get().find_equiv(val) {\n             Some(v) => Some(*v),\n             None => None,\n         }\n@@ -80,16 +85,16 @@ impl<T:Eq + IterBytes + Hash + Freeze + Clone + 'static> Interner<T> {\n // A StrInterner differs from Interner<String> in that it accepts\n // borrowed pointers rather than @ ones, resulting in less allocation.\n pub struct StrInterner {\n-    priv map: @mut HashMap<@str, Name>,\n-    priv vect: @mut ~[@str],\n+    priv map: @RefCell<HashMap<@str, Name>>,\n+    priv vect: @RefCell<~[@str]>,\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n impl StrInterner {\n     pub fn new() -> StrInterner {\n         StrInterner {\n-            map: @mut HashMap::new(),\n-            vect: @mut ~[],\n+            map: @RefCell::new(HashMap::new()),\n+            vect: @RefCell::new(~[]),\n         }\n     }\n \n@@ -100,22 +105,25 @@ impl StrInterner {\n     }\n \n     pub fn intern(&self, val: &str) -> Name {\n-        match self.map.find_equiv(&val) {\n+        let mut map = self.map.borrow_mut();\n+        match map.get().find_equiv(&val) {\n             Some(&idx) => return idx,\n             None => (),\n         }\n \n         let new_idx = self.len() as Name;\n         let val = val.to_managed();\n-        self.map.insert(val, new_idx);\n-        self.vect.push(val);\n+        map.get().insert(val, new_idx);\n+        let mut vect = self.vect.borrow_mut();\n+        vect.get().push(val);\n         new_idx\n     }\n \n     pub fn gensym(&self, val: &str) -> Name {\n         let new_idx = self.len() as Name;\n         // leave out of .map to avoid colliding\n-        self.vect.push(val.to_managed());\n+        let mut vect = self.vect.borrow_mut();\n+        vect.get().push(val.to_managed());\n         new_idx\n     }\n \n@@ -132,17 +140,26 @@ impl StrInterner {\n     pub fn gensym_copy(&self, idx : Name) -> Name {\n         let new_idx = self.len() as Name;\n         // leave out of map to avoid colliding\n-        self.vect.push(self.vect[idx]);\n+        let mut vect = self.vect.borrow_mut();\n+        let existing = vect.get()[idx];\n+        vect.get().push(existing);\n         new_idx\n     }\n \n-    pub fn get(&self, idx: Name) -> @str { self.vect[idx] }\n+    pub fn get(&self, idx: Name) -> @str {\n+        let vect = self.vect.borrow();\n+        vect.get()[idx]\n+    }\n \n-    pub fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n+    pub fn len(&self) -> uint {\n+        let vect = self.vect.borrow();\n+        vect.get().len()\n+    }\n \n     pub fn find_equiv<Q:Hash + IterBytes + Equiv<@str>>(&self, val: &Q)\n                                                          -> Option<Name> {\n-        match self.map.find_equiv(val) {\n+        let map = self.map.borrow();\n+        match map.get().find_equiv(val) {\n             Some(v) => Some(*v),\n             None => None,\n         }"}, {"sha": "dc546c7610f9f19e1548748ab02566d15971bf5e", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -17,7 +17,7 @@ use parse::token;\n \n // map a string to tts, using a made-up filename: return both the token_trees\n // and the ParseSess\n-pub fn string_to_tts_and_sess (source_str : @str) -> (~[ast::token_tree],@mut ParseSess) {\n+pub fn string_to_tts_and_sess (source_str : @str) -> (~[ast::token_tree],@ParseSess) {\n     let ps = new_parse_sess(None);\n     (filemap_to_tts(ps,string_to_filemap(ps,source_str,@\"bogofile\")),ps)\n }\n@@ -28,7 +28,7 @@ pub fn string_to_tts(source_str : @str) -> ~[ast::token_tree] {\n     tts\n }\n \n-pub fn string_to_parser_and_sess(source_str: @str) -> (Parser,@mut ParseSess) {\n+pub fn string_to_parser_and_sess(source_str: @str) -> (Parser,@ParseSess) {\n     let ps = new_parse_sess(None);\n     (new_parser_from_source_str(ps,~[],@\"bogofile\",source_str),ps)\n }\n@@ -54,7 +54,7 @@ pub fn string_to_crate (source_str : @str) -> ast::Crate {\n }\n \n // parse a string, return a crate and the ParseSess\n-pub fn string_to_crate_and_sess (source_str : @str) -> (ast::Crate,@mut ParseSess) {\n+pub fn string_to_crate_and_sess (source_str : @str) -> (ast::Crate,@ParseSess) {\n     let (mut p,ps) = string_to_parser_and_sess(source_str);\n     (p.parse_crate_mod(),ps)\n }"}, {"sha": "29567ab94421388f021bc38b574063966a3daf55", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -302,10 +302,10 @@ pub fn skip_ty<E, V:Visitor<E>>(_: &mut V, _: &Ty, _: E) {\n \n pub fn walk_ty<E:Clone, V:Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n     match typ.node {\n-        ty_uniq(ty) | ty_vec(ty) => {\n+        ty_uniq(ty) | ty_vec(ty) | ty_box(ty) => {\n             visitor.visit_ty(ty, env)\n         }\n-        ty_box(ref mutable_type) | ty_ptr(ref mutable_type) => {\n+        ty_ptr(ref mutable_type) => {\n             visitor.visit_ty(mutable_type.ty, env)\n         }\n         ty_rptr(ref lifetime, ref mutable_type) => {"}, {"sha": "90b01f8888bef4186b5ade011bdc4ca2c2baaa65", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,18 +10,21 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::RefCell;\n+\n pub struct Entry<A,B> {\n     key: A,\n     value: B\n }\n \n pub struct alist<A,B> {\n     eq_fn: extern \"Rust\" fn(A,A) -> bool,\n-    data: @mut ~[Entry<A,B>]\n+    data: @RefCell<~[Entry<A,B>]>,\n }\n \n pub fn alist_add<A:'static,B:'static>(lst: &alist<A,B>, k: A, v: B) {\n-    lst.data.push(Entry{key:k, value:v});\n+    let mut data = lst.data.borrow_mut();\n+    data.get().push(Entry{key:k, value:v});\n }\n \n pub fn alist_get<A:Clone + 'static,\n@@ -30,7 +33,8 @@ pub fn alist_get<A:Clone + 'static,\n                  k: A)\n                  -> B {\n     let eq_fn = lst.eq_fn;\n-    for entry in lst.data.iter() {\n+    let data = lst.data.borrow();\n+    for entry in data.get().iter() {\n         if eq_fn(entry.key.clone(), k.clone()) {\n             return entry.value.clone();\n         }\n@@ -41,12 +45,18 @@ pub fn alist_get<A:Clone + 'static,\n #[inline]\n pub fn new_int_alist<B:'static>() -> alist<int, B> {\n     fn eq_int(a: int, b: int) -> bool { a == b }\n-    return alist {eq_fn: eq_int, data: @mut ~[]};\n+    return alist {\n+        eq_fn: eq_int,\n+        data: @RefCell::new(~[]),\n+    };\n }\n \n #[inline]\n pub fn new_int_alist_2<B:'static>() -> alist<int, B> {\n     #[inline]\n     fn eq_int(a: int, b: int) -> bool { a == b }\n-    return alist {eq_fn: eq_int, data: @mut ~[]};\n+    return alist {\n+        eq_fn: eq_int,\n+        data: @RefCell::new(~[]),\n+    };\n }"}, {"sha": "15dde899ce374c2de5bdd1d99ab9c97af96f9173", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -14,11 +14,12 @@\n \n extern mod extra;\n \n+use std::cell::RefCell;\n use std::hashmap::HashMap;\n \n-pub type header_map = HashMap<~str, @mut ~[@~str]>;\n+pub type header_map = HashMap<~str, @RefCell<~[@~str]>>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T>(req: &header_map) {\n-  let _x = (*((**req.get(&~\"METHOD\")).clone())[0u]).clone();\n+  let _x = (*((**req.get(&~\"METHOD\")).clone()).get()[0u]).clone();\n }"}, {"sha": "75587f17b10330c552f45d43bdcf81e5dd347e1c", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -86,7 +86,7 @@ impl Sudoku {\n         return Sudoku::new(g)\n     }\n \n-    pub fn write(&self, writer: @mut io::Writer) {\n+    pub fn write(&self, writer: &mut io::Writer) {\n         for row in range(0u8, 9u8) {\n             write!(writer, \"{}\", self.grid[row][0]);\n             for col in range(1u8, 9u8) {\n@@ -280,5 +280,5 @@ fn main() {\n         Sudoku::read(BufferedReader::new(io::stdin()))\n     };\n     sudoku.solve();\n-    sudoku.write(@mut io::stdout() as @mut io::Writer);\n+    sudoku.write(&mut io::stdout());\n }"}, {"sha": "9d628c1f6c750402ce798ffb260b110b543b0f81", "filename": "src/test/compile-fail/borrowck-loan-rcvr-overloaded-op.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -49,13 +49,5 @@ fn b() {\n     q.x += 1; // and OK to mutate it\n }\n \n-fn c() {\n-    // Here the receiver is in aliased memory but due to write\n-    // barriers we can still consider it immutable.\n-    let q = @mut Point {x: 3, y: 4};\n-    *q + 3;\n-    q.times(3);\n-}\n-\n fn main() {\n }"}, {"sha": "a0071938ce437ee50ee4f879264286c45e01c91b", "filename": "src/test/compile-fail/borrowck-loan-rcvr.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -48,16 +48,5 @@ fn b() {\n     l.x += 1;\n }\n \n-fn c() {\n-    // Loaning @mut as & is considered legal due to dynamic checks...\n-    let q = @mut point {x: 3, y: 4};\n-    q.impurem();\n-\n-    // ...but we still detect errors statically when we can.\n-    q.blockm(|| {\n-        q.x = 10; //~ ERROR cannot assign\n-    })\n-}\n-\n fn main() {\n }"}, {"sha": "84c2db8bd576bdab4ecd8b829b7cfce652df7c62", "filename": "src/test/compile-fail/borrowck-mut-boxed-vec.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-fn main() {\n-    let v = @mut [ 1, 2, 3 ];\n-    for _x in v.iter() {\n-        v[1] = 4; //~ ERROR cannot assign\n-    }\n-}"}, {"sha": "77318e6a636a1fb47c4b0a0d0f2739959fce039d", "filename": "src/test/compile-fail/borrowck-mut-deref-comp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -12,7 +12,7 @@\n \n struct foo(~int);\n \n-fn borrow(x: @mut foo) {\n+fn borrow(x: @foo) {\n     let _y = &***x;\n     *x = foo(~4); //~ ERROR cannot assign\n }"}, {"sha": "1d1b993f5d1fee7faa7bf0cde4a696d18822a13b", "filename": "src/test/compile-fail/borrowck-object-mutability.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fborrowck-object-mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fborrowck-object-mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-object-mutability.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -30,11 +30,6 @@ fn managed_receiver(x: @Foo) {\n     x.borrowed_mut(); //~ ERROR cannot borrow\n }\n \n-fn managed_mut_receiver(x: @mut Foo) {\n-    x.borrowed();\n-    x.borrowed_mut();\n-}\n-\n fn owned_receiver(x: ~Foo) {\n     x.borrowed();\n     x.borrowed_mut(); //~ ERROR cannot borrow"}, {"sha": "451f023f5fcf718f79830280d9bf6b928eb4d1bc", "filename": "src/test/compile-fail/borrowck-wg-borrow-mut-to-imm-fail-2.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-2.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,5 +0,0 @@\n-fn main() {\n-    let mut b = ~3;\n-    let _x = &mut *b;\n-    let _y = &mut *b; //~ ERROR cannot borrow\n-}"}, {"sha": "c455de888a330bf9eeb9f6e6720b82e17ae3a2fc", "filename": "src/test/compile-fail/borrowck-wg-borrow-mut-to-imm-fail-3.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail-3.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    let mut a = ~3;\n-    let mut b = &mut a;\n-    let _c = &mut *b;\n-    let mut d = /*move*/ a; //~ ERROR cannot move out\n-    *d += 1;\n-}"}, {"sha": "e18808dfe538a2309acf8c135865fde3263183ed", "filename": "src/test/compile-fail/borrowck-wg-borrow-mut-to-imm-fail.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-borrow-mut-to-imm-fail.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,6 +0,0 @@\n-fn main() {\n-    let mut b = ~3;\n-    let _x = &mut *b;\n-    let mut y = /*move*/ b; //~ ERROR cannot move out\n-    *y += 1;\n-}"}, {"sha": "4050b4c5971a03248567583f14e6812d17f35a86", "filename": "src/test/compile-fail/borrowck-wg-move-base-2.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-move-base-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-move-base-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-wg-move-base-2.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,9 +0,0 @@\n-fn foo(x: &mut int) {\n-    let mut a = 3;\n-    let mut _y = &mut *x;\n-    let _z = &mut *_y;\n-    _y = &mut a; //~ ERROR cannot assign\n-}\n-\n-fn main() {\n-}"}, {"sha": "817696c6d20de1faff64208ad87aa62b7c649f95", "filename": "src/test/compile-fail/cast-immutable-mutable-trait.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Fcompile-fail%2Fcast-immutable-mutable-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Fcompile-fail%2Fcast-immutable-mutable-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-immutable-mutable-trait.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-trait T {\n-    fn foo(@mut self);\n-}\n-\n-struct S {\n-    unused: int\n-}\n-\n-impl T for S {\n-    fn foo(@mut self) {\n-    }\n-}\n-\n-fn main() {\n-    let s = @S { unused: 0 };\n-    let _s2 = s as @mut T; //~ error: types differ in mutability\n-    let _s3 = &s as &mut T; //~ error: types differ in mutability\n-}"}, {"sha": "2277f7080af75c464225f56ee34b52336f579f1d", "filename": "src/test/compile-fail/fn-variance-1.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -8,19 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n+fn takes_imm(x: &int) { }\n \n-fn takes_mut(x: @mut int) { }\n-fn takes_imm(x: @int) { }\n+fn takes_mut(x: &mut int) { }\n \n fn apply<T>(t: T, f: |T|) {\n     f(t)\n }\n \n fn main() {\n-    apply(@3, takes_mut); //~ ERROR (values differ in mutability)\n-    apply(@3, takes_imm);\n+    apply(&3, takes_mut); //~ ERROR (values differ in mutability)\n+    apply(&3, takes_imm);\n \n-    apply(@mut 3, takes_mut);\n-    apply(@mut 3, takes_imm); //~ ERROR (values differ in mutability)\n+    apply(&mut 3, takes_mut);\n+    apply(&mut 3, takes_imm); //~ ERROR (values differ in mutability)\n }"}, {"sha": "302e883942e6cc0f36c22e13a35d9d118dba715a", "filename": "src/test/compile-fail/issue-10487.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fissue-10487.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fissue-10487.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10487.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -12,6 +12,5 @@\n \n static x: ~[int] = ~[123, 456]; //~ ERROR: cannot allocate vectors in constant expressions\n static y: @[int] = @[123, 456]; //~ ERROR: cannot allocate vectors in constant expressions\n-static z: @mut [int] = @mut [123, 456]; //~ ERROR: cannot allocate vectors in constant expressions\n \n fn main() {}"}, {"sha": "def712d9e8de4314cebbbcd500dec0d4debbd202", "filename": "src/test/compile-fail/issue-2548.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -12,28 +12,28 @@\n \n // A test case for #2548.\n \n-struct foo {\n-    x: @mut int,\n-\n+use std::cell::Cell;\n \n+struct foo {\n+    x: @Cell<int>,\n }\n \n #[unsafe_destructor]\n impl Drop for foo {\n     fn drop(&mut self) {\n         unsafe {\n             println(\"Goodbye, World!\");\n-            *self.x += 1;\n+            self.x.set(self.x.get() + 1);\n         }\n     }\n }\n \n-fn foo(x: @mut int) -> foo {\n+fn foo(x: @Cell<int>) -> foo {\n     foo { x: x }\n }\n \n fn main() {\n-    let x = @mut 0;\n+    let x = @Cell::new(0);\n \n     {\n         let mut res = foo(x);\n@@ -43,5 +43,5 @@ fn main() {\n         assert_eq!(v.len(), 2);\n     }\n \n-    assert_eq!(*x, 1);\n+    assert_eq!(x.get(), 1);\n }"}, {"sha": "fe57d7171a68fe7b4c1c923726dfd6f264602b66", "filename": "src/test/compile-fail/issue-3668.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,7 +10,7 @@\n \n #[feature(managed_boxes)];\n \n-struct P { child: Option<@mut P> }\n+struct P { child: Option<@P> }\n trait PTrait {\n    fn getChildOption(&self) -> Option<@P>;\n }"}, {"sha": "de277b4c36efddcb70a7b4346dcd7c798c2f34d4", "filename": "src/test/compile-fail/kindck-destructor-owned.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fkindck-destructor-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fkindck-destructor-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-destructor-owned.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -1,12 +1,11 @@\n #[feature(managed_boxes)];\n \n struct Foo {\n-    f: @mut int,\n+    f: @int,\n }\n \n impl Drop for Foo { //~ ERROR cannot implement a destructor on a structure that does not satisfy Send\n     fn drop(&mut self) {\n-        *self.f = 10;\n     }\n }\n "}, {"sha": "0ce8ee40d3bfa203c148f02cefbf2928d640549b", "filename": "src/test/compile-fail/lub-in-args.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Fcompile-fail%2Flub-in-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Fcompile-fail%2Flub-in-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-in-args.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-fn two_args<T>(x: T, y: T) { }\n-\n-fn main() {\n-    let a: @mut int = @mut 3;\n-    let b: @int = @3;\n-\n-    // NOTE:\n-    //\n-    // The fact that this test fails to compile reflects a known\n-    // shortcoming of the current inference algorithm.  These errors\n-    // are *not* desirable.\n-\n-    two_args(a, b); //~ ERROR (values differ in mutability)\n-}"}, {"sha": "2270cb6f498b1f479958644eba0f0edece7d713c", "filename": "src/test/compile-fail/object-pointer-types.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -15,7 +15,6 @@ trait Foo {\n     fn borrowed_mut(&mut self);\n \n     fn managed(@self);\n-    fn managed_mut(@mut self);\n \n     fn owned(~self);\n }\n@@ -24,39 +23,27 @@ fn borrowed_receiver(x: &Foo) {\n     x.borrowed();\n     x.borrowed_mut(); // See [1]\n     x.managed(); //~ ERROR does not implement any method\n-    x.managed_mut(); //~ ERROR does not implement any method\n     x.owned(); //~ ERROR does not implement any method\n }\n \n fn borrowed_mut_receiver(x: &mut Foo) {\n     x.borrowed();\n     x.borrowed_mut();\n     x.managed(); //~ ERROR does not implement any method\n-    x.managed_mut(); //~ ERROR does not implement any method\n     x.owned(); //~ ERROR does not implement any method\n }\n \n fn managed_receiver(x: @Foo) {\n     x.borrowed();\n     x.borrowed_mut(); // See [1]\n     x.managed();\n-    x.managed_mut();  //~ ERROR does not implement any method\n-    x.owned(); //~ ERROR does not implement any method\n-}\n-\n-fn managed_mut_receiver(x: @mut Foo) {\n-    x.borrowed();\n-    x.borrowed_mut();\n-    x.managed();  //~ ERROR does not implement any method\n-    x.managed_mut();\n     x.owned(); //~ ERROR does not implement any method\n }\n \n fn owned_receiver(x: ~Foo) {\n     x.borrowed();\n     x.borrowed_mut(); // See [1]\n     x.managed();  //~ ERROR does not implement any method\n-    x.managed_mut();  //~ ERROR does not implement any method\n     x.owned();\n }\n "}, {"sha": "9c9b4a9f4d5b0babeca2348808ead932e4938684", "filename": "src/test/compile-fail/pinned-deep-copy.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,20 +10,22 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::Cell;\n+\n struct r {\n-  i: @mut int,\n+  i: @Cell<int>,\n }\n \n #[unsafe_destructor]\n impl Drop for r {\n     fn drop(&mut self) {\n         unsafe {\n-            *(self.i) = *(self.i) + 1;\n+            self.i.set(self.i.get() + 1);\n         }\n     }\n }\n \n-fn r(i: @mut int) -> r {\n+fn r(i: @Cell<int>) -> r {\n     r {\n         i: i\n     }\n@@ -34,7 +36,7 @@ struct A {\n }\n \n fn main() {\n-    let i = @mut 0;\n+    let i = @Cell::new(0);\n     {\n         // Can't do this copy\n         let x = ~~~A {y: r(i)};"}, {"sha": "b36933c4957f2f47e3c5c6cd0c1c2f697c929d52", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -11,7 +11,7 @@\n #[feature(managed_boxes)];\n \n struct invariant<'a> {\n-    f: 'static |x: @mut &'a int|\n+    f: 'static |x: &mut &'a int|\n }\n \n fn to_same_lifetime<'r>(bi: invariant<'r>) {"}, {"sha": "449cbc6970fdb2e61a8646be3ff4c3f701db290b", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -11,7 +11,7 @@\n #[feature(managed_boxes)];\n \n struct invariant<'a> {\n-    f: 'static || -> @mut &'a int\n+    f: 'static || -> &mut &'a int\n }\n \n fn to_same_lifetime<'r>(bi: invariant<'r>) {"}, {"sha": "c604e66507e0a32e89a981b36177dba2b68db060", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,15 +10,17 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::Cell;\n+\n struct r {\n-  i: @mut int,\n+  i: @Cell<int>,\n }\n \n #[unsafe_destructor]\n impl Drop for r {\n     fn drop(&mut self) {\n         unsafe {\n-            *(self.i) = *(self.i) + 1;\n+            self.i.set(self.i.get() + 1);\n         }\n     }\n }\n@@ -27,12 +29,12 @@ fn f<T>(_i: ~[T], _j: ~[T]) {\n }\n \n fn main() {\n-    let i1 = @mut 0;\n-    let i2 = @mut 1;\n+    let i1 = @Cell::new(0);\n+    let i2 = @Cell::new(1);\n     let r1 = ~[~r { i: i1 }];\n     let r2 = ~[~r { i: i2 }];\n     f(r1.clone(), r2.clone());\n     //~^ ERROR failed to find an implementation of\n-    info!(\"{:?}\", (r2, *i1));\n-    info!(\"{:?}\", (r1, *i2));\n+    info!(\"{:?}\", (r2, i1.get()));\n+    info!(\"{:?}\", (r1, i2.get()));\n }"}, {"sha": "3f789fa456a9c4eaffe1469c9e9ed1bacad912d3", "filename": "src/test/pretty/block-disambig.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-disambig.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -14,16 +14,18 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::Cell;\n+\n fn test1() { let val = @0; { } *val; }\n \n fn test2() -> int { let val = @0; { } *val }\n \n struct S { eax: int }\n \n fn test3() {\n-    let regs = @mut S {eax: 0};\n+    let regs = @Cell::new(S {eax: 0});\n     match true { true => { } _ => { } }\n-    (*regs).eax = 1;\n+    regs.set(S {eax: 1});\n }\n \n fn test4() -> bool { let regs = @true; if true { } *regs || false }\n@@ -51,10 +53,13 @@ fn test8() -> int {\n     }\n }\n \n-fn test9() { let regs = @mut 0; match true { true => { } _ => { } } *regs += 1; }\n+fn test9() {\n+    let regs = @Cell::new(0);\n+    match true { true => { } _ => { } } regs.set(regs.get() + 1);\n+}\n \n fn test10() -> int {\n-    let regs = @mut ~[0];\n+    let regs = @~[0];\n     match true { true => { } _ => { } }\n     (*regs)[0]\n }"}, {"sha": "c9bc061995d3e847086a1455a9de1d7dec93954b", "filename": "src/test/run-fail/borrowck-wg-autoderef-and-autoborrowvec-combined-fail-issue-6272.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-autoderef-and-autoborrowvec-combined-fail-issue-6272.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-autoderef-and-autoborrowvec-combined-fail-issue-6272.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-autoderef-and-autoborrowvec-combined-fail-issue-6272.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,23 +0,0 @@\n-// error-pattern:borrowed\n-\n-// Issue #6272. Tests that freezing correctly accounts for all the\n-// implicit derefs that can occur and freezes the innermost box. See\n-// the companion test\n-//\n-//     run-pass/borrowck-wg-autoderef-and-autoborrowvec-combined-issue-6272.rs\n-//\n-// for a detailed explanation of what is going on here.\n-\n-#[feature(managed_boxes)];\n-\n-fn main() {\n-    let a = @mut [3i];\n-    let b = @mut [a];\n-    let c = @mut b;\n-\n-    // this should freeze `a` only\n-    let _x: &mut [int] = c[0];\n-\n-    // hence this should fail\n-    a[0] = a[0];\n-}"}, {"sha": "284882ff6f5d57347d4c6f00012416de5a13a7d7", "filename": "src/test/run-fail/borrowck-wg-fail-2.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-2.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,17 +0,0 @@\n-// error-pattern:borrowed\n-\n-// Test that write guards trigger when there is a write to a field\n-// of a frozen structure.\n-\n-#[feature(managed_boxes)];\n-\n-struct S {\n-    x: int\n-}\n-\n-fn main() {\n-    let x = @mut S { x: 3 };\n-    let _y: &S = x;\n-    let z = x;\n-    z.x = 5;\n-}"}, {"sha": "2643ed261f944ce36d39f809d829ccc5b83e2c0c", "filename": "src/test/run-fail/borrowck-wg-fail-3.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-3.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,13 +0,0 @@\n-// error-pattern:borrowed\n-\n-// Test that write guards trigger when there is a write to a directly\n-// frozen @mut box.\n-\n-#[feature(managed_boxes)];\n-\n-fn main() {\n-    let x = @mut 3;\n-    let _y: &mut int = x;\n-    let z = x;\n-    *z = 5;\n-}"}, {"sha": "4a5664d08b690c34f4b68565e2a0b888eab021ed", "filename": "src/test/run-fail/borrowck-wg-fail-object-arg.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-object-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-object-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-object-arg.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,24 +0,0 @@\n-#[feature(managed_boxes)];\n-\n-// error-pattern:borrowed\n-\n-trait Foo {\n-    fn foo(&self, @mut int);\n-}\n-\n-impl Foo for int {\n-    fn foo(&self, x: @mut int) {\n-        *x += *self;\n-    }\n-}\n-\n-fn it_takes_two(_f: &Foo, _g: &mut Foo) {\n-}\n-\n-fn main() {\n-    let x = @mut 3_i;\n-    let y = x as @mut Foo;\n-    let z = y;\n-\n-    it_takes_two(y, z);\n-}"}, {"sha": "9e32dbf64206e6040ac9cc104efa305c5bebdac5", "filename": "src/test/run-fail/borrowck-wg-fail-object.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-object.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,23 +0,0 @@\n-#[feature(managed_boxes)];\n-\n-// error-pattern:borrowed\n-\n-trait Foo {\n-    fn foo(&self, @mut int);\n-}\n-\n-impl Foo for int {\n-    fn foo(&self, x: @mut int) {\n-        *x += *self;\n-    }\n-}\n-\n-fn main() {\n-    let x = @mut 3_i;\n-    let y = x as @mut Foo;\n-\n-    // The call to `y.foo(...)` should freeze `y` (and thus also `x`,\n-    // since `x === y`). It is thus an error when `foo` tries to\n-    // mutate `x`.\n-    y.foo(x);\n-}"}, {"sha": "e1273381e93c7370eebed0e806dde5d74daedc8f", "filename": "src/test/run-fail/borrowck-wg-fail.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,15 +0,0 @@\n-#[feature(managed_boxes)];\n-\n-// error-pattern:borrowed\n-\n-// Test that write guards trigger when mut box is frozen\n-// as part of argument coercion.\n-\n-fn f(_x: &int, y: @mut int) {\n-    *y = 2;\n-}\n-\n-fn main() {\n-    let x = @mut 3;\n-    f(x, x);\n-}"}, {"sha": "c41b9b37bb582c6a4c0eed908555338afd8dad7a", "filename": "src/test/run-fail/borrowck-wg-imm-then-mut.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-imm-then-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-imm-then-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-imm-then-mut.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,21 +0,0 @@\n-#[feature(managed_boxes)];\n-\n-// error-pattern:borrowed\n-\n-// Test that if you imm borrow then mut borrow it fails.\n-\n-fn add1(a:@mut int)\n-{\n-    add2(a); // already frozen\n-}\n-\n-fn add2(_:&mut int)\n-{\n-}\n-\n-pub fn main()\n-{\n-    let a = @mut 3;\n-    let _b = &*a; // freezes a\n-    add1(a);\n-}"}, {"sha": "aceadb0459c823439cad5de42331aa811b2ec97d", "filename": "src/test/run-fail/borrowck-wg-mut-then-imm.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-mut-then-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-mut-then-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-mut-then-imm.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,21 +0,0 @@\n-#[feature(managed_boxes)];\n-\n-// error-pattern:borrowed\n-\n-// Test that if you mut borrow then imm borrow it fails.\n-\n-fn add1(a:@mut int)\n-{\n-    add2(a); // already frozen\n-}\n-\n-fn add2(_:&int)\n-{\n-}\n-\n-pub fn main()\n-{\n-    let a = @mut 3;\n-    let _b = &mut *a; // freezes a\n-    add1(a);\n-}"}, {"sha": "d33e39e09a852f67c0fc89acec3df7b1a003f2c8", "filename": "src/test/run-fail/borrowck-wg-one-mut-one-imm-slice-method.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slice-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slice-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slice-method.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,39 +0,0 @@\n-// error-pattern:borrowed\n-\n-// Test that write guards trigger when there is a coercion to\n-// a slice on the receiver of a method.\n-\n-#[feature(managed_boxes)];\n-\n-trait MyMutSlice {\n-    fn my_mut_slice(self) -> Self;\n-}\n-\n-impl<'a, T> MyMutSlice for &'a mut [T] {\n-    fn my_mut_slice(self) -> &'a mut [T] {\n-        self\n-    }\n-}\n-\n-trait MySlice {\n-    fn my_slice(self) -> Self;\n-}\n-\n-impl<'a, T> MySlice for &'a [T] {\n-    fn my_slice(self) -> &'a [T] {\n-        self\n-    }\n-}\n-\n-fn add(x:&mut [int], y:&[int])\n-{\n-    x[0] = x[0] + y[0];\n-}\n-\n-pub fn main()\n-{\n-    let z = @mut [1,2,3];\n-    let z2 = z;\n-    add(z.my_mut_slice(), z2.my_slice());\n-    println!(\"{}\", z[0]);\n-}"}, {"sha": "63287981bdcc89fde16502cbb7678b6905435050", "filename": "src/test/run-fail/borrowck-wg-one-mut-one-imm-slices.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slices.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,18 +0,0 @@\n-// error-pattern:borrowed\n-\n-// Test that write guards trigger when arguments are coerced to slices.\n-\n-#[feature(managed_boxes)];\n-\n-fn add(x:&mut [int], y:&[int])\n-{\n-    x[0] = x[0] + y[0];\n-}\n-\n-pub fn main()\n-{\n-    let z = @mut [1,2,3];\n-    let z2 = z;\n-    add(z, z2);\n-    println!(\"{}\", z[0]);\n-}"}, {"sha": "0820b94e181c4fc1890a25579a09a9762fd585be", "filename": "src/test/run-fail/borrowck-wg-one-mut-one-imm.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,19 +0,0 @@\n-// error-pattern:borrowed\n-\n-// Test that write guards trigger when we are indexing into\n-// an @mut vector.\n-\n-#[feature(managed_boxes)];\n-\n-fn add(x:&mut int, y:&int)\n-{\n-    *x = *x + *y;\n-}\n-\n-pub fn main()\n-{\n-    let z = @mut [1,2,3];\n-    let z2 = z;\n-    add(&mut z[0], &z2[0]);\n-    println!(\"{}\", z[0]);\n-}"}, {"sha": "5ee9cd37e87b8fc74e41d1d9b364204ad5fb8751", "filename": "src/test/run-fail/borrowck-wg-two-array-indices.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-two-array-indices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-fail%2Fborrowck-wg-two-array-indices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-two-array-indices.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,19 +0,0 @@\n-// error-pattern:borrowed\n-\n-// Test that arguments trigger when there are *two mutable* borrows\n-// of indices.\n-\n-#[feature(managed_boxes)];\n-\n-fn add(x:&mut int, y:&mut int)\n-{\n-    *x = *x + *y;\n-}\n-\n-pub fn main()\n-{\n-    let z = @mut [1,2,3];\n-    let z2 = z;\n-    add(&mut z[0], &mut z2[0]);\n-    println!(\"{}\", z[0]);\n-}"}, {"sha": "09e7d0bc28c1fc2d99f00b71e9caef8d9fcedf93", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -14,7 +14,7 @@\n #[feature(managed_boxes)];\n \n fn main() {\n-    let _count = @mut 0u;\n+    let _count = @0u;\n     let mut map = std::hashmap::HashMap::new();\n     let mut arr = ~[];\n     for _i in range(0u, 10u) {"}, {"sha": "02ce1fd4b262a756ae3243f60c5fb2b24e71e9f1", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,19 +10,24 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::RefCell;\n+\n struct Pair<A,B> {\n     a: A, b: B\n }\n \n struct RecEnum<A>(Rec<A>);\n struct Rec<A> {\n     val: A,\n-    rec: Option<@mut RecEnum<A>>\n+    rec: Option<@RefCell<RecEnum<A>>>\n }\n \n fn make_cycle<A:'static>(a: A) {\n-    let g: @mut RecEnum<A> = @mut RecEnum(Rec {val: a, rec: None});\n-    g.rec = Some(g);\n+    let g: @RefCell<RecEnum<A>> = @RefCell::new(RecEnum(Rec {val: a, rec: None}));\n+    {\n+        let mut gb = g.borrow_mut();\n+        gb.get().rec = Some(g);\n+    }\n }\n \n struct Invoker<A,B> {"}, {"sha": "8058556a469fb8d2ff0351450e361d7b9d9067fa", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -35,8 +35,8 @@ fn test_ebml<'a, A:\n     Encodable<EBWriter::Encoder> +\n     Decodable<EBReader::Decoder<'a>>\n >(a1: &A) {\n-    let mut wr = @mut std::io::mem::MemWriter::new();\n-    let mut ebml_w = EBWriter::Encoder(wr);\n+    let mut wr = std::io::mem::MemWriter::new();\n+    let mut ebml_w = EBWriter::Encoder(&mut wr);\n     a1.encode(&mut ebml_w);\n     let bytes = wr.inner_ref().as_slice();\n "}, {"sha": "10b5825cdd6242031a0ab653709f500785db090a", "filename": "src/test/run-pass/borrowck-assign-to-subfield.rs", "status": "renamed", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fborrowck-assign-to-subfield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fborrowck-assign-to-subfield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-assign-to-subfield.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -8,23 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n-fn main() {\n+pub fn main() {\n     struct A {\n         a: int,\n         w: B,\n-        x: @B,\n-        z: @mut B\n     }\n     struct B {\n         a: int\n     }\n     let mut p = A {\n         a: 1,\n         w: B {a: 1},\n-        x: @B {a: 1},\n-        z: @mut B {a: 1}\n     };\n \n     // even though `x` is not declared as a mutable field,\n@@ -33,9 +27,4 @@ fn main() {\n \n     // this is true for an interior field too\n     p.w.a = 2;\n-\n-    // in these cases we pass through a box, so the mut\n-    // of the box is dominant\n-    p.x.a = 2;     //~ ERROR cannot assign to immutable field\n-    p.z.a = 2;\n }", "previous_filename": "src/test/compile-fail/borrowck-assign-to-subfield.rs"}, {"sha": "7402f0875086eb0699aa1c76e30c94ad912f4d27", "filename": "src/test/run-pass/borrowck-nested-calls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fborrowck-nested-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fborrowck-nested-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-nested-calls.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -24,7 +24,7 @@ impl Foo {\n     }\n }\n \n-fn main() {\n+pub fn main() {\n     let mut f = Foo {a: 22, b: 23};\n     f.inc_a(f.next_b());\n     assert_eq!(f.a, 22+23);"}, {"sha": "8871035908bbf2d3a57d7096bd7f54c43e6ea0fe", "filename": "src/test/run-pass/borrowck-preserve-box-in-arm-not-taken.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -12,15 +12,18 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::RefCell;\n+\n pub fn main() {\n-    let x: @mut @Option<~int> = @mut @None;\n-    match x {\n-      @@Some(ref _y) => {\n+    let x: @RefCell<@Option<~int>> = @RefCell::new(@None);\n+    let mut xb = x.borrow_mut();\n+    match *xb.get() {\n+      @Some(ref _y) => {\n         // here, the refcount of `*x` is bumped so\n         // `_y` remains valid even if `*x` is modified.\n-        *x = @None;\n+        *xb.get() = @None;\n       }\n-      @@None => {\n+      @None => {\n         // here, no bump of the ref count of `*x` is needed, but in\n         // fact a bump occurs anyway because of how pattern marching\n         // works."}, {"sha": "b333bcae5823add944d0739ccc1c920a0d2877a3", "filename": "src/test/run-pass/borrowck-preserve-box-in-pat.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -12,23 +12,25 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::RefCell;\n use std::ptr;\n \n struct F { f: ~int }\n \n pub fn main() {\n-    let x = @mut @F {f: ~3};\n-    match x {\n-      @@F{f: ref b_x} => {\n+    let x = @RefCell::new(@F {f: ~3});\n+    let mut xb = x.borrow_mut();\n+    match *xb.get() {\n+      @F{f: ref b_x} => {\n         assert_eq!(**b_x, 3);\n-        assert_eq!(ptr::to_unsafe_ptr(&(x.f)), ptr::to_unsafe_ptr(b_x));\n+        assert_eq!(ptr::to_unsafe_ptr(&(xb.get().f)), ptr::to_unsafe_ptr(b_x));\n \n-        *x = @F {f: ~4};\n+        *xb.get() = @F {f: ~4};\n \n         info!(\"ptr::to_unsafe_ptr(*b_x) = {:x}\",\n                ptr::to_unsafe_ptr(&(**b_x)) as uint);\n         assert_eq!(**b_x, 3);\n-        assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(**b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*xb.get().f)) != ptr::to_unsafe_ptr(&(**b_x)));\n       }\n     }\n }"}, {"sha": "9511d1b40e60ccef00a7b737e4579a98fece5b9e", "filename": "src/test/run-pass/borrowck-root-while-cond-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond-2.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -14,6 +14,6 @@ struct F { f: @G }\n struct G { g: ~[int] }\n \n pub fn main() {\n-    let rec = @mut F {f: @G {g: ~[1, 2, 3]}};\n+    let rec = @F {f: @G {g: ~[1, 2, 3]}};\n     while rec.f.g.len() == 23 {}\n }"}, {"sha": "a2d4991abc018f468a8fb090c345990966213ada", "filename": "src/test/run-pass/borrowck-root-while-cond.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -15,6 +15,6 @@ fn borrow<'r,T>(x: &'r T) -> &'r T {x}\n struct Rec { f: @int }\n \n pub fn main() {\n-    let rec = @mut Rec {f: @22};\n+    let rec = @Rec {f: @22};\n     while *borrow(rec.f) == 23 {}\n }"}, {"sha": "97d92f421c1488bf32236491dd9408f2f18738a1", "filename": "src/test/run-pass/borrowck-univariant-enum.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,6 +10,8 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::Cell;\n+\n enum newtype {\n     newtype(int)\n }\n@@ -19,12 +21,12 @@ pub fn main() {\n     // Test that borrowck treats enums with a single variant\n     // specially.\n \n-    let x = @mut 5;\n-    let y = @mut newtype(3);\n-    let z = match *y {\n+    let x = @Cell::new(5);\n+    let y = @Cell::new(newtype(3));\n+    let z = match y.get() {\n       newtype(b) => {\n-        *x += 1;\n-        *x * b\n+        x.set(x.get() + 1);\n+        x.get() * b\n       }\n     };\n     assert_eq!(z, 18);"}, {"sha": "27d337a28bf89dff623dc72d14331006945c45b7", "filename": "src/test/run-pass/borrowck-wg-autoderef-and-autoborrowvec-combined-issue-6272.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fborrowck-wg-autoderef-and-autoborrowvec-combined-issue-6272.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fborrowck-wg-autoderef-and-autoborrowvec-combined-issue-6272.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-autoderef-and-autoborrowvec-combined-issue-6272.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,42 +0,0 @@\n-// Issue #6272. Tests that freezing correctly accounts for all the\n-// implicit derefs that can occur.\n-//\n-// In this particular case, the expression:\n-//\n-//    let x: &mut [int] = c[0];\n-//\n-// is seen by borrowck as this sequence of derefs\n-// and pointer offsets:\n-//\n-//    &*((**c)[0])\n-//\n-// or, written using `x.*` for `*x` (so that everything\n-// is a postfix operation):\n-//\n-//    &c.*.*.[0].*\n-//       ^    ^\n-//       |    |\n-//       b    a\n-//\n-// Here I also indicated where the evaluation yields the boxes `a` and\n-// `b`. It is important then that we only freeze the innermost box\n-// (`a`), and not the other ones (`b`, `c`).\n-//\n-// Also see the companion test:\n-//\n-// run-fail/borrowck-wg-autoderef-and-autoborrowvec-combined-fail-issue-6272.rs\n-\n-#[feature(managed_boxes)];\n-\n-pub fn main() {\n-    let a = @mut 3i;\n-    let b = @mut [a];\n-    let c = @mut [3];\n-\n-    // this should freeze `a` only\n-    let _x: &mut int = a;\n-\n-    // hence these writes should not fail:\n-    b[0] = b[0];\n-    c[0] = c[0];\n-}"}, {"sha": "d721704ba55185a45c71d0489460ef8fdf8c2661", "filename": "src/test/run-pass/borrowck-wg-borrow-mut-to-imm-2.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-2.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,13 +0,0 @@\n-struct Cat;\n-\n-fn bar(_: &Cat) {\n-}\n-\n-fn foo(cat: &mut Cat) {\n-    bar(&*cat);\n-}\n-\n-pub fn main() {\n-    let mut mimi = ~Cat;\n-    foo(mimi);\n-}"}, {"sha": "dcf497e81f743deea5c3ec870aa34ff8af0e0381", "filename": "src/test/run-pass/borrowck-wg-borrow-mut-to-imm-3.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,18 +0,0 @@\n-struct Wizard {\n-    spells: ~[&'static str]\n-}\n-\n-impl Wizard {\n-    pub fn cast(&mut self) {\n-        for &spell in self.spells.iter() {\n-            println(spell);\n-        }\n-    }\n-}\n-\n-pub fn main() {\n-    let mut harry = Wizard {\n-        spells: ~[ \"expelliarmus\", \"expecto patronum\", \"incendio\" ]\n-    };\n-    harry.cast();\n-}"}, {"sha": "668f602b3d35c941770d07d920c29f7c04bdab7a", "filename": "src/test/run-pass/borrowck-wg-borrow-mut-to-imm.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,12 +0,0 @@\n-fn g(x: &Option<int>) {\n-    println(x.unwrap().to_str());\n-}\n-\n-fn f(x: &mut Option<int>) {\n-    g(&*x);\n-}\n-\n-pub fn main() {\n-    let mut x = ~Some(3);\n-    f(x);\n-}"}, {"sha": "f561dba2423274401ef1ccbcc6256b172d0ccb9b", "filename": "src/test/run-pass/borrowck-wg-simple.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fborrowck-wg-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fborrowck-wg-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-simple.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,10 +0,0 @@\n-#[feature(managed_boxes)];\n-\n-fn f(x: &int) {\n-    println(x.to_str());\n-}\n-\n-pub fn main() {\n-    let x = @mut 3;\n-    f(x);\n-}"}, {"sha": "efd0572c8c633b88a12ec286ef888549b8f8f401", "filename": "src/test/run-pass/borrowck-wg-two-imm-borrows.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fborrowck-wg-two-imm-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fborrowck-wg-two-imm-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-two-imm-borrows.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,16 +0,0 @@\n-// Test that we can borrow the same @mut box twice, so long as both are imm.\n-\n-#[feature(managed_boxes)];\n-\n-fn add(x:&int, y:&int)\n-{\n-    *x + *y;\n-}\n-\n-pub fn main()\n-{\n-    let z = @mut [1,2,3];\n-    let z2 = z;\n-    add(&z[0], &z2[0]);\n-    println!(\"{}\", z[0]);\n-}"}, {"sha": "54c4e0dce8b9809868c5b70d07639810c5c0ea1e", "filename": "src/test/run-pass/builtin-superkinds-capabilities-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -28,7 +28,7 @@ fn foo<T: RequiresRequiresFreezeAndSend>(val: T, chan: Chan<T>) {\n     chan.send(val);\n }\n \n-fn main() {\n+pub fn main() {\n     let (p,c) = Chan::new();\n     foo(X(31337), c);\n     assert!(p.recv() == X(31337));"}, {"sha": "55edc1351902420a7a74203b9f89db9dfac06b57", "filename": "src/test/run-pass/builtin-superkinds-in-metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-in-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-in-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-in-metadata.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -26,4 +26,4 @@ impl <T:Freeze+Send> RequiresRequiresFreezeAndSend for X<T> { }\n \n impl <T:Pod> RequiresPod for X<T> { }\n \n-fn main() { }\n+pub fn main() { }"}, {"sha": "09d10502b846b82215f05f6e829654dd11972f9d", "filename": "src/test/run-pass/cast-mutable-trait.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fcast-mutable-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fcast-mutable-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast-mutable-trait.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-trait T {\n-    fn foo(@mut self);\n-}\n-\n-struct S {\n-    unused: int\n-}\n-\n-impl T for S {\n-    fn foo(@mut self) {\n-    }\n-}\n-\n-fn bar(t: @mut T) {\n-    t.foo();\n-}\n-\n-pub fn main() {\n-    let s = @mut S { unused: 0 };\n-    let s2 = s as @mut T;\n-    s2.foo();\n-    bar(s2);\n-    bar(s as @mut T);\n-}"}, {"sha": "49e36ca5c63cdba6f28060a38121f5847d6ad9ac", "filename": "src/test/run-pass/cfg-macros-foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fcfg-macros-foo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fcfg-macros-foo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcfg-macros-foo.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -32,6 +32,6 @@ mod foo {\n     }\n }\n \n-fn main() {\n+pub fn main() {\n     assert!(bar!())\n }"}, {"sha": "88244135ff73b9e2f7c29e7af4996f3b68df0a5f", "filename": "src/test/run-pass/cfg-macros-notfoo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fcfg-macros-notfoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fcfg-macros-notfoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcfg-macros-notfoo.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -32,6 +32,6 @@ mod foo {\n     }\n }\n \n-fn main() {\n+pub fn main() {\n     assert!(!bar!())\n }"}, {"sha": "58f094c5987b57369d69752cac202585af22385e", "filename": "src/test/run-pass/cfg_inner_static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fcfg_inner_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fcfg_inner_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcfg_inner_static.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,6 +13,6 @@\n \n extern mod cfg_inner_static;\n \n-fn main() {\n+pub fn main() {\n     cfg_inner_static::foo();\n }"}, {"sha": "496770bc325278bd6b31a2e5f7ecd42b2f0f86a5", "filename": "src/test/run-pass/cfgs-on-items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fcfgs-on-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fcfgs-on-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcfgs-on-items.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -25,7 +25,7 @@ fn foo2() -> int { 2 }\n fn foo2() -> int { 3 }\n \n \n-fn main() {\n+pub fn main() {\n     assert_eq!(1, foo1());\n     assert_eq!(3, foo2());\n }"}, {"sha": "8c14276894475f94ebe50a4a349cdd482d173b9b", "filename": "src/test/run-pass/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 42, "deletions": 36, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -11,86 +11,92 @@\n #[feature(managed_boxes)];\n \n trait noisy {\n-  fn speak(&self) -> int;\n+  fn speak(&mut self) -> int;\n }\n \n struct dog {\n-  priv barks : @mut uint,\n+  priv barks: uint,\n \n-  volume : @mut int,\n+  volume: int,\n }\n \n impl dog {\n-    fn bark(&self) -> int {\n-      info!(\"Woof {} {}\", *self.barks, *self.volume);\n-      *self.barks += 1u;\n-      if *self.barks % 3u == 0u {\n-          *self.volume += 1;\n+    fn bark(&mut self) -> int {\n+      info!(\"Woof {} {}\", self.barks, self.volume);\n+      self.barks += 1u;\n+      if self.barks % 3u == 0u {\n+          self.volume += 1;\n       }\n-      if *self.barks % 10u == 0u {\n-          *self.volume -= 2;\n+      if self.barks % 10u == 0u {\n+          self.volume -= 2;\n       }\n-      info!(\"Grrr {} {}\", *self.barks, *self.volume);\n-      *self.volume\n+      info!(\"Grrr {} {}\", self.barks, self.volume);\n+      self.volume\n     }\n }\n \n impl noisy for dog {\n-  fn speak(&self) -> int { self.bark() }\n+    fn speak(&mut self) -> int {\n+        self.bark()\n+    }\n }\n \n fn dog() -> dog {\n     dog {\n-        volume: @mut 0,\n-        barks: @mut 0u\n+        volume: 0,\n+        barks: 0u\n     }\n }\n \n #[deriving(Clone)]\n struct cat {\n-  priv meows : @mut uint,\n+  priv meows: uint,\n \n-  how_hungry : @mut int,\n-  name : ~str,\n+  how_hungry: int,\n+  name: ~str,\n }\n \n impl noisy for cat {\n-  fn speak(&self) -> int { self.meow() as int }\n+    fn speak(&mut self) -> int {\n+        self.meow() as int\n+    }\n }\n \n impl cat {\n-  pub fn meow_count(&self) -> uint { *self.meows }\n+    pub fn meow_count(&self) -> uint {\n+        self.meows\n+    }\n }\n \n impl cat {\n-    fn meow(&self) -> uint {\n-      info!(\"Meow\");\n-      *self.meows += 1u;\n-      if *self.meows % 5u == 0u {\n-          *self.how_hungry += 1;\n-      }\n-      *self.meows\n+    fn meow(&mut self) -> uint {\n+        info!(\"Meow\");\n+        self.meows += 1u;\n+        if self.meows % 5u == 0u {\n+            self.how_hungry += 1;\n+        }\n+        self.meows\n     }\n }\n \n-fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n+fn cat(in_x: uint, in_y: int, in_name: ~str) -> cat {\n     cat {\n-        meows: @mut in_x,\n-        how_hungry: @mut in_y,\n+        meows: in_x,\n+        how_hungry: in_y,\n         name: in_name\n     }\n }\n \n \n-fn annoy_neighbors(critter: @noisy) {\n+fn annoy_neighbors(critter: &mut noisy) {\n     for _i in range(0u, 10) { critter.speak(); }\n }\n \n pub fn main() {\n-  let nyan : cat  = cat(0u, 2, ~\"nyan\");\n-  let whitefang : dog = dog();\n-  annoy_neighbors(@nyan.clone() as @noisy);\n-  annoy_neighbors(@whitefang as @noisy);\n+  let mut nyan: cat = cat(0u, 2, ~\"nyan\");\n+  let mut whitefang: dog = dog();\n+  annoy_neighbors(&mut nyan);\n+  annoy_neighbors(&mut whitefang);\n   assert_eq!(nyan.meow_count(), 10u);\n-  assert_eq!(*whitefang.volume, 1);\n+  assert_eq!(whitefang.volume, 1);\n }"}, {"sha": "86764df6ae07a2fc9e4410213b1fdda092c791a2", "filename": "src/test/run-pass/class-cast-to-trait.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -58,6 +58,7 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n \n \n pub fn main() {\n-  let nyan: @mut noisy = @mut cat(0u, 2, ~\"nyan\") as @mut noisy;\n-  nyan.speak();\n+    let mut nyan = cat(0u, 2, ~\"nyan\");\n+    let mut nyan: &mut noisy = &mut nyan;\n+    nyan.speak();\n }"}, {"sha": "54626f9ffffc9e0c00a7130613935eea350aa1b9", "filename": "src/test/run-pass/conditional-debug-macro-off.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-off.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-off.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-off.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -12,7 +12,7 @@\n // compile-flags: --cfg ndebug\n // exec-env:RUST_LOG=conditional-debug-macro-off=4\n \n-fn main() {\n+pub fn main() {\n     // only fails if debug! evaluates its argument.\n     debug!(\"{:?}\", { if true { fail!() } });\n }"}, {"sha": "0599d199dc09a40e4341c76e235aa97f301f567a", "filename": "src/test/run-pass/conditional-debug-macro-on.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-on.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-on.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-on.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast compile-flags directive doesn't work for check-fast\n // exec-env:RUST_LOG=conditional-debug-macro-on=4\n \n-fn main() {\n+pub fn main() {\n     // exits early if debug! evaluates its arguments, otherwise it\n     // will hit the fail.\n     debug!(\"{:?}\", { if true { return; } });"}, {"sha": "9d85689d4ad6144c8191c00cb3ee5184538d0fc7", "filename": "src/test/run-pass/const-cross-crate-const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fconst-cross-crate-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fconst-cross-crate-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cross-crate-const.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -16,7 +16,7 @@ static foo: &'static str = cci_const::foopy;\n static a: uint = cci_const::uint_val;\n static b: uint = cci_const::uint_expr + 5;\n \n-fn main() {\n+pub fn main() {\n     assert_eq!(a, 12);\n     let foo2 = a;\n     assert_eq!(foo2, cci_const::uint_val);"}, {"sha": "f6516d2b82615243fde24390cf293b73896ab84b", "filename": "src/test/run-pass/cross-crate-const-pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fcross-crate-const-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fcross-crate-const-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcross-crate-const-pat.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,7 +13,7 @@\n \n extern mod cci_const;\n \n-fn main() {\n+pub fn main() {\n     let x = cci_const::uint_val;\n     match x {\n         cci_const::uint_val => {}"}, {"sha": "db767151bd492c754cc49cb6a2127b84b83b55a3", "filename": "src/test/run-pass/cross-crate-newtype-struct-pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fcross-crate-newtype-struct-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fcross-crate-newtype-struct-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcross-crate-newtype-struct-pat.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,7 +13,7 @@\n \n extern mod newtype_struct_xc;\n \n-fn main() {\n+pub fn main() {\n     let x = newtype_struct_xc::Au(21);\n     match x {\n         newtype_struct_xc::Au(n) => assert_eq!(n, 21)"}, {"sha": "ca1e18eb87b97e1bf0999804da71876e19ef463b", "filename": "src/test/run-pass/cycle-collection.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fcycle-collection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fcycle-collection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-collection.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,14 +10,16 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::RefCell;\n+\n enum taggy {\n-    cons(@mut taggy),\n+    cons(@RefCell<taggy>),\n     nil,\n }\n \n fn f() {\n-    let a_box = @mut nil;\n-    *a_box = cons(a_box);\n+    let a_box = @RefCell::new(nil);\n+    a_box.set(cons(a_box));\n }\n \n pub fn main() {"}, {"sha": "f10592bf80097b7a92c27f9bde40ff750e4d73a8", "filename": "src/test/run-pass/cycle-collection2.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fcycle-collection2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fcycle-collection2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-collection2.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-struct foo {\n-    z: Option<@Invokable>,\n-}\n-\n-struct Thing {\n-    w: @mut foo,\n-}\n-\n-trait Invokable {\n-    fn f(&self);\n-}\n-\n-impl Invokable for Thing {\n-    fn f(&self) {\n-        nop_foo(self.w);\n-    }\n-}\n-\n-fn nop() { }\n-fn nop_foo(_x : @mut foo) { }\n-\n-pub fn main() {\n-    let w = @mut foo {\n-        z: None,\n-    };\n-    let x = @Thing {\n-        w: w,\n-    } as @Invokable;\n-    w.z = Some(x);\n-}"}, {"sha": "914805c126f376fe442fddcdf519f0c95861eb54", "filename": "src/test/run-pass/deref-lval.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fderef-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fderef-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderef-lval.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,4 +10,10 @@\n \n #[feature(managed_boxes)];\n \n-pub fn main() { let x = @mut 5; *x = 1000; info!(\"{:?}\", *x); }\n+use std::cell::Cell;\n+\n+pub fn main() {\n+    let x = @Cell::new(5);\n+    x.set(1000);\n+    info!(\"{:?}\", x.get());\n+}"}, {"sha": "9194304a376b1c1033c12787f50727cdc8f32ca5", "filename": "src/test/run-pass/deriving-encodable-decodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -58,8 +58,8 @@ struct G<T> {\n fn roundtrip<'a, T: Rand + Eq + Encodable<Encoder> +\n                     Decodable<Decoder<'a>>>() {\n     let obj: T = random();\n-    let w = @mut MemWriter::new();\n-    let mut e = Encoder(w);\n+    let mut w = MemWriter::new();\n+    let mut e = Encoder(&mut w);\n     obj.encode(&mut e);\n     let doc = ebml::reader::Doc(@w.inner_ref().to_owned());\n     let mut dec = Decoder(doc);"}, {"sha": "ce51e2dcd7059b03e14496051d7f2c710b028366", "filename": "src/test/run-pass/deriving-global.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-global.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -39,4 +39,4 @@ mod submod {\n \n }\n \n-fn main() {}\n+pub fn main() {}"}, {"sha": "58ef613b7cd9ab9ec6121f91f919c8fb78df2052", "filename": "src/test/run-pass/deriving-rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fderiving-rand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fderiving-rand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-rand.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -32,7 +32,7 @@ enum D {\n     D2 { x: (), y: () }\n }\n \n-fn main() {\n+pub fn main() {\n     // check there's no segfaults\n     20.times(|| {\n         rand::random::<A>();"}, {"sha": "d28e54d57ad4ceafef8740425d74d1f3d6698d4c", "filename": "src/test/run-pass/deriving-zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-zero.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -30,7 +30,7 @@ struct Lots {\n     e: char,\n     f: f64,\n     g: (f32, char),\n-    h: @mut (int, int),\n+    h: @(int, int),\n     i: bool,\n     j: (),\n }"}, {"sha": "c3c22cb26d27ab074fcd5fd7e6f6afe171238fa1", "filename": "src/test/run-pass/dupe-first-attr.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fdupe-first-attr.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fdupe-first-attr.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdupe-first-attr.rc?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -26,4 +26,4 @@ mod hello;\n #[cfg(target_os = \"android\")]\n mod hello;\n \n-fn main() { }\n\\ No newline at end of file\n+pub fn main() { }"}, {"sha": "c7e5681c0c1db98a5bbf74084b2812fefa923dd0", "filename": "src/test/run-pass/explicit-self-closures.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -18,9 +18,6 @@ impl Box {\n     pub fn set_many(&mut self, xs: &[uint]) {\n         for x in xs.iter() { self.x = *x; }\n     }\n-    pub fn set_many2(@mut self, xs: &[uint]) {\n-        for x in xs.iter() { self.x = *x; }\n-    }\n }\n \n pub fn main() {}"}, {"sha": "e1be481099c1888422778071f739bc60c827dd8c", "filename": "src/test/run-pass/expr-repeat-vstore.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,10 +13,4 @@ pub fn main() {\n     println(v[2].to_str());\n     println(v[3].to_str());\n     println(v[4].to_str());\n-    let v: @mut [int] = @mut [ 3, ..5 ];\n-    println((v[0]).to_str());\n-    println((v[1]).to_str());\n-    println((v[2]).to_str());\n-    println((v[3]).to_str());\n-    println((v[4]).to_str());\n }"}, {"sha": "d9505e01de95b43a64c404ebf597eec38e4c26db", "filename": "src/test/run-pass/exterior.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fexterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fexterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexterior.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,15 +10,21 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::Cell;\n+\n struct Point {x: int, y: int, z: int}\n \n-fn f(p: @mut Point) { assert!((p.z == 12)); p.z = 13; assert!((p.z == 13)); }\n+fn f(p: @Cell<Point>) {\n+    assert!((p.get().z == 12));\n+    p.set(Point {x: 10, y: 11, z: 13});\n+    assert!((p.get().z == 13));\n+}\n \n pub fn main() {\n     let a: Point = Point {x: 10, y: 11, z: 12};\n-    let b: @mut Point = @mut a;\n-    assert_eq!(b.z, 12);\n+    let b: @Cell<Point> = @Cell::new(a);\n+    assert_eq!(b.get().z, 12);\n     f(b);\n     assert_eq!(a.z, 12);\n-    assert_eq!(b.z, 13);\n+    assert_eq!(b.get().z, 13);\n }"}, {"sha": "5a5ed2e02c126d841ec009f9566695e4deadf224", "filename": "src/test/run-pass/extern-calling-convention-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fextern-calling-convention-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fextern-calling-convention-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-calling-convention-test.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -15,6 +15,6 @@ extern mod extern_calling_convention;\n \n use extern_calling_convention::foo;\n \n-fn main() {\n+pub fn main() {\n     foo(1, 2, 3, 4);\n }"}, {"sha": "c1af0c2b3735bfc6a1d70cdf10a71122f621fc18", "filename": "src/test/run-pass/extern-fn-reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fextern-fn-reachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fextern-fn-reachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-fn-reachable.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -27,7 +27,7 @@ pub mod bar {\n \n #[no_mangle] pub fn fun5() {}\n \n-fn main() {\n+pub fn main() {\n     unsafe {\n         let a = DynamicLibrary::open(None).unwrap();\n         assert!(a.symbol::<int>(\"fun1\").is_ok());"}, {"sha": "17731d9ec9402d55813930385c8eb8baafb6ab36", "filename": "src/test/run-pass/extern-mod-ordering-exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fextern-mod-ordering-exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fextern-mod-ordering-exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-mod-ordering-exe.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -5,6 +5,6 @@ extern mod extern_mod_ordering_lib;\n \n use extern_mod_ordering_lib::extern_mod_ordering_lib;\n \n-fn main() {\n+pub fn main() {\n     extern_mod_ordering_lib::f();\n }"}, {"sha": "905fa42635b9be59ff0e879c68d3192ff2dc5735", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -40,7 +40,7 @@ mod map_reduce {\n     }\n \n     fn map_task(ctrl: SharedChan<ctrl_proto>, input: ~str) {\n-        let intermediates = @mut HashMap::new();\n+        let mut intermediates = HashMap::new();\n \n         fn emit(im: &mut HashMap<~str, int>,\n                 ctrl: SharedChan<ctrl_proto>, key: ~str,\n@@ -58,7 +58,7 @@ mod map_reduce {\n         }\n \n         let ctrl_clone = ctrl.clone();\n-        ::map(input, |a,b| emit(intermediates, ctrl.clone(), a, b) );\n+        ::map(input, |a,b| emit(&mut intermediates, ctrl.clone(), a, b) );\n         ctrl_clone.send(mapper_done);\n     }\n "}, {"sha": "ede67275ba9d79277658e42188eb028e4697b9b6", "filename": "src/test/run-pass/init-res-into-things.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Finit-res-into-things.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Finit-res-into-things.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finit-res-into-things.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,80 +10,82 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::Cell;\n+\n // Resources can't be copied, but storing into data structures counts\n // as a move unless the stored thing is used afterwards.\n \n struct r {\n-  i: @mut int,\n+    i: @Cell<int>,\n }\n \n struct Box { x: r }\n \n #[unsafe_destructor]\n impl Drop for r {\n     fn drop(&mut self) {\n-        *(self.i) = *(self.i) + 1;\n+        self.i.set(self.i.get() + 1)\n     }\n }\n \n-fn r(i: @mut int) -> r {\n+fn r(i: @Cell<int>) -> r {\n     r {\n         i: i\n     }\n }\n \n fn test_box() {\n-    let i = @mut 0;\n+    let i = @Cell::new(0);\n     {\n         let _a = @r(i);\n     }\n-    assert_eq!(*i, 1);\n+    assert_eq!(i.get(), 1);\n }\n \n fn test_rec() {\n-    let i = @mut 0;\n+    let i = @Cell::new(0);\n     {\n         let _a = Box {x: r(i)};\n     }\n-    assert_eq!(*i, 1);\n+    assert_eq!(i.get(), 1);\n }\n \n fn test_tag() {\n     enum t {\n         t0(r),\n     }\n \n-    let i = @mut 0;\n+    let i = @Cell::new(0);\n     {\n         let _a = t0(r(i));\n     }\n-    assert_eq!(*i, 1);\n+    assert_eq!(i.get(), 1);\n }\n \n fn test_tup() {\n-    let i = @mut 0;\n+    let i = @Cell::new(0);\n     {\n         let _a = (r(i), 0);\n     }\n-    assert_eq!(*i, 1);\n+    assert_eq!(i.get(), 1);\n }\n \n fn test_unique() {\n-    let i = @mut 0;\n+    let i = @Cell::new(0);\n     {\n         let _a = ~r(i);\n     }\n-    assert_eq!(*i, 1);\n+    assert_eq!(i.get(), 1);\n }\n \n fn test_box_rec() {\n-    let i = @mut 0;\n+    let i = @Cell::new(0);\n     {\n         let _a = @Box {\n             x: r(i)\n         };\n     }\n-    assert_eq!(*i, 1);\n+    assert_eq!(i.get(), 1);\n }\n \n pub fn main() {"}, {"sha": "020db44bb87a612dca305faead033cae95c67068", "filename": "src/test/run-pass/issue-10626.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10626.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -16,7 +16,7 @@\n use std::os;\n use std::io::process;\n \n-fn main () {\n+pub fn main () {\n     let args = os::args();\n     if args.len() > 1 && args[1] == ~\"child\" {\n         for _ in range(0, 1000) {"}, {"sha": "046b2884a0e9cafd63befbbb478500db29294d04", "filename": "src/test/run-pass/issue-10806.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-10806.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-10806.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10806.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -38,7 +38,7 @@ pub mod waldo {\n     }\n }\n \n-fn main() {\n+pub fn main() {\n     let _x = baz::quux();\n     let _y = grault::garply();\n     let _z = waldo::plugh();"}, {"sha": "c0686d91fb90661b4390a87855709ff539de611e", "filename": "src/test/run-pass/issue-11085.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-11085.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-11085.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11085.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -43,7 +43,7 @@ enum Bar3 {\n     }\n }\n \n-fn main() {\n+pub fn main() {\n     let _f = Foo { foo: 3 };\n     let _f = Foo2 { foo: 3 };\n "}, {"sha": "da92428f25805149960227186727276f37ba52af", "filename": "src/test/run-pass/issue-11224.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-11224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-11224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11224.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,4 +13,4 @@\n \n extern mod unused = \"issue-11224\";\n \n-fn main() {}\n+pub fn main() {}"}, {"sha": "d8724b5ba8d907790cc32ceaa760c0c821ff2e02", "filename": "src/test/run-pass/issue-11225-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-11225-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-11225-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11225-1.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,6 +13,6 @@\n \n extern mod foo = \"issue-11225-1\";\n \n-fn main() {\n+pub fn main() {\n     foo::foo(1);\n }"}, {"sha": "86e4232880cfbe22796c080ab9240cc5a73deaac", "filename": "src/test/run-pass/issue-11225-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-11225-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-11225-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11225-2.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,6 +13,6 @@\n \n extern mod foo = \"issue-11225-2\";\n \n-fn main() {\n+pub fn main() {\n     foo::foo(1);\n }"}, {"sha": "dc46bef4ed46cfca8d17de1487d11c425e4eade7", "filename": "src/test/run-pass/issue-2631-b.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -16,11 +16,12 @@\n extern mod req;\n \n use req::request;\n+use std::cell::RefCell;\n use std::hashmap::HashMap;\n \n pub fn main() {\n   let v = ~[@~\"hi\"];\n   let mut m: req::header_map = HashMap::new();\n-  m.insert(~\"METHOD\", @mut v);\n+  m.insert(~\"METHOD\", @RefCell::new(v));\n   request::<int>(&m);\n }"}, {"sha": "44222315dcd0931c21698357615f7484819002c5", "filename": "src/test/run-pass/issue-2735-2.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-2735-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-2735-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2735-2.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,26 +10,28 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::Cell;\n+\n // This test should behave exactly like issue-2735-3\n struct defer {\n-    b: @mut bool,\n+    b: @Cell<bool>,\n }\n \n #[unsafe_destructor]\n impl Drop for defer {\n     fn drop(&mut self) {\n-        *self.b = true;\n+        self.b.set(true);\n     }\n }\n \n-fn defer(b: @mut bool) -> defer {\n+fn defer(b: @Cell<bool>) -> defer {\n     defer {\n         b: b\n     }\n }\n \n pub fn main() {\n-    let dtor_ran = @mut false;\n+    let dtor_ran = @Cell::new(false);\n     let _  = defer(dtor_ran);\n-    assert!(*dtor_ran);\n+    assert!(dtor_ran.get());\n }"}, {"sha": "f48e763966b1ac90f866f0a5198fef5374e68290", "filename": "src/test/run-pass/issue-2735-3.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-2735-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-2735-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2735-3.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,26 +10,28 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::Cell;\n+\n // This test should behave exactly like issue-2735-2\n struct defer {\n-    b: @mut bool,\n+    b: @Cell<bool>,\n }\n \n #[unsafe_destructor]\n impl Drop for defer {\n     fn drop(&mut self) {\n-        *self.b = true;\n+        self.b.set(true);\n     }\n }\n \n-fn defer(b: @mut bool) -> defer {\n+fn defer(b: @Cell<bool>) -> defer {\n     defer {\n         b: b\n     }\n }\n \n pub fn main() {\n-    let dtor_ran = @mut false;\n+    let dtor_ran = @Cell::new(false);\n     defer(dtor_ran);\n-    assert!(*dtor_ran);\n+    assert!(dtor_ran.get());\n }"}, {"sha": "dc2f59f14816c79b4c71036c70f9ea96894f8e52", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -62,8 +62,8 @@ fn square_from_char(c: char) -> square {\n     }\n }\n \n-fn read_board_grid<rdr:'static + io::Reader>(input: rdr) -> ~[~[square]] {\n-    let input = @mut input as @mut io::Reader;\n+fn read_board_grid<rdr:'static + io::Reader>(mut input: rdr) -> ~[~[square]] {\n+    let mut input: &mut io::Reader = &mut input;\n     let mut grid = ~[];\n     let mut line = [0, ..10];\n     input.read(line);"}, {"sha": "c6b48ad636f11f5c26455c8b4e6d4d7a6fec8842", "filename": "src/test/run-pass/issue-3290.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-3290.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-3290.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3290.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // xfail-test FIXME #3290\n-fn main() {\n+pub fn main() {\n    let mut x = ~3;\n    x = x;\n    assert_eq!(*x, 3);"}, {"sha": "3d56abb3de686fbeafc601fce14b49bc33f15f3f", "filename": "src/test/run-pass/issue-3447.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-3447.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-3447.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3447.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,11 +10,13 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::RefCell;\n+\n static S: &'static str = \"str\";\n \n struct list<T> {\n     element: T,\n-    next: Option<@mut list<T>>\n+    next: Option<@RefCell<list<T>>>\n }\n \n impl<T:'static> list<T> {\n@@ -24,7 +26,7 @@ impl<T:'static> list<T> {\n             next: None\n         };\n \n-        self.next = Some(@mut newList);\n+        self.next = Some(@RefCell::new(newList));\n     }\n }\n "}, {"sha": "df8820c5623a285f0f75dc3290e1cb0050acd310", "filename": "src/test/run-pass/issue-3796.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-3796.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-3796.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3796.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-test FIXME #3796\n #[deny(dead_assignment)];\n-fn main() {\n+pub fn main() {\n     let mut x = 1;\n     let f: || -> int = || { x + 20 };\n     assert_eq!(f(), 21);"}, {"sha": "8a30cc9674860750762b0a210cc7c2a494a2b244", "filename": "src/test/run-pass/issue-3860.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fissue-3860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fissue-3860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3860.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-struct Foo { x: int }\n-\n-impl Foo {\n-    pub fn stuff<'a>(&'a mut self) -> &'a mut Foo {\n-        return self;\n-    }\n-}\n-\n-pub fn main() {\n-    let x = @mut Foo { x: 3 };\n-    // Neither of the next two lines should cause an error\n-    let _ = x.stuff();\n-    x.stuff();\n-}"}, {"sha": "4a4c263f938f09b5bf88dd9715f004636108fad7", "filename": "src/test/run-pass/issue-4208.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-4208.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-4208.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4208.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -16,4 +16,4 @@ use numeric::{sin, Angle};\n \n fn foo<T, A:Angle<T>>(theta: A) -> T { sin(&theta) }\n \n-fn main() {}\n+pub fn main() {}"}, {"sha": "7a09741acb18059e97863220dc0abe9664de2fb7", "filename": "src/test/run-pass/issue-4241.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4241.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -127,5 +127,5 @@ fn query2(cmd: ~[~str]) -> Result {\n }\n \n \n-fn main() {\n+pub fn main() {\n }"}, {"sha": "9fd1a1c81ebc749975616925285221d6c34c51d2", "filename": "src/test/run-pass/issue-4252.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-4252.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-4252.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4252.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -31,7 +31,7 @@ impl<T: X> Drop for Z<T> {\n     }\n }\n \n-fn main() {\n+pub fn main() {\n     let y = Y;\n     let _z = Z{x: y};\n }"}, {"sha": "6c018b5cd2fa0f489839cbe5cab7456537a334a2", "filename": "src/test/run-pass/issue-4545.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-4545.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-4545.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4545.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -12,4 +12,4 @@\n // aux-build:issue-4545.rs\n \n extern mod somelib = \"issue-4545\";\n-fn main() { somelib::mk::<int>(); }\n+pub fn main() { somelib::mk::<int>(); }"}, {"sha": "088376c1068b983fdc9edde36b3ef70333eadaa3", "filename": "src/test/run-pass/issue-5275.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fissue-5275.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fissue-5275.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5275.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-// Regression test for issue #5275\n-\n-fn foo(self_: &A) -> int {\n-    if true {\n-        fail!()\n-    } else {\n-        *bar(self_.bar)\n-    }\n-}\n-\n-fn bar<'r>(_: &'r mut int) -> &'r int {\n-    fail!()\n-}\n-\n-struct A {\n-    bar: @mut int,\n-}\n-\n-pub fn main() {}"}, {"sha": "a5c318a20f47d8c0e4cc1187e03cfcd454262db0", "filename": "src/test/run-pass/issue-5517.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fissue-5517.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fissue-5517.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5517.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-pub fn main() {\n-    let box1 = @mut 42;\n-    let _x = *(&mut *box1) == 42 || *(&mut *box1) == 31337;\n-}"}, {"sha": "9cef8b5685f42f11382590ba01a549c7a8918bd6", "filename": "src/test/run-pass/issue-5950.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-5950.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-5950.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5950.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -14,4 +14,4 @@ pub use local_alias = local;\n \n mod local { }\n \n-fn main() {}\n+pub fn main() {}"}, {"sha": "38934c6e7634dcd26abacd5f8cc32b3b0a83dabc", "filename": "src/test/run-pass/issue-6334.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-6334.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-6334.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6334.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -48,7 +48,7 @@ fn use_c<S:C, T:B+A>(s: &S, t: &T) -> uint {\n     s.combine(t)\n }\n \n-fn main() {\n+pub fn main() {\n     let foo = Foo;\n     let bar = Bar;\n     let r = use_c(&bar, &foo);"}, {"sha": "39afbd1c3ec55f54026d56991e1d734f73b0a086", "filename": "src/test/run-pass/issue-7178.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-7178.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-7178.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7178.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,6 +13,6 @@\n \n extern mod cross_crate_self = \"issue-7178\";\n \n-fn main() {\n+pub fn main() {\n     let _ = cross_crate_self::Foo::new(&1i);\n }"}, {"sha": "5ad355dbd4c528cb3788f29d0c7a8d834b5eced6", "filename": "src/test/run-pass/issue-8044.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-8044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-8044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8044.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -14,6 +14,6 @@\n extern mod minimal = \"issue-8044\";\n use minimal::{BTree, leaf};\n \n-fn main() {\n+pub fn main() {\n     BTree::<int> { node: leaf(1) };\n }"}, {"sha": "3533f336b428d1e65dce0b01b23d9909b583ab1f", "filename": "src/test/run-pass/issue-8259.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-8259.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-8259.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8259.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -14,4 +14,4 @@\n extern mod other = \"issue-8259\";\n static a: other::Foo<'static> = other::A;\n \n-fn main() {}\n+pub fn main() {}"}, {"sha": "fc7e24ccd7afc5e8e523c53e2bcc0bfe32d899f6", "filename": "src/test/run-pass/issue-8498.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-8498.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-8498.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8498.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-test\n \n-fn main() {\n+pub fn main() {\n // This is ok\n     match &[(~5,~7)] {\n         ps => {"}, {"sha": "d3455af4e2c744d54eea8d58993b60843a92e672", "filename": "src/test/run-pass/issue-9188.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-9188.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-9188.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9188.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,7 +13,7 @@\n \n extern mod issue_9188;\n \n-fn main() {\n+pub fn main() {\n     let a = issue_9188::bar();\n     let b = issue_9188::foo::<int>();\n     assert_eq!(*a, *b);"}, {"sha": "ca83e783268e833e37bc90abc035ee403a822c6f", "filename": "src/test/run-pass/issue-979.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-979.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-979.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-979.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,28 +10,30 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::Cell;\n+\n struct r {\n-  b: @mut int,\n+    b: @Cell<int>,\n }\n \n #[unsafe_destructor]\n impl Drop for r {\n     fn drop(&mut self) {\n-        *(self.b) += 1;\n+        self.b.set(self.b.get() + 1);\n     }\n }\n \n-fn r(b: @mut int) -> r {\n+fn r(b: @Cell<int>) -> r {\n     r {\n         b: b\n     }\n }\n \n pub fn main() {\n-    let b = @mut 0;\n+    let b = @Cell::new(0);\n     {\n         let _p = Some(r(b));\n     }\n \n-    assert_eq!(*b, 1);\n+    assert_eq!(b.get(), 1);\n }"}, {"sha": "f6dc4adcf9b5af86e3fe9f991ea429864ced7830", "filename": "src/test/run-pass/issue-980.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-980.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-980.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-980.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,16 +10,20 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::RefCell;\n+\n enum maybe_pointy {\n     no_pointy,\n-    yes_pointy(@mut Pointy),\n+    yes_pointy(@RefCell<Pointy>),\n }\n \n struct Pointy {\n-    x : maybe_pointy\n+    x: maybe_pointy\n }\n \n pub fn main() {\n-    let m = @mut Pointy { x : no_pointy };\n-    m.x = yes_pointy(m);\n+    let m = @RefCell::new(Pointy { x : no_pointy });\n+    m.set(Pointy {\n+        x: yes_pointy(m)\n+    });\n }"}, {"sha": "6a604058663e14494faa61d5170fcb9216a30ea4", "filename": "src/test/run-pass/issue-9906.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-9906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-9906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9906.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,7 +13,7 @@\n \n extern mod testmod = \"issue-9906\";\n \n-fn main() {\n+pub fn main() {\n     testmod::foo();\n     testmod::FooBar::new(1);\n }"}, {"sha": "f23729537eb03deab7cb432d8279613997a2aa6e", "filename": "src/test/run-pass/issue-9968.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-9968.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue-9968.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9968.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -15,7 +15,7 @@ extern mod lib = \"issue-9968\";\n \n use lib::{Trait, Struct};\n \n-fn main()\n+pub fn main()\n {\n     Struct::init().test();\n }"}, {"sha": "3fbdf57e3488fa2173ffe81e950fde03cf0379c1", "filename": "src/test/run-pass/issue_9155.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue_9155.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fissue_9155.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue_9155.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -15,6 +15,6 @@ extern mod issue_9155;\n \n struct Baz;\n \n-fn main() {\n+pub fn main() {\n     issue_9155::Foo::new(Baz);\n }"}, {"sha": "65f95f78ea86f6dbb89a7d22aadcb551077c5f64", "filename": "src/test/run-pass/lambda-infer-unresolved.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -11,12 +11,10 @@\n // This should typecheck even though the type of e is not fully\n // resolved when we finish typechecking the ||.\n \n-#[feature(managed_boxes)];\n-\n struct Refs { refs: ~[int], n: int }\n \n pub fn main() {\n-    let e = @mut Refs{refs: ~[], n: 0};\n+    let mut e = Refs{refs: ~[], n: 0};\n     let _f: || = || error!(\"{}\", e.n);\n     e.refs.push(1);\n }"}, {"sha": "bbfbdb1cdf0e8ffc7cff3b9c90b39e9280344162", "filename": "src/test/run-pass/linkage-visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -15,7 +15,7 @@\n \n extern mod foo = \"linkage-visibility\";\n \n-fn main() {\n+pub fn main() {\n     foo::test();\n     foo::foo2::<int>();\n     foo::foo();"}, {"sha": "e4dd3b56fca603a1989ee57973956bc25667e65d", "filename": "src/test/run-pass/log-linearized.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Flog-linearized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Flog-linearized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-linearized.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-// Tests that shapes respect linearize_ty_params().\n-\n-enum option<T> {\n-    none,\n-    some(T),\n-}\n-\n-struct Smallintmap<T> {v: ~[option<T>]}\n-\n-struct V<T> { v: ~[option<T>] }\n-\n-fn mk<T:'static>() -> @mut Smallintmap<T> {\n-    let v: ~[option<T>] = ~[];\n-    return @mut Smallintmap {v: v};\n-}\n-\n-fn f<T,U:'static>() {\n-    let sim = mk::<U>();\n-    error!(\"{:?}\", sim);\n-}\n-\n-pub fn main() {\n-    f::<int,int>();\n-}"}, {"sha": "98fe46357ba37727cd601a47259941256251cbf0", "filename": "src/test/run-pass/logging-enabled-debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Flogging-enabled-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Flogging-enabled-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-enabled-debug.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -14,7 +14,7 @@\n \n use std::logging;\n \n-fn main() {\n+pub fn main() {\n     if log_enabled!(logging::DEBUG) {\n         fail!(\"what?! debugging?\");\n     }"}, {"sha": "43f039569b2abe770dafc5689163b96a5987ed60", "filename": "src/test/run-pass/logging-enabled.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Flogging-enabled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Flogging-enabled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-enabled.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,7 +13,7 @@\n \n use std::logging;\n \n-fn main() {\n+pub fn main() {\n     if log_enabled!(logging::DEBUG) {\n         fail!(\"what?! debugging?\");\n     }"}, {"sha": "fb352ea07085b1b17f0a2520589560b060573ada", "filename": "src/test/run-pass/logging-only-prints-once.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -11,25 +11,24 @@\n // xfail-fast\n // exec-env:RUST_LOG=debug\n \n-#[feature(managed_boxes)];\n-\n+use std::cell::Cell;\n use std::fmt;\n \n-struct Foo(@mut int);\n+struct Foo(Cell<int>);\n \n impl fmt::Default for Foo {\n     fn fmt(f: &Foo, _fmt: &mut fmt::Formatter) {\n-        assert!(***f == 0);\n-        ***f = 1;\n+        assert!(f.get() == 0);\n+        f.set(1);\n     }\n }\n \n pub fn main() {\n     let (p,c) = Chan::new();\n     do spawn {\n-        let f = Foo(@mut 0);\n+        let mut f = Foo(Cell::new(0));\n         debug!(\"{}\", f);\n-        assert!(**f == 1);\n+        assert!(f.get() == 1);\n         c.send(());\n     }\n     p.recv();"}, {"sha": "3e6978a6fa73bc5a6817a116633bb1cf0c0e0825", "filename": "src/test/run-pass/logging-right-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Flogging-right-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Flogging-right-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-right-crate.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -24,7 +24,7 @@\n \n extern mod logging_right_crate;\n \n-fn main() {\n+pub fn main() {\n     // this function fails if logging is turned on\n     logging_right_crate::foo::<int>();\n }"}, {"sha": "7bbe7f72a2c4814a395acd116cbb6a7c2c03bbda", "filename": "src/test/run-pass/logging_before_rt_started.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Flogging_before_rt_started.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Flogging_before_rt_started.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging_before_rt_started.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -17,4 +17,4 @@\n // this test will trigger \"output during runtime initialization\" to make sure\n // that the bug isn't re-introduced.\n \n-fn main() {}\n+pub fn main() {}"}, {"sha": "6d6d8f2cc21d986da64c50254c12a80cfe491215", "filename": "src/test/run-pass/macro-with-attrs1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fmacro-with-attrs1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fmacro-with-attrs1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-with-attrs1.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -19,6 +19,6 @@ macro_rules! foo( () => (1) )\n #[cfg(not(foo))]\n macro_rules! foo( () => (2) )\n \n-fn main() {\n+pub fn main() {\n     assert_eq!(foo!(), 1);\n }"}, {"sha": "66e7fc4265b6c08cf31ba38bc8050e015776124a", "filename": "src/test/run-pass/mlist-cycle.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-test\n-extern mod std;\n-use std::gc;\n-use std::gc::rustrt;\n-\n-struct cell {c: @list}\n-\n-enum list { link(@mut cell), nil, }\n-\n-pub fn main() {\n-    let first: @cell = @mut cell{c: @nil()};\n-    let second: @cell = @mut cell{c: @link(first)};\n-    first._0 = @link(second);\n-    rustrt::gc();\n-    let third: @cell = @mut cell{c: @nil()};\n-}"}, {"sha": "7dbd895b47693e06cf11893fd131f368fe1b6736", "filename": "src/test/run-pass/native-print-no-runtime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fnative-print-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fnative-print-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-print-no-runtime.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,7 +13,7 @@\n #[no_uv];\n \n #[start]\n-fn main(_: int, _: **u8) -> int {\n+pub fn main(_: int, _: **u8) -> int {\n     println!(\"hello\");\n     0\n }"}, {"sha": "4a2756f5446eb35eb43628fff73a6a65bc4e085b", "filename": "src/test/run-pass/new-vstore-mut-box-syntax.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fnew-vstore-mut-box-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fnew-vstore-mut-box-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-vstore-mut-box-syntax.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-pub fn main() {\n-    let _x: @mut [int] = @mut [ 1, 2, 3 ];\n-\n-}"}, {"sha": "f190a5102d2b462478525d737df6912ff9738c23", "filename": "src/test/run-pass/newtype-struct-drop-run.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fnewtype-struct-drop-run.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fnewtype-struct-drop-run.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-struct-drop-run.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -12,19 +12,21 @@\n \n // Make sure the destructor is run for newtype structs.\n \n-struct Foo(@mut int);\n+use std::cell::Cell;\n+\n+struct Foo(@Cell<int>);\n \n #[unsafe_destructor]\n impl Drop for Foo {\n     fn drop(&mut self) {\n-        ***self = 23;\n+        self.set(23);\n     }\n }\n \n pub fn main() {\n-    let y = @mut 32;\n+    let y = @Cell::new(32);\n     {\n         let _x = Foo(y);\n     }\n-    assert_eq!(*y, 23);\n+    assert_eq!(y.get(), 23);\n }"}, {"sha": "d4341ccf7dc6fde1339c95c86136ddcc48c1355e", "filename": "src/test/run-pass/no-std-xcrate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fno-std-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fno-std-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fno-std-xcrate.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -16,6 +16,6 @@\n \n extern mod no_std_crate;\n \n-fn main() {\n+pub fn main() {\n     no_std_crate::foo();\n }"}, {"sha": "f164d8609fcf8d403887cc574faba140688f079b", "filename": "src/test/run-pass/no-std-xcrate2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fno-std-xcrate2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fno-std-xcrate2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fno-std-xcrate2.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -29,7 +29,7 @@ pub mod linkhack {\n }\n \n #[start]\n-fn main(_: int, _: **u8, _: *u8) -> int {\n+pub fn main(_: int, _: **u8, _: *u8) -> int {\n     no_std_crate::foo();\n     0\n }"}, {"sha": "52792c8c4279391ee7ac64e658dde4e7a4ca3139", "filename": "src/test/run-pass/objects-coerce-from-managed-to-borrowed.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fobjects-coerce-from-managed-to-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fobjects-coerce-from-managed-to-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobjects-coerce-from-managed-to-borrowed.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -14,24 +14,12 @@\n \n trait Foo {\n     fn foo(&self) -> uint;\n-    fn bar(&mut self) -> uint;\n }\n \n impl Foo for uint {\n     fn foo(&self) -> uint {\n         *self\n     }\n-\n-    fn bar(&mut self) -> uint {\n-        *self += 1;\n-        *self\n-    }\n-}\n-\n-fn do_it_mut(obj: &mut Foo) {\n-    let x = obj.bar();\n-    let y = obj.foo();\n-    assert_eq!(x, y);\n }\n \n fn do_it_imm(obj: &Foo, v: uint) {\n@@ -40,7 +28,6 @@ fn do_it_imm(obj: &Foo, v: uint) {\n }\n \n pub fn main() {\n-    let x = @mut 22u as @mut Foo;\n-    do_it_mut(x);\n-    do_it_imm(x, 23u);\n+    let x = @22u as @Foo;\n+    do_it_imm(x, 22u);\n }"}, {"sha": "8c3f889c176cd97c4b59c9e8b4b12c323e11c293", "filename": "src/test/run-pass/once-move-out-on-heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -20,7 +20,7 @@ fn foo(blk: proc()) {\n     blk();\n }\n \n-fn main() {\n+pub fn main() {\n     let x = arc::Arc::new(true);\n     do foo {\n         assert!(*x.get());"}, {"sha": "07dd5175a0fae1ae50f328b87cbb754a9c0d1d4a", "filename": "src/test/run-pass/once-move-out-on-stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -20,7 +20,7 @@ fn foo(blk: once ||) {\n     blk();\n }\n \n-fn main() {\n+pub fn main() {\n     let x = arc::Arc::new(true);\n     foo(|| {\n         assert!(*x.get());"}, {"sha": "0806bcd185e4f0de1f2aecba6268817c9427580e", "filename": "src/test/run-pass/option-unwrap.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Foption-unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Foption-unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foption-unwrap.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,16 +10,17 @@\n \n #[feature(managed_boxes)];\n \n-struct dtor {\n-    x: @mut int,\n+use std::cell::Cell;\n \n+struct dtor {\n+    x: @Cell<int>,\n }\n \n #[unsafe_destructor]\n impl Drop for dtor {\n     fn drop(&mut self) {\n         // abuse access to shared mutable state to write this code\n-        *self.x -= 1;\n+        self.x.set(self.x.get() - 1);\n     }\n }\n \n@@ -31,12 +32,12 @@ fn unwrap<T>(o: Option<T>) -> T {\n }\n \n pub fn main() {\n-    let x = @mut 1;\n+    let x = @Cell::new(1);\n \n     {\n         let b = Some(dtor { x:x });\n         let _c = unwrap(b);\n     }\n \n-    assert_eq!(*x, 0);\n+    assert_eq!(x.get(), 0);\n }"}, {"sha": "5e45386353b2bf08ab4e722816d21d95eb3f84ca", "filename": "src/test/run-pass/osx-frameworks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fosx-frameworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fosx-frameworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fosx-frameworks.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -17,7 +17,7 @@ extern {\n }\n \n #[cfg(target_os = \"macos\")]\n-fn main() {\n+pub fn main() {\n     unsafe { CFRunLoopGetTypeID(); }\n }\n "}, {"sha": "cba923ef646f8ec83945fe672fa477a3fc16697d", "filename": "src/test/run-pass/packed-struct-generic-size.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -22,6 +22,6 @@ pub fn main() {\n \n     assert_eq!(mem::size_of::<S<u64, u16>>(), 11);\n \n-    assert_eq!(mem::size_of::<S<~str, @mut [int]>>(),\n-               1 + mem::size_of::<~str>() + mem::size_of::<@mut [int]>());\n+    assert_eq!(mem::size_of::<S<~str, @[int]>>(),\n+               1 + mem::size_of::<~str>() + mem::size_of::<@[int]>());\n }"}, {"sha": "336df24586a9fbe84b46e44d8d4698dfda92cc54", "filename": "src/test/run-pass/packed-struct-size-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fpacked-struct-size-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fpacked-struct-size-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-size-xc.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -5,6 +5,6 @@ extern mod packed;\n \n use std::mem;\n \n-fn main() {\n+pub fn main() {\n     assert_eq!(mem::size_of::<packed::S>(), 5);\n }"}, {"sha": "f694cc98ad350803183c9126a6ad2553c278f68e", "filename": "src/test/run-pass/packed-struct-size.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -49,7 +49,7 @@ struct S7_Option {\n     a: f32,\n     b: u8,\n     c: u16,\n-    d: Option<@mut f64>\n+    d: Option<@f64>\n }\n \n // Placing packed structs in statics should work\n@@ -63,5 +63,5 @@ pub fn main() {\n     assert_eq!(mem::size_of::<S5>(), 5);\n     assert_eq!(mem::size_of::<S13_str>(), 13 + mem::size_of::<~str>());\n     assert_eq!(mem::size_of::<S3_Foo>(), 3 + mem::size_of::<Foo>());\n-    assert_eq!(mem::size_of::<S7_Option>(), 7 + mem::size_of::<Option<@mut f64>>());\n+    assert_eq!(mem::size_of::<S7_Option>(), 7 + mem::size_of::<Option<@f64>>());\n }"}, {"sha": "7d2be73edc398266278e908aea051e9ab57b85b9", "filename": "src/test/run-pass/packed-tuple-struct-size.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -30,7 +30,7 @@ enum Foo {\n struct S3_Foo(u8, u16, Foo);\n \n #[packed]\n-struct S7_Option(f32, u8, u16, Option<@mut f64>);\n+struct S7_Option(f32, u8, u16, Option<@f64>);\n \n pub fn main() {\n     assert_eq!(mem::size_of::<S4>(), 4);\n@@ -44,5 +44,5 @@ pub fn main() {\n                3 + mem::size_of::<Foo>());\n \n     assert_eq!(mem::size_of::<S7_Option>(),\n-              7 + mem::size_of::<Option<@mut f64>>());\n+              7 + mem::size_of::<Option<@f64>>());\n }"}, {"sha": "a61b30dd480e9588dbe3aeae4f4d0fe6763bb44b", "filename": "src/test/run-pass/priv-impl-prim-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fpriv-impl-prim-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fpriv-impl-prim-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpriv-impl-prim-ty.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,7 +13,7 @@\n \n extern mod bar = \"priv-impl-prim-ty\";\n \n-fn main() {\n+pub fn main() {\n     bar::frob(1i);\n \n }"}, {"sha": "6e0e1d6ef9e2ea2da6afb5baa8b6b4c8354f1947", "filename": "src/test/run-pass/privacy-reexport.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fprivacy-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fprivacy-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivacy-reexport.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,6 +13,6 @@\n \n extern mod privacy_reexport;\n \n-fn main() {\n+pub fn main() {\n     privacy_reexport::bar::frob();\n }"}, {"sha": "8c1be0a6219756a89d31cd0a0b5c60c5bc9d1bd1", "filename": "src/test/run-pass/rcvr-borrowed-to-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -24,7 +24,7 @@ impl<'a> get for &'a int {\n }\n \n pub fn main() {\n-    let x = @mut 6;\n+    let x = @6;\n     let y = x.get();\n     assert_eq!(y, 6);\n "}, {"sha": "1cd8e80ba93d78b816ee27187debbb4f776c9b40", "filename": "src/test/run-pass/reexport-should-still-link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Freexport-should-still-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Freexport-should-still-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freexport-should-still-link.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,6 +13,6 @@\n \n extern mod foo = \"reexport-should-still-link\";\n \n-fn main() {\n+pub fn main() {\n     foo::bar();\n }"}, {"sha": "0d4277d2e1d638308a7748cfc5110ff4fce8d814", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -12,6 +12,7 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::RefCell;\n use std::libc::c_void;\n use std::ptr;\n use std::mem;\n@@ -458,8 +459,9 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n }\n \n-struct my_visitor(@mut Stuff);\n+struct my_visitor(@RefCell<Stuff>);\n \n+#[deriving(Clone)]\n struct Stuff {\n     ptr1: *c_void,\n     ptr2: *c_void,\n@@ -469,7 +471,7 @@ struct Stuff {\n impl my_visitor {\n     pub fn get<T:Clone>(&mut self, f: |T|) {\n         unsafe {\n-            f((*(self.ptr1 as *T)).clone());\n+            f((*((**self).get().ptr1 as *T)).clone());\n         }\n     }\n \n@@ -487,8 +489,9 @@ struct Inner<V> { inner: V }\n \n impl movable_ptr for my_visitor {\n     fn move_ptr(&mut self, adjustment: |*c_void| -> *c_void) {\n-        self.ptr1 = adjustment(self.ptr1);\n-        self.ptr2 = adjustment(self.ptr2);\n+        let mut this = self.borrow_mut();\n+        this.get().ptr1 = adjustment(this.get().ptr1);\n+        this.get().ptr2 = adjustment(this.get().ptr2);\n     }\n }\n \n@@ -497,11 +500,17 @@ impl TyVisitor for my_visitor {\n     fn visit_bot(&mut self) -> bool { true }\n     fn visit_nil(&mut self) -> bool { true }\n     fn visit_bool(&mut self) -> bool {\n-        self.get::<bool>(|b| self.vals.push(b.to_str()));\n+        self.get::<bool>(|b| {\n+            let mut this = self.borrow_mut();\n+            this.get().vals.push(b.to_str());\n+        });\n         true\n     }\n     fn visit_int(&mut self) -> bool {\n-        self.get::<int>(|i| self.vals.push(i.to_str()));\n+        self.get::<int>(|i| {\n+            let mut this = self.borrow_mut();\n+            this.get().vals.push(i.to_str());\n+        });\n         true\n     }\n     fn visit_i8(&mut self) -> bool { true }\n@@ -622,21 +631,22 @@ pub fn main() {\n     unsafe {\n         let r = (1,2,3,true,false, Triple {x:5,y:4,z:3}, (12,));\n         let p = ptr::to_unsafe_ptr(&r) as *c_void;\n-        let u = my_visitor(@mut Stuff {ptr1: p,\n-                                       ptr2: p,\n-                                       vals: ~[]});\n+        let u = my_visitor(@RefCell::new(Stuff {ptr1: p,\n+                                                ptr2: p,\n+                                                vals: ~[]}));\n         let mut v = ptr_visit_adaptor(Inner {inner: u});\n         let td = get_tydesc_for(r);\n         error!(\"tydesc sz: {}, align: {}\",\n                (*td).size, (*td).align);\n         visit_tydesc(td, &mut v as &mut TyVisitor);\n \n-        let r = u.vals.clone();\n+        let mut ub = u.borrow_mut();\n+        let r = ub.get().vals.clone();\n         for s in r.iter() {\n             println!(\"val: {}\", *s);\n         }\n-        error!(\"{:?}\", u.vals.clone());\n-        assert_eq!(u.vals.clone(),\n+        error!(\"{:?}\", ub.get().vals.clone());\n+        assert_eq!(ub.get().vals.clone(),\n                    ~[ ~\"1\", ~\"2\", ~\"3\", ~\"true\", ~\"false\", ~\"5\", ~\"4\", ~\"3\", ~\"12\"]);\n     }\n }"}, {"sha": "5acb072fd2d3723fec8586b92f3ebbb85f834737", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,7 +13,7 @@\n use std::unstable::intrinsics::{TyDesc, get_tydesc, visit_tydesc, TyVisitor, Disr, Opaque};\n \n struct MyVisitor {\n-    types: @mut ~[~str],\n+    types: ~[~str],\n }\n \n impl TyVisitor for MyVisitor {\n@@ -153,7 +153,7 @@ fn visit_ty<T>(v: &mut MyVisitor) {\n }\n \n pub fn main() {\n-    let mut v = MyVisitor {types: @mut ~[]};\n+    let mut v = MyVisitor {types: ~[]};\n \n     visit_ty::<bool>(&mut v);\n     visit_ty::<int>(&mut v);\n@@ -164,5 +164,5 @@ pub fn main() {\n     for s in v.types.iter() {\n         println!(\"type: {}\", (*s).clone());\n     }\n-    assert_eq!((*v.types).clone(), ~[~\"bool\", ~\"int\", ~\"i8\", ~\"i16\", ~\"[\", ~\"int\", ~\"]\"]);\n+    assert_eq!(v.types.clone(), ~[~\"bool\", ~\"int\", ~\"i8\", ~\"i16\", ~\"[\", ~\"int\", ~\"]\"]);\n }"}, {"sha": "1e5dfe21cbe8844d567f6c23ee6db0b8dcc359d0", "filename": "src/test/run-pass/rename-directory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frename-directory.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -55,4 +55,4 @@ fn rename_directory() {\n     }\n }\n \n-fn main() { rename_directory() }\n+pub fn main() { rename_directory() }"}, {"sha": "bec101a6d45a93c9f14b2c9ae79f8205e9cc0bcb", "filename": "src/test/run-pass/resource-assign-is-not-copy.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fresource-assign-is-not-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fresource-assign-is-not-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-assign-is-not-copy.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,31 +10,33 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::Cell;\n+\n struct r {\n-  i: @mut int,\n+    i: @Cell<int>,\n }\n \n #[unsafe_destructor]\n impl Drop for r {\n     fn drop(&mut self) {\n-        *(self.i) += 1;\n+        self.i.set(self.i.get() + 1);\n     }\n }\n \n-fn r(i: @mut int) -> r {\n+fn r(i: @Cell<int>) -> r {\n     r {\n         i: i\n     }\n }\n \n pub fn main() {\n-    let i = @mut 0;\n+    let i = @Cell::new(0);\n     // Even though these look like copies, they are guaranteed not to be\n     {\n         let a = r(i);\n         let b = (a, 10);\n         let (c, _d) = b;\n         info!(\"{:?}\", c);\n     }\n-    assert_eq!(*i, 1);\n+    assert_eq!(i.get(), 1);\n }"}, {"sha": "898f6327aeb17b6de37179aeabf61a9c581cd15c", "filename": "src/test/run-pass/resource-cycle.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-// Don't leak the unique pointers\n-\n-use std::cast;\n-\n-struct r {\n-  v: *int,\n-}\n-\n-impl Drop for r {\n-    fn drop(&mut self) {\n-        unsafe {\n-            info!(\"r's dtor: self = {:x}, self.v = {:x}, self.v's value = {:x}\",\n-              cast::transmute::<*mut r, uint>(self),\n-              cast::transmute::<**int, uint>(&(self.v)),\n-              cast::transmute::<*int, uint>(self.v));\n-            let _v2: ~int = cast::transmute(self.v);\n-        }\n-    }\n-}\n-\n-fn r(v: *int) -> r {\n-    r {\n-        v: v\n-    }\n-}\n-\n-struct t(Node);\n-\n-struct Node {\n-    next: Option<@mut t>,\n-    r: r\n-}\n-\n-pub fn main() {\n-    unsafe {\n-        let i1 = ~0;\n-        let i1p = cast::transmute_copy(&i1);\n-        cast::forget(i1);\n-        let i2 = ~0;\n-        let i2p = cast::transmute_copy(&i2);\n-        cast::forget(i2);\n-\n-        let x1 = @mut t(Node{\n-            next: None,\n-              r: {\n-              let rs = r(i1p);\n-              info!(\"r = {:x}\", cast::transmute::<*r, uint>(&rs));\n-              rs }\n-        });\n-\n-        info!(\"x1 = {:x}, x1.r = {:x}\",\n-               cast::transmute::<@mut t, uint>(x1),\n-               cast::transmute::<*r, uint>(&x1.r));\n-\n-        let x2 = @mut t(Node{\n-            next: None,\n-              r: {\n-              let rs = r(i2p);\n-              info!(\"r2 = {:x}\", cast::transmute::<*r, uint>(&rs));\n-              rs\n-                }\n-        });\n-\n-        info!(\"x2 = {:x}, x2.r = {:x}\",\n-               cast::transmute::<@mut t, uint>(x2),\n-               cast::transmute::<*r, uint>(&(x2.r)));\n-\n-        x1.next = Some(x2);\n-        x2.next = Some(x1);\n-    }\n-}"}, {"sha": "c7ad9711ed45d147dbe6dec94eb91a585ff99df4", "filename": "src/test/run-pass/resource-cycle2.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,71 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-// Don't leak the unique pointers\n-\n-use std::cast;\n-\n-struct U {\n-    a: int,\n-    b: int,\n-    c: *int\n-}\n-\n-struct r {\n-  v: U,\n-}\n-\n-impl Drop for r {\n-    fn drop(&mut self) {\n-        unsafe {\n-            let _v2: ~int = cast::transmute(self.v.c);\n-        }\n-    }\n-}\n-\n-fn r(v: U) -> r {\n-    r {\n-        v: v\n-    }\n-}\n-\n-struct t(Node);\n-\n-struct Node {\n-    next: Option<@mut t>,\n-    r: r\n-}\n-\n-pub fn main() {\n-    unsafe {\n-        let i1 = ~0xA;\n-        let i1p = cast::transmute_copy(&i1);\n-        cast::forget(i1);\n-        let i2 = ~0xA;\n-        let i2p = cast::transmute_copy(&i2);\n-        cast::forget(i2);\n-\n-        let u1 = U {a: 0xB, b: 0xC, c: i1p};\n-        let u2 = U {a: 0xB, b: 0xC, c: i2p};\n-\n-        let x1 = @mut t(Node {\n-            next: None,\n-            r: r(u1)\n-        });\n-        let x2 = @mut t(Node {\n-            next: None,\n-            r: r(u2)\n-        });\n-        x1.next = Some(x2);\n-        x2.next = Some(x1);\n-    }\n-}"}, {"sha": "8d11eca44922d6905c34af1d18debc847845f7c0", "filename": "src/test/run-pass/resource-cycle3.rs", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,80 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-// same as resource-cycle2, but be sure to give r multiple fields...\n-\n-// Don't leak the unique pointers\n-\n-use std::cast;\n-\n-struct U {\n-    a: int,\n-    b: int,\n-    c: *int\n-}\n-\n-struct R {\n-  v: U,\n-  w: int,\n-  x: *int,\n-}\n-\n-impl Drop for R {\n-    fn drop(&mut self) {\n-        unsafe {\n-            let _v2: ~int = cast::transmute(self.v.c);\n-            // let _v3: ~int = cast::transmute_copy(self.x);\n-        }\n-    }\n-}\n-\n-fn r(v: U, w: int, _x: *int) -> R {\n-    unsafe {\n-        R {\n-            v: v,\n-            w: w,\n-            x: cast::transmute(0)\n-        }\n-    }\n-}\n-\n-struct t(Node);\n-\n-struct Node {\n-    next: Option<@mut t>,\n-    r: R\n-}\n-\n-pub fn main() {\n-    unsafe {\n-        let i1 = ~0xA;\n-        let i1p = cast::transmute_copy(&i1);\n-        cast::forget(i1);\n-        let i2 = ~0xA;\n-        let i2p = cast::transmute_copy(&i2);\n-        cast::forget(i2);\n-\n-        let u1 = U {a: 0xB, b: 0xC, c: i1p};\n-        let u2 = U {a: 0xB, b: 0xC, c: i2p};\n-\n-        let x1 = @mut t(Node{\n-            next: None,\n-            r: r(u1, 42, i1p)\n-        });\n-        let x2 = @mut t(Node{\n-            next: None,\n-            r: r(u2, 42, i2p)\n-        });\n-        x1.next = Some(x2);\n-        x2.next = Some(x1);\n-    }\n-}"}, {"sha": "93183f8dba47582b86a057c1fbdd310dabb58410", "filename": "src/test/run-pass/resource-destruct.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fresource-destruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fresource-destruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-destruct.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,30 +10,32 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::Cell;\n+\n struct shrinky_pointer {\n-  i: @@mut int,\n+  i: @@Cell<int>,\n }\n \n #[unsafe_destructor]\n impl Drop for shrinky_pointer {\n     fn drop(&mut self) {\n-        error!(\"Hello!\"); **(self.i) -= 1;\n+        error!(\"Hello!\"); self.i.set(self.i.get() - 1);\n     }\n }\n \n impl shrinky_pointer {\n-    pub fn look_at(&self) -> int { return **(self.i); }\n+    pub fn look_at(&self) -> int { return self.i.get(); }\n }\n \n-fn shrinky_pointer(i: @@mut int) -> shrinky_pointer {\n+fn shrinky_pointer(i: @@Cell<int>) -> shrinky_pointer {\n     shrinky_pointer {\n         i: i\n     }\n }\n \n pub fn main() {\n-    let my_total = @@mut 10;\n+    let my_total = @@Cell::new(10);\n     { let pt = shrinky_pointer(my_total); assert!((pt.look_at() == 10)); }\n-    error!(\"my_total = {}\", **my_total);\n-    assert_eq!(**my_total, 9);\n+    error!(\"my_total = {}\", my_total.get());\n+    assert_eq!(my_total.get(), 9);\n }"}, {"sha": "1c5ad9ce525df33bd129b6b05b0dc22b5017b95a", "filename": "src/test/run-pass/resource-in-struct.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fresource-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fresource-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-in-struct.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,7 +13,9 @@\n // Ensures that class dtors run if the object is inside an enum\n // variant\n \n-type closable = @mut bool;\n+use std::cell::Cell;\n+\n+type closable = @Cell<bool>;\n \n struct close_res {\n   i: closable,\n@@ -23,7 +25,7 @@ struct close_res {\n #[unsafe_destructor]\n impl Drop for close_res {\n     fn drop(&mut self) {\n-        *(self.i) = false;\n+        self.i.set(false);\n     }\n }\n \n@@ -38,8 +40,8 @@ enum option<T> { none, some(T), }\n fn sink(_res: option<close_res>) { }\n \n pub fn main() {\n-    let c = @mut true;\n+    let c = @Cell::new(true);\n     sink(none);\n     sink(some(close_res(c)));\n-    assert!((!*c));\n+    assert!(!c.get());\n }"}, {"sha": "dc74e9fb47051ade83856c1f45cbae9e95aea7f0", "filename": "src/test/run-pass/signal-exit-status.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,7 +13,7 @@\n use std::{os, run};\n use std::io::process;\n \n-fn main() {\n+pub fn main() {\n     let args = os::args();\n     if args.len() >= 2 && args[1] == ~\"signal\" {\n         // Raise a segfault."}, {"sha": "11cef9d480a4d5ad62b85fd03b082a26ca261270", "filename": "src/test/run-pass/smallest-hello-world.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -32,7 +32,7 @@ extern \"rust-intrinsic\" {\n }\n \n #[start]\n-fn main(_: int, _: **u8, _: *u8) -> int {\n+pub fn main(_: int, _: **u8, _: *u8) -> int {\n     unsafe {\n         let (ptr, _): (*u8, uint) = transmute(\"Hello!\");\n         puts(ptr);"}, {"sha": "c14ef147bc726df45665ec9ffc23dd2b395308ca", "filename": "src/test/run-pass/spawning-with-debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fspawning-with-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fspawning-with-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawning-with-debug.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -15,7 +15,7 @@\n \n use std::task;\n \n-fn main() {\n+pub fn main() {\n     let mut t = task::task();\n     t.spawn(proc() ());\n }"}, {"sha": "4c72c3075ff8eaa8b1e24476760607b8397c9e49", "filename": "src/test/run-pass/static-function-pointer-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fstatic-function-pointer-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fstatic-function-pointer-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-function-pointer-xc.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -14,7 +14,7 @@ extern mod aux = \"static-function-pointer-aux\";\n \n fn f(x: int) -> int { x }\n \n-fn main() {\n+pub fn main() {\n     assert_eq!(aux::F(42), -42);\n     unsafe {\n         assert_eq!(aux::MutF(42), -42);"}, {"sha": "dc56cdf3a34ea3136de81d26deb17f44d807d837", "filename": "src/test/run-pass/struct_variant_xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fstruct_variant_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fstruct_variant_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct_variant_xc.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -14,6 +14,6 @@ extern mod struct_variant_xc_aux;\n \n use struct_variant_xc_aux::Variant;\n \n-fn main() {\n+pub fn main() {\n     let _ = Variant { arg: 1 };\n }"}, {"sha": "5f85ac1bd5577c326be094a82949bd6fbdffa419", "filename": "src/test/run-pass/syntax-extension-cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fsyntax-extension-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fsyntax-extension-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-cfg.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast compile-flags doesn't work with fast-check\n // compile-flags: --cfg foo --cfg bar(baz) --cfg qux=\"foo\"\n \n-fn main() {\n+pub fn main() {\n     // check\n     if ! cfg!(foo) { fail!() }\n     if   cfg!(not(foo)) { fail!() }"}, {"sha": "16e9cb538919cbc173db9a898e51315be0c56a8c", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,12 +13,14 @@\n // A port of task-killjoin to use a class with a dtor to manage\n // the join.\n \n+use std::cell::Cell;\n use std::comm::*;\n use std::ptr;\n use std::task;\n \n struct notify {\n-    ch: Chan<bool>, v: @mut bool,\n+    ch: Chan<bool>,\n+    v: @Cell<bool>,\n }\n \n #[unsafe_destructor]\n@@ -36,7 +38,7 @@ impl Drop for notify {\n     }\n }\n \n-fn notify(ch: Chan<bool>, v: @mut bool) -> notify {\n+fn notify(ch: Chan<bool>, v: @Cell<bool>) -> notify {\n     notify {\n         ch: ch,\n         v: v\n@@ -45,10 +47,10 @@ fn notify(ch: Chan<bool>, v: @mut bool) -> notify {\n \n fn joinable(f: proc()) -> Port<bool> {\n     fn wrapper(c: Chan<bool>, f: ||) {\n-        let b = @mut false;\n+        let b = @Cell::new(false);\n         error!(\"wrapper: task=%? allocated v=%x\",\n                0,\n-               ptr::to_unsafe_ptr(&(*b)) as uint);\n+               ptr::to_unsafe_ptr(&b) as uint);\n         let _r = notify(c, b);\n         f();\n         *b = true;"}, {"sha": "eb055342acd24ee52337c4b01552186ddce85882", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -141,7 +141,7 @@ fn in_tmpdir(f: ||) {\n     f();\n }\n \n-fn main() {\n+pub fn main() {\n     in_tmpdir(test_tempdir);\n     in_tmpdir(test_rm_tempdir);\n     in_tmpdir(recursive_mkdir_rel);"}, {"sha": "b99e6a03bcb3bae24ec5b5bd182c7ab635e2bbc8", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -60,7 +60,7 @@ impl Pet for Goldfyshe {\n     fn of_good_pedigree(&self) -> bool { self.swim_speed >= 500 }\n }\n \n-fn main() {\n+pub fn main() {\n     let catte = Catte { num_whiskers: 7, name: ~\"alonzo_church\" };\n     let dogge1 = Dogge { bark_decibels: 100, tricks_known: 42, name: ~\"alan_turing\" };\n     let dogge2 = Dogge { bark_decibels: 55,  tricks_known: 11, name: ~\"albert_einstein\" };"}, {"sha": "bf8b0b5522dca76b0514ac7229130e69d533cba9", "filename": "src/test/run-pass/trait-cast.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-cast.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -12,7 +12,9 @@\n \n // Test cyclic detector when using trait instances.\n \n-struct Tree(@mut TreeR);\n+use std::cell::RefCell;\n+\n+struct Tree(@RefCell<TreeR>);\n struct TreeR {\n     left: Option<Tree>,\n     right: Option<Tree>,\n@@ -38,23 +40,28 @@ impl to_str for int {\n \n impl to_str for Tree {\n     fn to_str_(&self) -> ~str {\n-        let (l, r) = (self.left, self.right);\n-        let val = &self.val;\n+        let this = self.borrow();\n+        let (l, r) = (this.get().left, this.get().right);\n+        let val = &this.get().val;\n         format!(\"[{}, {}, {}]\", val.to_str_(), l.to_str_(), r.to_str_())\n     }\n }\n \n fn foo<T:to_str>(x: T) -> ~str { x.to_str_() }\n \n pub fn main() {\n-    let t1 = Tree(@mut TreeR{left: None,\n-                             right: None,\n-                             val: ~1 as ~to_str });\n-    let t2 = Tree(@mut TreeR{left: Some(t1),\n-                             right: Some(t1),\n-                             val: ~2 as ~to_str });\n+    let t1 = Tree(@RefCell::new(TreeR{left: None,\n+                                      right: None,\n+                                      val: ~1 as ~to_str}));\n+    let t2 = Tree(@RefCell::new(TreeR{left: Some(t1),\n+                                      right: Some(t1),\n+                                      val: ~2 as ~to_str}));\n     let expected = ~\"[2, some([1, none, none]), some([1, none, none])]\";\n     assert!(t2.to_str_() == expected);\n     assert!(foo(t2) == expected);\n-    t1.left = Some(t2); // create cycle\n+\n+    {\n+        let mut t1 = t1.borrow_mut();\n+        t1.get().left = Some(t2); // create cycle\n+    }\n }"}, {"sha": "58066adc4bd6f6b2c2bdf497c197771a4aa5a2e7", "filename": "src/test/run-pass/trait-default-method-xc-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc-2.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -9,7 +9,7 @@ use aux::A;\n use aux2::{a_struct, welp};\n \n \n-fn main () {\n+pub fn main () {\n \n     let a = a_struct { x: 0 };\n     let b = a_struct { x: 1 };"}, {"sha": "3323b3c952ab9a75d309abe7747bb22f872097cb", "filename": "src/test/run-pass/trait-default-method-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -44,7 +44,7 @@ impl TestEquality for stuff::thing {\n }\n \n \n-fn main () {\n+pub fn main () {\n     // Some tests of random things\n     f(0);\n "}, {"sha": "55360608bca1d6970c9fc678291a9392b4bd42df", "filename": "src/test/run-pass/tydesc-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Ftydesc-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Ftydesc-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftydesc-name.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -16,7 +16,7 @@ struct Foo<T> {\n     x: T\n }\n \n-fn main() {\n+pub fn main() {\n     unsafe {\n         assert_eq!((*get_tydesc::<int>()).name, \"int\");\n         assert_eq!((*get_tydesc::<~[int]>()).name, \"~[int]\");"}, {"sha": "d7feb4f4a012be5a2505114b1efa3cb87160dbea", "filename": "src/test/run-pass/typeid-intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -21,7 +21,7 @@ use std::unstable::intrinsics::TypeId;\n struct A;\n struct Test;\n \n-fn main() {\n+pub fn main() {\n     unsafe {\n         assert_eq!(intrinsics::type_id::<other1::A>(), other1::id_A());\n         assert_eq!(intrinsics::type_id::<other1::B>(), other1::id_B());"}, {"sha": "53836a6e17dfbb9e589a7dde3ef606db0fc7245d", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,11 +10,12 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::RefCell;\n use std::ptr;\n \n enum maybe_pointy {\n     none,\n-    p(@mut Pointy),\n+    p(@RefCell<Pointy>),\n }\n \n struct Pointy {\n@@ -27,14 +28,17 @@ fn make_uniq_closure<A:Send>(a: A) -> proc() -> uint {\n     result\n }\n \n-fn empty_pointy() -> @mut Pointy {\n-    return @mut Pointy {\n+fn empty_pointy() -> @RefCell<Pointy> {\n+    return @RefCell::new(Pointy {\n         a : none,\n         d : make_uniq_closure(~\"hi\")\n-    }\n+    })\n }\n \n pub fn main() {\n     let v = empty_pointy();\n-    v.a = p(v);\n+    {\n+        let mut vb = v.borrow_mut();\n+        vb.get().a = p(v);\n+    }\n }"}, {"sha": "23a27dece46f1b2b43685a6c5cbb14036004f6ea", "filename": "src/test/run-pass/uniq-cc.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Funiq-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Funiq-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,9 +10,11 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::RefCell;\n+\n enum maybe_pointy {\n     none,\n-    p(@mut Pointy),\n+    p(@RefCell<Pointy>),\n }\n \n struct Pointy {\n@@ -21,15 +23,18 @@ struct Pointy {\n     d : proc()->(),\n }\n \n-fn empty_pointy() -> @mut Pointy {\n-    return @mut Pointy {\n+fn empty_pointy() -> @RefCell<Pointy> {\n+    return @RefCell::new(Pointy {\n         a : none,\n         c : ~22,\n         d : proc() {},\n-    }\n+    })\n }\n \n pub fn main() {\n     let v = empty_pointy();\n-    v.a = p(v);\n+    {\n+        let mut vb = v.borrow_mut();\n+        vb.get().a = p(v);\n+    }\n }"}, {"sha": "a7c326ba11c4222bd5c168e38042f1a7f410ae63", "filename": "src/test/run-pass/unique-pinned-nocopy-2.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Funique-pinned-nocopy-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff6c12ce94993dae702d597a213eee6b969231a/src%2Ftest%2Frun-pass%2Funique-pinned-nocopy-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-pinned-nocopy-2.rs?ref=0ff6c12ce94993dae702d597a213eee6b969231a", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-struct r {\n-  i: @mut int,\n-}\n-\n-#[unsafe_destructor]\n-impl Drop for r {\n-    fn drop(&mut self) {\n-        *(self.i) = *(self.i) + 1;\n-    }\n-}\n-\n-fn r(i: @mut int) -> r {\n-    r {\n-        i: i\n-    }\n-}\n-\n-pub fn main() {\n-    let i = @mut 0;\n-    {\n-        let _j = ~r(i);\n-    }\n-    assert_eq!(*i, 1);\n-}"}, {"sha": "239416adfe0d4b2f38df226404f58a5f5b2bf588", "filename": "src/test/run-pass/use_inline_dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fuse_inline_dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fuse_inline_dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse_inline_dtor.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,6 +13,6 @@\n \n extern mod inline_dtor;\n \n-fn main() {\n+pub fn main() {\n     let _x = inline_dtor::Foo;\n }"}, {"sha": "f8e28dc792cfd6dfe6494b997657bb17ec8f7f99", "filename": "src/test/run-pass/vec-slice-drop.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fvec-slice-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fvec-slice-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-slice-drop.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,29 +10,31 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::Cell;\n+\n // Make sure that destructors get run on slice literals\n struct foo {\n-    x: @mut int,\n+    x: @Cell<int>,\n }\n \n #[unsafe_destructor]\n impl Drop for foo {\n     fn drop(&mut self) {\n-        *self.x += 1;\n+        self.x.set(self.x.get() + 1);\n     }\n }\n \n-fn foo(x: @mut int) -> foo {\n+fn foo(x: @Cell<int>) -> foo {\n     foo {\n         x: x\n     }\n }\n \n pub fn main() {\n-    let x = @mut 0;\n+    let x = @Cell::new(0);\n     {\n         let l = &[foo(x)];\n-        assert_eq!(*l[0].x, 0);\n+        assert_eq!(l[0].x.get(), 0);\n     }\n-    assert_eq!(*x, 1);\n+    assert_eq!(x.get(), 1);\n }"}, {"sha": "f62ab6f59a06242712085acf7dccfcaab4797a4a", "filename": "src/test/run-pass/weird-exprs.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweird-exprs.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -10,6 +10,7 @@\n \n #[feature(managed_boxes)];\n \n+use std::cell::Cell;\n use std::util;\n \n // Just a grab bag of stuff that you wouldn't want to actually write.\n@@ -22,11 +23,13 @@ fn funny() {\n }\n \n fn what() {\n-    fn the(x: @mut bool) { return while !*x { *x = true; }; }\n-    let i = @mut false;\n+    fn the(x: @Cell<bool>) {\n+        return while !x.get() { x.set(true); };\n+    }\n+    let i = @Cell::new(false);\n     let dont = {||the(i)};\n     dont();\n-    assert!((*i));\n+    assert!((i.get()));\n }\n \n fn zombiejesus() {"}, {"sha": "872c94e05fd55508f870ce10b641995b9e966add", "filename": "src/test/run-pass/xcrate-address-insignificant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fxcrate-address-insignificant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fxcrate-address-insignificant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxcrate-address-insignificant.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -13,6 +13,6 @@\n \n extern mod foo = \"xcrate_address_insignificant\";\n \n-fn main() {\n+pub fn main() {\n     assert_eq!(foo::foo::<f64>(), foo::bar());\n }"}, {"sha": "10f3a2b037f2754489f0cf7f14d06f8c1ab381a9", "filename": "src/test/run-pass/xcrate-unit-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dd7c49faf5ae3a9158ab242a264c0f0eb99f657/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs?ref=3dd7c49faf5ae3a9158ab242a264c0f0eb99f657", "patch": "@@ -21,7 +21,7 @@ static s4: xcrate_unit_struct::Unit = xcrate_unit_struct::Argument(s1);\n fn f1(_: xcrate_unit_struct::Struct) {}\n fn f2(_: xcrate_unit_struct::Unit) {}\n \n-fn main() {\n+pub fn main() {\n     f1(xcrate_unit_struct::Struct);\n     f2(xcrate_unit_struct::Unit);\n     f2(xcrate_unit_struct::Argument(xcrate_unit_struct::Struct));"}]}