{"sha": "38f4d557d0c227230a580b328ded5c06a4a20509", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ZjRkNTU3ZDBjMjI3MjMwYTU4MGIzMjhkZWQ1YzA2YTRhMjA1MDk=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-03-01T07:33:30Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-03-01T17:29:39Z"}, "message": "Rollup merge of #48500 - petrochenkov:parpat, r=nikomatsakis\n\nSupport parentheses in patterns under feature gate\n\nThis is a prerequisite for any other extensions to pattern syntax - `|` with multiple patterns, type ascription, `..PAT` in slice patterns.\n\nCloses https://github.com/rust-lang/rfcs/issues/554", "tree": {"sha": "d4683ad20f74dc1fea918beeea98ea4e51303f84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4683ad20f74dc1fea918beeea98ea4e51303f84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38f4d557d0c227230a580b328ded5c06a4a20509", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38f4d557d0c227230a580b328ded5c06a4a20509", "html_url": "https://github.com/rust-lang/rust/commit/38f4d557d0c227230a580b328ded5c06a4a20509", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38f4d557d0c227230a580b328ded5c06a4a20509/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39d5e1cba65be49248be82fcc3c965287a2a2cb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/39d5e1cba65be49248be82fcc3c965287a2a2cb1", "html_url": "https://github.com/rust-lang/rust/commit/39d5e1cba65be49248be82fcc3c965287a2a2cb1"}, {"sha": "c9aff92e6dc3ea43228d3d4e24ee7f5485943569", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9aff92e6dc3ea43228d3d4e24ee7f5485943569", "html_url": "https://github.com/rust-lang/rust/commit/c9aff92e6dc3ea43228d3d4e24ee7f5485943569"}], "stats": {"total": 273, "additions": 166, "deletions": 107}, "files": [{"sha": "a41ac5bceed27d51b8813e56afb5fe83e23b2239", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 78, "deletions": 76, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=38f4d557d0c227230a580b328ded5c06a4a20509", "patch": "@@ -2472,86 +2472,88 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(p.id);\n+        let node = match p.node {\n+            PatKind::Wild => hir::PatKind::Wild,\n+            PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n+                match self.resolver.get_resolution(p.id).map(|d| d.base_def()) {\n+                    // `None` can occur in body-less function signatures\n+                    def @ None | def @ Some(Def::Local(_)) => {\n+                        let canonical_id = match def {\n+                            Some(Def::Local(id)) => id,\n+                            _ => p.id\n+                        };\n+                        hir::PatKind::Binding(self.lower_binding_mode(binding_mode),\n+                                                canonical_id,\n+                                                respan(pth1.span, pth1.node.name),\n+                                                sub.as_ref().map(|x| self.lower_pat(x)))\n+                    }\n+                    Some(def) => {\n+                        hir::PatKind::Path(hir::QPath::Resolved(None, P(hir::Path {\n+                            span: pth1.span,\n+                            def,\n+                            segments: hir_vec![\n+                                hir::PathSegment::from_name(pth1.node.name)\n+                            ],\n+                        })))\n+                    }\n+                }\n+            }\n+            PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n+            PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n+                let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional,\n+                                                ImplTraitContext::Disallowed);\n+                hir::PatKind::TupleStruct(qpath,\n+                                            pats.iter().map(|x| self.lower_pat(x)).collect(),\n+                                            ddpos)\n+            }\n+            PatKind::Path(ref qself, ref path) => {\n+                hir::PatKind::Path(self.lower_qpath(p.id, qself, path, ParamMode::Optional,\n+                                                    ImplTraitContext::Disallowed))\n+            }\n+            PatKind::Struct(ref path, ref fields, etc) => {\n+                let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional,\n+                                                ImplTraitContext::Disallowed);\n+\n+                let fs = fields.iter()\n+                                .map(|f| {\n+                                    Spanned {\n+                                        span: f.span,\n+                                        node: hir::FieldPat {\n+                                            name: self.lower_ident(f.node.ident),\n+                                            pat: self.lower_pat(&f.node.pat),\n+                                            is_shorthand: f.node.is_shorthand,\n+                                        },\n+                                    }\n+                                })\n+                                .collect();\n+                hir::PatKind::Struct(qpath, fs, etc)\n+            }\n+            PatKind::Tuple(ref elts, ddpos) => {\n+                hir::PatKind::Tuple(elts.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n+            }\n+            PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n+            PatKind::Ref(ref inner, mutbl) => {\n+                hir::PatKind::Ref(self.lower_pat(inner), self.lower_mutability(mutbl))\n+            }\n+            PatKind::Range(ref e1, ref e2, ref end) => {\n+                hir::PatKind::Range(P(self.lower_expr(e1)),\n+                                    P(self.lower_expr(e2)),\n+                                    self.lower_range_end(end))\n+            }\n+            PatKind::Slice(ref before, ref slice, ref after) => {\n+                hir::PatKind::Slice(before.iter().map(|x| self.lower_pat(x)).collect(),\n+                            slice.as_ref().map(|x| self.lower_pat(x)),\n+                            after.iter().map(|x| self.lower_pat(x)).collect())\n+            }\n+            PatKind::Paren(ref inner) => return self.lower_pat(inner),\n+            PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n+        };\n \n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(p.id);\n         P(hir::Pat {\n             id: node_id,\n             hir_id,\n-            node: match p.node {\n-                PatKind::Wild => hir::PatKind::Wild,\n-                PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n-                    match self.resolver.get_resolution(p.id).map(|d| d.base_def()) {\n-                        // `None` can occur in body-less function signatures\n-                        def @ None | def @ Some(Def::Local(_)) => {\n-                            let canonical_id = match def {\n-                                Some(Def::Local(id)) => id,\n-                                _ => p.id\n-                            };\n-                            hir::PatKind::Binding(self.lower_binding_mode(binding_mode),\n-                                                  canonical_id,\n-                                                  respan(pth1.span, pth1.node.name),\n-                                                  sub.as_ref().map(|x| self.lower_pat(x)))\n-                        }\n-                        Some(def) => {\n-                            hir::PatKind::Path(hir::QPath::Resolved(None, P(hir::Path {\n-                                span: pth1.span,\n-                                def,\n-                                segments: hir_vec![\n-                                    hir::PathSegment::from_name(pth1.node.name)\n-                                ],\n-                            })))\n-                        }\n-                    }\n-                }\n-                PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n-                PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n-                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional,\n-                                                 ImplTraitContext::Disallowed);\n-                    hir::PatKind::TupleStruct(qpath,\n-                                              pats.iter().map(|x| self.lower_pat(x)).collect(),\n-                                              ddpos)\n-                }\n-                PatKind::Path(ref qself, ref path) => {\n-                    hir::PatKind::Path(self.lower_qpath(p.id, qself, path, ParamMode::Optional,\n-                                                        ImplTraitContext::Disallowed))\n-                }\n-                PatKind::Struct(ref path, ref fields, etc) => {\n-                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional,\n-                                                 ImplTraitContext::Disallowed);\n-\n-                    let fs = fields.iter()\n-                                   .map(|f| {\n-                                       Spanned {\n-                                           span: f.span,\n-                                           node: hir::FieldPat {\n-                                               name: self.lower_ident(f.node.ident),\n-                                               pat: self.lower_pat(&f.node.pat),\n-                                               is_shorthand: f.node.is_shorthand,\n-                                           },\n-                                       }\n-                                   })\n-                                   .collect();\n-                    hir::PatKind::Struct(qpath, fs, etc)\n-                }\n-                PatKind::Tuple(ref elts, ddpos) => {\n-                    hir::PatKind::Tuple(elts.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n-                }\n-                PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n-                PatKind::Ref(ref inner, mutbl) => {\n-                    hir::PatKind::Ref(self.lower_pat(inner), self.lower_mutability(mutbl))\n-                }\n-                PatKind::Range(ref e1, ref e2, ref end) => {\n-                    hir::PatKind::Range(P(self.lower_expr(e1)),\n-                                        P(self.lower_expr(e2)),\n-                                        self.lower_range_end(end))\n-                }\n-                PatKind::Slice(ref before, ref slice, ref after) => {\n-                    hir::PatKind::Slice(before.iter().map(|x| self.lower_pat(x)).collect(),\n-                                slice.as_ref().map(|x| self.lower_pat(x)),\n-                                after.iter().map(|x| self.lower_pat(x)).collect())\n-                }\n-                PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n-            },\n+            node,\n             span: p.span,\n         })\n     }"}, {"sha": "66f34a72edf2d4fce674ae9c15ba32a980861595", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=38f4d557d0c227230a580b328ded5c06a4a20509", "patch": "@@ -737,6 +737,7 @@ impl EarlyLintPass for IllegalFloatLiteralPattern {\n                 PatKind::TupleStruct(..) |\n                 PatKind::Ref(..) |\n                 PatKind::Box(..) |\n+                PatKind::Paren(..) |\n                 PatKind::Slice(..) => (),\n \n                 // Extract the expressions and check them"}, {"sha": "40000bc378ed0aba6c22f44ee291bae5385b5d9e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=38f4d557d0c227230a580b328ded5c06a4a20509", "patch": "@@ -562,7 +562,7 @@ impl Pat {\n             PatKind::TupleStruct(_, ref s, _) | PatKind::Tuple(ref s, _) => {\n                 s.iter().all(|p| p.walk(it))\n             }\n-            PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n+            PatKind::Box(ref s) | PatKind::Ref(ref s, _) | PatKind::Paren(ref s) => {\n                 s.walk(it)\n             }\n             PatKind::Slice(ref before, ref slice, ref after) => {\n@@ -656,6 +656,8 @@ pub enum PatKind {\n     /// `[a, b, ..i, y, z]` is represented as:\n     ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`\n     Slice(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n+    /// Parentheses in patters used for grouping, i.e. `(PAT)`.\n+    Paren(P<Pat>),\n     /// A macro pattern; pre-expansion\n     Mac(Mac),\n }"}, {"sha": "70ea015de4e309a6b67d8af90a96979b9ef33972", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=38f4d557d0c227230a580b328ded5c06a4a20509", "patch": "@@ -449,6 +449,9 @@ declare_features! (\n \n     // Multiple patterns with `|` in `if let` and `while let`\n     (active, if_while_or_patterns, \"1.26.0\", Some(48215)),\n+\n+    // Parentheses in patterns\n+    (active, pattern_parentheses, \"1.26.0\", None),\n );\n \n declare_features! (\n@@ -1663,6 +1666,10 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, dotdoteq_in_patterns, pattern.span,\n                                    \"`..=` syntax in patterns is experimental\");\n             }\n+            PatKind::Paren(..) => {\n+                gate_feature_post!(&self, pattern_parentheses, pattern.span,\n+                                   \"parentheses in patterns are unstable\");\n+            }\n             _ => {}\n         }\n         visit::walk_pat(self, pattern)"}, {"sha": "1963ab45f1a3281e7fabf567710b07d9cbf5d4a9", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=38f4d557d0c227230a580b328ded5c06a4a20509", "patch": "@@ -1148,6 +1148,7 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                        slice.map(|x| folder.fold_pat(x)),\n                        after.move_map(|x| folder.fold_pat(x)))\n             }\n+            PatKind::Paren(inner) => PatKind::Paren(folder.fold_pat(inner)),\n             PatKind::Mac(mac) => PatKind::Mac(folder.fold_mac(mac))\n         },\n         span: folder.new_span(span)"}, {"sha": "881e3e412d4eb4052db4debcabd1a5a8fcf1e9b3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=38f4d557d0c227230a580b328ded5c06a4a20509", "patch": "@@ -3484,33 +3484,47 @@ impl<'a> Parser<'a> {\n         };\n     }\n \n-    fn parse_pat_tuple_elements(&mut self, unary_needs_comma: bool)\n-                                -> PResult<'a, (Vec<P<Pat>>, Option<usize>)> {\n-        let mut fields = vec![];\n-        let mut ddpos = None;\n+    // Parses a parenthesized list of patterns like\n+    // `()`, `(p)`, `(p,)`, `(p, q)`, or `(p, .., q)`. Returns:\n+    // - a vector of the patterns that were parsed\n+    // - an option indicating the index of the `..` element\n+    // - a boolean indicating whether a trailing comma was present.\n+    // Trailing commas are significant because (p) and (p,) are different patterns.\n+    fn parse_parenthesized_pat_list(&mut self) -> PResult<'a, (Vec<P<Pat>>, Option<usize>, bool)> {\n+        self.expect(&token::OpenDelim(token::Paren))?;\n \n-        while !self.check(&token::CloseDelim(token::Paren)) {\n-            if ddpos.is_none() && self.eat(&token::DotDot) {\n-                ddpos = Some(fields.len());\n-                if self.eat(&token::Comma) {\n-                    // `..` needs to be followed by `)` or `, pat`, `..,)` is disallowed.\n-                    fields.push(self.parse_pat()?);\n+        let mut fields = Vec::new();\n+        let mut ddpos = None;\n+        let mut trailing_comma = false;\n+        loop {\n+            if self.eat(&token::DotDot) {\n+                if ddpos.is_none() {\n+                    ddpos = Some(fields.len());\n+                } else {\n+                    // Emit a friendly error, ignore `..` and continue parsing\n+                    self.span_err(self.prev_span,\n+                                  \"`..` can only be used once per tuple or tuple struct pattern\");\n                 }\n-            } else if ddpos.is_some() && self.eat(&token::DotDot) {\n-                // Emit a friendly error, ignore `..` and continue parsing\n-                self.span_err(self.prev_span, \"`..` can only be used once per \\\n-                                               tuple or tuple struct pattern\");\n-            } else {\n+            } else if !self.check(&token::CloseDelim(token::Paren)) {\n                 fields.push(self.parse_pat()?);\n+            } else {\n+                break\n             }\n \n-            if !self.check(&token::CloseDelim(token::Paren)) ||\n-                    (unary_needs_comma && fields.len() == 1 && ddpos.is_none()) {\n-                self.expect(&token::Comma)?;\n+            trailing_comma = self.eat(&token::Comma);\n+            if !trailing_comma {\n+                break\n             }\n         }\n \n-        Ok((fields, ddpos))\n+        if ddpos == Some(fields.len()) && trailing_comma {\n+            // `..` needs to be followed by `)` or `, pat`, `..,)` is disallowed.\n+            self.span_err(self.prev_span, \"trailing comma is not permitted after `..`\");\n+        }\n+\n+        self.expect(&token::CloseDelim(token::Paren))?;\n+\n+        Ok((fields, ddpos, trailing_comma))\n     }\n \n     fn parse_pat_vec_elements(\n@@ -3714,10 +3728,12 @@ impl<'a> Parser<'a> {\n             }\n             token::OpenDelim(token::Paren) => {\n                 // Parse (pat,pat,pat,...) as tuple pattern\n-                self.bump();\n-                let (fields, ddpos) = self.parse_pat_tuple_elements(true)?;\n-                self.expect(&token::CloseDelim(token::Paren))?;\n-                pat = PatKind::Tuple(fields, ddpos);\n+                let (fields, ddpos, trailing_comma) = self.parse_parenthesized_pat_list()?;\n+                pat = if fields.len() == 1 && ddpos.is_none() && !trailing_comma {\n+                    PatKind::Paren(fields.into_iter().nth(0).unwrap())\n+                } else {\n+                    PatKind::Tuple(fields, ddpos)\n+                };\n             }\n             token::OpenDelim(token::Bracket) => {\n                 // Parse [pat,pat,...] as slice pattern\n@@ -3807,9 +3823,7 @@ impl<'a> Parser<'a> {\n                             return Err(self.fatal(\"unexpected `(` after qualified path\"));\n                         }\n                         // Parse tuple struct or enum pattern\n-                        self.bump();\n-                        let (fields, ddpos) = self.parse_pat_tuple_elements(false)?;\n-                        self.expect(&token::CloseDelim(token::Paren))?;\n+                        let (fields, ddpos, _) = self.parse_parenthesized_pat_list()?;\n                         pat = PatKind::TupleStruct(path, fields, ddpos)\n                     }\n                     _ => pat = PatKind::Path(qself, path),"}, {"sha": "77afafbb4e003525fd80f89f0d7e84d978023725", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=38f4d557d0c227230a580b328ded5c06a4a20509", "patch": "@@ -2659,6 +2659,11 @@ impl<'a> State<'a> {\n                                    |s, p| s.print_pat(p))?;\n                 self.s.word(\"]\")?;\n             }\n+            PatKind::Paren(ref inner) => {\n+                self.popen()?;\n+                self.print_pat(inner)?;\n+                self.pclose()?;\n+            }\n             PatKind::Mac(ref m) => self.print_mac(m, token::Paren)?,\n         }\n         self.ann.post(self, NodePat(pat))"}, {"sha": "5a24c61cb5aaf8588f28ab255251aadbf2e3ab40", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=38f4d557d0c227230a580b328ded5c06a4a20509", "patch": "@@ -425,7 +425,8 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n             walk_list!(visitor, visit_pat, tuple_elements);\n         }\n         PatKind::Box(ref subpattern) |\n-        PatKind::Ref(ref subpattern, _) => {\n+        PatKind::Ref(ref subpattern, _) |\n+        PatKind::Paren(ref subpattern) => {\n             visitor.visit_pat(subpattern)\n         }\n         PatKind::Ident(_, ref pth1, ref optional_subpattern) => {"}, {"sha": "07b391d327984731a650138ebccd55c624fcdc78", "filename": "src/test/parse-fail/pat-tuple-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Ftest%2Fparse-fail%2Fpat-tuple-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Ftest%2Fparse-fail%2Fpat-tuple-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-tuple-2.rs?ref=38f4d557d0c227230a580b328ded5c06a4a20509", "patch": "@@ -12,6 +12,6 @@\n \n fn main() {\n     match 0 {\n-        (pat, ..,) => {} //~ ERROR expected pattern, found `)`\n+        (pat, ..,) => {} //~ ERROR trailing comma is not permitted after `..`\n     }\n }"}, {"sha": "6d51df63e158a0c7741b9bc5f9e691297c0f53dc", "filename": "src/test/run-pass/pat-tuple-7.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Ftest%2Frun-pass%2Fpat-tuple-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Ftest%2Frun-pass%2Fpat-tuple-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpat-tuple-7.rs?ref=38f4d557d0c227230a580b328ded5c06a4a20509", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+#![feature(pattern_parentheses)]\n \n fn main() {\n     match 0 {\n-        (pat) => {} //~ ERROR expected one of `,` or `@`, found `)`\n+        (pat) => assert_eq!(pat, 0)\n     }\n }", "previous_filename": "src/test/parse-fail/pat-tuple-6.rs"}, {"sha": "29768018f0e447bb8de78c7faa4ac306f5d50e29", "filename": "src/test/ui/feature-gate-pattern_parentheses.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Ftest%2Fui%2Ffeature-gate-pattern_parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Ftest%2Fui%2Ffeature-gate-pattern_parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-pattern_parentheses.rs?ref=38f4d557d0c227230a580b328ded5c06a4a20509", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    match 0 {\n+        (pat) => {} //~ ERROR parentheses in patterns are unstable\n+    }\n+}"}, {"sha": "4fc1441a0fadde5195c3d25ed1e55f4914ca42b2", "filename": "src/test/ui/feature-gate-pattern_parentheses.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Ftest%2Fui%2Ffeature-gate-pattern_parentheses.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38f4d557d0c227230a580b328ded5c06a4a20509/src%2Ftest%2Fui%2Ffeature-gate-pattern_parentheses.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-pattern_parentheses.stderr?ref=38f4d557d0c227230a580b328ded5c06a4a20509", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: parentheses in patterns are unstable\n+  --> $DIR/feature-gate-pattern_parentheses.rs:13:9\n+   |\n+LL |         (pat) => {} //~ ERROR parentheses in patterns are unstable\n+   |         ^^^^^\n+   |\n+   = help: add #![feature(pattern_parentheses)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+If you want more information on this error, try using \"rustc --explain E0658\""}]}