{"sha": "4ce3749235fc31d15ebd444b038a9877e8c700d7", "node_id": "C_kwDOAAsO6NoAKDRjZTM3NDkyMzVmYzMxZDE1ZWJkNDQ0YjAzOGE5ODc3ZThjNzAwZDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-28T21:17:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-28T21:17:11Z"}, "message": "Auto merge of #94453 - matthiaskrgr:rollup-xv9y98j, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #92399 (fix typo in btree/vec doc: Self -> self)\n - #92823 (Tweak diagnostics)\n - #94248 (Fix ICE when passing block to while-loop condition)\n - #94414 (Fix ICE when using Box<T, A> with large A)\n - #94445 (4 - Make more use of `let_chains`)\n - #94449 (Add long explanation for E0726)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "3475f4c5d657d246d98959b6ab1a2c7c2cd8daac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3475f4c5d657d246d98959b6ab1a2c7c2cd8daac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ce3749235fc31d15ebd444b038a9877e8c700d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ce3749235fc31d15ebd444b038a9877e8c700d7", "html_url": "https://github.com/rust-lang/rust/commit/4ce3749235fc31d15ebd444b038a9877e8c700d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ce3749235fc31d15ebd444b038a9877e8c700d7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97cde9fe08804a3a5208d77f6870ad7d43f8c9c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/97cde9fe08804a3a5208d77f6870ad7d43f8c9c3", "html_url": "https://github.com/rust-lang/rust/commit/97cde9fe08804a3a5208d77f6870ad7d43f8c9c3"}, {"sha": "34657ccbe739d1263d0808e3d1b0226b9e87490a", "url": "https://api.github.com/repos/rust-lang/rust/commits/34657ccbe739d1263d0808e3d1b0226b9e87490a", "html_url": "https://github.com/rust-lang/rust/commit/34657ccbe739d1263d0808e3d1b0226b9e87490a"}], "stats": {"total": 912, "additions": 591, "deletions": 321}, "files": [{"sha": "809d64479084a389bd617c55846d2918f785227d", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -453,7 +453,18 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         };\n         for elem in place_ref.projection[base..].iter() {\n             cg_base = match elem.clone() {\n-                mir::ProjectionElem::Deref => bx.load_operand(cg_base).deref(bx.cx()),\n+                mir::ProjectionElem::Deref => {\n+                    // custom allocators can change box's abi, making it unable to be derefed directly\n+                    if cg_base.layout.ty.is_box()\n+                        && matches!(cg_base.layout.abi, Abi::Aggregate { .. } | Abi::Uninhabited)\n+                    {\n+                        let ptr = cg_base.project_field(bx, 0).project_field(bx, 0);\n+\n+                        bx.load_operand(ptr).deref(bx.cx())\n+                    } else {\n+                        bx.load_operand(cg_base).deref(bx.cx())\n+                    }\n+                }\n                 mir::ProjectionElem::Field(ref field, _) => {\n                     cg_base.project_field(bx, field.index())\n                 }"}, {"sha": "a185902123d8ab3a37cb09400ec2dd16e2421b67", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -429,6 +429,7 @@ E0720: include_str!(\"./error_codes/E0720.md\"),\n E0722: include_str!(\"./error_codes/E0722.md\"),\n E0724: include_str!(\"./error_codes/E0724.md\"),\n E0725: include_str!(\"./error_codes/E0725.md\"),\n+E0726: include_str!(\"./error_codes/E0726.md\"),\n E0727: include_str!(\"./error_codes/E0727.md\"),\n E0728: include_str!(\"./error_codes/E0728.md\"),\n E0729: include_str!(\"./error_codes/E0729.md\"),\n@@ -641,6 +642,5 @@ E0787: include_str!(\"./error_codes/E0787.md\"),\n     E0717, // rustc_promotable without stability attribute\n //  E0721, // `await` keyword\n //  E0723, // unstable feature in `const` context\n-    E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n //  E0738, // Removed; errored on `#[track_caller] fn`s in `extern \"Rust\" { ... }`.\n }"}, {"sha": "e3794327f2d4d259fd3f61a871ce4ca4830700bb", "filename": "compiler/rustc_error_codes/src/error_codes/E0726.md", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0726.md", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0726.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0726.md?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -0,0 +1,46 @@\n+An argument lifetime was elided in an async function.\n+\n+Erroneous code example:\n+\n+When a struct or a type is bound/declared with a lifetime it is important for\n+the Rust compiler to know, on usage, the lifespan of the type. When the\n+lifetime is not explicitly mentioned and the Rust Compiler cannot determine\n+the lifetime of your type, the following error occurs.\n+\n+```compile_fail,E0726\n+use futures::executor::block_on;\n+struct Content<'a> {\n+    title: &'a str,\n+    body: &'a str,\n+}\n+async fn create(content: Content) { // error: implicit elided\n+                                    // lifetime not allowed here\n+    println!(\"title: {}\", content.title);\n+    println!(\"body: {}\", content.body);\n+}\n+let content = Content { title: \"Rust\", body: \"is great!\" };\n+let future = create(content);\n+block_on(future);\n+```\n+\n+Specify desired lifetime of parameter `content` or indicate the anonymous\n+lifetime like `content: Content<'_>`. The anonymous lifetime tells the Rust\n+compiler that `content` is only needed until create function is done with\n+it's execution.\n+\n+The `implicit elision` meaning the omission of suggested lifetime that is\n+`pub async fn create<'a>(content: Content<'a>) {}` is not allowed here as\n+lifetime of the `content` can differ from current context:\n+\n+```ignore (needs futures dependency)\n+async fn create(content: Content<'_>) { // ok!\n+    println!(\"title: {}\", content.title);\n+    println!(\"body: {}\", content.body);\n+}\n+```\n+\n+Know more about lifetime elision in this [chapter][lifetime-elision] and a\n+chapter on lifetimes can be found [here][lifetimes].\n+\n+[lifetime-elision]: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision\n+[lifetimes]: https://doc.rust-lang.org/rust-by-example/scope/lifetime.html"}, {"sha": "ab3951d76830145faf03e42bbdb63b4513c95f4f", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -20,7 +20,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, PResult};\n use rustc_feature::Features;\n use rustc_parse::parser::{\n-    AttemptLocalParseRecovery, ForceCollect, Parser, RecoverColon, RecoverComma,\n+    AttemptLocalParseRecovery, CommaRecoveryMode, ForceCollect, Parser, RecoverColon, RecoverComma,\n };\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::{UNUSED_ATTRIBUTES, UNUSED_DOC_COMMENTS};\n@@ -911,6 +911,7 @@ pub fn parse_ast_fragment<'a>(\n             None,\n             RecoverComma::No,\n             RecoverColon::Yes,\n+            CommaRecoveryMode::LikelyTuple,\n         )?),\n         AstFragmentKind::Crate => AstFragment::Crate(this.parse_crate_mod()?),\n         AstFragmentKind::Arms"}, {"sha": "8318aec8726dc801a19d906ed84e259aebab00fe", "filename": "compiler/rustc_parse/src/lexer/tokentrees.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -282,14 +282,13 @@ struct TokenStreamBuilder {\n \n impl TokenStreamBuilder {\n     fn push(&mut self, (tree, joint): TreeAndSpacing) {\n-        if let Some((TokenTree::Token(prev_token), Joint)) = self.buf.last() {\n-            if let TokenTree::Token(token) = &tree {\n-                if let Some(glued) = prev_token.glue(token) {\n-                    self.buf.pop();\n-                    self.buf.push((TokenTree::Token(glued), joint));\n-                    return;\n-                }\n-            }\n+        if let Some((TokenTree::Token(prev_token), Joint)) = self.buf.last()\n+            && let TokenTree::Token(token) = &tree\n+            && let Some(glued) = prev_token.glue(token)\n+        {\n+            self.buf.pop();\n+            self.buf.push((TokenTree::Token(glued), joint));\n+            return;\n         }\n         self.buf.push((tree, joint))\n     }"}, {"sha": "5c95a9e7bb616bcea659745ab0d855cd71f9e467", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -1,9 +1,10 @@\n //! The main parser interface.\n \n #![feature(array_windows)]\n+#![feature(box_patterns)]\n #![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n-#![feature(box_patterns)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "c92785bd9afebd67799707008ea881dcd33d0598", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 78, "deletions": 53, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -1,8 +1,8 @@\n use super::pat::Expected;\n use super::ty::{AllowPlus, IsAsCast};\n use super::{\n-    BlockMode, Parser, PathStyle, RecoverColon, RecoverComma, Restrictions, SemiColonMode, SeqSep,\n-    TokenExpectType, TokenType,\n+    BlockMode, CommaRecoveryMode, Parser, PathStyle, RecoverColon, RecoverComma, Restrictions,\n+    SemiColonMode, SeqSep, TokenExpectType, TokenType,\n };\n \n use rustc_ast as ast;\n@@ -732,43 +732,42 @@ impl<'a> Parser<'a> {\n         mut e: DiagnosticBuilder<'a, ErrorReported>,\n         expr: &mut P<Expr>,\n     ) -> PResult<'a, ()> {\n-        if let ExprKind::Binary(binop, _, _) = &expr.kind {\n-            if let ast::BinOpKind::Lt = binop.node {\n-                if self.eat(&token::Comma) {\n-                    let x = self.parse_seq_to_before_end(\n-                        &token::Gt,\n-                        SeqSep::trailing_allowed(token::Comma),\n-                        |p| p.parse_generic_arg(None),\n-                    );\n-                    match x {\n-                        Ok((_, _, false)) => {\n-                            if self.eat(&token::Gt) {\n-                                e.span_suggestion_verbose(\n-                                    binop.span.shrink_to_lo(),\n-                                    TURBOFISH_SUGGESTION_STR,\n-                                    \"::\".to_string(),\n-                                    Applicability::MaybeIncorrect,\n-                                )\n-                                .emit();\n-                                match self.parse_expr() {\n-                                    Ok(_) => {\n-                                        *expr =\n-                                            self.mk_expr_err(expr.span.to(self.prev_token.span));\n-                                        return Ok(());\n-                                    }\n-                                    Err(err) => {\n-                                        *expr = self.mk_expr_err(expr.span);\n-                                        err.cancel();\n-                                    }\n-                                }\n+        if let ExprKind::Binary(binop, _, _) = &expr.kind\n+            && let ast::BinOpKind::Lt = binop.node\n+            && self.eat(&token::Comma)\n+        {\n+            let x = self.parse_seq_to_before_end(\n+                &token::Gt,\n+                SeqSep::trailing_allowed(token::Comma),\n+                |p| p.parse_generic_arg(None),\n+            );\n+            match x {\n+                Ok((_, _, false)) => {\n+                    if self.eat(&token::Gt) {\n+                        e.span_suggestion_verbose(\n+                            binop.span.shrink_to_lo(),\n+                            TURBOFISH_SUGGESTION_STR,\n+                            \"::\".to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n+                        match self.parse_expr() {\n+                            Ok(_) => {\n+                                *expr =\n+                                    self.mk_expr_err(expr.span.to(self.prev_token.span));\n+                                return Ok(());\n+                            }\n+                            Err(err) => {\n+                                *expr = self.mk_expr_err(expr.span);\n+                                err.cancel();\n                             }\n                         }\n-                        Err(err) => {\n-                            err.cancel();\n-                        }\n-                        _ => {}\n                     }\n                 }\n+                Err(err) => {\n+                    err.cancel();\n+                }\n+                _ => {}\n             }\n         }\n         Err(e)\n@@ -784,12 +783,13 @@ impl<'a> Parser<'a> {\n         outer_op: &Spanned<AssocOp>,\n     ) -> bool /* advanced the cursor */ {\n         if let ExprKind::Binary(op, ref l1, ref r1) = inner_op.kind {\n-            if let ExprKind::Field(_, ident) = l1.kind {\n-                if ident.as_str().parse::<i32>().is_err() && !matches!(r1.kind, ExprKind::Lit(_)) {\n-                    // The parser has encountered `foo.bar<baz`, the likelihood of the turbofish\n-                    // suggestion being the only one to apply is high.\n-                    return false;\n-                }\n+            if let ExprKind::Field(_, ident) = l1.kind\n+                && ident.as_str().parse::<i32>().is_err()\n+                && !matches!(r1.kind, ExprKind::Lit(_))\n+            {\n+                // The parser has encountered `foo.bar<baz`, the likelihood of the turbofish\n+                // suggestion being the only one to apply is high.\n+                return false;\n             }\n             let mut enclose = |left: Span, right: Span| {\n                 err.multipart_suggestion(\n@@ -2245,12 +2245,32 @@ impl<'a> Parser<'a> {\n         first_pat\n     }\n \n+    crate fn maybe_recover_unexpected_block_label(&mut self) -> bool {\n+        let Some(label) = self.eat_label().filter(|_| {\n+            self.eat(&token::Colon) && self.token.kind == token::OpenDelim(token::Brace)\n+        }) else {\n+            return false;\n+        };\n+        let span = label.ident.span.to(self.prev_token.span);\n+        let mut err = self.struct_span_err(span, \"block label not supported here\");\n+        err.span_label(span, \"not supported here\");\n+        err.tool_only_span_suggestion(\n+            label.ident.span.until(self.token.span),\n+            \"remove this block label\",\n+            String::new(),\n+            Applicability::MachineApplicable,\n+        );\n+        err.emit();\n+        true\n+    }\n+\n     /// Some special error handling for the \"top-level\" patterns in a match arm,\n     /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n     crate fn maybe_recover_unexpected_comma(\n         &mut self,\n         lo: Span,\n         rc: RecoverComma,\n+        rt: CommaRecoveryMode,\n     ) -> PResult<'a, ()> {\n         if rc == RecoverComma::No || self.token != token::Comma {\n             return Ok(());\n@@ -2270,20 +2290,25 @@ impl<'a> Parser<'a> {\n         let seq_span = lo.to(self.prev_token.span);\n         let mut err = self.struct_span_err(comma_span, \"unexpected `,` in pattern\");\n         if let Ok(seq_snippet) = self.span_to_snippet(seq_span) {\n-            const MSG: &str = \"try adding parentheses to match on a tuple...\";\n-\n-            err.span_suggestion(\n-                seq_span,\n-                MSG,\n-                format!(\"({})\", seq_snippet),\n-                Applicability::MachineApplicable,\n-            );\n-            err.span_suggestion(\n-                seq_span,\n-                \"...or a vertical bar to match on multiple alternatives\",\n-                seq_snippet.replace(',', \" |\"),\n+            err.multipart_suggestion(\n+                &format!(\n+                    \"try adding parentheses to match on a tuple{}\",\n+                    if let CommaRecoveryMode::LikelyTuple = rt { \"\" } else { \"...\" },\n+                ),\n+                vec![\n+                    (seq_span.shrink_to_lo(), \"(\".to_string()),\n+                    (seq_span.shrink_to_hi(), \")\".to_string()),\n+                ],\n                 Applicability::MachineApplicable,\n             );\n+            if let CommaRecoveryMode::EitherTupleOrPipe = rt {\n+                err.span_suggestion(\n+                    seq_span,\n+                    \"...or a vertical bar to match on multiple alternatives\",\n+                    seq_snippet.replace(',', \" |\"),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n         }\n         Err(err)\n     }"}, {"sha": "a54ab4a92e1b81898360dc3d47da14b893fa9459", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 46, "deletions": 10, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -1,4 +1,4 @@\n-use super::pat::{RecoverColon, RecoverComma, PARAM_EXPECTED};\n+use super::pat::{CommaRecoveryMode, RecoverColon, RecoverComma, PARAM_EXPECTED};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{\n     AttrWrapper, BlockMode, ClosureSpans, ForceCollect, Parser, PathStyle, Restrictions, TokenType,\n@@ -1286,18 +1286,27 @@ impl<'a> Parser<'a> {\n         } else if let Some(label) = self.eat_label() {\n             self.parse_labeled_expr(label, attrs, true)\n         } else if self.eat_keyword(kw::Loop) {\n-            self.parse_loop_expr(None, self.prev_token.span, attrs)\n+            let sp = self.prev_token.span;\n+            self.parse_loop_expr(None, self.prev_token.span, attrs).map_err(|mut err| {\n+                err.span_label(sp, \"while parsing this `loop` expression\");\n+                err\n+            })\n         } else if self.eat_keyword(kw::Continue) {\n             let kind = ExprKind::Continue(self.eat_label());\n             Ok(self.mk_expr(lo.to(self.prev_token.span), kind, attrs))\n         } else if self.eat_keyword(kw::Match) {\n             let match_sp = self.prev_token.span;\n             self.parse_match_expr(attrs).map_err(|mut err| {\n-                err.span_label(match_sp, \"while parsing this match expression\");\n+                err.span_label(match_sp, \"while parsing this `match` expression\");\n                 err\n             })\n         } else if self.eat_keyword(kw::Unsafe) {\n+            let sp = self.prev_token.span;\n             self.parse_block_expr(None, lo, BlockCheckMode::Unsafe(ast::UserProvided), attrs)\n+                .map_err(|mut err| {\n+                    err.span_label(sp, \"while parsing this `unsafe` expression\");\n+                    err\n+                })\n         } else if self.check_inline_const(0) {\n             self.parse_const_block(lo.to(self.token.span), false)\n         } else if self.is_do_catch_block() {\n@@ -2160,7 +2169,12 @@ impl<'a> Parser<'a> {\n     /// The `let` token has already been eaten.\n     fn parse_let_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n-        let pat = self.parse_pat_allow_top_alt(None, RecoverComma::Yes, RecoverColon::Yes)?;\n+        let pat = self.parse_pat_allow_top_alt(\n+            None,\n+            RecoverComma::Yes,\n+            RecoverColon::Yes,\n+            CommaRecoveryMode::LikelyTuple,\n+        )?;\n         self.expect(&token::Eq)?;\n         let expr = self.with_res(self.restrictions | Restrictions::NO_STRUCT_LITERAL, |this| {\n             this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n@@ -2223,7 +2237,12 @@ impl<'a> Parser<'a> {\n             _ => None,\n         };\n \n-        let pat = self.parse_pat_allow_top_alt(None, RecoverComma::Yes, RecoverColon::Yes)?;\n+        let pat = self.parse_pat_allow_top_alt(\n+            None,\n+            RecoverComma::Yes,\n+            RecoverColon::Yes,\n+            CommaRecoveryMode::LikelyTuple,\n+        )?;\n         if !self.eat_keyword(kw::In) {\n             self.error_missing_in_for_loop();\n         }\n@@ -2266,8 +2285,15 @@ impl<'a> Parser<'a> {\n         lo: Span,\n         mut attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n-        let cond = self.parse_cond_expr()?;\n-        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n+        let cond = self.parse_cond_expr().map_err(|mut err| {\n+            err.span_label(lo, \"while parsing the condition of this `while` expression\");\n+            err\n+        })?;\n+        let (iattrs, body) = self.parse_inner_attrs_and_block().map_err(|mut err| {\n+            err.span_label(lo, \"while parsing the body of this `while` expression\");\n+            err.span_label(cond.span, \"this `while` condition successfully parsed\");\n+            err\n+        })?;\n         attrs.extend(iattrs);\n         Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::While(cond, body, opt_label), attrs))\n     }\n@@ -2284,7 +2310,7 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::Loop(body, opt_label), attrs))\n     }\n \n-    fn eat_label(&mut self) -> Option<Label> {\n+    crate fn eat_label(&mut self) -> Option<Label> {\n         self.token.lifetime().map(|ident| {\n             self.bump();\n             Label { ident }\n@@ -2305,7 +2331,12 @@ impl<'a> Parser<'a> {\n                     Applicability::MaybeIncorrect, // speculative\n                 );\n             }\n-            return Err(e);\n+            if self.maybe_recover_unexpected_block_label() {\n+                e.cancel();\n+                self.bump();\n+            } else {\n+                return Err(e);\n+            }\n         }\n         attrs.extend(self.parse_inner_attributes()?);\n \n@@ -2441,7 +2472,12 @@ impl<'a> Parser<'a> {\n         let attrs = self.parse_outer_attributes()?;\n         self.collect_tokens_trailing_token(attrs, ForceCollect::No, |this, attrs| {\n             let lo = this.token.span;\n-            let pat = this.parse_pat_allow_top_alt(None, RecoverComma::Yes, RecoverColon::Yes)?;\n+            let pat = this.parse_pat_allow_top_alt(\n+                None,\n+                RecoverComma::Yes,\n+                RecoverColon::Yes,\n+                CommaRecoveryMode::EitherTupleOrPipe,\n+            )?;\n             let guard = if this.eat_keyword(kw::If) {\n                 let if_span = this.prev_token.span;\n                 let cond = this.parse_expr()?;"}, {"sha": "af5cc0e0948680414fd85556a29ff01672c95da8", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -102,14 +102,12 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, Option<Item>> {\n         // Don't use `maybe_whole` so that we have precise control\n         // over when we bump the parser\n-        if let token::Interpolated(nt) = &self.token.kind {\n-            if let token::NtItem(item) = &**nt {\n-                let mut item = item.clone();\n-                self.bump();\n+        if let token::Interpolated(nt) = &self.token.kind && let token::NtItem(item) = &**nt {\n+            let mut item = item.clone();\n+            self.bump();\n \n-                attrs.prepend_to_nt_inner(&mut item.attrs);\n-                return Ok(Some(item.into_inner()));\n-            }\n+            attrs.prepend_to_nt_inner(&mut item.attrs);\n+            return Ok(Some(item.into_inner()));\n         };\n \n         let mut unclosed_delims = vec![];"}, {"sha": "9d85be93b1dd787986d8a1ffa452f966e3718601", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -15,7 +15,7 @@ pub use attr_wrapper::AttrWrapper;\n pub use diagnostics::AttemptLocalParseRecovery;\n use diagnostics::Error;\n pub(crate) use item::FnParseMode;\n-pub use pat::{RecoverColon, RecoverComma};\n+pub use pat::{CommaRecoveryMode, RecoverColon, RecoverComma};\n pub use path::PathStyle;\n \n use rustc_ast::ptr::P;\n@@ -97,15 +97,15 @@ macro_rules! maybe_whole {\n #[macro_export]\n macro_rules! maybe_recover_from_interpolated_ty_qpath {\n     ($self: expr, $allow_qpath_recovery: expr) => {\n-        if $allow_qpath_recovery && $self.look_ahead(1, |t| t == &token::ModSep) {\n-            if let token::Interpolated(nt) = &$self.token.kind {\n-                if let token::NtTy(ty) = &**nt {\n+        if $allow_qpath_recovery\n+                    && $self.look_ahead(1, |t| t == &token::ModSep)\n+                    && let token::Interpolated(nt) = &$self.token.kind\n+                    && let token::NtTy(ty) = &**nt\n+                {\n                     let ty = ty.clone();\n                     $self.bump();\n                     return $self.maybe_recover_from_bad_qpath_stage_2($self.prev_token.span, ty);\n                 }\n-            }\n-        }\n     };\n }\n "}, {"sha": "83e0a4997ad85020b539b5d61a67a513d86a5cbe", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -5,7 +5,7 @@ use rustc_ast_pretty::pprust;\n use rustc_errors::PResult;\n use rustc_span::symbol::{kw, Ident};\n \n-use crate::parser::pat::{RecoverColon, RecoverComma};\n+use crate::parser::pat::{CommaRecoveryMode, RecoverColon, RecoverComma};\n use crate::parser::{FollowedByType, ForceCollect, Parser, PathStyle};\n \n impl<'a> Parser<'a> {\n@@ -125,7 +125,7 @@ impl<'a> Parser<'a> {\n                 token::NtPat(self.collect_tokens_no_attrs(|this| match kind {\n                     NonterminalKind::PatParam { .. } => this.parse_pat_no_top_alt(None),\n                     NonterminalKind::PatWithOr { .. } => {\n-                        this.parse_pat_allow_top_alt(None, RecoverComma::No, RecoverColon::No)\n+                        this.parse_pat_allow_top_alt(None, RecoverComma::No, RecoverColon::No, CommaRecoveryMode::EitherTupleOrPipe)\n                     }\n                     _ => unreachable!(),\n                 })?)"}, {"sha": "ff536d15cbfca6194e5783c151f1d7b0b26109ca", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -33,6 +33,13 @@ pub enum RecoverColon {\n     No,\n }\n \n+/// Whether or not to recover a `a, b` when parsing patterns as `(a, b)` or that *and* `a | b`.\n+#[derive(PartialEq, Copy, Clone)]\n+pub enum CommaRecoveryMode {\n+    LikelyTuple,\n+    EitherTupleOrPipe,\n+}\n+\n /// The result of `eat_or_separator`. We want to distinguish which case we are in to avoid\n /// emitting duplicate diagnostics.\n #[derive(Debug, Clone, Copy)]\n@@ -68,8 +75,9 @@ impl<'a> Parser<'a> {\n         expected: Expected,\n         rc: RecoverComma,\n         ra: RecoverColon,\n+        rt: CommaRecoveryMode,\n     ) -> PResult<'a, P<Pat>> {\n-        self.parse_pat_allow_top_alt_inner(expected, rc, ra).map(|(pat, _)| pat)\n+        self.parse_pat_allow_top_alt_inner(expected, rc, ra, rt).map(|(pat, _)| pat)\n     }\n \n     /// Returns the pattern and a bool indicating whether we recovered from a trailing vert (true =\n@@ -79,6 +87,7 @@ impl<'a> Parser<'a> {\n         expected: Expected,\n         rc: RecoverComma,\n         ra: RecoverColon,\n+        rt: CommaRecoveryMode,\n     ) -> PResult<'a, (P<Pat>, bool)> {\n         // Keep track of whether we recovered from a trailing vert so that we can avoid duplicated\n         // suggestions (which bothers rustfix).\n@@ -92,7 +101,7 @@ impl<'a> Parser<'a> {\n \n         // Parse the first pattern (`p_0`).\n         let first_pat = self.parse_pat_no_top_alt(expected)?;\n-        self.maybe_recover_unexpected_comma(first_pat.span, rc)?;\n+        self.maybe_recover_unexpected_comma(first_pat.span, rc, rt)?;\n \n         // If the next token is not a `|`,\n         // this is not an or-pattern and we should exit here.\n@@ -130,7 +139,7 @@ impl<'a> Parser<'a> {\n                 err.span_label(lo, WHILE_PARSING_OR_MSG);\n                 err\n             })?;\n-            self.maybe_recover_unexpected_comma(pat.span, rc)?;\n+            self.maybe_recover_unexpected_comma(pat.span, rc, rt)?;\n             pats.push(pat);\n         }\n         let or_pattern_span = lo.to(self.prev_token.span);\n@@ -155,8 +164,12 @@ impl<'a> Parser<'a> {\n         // We use `parse_pat_allow_top_alt` regardless of whether we actually want top-level\n         // or-patterns so that we can detect when a user tries to use it. This allows us to print a\n         // better error message.\n-        let (pat, trailing_vert) =\n-            self.parse_pat_allow_top_alt_inner(expected, rc, RecoverColon::No)?;\n+        let (pat, trailing_vert) = self.parse_pat_allow_top_alt_inner(\n+            expected,\n+            rc,\n+            RecoverColon::No,\n+            CommaRecoveryMode::LikelyTuple,\n+        )?;\n         let colon = self.eat(&token::Colon);\n \n         if let PatKind::Or(pats) = &pat.kind {\n@@ -315,7 +328,12 @@ impl<'a> Parser<'a> {\n         } else if self.check(&token::OpenDelim(token::Bracket)) {\n             // Parse `[pat, pat,...]` as a slice pattern.\n             let (pats, _) = self.parse_delim_comma_seq(token::Bracket, |p| {\n-                p.parse_pat_allow_top_alt(None, RecoverComma::No, RecoverColon::No)\n+                p.parse_pat_allow_top_alt(\n+                    None,\n+                    RecoverComma::No,\n+                    RecoverColon::No,\n+                    CommaRecoveryMode::EitherTupleOrPipe,\n+                )\n             })?;\n             PatKind::Slice(pats)\n         } else if self.check(&token::DotDot) && !self.is_pat_range_end_start(1) {\n@@ -529,7 +547,12 @@ impl<'a> Parser<'a> {\n     /// Parse a tuple or parenthesis pattern.\n     fn parse_pat_tuple_or_parens(&mut self) -> PResult<'a, PatKind> {\n         let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| {\n-            p.parse_pat_allow_top_alt(None, RecoverComma::No, RecoverColon::No)\n+            p.parse_pat_allow_top_alt(\n+                None,\n+                RecoverComma::No,\n+                RecoverColon::No,\n+                CommaRecoveryMode::LikelyTuple,\n+            )\n         })?;\n \n         // Here, `(pat,)` is a tuple pattern.\n@@ -873,7 +896,12 @@ impl<'a> Parser<'a> {\n     /// Parse tuple struct or tuple variant pattern (e.g. `Foo(...)` or `Foo::Bar(...)`).\n     fn parse_pat_tuple_struct(&mut self, qself: Option<QSelf>, path: Path) -> PResult<'a, PatKind> {\n         let (fields, _) = self.parse_paren_comma_seq(|p| {\n-            p.parse_pat_allow_top_alt(None, RecoverComma::No, RecoverColon::No)\n+            p.parse_pat_allow_top_alt(\n+                None,\n+                RecoverComma::No,\n+                RecoverColon::No,\n+                CommaRecoveryMode::EitherTupleOrPipe,\n+            )\n         })?;\n         if qself.is_some() {\n             self.sess.gated_spans.gate(sym::more_qualified_paths, path.span);\n@@ -1033,7 +1061,12 @@ impl<'a> Parser<'a> {\n             // Parsing a pattern of the form `fieldname: pat`.\n             let fieldname = self.parse_field_name()?;\n             self.bump();\n-            let pat = self.parse_pat_allow_top_alt(None, RecoverComma::No, RecoverColon::No)?;\n+            let pat = self.parse_pat_allow_top_alt(\n+                None,\n+                RecoverComma::No,\n+                RecoverColon::No,\n+                CommaRecoveryMode::EitherTupleOrPipe,\n+            )?;\n             hi = pat.span;\n             (pat, fieldname, false)\n         } else {"}, {"sha": "5e537d7b95c4a082d66a342876c62fd11d259c09", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -658,13 +658,13 @@ impl<'a> Parser<'a> {\n         &self,\n         gen_arg: GenericArg,\n     ) -> Result<(Ident, Option<GenericArgs>), GenericArg> {\n-        if let GenericArg::Type(ty) = &gen_arg {\n-            if let ast::TyKind::Path(qself, path) = &ty.kind {\n-                if qself.is_none() && path.segments.len() == 1 {\n-                    let seg = &path.segments[0];\n-                    return Ok((seg.ident, seg.args.as_deref().cloned()));\n-                }\n-            }\n+        if let GenericArg::Type(ty) = &gen_arg\n+            && let ast::TyKind::Path(qself, path) = &ty.kind\n+            && qself.is_none()\n+            && path.segments.len() == 1\n+        {\n+            let seg = &path.segments[0];\n+            return Ok((seg.ident, seg.args.as_deref().cloned()));\n         }\n         Err(gen_arg)\n     }"}, {"sha": "e39e32ff364fa25aac26b46f3fc1980b7610a4cc", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -48,15 +48,13 @@ impl<'a> Parser<'a> {\n \n         // Don't use `maybe_whole` so that we have precise control\n         // over when we bump the parser\n-        if let token::Interpolated(nt) = &self.token.kind {\n-            if let token::NtStmt(stmt) = &**nt {\n-                let mut stmt = stmt.clone();\n-                self.bump();\n-                stmt.visit_attrs(|stmt_attrs| {\n-                    attrs.prepend_to_nt_inner(stmt_attrs);\n-                });\n-                return Ok(Some(stmt));\n-            }\n+        if let token::Interpolated(nt) = &self.token.kind && let token::NtStmt(stmt) = &**nt {\n+            let mut stmt = stmt.clone();\n+            self.bump();\n+            stmt.visit_attrs(|stmt_attrs| {\n+                attrs.prepend_to_nt_inner(stmt_attrs);\n+            });\n+            return Ok(Some(stmt));\n         }\n \n         Ok(Some(if self.token.is_keyword(kw::Let) {\n@@ -434,6 +432,8 @@ impl<'a> Parser<'a> {\n             Ok(Some(_))\n                 if self.look_ahead(1, |t| t == &token::OpenDelim(token::Brace))\n                     || do_not_suggest_help => {}\n+            // Do not suggest `if foo println!(\"\") {;}` (as would be seen in test for #46836).\n+            Ok(Some(Stmt { kind: StmtKind::Empty, .. })) => {}\n             Ok(Some(stmt)) => {\n                 let stmt_own_line = self.sess.source_map().is_line_before_span_empty(sp);\n                 let stmt_span = if stmt_own_line && self.eat(&token::Semi) {\n@@ -442,15 +442,15 @@ impl<'a> Parser<'a> {\n                 } else {\n                     stmt.span\n                 };\n-                if let Ok(snippet) = self.span_to_snippet(stmt_span) {\n-                    e.span_suggestion(\n-                        stmt_span,\n-                        \"try placing this code inside a block\",\n-                        format!(\"{{ {} }}\", snippet),\n-                        // Speculative; has been misleading in the past (#46836).\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n+                e.multipart_suggestion(\n+                    \"try placing this code inside a block\",\n+                    vec![\n+                        (stmt_span.shrink_to_lo(), \"{ \".to_string()),\n+                        (stmt_span.shrink_to_hi(), \" }\".to_string()),\n+                    ],\n+                    // Speculative; has been misleading in the past (#46836).\n+                    Applicability::MaybeIncorrect,\n+                );\n             }\n             Err(e) => {\n                 self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n@@ -483,15 +483,15 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n         maybe_whole!(self, NtBlock, |x| (Vec::new(), x));\n \n+        self.maybe_recover_unexpected_block_label();\n         if !self.eat(&token::OpenDelim(token::Brace)) {\n             return self.error_block_no_opening_brace();\n         }\n \n         let attrs = self.parse_inner_attributes()?;\n-        let tail = if let Some(tail) = self.maybe_suggest_struct_literal(lo, blk_mode) {\n-            tail?\n-        } else {\n-            self.parse_block_tail(lo, blk_mode, AttemptLocalParseRecovery::Yes)?\n+        let tail = match self.maybe_suggest_struct_literal(lo, blk_mode) {\n+            Some(tail) => tail?,\n+            None => self.parse_block_tail(lo, blk_mode, AttemptLocalParseRecovery::Yes)?,\n         };\n         Ok((attrs, tail))\n     }\n@@ -587,11 +587,11 @@ impl<'a> Parser<'a> {\n                 // We might be at the `,` in `let x = foo<bar, baz>;`. Try to recover.\n                 match &mut local.kind {\n                     LocalKind::Init(expr) | LocalKind::InitElse(expr, _) => {\n-                            self.check_mistyped_turbofish_with_multiple_type_params(e, expr)?;\n-                            // We found `foo<bar, baz>`, have we fully recovered?\n-                            self.expect_semi()?;\n-                        }\n-                        LocalKind::Decl => return Err(e),\n+                        self.check_mistyped_turbofish_with_multiple_type_params(e, expr)?;\n+                        // We found `foo<bar, baz>`, have we fully recovered?\n+                        self.expect_semi()?;\n+                    }\n+                    LocalKind::Decl => return Err(e),\n                 }\n                 eat_semi = false;\n             }"}, {"sha": "f3aa40b9ad11e9f5a86fa56202c0c63ca41abe58", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -840,7 +840,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         err.span_label(lhs.span, \"cannot assign to this expression\");\n \n-        let mut parent = self.tcx.hir().get_parent_node(lhs.hir_id);\n+        self.comes_from_while_condition(lhs.hir_id, |expr| {\n+            err.span_suggestion_verbose(\n+                expr.span.shrink_to_lo(),\n+                \"you might have meant to use pattern destructuring\",\n+                \"let \".to_string(),\n+                Applicability::MachineApplicable,\n+            );\n+        });\n+\n+        err.emit();\n+    }\n+\n+    // Check if an expression `original_expr_id` comes from the condition of a while loop,\n+    // as opposed from the body of a while loop, which we can naively check by iterating\n+    // parents until we find a loop...\n+    pub(super) fn comes_from_while_condition(\n+        &self,\n+        original_expr_id: HirId,\n+        then: impl FnOnce(&hir::Expr<'_>),\n+    ) {\n+        let mut parent = self.tcx.hir().get_parent_node(original_expr_id);\n         while let Some(node) = self.tcx.hir().find(parent) {\n             match node {\n                 hir::Node::Expr(hir::Expr {\n@@ -861,21 +881,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ),\n                     ..\n                 }) => {\n-                    // Check if our lhs is a child of the condition of a while loop\n-                    let expr_is_ancestor = std::iter::successors(Some(lhs.hir_id), |id| {\n+                    // Check if our original expression is a child of the condition of a while loop\n+                    let expr_is_ancestor = std::iter::successors(Some(original_expr_id), |id| {\n                         self.tcx.hir().find_parent_node(*id)\n                     })\n                     .take_while(|id| *id != parent)\n                     .any(|id| id == expr.hir_id);\n                     // if it is, then we have a situation like `while Some(0) = value.get(0) {`,\n                     // where `while let` was more likely intended.\n                     if expr_is_ancestor {\n-                        err.span_suggestion_verbose(\n-                            expr.span.shrink_to_lo(),\n-                            \"you might have meant to use pattern destructuring\",\n-                            \"let \".to_string(),\n-                            Applicability::MachineApplicable,\n-                        );\n+                        then(expr);\n                     }\n                     break;\n                 }\n@@ -888,8 +903,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n         }\n-\n-        err.emit();\n     }\n \n     // A generic function for checking the 'then' and 'else' clauses in an 'if'"}, {"sha": "f5d110903e6e37e811c23f1616f42652e7ab2aec", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 74, "deletions": 60, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -768,55 +768,57 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let prev_diverges = self.diverges.get();\n         let ctxt = BreakableCtxt { coerce: Some(coerce), may_break: false };\n \n-        let (ctxt, ()) = self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n-            for (pos, s) in blk.stmts.iter().enumerate() {\n-                self.check_stmt(s, blk.stmts.len() - 1 == pos);\n-            }\n+        let (ctxt, ()) =\n+            self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n+                for (pos, s) in blk.stmts.iter().enumerate() {\n+                    self.check_stmt(s, blk.stmts.len() - 1 == pos);\n+                }\n \n-            // check the tail expression **without** holding the\n-            // `enclosing_breakables` lock below.\n-            let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n-\n-            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-            let ctxt = enclosing_breakables.find_breakable(blk.hir_id);\n-            let coerce = ctxt.coerce.as_mut().unwrap();\n-            if let Some(tail_expr_ty) = tail_expr_ty {\n-                let tail_expr = tail_expr.unwrap();\n-                let span = self.get_expr_coercion_span(tail_expr);\n-                let cause = self.cause(span, ObligationCauseCode::BlockTailExpression(blk.hir_id));\n-                coerce.coerce(self, &cause, tail_expr, tail_expr_ty);\n-            } else {\n-                // Subtle: if there is no explicit tail expression,\n-                // that is typically equivalent to a tail expression\n-                // of `()` -- except if the block diverges. In that\n-                // case, there is no value supplied from the tail\n-                // expression (assuming there are no other breaks,\n-                // this implies that the type of the block will be\n-                // `!`).\n-                //\n-                // #41425 -- label the implicit `()` as being the\n-                // \"found type\" here, rather than the \"expected type\".\n-                if !self.diverges.get().is_always() {\n-                    // #50009 -- Do not point at the entire fn block span, point at the return type\n-                    // span, as it is the cause of the requirement, and\n-                    // `consider_hint_about_removing_semicolon` will point at the last expression\n-                    // if it were a relevant part of the error. This improves usability in editors\n-                    // that highlight errors inline.\n-                    let mut sp = blk.span;\n-                    let mut fn_span = None;\n-                    if let Some((decl, ident)) = self.get_parent_fn_decl(blk.hir_id) {\n-                        let ret_sp = decl.output.span();\n-                        if let Some(block_sp) = self.parent_item_span(blk.hir_id) {\n-                            // HACK: on some cases (`ui/liveness/liveness-issue-2163.rs`) the\n-                            // output would otherwise be incorrect and even misleading. Make sure\n-                            // the span we're aiming at correspond to a `fn` body.\n-                            if block_sp == blk.span {\n-                                sp = ret_sp;\n-                                fn_span = Some(ident.span);\n+                // check the tail expression **without** holding the\n+                // `enclosing_breakables` lock below.\n+                let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n+\n+                let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                let ctxt = enclosing_breakables.find_breakable(blk.hir_id);\n+                let coerce = ctxt.coerce.as_mut().unwrap();\n+                if let Some(tail_expr_ty) = tail_expr_ty {\n+                    let tail_expr = tail_expr.unwrap();\n+                    let span = self.get_expr_coercion_span(tail_expr);\n+                    let cause =\n+                        self.cause(span, ObligationCauseCode::BlockTailExpression(blk.hir_id));\n+                    coerce.coerce(self, &cause, tail_expr, tail_expr_ty);\n+                } else {\n+                    // Subtle: if there is no explicit tail expression,\n+                    // that is typically equivalent to a tail expression\n+                    // of `()` -- except if the block diverges. In that\n+                    // case, there is no value supplied from the tail\n+                    // expression (assuming there are no other breaks,\n+                    // this implies that the type of the block will be\n+                    // `!`).\n+                    //\n+                    // #41425 -- label the implicit `()` as being the\n+                    // \"found type\" here, rather than the \"expected type\".\n+                    if !self.diverges.get().is_always() {\n+                        // #50009 -- Do not point at the entire fn block span, point at the return type\n+                        // span, as it is the cause of the requirement, and\n+                        // `consider_hint_about_removing_semicolon` will point at the last expression\n+                        // if it were a relevant part of the error. This improves usability in editors\n+                        // that highlight errors inline.\n+                        let mut sp = blk.span;\n+                        let mut fn_span = None;\n+                        if let Some((decl, ident)) = self.get_parent_fn_decl(blk.hir_id) {\n+                            let ret_sp = decl.output.span();\n+                            if let Some(block_sp) = self.parent_item_span(blk.hir_id) {\n+                                // HACK: on some cases (`ui/liveness/liveness-issue-2163.rs`) the\n+                                // output would otherwise be incorrect and even misleading. Make sure\n+                                // the span we're aiming at correspond to a `fn` body.\n+                                if block_sp == blk.span {\n+                                    sp = ret_sp;\n+                                    fn_span = Some(ident.span);\n+                                }\n                             }\n                         }\n-                    }\n-                    coerce.coerce_forced_unit(\n+                        coerce.coerce_forced_unit(\n                         self,\n                         &self.misc(sp),\n                         &mut |err| {\n@@ -825,19 +827,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 if expected_ty == self.tcx.types.bool {\n                                     // If this is caused by a missing `let` in a `while let`,\n                                     // silence this redundant error, as we already emit E0070.\n-                                    let parent = self.tcx.hir().get_parent_node(blk.hir_id);\n-                                    let parent = self.tcx.hir().get_parent_node(parent);\n-                                    let parent = self.tcx.hir().get_parent_node(parent);\n-                                    let parent = self.tcx.hir().get_parent_node(parent);\n-                                    let parent = self.tcx.hir().get_parent_node(parent);\n-                                    match self.tcx.hir().find(parent) {\n-                                        Some(hir::Node::Expr(hir::Expr {\n-                                            kind: hir::ExprKind::Loop(_, _, hir::LoopSource::While, _),\n-                                            ..\n-                                        })) => {\n+\n+                                    // Our block must be a `assign desugar local; assignment`\n+                                    if let Some(hir::Node::Block(hir::Block {\n+                                        stmts:\n+                                            [hir::Stmt {\n+                                                kind:\n+                                                    hir::StmtKind::Local(hir::Local {\n+                                                        source: hir::LocalSource::AssignDesugar(_),\n+                                                        ..\n+                                                    }),\n+                                                ..\n+                                            }, hir::Stmt {\n+                                                kind:\n+                                                    hir::StmtKind::Expr(hir::Expr {\n+                                                        kind: hir::ExprKind::Assign(..),\n+                                                        ..\n+                                                    }),\n+                                                ..\n+                                            }],\n+                                        ..\n+                                    })) = self.tcx.hir().find(blk.hir_id)\n+                                    {\n+                                        self.comes_from_while_condition(blk.hir_id, |_| {\n                                             err.downgrade_to_delayed_bug();\n-                                        }\n-                                        _ => {}\n+                                        })\n                                     }\n                                 }\n                             }\n@@ -851,9 +865,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         },\n                         false,\n                     );\n+                    }\n                 }\n-            }\n-        });\n+            });\n \n         if ctxt.may_break {\n             // If we can break from the block, then the block's exit is always reachable"}, {"sha": "7890c1040f0a18a08496cd5cbcde446fdc755a36", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -986,7 +986,7 @@ impl<K, V> BTreeMap<K, V> {\n         self.drain_filter(|k, v| !f(k, v));\n     }\n \n-    /// Moves all elements from `other` into `Self`, leaving `other` empty.\n+    /// Moves all elements from `other` into `self`, leaving `other` empty.\n     ///\n     /// # Examples\n     ///"}, {"sha": "bab6af826986421a57a6fb0782abd86b7265ead3", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -895,7 +895,7 @@ impl<T> BTreeSet<T> {\n         self.drain_filter(|v| !f(v));\n     }\n \n-    /// Moves all elements from `other` into `Self`, leaving `other` empty.\n+    /// Moves all elements from `other` into `self`, leaving `other` empty.\n     ///\n     /// # Examples\n     ///"}, {"sha": "c4c393f55eee9f8aeaa980976fefec890d1d4c78", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -1763,7 +1763,7 @@ impl<T, A: Allocator> Vec<T, A> {\n         }\n     }\n \n-    /// Moves all the elements of `other` into `Self`, leaving `other` empty.\n+    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n     ///\n     /// # Panics\n     ///\n@@ -1788,7 +1788,7 @@ impl<T, A: Allocator> Vec<T, A> {\n         }\n     }\n \n-    /// Appends elements to `Self` from other buffer.\n+    /// Appends elements to `self` from other buffer.\n     #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     unsafe fn append_elements(&mut self, other: *const [T]) {"}, {"sha": "3d18d9c4125962970e090809b4b12016320b02b1", "filename": "src/test/ui/async-await/async-fn-path-elision.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -8,3 +8,4 @@ LL | async fn error(lt: HasLifetime) {\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0726`."}, {"sha": "b30f2883732b459eaa9c5d76ea19a883fe792b2e", "filename": "src/test/ui/async-await/await-keyword/incorrect-syntax-suggestions.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -132,7 +132,7 @@ error: expected one of `.`, `?`, `{`, or an operator, found `}`\n LL |     match await { await => () }\n    |     -----                      - expected one of `.`, `?`, `{`, or an operator\n    |     |\n-   |     while parsing this match expression\n+   |     while parsing this `match` expression\n ...\n LL | }\n    | ^ unexpected token"}, {"sha": "89f75fea15b1d8cf72a21c71befe2323df64dce9", "filename": "src/test/ui/box/issue-78459-ice.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97cde9fe08804a3a5208d77f6870ad7d43f8c9c3/src%2Ftest%2Fui%2Fbox%2Fissue-78459-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97cde9fe08804a3a5208d77f6870ad7d43f8c9c3/src%2Ftest%2Fui%2Fbox%2Fissue-78459-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Fissue-78459-ice.rs?ref=97cde9fe08804a3a5208d77f6870ad7d43f8c9c3", "patch": "@@ -1,6 +0,0 @@\n-// check-pass\n-#![feature(allocator_api)]\n-\n-fn main() {\n-    Box::new_in((), &std::alloc::Global);\n-}"}, {"sha": "3ef1171ff50d9c8328d596031a684b0fdb9a82cd", "filename": "src/test/ui/box/large-allocator-ice.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fbox%2Flarge-allocator-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fbox%2Flarge-allocator-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Flarge-allocator-ice.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -0,0 +1,23 @@\n+// build-pass\n+#![feature(allocator_api)]\n+\n+use std::alloc::Allocator;\n+\n+struct BigAllocator([usize; 2]);\n+\n+unsafe impl Allocator for BigAllocator {\n+    fn allocate(\n+        &self,\n+        _: std::alloc::Layout,\n+    ) -> Result<std::ptr::NonNull<[u8]>, std::alloc::AllocError> {\n+        todo!()\n+    }\n+    unsafe fn deallocate(&self, _: std::ptr::NonNull<u8>, _: std::alloc::Layout) {\n+        todo!()\n+    }\n+}\n+\n+fn main() {\n+    Box::new_in((), &std::alloc::Global);\n+    Box::new_in((), BigAllocator([0; 2]));\n+}"}, {"sha": "609a5efd46feeb9ee55ce95e3db23739a73112e9", "filename": "src/test/ui/did_you_mean/issue-46836-identifier-not-instead-of-negation.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-46836-identifier-not-instead-of-negation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-46836-identifier-not-instead-of-negation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-46836-identifier-not-instead-of-negation.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -28,10 +28,7 @@ error: expected `{`, found `;`\n LL |     if not  // lack of braces is [sic]\n    |     -- this `if` expression has a condition, but no block\n LL |         println!(\"Then when?\");\n-   |                               ^\n-   |                               |\n-   |                               expected `{`\n-   |                               help: try placing this code inside a block: `{ ; }`\n+   |                               ^ expected `{`\n \n error: unexpected `2` after identifier\n   --> $DIR/issue-46836-identifier-not-instead-of-negation.rs:26:24"}, {"sha": "a3c607b59037f4b6237164ae67bf5eef157a342d", "filename": "src/test/ui/did_you_mean/issue-48492-tuple-destructure-missing-parens.stderr", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -2,31 +2,25 @@ error: unexpected `,` in pattern\n   --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:38:17\n    |\n LL |     while let b1, b2, b3 = reading_frame.next().expect(\"there should be a start codon\") {\n-   |                 ^\n+   |     -----       ^\n+   |     |\n+   |     while parsing the condition of this `while` expression\n    |\n-help: try adding parentheses to match on a tuple...\n+help: try adding parentheses to match on a tuple\n    |\n LL |     while let (b1, b2, b3) = reading_frame.next().expect(\"there should be a start codon\") {\n-   |               ~~~~~~~~~~~~\n-help: ...or a vertical bar to match on multiple alternatives\n-   |\n-LL |     while let b1 | b2 | b3 = reading_frame.next().expect(\"there should be a start codon\") {\n-   |               ~~~~~~~~~~~~\n+   |               +          +\n \n error: unexpected `,` in pattern\n   --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:49:14\n    |\n LL |     if let b1, b2, b3 = reading_frame.next().unwrap() {\n    |              ^\n    |\n-help: try adding parentheses to match on a tuple...\n+help: try adding parentheses to match on a tuple\n    |\n LL |     if let (b1, b2, b3) = reading_frame.next().unwrap() {\n-   |            ~~~~~~~~~~~~\n-help: ...or a vertical bar to match on multiple alternatives\n-   |\n-LL |     if let b1 | b2 | b3 = reading_frame.next().unwrap() {\n-   |            ~~~~~~~~~~~~\n+   |            +          +\n \n error: unexpected `,` in pattern\n   --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:59:28\n@@ -37,7 +31,7 @@ LL |         Nucleotide::Adenine, Nucleotide::Cytosine, _ => true\n help: try adding parentheses to match on a tuple...\n    |\n LL |         (Nucleotide::Adenine, Nucleotide::Cytosine, _) => true\n-   |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   |         +                                            +\n help: ...or a vertical bar to match on multiple alternatives\n    |\n LL |         Nucleotide::Adenine | Nucleotide::Cytosine | _ => true\n@@ -49,44 +43,32 @@ error: unexpected `,` in pattern\n LL |     for x, _barr_body in women.iter().map(|woman| woman.allosomes.clone()) {\n    |          ^\n    |\n-help: try adding parentheses to match on a tuple...\n+help: try adding parentheses to match on a tuple\n    |\n LL |     for (x, _barr_body) in women.iter().map(|woman| woman.allosomes.clone()) {\n-   |         ~~~~~~~~~~~~~~~\n-help: ...or a vertical bar to match on multiple alternatives\n-   |\n-LL |     for x | _barr_body in women.iter().map(|woman| woman.allosomes.clone()) {\n-   |         ~~~~~~~~~~~~~~\n+   |         +             +\n \n error: unexpected `,` in pattern\n   --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:75:10\n    |\n LL |     for x, y @ Allosome::Y(_) in men.iter().map(|man| man.allosomes.clone()) {\n    |          ^\n    |\n-help: try adding parentheses to match on a tuple...\n+help: try adding parentheses to match on a tuple\n    |\n LL |     for (x, y @ Allosome::Y(_)) in men.iter().map(|man| man.allosomes.clone()) {\n-   |         ~~~~~~~~~~~~~~~~~~~~~~~\n-help: ...or a vertical bar to match on multiple alternatives\n-   |\n-LL |     for x | y @ Allosome::Y(_) in men.iter().map(|man| man.allosomes.clone()) {\n-   |         ~~~~~~~~~~~~~~~~~~~~~~\n+   |         +                     +\n \n error: unexpected `,` in pattern\n   --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:84:14\n    |\n LL |     let women, men: (Vec<Genome>, Vec<Genome>) = genomes.iter().cloned()\n    |              ^\n    |\n-help: try adding parentheses to match on a tuple...\n+help: try adding parentheses to match on a tuple\n    |\n LL |     let (women, men): (Vec<Genome>, Vec<Genome>) = genomes.iter().cloned()\n-   |         ~~~~~~~~~~~~\n-help: ...or a vertical bar to match on multiple alternatives\n-   |\n-LL |     let women | men: (Vec<Genome>, Vec<Genome>) = genomes.iter().cloned()\n-   |         ~~~~~~~~~~~\n+   |         +          +\n \n error: aborting due to 6 previous errors\n "}, {"sha": "90522a885ab90d3df8c8d0f0a905e94645a68dbf", "filename": "src/test/ui/impl-header-lifetime-elision/path-elided.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -8,3 +8,4 @@ LL | impl MyTrait for Foo {\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0726`."}, {"sha": "15bc3f106b9c48169fed5d56eb8af8fe6307fff0", "filename": "src/test/ui/impl-header-lifetime-elision/trait-elided.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -8,3 +8,4 @@ LL | impl MyTrait for u32 {\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0726`."}, {"sha": "a91b3c90ebb25e3328e26e51faab9e56d3dca5f6", "filename": "src/test/ui/issues/issue-10412.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -67,4 +67,5 @@ LL | trait Serializable<'self, T: ?Sized> {\n \n error: aborting due to 9 previous errors\n \n-For more information about this error, try `rustc --explain E0277`.\n+Some errors have detailed explanations: E0277, E0726.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "feabe3814dcf9855c043f9ae33632b4331664368", "filename": "src/test/ui/issues/issue-39848.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fissues%2Fissue-39848.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fissues%2Fissue-39848.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39848.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -2,16 +2,18 @@ error: expected `{`, found `foo`\n   --> $DIR/issue-39848.rs:3:21\n    |\n LL |         if $tgt.has_$field() {}\n-   |         --          ^^^^^^--\n-   |         |           |\n-   |         |           expected `{`\n-   |         |           help: try placing this code inside a block: `{ $field() }`\n+   |         --          ^^^^^^ expected `{`\n+   |         |\n    |         this `if` expression has a condition, but no block\n ...\n LL |     get_opt!(bar, foo);\n    |     ------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `get_opt` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: try placing this code inside a block\n+   |\n+LL |         if $tgt.has_{ $field() } {}\n+   |                     +          +\n \n error: aborting due to previous error\n "}, {"sha": "c1d2023a21629ca014171a1697ffd2d21db39d0e", "filename": "src/test/ui/label/label_break_value_illegal_uses.fixed", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.fixed?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -0,0 +1,30 @@\n+// run-rustfix\n+#![feature(label_break_value)]\n+\n+// These are forbidden occurrences of label-break-value\n+\n+#[allow(unused_unsafe)]\n+fn labeled_unsafe() {\n+    unsafe {} //~ ERROR block label not supported here\n+}\n+\n+fn labeled_if() {\n+    if true {} //~ ERROR block label not supported here\n+}\n+\n+fn labeled_else() {\n+    if true {} else {} //~ ERROR block label not supported here\n+}\n+\n+fn labeled_match() {\n+    match false { //~ ERROR block label not supported here\n+        _ => {}\n+    }\n+}\n+\n+fn main() {\n+    labeled_unsafe();\n+    labeled_if();\n+    labeled_else();\n+    labeled_match();\n+}"}, {"sha": "5b20c95e581e5b1e84219a7361e3d1dfdf723802", "filename": "src/test/ui/label/label_break_value_illegal_uses.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -1,21 +1,30 @@\n+// run-rustfix\n #![feature(label_break_value)]\n \n // These are forbidden occurrences of label-break-value\n \n+#[allow(unused_unsafe)]\n fn labeled_unsafe() {\n-    unsafe 'b: {} //~ ERROR expected `{`, found `'b`\n+    unsafe 'b: {} //~ ERROR block label not supported here\n }\n \n fn labeled_if() {\n-    if true 'b: {} //~ ERROR expected `{`, found `'b`\n+    if true 'b: {} //~ ERROR block label not supported here\n }\n \n fn labeled_else() {\n-    if true {} else 'b: {} //~ ERROR expected `{`, found `'b`\n+    if true {} else 'b: {} //~ ERROR block label not supported here\n }\n \n fn labeled_match() {\n-    match false 'b: {} //~ ERROR expected one of `.`, `?`, `{`, or an operator\n+    match false 'b: { //~ ERROR block label not supported here\n+        _ => {}\n+    }\n }\n \n-pub fn main() {}\n+fn main() {\n+    labeled_unsafe();\n+    labeled_if();\n+    labeled_else();\n+    labeled_match();\n+}"}, {"sha": "24b733fec5301ca3e478433be374ce98d3302411", "filename": "src/test/ui/label/label_break_value_illegal_uses.stderr", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel%2Flabel_break_value_illegal_uses.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -1,38 +1,26 @@\n-error: expected `{`, found `'b`\n-  --> $DIR/label_break_value_illegal_uses.rs:6:12\n+error: block label not supported here\n+  --> $DIR/label_break_value_illegal_uses.rs:8:12\n    |\n LL |     unsafe 'b: {}\n-   |            ^^----\n-   |            |\n-   |            expected `{`\n-   |            help: try placing this code inside a block: `{ 'b: {} }`\n+   |            ^^^ not supported here\n \n-error: expected `{`, found `'b`\n-  --> $DIR/label_break_value_illegal_uses.rs:10:13\n+error: block label not supported here\n+  --> $DIR/label_break_value_illegal_uses.rs:12:13\n    |\n LL |     if true 'b: {}\n-   |     --      ^^----\n-   |     |       |\n-   |     |       expected `{`\n-   |     |       help: try placing this code inside a block: `{ 'b: {} }`\n-   |     this `if` expression has a condition, but no block\n+   |             ^^^ not supported here\n \n-error: expected `{`, found `'b`\n-  --> $DIR/label_break_value_illegal_uses.rs:14:21\n+error: block label not supported here\n+  --> $DIR/label_break_value_illegal_uses.rs:16:21\n    |\n LL |     if true {} else 'b: {}\n-   |                     ^^----\n-   |                     |\n-   |                     expected `{`\n-   |                     help: try placing this code inside a block: `{ 'b: {} }`\n+   |                     ^^^ not supported here\n \n-error: expected one of `.`, `?`, `{`, or an operator, found `'b`\n-  --> $DIR/label_break_value_illegal_uses.rs:18:17\n+error: block label not supported here\n+  --> $DIR/label_break_value_illegal_uses.rs:20:17\n    |\n-LL |     match false 'b: {}\n-   |     -----       ^^ expected one of `.`, `?`, `{`, or an operator\n-   |     |\n-   |     while parsing this match expression\n+LL |     match false 'b: {\n+   |                 ^^^ not supported here\n \n error: aborting due to 4 previous errors\n "}, {"sha": "a0324565673dac6f45aa620c62f9a7ba1ed9d55f", "filename": "src/test/ui/let-else/let-else-if.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Flet-else%2Flet-else-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Flet-else%2Flet-else-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-if.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -7,10 +7,10 @@ LL |     let Some(_) = Some(()) else if true {\n help: try placing this code inside a block\n    |\n LL ~     let Some(_) = Some(()) else { if true {\n-LL +\n-LL +         return;\n-LL +     } else {\n-LL +         return;\n+LL |\n+LL |         return;\n+LL |     } else {\n+LL |         return;\n LL ~     } };\n    |\n "}, {"sha": "148e214e58ec1f7ce8a2c7605669294bc4c8895c", "filename": "src/test/ui/missing/missing-block-hint.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fmissing%2Fmissing-block-hint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fmissing%2Fmissing-block-hint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-block-hint.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -12,10 +12,12 @@ error: expected `{`, found `bar`\n LL |         if (foo)\n    |         -- this `if` expression has a condition, but no block\n LL |             bar;\n-   |             ^^^-\n-   |             |\n-   |             expected `{`\n-   |             help: try placing this code inside a block: `{ bar; }`\n+   |             ^^^ expected `{`\n+   |\n+help: try placing this code inside a block\n+   |\n+LL |             { bar; }\n+   |             +      +\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f232f480ce9c2595647092d338c572a41f45286b", "filename": "src/test/ui/parser/block-no-opening-brace.stderr", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fblock-no-opening-brace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fblock-no-opening-brace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fblock-no-opening-brace.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -1,29 +1,41 @@\n error: expected `{`, found keyword `let`\n   --> $DIR/block-no-opening-brace.rs:9:9\n    |\n+LL |     loop\n+   |     ---- while parsing this `loop` expression\n LL |         let x = 0;\n-   |         ^^^-------\n-   |         |\n-   |         expected `{`\n-   |         help: try placing this code inside a block: `{ let x = 0; }`\n+   |         ^^^ expected `{`\n+   |\n+help: try placing this code inside a block\n+   |\n+LL |         { let x = 0; }\n+   |         +            +\n \n error: expected `{`, found keyword `let`\n   --> $DIR/block-no-opening-brace.rs:15:9\n    |\n+LL |     while true\n+   |     ----- ---- this `while` condition successfully parsed\n+   |     |\n+   |     while parsing the body of this `while` expression\n LL |         let x = 0;\n-   |         ^^^-------\n-   |         |\n-   |         expected `{`\n-   |         help: try placing this code inside a block: `{ let x = 0; }`\n+   |         ^^^ expected `{`\n+   |\n+help: try placing this code inside a block\n+   |\n+LL |         { let x = 0; }\n+   |         +            +\n \n error: expected `{`, found keyword `let`\n   --> $DIR/block-no-opening-brace.rs:20:9\n    |\n LL |         let x = 0;\n-   |         ^^^-------\n-   |         |\n-   |         expected `{`\n-   |         help: try placing this code inside a block: `{ let x = 0; }`\n+   |         ^^^ expected `{`\n+   |\n+help: try placing this code inside a block\n+   |\n+LL |         { let x = 0; }\n+   |         +            +\n \n error: expected expression, found reserved keyword `try`\n   --> $DIR/block-no-opening-brace.rs:24:5"}, {"sha": "3d16a2067ccae7f882f8549df17a85cace19017f", "filename": "src/test/ui/parser/closure-return-syntax.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fclosure-return-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fclosure-return-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fclosure-return-syntax.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -2,10 +2,12 @@ error: expected `{`, found `22`\n   --> $DIR/closure-return-syntax.rs:5:23\n    |\n LL |     let x = || -> i32 22;\n-   |                       ^^\n-   |                       |\n-   |                       expected `{`\n-   |                       help: try placing this code inside a block: `{ 22 }`\n+   |                       ^^ expected `{`\n+   |\n+help: try placing this code inside a block\n+   |\n+LL |     let x = || -> i32 { 22 };\n+   |                       +    +\n \n error: aborting due to previous error\n "}, {"sha": "3589016e1dc83f5f352eda753d7cd069f4e03472", "filename": "src/test/ui/parser/issues/issue-62554.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-62554.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-62554.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-62554.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -63,9 +63,8 @@ LL | fn foo(u: u8) { if u8 macro_rules! u8 { (u6) => { fn uuuuuuuuuuu() { use s\n    |\n help: try placing this code inside a block\n    |\n-LL ~ fn foo(u: u8) { if u8 { macro_rules! u8 { (u6) => { fn uuuuuuuuuuu() { use s loo mod u8 {\n-LL +  }\n-   |\n+LL | fn foo(u: u8) { if u8 { macro_rules! u8 { (u6) => { fn uuuuuuuuuuu() { use s loo mod u8 { }\n+   |                       +                                                                    +\n \n error: aborting due to 6 previous errors\n "}, {"sha": "871b5d59651343b027e376d060e09e6891547973", "filename": "src/test/ui/parser/issues/issue-62973.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-62973.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-62973.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-62973.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -50,7 +50,7 @@ error: expected one of `.`, `?`, `{`, or an operator, found `}`\n   --> $DIR/issue-62973.rs:8:2\n    |\n LL | fn p() { match s { v, E { [) {) }\n-   |          ----- while parsing this match expression\n+   |          ----- while parsing this `match` expression\n LL | \n LL | \n    |  ^ expected one of `.`, `?`, `{`, or an operator"}, {"sha": "423147b27aa0b0c0c16ddf6d6c10d5c807e63c47", "filename": "src/test/ui/parser/match-refactor-to-expr.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fmatch-refactor-to-expr.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fmatch-refactor-to-expr.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmatch-refactor-to-expr.fixed?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -2,7 +2,7 @@\n \n fn main() {\n     let foo =\n-         //~ NOTE while parsing this match expression\n+         //~ NOTE while parsing this `match` expression\n         Some(4).unwrap_or(5)\n         //~^ NOTE expected one of `.`, `?`, `{`, or an operator\n         ; //~ NOTE unexpected token"}, {"sha": "fcba5d0447e0df6d678ab34f72193b38b1e5e1b7", "filename": "src/test/ui/parser/match-refactor-to-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fmatch-refactor-to-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fmatch-refactor-to-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmatch-refactor-to-expr.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -2,7 +2,7 @@\n \n fn main() {\n     let foo =\n-        match //~ NOTE while parsing this match expression\n+        match //~ NOTE while parsing this `match` expression\n         Some(4).unwrap_or(5)\n         //~^ NOTE expected one of `.`, `?`, `{`, or an operator\n         ; //~ NOTE unexpected token"}, {"sha": "851bef8f2c7e8c5eb65971ec036ddb3b46e4d230", "filename": "src/test/ui/parser/match-refactor-to-expr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fmatch-refactor-to-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fmatch-refactor-to-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmatch-refactor-to-expr.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -4,7 +4,7 @@ error: expected one of `.`, `?`, `{`, or an operator, found `;`\n LL |         match\n    |         -----\n    |         |\n-   |         while parsing this match expression\n+   |         while parsing this `match` expression\n    |         help: try removing this `match`\n LL |         Some(4).unwrap_or(5)\n    |                             - expected one of `.`, `?`, `{`, or an operator"}, {"sha": "063c0145c85c681984e65f35c49f87bf9aea5ec2", "filename": "src/test/ui/parser/while-if-let-without-body.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fwhile-if-let-without-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fwhile-if-let-without-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fwhile-if-let-without-body.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -0,0 +1,13 @@\n+fn main() {\n+    let container = vec![Some(1), Some(2), None];\n+\n+    let mut i = 0;\n+    while if let Some(thing) = container.get(i) {\n+        //~^ NOTE while parsing the body of this `while` expression\n+        //~| NOTE this `while` condition successfully parsed\n+        println!(\"{:?}\", thing);\n+        i += 1;\n+    }\n+}\n+//~^ ERROR expected `{`, found `}`\n+//~| NOTE expected `{`"}, {"sha": "2dac45c115d11915f4f2f471316c7789288b14dc", "filename": "src/test/ui/parser/while-if-let-without-body.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fwhile-if-let-without-body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fparser%2Fwhile-if-let-without-body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fwhile-if-let-without-body.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -0,0 +1,18 @@\n+error: expected `{`, found `}`\n+  --> $DIR/while-if-let-without-body.rs:11:1\n+   |\n+LL |       while if let Some(thing) = container.get(i) {\n+   |  _____-----_-\n+   | |     |\n+   | |     while parsing the body of this `while` expression\n+LL | |\n+LL | |\n+LL | |         println!(\"{:?}\", thing);\n+LL | |         i += 1;\n+LL | |     }\n+   | |_____- this `while` condition successfully parsed\n+LL |   }\n+   |   ^ expected `{`\n+\n+error: aborting due to previous error\n+"}, {"sha": "929759766f279f8707806036e838931ae59960bc", "filename": "src/test/ui/typeck/while-loop-block-cond.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.rs?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    while {} {}\n+    //~^ ERROR mismatched types [E0308]\n+}"}, {"sha": "598273af9cfc4c5d6f70e44eff0c1b3d00f94b03", "filename": "src/test/ui/typeck/while-loop-block-cond.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -0,0 +1,9 @@\n+error[E0308]: mismatched types\n+  --> $DIR/while-loop-block-cond.rs:2:11\n+   |\n+LL |     while {} {}\n+   |           ^^ expected `bool`, found `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "44f77b99c561c04d0bd69528322174a36a659d20", "filename": "src/test/ui/unsafe/unsafe-block-without-braces.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Funsafe%2Funsafe-block-without-braces.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Funsafe%2Funsafe-block-without-braces.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Funsafe-block-without-braces.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -1,11 +1,15 @@\n error: expected `{`, found `std`\n   --> $DIR/unsafe-block-without-braces.rs:3:9\n    |\n+LL |     unsafe //{\n+   |     ------ while parsing this `unsafe` expression\n LL |         std::mem::transmute::<f32, u32>(1.0);\n-   |         ^^^----------------------------------\n-   |         |\n-   |         expected `{`\n-   |         help: try placing this code inside a block: `{ std::mem::transmute::<f32, u32>(1.0); }`\n+   |         ^^^ expected `{`\n+   |\n+help: try placing this code inside a block\n+   |\n+LL |         { std::mem::transmute::<f32, u32>(1.0); }\n+   |         +                                       +\n \n error: aborting due to previous error\n "}, {"sha": "ba624507c21f0d332f13adb8259c7d786fedf2ab", "filename": "src/test/ui/wf/wf-in-foreign-fn-decls-issue-80468.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ce3749235fc31d15ebd444b038a9877e8c700d7/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.stderr?ref=4ce3749235fc31d15ebd444b038a9877e8c700d7", "patch": "@@ -30,3 +30,4 @@ LL | impl Trait for Ref {}\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0726`."}]}