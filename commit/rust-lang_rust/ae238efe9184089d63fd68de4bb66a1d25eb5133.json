{"sha": "ae238efe9184089d63fd68de4bb66a1d25eb5133", "node_id": "C_kwDOAAsO6NoAKGFlMjM4ZWZlOTE4NDA4OWQ2M2ZkNjhkZTRiYjY2YTFkMjVlYjUxMzM", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-08-27T15:51:28Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-09-27T11:31:51Z"}, "message": "Prefer new_v1_formatted instead of new_v1 with duplicates.", "tree": {"sha": "680642f413a64c4c61a0d4f7c6e9e5239650436a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/680642f413a64c4c61a0d4f7c6e9e5239650436a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae238efe9184089d63fd68de4bb66a1d25eb5133", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae238efe9184089d63fd68de4bb66a1d25eb5133", "html_url": "https://github.com/rust-lang/rust/commit/ae238efe9184089d63fd68de4bb66a1d25eb5133", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae238efe9184089d63fd68de4bb66a1d25eb5133/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00074926bb3a6ed60b96b6b4c70e0d017ed33513", "url": "https://api.github.com/repos/rust-lang/rust/commits/00074926bb3a6ed60b96b6b4c70e0d017ed33513", "html_url": "https://github.com/rust-lang/rust/commit/00074926bb3a6ed60b96b6b4c70e0d017ed33513"}], "stats": {"total": 69, "additions": 33, "deletions": 36}, "files": [{"sha": "a2a8213dafc277ea8309e0ebc20daebd20c312af", "filename": "compiler/rustc_builtin_macros/src/format/expand.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ae238efe9184089d63fd68de4bb66a1d25eb5133/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae238efe9184089d63fd68de4bb66a1d25eb5133/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs?ref=ae238efe9184089d63fd68de4bb66a1d25eb5133", "patch": "@@ -164,18 +164,32 @@ pub fn expand_parsed_format_args(ecx: &mut ExtCtxt<'_>, fmt: FormatArgs) -> P<as\n             .collect(),\n     );\n \n-    let has_any_format_options = fmt.template.iter().any(|piece| {\n-        let FormatArgsPiece::Placeholder(placeholder) = piece else { return false };\n-        placeholder.format_options != Default::default()\n-    });\n+    // Whether we'll use the `Arguments::new_v1_formatted` form (true),\n+    // or the `Arguments::new_v1` form (false).\n+    let mut use_format_options = false;\n \n-    let (args, format_options) = if has_any_format_options {\n-        // Create a list of all _unique_ (argument, format trait) combinations.\n-        // E.g. \"{0} {0:x} {0} {1}\" -> [(0, Display), (0, LowerHex), (1, Display)]\n-        let mut argmap = FxIndexSet::default();\n+    // Create a list of all _unique_ (argument, format trait) combinations.\n+    // E.g. \"{0} {0:x} {0} {1}\" -> [(0, Display), (0, LowerHex), (1, Display)]\n+    let mut argmap = FxIndexSet::default();\n+    for piece in &fmt.template {\n+        let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };\n+        if placeholder.format_options != Default::default() {\n+            // Can't use basic form if there's any formatting options.\n+            use_format_options = true;\n+        }\n+        if let Ok(index) = placeholder.argument.index {\n+            if !argmap.insert((index, ArgumentType::Format(placeholder.format_trait))) {\n+                // Duplicate (argument, format trait) combination,\n+                // which we'll only put once in the args array.\n+                use_format_options = true;\n+            }\n+        }\n+    }\n+\n+    let format_options = use_format_options.then(|| {\n         // Generate:\n         //     &[format_spec_0, format_spec_1, format_spec_2]\n-        let format_options = ecx.expr_array_ref(\n+        ecx.expr_array_ref(\n             macsp,\n             fmt.template\n                 .iter()\n@@ -184,34 +198,18 @@ pub fn expand_parsed_format_args(ecx: &mut ExtCtxt<'_>, fmt: FormatArgs) -> P<as\n                     Some(make_format_spec(ecx, macsp, placeholder, &mut argmap))\n                 })\n                 .collect(),\n-        );\n-        (Vec::from_iter(argmap), Some(format_options))\n-    } else {\n-        // Create a list of all (argument, format trait) pairs, one for each placeholder.\n-        // E.g. \"{0} {0:x} {0} {1}\" -> [(0, Display), (0, LowerHex), (0, Display), (1, Display)]\n-        let args = fmt\n-            .template\n-            .iter()\n-            .filter_map(|piece| {\n-                let FormatArgsPiece::Placeholder(placeholder) = piece else { return None };\n-                Some((\n-                    placeholder.argument.index.ok()?,\n-                    ArgumentType::Format(placeholder.format_trait),\n-                ))\n-            })\n-            .collect();\n-        (args, None)\n-    };\n+        )\n+    });\n \n     // If the args array contains exactly all the original arguments once,\n     // in order, we can use a simple array instead of a `match` construction.\n     // However, if there's a yield point in any argument except the first one,\n     // we don't do this, because an ArgumentV1 cannot be kept across yield points.\n-    let use_simple_array = args.len() == fmt.arguments.len()\n-        && args.iter().enumerate().all(|(i, &(j, _))| i == j)\n+    let use_simple_array = argmap.len() == fmt.arguments.len()\n+        && argmap.iter().enumerate().all(|(i, &(j, _))| i == j)\n         && fmt.arguments.iter().skip(1).all(|(arg, _)| !may_contain_yield_point(arg));\n \n-    let args_expr = if use_simple_array {\n+    let args = if use_simple_array {\n         // Generate:\n         //     &[\n         //         ::core::fmt::ArgumentV1::new_display(&arg0),\n@@ -222,7 +220,7 @@ pub fn expand_parsed_format_args(ecx: &mut ExtCtxt<'_>, fmt: FormatArgs) -> P<as\n             macsp,\n             fmt.arguments\n                 .into_iter()\n-                .zip(args)\n+                .zip(argmap)\n                 .map(|((arg, _), (_, ty))| {\n                     let sp = arg.span.with_ctxt(macsp.ctxt());\n                     make_argument(ecx, sp, ecx.expr_addr_of(sp, arg), ty)\n@@ -239,7 +237,7 @@ pub fn expand_parsed_format_args(ecx: &mut ExtCtxt<'_>, fmt: FormatArgs) -> P<as\n         //         ]\n         //     }\n         let args_ident = Ident::new(sym::args, macsp);\n-        let args = args\n+        let args = argmap\n             .iter()\n             .map(|&(arg_index, ty)| {\n                 if let Some((arg, _)) = fmt.arguments.get(arg_index) {\n@@ -270,8 +268,7 @@ pub fn expand_parsed_format_args(ecx: &mut ExtCtxt<'_>, fmt: FormatArgs) -> P<as\n                         .map(|(arg, _)| ecx.expr_addr_of(arg.span.with_ctxt(macsp.ctxt()), arg))\n                         .collect(),\n                 ),\n-                [ecx.arm(macsp, ecx.pat_ident(macsp, args_ident), ecx.expr_array(macsp, args))]\n-                    .into(),\n+                vec![ecx.arm(macsp, ecx.pat_ident(macsp, args_ident), ecx.expr_array(macsp, args))],\n             ),\n         )\n     };\n@@ -289,7 +286,7 @@ pub fn expand_parsed_format_args(ecx: &mut ExtCtxt<'_>, fmt: FormatArgs) -> P<as\n             ecx.std_path(&[sym::fmt, sym::Arguments, sym::new_v1_formatted]),\n             vec![\n                 lit_pieces,\n-                args_expr,\n+                args,\n                 format_options,\n                 ecx.expr_block(P(ast::Block {\n                     stmts: vec![ecx.stmt_expr(ecx.expr_call_global(\n@@ -314,7 +311,7 @@ pub fn expand_parsed_format_args(ecx: &mut ExtCtxt<'_>, fmt: FormatArgs) -> P<as\n         ecx.expr_call_global(\n             macsp,\n             ecx.std_path(&[sym::fmt, sym::Arguments, sym::new_v1]),\n-            vec![lit_pieces, args_expr],\n+            vec![lit_pieces, args],\n         )\n     }\n }"}]}