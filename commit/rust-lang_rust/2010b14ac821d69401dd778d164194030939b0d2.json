{"sha": "2010b14ac821d69401dd778d164194030939b0d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMTBiMTRhYzgyMWQ2OTQwMWRkNzc4ZDE2NDE5NDAzMDkzOWIwZDI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2015-11-21T07:31:09Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2015-11-21T07:31:09Z"}, "message": "Add initial support for matching on enums.\n\nThis adds support for:\n  * the Switch terminator\n  * the Downcast projection rvalue\n  * the Index projection rvalue", "tree": {"sha": "96061fefe0ea15344b6bbafd9452a140266f0e22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96061fefe0ea15344b6bbafd9452a140266f0e22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2010b14ac821d69401dd778d164194030939b0d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2010b14ac821d69401dd778d164194030939b0d2", "html_url": "https://github.com/rust-lang/rust/commit/2010b14ac821d69401dd778d164194030939b0d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2010b14ac821d69401dd778d164194030939b0d2/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12bce479b31760d4f92e82adca31b99c2185ec41", "url": "https://api.github.com/repos/rust-lang/rust/commits/12bce479b31760d4f92e82adca31b99c2185ec41", "html_url": "https://github.com/rust-lang/rust/commit/12bce479b31760d4f92e82adca31b99c2185ec41"}], "stats": {"total": 80, "additions": 74, "deletions": 6}, "files": [{"sha": "bf0f3af491a41b0f4eda4f91b25f4af41d4c8710", "filename": "src/interpreter.rs", "status": "modified", "additions": 51, "deletions": 6, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2010b14ac821d69401dd778d164194030939b0d2/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2010b14ac821d69401dd778d164194030939b0d2/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=2010b14ac821d69401dd778d164194030939b0d2", "patch": "@@ -12,8 +12,8 @@ const TRACE_EXECUTION: bool = false;\n enum Value {\n     Uninit,\n     Bool(bool),\n-    Int(i64), // FIXME: Should be bit-width aware.\n-    Adt { variant: usize, data: Pointer },\n+    Int(i64), // FIXME(tsion): Should be bit-width aware.\n+    Adt { variant: usize, data_ptr: Pointer },\n     Func(def_id::DefId),\n }\n \n@@ -125,8 +125,10 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n \n     fn allocate_aggregate(&mut self, size: usize) -> Pointer {\n         let frame = self.call_stack.last_mut().expect(\"missing call frame\");\n+        frame.num_aggregate_fields += size;\n+\n         let ptr = Pointer::Stack(self.value_stack.len());\n-        self.value_stack.extend(iter::repeat(Value::Uninit).take(frame.size()));\n+        self.value_stack.extend(iter::repeat(Value::Uninit).take(size));\n         ptr\n     }\n \n@@ -195,9 +197,18 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                     block = targets[index];\n                 }\n \n+                mir::Terminator::Switch { ref discr, ref targets, .. } => {\n+                    let discr_val = self.read_lvalue(discr);\n+\n+                    if let Value::Adt { variant, .. } = discr_val {\n+                        block = targets[variant];\n+                    } else {\n+                        panic!(\"Switch on non-Adt value: {:?}\", discr_val);\n+                    }\n+                }\n+\n                 // mir::Terminator::Diverge => unimplemented!(),\n                 // mir::Terminator::Panic { target } => unimplemented!(),\n-                // mir::Terminator::Switch { ref discr, adt_def, ref targets } => unimplemented!(),\n                 _ => unimplemented!(),\n             }\n         }\n@@ -213,6 +224,37 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n             mir::Lvalue::Arg(i)  => Pointer::Stack(frame.arg_offset(i as usize)),\n             mir::Lvalue::Var(i)  => Pointer::Stack(frame.var_offset(i as usize)),\n             mir::Lvalue::Temp(i) => Pointer::Stack(frame.temp_offset(i as usize)),\n+\n+            mir::Lvalue::Projection(ref proj) => {\n+                // proj.base: Lvalue\n+                // proj.elem: ProjectionElem<Operand>\n+\n+                let base_ptr = self.eval_lvalue(&proj.base);\n+\n+                match proj.elem {\n+                    mir::ProjectionElem::Field(field) => {\n+                        base_ptr.offset(field.index())\n+                    }\n+\n+                    mir::ProjectionElem::Downcast(_, variant) => {\n+                        let adt_val = self.read_pointer(base_ptr);\n+\n+                        match adt_val {\n+                            Value::Adt { variant: actual_variant, data_ptr } => {\n+                                debug_assert_eq!(variant, actual_variant);\n+                                data_ptr\n+                            }\n+\n+                            _ => panic!(\"Downcast attempted on non-Adt: {:?}\", adt_val),\n+                        }\n+                    }\n+\n+                    mir::ProjectionElem::Deref => unimplemented!(),\n+                    mir::ProjectionElem::Index(ref _operand) => unimplemented!(),\n+                    mir::ProjectionElem::ConstantIndex { .. } => unimplemented!(),\n+                }\n+            }\n+\n             _ => unimplemented!(),\n         }\n     }\n@@ -262,7 +304,7 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                 }\n             }\n \n-            mir::Rvalue::Aggregate(mir::AggregateKind::Adt(ref adt_def, variant, substs),\n+            mir::Rvalue::Aggregate(mir::AggregateKind::Adt(ref adt_def, variant, _substs),\n                                    ref operands) => {\n                 let max_fields = adt_def.variants\n                     .iter()\n@@ -277,7 +319,7 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                     self.write_pointer(ptr.offset(i), val);\n                 }\n \n-                Value::Adt { variant: variant, data: ptr }\n+                Value::Adt { variant: variant, data_ptr: ptr }\n             }\n \n             _ => unimplemented!(),\n@@ -293,6 +335,9 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                     mir::Literal::Value { ref value } => self.eval_constant(value),\n \n                     mir::Literal::Item { def_id, substs: _ } => {\n+                        // FIXME(tsion): Only items of function type shoud be wrapped into Func\n+                        // values. One test currently fails because a unit-like enum variant gets\n+                        // wrapped into Func here instead of a Value::Adt.\n                         Value::Func(def_id)\n                     }\n                 }"}, {"sha": "330bab89fea907feda7a9d47db020fd6ef0e12ca", "filename": "test/basic.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2010b14ac821d69401dd778d164194030939b0d2/test%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2010b14ac821d69401dd778d164194030939b0d2/test%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test%2Fbasic.rs?ref=2010b14ac821d69401dd778d164194030939b0d2", "patch": "@@ -107,4 +107,27 @@ fn match_int() -> i32 {\n //     }\n // }\n \n+enum MyOption<T> {\n+    Some { data: T },\n+    None,\n+}\n+\n+#[miri_run(expected = \"Int(13)\")]\n+fn match_opt_some() -> i32 {\n+    let x = MyOption::Some { data: 13 };\n+    match x {\n+        MyOption::Some { data } => data,\n+        MyOption::None => 42,\n+    }\n+}\n+\n+// #[miri_run(expected = \"Int(42)\")]\n+// fn match_opt_none() -> i32 {\n+//     let x = MyOption::None;\n+//     match x {\n+//         MyOption::Some { data } => data,\n+//         MyOption::None => 42,\n+//     }\n+// }\n+\n fn main() {}"}]}