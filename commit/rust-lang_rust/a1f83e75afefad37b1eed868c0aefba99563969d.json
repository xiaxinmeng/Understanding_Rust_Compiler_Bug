{"sha": "a1f83e75afefad37b1eed868c0aefba99563969d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExZjgzZTc1YWZlZmFkMzdiMWVlZDg2OGMwYWVmYmE5OTU2Mzk2OWQ=", "commit": {"author": {"name": "Stepan Koltsov", "email": "stepan.koltsov@gmail.com", "date": "2018-11-15T00:18:19Z"}, "committer": {"name": "Stepan Koltsov", "email": "stepan.koltsov@gmail.com", "date": "2018-11-15T00:18:19Z"}, "message": "Stress test for MPSC\n\n`concurrent_recv_timeout_and_upgrade` reproduces a problem 100%\ntimes on my MacBook with command:\n\n```\n./x.py test --stage 0 ./src/test/run-pass/mpsc_stress.rs\n```\n\nThus it is commented out.\n\nOther tests cases were useful for catching another test cases\nwhich may arise during the fix.\n\nThis diff is a part of my previous rewrite attempt: #42883\n\nCC #39364", "tree": {"sha": "36096521cca37d5a07b5139420290b847af05e49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36096521cca37d5a07b5139420290b847af05e49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1f83e75afefad37b1eed868c0aefba99563969d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1f83e75afefad37b1eed868c0aefba99563969d", "html_url": "https://github.com/rust-lang/rust/commit/a1f83e75afefad37b1eed868c0aefba99563969d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1f83e75afefad37b1eed868c0aefba99563969d/comments", "author": {"login": "stepancheg", "id": 28969, "node_id": "MDQ6VXNlcjI4OTY5", "avatar_url": "https://avatars.githubusercontent.com/u/28969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stepancheg", "html_url": "https://github.com/stepancheg", "followers_url": "https://api.github.com/users/stepancheg/followers", "following_url": "https://api.github.com/users/stepancheg/following{/other_user}", "gists_url": "https://api.github.com/users/stepancheg/gists{/gist_id}", "starred_url": "https://api.github.com/users/stepancheg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stepancheg/subscriptions", "organizations_url": "https://api.github.com/users/stepancheg/orgs", "repos_url": "https://api.github.com/users/stepancheg/repos", "events_url": "https://api.github.com/users/stepancheg/events{/privacy}", "received_events_url": "https://api.github.com/users/stepancheg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stepancheg", "id": 28969, "node_id": "MDQ6VXNlcjI4OTY5", "avatar_url": "https://avatars.githubusercontent.com/u/28969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stepancheg", "html_url": "https://github.com/stepancheg", "followers_url": "https://api.github.com/users/stepancheg/followers", "following_url": "https://api.github.com/users/stepancheg/following{/other_user}", "gists_url": "https://api.github.com/users/stepancheg/gists{/gist_id}", "starred_url": "https://api.github.com/users/stepancheg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stepancheg/subscriptions", "organizations_url": "https://api.github.com/users/stepancheg/orgs", "repos_url": "https://api.github.com/users/stepancheg/repos", "events_url": "https://api.github.com/users/stepancheg/events{/privacy}", "received_events_url": "https://api.github.com/users/stepancheg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f93e93af6f823948cc13d2938957757c6486d88", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f93e93af6f823948cc13d2938957757c6486d88", "html_url": "https://github.com/rust-lang/rust/commit/6f93e93af6f823948cc13d2938957757c6486d88"}], "stats": {"total": 172, "additions": 172, "deletions": 0}, "files": [{"sha": "aa369bb17fead69364876919953e98598f570846", "filename": "src/test/run-pass/mpsc_stress.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/a1f83e75afefad37b1eed868c0aefba99563969d/src%2Ftest%2Frun-pass%2Fmpsc_stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1f83e75afefad37b1eed868c0aefba99563969d/src%2Ftest%2Frun-pass%2Fmpsc_stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmpsc_stress.rs?ref=a1f83e75afefad37b1eed868c0aefba99563969d", "patch": "@@ -0,0 +1,172 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:--test\n+// ignore-emscripten\n+\n+use std::sync::mpsc::channel;\n+use std::sync::mpsc::TryRecvError;\n+use std::sync::mpsc::RecvError;\n+use std::sync::mpsc::RecvTimeoutError;\n+use std::sync::Arc;\n+use std::sync::atomic::AtomicUsize;\n+use std::sync::atomic::Ordering;\n+\n+use std::thread;\n+use std::time::Duration;\n+\n+\n+/// Simple thread synchronization utility\n+struct Barrier {\n+    // Not using mutex/condvar for precision\n+    shared: Arc<AtomicUsize>,\n+    count: usize,\n+}\n+\n+impl Barrier {\n+    fn new(count: usize) -> Vec<Barrier> {\n+        let shared = Arc::new(AtomicUsize::new(0));\n+        (0..count).map(|_| Barrier { shared: shared.clone(), count: count }).collect()\n+    }\n+\n+    fn new2() -> (Barrier, Barrier) {\n+        let mut v = Barrier::new(2);\n+        (v.pop().unwrap(), v.pop().unwrap())\n+    }\n+\n+    /// Returns when `count` threads enter `wait`\n+    fn wait(self) {\n+        self.shared.fetch_add(1, Ordering::SeqCst);\n+        while self.shared.load(Ordering::SeqCst) != self.count {\n+        }\n+    }\n+}\n+\n+\n+fn shared_close_sender_does_not_lose_messages_iter() {\n+    let (tb, rb) = Barrier::new2();\n+\n+    let (tx, rx) = channel();\n+    let _ = tx.clone(); // convert to shared\n+\n+    thread::spawn(move || {\n+        tb.wait();\n+        thread::sleep(Duration::from_micros(1));\n+        tx.send(17).expect(\"send\");\n+        drop(tx);\n+    });\n+\n+    let i = rx.into_iter();\n+    rb.wait();\n+    // Make sure it doesn't return disconnected before returning an element\n+    assert_eq!(vec![17], i.collect::<Vec<_>>());\n+}\n+\n+#[test]\n+fn shared_close_sender_does_not_lose_messages() {\n+    for _ in 0..10000 {\n+        shared_close_sender_does_not_lose_messages_iter();\n+    }\n+}\n+\n+\n+// https://github.com/rust-lang/rust/issues/39364\n+fn concurrent_recv_timeout_and_upgrade_iter() {\n+    // 1 us\n+    let sleep = Duration::new(0, 1_000);\n+\n+    let (a, b) = Barrier::new2();\n+    let (tx, rx) = channel();\n+    let th = thread::spawn(move || {\n+        a.wait();\n+        loop {\n+            match rx.recv_timeout(sleep) {\n+                Ok(_) => {\n+                    break;\n+                },\n+                Err(_) => {},\n+            }\n+        }\n+    });\n+    b.wait();\n+    thread::sleep(sleep);\n+    tx.clone().send(()).expect(\"send\");\n+    th.join().unwrap();\n+}\n+\n+#[test]\n+fn concurrent_recv_timeout_and_upgrade() {\n+    // FIXME: fix and enable\n+    if true { return }\n+\n+    // at the moment of writing this test fails like this:\n+    // thread '<unnamed>' panicked at 'assertion failed: `(left == right)`\n+    //  left: `4561387584`,\n+    // right: `0`', libstd/sync/mpsc/shared.rs:253:13\n+\n+    for _ in 0..10000 {\n+        concurrent_recv_timeout_and_upgrade_iter();\n+    }\n+}\n+\n+\n+fn concurrent_writes_iter() {\n+    const THREADS: usize = 4;\n+    const PER_THR: usize = 100;\n+\n+    let mut bs = Barrier::new(THREADS + 1);\n+    let (tx, rx) = channel();\n+\n+    let mut threads = Vec::new();\n+    for j in 0..THREADS {\n+        let tx = tx.clone();\n+        let b = bs.pop().unwrap();\n+        threads.push(thread::spawn(move || {\n+            b.wait();\n+            for i in 0..PER_THR {\n+                tx.send(j * 1000 + i).expect(\"send\");\n+            }\n+        }));\n+    }\n+\n+    let b = bs.pop().unwrap();\n+    b.wait();\n+\n+    let mut v: Vec<_> = rx.iter().take(THREADS * PER_THR).collect();\n+    v.sort();\n+\n+    for j in 0..THREADS {\n+        for i in 0..PER_THR {\n+            assert_eq!(j * 1000 + i, v[j * PER_THR + i]);\n+        }\n+    }\n+\n+    for t in threads {\n+        t.join().unwrap();\n+    }\n+\n+    let one_us = Duration::new(0, 1000);\n+\n+    assert_eq!(TryRecvError::Empty, rx.try_recv().unwrap_err());\n+    assert_eq!(RecvTimeoutError::Timeout, rx.recv_timeout(one_us).unwrap_err());\n+\n+    drop(tx);\n+\n+    assert_eq!(RecvError, rx.recv().unwrap_err());\n+    assert_eq!(RecvTimeoutError::Disconnected, rx.recv_timeout(one_us).unwrap_err());\n+    assert_eq!(TryRecvError::Disconnected, rx.try_recv().unwrap_err());\n+}\n+\n+#[test]\n+fn concurrent_writes() {\n+    for _ in 0..100 {\n+        concurrent_writes_iter();\n+    }\n+}"}]}