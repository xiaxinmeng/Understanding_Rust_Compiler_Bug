{"sha": "ff13b7c91813eb178c98a7abc661acaf5c41dc31", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMTNiN2M5MTgxM2ViMTc4Yzk4YTdhYmM2NjFhY2FmNWM0MWRjMzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-22T03:31:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-22T03:31:53Z"}, "message": "Auto merge of #41459 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 4 pull requests\n\n- Successful merges: #37658, #41405, #41432, #41435\n- Failed merges:", "tree": {"sha": "b3e8443a35d674ef3b08a7bc879d142e6fb51771", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3e8443a35d674ef3b08a7bc879d142e6fb51771"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff13b7c91813eb178c98a7abc661acaf5c41dc31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff13b7c91813eb178c98a7abc661acaf5c41dc31", "html_url": "https://github.com/rust-lang/rust/commit/ff13b7c91813eb178c98a7abc661acaf5c41dc31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff13b7c91813eb178c98a7abc661acaf5c41dc31/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1785bca5137fad1f26e4d3c347cbb68408a28fa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1785bca5137fad1f26e4d3c347cbb68408a28fa9", "html_url": "https://github.com/rust-lang/rust/commit/1785bca5137fad1f26e4d3c347cbb68408a28fa9"}, {"sha": "df72158d47e2a1524f6e1631f8181a4cd3b6b231", "url": "https://api.github.com/repos/rust-lang/rust/commits/df72158d47e2a1524f6e1631f8181a4cd3b6b231", "html_url": "https://github.com/rust-lang/rust/commit/df72158d47e2a1524f6e1631f8181a4cd3b6b231"}], "stats": {"total": 265, "additions": 227, "deletions": 38}, "files": [{"sha": "d21b5f739bd7b5510712cc7eac3c43c44cfdf034", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -78,6 +78,7 @@ use errors::DiagnosticBuilder;\n use syntax::abi;\n use syntax::feature_gate;\n use syntax::ptr::P;\n+use syntax_pos;\n \n use std::collections::VecDeque;\n use std::ops::Deref;\n@@ -722,6 +723,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         Ok(target)\n     }\n \n+    /// Same as `try_coerce()`, but without side-effects.\n+    pub fn can_coerce(&self, expr_ty: Ty<'tcx>, target: Ty<'tcx>) -> bool {\n+        let source = self.resolve_type_vars_with_obligations(expr_ty);\n+        debug!(\"coercion::can({:?} -> {:?})\", source, target);\n+\n+        let cause = self.cause(syntax_pos::DUMMY_SP, ObligationCauseCode::ExprAssignable);\n+        let coerce = Coerce::new(self, cause);\n+        self.probe(|_| coerce.coerce::<hir::Expr>(&[], source, target)).is_ok()\n+    }\n+\n     /// Given some expressions, their known unified type and another expression,\n     /// tries to unify the types, potentially inserting coercions on any of the\n     /// provided expressions and returns their LUB (aka \"common supertype\")."}, {"sha": "4cc3f2dacdfe996a77e4fc4c641595ce49109871", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 75, "deletions": 14, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -10,15 +10,14 @@\n \n \n use check::FnCtxt;\n-use rustc::ty::Ty;\n-use rustc::infer::{InferOk};\n+use rustc::infer::InferOk;\n use rustc::traits::ObligationCause;\n \n use syntax::ast;\n use syntax_pos::{self, Span};\n use rustc::hir;\n use rustc::hir::def::Def;\n-use rustc::ty::{self, AssociatedItem};\n+use rustc::ty::{self, Ty, AssociatedItem};\n use errors::DiagnosticBuilder;\n \n use super::method::probe;\n@@ -80,18 +79,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Err(e) = self.try_coerce(expr, checked_ty, self.diverges.get(), expected) {\n             let cause = self.misc(expr.span);\n             let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n-            let mode = probe::Mode::MethodCall;\n-            let suggestions = self.probe_for_return_type(syntax_pos::DUMMY_SP,\n-                                                         mode,\n-                                                         expected,\n-                                                         checked_ty,\n-                                                         ast::DUMMY_NODE_ID);\n             let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e);\n-            if suggestions.len() > 0 {\n-                err.help(&format!(\"here are some functions which \\\n-                                   might fulfill your needs:\\n{}\",\n-                                  self.get_best_match(&suggestions).join(\"\\n\")));\n-            };\n+            if let Some(suggestion) = self.check_ref(expr,\n+                                                     checked_ty,\n+                                                     expected) {\n+                err.help(&suggestion);\n+            } else {\n+                let mode = probe::Mode::MethodCall;\n+                let suggestions = self.probe_for_return_type(syntax_pos::DUMMY_SP,\n+                                                             mode,\n+                                                             expected,\n+                                                             checked_ty,\n+                                                             ast::DUMMY_NODE_ID);\n+                if suggestions.len() > 0 {\n+                    err.help(&format!(\"here are some functions which \\\n+                                       might fulfill your needs:\\n{}\",\n+                                      self.get_best_match(&suggestions).join(\"\\n\")));\n+                }\n+            }\n             err.emit();\n         }\n     }\n@@ -140,4 +145,60 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => false,\n         }\n     }\n+\n+    /// This function is used to determine potential \"simple\" improvements or users' errors and\n+    /// provide them useful help. For example:\n+    ///\n+    /// ```\n+    /// fn some_fn(s: &str) {}\n+    ///\n+    /// let x = \"hey!\".to_owned();\n+    /// some_fn(x); // error\n+    /// ```\n+    ///\n+    /// No need to find every potential function which could make a coercion to transform a\n+    /// `String` into a `&str` since a `&` would do the trick!\n+    ///\n+    /// In addition of this check, it also checks between references mutability state. If the\n+    /// expected is mutable but the provided isn't, maybe we could just say \"Hey, try with\n+    /// `&mut`!\".\n+    fn check_ref(&self,\n+                 expr: &hir::Expr,\n+                 checked_ty: Ty<'tcx>,\n+                 expected: Ty<'tcx>)\n+                 -> Option<String> {\n+        match (&expected.sty, &checked_ty.sty) {\n+            (&ty::TyRef(_, _), &ty::TyRef(_, _)) => None,\n+            (&ty::TyRef(_, mutability), _) => {\n+                // Check if it can work when put into a ref. For example:\n+                //\n+                // ```\n+                // fn bar(x: &mut i32) {}\n+                //\n+                // let x = 0u32;\n+                // bar(&x); // error, expected &mut\n+                // ```\n+                let ref_ty = match mutability.mutbl {\n+                    hir::Mutability::MutMutable => self.tcx.mk_mut_ref(\n+                                                       self.tcx.mk_region(ty::ReStatic),\n+                                                       checked_ty),\n+                    hir::Mutability::MutImmutable => self.tcx.mk_imm_ref(\n+                                                       self.tcx.mk_region(ty::ReStatic),\n+                                                       checked_ty),\n+                };\n+                if self.can_coerce(ref_ty, expected) {\n+                    if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n+                        return Some(format!(\"try with `{}{}`\",\n+                                            match mutability.mutbl {\n+                                                hir::Mutability::MutMutable => \"&mut \",\n+                                                hir::Mutability::MutImmutable => \"&\",\n+                                            },\n+                                            &src));\n+                    }\n+                }\n+                None\n+            }\n+            _ => None,\n+        }\n+    }\n }"}, {"sha": "4bf856240f66a8cabd5928e4cd2eb40c6cfbb00d", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -492,7 +492,7 @@ pub fn old_find_testable_code(doc: &str, tests: &mut ::test::Collector, position\n                     text: *const hoedown_buffer,\n                     lang: *const hoedown_buffer,\n                     data: *const hoedown_renderer_data,\n-                    line: libc::size_t) {\n+                    _line: libc::size_t) {\n         unsafe {\n             if text.is_null() { return }\n             let block_info = if lang.is_null() {\n@@ -503,11 +503,15 @@ pub fn old_find_testable_code(doc: &str, tests: &mut ::test::Collector, position\n                 LangString::parse(s)\n             };\n             if !block_info.rust { return }\n+            let text = (*text).as_bytes();\n             let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n             let tests = &mut *((*opaque).opaque as *mut ::test::Collector);\n-            let line = tests.get_line() + line;\n+            let text = str::from_utf8(text).unwrap();\n+            let lines = text.lines().map(|l| {\n+                stripped_filtered_line(l).unwrap_or(l)\n+            });\n             let filename = tests.get_filename();\n-            tests.add_old_test(line, filename);\n+            tests.add_old_test(lines.collect::<Vec<&str>>().join(\"\\n\"), filename);\n         }\n     }\n "}, {"sha": "0ca267bb82d2eb1c7a95f1f73b851e024c89d8d9", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -27,6 +27,7 @@\n #![feature(staged_api)]\n #![feature(test)]\n #![feature(unicode)]\n+#![feature(vec_remove_item)]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "3206b5021075d5f5a5346abd759e5fc39b10296d", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::collections::HashMap;\n use std::env;\n use std::ffi::OsString;\n use std::io::prelude::*;\n@@ -381,7 +382,7 @@ fn partition_source(s: &str) -> (String, String) {\n pub struct Collector {\n     pub tests: Vec<testing::TestDescAndFn>,\n     // to be removed when hoedown will be definitely gone\n-    pub old_tests: Vec<String>,\n+    pub old_tests: HashMap<String, Vec<String>>,\n     names: Vec<String>,\n     cfgs: Vec<String>,\n     libs: SearchPaths,\n@@ -403,7 +404,7 @@ impl Collector {\n                codemap: Option<Rc<CodeMap>>, filename: Option<String>) -> Collector {\n         Collector {\n             tests: Vec::new(),\n-            old_tests: Vec::new(),\n+            old_tests: HashMap::new(),\n             names: Vec::new(),\n             cfgs: cfgs,\n             libs: libs,\n@@ -432,17 +433,39 @@ impl Collector {\n         }\n     }\n \n-    pub fn add_old_test(&mut self, line: usize, filename: String) {\n-        let name = self.generate_name(line, &filename);\n-        self.old_tests.push(name);\n+    // to be removed once hoedown is gone\n+    fn generate_name_beginning(&self, filename: &str) -> String {\n+        if self.use_headers {\n+            if let Some(ref header) = self.current_header {\n+                format!(\"{} - {} (line\", filename, header)\n+            } else {\n+                format!(\"{} - (line\", filename)\n+            }\n+        } else {\n+            format!(\"{} - {} (line\", filename, self.names.join(\"::\"))\n+        }\n+    }\n+\n+    pub fn add_old_test(&mut self, test: String, filename: String) {\n+        let name_beg = self.generate_name_beginning(&filename);\n+        let entry = self.old_tests.entry(name_beg)\n+                                  .or_insert(Vec::new());\n+        entry.push(test.trim().to_owned());\n     }\n \n     pub fn add_test(&mut self, test: String,\n                     should_panic: bool, no_run: bool, should_ignore: bool,\n                     as_test_harness: bool, compile_fail: bool, error_codes: Vec<String>,\n                     line: usize, filename: String) {\n         let name = self.generate_name(line, &filename);\n-        if self.old_tests.iter().find(|&x| x == &name).is_none() {\n+        let name_beg = self.generate_name_beginning(&filename);\n+        let mut found = false;\n+        // to be removed when hoedown is removed\n+        let test = test.trim().to_owned();\n+        if let Some(entry) = self.old_tests.get_mut(&name_beg) {\n+            found = entry.remove_item(&test).is_some();\n+        }\n+        if !found {\n             let _ = writeln!(&mut io::stderr(),\n                              \"WARNING: {} Code block is not currently run as a test, but will in \\\n                               future versions of rustdoc. Please ensure this code block is a \\"}, {"sha": "842398ea02b9e132f5b4445c2bce05f8797a031d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -205,6 +205,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         module.directory.pop();\n         self.cx.current_expansion.module = Rc::new(module);\n \n+        let orig_mod_span = krate.module.inner;\n+\n         let krate_item = Expansion::Items(SmallVector::one(P(ast::Item {\n             attrs: krate.attrs,\n             span: krate.span,\n@@ -214,11 +216,19 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             vis: ast::Visibility::Public,\n         })));\n \n-        match self.expand(krate_item).make_items().pop().unwrap().unwrap() {\n-            ast::Item { attrs, node: ast::ItemKind::Mod(module), .. } => {\n+        match self.expand(krate_item).make_items().pop().map(P::unwrap) {\n+            Some(ast::Item { attrs, node: ast::ItemKind::Mod(module), .. }) => {\n                 krate.attrs = attrs;\n                 krate.module = module;\n             },\n+            None => {\n+                // Resolution failed so we return an empty expansion\n+                krate.attrs = vec![];\n+                krate.module = ast::Mod {\n+                    inner: orig_mod_span,\n+                    items: vec![],\n+                };\n+            },\n             _ => unreachable!(),\n         };\n "}, {"sha": "99400bd147c201e2cc5f12c368e24c4fdecae505", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/issue-41211.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-41211.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-41211.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-41211.rs?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro)]\n+\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_attribute]\n+pub fn emit_unchanged(_args: TokenStream, input: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "17237912be49bd8844aa832a6f8aa1d776e012ca", "filename": "src/test/compile-fail-fulldeps/proc-macro/issue-41211.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-41211.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-41211.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-41211.rs?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-41211.rs\n+\n+// FIXME: https://github.com/rust-lang/rust/issues/41430\n+// This is a temporary regression test for the ICE reported in #41211\n+\n+#![feature(proc_macro)]\n+#![emit_unchanged]\n+//~^ ERROR: cannot find attribute macro `emit_unchanged` in this scope\n+extern crate issue_41211;\n+use issue_41211::emit_unchanged;\n+\n+fn main() {}"}, {"sha": "7c5a4e0c3c6f644467c7117cbdc8da80dcfd1d61", "filename": "src/test/compile-fail/coercion-slice.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fcompile-fail%2Fcoercion-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fcompile-fail%2Fcoercion-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoercion-slice.rs?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -14,6 +14,5 @@ fn main() {\n     let _: &[i32] = [0];\n     //~^ ERROR mismatched types\n     //~| expected type `&[i32]`\n-    //~| found type `[{integer}; 1]`\n     //~| expected &[i32], found array of 1 elements\n }"}, {"sha": "847a82c082651f1a4550cc7bfc34aefa873f2fa3", "filename": "src/test/compile-fail/cross-borrow-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -17,7 +17,7 @@ impl Trait for Foo {}\n \n pub fn main() {\n     let x: Box<Trait> = Box::new(Foo);\n-    let _y: &Trait = x; //~  ERROR mismatched types\n+    let _y: &Trait = x; //~ ERROR E0308\n                         //~| expected type `&Trait`\n                         //~| found type `std::boxed::Box<Trait>`\n }"}, {"sha": "1e444a6bebf9b23b573465a7090f60b174d52fa3", "filename": "src/test/compile-fail/issue-11374.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -33,5 +33,5 @@ pub fn for_stdin<'a>() -> Container<'a> {\n fn main() {\n     let mut c = for_stdin();\n     let mut v = Vec::new();\n-    c.read_to(v); //~ ERROR mismatched types\n+    c.read_to(v); //~ ERROR E0308\n }"}, {"sha": "ed1634441498be40d5a05f98c51f2c5b8019a02c", "filename": "src/test/compile-fail/issue-13058.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -35,4 +35,5 @@ fn check<'r, I: Iterator<Item=usize>, T: Itble<'r, usize, I>>(cont: &T) -> bool\n fn main() {\n     check((3, 5));\n //~^ ERROR mismatched types\n+//~| HELP try with `&(3, 5)`\n }"}, {"sha": "bc3122bf71c0e21056a40d31e75e4a41f6e032ed", "filename": "src/test/ui/span/coerce-suggestions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.rs?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -32,7 +32,6 @@ fn main() {\n     //~| NOTE types differ in mutability\n     //~| NOTE expected type `&mut std::string::String`\n     //~| NOTE found type `&std::string::String`\n-    //~| HELP try with `&mut y`\n     test2(&y);\n     //~^ ERROR E0308\n     //~| NOTE types differ in mutability"}, {"sha": "220b2f471da9ad7aef33e4d22a67ab811adbb778", "filename": "src/test/ui/span/coerce-suggestions.stderr", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -18,11 +18,7 @@ error[E0308]: mismatched types\n    |\n    = note: expected type `&str`\n               found type `std::string::String`\n-   = help: here are some functions which might fulfill your needs:\n-           - .as_str()\n-           - .trim()\n-           - .trim_left()\n-           - .trim_right()\n+   = help: try with `&String::new()`\n \n error[E0308]: mismatched types\n   --> $DIR/coerce-suggestions.rs:30:10\n@@ -34,18 +30,18 @@ error[E0308]: mismatched types\n               found type `&std::string::String`\n \n error[E0308]: mismatched types\n-  --> $DIR/coerce-suggestions.rs:36:11\n+  --> $DIR/coerce-suggestions.rs:35:11\n    |\n-36 |     test2(&y);\n+35 |     test2(&y);\n    |           ^^ types differ in mutability\n    |\n    = note: expected type `&mut i32`\n               found type `&std::string::String`\n \n error[E0308]: mismatched types\n-  --> $DIR/coerce-suggestions.rs:42:9\n+  --> $DIR/coerce-suggestions.rs:41:9\n    |\n-42 |     f = box f;\n+41 |     f = box f;\n    |         ^^^^^ cyclic type of infinite size\n    |\n    = note: expected type `_`"}, {"sha": "93aa502ee153133293c80fbe183df6fb63b61580", "filename": "src/test/ui/span/issue-33884.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fui%2Fspan%2Fissue-33884.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fui%2Fspan%2Fissue-33884.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-33884.rs?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::net::TcpListener;\n+use std::net::TcpStream;\n+use std::io::{self, Read, Write};\n+\n+fn handle_client(stream: TcpStream) -> io::Result<()> {\n+    stream.write_fmt(format!(\"message received\"))\n+}\n+\n+fn main() {\n+    if let Ok(listener) = TcpListener::bind(\"127.0.0.1:8080\") {\n+        for incoming in listener.incoming() {\n+            if let Ok(stream) = incoming {\n+                handle_client(stream);\n+            }\n+        }\n+    }\n+}"}, {"sha": "2a874181c7ad9a03332c073bbde569fce15ebc76", "filename": "src/test/ui/span/issue-33884.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fui%2Fspan%2Fissue-33884.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff13b7c91813eb178c98a7abc661acaf5c41dc31/src%2Ftest%2Fui%2Fspan%2Fissue-33884.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-33884.stderr?ref=ff13b7c91813eb178c98a7abc661acaf5c41dc31", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-33884.rs:16:22\n+   |\n+16 |     stream.write_fmt(format!(\"message received\"))\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::fmt::Arguments`, found struct `std::string::String`\n+   |\n+   = note: expected type `std::fmt::Arguments<'_>`\n+              found type `std::string::String`\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: aborting due to previous error\n+"}]}