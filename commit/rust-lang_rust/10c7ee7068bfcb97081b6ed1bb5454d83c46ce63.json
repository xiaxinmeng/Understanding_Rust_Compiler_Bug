{"sha": "10c7ee7068bfcb97081b6ed1bb5454d83c46ce63", "node_id": "C_kwDOAAsO6NoAKDEwYzdlZTcwNjhiZmNiOTcwODFiNmVkMWJiNTQ1NGQ4M2M0NmNlNjM", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-07-21T06:48:09Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-07-21T06:48:09Z"}, "message": "Simplify", "tree": {"sha": "f79e7ab16844949bca3f1d11adec026dd73d3965", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f79e7ab16844949bca3f1d11adec026dd73d3965"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10c7ee7068bfcb97081b6ed1bb5454d83c46ce63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10c7ee7068bfcb97081b6ed1bb5454d83c46ce63", "html_url": "https://github.com/rust-lang/rust/commit/10c7ee7068bfcb97081b6ed1bb5454d83c46ce63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10c7ee7068bfcb97081b6ed1bb5454d83c46ce63/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bd2e305d667e53314601ef04435d59b25e65235", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bd2e305d667e53314601ef04435d59b25e65235", "html_url": "https://github.com/rust-lang/rust/commit/7bd2e305d667e53314601ef04435d59b25e65235"}], "stats": {"total": 117, "additions": 54, "deletions": 63}, "files": [{"sha": "4309411419334d4a3bf358f96d15bf145aa07c5c", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 54, "deletions": 63, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/10c7ee7068bfcb97081b6ed1bb5454d83c46ce63/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10c7ee7068bfcb97081b6ed1bb5454d83c46ce63/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=10c7ee7068bfcb97081b6ed1bb5454d83c46ce63", "patch": "@@ -1,22 +1,23 @@\n //! Contains basic data about various HIR declarations.\n \n-use std::{mem, sync::Arc};\n+use std::sync::Arc;\n \n-use hir_expand::{name::Name, AstId, ExpandResult, HirFileId, InFile, MacroCallId, MacroDefKind};\n+use hir_expand::{name::Name, AstId, ExpandResult, HirFileId, MacroCallId, MacroDefKind};\n+use smallvec::SmallVec;\n use syntax::ast;\n \n use crate::{\n     attr::Attrs,\n     body::{Expander, Mark},\n     db::DefDatabase,\n     intern::Interned,\n-    item_tree::{self, AssocItem, FnFlags, ItemTreeId, ModItem, Param, TreeId},\n+    item_tree::{self, AssocItem, FnFlags, ItemTree, ItemTreeId, ModItem, Param, TreeId},\n     nameres::{attr_resolution::ResolvedAttr, DefMap},\n     type_ref::{TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n     AssocItemId, AstIdWithPath, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId,\n-    Intern, ItemContainerId, Lookup, Macro2Id, MacroRulesId, ModuleId, ProcMacroId, StaticId,\n-    TraitId, TypeAliasId, TypeAliasLoc,\n+    Intern, ItemContainerId, ItemLoc, Lookup, Macro2Id, MacroRulesId, ModuleId, ProcMacroId,\n+    StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -209,35 +210,31 @@ pub struct TraitData {\n \n impl TraitData {\n     pub(crate) fn trait_data_query(db: &dyn DefDatabase, tr: TraitId) -> Arc<TraitData> {\n-        let tr_loc = tr.lookup(db);\n-        let item_tree = tr_loc.id.item_tree(db);\n-        let tr_def = &item_tree[tr_loc.id.value];\n+        let tr_loc @ ItemLoc { container: module_id, id: tree_id } = tr.lookup(db);\n+        let item_tree = tree_id.item_tree(db);\n+        let tr_def = &item_tree[tree_id.value];\n         let _cx = stdx::panic_context::enter(format!(\n             \"trait_data_query({:?} -> {:?} -> {:?})\",\n             tr, tr_loc, tr_def\n         ));\n         let name = tr_def.name.clone();\n         let is_auto = tr_def.is_auto;\n         let is_unsafe = tr_def.is_unsafe;\n-        let module_id = tr_loc.container;\n         let visibility = item_tree[tr_def.visibility].clone();\n         let skip_array_during_method_dispatch = item_tree\n-            .attrs(db, tr_loc.container.krate(), ModItem::from(tr_loc.id.value).into())\n+            .attrs(db, module_id.krate(), ModItem::from(tree_id.value).into())\n             .by_key(\"rustc_skip_array_during_method_dispatch\")\n             .exists();\n \n-        let mut collector = AssocItemCollector::new(\n-            db,\n-            module_id,\n-            tr_loc.id.file_id(),\n-            ItemContainerId::TraitId(tr),\n-        );\n-        collector.collect(tr_loc.id.tree_id(), &tr_def.items);\n+        let mut collector =\n+            AssocItemCollector::new(db, module_id, tree_id.file_id(), ItemContainerId::TraitId(tr));\n+        collector.collect(&item_tree, tree_id.tree_id(), &tr_def.items);\n+        let (items, attribute_calls) = collector.finish();\n \n         Arc::new(TraitData {\n             name,\n-            attribute_calls: collector.take_attr_calls(),\n-            items: collector.items,\n+            attribute_calls,\n+            items,\n             is_auto,\n             is_unsafe,\n             visibility,\n@@ -284,25 +281,20 @@ pub struct ImplData {\n impl ImplData {\n     pub(crate) fn impl_data_query(db: &dyn DefDatabase, id: ImplId) -> Arc<ImplData> {\n         let _p = profile::span(\"impl_data_query\");\n-        let impl_loc = id.lookup(db);\n+        let ItemLoc { container: module_id, id: tree_id } = id.lookup(db);\n \n-        let item_tree = impl_loc.id.item_tree(db);\n-        let impl_def = &item_tree[impl_loc.id.value];\n+        let item_tree = tree_id.item_tree(db);\n+        let impl_def = &item_tree[tree_id.value];\n         let target_trait = impl_def.target_trait.clone();\n         let self_ty = impl_def.self_ty.clone();\n         let is_negative = impl_def.is_negative;\n-        let module_id = impl_loc.container;\n \n-        let mut collector = AssocItemCollector::new(\n-            db,\n-            module_id,\n-            impl_loc.id.file_id(),\n-            ItemContainerId::ImplId(id),\n-        );\n-        collector.collect(impl_loc.id.tree_id(), &impl_def.items);\n+        let mut collector =\n+            AssocItemCollector::new(db, module_id, tree_id.file_id(), ItemContainerId::ImplId(id));\n+        collector.collect(&item_tree, tree_id.tree_id(), &impl_def.items);\n \n-        let attribute_calls = collector.take_attr_calls();\n-        let items = collector.items.into_iter().map(|(_, item)| item).collect();\n+        let (items, attribute_calls) = collector.finish();\n+        let items = items.into_iter().map(|(_, item)| item).collect();\n \n         Arc::new(ImplData { target_trait, self_ty, items, is_negative, attribute_calls })\n     }\n@@ -463,18 +455,19 @@ impl<'a> AssocItemCollector<'a> {\n         }\n     }\n \n-    fn take_attr_calls(&mut self) -> Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>> {\n-        let attribute_calls = mem::take(&mut self.attr_calls);\n-        if attribute_calls.is_empty() {\n-            None\n-        } else {\n-            Some(Box::new(attribute_calls))\n-        }\n+    fn finish(\n+        self,\n+    ) -> (Vec<(Name, AssocItemId)>, Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>) {\n+        (\n+            self.items,\n+            if self.attr_calls.is_empty() { None } else { Some(Box::new(self.attr_calls)) },\n+        )\n     }\n \n     // FIXME: proc-macro diagnostics\n-    fn collect(&mut self, tree_id: TreeId, assoc_items: &[AssocItem]) {\n-        let item_tree = tree_id.item_tree(self.db);\n+    fn collect(&mut self, item_tree: &ItemTree, tree_id: TreeId, assoc_items: &[AssocItem]) {\n+        let container = self.container;\n+        self.items.reserve(assoc_items.len());\n \n         'items: for &item in assoc_items {\n             let attrs = item_tree.attrs(self.db, self.module_id.krate, ModItem::from(item).into());\n@@ -509,9 +502,9 @@ impl<'a> AssocItemCollector<'a> {\n                             continue 'attrs;\n                         }\n                     }\n-                    match self.expander.enter_expand_id(self.db, call_id) {\n-                        ExpandResult { value: Some((mark, mac)), .. } => {\n-                            self.collect_macro_items(mark, mac);\n+                    match self.expander.enter_expand_id::<ast::MacroItems>(self.db, call_id) {\n+                        ExpandResult { value: Some((mark, _)), .. } => {\n+                            self.collect_macro_items(mark);\n                             continue 'items;\n                         }\n                         ExpandResult { .. } => {}\n@@ -522,59 +515,57 @@ impl<'a> AssocItemCollector<'a> {\n             match item {\n                 AssocItem::Function(id) => {\n                     let item = &item_tree[id];\n+\n                     let def =\n-                        FunctionLoc { container: self.container, id: ItemTreeId::new(tree_id, id) }\n-                            .intern(self.db);\n+                        FunctionLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(self.db);\n                     self.items.push((item.name.clone(), def.into()));\n                 }\n                 AssocItem::Const(id) => {\n                     let item = &item_tree[id];\n+\n                     let name = match item.name.clone() {\n                         Some(name) => name,\n                         None => continue,\n                     };\n                     let def =\n-                        ConstLoc { container: self.container, id: ItemTreeId::new(tree_id, id) }\n-                            .intern(self.db);\n+                        ConstLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(self.db);\n                     self.items.push((name, def.into()));\n                 }\n                 AssocItem::TypeAlias(id) => {\n                     let item = &item_tree[id];\n-                    let def = TypeAliasLoc {\n-                        container: self.container,\n-                        id: ItemTreeId::new(tree_id, id),\n-                    }\n-                    .intern(self.db);\n+\n+                    let def = TypeAliasLoc { container, id: ItemTreeId::new(tree_id, id) }\n+                        .intern(self.db);\n                     self.items.push((item.name.clone(), def.into()));\n                 }\n                 AssocItem::MacroCall(call) => {\n-                    let call = &item_tree[call];\n-                    let ast_id_map = self.db.ast_id_map(self.expander.current_file_id());\n                     if let Some(root) = self.db.parse_or_expand(self.expander.current_file_id()) {\n+                        let call = &item_tree[call];\n+\n+                        let ast_id_map = self.db.ast_id_map(self.expander.current_file_id());\n                         let call = ast_id_map.get(call.ast_id).to_node(&root);\n                         let _cx = stdx::panic_context::enter(format!(\n                             \"collect_items MacroCall: {}\",\n                             call\n                         ));\n-                        let res = self.expander.enter_expand(self.db, call);\n+                        let res = self.expander.enter_expand::<ast::MacroItems>(self.db, call);\n \n-                        if let Ok(ExpandResult { value: Some((mark, mac)), .. }) = res {\n-                            self.collect_macro_items(mark, mac);\n+                        if let Ok(ExpandResult { value: Some((mark, _)), .. }) = res {\n+                            self.collect_macro_items(mark);\n                         }\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn collect_macro_items(&mut self, mark: Mark, mac: ast::MacroItems) {\n-        let src: InFile<ast::MacroItems> = self.expander.to_source(mac);\n-        let tree_id = item_tree::TreeId::new(src.file_id, None);\n+    fn collect_macro_items(&mut self, mark: Mark) {\n+        let tree_id = item_tree::TreeId::new(self.expander.current_file_id(), None);\n         let item_tree = tree_id.item_tree(self.db);\n-        let iter: Vec<_> =\n+        let iter: SmallVec<[_; 2]> =\n             item_tree.top_level_items().iter().filter_map(ModItem::as_assoc_item).collect();\n \n-        self.collect(tree_id, &iter);\n+        self.collect(&item_tree, tree_id, &iter);\n \n         self.expander.exit(self.db, mark);\n     }"}]}