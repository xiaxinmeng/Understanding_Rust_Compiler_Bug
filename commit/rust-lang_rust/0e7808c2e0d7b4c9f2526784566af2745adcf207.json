{"sha": "0e7808c2e0d7b4c9f2526784566af2745adcf207", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNzgwOGMyZTBkN2I0YzlmMjUyNjc4NDU2NmFmMjc0NWFkY2YyMDc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-08-15T16:21:16Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-08-16T20:30:43Z"}, "message": "debuginfo: Support for combinations of Self type and type parameters.", "tree": {"sha": "ef2818e7c0a8548c3b90cb4d99b33d1bda27f920", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef2818e7c0a8548c3b90cb4d99b33d1bda27f920"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e7808c2e0d7b4c9f2526784566af2745adcf207", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e7808c2e0d7b4c9f2526784566af2745adcf207", "html_url": "https://github.com/rust-lang/rust/commit/0e7808c2e0d7b4c9f2526784566af2745adcf207", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e7808c2e0d7b4c9f2526784566af2745adcf207/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "024d644c68fa9758f003260b23834032da1a6613", "url": "https://api.github.com/repos/rust-lang/rust/commits/024d644c68fa9758f003260b23834032da1a6613", "html_url": "https://github.com/rust-lang/rust/commit/024d644c68fa9758f003260b23834032da1a6613"}], "stats": {"total": 214, "additions": 81, "deletions": 133}, "files": [{"sha": "72af558e5e1fe8b5b1d08ef8a8d3097c0cd5d125", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 81, "deletions": 133, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/0e7808c2e0d7b4c9f2526784566af2745adcf207/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e7808c2e0d7b4c9f2526784566af2745adcf207/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0e7808c2e0d7b4c9f2526784566af2745adcf207", "patch": "@@ -69,7 +69,7 @@ use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n use std::vec;\n use syntax::codemap::span;\n-use syntax::{ast, codemap, ast_util, ast_map};\n+use syntax::{ast, codemap, ast_util, ast_map, opt_vec};\n use syntax::parse::token::special_idents;\n \n static DW_LANG_RUST: int = 0x9000;\n@@ -334,12 +334,14 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n         None => { /* fallthrough */}\n     }\n \n+    let empty_generics = ast::Generics { lifetimes: opt_vec::Empty, ty_params: opt_vec::Empty };\n+\n     let fnitem = cx.tcx.items.get_copy(&fcx.id);\n-    let (ident, fn_decl, generics, span, is_trait_default_impl) = match fnitem {\n+    let (ident, fn_decl, generics, span) = match fnitem {\n         ast_map::node_item(ref item, _) => {\n             match item.node {\n                 ast::item_fn(ref fn_decl, _, _, ref generics, _) => {\n-                    (item.ident, fn_decl, Some(generics), item.span, false)\n+                    (item.ident, fn_decl, generics, item.span)\n                 }\n                 _ => fcx.ccx.sess.span_bug(item.span,\n                                            \"create_function_metadata: item bound to non-function\")\n@@ -355,7 +357,7 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n             },\n             _,\n             _) => {\n-            (ident, fn_decl, Some(generics), span, false)\n+            (ident, fn_decl, generics, span)\n         }\n         ast_map::node_expr(ref expr) => {\n             match expr.node {\n@@ -364,9 +366,8 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n                     (name, fn_decl,\n                         // This is not quite right. It should actually inherit the generics of the\n                         // enclosing function.\n-                        None,\n-                        expr.span,\n-                        false)\n+                        &empty_generics,\n+                        expr.span)\n                 }\n                 _ => fcx.ccx.sess.span_bug(expr.span,\n                         \"create_function_metadata: expected an expr_fn_block here\")\n@@ -383,7 +384,7 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n                 }),\n             _,\n             _) => {\n-            (ident, fn_decl, Some(generics), span, true)\n+            (ident, fn_decl, generics, span)\n         }\n         _ => fcx.ccx.sess.bug(fmt!(\"create_function_metadata: unexpected sort of node: %?\", fnitem))\n     };\n@@ -404,7 +405,6 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n     let mut function_name = cx.sess.str_of(ident).to_owned();\n     let template_parameters = get_template_parameters(fcx,\n                                                       generics,\n-                                                      is_trait_default_impl,\n                                                       file_metadata,\n                                                       span,\n                                                       &mut function_name);\n@@ -506,153 +506,101 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n     }\n \n     fn get_template_parameters(fcx: &FunctionContext,\n-                               generics: Option<&ast::Generics>,\n-                               is_trait_default_impl: bool,\n+                               generics: &ast::Generics,\n                                file_metadata: DIFile,\n                                span: span,\n                                name_to_append_suffix_to: &mut ~str)\n                             -> DIArray {\n-        // Normalize cases\n-        let generics = match generics {\n-            Some(generics_ref) if generics_ref.is_type_parameterized() => Some(generics_ref),\n+        let cx = fcx.ccx;\n+\n+        let self_type = match fcx.param_substs {\n+            Some(@param_substs{ self_ty: self_type, _ }) => self_type,\n             _ => None\n         };\n \n-        let cx = fcx.ccx;\n-\n-        match generics {\n-            None => {\n-                if (!is_trait_default_impl && fcx.param_substs.is_some()) {\n-                    cx.sess.span_bug(span, \"debuginfo::create_function_metadata() - \\\n-                        Mismatch between ast::Generics (does not exist) and \\\n-                        FunctionContext::param_substs (does exist)\");\n-                }\n+        // Only true for static default methods:\n+        let has_self_type = self_type.is_some();\n \n-                return ptr::null();\n-            }\n+        if !generics.is_type_parameterized() && !has_self_type {\n+            return ptr::null();\n+        }\n \n-            Some(generics) => {\n-                let (actual_types, actual_self_type) = match fcx.param_substs {\n-                    Some(@param_substs { tys: ref types, self_ty: ref self_type, _ }) => {\n-                        if is_trait_default_impl && self_type.is_none() {\n-                            cx.sess.span_bug(span, \"debuginfo::create_function_metadata() - \\\n-                                Expected self type parameter substitution for default \\\n-                                implementation of trait method\");\n-                        }\n+        name_to_append_suffix_to.push_char('<');\n \n-                        (types, self_type)\n-                    }\n-                    None => {\n-                        cx.sess.span_bug(span, \"debuginfo::create_function_metadata() - \\\n-                            Mismatch between ast::Generics (does exist) and \\\n-                            FunctionContext::param_substs (does not exist)\");\n-                    }\n-                };\n+        // The list to be filled with template parameters:\n+        let mut template_params: ~[DIDescriptor] = vec::with_capacity(generics.ty_params.len() + 1);\n \n-                name_to_append_suffix_to.push_char('<');\n+        // Handle self type\n+        if has_self_type {\n+            let actual_self_type = self_type.unwrap();\n+            let actual_self_type_metadata = type_metadata(cx,\n+                                                          actual_self_type,\n+                                                          codemap::dummy_sp());\n \n-                let mut template_params: ~[DIDescriptor] =\n-                    vec::with_capacity(actual_types.len() + 1);\n+            // Add self type name to <...> clause of function name\n+            let actual_self_type_name = ty_to_str(cx.tcx, actual_self_type);\n+            name_to_append_suffix_to.push_str(actual_self_type_name);\n+            if generics.is_type_parameterized() {\n+                name_to_append_suffix_to.push_str(\",\");\n+            }\n \n-                if is_trait_default_impl {\n-                    let actual_self_type_metadata = type_metadata(cx,\n-                                                                  actual_self_type.unwrap(),\n-                                                                  codemap::dummy_sp());\n+            let ident = special_idents::type_self;\n \n-                    // Add self type name to <...> clause of function name\n-                    let actual_self_type_name = ty_to_str(cx.tcx, actual_self_type.unwrap());\n-                    name_to_append_suffix_to.push_str(actual_self_type_name);\n-                    if actual_types.len() > 0 {\n-                        name_to_append_suffix_to.push_str(\",\");\n-                    }\n+            let param_metadata = do cx.sess.str_of(ident).to_c_str().with_ref |name| {\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                        DIB(cx),\n+                        file_metadata,\n+                        name,\n+                        actual_self_type_metadata,\n+                        ptr::null(),\n+                        0,\n+                        0)\n+                }\n+            };\n \n-                    let ident = special_idents::type_self;\n+            template_params.push(param_metadata);\n+        }\n \n-                    let param_metadata = do cx.sess.str_of(ident).to_c_str().with_ref |name| {\n-                        unsafe {\n-                            llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n-                                DIB(cx),\n-                                file_metadata,\n-                                name,\n-                                actual_self_type_metadata,\n-                                ptr::null(),\n-                                0,\n-                                0)\n-                        }\n-                    };\n+        // Handle other generic parameters\n+        let actual_types = match fcx.param_substs {\n+            Some(@param_substs { tys: ref types, _ }) => types,\n+            None => {\n+                return create_DIArray(DIB(cx), template_params);\n+            }\n+        };\n \n-                    template_params.push(param_metadata);\n-                }\n+        for (index, &ast::TyParam{ ident: ident, _ }) in generics.ty_params.iter().enumerate() {\n+            let actual_type = actual_types[index];\n+            let actual_type_metadata = type_metadata(cx, actual_type, codemap::dummy_sp());\n \n-                for (index, &ast::TyParam{ ident: ident, _ }) in generics\n-                                                                 .ty_params\n-                                                                 .iter()\n-                                                                 .enumerate() {\n-                    let actual_type = actual_types[index];\n-                    let actual_type_metadata = type_metadata(cx,\n-                                                             actual_type,\n-                                                             codemap::dummy_sp());\n-\n-                    // Add actual type name to <...> clause of function name\n-                    let actual_type_name = ty_to_str(cx.tcx, actual_type);\n-                    name_to_append_suffix_to.push_str(actual_type_name);\n-                    if index != generics.ty_params.len() - 1 {\n-                        name_to_append_suffix_to.push_str(\",\");\n-                    }\n+            // Add actual type name to <...> clause of function name\n+            let actual_type_name = ty_to_str(cx.tcx, actual_type);\n+            name_to_append_suffix_to.push_str(actual_type_name);\n \n-                    let param_metadata = do cx.sess.str_of(ident).to_c_str().with_ref |name| {\n-                        unsafe {\n-                            llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n-                                DIB(cx),\n-                                file_metadata,\n-                                name,\n-                                actual_type_metadata,\n-                                ptr::null(),\n-                                0,\n-                                0)\n-                        }\n-                    };\n+            if index != generics.ty_params.len() - 1 {\n+                name_to_append_suffix_to.push_str(\",\");\n+            }\n \n-                    template_params.push(param_metadata);\n+            let param_metadata = do cx.sess.str_of(ident).to_c_str().with_ref |name| {\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                        DIB(cx),\n+                        file_metadata,\n+                        name,\n+                        actual_type_metadata,\n+                        ptr::null(),\n+                        0,\n+                        0)\n                 }\n+            };\n \n-                // let template_params: ~[DIDescriptor] = do generics\n-                //     .ty_params\n-                //     .iter()\n-                //     .enumerate()\n-                //     .map |(index, &ast::TyParam{ ident: ident, _ })| {\n-\n-                //         let actual_type = actual_types[index];\n-                //         let actual_type_metadata = type_metadata(cx,\n-                //                                                  actual_type,\n-                //                                                  codemap::dummy_sp());\n-\n-                //         // Add actual type name to <...> clause of function name\n-                //         let actual_type_name = ty_to_str(cx.tcx, actual_type);\n-                //         name_to_append_suffix_to.push_str(actual_type_name);\n-                //         if index != generics.ty_params.len() - 1 {\n-                //             name_to_append_suffix_to.push_str(\",\");\n-                //         }\n-\n-                //         do cx.sess.str_of(ident).to_c_str().with_ref |name| {\n-                //             unsafe {\n-                //                 llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n-                //                     DIB(cx),\n-                //                     file_metadata,\n-                //                     name,\n-                //                     actual_type_metadata,\n-                //                     ptr::null(),\n-                //                     0,\n-                //                     0)\n-                //             }\n-                //         }\n-                //     }.collect();\n-\n-                name_to_append_suffix_to.push_char('>');\n-\n-                return create_DIArray(DIB(cx), template_params);\n-            }\n+            template_params.push(param_metadata);\n         }\n+\n+        name_to_append_suffix_to.push_char('>');\n+\n+        return create_DIArray(DIB(cx), template_params);\n     }\n }\n "}]}