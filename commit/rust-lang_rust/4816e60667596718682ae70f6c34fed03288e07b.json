{"sha": "4816e60667596718682ae70f6c34fed03288e07b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4MTZlNjA2Njc1OTY3MTg2ODJhZTcwZjZjMzRmZWQwMzI4OGUwN2I=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-07-22T18:53:52Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-08-06T12:57:52Z"}, "message": "create VariantDef-s (but don't actually use them)", "tree": {"sha": "3c78988bc16db44b222bef82b0772b3efc8cfae3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c78988bc16db44b222bef82b0772b3efc8cfae3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4816e60667596718682ae70f6c34fed03288e07b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4816e60667596718682ae70f6c34fed03288e07b", "html_url": "https://github.com/rust-lang/rust/commit/4816e60667596718682ae70f6c34fed03288e07b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4816e60667596718682ae70f6c34fed03288e07b/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "213b6d71f502a8568208cf549050a71cc24b1338", "url": "https://api.github.com/repos/rust-lang/rust/commits/213b6d71f502a8568208cf549050a71cc24b1338", "html_url": "https://github.com/rust-lang/rust/commit/213b6d71f502a8568208cf549050a71cc24b1338"}], "stats": {"total": 687, "additions": 504, "deletions": 183}, "files": [{"sha": "f97ffebaebb19586c5bb182acea50a07d0728da6", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4816e60667596718682ae70f6c34fed03288e07b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4816e60667596718682ae70f6c34fed03288e07b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=4816e60667596718682ae70f6c34fed03288e07b", "patch": "@@ -222,10 +222,10 @@ pub fn get_trait_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> ty::TraitDe\n     decoder::get_trait_def(&*cdata, def.node, tcx)\n }\n \n-pub fn get_adt_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> &'tcx ty::ADTDef<'tcx> {\n+pub fn get_adt_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> &'tcx ty::ADTDef_<'tcx, 'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_adt_def(&*cdata, def.node, tcx)\n+    decoder::get_adt_def(&cstore.intr, &*cdata, def.node, tcx)\n }\n \n pub fn get_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)"}, {"sha": "7a899218512f7d9e0da7fd7811cbb86819a3b960", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 104, "deletions": 5, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/4816e60667596718682ae70f6c34fed03288e07b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4816e60667596718682ae70f6c34fed03288e07b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=4816e60667596718682ae70f6c34fed03288e07b", "patch": "@@ -108,7 +108,7 @@ fn lookup_item<'a>(item_id: ast::NodeId, data: &'a [u8]) -> rbml::Doc<'a> {\n     find_item(item_id, items)\n }\n \n-#[derive(PartialEq)]\n+#[derive(Debug, PartialEq)]\n enum Family {\n     ImmStatic,             // c\n     MutStatic,             // b\n@@ -390,12 +390,111 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n     }\n }\n \n-pub fn get_adt_def<'tcx>(cdata: Cmd,\n+pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n+                         cdata: Cmd,\n                          item_id: ast::NodeId,\n-                         tcx: &ty::ctxt<'tcx>) -> &'tcx ty::ADTDef<'tcx>\n+                         tcx: &ty::ctxt<'tcx>) -> &'tcx ty::ADTDef_<'tcx, 'tcx>\n {\n-    tcx.intern_adt_def(ast::DefId { krate: cdata.cnum, node: item_id },\n-                       ty::ADTKind::Enum)\n+    fn get_enum_variants<'tcx>(intr: &IdentInterner,\n+                               cdata: Cmd,\n+                               doc: rbml::Doc,\n+                               tcx: &ty::ctxt<'tcx>) -> Vec<ty::VariantDef_<'tcx, 'tcx>> {\n+        let mut disr_val = 0;\n+        reader::tagged_docs(doc, tag_items_data_item_variant).map(|p| {\n+            let did = translated_def_id(cdata, p);\n+            let item = lookup_item(did.node, cdata.data());\n+\n+            if let Some(disr) = variant_disr_val(item) {\n+                disr_val = disr;\n+            }\n+            let disr = disr_val;\n+            disr_val = disr_val.wrapping_add(1);\n+\n+            ty::VariantDef_ {\n+                did: did,\n+                name: item_name(intr, item),\n+                fields: get_variant_fields(intr, cdata, item, tcx),\n+                disr_val: disr\n+            }\n+        }).collect()\n+    }\n+    fn get_variant_fields<'tcx>(intr: &IdentInterner,\n+                                cdata: Cmd,\n+                                doc: rbml::Doc,\n+                                tcx: &ty::ctxt<'tcx>) -> Vec<ty::FieldDef_<'tcx, 'tcx>> {\n+        reader::tagged_docs(doc, tag_item_field).map(|f| {\n+            let ff = item_family(f);\n+            match ff {\n+                PublicField | InheritedField => {},\n+                _ => tcx.sess.bug(&format!(\"expected field, found {:?}\", ff))\n+            };\n+            ty::FieldDef_::new(item_def_id(f, cdata),\n+                               item_name(intr, f),\n+                               struct_field_family_to_visibility(ff))\n+        }).chain(reader::tagged_docs(doc, tag_item_unnamed_field).map(|f| {\n+            let ff = item_family(f);\n+            ty::FieldDef_::new(item_def_id(f, cdata),\n+                               special_idents::unnamed_field.name,\n+                               struct_field_family_to_visibility(ff))\n+        })).collect()\n+    }\n+    fn get_struct_variant<'tcx>(intr: &IdentInterner,\n+                                cdata: Cmd,\n+                                doc: rbml::Doc,\n+                                did: ast::DefId,\n+                                tcx: &ty::ctxt<'tcx>) -> ty::VariantDef_<'tcx, 'tcx> {\n+        ty::VariantDef_ {\n+            did: did,\n+            name: item_name(intr, doc),\n+            fields: get_variant_fields(intr, cdata, doc, tcx),\n+            disr_val: 0\n+        }\n+    }\n+\n+    let doc = lookup_item(item_id, cdata.data());\n+    let did = ast::DefId { krate: cdata.cnum, node: item_id };\n+    let (kind, variants) = match item_family(doc) {\n+        Enum => (ty::ADTKind::Enum,\n+                 get_enum_variants(intr, cdata, doc, tcx)),\n+        Struct => (ty::ADTKind::Struct,\n+                   vec![get_struct_variant(intr, cdata, doc, did, tcx)]),\n+        _ => tcx.sess.bug(\"get_adt_def called on a non-ADT\")\n+    };\n+\n+    let adt = tcx.intern_adt_def(did, kind, variants);\n+\n+    // this needs to be done *after* the variant is interned,\n+    // to support recursive structures\n+    for variant in &adt.variants {\n+        if variant.kind() == ty::VariantKind::Tuple &&\n+            adt.adt_kind() == ty::ADTKind::Enum {\n+            // tuple-like enum variant fields aren't real items - get the types\n+            // from the ctor.\n+            debug!(\"evaluating the ctor-type of {:?}\",\n+                   variant.name);\n+            let ctor_ty = get_type(cdata, variant.did.node, tcx).ty;\n+            debug!(\"evaluating the ctor-type of {:?}.. {:?}\",\n+                   variant.name,\n+                   ctor_ty);\n+            let field_tys = match ctor_ty.sty {\n+                ty::TyBareFn(_, ref f) => &f.sig.skip_binder().inputs,\n+                _ => tcx.sess.bug(\"tuple-variant ctor is not an ADT\")\n+            };\n+            for (field, &ty) in variant.fields.iter().zip(field_tys.iter()) {\n+                field.fulfill_ty(ty);\n+            }\n+        } else {\n+            for field in &variant.fields {\n+                debug!(\"evaluating the type of {:?}::{:?}\", variant.name, field.name);\n+                let ty = get_type(cdata, field.did.node, tcx).ty;\n+                field.fulfill_ty(ty);\n+                debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n+                       variant.name, field.name, ty);\n+            }\n+        }\n+    }\n+\n+    adt\n }\n \n pub fn get_predicates<'tcx>(cdata: Cmd,"}, {"sha": "4c4a1e07f44c1a7f745aa0d15ed9bd01e38641b9", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 44, "deletions": 48, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/4816e60667596718682ae70f6c34fed03288e07b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4816e60667596718682ae70f6c34fed03288e07b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=4816e60667596718682ae70f6c34fed03288e07b", "patch": "@@ -41,7 +41,6 @@ use syntax::attr::AttrMetaMethods;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust;\n-use syntax::ptr::P;\n use syntax::visit::Visitor;\n use syntax::visit;\n use syntax;\n@@ -266,7 +265,7 @@ fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n }\n \n fn encode_struct_fields(rbml_w: &mut Encoder,\n-                        fields: &[ty::FieldTy],\n+                        fields: &[ty::FieldDef],\n                         origin: DefId) {\n     for f in fields {\n         if f.name == special_idents::unnamed_field.name {\n@@ -276,7 +275,7 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n             encode_name(rbml_w, f.name);\n         }\n         encode_struct_field_family(rbml_w, f.vis);\n-        encode_def_id(rbml_w, f.id);\n+        encode_def_id(rbml_w, f.did);\n         rbml_w.wr_tagged_u64(tag_item_field_origin, def_to_u64(origin));\n         rbml_w.end_tag();\n     }\n@@ -285,57 +284,56 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n fn encode_enum_variant_info(ecx: &EncodeContext,\n                             rbml_w: &mut Encoder,\n                             id: NodeId,\n-                            variants: &[P<ast::Variant>],\n+                            vis: ast::Visibility,\n                             index: &mut Vec<entry<i64>>) {\n     debug!(\"encode_enum_variant_info(id={})\", id);\n \n     let mut disr_val = 0;\n-    let mut i = 0;\n-    let vi = ecx.tcx.enum_variants(local_def(id));\n-    for variant in variants {\n-        let def_id = local_def(variant.node.id);\n+    let def = ecx.tcx.lookup_adt_def(local_def(id));\n+    for variant in &def.variants {\n+        let vid = variant.did;\n+        assert!(is_local(vid));\n         index.push(entry {\n-            val: variant.node.id as i64,\n+            val: vid.node as i64,\n             pos: rbml_w.mark_stable_position(),\n         });\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n-        match variant.node.kind {\n-            ast::TupleVariantKind(_) => encode_family(rbml_w, 'v'),\n-            ast::StructVariantKind(_) => encode_family(rbml_w, 'V')\n-        }\n-        encode_name(rbml_w, variant.node.name.name);\n+        encode_def_id(rbml_w, vid);\n+        encode_family(rbml_w, match variant.kind() {\n+            ty::VariantKind::Unit | ty::VariantKind::Tuple => 'v',\n+            ty::VariantKind::Dict => 'V'\n+        });\n+        encode_name(rbml_w, variant.name);\n         encode_parent_item(rbml_w, local_def(id));\n-        encode_visibility(rbml_w, variant.node.vis);\n-        encode_attributes(rbml_w, &variant.node.attrs);\n-        encode_repr_attrs(rbml_w, ecx, &variant.node.attrs);\n+        encode_visibility(rbml_w, vis);\n+\n+        let attrs = ecx.tcx.get_attrs(vid);\n+        encode_attributes(rbml_w, &attrs);\n+        encode_repr_attrs(rbml_w, ecx, &attrs);\n \n-        let stab = stability::lookup(ecx.tcx, ast_util::local_def(variant.node.id));\n+        let stab = stability::lookup(ecx.tcx, vid);\n         encode_stability(rbml_w, stab);\n \n-        match variant.node.kind {\n-            ast::TupleVariantKind(_) => {},\n-            ast::StructVariantKind(_) => {\n-                let fields = ecx.tcx.lookup_struct_fields(def_id);\n-                let idx = encode_info_for_struct(ecx,\n-                                                 rbml_w,\n-                                                 &fields[..],\n-                                                 index);\n-                encode_struct_fields(rbml_w, &fields[..], def_id);\n-                encode_index(rbml_w, idx, write_i64);\n-            }\n+        if let ty::VariantKind::Dict = variant.kind() {\n+            let idx = encode_info_for_struct(ecx,\n+                                             rbml_w,\n+                                             &variant.fields,\n+                                             index);\n+            encode_index(rbml_w, idx, write_i64);\n         }\n-        let specified_disr_val = vi[i].disr_val;\n+\n+        encode_struct_fields(rbml_w, &variant.fields, vid);\n+\n+        let specified_disr_val = variant.disr_val;\n         if specified_disr_val != disr_val {\n             encode_disr_val(ecx, rbml_w, specified_disr_val);\n             disr_val = specified_disr_val;\n         }\n-        encode_bounds_and_type_for_item(rbml_w, ecx, def_id.local_id());\n+        encode_bounds_and_type_for_item(rbml_w, ecx, vid.node);\n \n-        ecx.tcx.map.with_path(variant.node.id, |path| encode_path(rbml_w, path));\n+        ecx.tcx.map.with_path(vid.node, |path| encode_path(rbml_w, path));\n         rbml_w.end_tag();\n         disr_val = disr_val.wrapping_add(1);\n-        i += 1;\n     }\n }\n \n@@ -630,19 +628,19 @@ fn encode_provided_source(rbml_w: &mut Encoder,\n }\n \n /* Returns an index of items in this class */\n-fn encode_info_for_struct(ecx: &EncodeContext,\n-                          rbml_w: &mut Encoder,\n-                          fields: &[ty::FieldTy],\n-                          global_index: &mut Vec<entry<i64>>)\n-                          -> Vec<entry<i64>> {\n+fn encode_info_for_struct<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                    rbml_w: &mut Encoder,\n+                                    fields: &[ty::FieldDef<'tcx>],\n+                                    global_index: &mut Vec<entry<i64>>)\n+                                    -> Vec<entry<i64>> {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n     let mut index = Vec::new();\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n     for field in fields {\n         let nm = field.name;\n-        let id = field.id.node;\n+        let id = field.did.node;\n \n         let pos = rbml_w.mark_stable_position();\n         index.push(entry {val: id as i64, pos: pos});\n@@ -658,7 +656,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         encode_bounds_and_type_for_item(rbml_w, ecx, id);\n         encode_def_id(rbml_w, local_def(id));\n \n-        let stab = stability::lookup(ecx.tcx, field.id);\n+        let stab = stability::lookup(ecx.tcx, field.did);\n         encode_stability(rbml_w, stab);\n \n         rbml_w.end_tag();\n@@ -1150,20 +1148,18 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_enum_variant_info(ecx,\n                                  rbml_w,\n                                  item.id,\n-                                 &(*enum_definition).variants,\n+                                 vis,\n                                  index);\n       }\n       ast::ItemStruct(ref struct_def, _) => {\n-        let fields = tcx.lookup_struct_fields(def_id);\n+        let def = ecx.tcx.lookup_adt_def(def_id);\n+        let fields = &def.struct_variant().fields;\n \n         /* First, encode the fields\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n            class itself */\n-        let idx = encode_info_for_struct(ecx,\n-                                         rbml_w,\n-                                         &fields[..],\n-                                         index);\n+        let idx = encode_info_for_struct(ecx, rbml_w, &fields, index);\n \n         /* Index the class*/\n         add_to_index(item, rbml_w, index);\n@@ -1185,7 +1181,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(rbml_w, &fields[..], def_id);\n+        encode_struct_fields(rbml_w, &fields, def_id);\n \n         encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n "}, {"sha": "5cef50be770977c100f153b1e0a1fcbd42f99237", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4816e60667596718682ae70f6c34fed03288e07b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4816e60667596718682ae70f6c34fed03288e07b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=4816e60667596718682ae70f6c34fed03288e07b", "patch": "@@ -513,7 +513,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                 &Variant(vid) =>\n                     (vid, cx.tcx.enum_variant_with_id(cid.did, vid).arg_names.is_some()),\n                 _ =>\n-                    (cid.did, !cid.is_tuple_struct(cx.tcx))\n+                    (cid.did, !cid.struct_variant().is_tuple_struct())\n             };\n             if is_structure {\n                 let fields = cx.tcx.lookup_struct_fields(vid);"}, {"sha": "0354918acf8fc638aed96644478afc6489da2e14", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 133, "deletions": 18, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/4816e60667596718682ae70f6c34fed03288e07b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4816e60667596718682ae70f6c34fed03288e07b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4816e60667596718682ae70f6c34fed03288e07b", "patch": "@@ -74,10 +74,12 @@ use std::cell::{Cell, RefCell, Ref};\n use std::cmp;\n use std::fmt;\n use std::hash::{Hash, SipHasher, Hasher};\n+use std::iter;\n use std::marker::PhantomData;\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n+use std::slice;\n use std::vec::IntoIter;\n use collections::enum_set::{self, EnumSet, CLike};\n use core::nonzero::NonZero;\n@@ -90,7 +92,7 @@ use syntax::ast::{StructField, UnnamedField, Visibility};\n use syntax::ast_util::{self, is_local, local_def};\n use syntax::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n use syntax::codemap::Span;\n-use syntax::parse::token::{self, InternedString, special_idents};\n+use syntax::parse::token::{InternedString, special_idents};\n use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::ast;\n@@ -211,7 +213,7 @@ impl DtorKind {\n     }\n }\n \n-trait IntTypeExt {\n+pub trait IntTypeExt {\n     fn to_ty<'tcx>(&self, cx: &ctxt<'tcx>) -> Ty<'tcx>;\n     fn i64_to_disr(&self, val: i64) -> Option<Disr>;\n     fn u64_to_disr(&self, val: u64) -> Option<Disr>;\n@@ -852,7 +854,7 @@ pub struct ctxt<'tcx> {\n \n     pub impl_trait_refs: RefCell<DefIdMap<Option<TraitRef<'tcx>>>>,\n     pub trait_defs: RefCell<DefIdMap<&'tcx TraitDef<'tcx>>>,\n-    pub adt_defs: RefCell<DefIdMap<&'tcx ADTDef<'tcx>>>,\n+    pub adt_defs: RefCell<DefIdMap<&'tcx ADTDef_<'tcx, 'tcx>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated predicates.\n@@ -1023,8 +1025,12 @@ impl<'tcx> ctxt<'tcx> {\n         interned\n     }\n \n-    pub fn intern_adt_def(&self, did: DefId, kind: ADTKind) -> &'tcx ADTDef_<'tcx, 'tcx> {\n-        let def = ADTDef_::new(self, did, kind);\n+    pub fn intern_adt_def(&self,\n+                          did: DefId,\n+                          kind: ADTKind,\n+                          variants: Vec<VariantDef_<'tcx, 'tcx>>)\n+                          -> &'tcx ADTDef_<'tcx, 'tcx> {\n+        let def = ADTDef_::new(self, did, kind, variants);\n         let interned = self.arenas.adt_defs.alloc(def);\n         // this will need a transmute when reverse-variance is removed\n         self.adt_defs.borrow_mut().insert(did, interned);\n@@ -2190,7 +2196,7 @@ pub struct ExistentialBounds<'tcx> {\n pub struct BuiltinBounds(EnumSet<BuiltinBound>);\n \n impl BuiltinBounds {\n-       pub fn empty() -> BuiltinBounds {\n+    pub fn empty() -> BuiltinBounds {\n         BuiltinBounds(EnumSet::new())\n     }\n \n@@ -3274,17 +3280,21 @@ bitflags! {\n }\n \n pub type ADTDef<'tcx> = ADTDef_<'tcx, 'static>;\n+pub type VariantDef<'tcx> = VariantDef_<'tcx, 'static>;\n+pub type FieldDef<'tcx> = FieldDef_<'tcx, 'static>;\n \n-pub struct VariantDef<'tcx, 'lt: 'tcx> {\n+pub struct VariantDef_<'tcx, 'lt: 'tcx> {\n     pub did: DefId,\n     pub name: Name, // struct's name if this is a struct\n     pub disr_val: Disr,\n-    pub fields: Vec<FieldDef<'tcx, 'lt>>\n+    pub fields: Vec<FieldDef_<'tcx, 'lt>>\n }\n \n-pub struct FieldDef<'tcx, 'lt: 'tcx> {\n+pub struct FieldDef_<'tcx, 'lt: 'tcx> {\n     pub did: DefId,\n-    pub name: Name, // XXX if tuple-like\n+    // special_idents::unnamed_field.name\n+    // if this is a tuple-like field\n+    pub name: Name,\n     pub vis: ast::Visibility,\n     // TyIVar is used here to allow for\n     ty: TyIVar<'tcx, 'lt>\n@@ -3294,7 +3304,7 @@ pub struct FieldDef<'tcx, 'lt: 'tcx> {\n /// is here so 'tcx can be variant.\n pub struct ADTDef_<'tcx, 'lt: 'tcx> {\n     pub did: DefId,\n-    pub variants: Vec<VariantDef<'tcx, 'lt>>,\n+    pub variants: Vec<VariantDef_<'tcx, 'lt>>,\n     flags: Cell<ADTFlags>,\n }\n \n@@ -3313,11 +3323,18 @@ impl<'tcx, 'lt> Hash for ADTDef_<'tcx, 'lt> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum ADTKind { Struct, Enum }\n \n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub enum VariantKind { Dict, Tuple, Unit }\n+\n impl<'tcx, 'lt> ADTDef_<'tcx, 'lt> {\n-    fn new(tcx: &ctxt<'tcx>, did: DefId, kind: ADTKind) -> Self {\n+    fn new(tcx: &ctxt<'tcx>,\n+           did: DefId,\n+           kind: ADTKind,\n+           variants: Vec<VariantDef_<'tcx, 'lt>>) -> Self {\n         let mut flags = ADTFlags::NO_ADT_FLAGS;\n         if tcx.has_attr(did, \"fundamental\") {\n             flags = flags | ADTFlags::IS_FUNDAMENTAL;\n@@ -3330,7 +3347,7 @@ impl<'tcx, 'lt> ADTDef_<'tcx, 'lt> {\n         }\n         ADTDef {\n             did: did,\n-            variants: vec![],\n+            variants: variants,\n             flags: Cell::new(flags),\n         }\n     }\n@@ -3374,9 +3391,9 @@ impl<'tcx, 'lt> ADTDef_<'tcx, 'lt> {\n         tcx.destructor_for_type.borrow().contains_key(&self.did)\n     }\n \n-    pub fn is_tuple_struct(&self, tcx: &ctxt<'tcx>) -> bool {\n-        let fields = tcx.lookup_struct_fields(self.did);\n-        !fields.is_empty() && fields.iter().all(|f| f.name == token::special_names::unnamed_field)\n+    pub fn struct_variant(&self) -> &ty::VariantDef_<'tcx, 'lt> {\n+        assert!(self.adt_kind() == ADTKind::Struct);\n+        &self.variants[0]\n     }\n \n     #[inline]\n@@ -3388,6 +3405,104 @@ impl<'tcx, 'lt> ADTDef_<'tcx, 'lt> {\n     pub fn predicates(&self, tcx: &ctxt<'tcx>) -> GenericPredicates<'tcx> {\n         tcx.lookup_predicates(self.did)\n     }\n+\n+    #[inline]\n+    pub fn all_fields(&self) ->\n+            iter::FlatMap<\n+                slice::Iter<VariantDef_<'tcx, 'lt>>,\n+                slice::Iter<FieldDef_<'tcx, 'lt>>,\n+                for<'s> fn(&'s VariantDef_<'tcx, 'lt>)\n+                    -> slice::Iter<'s, FieldDef_<'tcx, 'lt>>\n+            > {\n+        self.variants.iter().flat_map(VariantDef_::fields_iter)\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        // FIXME(#TODO(wxyz)): be smarter here\n+        self.variants.is_empty()\n+    }\n+\n+    #[inline]\n+    pub fn is_univariant(&self) -> bool {\n+        self.variants.len() == 1\n+    }\n+\n+    pub fn is_payloadfree(&self) -> bool {\n+        !self.variants.is_empty() &&\n+            self.variants.iter().all(|v| v.fields.is_empty())\n+    }\n+\n+    pub fn variant_with_id(&self, vid: DefId) -> &VariantDef_<'tcx, 'lt> {\n+        self.variants\n+            .iter()\n+            .find(|v| v.did == vid)\n+            .expect(\"variant_with_id: unknown variant\")\n+    }\n+\n+    pub fn variant_of_def(&self, def: def::Def) -> &VariantDef_<'tcx, 'lt> {\n+        match def {\n+            def::DefVariant(_, vid, _) => self.variant_with_id(vid),\n+            def::DefStruct(..) | def::DefTy(..) => self.struct_variant(),\n+            _ => panic!(\"unexpected def {:?} in variant_of_def\", def)\n+        }\n+    }\n+}\n+\n+impl<'tcx, 'lt> VariantDef_<'tcx, 'lt> {\n+    #[inline]\n+    fn fields_iter(&self) -> slice::Iter<FieldDef_<'tcx, 'lt>> {\n+        self.fields.iter()\n+    }\n+\n+    pub fn kind(&self) -> VariantKind {\n+        match self.fields.get(0) {\n+            None => VariantKind::Unit,\n+            Some(&FieldDef_ { name, .. }) if name == special_idents::unnamed_field.name => {\n+                VariantKind::Tuple\n+            }\n+            Some(_) => VariantKind::Dict\n+        }\n+    }\n+\n+    pub fn is_tuple_struct(&self) -> bool {\n+        self.kind() == VariantKind::Tuple\n+    }\n+\n+    #[inline]\n+    pub fn find_field_named(&self, name: ast::Name) -> Option<&FieldDef_<'tcx, 'lt>> {\n+        self.fields.iter().find(|f| f.name == name)\n+    }\n+\n+    #[inline]\n+    pub fn field_named(&self, name: ast::Name) -> &FieldDef_<'tcx, 'lt> {\n+        self.find_field_named(name).unwrap()\n+    }\n+}\n+\n+impl<'tcx, 'lt> FieldDef_<'tcx, 'lt> {\n+    pub fn new(did: DefId,\n+               name: Name,\n+               vis: ast::Visibility) -> Self {\n+        FieldDef_ {\n+            did: did,\n+            name: name,\n+            vis: vis,\n+            ty: TyIVar::new()\n+        }\n+    }\n+\n+    pub fn ty(&self, tcx: &ctxt<'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n+        self.unsubst_ty().subst(tcx, subst)\n+    }\n+\n+    pub fn unsubst_ty(&self) -> Ty<'tcx> {\n+        self.ty.unwrap()\n+    }\n+\n+    pub fn fulfill_ty(&self, ty: Ty<'lt>) {\n+        self.ty.fulfill(ty);\n+    }\n }\n \n /// Records the substitutions used to translate the polytype for an\n@@ -6132,7 +6247,7 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n-    pub fn lookup_adt_def(&self, did: ast::DefId) -> &'tcx ADTDef<'tcx> {\n+    pub fn lookup_adt_def(&self, did: ast::DefId) -> &'tcx ADTDef_<'tcx, 'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"adt_defs\", did, &self.adt_defs,\n             || csearch::get_adt_def(self, did)"}, {"sha": "2f63d7abe4afcf8e0f567455652017ec55fb65a8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4816e60667596718682ae70f6c34fed03288e07b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4816e60667596718682ae70f6c34fed03288e07b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4816e60667596718682ae70f6c34fed03288e07b", "patch": "@@ -2980,7 +2980,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   |base_t, _| {\n                 match base_t.sty {\n                     ty::TyStruct(base_def, substs) => {\n-                        tuple_like = base_def.is_tuple_struct(tcx);\n+                        tuple_like = base_def.struct_variant().is_tuple_struct();\n                         if tuple_like {\n                             debug!(\"tuple struct named {:?}\",  base_t);\n                             let fields = tcx.lookup_struct_fields(base_def.did);"}, {"sha": "c9f6ccb8cb2e769df5f5bc095951ec95c1220b14", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 219, "deletions": 108, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/4816e60667596718682ae70f6c34fed03288e07b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4816e60667596718682ae70f6c34fed03288e07b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4816e60667596718682ae70f6c34fed03288e07b", "patch": "@@ -71,9 +71,12 @@ use middle::lang_items::SizedTraitLangItem;\n use middle::free_region::FreeRegionMap;\n use middle::region;\n use middle::resolve_lifetime;\n+use middle::const_eval::{self, ConstVal};\n+use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace, VecPerParamSpace};\n use middle::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n-use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty, TypeScheme};\n+use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty, TypeScheme, IntTypeExt};\n+use middle::ty::{VariantKind};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n use middle::infer;\n use rscope::*;\n@@ -89,8 +92,10 @@ use std::rc::Rc;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_util::local_def;\n+use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n+use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::visit;\n \n@@ -563,48 +568,6 @@ fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n }\n \n-fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                    enum_scheme: ty::TypeScheme<'tcx>,\n-                                    enum_predicates: ty::GenericPredicates<'tcx>,\n-                                    variants: &[P<ast::Variant>]) {\n-    let tcx = ccx.tcx;\n-    let icx = ccx.icx(&enum_predicates);\n-\n-    // Create a set of parameter types shared among all the variants.\n-    for variant in variants {\n-        let variant_def_id = local_def(variant.node.id);\n-\n-        // Nullary enum constructors get turned into constants; n-ary enum\n-        // constructors get turned into functions.\n-        let result_ty = match variant.node.kind {\n-            ast::TupleVariantKind(ref args) if !args.is_empty() => {\n-                let rs = ExplicitRscope;\n-                let input_tys: Vec<_> = args.iter().map(|va| icx.to_ty(&rs, &*va.ty)).collect();\n-                tcx.mk_ctor_fn(variant_def_id, &input_tys, enum_scheme.ty)\n-            }\n-\n-            ast::TupleVariantKind(_) => {\n-                enum_scheme.ty\n-            }\n-\n-            ast::StructVariantKind(ref struct_def) => {\n-                convert_struct(ccx, &**struct_def, enum_scheme.clone(),\n-                               enum_predicates.clone(), variant.node.id);\n-                enum_scheme.ty\n-            }\n-        };\n-\n-        let variant_scheme = TypeScheme {\n-            generics: enum_scheme.generics.clone(),\n-            ty: result_ty\n-        };\n-\n-        tcx.register_item_type(variant_def_id, variant_scheme.clone());\n-        tcx.predicates.borrow_mut().insert(variant_def_id, enum_predicates.clone());\n-        write_ty_to_tcx(tcx, variant.node.id, result_ty);\n-    }\n-}\n-\n fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             container: ImplOrTraitItemContainer,\n                             sig: &ast::MethodSig,\n@@ -657,10 +620,12 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            struct_generics: &ty::Generics<'tcx>,\n                            struct_predicates: &ty::GenericPredicates<'tcx>,\n                            v: &ast::StructField,\n+                           ty_f: &'tcx ty::FieldDef_<'tcx, 'tcx>,\n                            origin: ast::DefId)\n                            -> ty::FieldTy\n {\n     let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &*v.node.ty);\n+    ty_f.fulfill_ty(tt);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n \n     /* add the field to the tcache */\n@@ -803,10 +768,11 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n         ast::ItemEnum(ref enum_definition, _) => {\n             let (scheme, predicates) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n-            get_enum_variant_types(ccx,\n-                                   scheme,\n-                                   predicates,\n-                                   &enum_definition.variants);\n+            convert_enum_variant_types(ccx,\n+                                       tcx.lookup_adt_def(local_def(it.id)),\n+                                       scheme,\n+                                       predicates,\n+                                       &enum_definition.variants);\n         },\n         ast::ItemDefaultImpl(_, ref ast_trait_ref) => {\n             let trait_ref =\n@@ -1048,10 +1014,14 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             }\n         },\n         ast::ItemStruct(ref struct_def, _) => {\n-            // Write the class type.\n             let (scheme, predicates) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n-            convert_struct(ccx, &**struct_def, scheme, predicates, it.id);\n+\n+            let variant = tcx.lookup_adt_def(local_def(it.id)).struct_variant();\n+            convert_struct_variant_types(ccx, &struct_def, variant, &scheme, &predicates);\n+            if let Some(ctor_id) = struct_def.ctor_id {\n+                convert_variant_ctor(tcx, ctor_id, variant, scheme, predicates);\n+            }\n         },\n         ast::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n@@ -1068,74 +1038,216 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n     }\n }\n \n-fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                            struct_def: &ast::StructDef,\n-                            scheme: ty::TypeScheme<'tcx>,\n-                            predicates: ty::GenericPredicates<'tcx>,\n-                            id: ast::NodeId) {\n+fn convert_variant_ctor<'a, 'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                  ctor_id: ast::NodeId,\n+                                  variant: &'tcx ty::VariantDef<'tcx>,\n+                                  scheme: ty::TypeScheme<'tcx>,\n+                                  predicates: ty::GenericPredicates<'tcx>) {\n+    let ctor_ty = match variant.kind() {\n+        VariantKind::Unit | VariantKind::Dict => scheme.ty,\n+        VariantKind::Tuple => {\n+            let inputs: Vec<_> =\n+                variant.fields\n+                .iter()\n+                .map(|field| field.unsubst_ty())\n+                .collect();\n+            tcx.mk_ctor_fn(local_def(ctor_id),\n+                           &inputs[..],\n+                           scheme.ty)\n+        }\n+    };\n+    write_ty_to_tcx(tcx, ctor_id, ctor_ty);\n+    tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n+    tcx.register_item_type(local_def(ctor_id),\n+                           TypeScheme {\n+                               generics: scheme.generics,\n+                               ty: ctor_ty\n+                           });\n+}\n+\n+fn convert_struct_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                          def: &ast::StructDef,\n+                                          variant: &'tcx ty::VariantDef_<'tcx, 'tcx>,\n+                                          scheme: &ty::TypeScheme<'tcx>,\n+                                          predicates: &ty::GenericPredicates<'tcx>) {\n+    let field_tys = def.fields.iter().zip(variant.fields.iter()).map(|(f, ty_f)| {\n+        convert_field(ccx, &scheme.generics, &predicates, f, ty_f, variant.did)\n+    }).collect();\n+    ccx.tcx.struct_fields.borrow_mut().insert(variant.did, Rc::new(field_tys));\n+}\n+\n+fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                        def: &'tcx ty::ADTDef_<'tcx, 'tcx>,\n+                                        scheme: ty::TypeScheme<'tcx>,\n+                                        predicates: ty::GenericPredicates<'tcx>,\n+                                        variants: &[P<ast::Variant>]) {\n     let tcx = ccx.tcx;\n+    let icx = ccx.icx(&predicates);\n \n-    // Write the type of each of the members and check for duplicate fields.\n-    let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n-    let field_tys = struct_def.fields.iter().map(|f| {\n-        let result = convert_field(ccx, &scheme.generics, &predicates, f, local_def(id));\n+    // Create a set of parameter types shared among all the variants.\n+    for (variant, ty_variant) in variants.iter().zip(def.variants.iter()) {\n+        match variant.node.kind {\n+            ast::TupleVariantKind(ref args) => {\n+                let rs = ExplicitRscope;\n+                let input_tys: Vec<_> = args.iter().map(|va| icx.to_ty(&rs, &*va.ty)).collect();\n+                for (field, &ty) in ty_variant.fields.iter().zip(input_tys.iter()) {\n+                    field.fulfill_ty(ty);\n+                }\n+            }\n+\n+            ast::StructVariantKind(ref struct_def) => {\n+                convert_struct_variant_types(ccx, &struct_def, ty_variant, &scheme, &predicates);\n+            }\n+        };\n \n-        if result.name != special_idents::unnamed_field.name {\n-            let dup = match seen_fields.get(&result.name) {\n-                Some(prev_span) => {\n+        convert_variant_ctor(\n+            tcx,\n+            variant.node.id,\n+            ty_variant,\n+            scheme.clone(),\n+            predicates.clone()\n+        );\n+    }\n+}\n+\n+fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                did: ast::DefId,\n+                                name: ast::Name,\n+                                disr_val: ty::Disr,\n+                                def: &ast::StructDef) -> ty::VariantDef_<'tcx, 'tcx> {\n+    let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n+    let fields = def.fields.iter().map(|f| {\n+        let fid = local_def(f.node.id);\n+        match f.node.kind {\n+            ast::NamedField(ident, vis) => {\n+                let dup_span = seen_fields.get(&ident.name).cloned();\n+                if let Some(prev_span) = dup_span {\n                     span_err!(tcx.sess, f.span, E0124,\n                               \"field `{}` is already declared\",\n-                              result.name);\n-                    span_note!(tcx.sess, *prev_span, \"previously declared here\");\n-                    true\n-                },\n-                None => false,\n-            };\n-            // FIXME(#6393) this whole dup thing is just to satisfy\n-            // the borrow checker :-(\n-            if !dup {\n-                seen_fields.insert(result.name, f.span);\n+                              ident.name);\n+                    span_note!(tcx.sess, prev_span, \"previously declared here\");\n+                } else {\n+                    seen_fields.insert(ident.name, f.span);\n+                }\n+\n+                ty::FieldDef_::new(fid, ident.name, vis)\n+            },\n+            ast::UnnamedField(vis) => {\n+                ty::FieldDef_::new(fid, special_idents::unnamed_field.name, vis)\n             }\n         }\n-\n-        result\n     }).collect();\n+    ty::VariantDef_ {\n+        did: did,\n+        name: name,\n+        disr_val: disr_val,\n+        fields: fields\n+    }\n+}\n \n-    tcx.struct_fields.borrow_mut().insert(local_def(id), Rc::new(field_tys));\n+fn convert_struct_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                            it: &ast::Item,\n+                            def: &ast::StructDef)\n+                            -> &'tcx ty::ADTDef_<'tcx, 'tcx>\n+{\n \n+    let did = local_def(it.id);\n+    tcx.intern_adt_def(\n+        did,\n+        ty::ADTKind::Struct,\n+        vec![convert_struct_variant(tcx, did, it.ident.name, 0, def)]\n+    )\n+}\n \n-    // If this struct is enum-like or tuple-like, create the type of its\n-    // constructor.\n-    if let Some(ctor_id) = struct_def.ctor_id {\n-        let substs = mk_item_substs(ccx, &scheme.generics);\n-        let selfty = tcx.mk_struct(tcx.lookup_adt_def(local_def(id)),\n-                                   tcx.mk_substs(substs));\n-        if struct_def.fields.is_empty() {\n-            // Enum-like.\n-            write_ty_to_tcx(tcx, ctor_id, selfty);\n+fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                          it: &ast::Item,\n+                          def: &ast::EnumDef)\n+                          -> &'tcx ty::ADTDef_<'tcx, 'tcx>\n+{\n+    fn evaluate_disr_expr<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                repr_ty: Ty<'tcx>,\n+                                e: &ast::Expr) -> Option<ty::Disr> {\n+        debug!(\"disr expr, checking {}\", pprust::expr_to_string(e));\n+\n+        let hint = UncheckedExprHint(repr_ty);\n+        match const_eval::eval_const_expr_partial(tcx, e, hint) {\n+            Ok(ConstVal::Int(val)) => Some(val as ty::Disr),\n+            Ok(ConstVal::Uint(val)) => Some(val as ty::Disr),\n+            Ok(_) => {\n+//                let sign_desc = if repr_type.is_signed() {\n+//                    \"signed\"\n+//                } else {\n+//                    \"unsigned\"\n+//                };\n+//                span_err!(self.sess, e.span, E0079,\n+//                          \"expected {} integer constant\",\n+//                          sign_desc);\n+                None\n+            },\n+            Err(_) => {\n+//              span_err!(self.sess, err.span, E0080,\n+//                        \"constant evaluation error: {}\",\n+//                        err.description());\n+                None\n+            }\n+        }\n+    }\n \n-            tcx.register_item_type(local_def(ctor_id), scheme);\n-            tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n-        } else if struct_def.fields[0].node.kind.is_unnamed() {\n-            // Tuple-like.\n-            let inputs: Vec<_> =\n-                struct_def.fields\n-                          .iter()\n-                          .map(|field| tcx.lookup_item_type(\n-                              local_def(field.node.id)).ty)\n-                          .collect();\n-            let ctor_fn_ty = tcx.mk_ctor_fn(local_def(ctor_id),\n-                                            &inputs[..],\n-                                            selfty);\n-            write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n-            tcx.register_item_type(local_def(ctor_id),\n-                                   TypeScheme {\n-                                       generics: scheme.generics,\n-                                       ty: ctor_fn_ty\n-                                   });\n-            tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n+    fn next_disr(repr_type: attr::IntType,\n+                 prev_disr_val: Option<ty::Disr>) -> Option<ty::Disr> {\n+        if let Some(prev_disr_val) = prev_disr_val {\n+            let result = repr_type.disr_incr(prev_disr_val);\n+//          if let None = result {\n+//              self.report_discrim_overflow(v.span, &v.node.name.name.as_str(),\n+//                                           repr_type, prev_disr_val);\n+//          }\n+            result\n+        } else {\n+            Some(ty::INITIAL_DISCRIMINANT_VALUE)\n         }\n     }\n+    fn convert_enum_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                  v: &ast::Variant,\n+                                  disr: ty::Disr)\n+                                  -> ty::VariantDef_<'tcx, 'tcx>\n+    {\n+        let did = local_def(v.node.id);\n+        let name = v.node.name.name;\n+        match v.node.kind {\n+            ast::TupleVariantKind(ref va) => {\n+                ty::VariantDef_ {\n+                    did: did,\n+                    name: name,\n+                    disr_val: disr,\n+                    fields: va.iter().map(|&ast::VariantArg { id, .. }| {\n+                        ty::FieldDef_::new(\n+                            local_def(id),\n+                            special_idents::unnamed_field.name,\n+                            ast::Visibility::Public\n+                        )\n+                    }).collect()\n+                }\n+            }\n+            ast::StructVariantKind(ref def) => {\n+                convert_struct_variant(tcx, did, name, disr, &def)\n+            }\n+        }\n+    }\n+    let did = local_def(it.id);\n+    let repr_hints = tcx.lookup_repr_hints(did);\n+    let (repr_type, repr_type_ty) = tcx.enum_repr_type(repr_hints.get(0));\n+    let mut prev_disr = None;\n+    let variants = def.variants.iter().map(|v| {\n+        let disr = match v.node.disr_expr {\n+            Some(ref e) => evaluate_disr_expr(tcx, repr_type_ty, e),\n+            None => next_disr(repr_type, prev_disr)\n+        }.unwrap_or(repr_type.disr_wrap_incr(prev_disr));\n+\n+        let v = convert_enum_variant(tcx, v, disr);\n+        prev_disr = Some(disr);\n+        v\n+    }).collect();\n+    tcx.intern_adt_def(local_def(it.id), ty::ADTKind::Enum, variants)\n }\n \n /// Ensures that the super-predicates of the trait with def-id\n@@ -1469,18 +1581,17 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             let ty = ccx.icx(generics).to_ty(&ExplicitRscope, &**t);\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n-        ast::ItemEnum(_, ref generics) => {\n-            // Create a new generic polytype.\n+        ast::ItemEnum(ref ei, ref generics) => {\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let def = tcx.intern_adt_def(local_def(it.id), ty::ADTKind::Enum);\n+            let def = convert_enum_def(tcx, it, ei);\n             let t = tcx.mk_enum(def, tcx.mk_substs(substs));\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n-        ast::ItemStruct(_, ref generics) => {\n+        ast::ItemStruct(ref si, ref generics) => {\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let def = tcx.intern_adt_def(local_def(it.id), ty::ADTKind::Struct);\n+            let def = convert_struct_def(tcx, it, si);\n             let t = tcx.mk_struct(def, tcx.mk_substs(substs));\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }"}]}