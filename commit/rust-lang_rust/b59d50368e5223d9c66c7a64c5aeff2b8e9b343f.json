{"sha": "b59d50368e5223d9c66c7a64c5aeff2b8e9b343f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1OWQ1MDM2OGU1MjIzZDljNjZjN2E2NGM1YWVmZjJiOGU5YjM0M2Y=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-25T06:54:47Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-25T06:54:47Z"}, "message": "std::str: Double-ended CharSplitIterator\n\nAdd new methods `.rsplit_iter()` and `.rsplitn_iter()` for &str.\n\nSeparate out CharSplitIterator and CharSplitNIterator,\nCharSplitIterator (`split_iter` and `rsplit_iter`) is made double-ended\nwhile `splitn_iter` and `rsplitn_iter` (limited to N splits) are not,\nsince these don't have the same symmetry.\n\nWith CharSplitIterator being double ended, derived iterators like\n`line_iter` and `word_iter` are too.", "tree": {"sha": "48710b82bbf526c57191b479288b08e8d6c5aa3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48710b82bbf526c57191b479288b08e8d6c5aa3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b59d50368e5223d9c66c7a64c5aeff2b8e9b343f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b59d50368e5223d9c66c7a64c5aeff2b8e9b343f", "html_url": "https://github.com/rust-lang/rust/commit/b59d50368e5223d9c66c7a64c5aeff2b8e9b343f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b59d50368e5223d9c66c7a64c5aeff2b8e9b343f/comments", "author": null, "committer": null, "parents": [{"sha": "a17c7e4f2c0cfd800ce873b83334e8b17bef2f70", "url": "https://api.github.com/repos/rust-lang/rust/commits/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70", "html_url": "https://github.com/rust-lang/rust/commit/a17c7e4f2c0cfd800ce873b83334e8b17bef2f70"}], "stats": {"total": 296, "additions": 228, "deletions": 68}, "files": [{"sha": "d4f1c37f7a25cec6d3d43b1e3fbe824c6d42412f", "filename": "src/libstd/str.rs", "status": "modified", "additions": 228, "deletions": 68, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/b59d50368e5223d9c66c7a64c5aeff2b8e9b343f/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b59d50368e5223d9c66c7a64c5aeff2b8e9b343f/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=b59d50368e5223d9c66c7a64c5aeff2b8e9b343f", "patch": "@@ -21,9 +21,10 @@ use char;\n use char::Char;\n use clone::{Clone, DeepClone};\n use container::{Container, Mutable};\n+use either::{Left, Right};\n use iter::Times;\n use iterator::{Iterator, FromIterator, Extendable};\n-use iterator::{Filter, AdditiveIterator, Map, Enumerate};\n+use iterator::{Filter, AdditiveIterator, Map};\n use iterator::{Invert, DoubleEndedIterator};\n use libc;\n use num::{Saturating, Zero};\n@@ -359,28 +360,32 @@ pub type ByteIterator<'self> =\n /// Use with the `std::iterator` module.\n pub type ByteRevIterator<'self> = Invert<ByteIterator<'self>>;\n \n-/// An iterator over byte index and either &u8 or char\n-#[deriving(Clone)]\n-enum OffsetIterator<'self> {\n-    // use ByteIterator here when it can be cloned\n-    ByteOffset(Enumerate<vec::VecIterator<'self, u8>>),\n-    CharOffset(CharOffsetIterator<'self>),\n-}\n-\n /// An iterator over the substrings of a string, separated by `sep`.\n #[deriving(Clone)]\n-pub struct CharSplitIterator<'self,Sep> {\n-    priv iter: OffsetIterator<'self>,\n+pub struct CharSplitIterator<'self, Sep> {\n+    /// The slice remaining to be iterated\n     priv string: &'self str,\n-    priv position: uint,\n     priv sep: Sep,\n-    /// The number of splits remaining\n-    priv count: uint,\n     /// Whether an empty string at the end is allowed\n     priv allow_trailing_empty: bool,\n+    priv only_ascii: bool,\n     priv finished: bool,\n }\n \n+/// An iterator over the substrings of a string, separated by `sep`,\n+/// starting from the back of the string.\n+pub type CharRSplitIterator<'self, Sep> = Invert<CharSplitIterator<'self, Sep>>;\n+\n+/// An iterator over the substrings of a string, separated by `sep`,\n+/// splitting at most `count` times.\n+#[deriving(Clone)]\n+pub struct CharSplitNIterator<'self, Sep> {\n+    priv iter: CharSplitIterator<'self, Sep>,\n+    /// The number of splits remaining\n+    priv count: uint,\n+    priv invert: bool,\n+}\n+\n /// An iterator over the words of a string, separated by an sequence of whitespace\n pub type WordIterator<'self> =\n     Filter<'self, &'self str, CharSplitIterator<'self, extern \"Rust\" fn(char) -> bool>>;\n@@ -389,46 +394,111 @@ pub type WordIterator<'self> =\n pub type AnyLineIterator<'self> =\n     Map<'self, &'self str, &'self str, CharSplitIterator<'self, char>>;\n \n+impl<'self, Sep> CharSplitIterator<'self, Sep> {\n+    #[inline]\n+    fn get_end(&mut self) -> Option<&'self str> {\n+        if !self.finished && (self.allow_trailing_empty || self.string.len() > 0) {\n+            self.finished = true;\n+            Some(self.string)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<'self, Sep: CharEq> Iterator<&'self str> for CharSplitIterator<'self, Sep> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self str> {\n         if self.finished { return None }\n \n-        let start = self.position;\n         let len = self.string.len();\n+        let mut iter = match self.only_ascii {\n+            true => Left(self.string.byte_iter().enumerate()),\n+            false => Right(self.string.char_offset_iter())\n+        };\n \n-        if self.count > 0 {\n-            match self.iter {\n+        loop {\n+            let (idx, next) = match iter {\n                 // this gives a *huge* speed up for splitting on ASCII\n                 // characters (e.g. '\\n' or ' ')\n-                ByteOffset(ref mut iter) =>\n-                    for (idx, &byte) in *iter {\n-                        if self.sep.matches(byte as char) {\n-                            self.position = idx + 1;\n-                            self.count -= 1;\n-                            return Some(unsafe {\n-                                raw::slice_bytes(self.string, start, idx)\n-                            })\n-                        }\n-                    },\n-                CharOffset(ref mut iter) =>\n-                    for (idx, ch) in *iter {\n-                        if self.sep.matches(ch) {\n-                            // skip over the separator\n-                            self.position = self.string.char_range_at(idx).next;\n-                            self.count -= 1;\n-                            return Some(unsafe {\n-                                raw::slice_bytes(self.string, start, idx)\n-                            })\n-                        }\n+                Left(ref mut it) => match it.next() {\n+                    Some((idx, byte)) if byte < 128u8 && self.sep.matches(byte as char) =>\n+                        (idx, idx + 1),\n+                    Some(*) => loop,\n+                    None => break,\n+                },\n+                Right(ref mut it) => match it.next() {\n+                    Some((idx, ch)) if self.sep.matches(ch) =>\n+                        (idx, self.string.char_range_at(idx).next),\n+                    Some(*) => loop,\n+                    None => break,\n+                }\n+            };\n+            unsafe {\n+                let elt = raw::slice_bytes(self.string, 0, idx);\n+                self.string = raw::slice_bytes(self.string, next, len);\n+                return Some(elt)\n+            }\n+        }\n+        self.get_end()\n+    }\n+}\n+\n+impl<'self, Sep: CharEq> DoubleEndedIterator<&'self str>\n+for CharSplitIterator<'self, Sep> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'self str> {\n+        if self.finished { return None }\n+\n+        if !self.allow_trailing_empty {\n+            self.allow_trailing_empty = true;\n+            match self.next_back() {\n+                Some(elt) if !elt.is_empty() => return Some(elt),\n+                _ => if self.finished { return None }\n+            }\n+        }\n+        let len = self.string.len();\n+        let mut iter = match self.only_ascii {\n+            true => Left(self.string.byte_rev_iter().enumerate()),\n+            false => Right(self.string.char_offset_iter())\n+        };\n+\n+        loop {\n+            let (idx, next) = match iter {\n+                Left(ref mut it) => match it.next() {\n+                    Some((j, byte)) if byte < 128u8 && self.sep.matches(byte as char) => {\n+                        let idx = self.string.len() - j - 1;\n+                        (idx, idx + 1)\n                     },\n+                    Some(*) => loop,\n+                    None => break,\n+                },\n+                Right(ref mut it) => match it.next_back() {\n+                    Some((idx, ch)) if self.sep.matches(ch) =>\n+                        (idx, self.string.char_range_at(idx).next),\n+                    Some(*) => loop,\n+                    None => break,\n+                }\n+            };\n+            unsafe {\n+                let elt = raw::slice_bytes(self.string, next, len);\n+                self.string = raw::slice_bytes(self.string, 0, idx);\n+                return Some(elt)\n             }\n         }\n         self.finished = true;\n-        if self.allow_trailing_empty || start < len {\n-            Some(unsafe { raw::slice_bytes(self.string, start, len) })\n+        Some(self.string)\n+    }\n+}\n+\n+impl<'self, Sep: CharEq> Iterator<&'self str> for CharSplitNIterator<'self, Sep> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self str> {\n+        if self.count != 0 {\n+            self.count -= 1;\n+            if self.invert { self.iter.next_back() } else { self.iter.next() }\n         } else {\n-            None\n+            self.iter.get_end()\n         }\n     }\n }\n@@ -1271,9 +1341,10 @@ pub trait StrSlice<'self> {\n     fn char_offset_iter(&self) -> CharOffsetIterator<'self>;\n     fn char_offset_rev_iter(&self) -> CharOffsetRevIterator<'self>;\n     fn split_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n-    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitIterator<'self, Sep>;\n-    fn split_options_iter<Sep: CharEq>(&self, sep: Sep, count: uint, allow_trailing_empty: bool)\n-        -> CharSplitIterator<'self, Sep>;\n+    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'self, Sep>;\n+    fn split_terminator_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n+    fn rsplit_iter<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'self, Sep>;\n+    fn rsplitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'self, Sep>;\n     fn matches_index_iter(&self, sep: &'self str) -> MatchesIndexIterator<'self>;\n     fn split_str_iter(&self, &'self str) -> StrSplitIterator<'self>;\n     fn line_iter(&self) -> CharSplitIterator<'self, char>;\n@@ -1410,40 +1481,78 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// ~~~\n     #[inline]\n     fn split_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep> {\n-        self.split_options_iter(sep, self.len(), true)\n+        CharSplitIterator {\n+            string: *self,\n+            only_ascii: sep.only_ascii(),\n+            sep: sep,\n+            allow_trailing_empty: true,\n+            finished: false,\n+        }\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, restricted to splitting at most `count`\n     /// times.\n     #[inline]\n-    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitIterator<'self, Sep> {\n-        self.split_options_iter(sep, count, true)\n+    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint)\n+        -> CharSplitNIterator<'self, Sep> {\n+        CharSplitNIterator {\n+            iter: self.split_iter(sep),\n+            count: count,\n+            invert: false,\n+        }\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`, splitting at most `count` times, and\n-    /// possibly not including the trailing empty substring, if it\n-    /// exists.\n+    /// matched by `sep`.\n+    ///\n+    /// Equivalent to `split_iter`, except that the trailing substring\n+    /// is skipped if empty (terminator semantics).\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let v: ~[&str] = \"A.B.\".split_terminator_iter('.').collect();\n+    /// assert_eq!(v, ~[\"A\", \"B\"]);\n+    /// ~~~\n     #[inline]\n-    fn split_options_iter<Sep: CharEq>(&self, sep: Sep, count: uint, allow_trailing_empty: bool)\n+    fn split_terminator_iter<Sep: CharEq>(&self, sep: Sep)\n         -> CharSplitIterator<'self, Sep> {\n-        let iter = if sep.only_ascii() {\n-            ByteOffset(self.as_bytes().iter().enumerate())\n-        } else {\n-            CharOffset(self.char_offset_iter())\n-        };\n         CharSplitIterator {\n-            iter: iter,\n-            string: *self,\n-            position: 0,\n-            sep: sep,\n+            allow_trailing_empty: false,\n+            ..self.split_iter(sep)\n+        }\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`, in reverse order\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let v: ~[&str] = \"Mary had a little lamb\".rsplit_iter(' ').collect();\n+    /// assert_eq!(v, ~[\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    /// ~~~\n+    #[inline]\n+    fn rsplit_iter<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'self, Sep> {\n+        self.split_iter(sep).invert()\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`, starting from the end of the string.\n+    /// Restricted to splitting at most `count` times.\n+    #[inline]\n+    fn rsplitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint)\n+        -> CharSplitNIterator<'self, Sep> {\n+        CharSplitNIterator {\n+            iter: self.split_iter(sep),\n             count: count,\n-            allow_trailing_empty: allow_trailing_empty,\n-            finished: false,\n+            invert: true,\n         }\n     }\n \n+\n+\n     /// An iterator over the start and end indices of each match of\n     /// `sep` within `self`.\n     #[inline]\n@@ -1477,7 +1586,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// by `\\n`).\n     #[inline]\n     fn line_iter(&self) -> CharSplitIterator<'self, char> {\n-        self.split_options_iter('\\n', self.len(), false)\n+        self.split_terminator_iter('\\n')\n     }\n \n     /// An iterator over the lines of a string, separated by either\n@@ -3371,17 +3480,33 @@ mod tests {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n         let split: ~[&str] = data.split_iter(' ').collect();\n-        assert_eq!(split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!( split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+        let mut rsplit: ~[&str] = data.rsplit_iter(' ').collect();\n+        rsplit.reverse();\n+        assert_eq!(rsplit, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         let split: ~[&str] = data.split_iter(|c: char| c == ' ').collect();\n-        assert_eq!(split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!( split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+        let mut rsplit: ~[&str] = data.rsplit_iter(|c: char| c == ' ').collect();\n+        rsplit.reverse();\n+        assert_eq!(rsplit, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         // Unicode\n         let split: ~[&str] = data.split_iter('\u00e4').collect();\n-        assert_eq!(split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!( split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+        let mut rsplit: ~[&str] = data.rsplit_iter('\u00e4').collect();\n+        rsplit.reverse();\n+        assert_eq!(rsplit, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n         let split: ~[&str] = data.split_iter(|c: char| c == '\u00e4').collect();\n-        assert_eq!(split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!( split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+        let mut rsplit: ~[&str] = data.rsplit_iter(|c: char| c == '\u00e4').collect();\n+        rsplit.reverse();\n+        assert_eq!(rsplit, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n     }\n \n     #[test]\n@@ -3402,14 +3527,49 @@ mod tests {\n         assert_eq!(split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n     }\n \n+    #[test]\n+    fn test_rsplitn_char_iterator() {\n+        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+        let mut split: ~[&str] = data.rsplitn_iter(' ', 3).collect();\n+        split.reverse();\n+        assert_eq!(split, ~[\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+        let mut split: ~[&str] = data.rsplitn_iter(|c: char| c == ' ', 3).collect();\n+        split.reverse();\n+        assert_eq!(split, ~[\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+        // Unicode\n+        let mut split: ~[&str] = data.rsplitn_iter('\u00e4', 3).collect();\n+        split.reverse();\n+        assert_eq!(split, ~[\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+        let mut split: ~[&str] = data.rsplitn_iter(|c: char| c == '\u00e4', 3).collect();\n+        split.reverse();\n+        assert_eq!(split, ~[\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    }\n+\n     #[test]\n     fn test_split_char_iterator_no_trailing() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let split: ~[&str] = data.split_options_iter('\\n', 1000, true).collect();\n+        let split: ~[&str] = data.split_iter('\\n').collect();\n+        assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+\n+        let split: ~[&str] = data.split_terminator_iter('\\n').collect();\n+        assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+    }\n+\n+    #[test]\n+    fn test_rev_split_char_iterator_no_trailing() {\n+        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+        let mut split: ~[&str] = data.split_iter('\\n').invert().collect();\n+        split.reverse();\n         assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n \n-        let split: ~[&str] = data.split_options_iter('\\n', 1000, false).collect();\n+        let mut split: ~[&str] = data.split_terminator_iter('\\n').invert().collect();\n+        split.reverse();\n         assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n     }\n "}]}