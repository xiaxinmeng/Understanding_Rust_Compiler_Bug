{"sha": "e129b92c40678f65490ce58fa06079d38ae07eba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMjliOTJjNDA2NzhmNjU0OTBjZTU4ZmEwNjA3OWQzOGFlMDdlYmE=", "commit": {"author": {"name": "Steven Allen", "email": "steven@stebalien.com", "date": "2015-04-24T16:55:19Z"}, "committer": {"name": "Steven Allen", "email": "steven@stebalien.com", "date": "2015-04-24T16:55:19Z"}, "message": "Deduplicate slice iter offset/transmute code.", "tree": {"sha": "1b5ddb400aa428ebc36c75a2a29325334e942a50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b5ddb400aa428ebc36c75a2a29325334e942a50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e129b92c40678f65490ce58fa06079d38ae07eba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e129b92c40678f65490ce58fa06079d38ae07eba", "html_url": "https://github.com/rust-lang/rust/commit/e129b92c40678f65490ce58fa06079d38ae07eba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e129b92c40678f65490ce58fa06079d38ae07eba/comments", "author": {"login": "Stebalien", "id": 310393, "node_id": "MDQ6VXNlcjMxMDM5Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/310393?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Stebalien", "html_url": "https://github.com/Stebalien", "followers_url": "https://api.github.com/users/Stebalien/followers", "following_url": "https://api.github.com/users/Stebalien/following{/other_user}", "gists_url": "https://api.github.com/users/Stebalien/gists{/gist_id}", "starred_url": "https://api.github.com/users/Stebalien/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Stebalien/subscriptions", "organizations_url": "https://api.github.com/users/Stebalien/orgs", "repos_url": "https://api.github.com/users/Stebalien/repos", "events_url": "https://api.github.com/users/Stebalien/events{/privacy}", "received_events_url": "https://api.github.com/users/Stebalien/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Stebalien", "id": 310393, "node_id": "MDQ6VXNlcjMxMDM5Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/310393?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Stebalien", "html_url": "https://github.com/Stebalien", "followers_url": "https://api.github.com/users/Stebalien/followers", "following_url": "https://api.github.com/users/Stebalien/following{/other_user}", "gists_url": "https://api.github.com/users/Stebalien/gists{/gist_id}", "starred_url": "https://api.github.com/users/Stebalien/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Stebalien/subscriptions", "organizations_url": "https://api.github.com/users/Stebalien/orgs", "repos_url": "https://api.github.com/users/Stebalien/repos", "events_url": "https://api.github.com/users/Stebalien/events{/privacy}", "received_events_url": "https://api.github.com/users/Stebalien/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50c6c6ca9038223226a36d9ceb15b6f37254959c", "url": "https://api.github.com/repos/rust-lang/rust/commits/50c6c6ca9038223226a36d9ceb15b6f37254959c", "html_url": "https://github.com/rust-lang/rust/commit/50c6c6ca9038223226a36d9ceb15b6f37254959c"}], "stats": {"total": 86, "additions": 41, "deletions": 45}, "files": [{"sha": "38e66c5a3d6a2460e4e474a41f7e0c78a0ffb287", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 41, "deletions": 45, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e129b92c40678f65490ce58fa06079d38ae07eba/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e129b92c40678f65490ce58fa06079d38ae07eba/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=e129b92c40678f65490ce58fa06079d38ae07eba", "patch": "@@ -625,6 +625,36 @@ impl<'a, T> IntoIterator for &'a mut [T] {\n     }\n }\n \n+#[inline(always)]\n+fn size_from_ptr<T>(_: *const T) -> usize {\n+    mem::size_of::<T>()\n+}\n+\n+\n+// Use macro to be generic over const/mut\n+macro_rules! slice_offset {\n+    ($ptr:expr, $by:expr) => {{\n+        let ptr = $ptr;\n+        if size_from_ptr(ptr) == 0 {\n+            transmute(ptr as usize + $by)\n+        } else {\n+            ptr.offset($by)\n+        }\n+    }};\n+}\n+\n+macro_rules! slice_ref {\n+    ($ptr:expr) => {{\n+        let ptr = $ptr;\n+        if size_from_ptr(ptr) == 0 {\n+            // Use a non-null pointer value\n+            &mut *(1 as *mut _)\n+        } else {\n+            transmute(ptr)\n+        }\n+    }};\n+}\n+\n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n@@ -641,20 +671,9 @@ macro_rules! iterator {\n                     if self.ptr == self.end {\n                         None\n                     } else {\n-                        if mem::size_of::<T>() == 0 {\n-                            // purposefully don't use 'ptr.offset' because for\n-                            // vectors with 0-size elements this would return the\n-                            // same pointer.\n-                            self.ptr = transmute(self.ptr as usize + 1);\n-\n-                            // Use a non-null pointer value\n-                            Some(&mut *(1 as *mut _))\n-                        } else {\n-                            let old = self.ptr;\n-                            self.ptr = self.ptr.offset(1);\n-\n-                            Some(transmute(old))\n-                        }\n+                        let old = self.ptr;\n+                        self.ptr = slice_offset!(self.ptr, 1);\n+                        Some(slice_ref!(old))\n                     }\n                 }\n             }\n@@ -695,17 +714,8 @@ macro_rules! iterator {\n                     if self.end == self.ptr {\n                         None\n                     } else {\n-                        if mem::size_of::<T>() == 0 {\n-                            // See above for why 'ptr.offset' isn't used\n-                            self.end = transmute(self.end as usize - 1);\n-\n-                            // Use a non-null pointer value\n-                            Some(&mut *(1 as *mut _))\n-                        } else {\n-                            self.end = self.end.offset(-1);\n-\n-                            Some(transmute(self.end))\n-                        }\n+                        self.end = slice_offset!(self.end, -1);\n+                        Some(slice_ref!(self.end))\n                     }\n                 }\n             }\n@@ -805,16 +815,9 @@ impl<'a, T> Iter<'a, T> {\n     // Helper function for Iter::nth\n     fn iter_nth(&mut self, n: usize) -> Option<&'a T> {\n         match self.as_slice().get(n) {\n-            Some(elem_ref) => if mem::size_of::<T>() == 0 {\n-                unsafe {\n-                    self.ptr = transmute((elem_ref as *const _) as usize + 1);\n-                    Some(& *(1 as *const _))\n-                }\n-            } else {\n-                unsafe {\n-                    self.ptr = (elem_ref as *const _).offset(1);\n-                    Some(elem_ref)\n-                }\n+            Some(elem_ref) => unsafe {\n+                self.ptr = slice_offset!(elem_ref as *const _, 1);\n+                Some(slice_ref!(elem_ref))\n             },\n             None => {\n                 self.ptr = self.end;\n@@ -955,16 +958,9 @@ impl<'a, T> IterMut<'a, T> {\n     // Helper function for IterMut::nth\n     fn iter_nth(&mut self, n: usize) -> Option<&'a mut T> {\n         match make_mut_slice!(T => &'a mut [T]: self.ptr, self.end).get_mut(n) {\n-            Some(elem_ref) => if mem::size_of::<T>() == 0 {\n-                unsafe {\n-                    self.ptr = transmute((elem_ref as *mut _) as usize + 1);\n-                    Some(&mut *(1 as *mut _))\n-                }\n-            } else {\n-                unsafe {\n-                    self.ptr = (elem_ref as *mut _).offset(1);\n-                    Some(elem_ref)\n-                }\n+            Some(elem_ref) => unsafe {\n+                self.ptr = slice_offset!(elem_ref as *mut _, 1);\n+                Some(slice_ref!(elem_ref))\n             },\n             None => {\n                 self.ptr = self.end;"}]}