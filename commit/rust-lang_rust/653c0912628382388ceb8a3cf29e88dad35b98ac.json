{"sha": "653c0912628382388ceb8a3cf29e88dad35b98ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1M2MwOTEyNjI4MzgyMzg4Y2ViOGEzY2YyOWU4OGRhZDM1Yjk4YWM=", "commit": {"author": {"name": "Dan Gohman", "email": "sunfish@mozilla.com", "date": "2020-07-03T23:20:37Z"}, "committer": {"name": "Dan Gohman", "email": "sunfish@mozilla.com", "date": "2020-07-07T23:04:52Z"}, "message": "Add `read_exact_at` and `write_all_at` to WASI's `FileExt`\n\nThis adds `read_exact_at` and `write_all_at` to WASI's `FileExt`,\nsimilar to the Unix versions of the same names.", "tree": {"sha": "79a99afda4f8c4facb01264ac884535161c9e42b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79a99afda4f8c4facb01264ac884535161c9e42b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/653c0912628382388ceb8a3cf29e88dad35b98ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/653c0912628382388ceb8a3cf29e88dad35b98ac", "html_url": "https://github.com/rust-lang/rust/commit/653c0912628382388ceb8a3cf29e88dad35b98ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/653c0912628382388ceb8a3cf29e88dad35b98ac/comments", "author": {"login": "sunfishcode", "id": 4503403, "node_id": "MDQ6VXNlcjQ1MDM0MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/4503403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunfishcode", "html_url": "https://github.com/sunfishcode", "followers_url": "https://api.github.com/users/sunfishcode/followers", "following_url": "https://api.github.com/users/sunfishcode/following{/other_user}", "gists_url": "https://api.github.com/users/sunfishcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunfishcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunfishcode/subscriptions", "organizations_url": "https://api.github.com/users/sunfishcode/orgs", "repos_url": "https://api.github.com/users/sunfishcode/repos", "events_url": "https://api.github.com/users/sunfishcode/events{/privacy}", "received_events_url": "https://api.github.com/users/sunfishcode/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sunfishcode", "id": 4503403, "node_id": "MDQ6VXNlcjQ1MDM0MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/4503403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunfishcode", "html_url": "https://github.com/sunfishcode", "followers_url": "https://api.github.com/users/sunfishcode/followers", "following_url": "https://api.github.com/users/sunfishcode/following{/other_user}", "gists_url": "https://api.github.com/users/sunfishcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunfishcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunfishcode/subscriptions", "organizations_url": "https://api.github.com/users/sunfishcode/orgs", "repos_url": "https://api.github.com/users/sunfishcode/repos", "events_url": "https://api.github.com/users/sunfishcode/events{/privacy}", "received_events_url": "https://api.github.com/users/sunfishcode/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1beee4992ad4b235fc700bf7af1ee86f894ea53", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1beee4992ad4b235fc700bf7af1ee86f894ea53", "html_url": "https://github.com/rust-lang/rust/commit/e1beee4992ad4b235fc700bf7af1ee86f894ea53"}], "stats": {"total": 94, "additions": 94, "deletions": 0}, "files": [{"sha": "10ea4fd34bda3c13519d3931c17c99f521e20ec0", "filename": "src/libstd/sys/wasi/ext/fs.rs", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/653c0912628382388ceb8a3cf29e88dad35b98ac/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653c0912628382388ceb8a3cf29e88dad35b98ac/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs?ref=653c0912628382388ceb8a3cf29e88dad35b98ac", "patch": "@@ -27,6 +27,58 @@ pub trait FileExt {\n     /// [`File::read`]: ../../../../std/fs/struct.File.html#method.read_vectored\n     fn read_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize>;\n \n+    /// Reads the exact number of byte required to fill `buf` from the given offset.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// Similar to [`Read::read_exact`] but uses [`read_at`] instead of `read`.\n+    ///\n+    /// [`Read::read_exact`]: ../../../../std/io/trait.Read.html#method.read_exact\n+    /// [`read_at`]: #tymethod.read_at\n+    ///\n+    /// # Errors\n+    ///\n+    /// If this function encounters an error of the kind\n+    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n+    /// will continue.\n+    ///\n+    /// If this function encounters an \"end of file\" before completely filling\n+    /// the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n+    /// The contents of `buf` are unspecified in this case.\n+    ///\n+    /// If any other read error is encountered then this function immediately\n+    /// returns. The contents of `buf` are unspecified in this case.\n+    ///\n+    /// If this function returns an error, it is unspecified how many bytes it\n+    /// has read, but it will never read more than would be necessary to\n+    /// completely fill the buffer.\n+    ///\n+    /// [`ErrorKind::Interrupted`]: ../../../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`ErrorKind::UnexpectedEof`]: ../../../../std/io/enum.ErrorKind.html#variant.UnexpectedEof\n+    #[stable(feature = \"rw_exact_all_at\", since = \"1.33.0\")]\n+    fn read_exact_at(&self, mut buf: &mut [u8], mut offset: u64) -> io::Result<()> {\n+        while !buf.is_empty() {\n+            match self.read_at(buf, offset) {\n+                Ok(0) => break,\n+                Ok(n) => {\n+                    let tmp = buf;\n+                    buf = &mut tmp[n..];\n+                    offset += n as u64;\n+                }\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        if !buf.is_empty() {\n+            Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     /// Writes a number of bytes starting from a given offset.\n     ///\n     /// Returns the number of bytes written.\n@@ -45,6 +97,48 @@ pub trait FileExt {\n     /// [`File::write`]: ../../../../std/fs/struct.File.html#method.write_vectored\n     fn write_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize>;\n \n+    /// Attempts to write an entire buffer starting from a given offset.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// This method will continuously call [`write_at`] until there is no more data\n+    /// to be written or an error of non-[`ErrorKind::Interrupted`] kind is\n+    /// returned. This method will not return until the entire buffer has been\n+    /// successfully written or such an error occurs. The first error that is\n+    /// not of [`ErrorKind::Interrupted`] kind generated from this method will be\n+    /// returned.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return the first error of\n+    /// non-[`ErrorKind::Interrupted`] kind that [`write_at`] returns.\n+    ///\n+    /// [`ErrorKind::Interrupted`]: ../../../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`write_at`]: #tymethod.write_at\n+    #[stable(feature = \"rw_exact_all_at\", since = \"1.33.0\")]\n+    fn write_all_at(&self, mut buf: &[u8], mut offset: u64) -> io::Result<()> {\n+        while !buf.is_empty() {\n+            match self.write_at(buf, offset) {\n+                Ok(0) => {\n+                    return Err(io::Error::new(\n+                        io::ErrorKind::WriteZero,\n+                        \"failed to write whole buffer\",\n+                    ));\n+                }\n+                Ok(n) => {\n+                    buf = &buf[n..];\n+                    offset += n as u64\n+                }\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     /// Returns the current position within the file.\n     ///\n     /// This corresponds to the `fd_tell` syscall and is similar to"}]}