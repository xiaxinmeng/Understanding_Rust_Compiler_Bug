{"sha": "fbad684e2ff11f58dc94d9c19bf31c5787afd98e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYWQ2ODRlMmZmMTFmNThkYzk0ZDljMTliZjMxYzU3ODdhZmQ5OGU=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-04T02:26:45Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-14T09:35:54Z"}, "message": "move indexing impl to new mod", "tree": {"sha": "7aa3b6ce88a6dfae3dc8effed0359ef0a19d4fd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7aa3b6ce88a6dfae3dc8effed0359ef0a19d4fd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbad684e2ff11f58dc94d9c19bf31c5787afd98e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbad684e2ff11f58dc94d9c19bf31c5787afd98e", "html_url": "https://github.com/rust-lang/rust/commit/fbad684e2ff11f58dc94d9c19bf31c5787afd98e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbad684e2ff11f58dc94d9c19bf31c5787afd98e/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcd18f977bee4db79d42d54cc7edce19c942b963", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcd18f977bee4db79d42d54cc7edce19c942b963", "html_url": "https://github.com/rust-lang/rust/commit/bcd18f977bee4db79d42d54cc7edce19c942b963"}], "stats": {"total": 1490, "additions": 753, "deletions": 737}, "files": [{"sha": "27a358bddaf4f03e0bb2fd35a32f050f5944cdd9", "filename": "library/core/src/slice/cmp.rs", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/fbad684e2ff11f58dc94d9c19bf31c5787afd98e/library%2Fcore%2Fsrc%2Fslice%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbad684e2ff11f58dc94d9c19bf31c5787afd98e/library%2Fcore%2Fsrc%2Fslice%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fcmp.rs?ref=fbad684e2ff11f58dc94d9c19bf31c5787afd98e", "patch": "@@ -0,0 +1,286 @@\n+//! Comparison traits for `[T]`.\n+\n+use crate::cmp;\n+use crate::cmp::Ordering::{self, Greater, Less};\n+use crate::mem;\n+\n+use super::from_raw_parts;\n+use super::memchr;\n+\n+extern \"C\" {\n+    /// Calls implementation provided memcmp.\n+    ///\n+    /// Interprets the data as u8.\n+    ///\n+    /// Returns 0 for equal, < 0 for less than and > 0 for greater\n+    /// than.\n+    // FIXME(#32610): Return type should be c_int\n+    fn memcmp(s1: *const u8, s2: *const u8, n: usize) -> i32;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> PartialEq<[B]> for [A]\n+where\n+    A: PartialEq<B>,\n+{\n+    fn eq(&self, other: &[B]) -> bool {\n+        SlicePartialEq::equal(self, other)\n+    }\n+\n+    fn ne(&self, other: &[B]) -> bool {\n+        SlicePartialEq::not_equal(self, other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Eq> Eq for [T] {}\n+\n+/// Implements comparison of vectors lexicographically.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Ord> Ord for [T] {\n+    fn cmp(&self, other: &[T]) -> Ordering {\n+        SliceOrd::compare(self, other)\n+    }\n+}\n+\n+/// Implements comparison of vectors lexicographically.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: PartialOrd> PartialOrd for [T] {\n+    fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n+        SlicePartialOrd::partial_compare(self, other)\n+    }\n+}\n+\n+#[doc(hidden)]\n+// intermediate trait for specialization of slice's PartialEq\n+trait SlicePartialEq<B> {\n+    fn equal(&self, other: &[B]) -> bool;\n+\n+    fn not_equal(&self, other: &[B]) -> bool {\n+        !self.equal(other)\n+    }\n+}\n+\n+// Generic slice equality\n+impl<A, B> SlicePartialEq<B> for [A]\n+where\n+    A: PartialEq<B>,\n+{\n+    default fn equal(&self, other: &[B]) -> bool {\n+        if self.len() != other.len() {\n+            return false;\n+        }\n+\n+        self.iter().zip(other.iter()).all(|(x, y)| x == y)\n+    }\n+}\n+\n+// Use an equal-pointer optimization when types are `Eq`\n+// We can't make `A` and `B` the same type because `min_specialization` won't\n+// allow it.\n+impl<A, B> SlicePartialEq<B> for [A]\n+where\n+    A: MarkerEq<B>,\n+{\n+    default fn equal(&self, other: &[B]) -> bool {\n+        if self.len() != other.len() {\n+            return false;\n+        }\n+\n+        // While performance would suffer if `guaranteed_eq` just returned `false`\n+        // for all arguments, correctness and return value of this function are not affected.\n+        if self.as_ptr().guaranteed_eq(other.as_ptr() as *const A) {\n+            return true;\n+        }\n+\n+        self.iter().zip(other.iter()).all(|(x, y)| x == y)\n+    }\n+}\n+\n+// Use memcmp for bytewise equality when the types allow\n+impl<A, B> SlicePartialEq<B> for [A]\n+where\n+    A: BytewiseEquality<B>,\n+{\n+    fn equal(&self, other: &[B]) -> bool {\n+        if self.len() != other.len() {\n+            return false;\n+        }\n+\n+        // While performance would suffer if `guaranteed_eq` just returned `false`\n+        // for all arguments, correctness and return value of this function are not affected.\n+        if self.as_ptr().guaranteed_eq(other.as_ptr() as *const A) {\n+            return true;\n+        }\n+        // SAFETY: `self` and `other` are references and are thus guaranteed to be valid.\n+        // The two slices have been checked to have the same size above.\n+        unsafe {\n+            let size = mem::size_of_val(self);\n+            memcmp(self.as_ptr() as *const u8, other.as_ptr() as *const u8, size) == 0\n+        }\n+    }\n+}\n+\n+#[doc(hidden)]\n+// intermediate trait for specialization of slice's PartialOrd\n+trait SlicePartialOrd: Sized {\n+    fn partial_compare(left: &[Self], right: &[Self]) -> Option<Ordering>;\n+}\n+\n+impl<A: PartialOrd> SlicePartialOrd for A {\n+    default fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n+        let l = cmp::min(left.len(), right.len());\n+\n+        // Slice to the loop iteration range to enable bound check\n+        // elimination in the compiler\n+        let lhs = &left[..l];\n+        let rhs = &right[..l];\n+\n+        for i in 0..l {\n+            match lhs[i].partial_cmp(&rhs[i]) {\n+                Some(Ordering::Equal) => (),\n+                non_eq => return non_eq,\n+            }\n+        }\n+\n+        left.len().partial_cmp(&right.len())\n+    }\n+}\n+\n+// This is the impl that we would like to have. Unfortunately it's not sound.\n+// See `partial_ord_slice.rs`.\n+/*\n+impl<A> SlicePartialOrd for A\n+where\n+    A: Ord,\n+{\n+    default fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n+        Some(SliceOrd::compare(left, right))\n+    }\n+}\n+*/\n+\n+impl<A: AlwaysApplicableOrd> SlicePartialOrd for A {\n+    fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n+        Some(SliceOrd::compare(left, right))\n+    }\n+}\n+\n+#[rustc_specialization_trait]\n+trait AlwaysApplicableOrd: SliceOrd + Ord {}\n+\n+macro_rules! always_applicable_ord {\n+    ($([$($p:tt)*] $t:ty,)*) => {\n+        $(impl<$($p)*> AlwaysApplicableOrd for $t {})*\n+    }\n+}\n+\n+always_applicable_ord! {\n+    [] u8, [] u16, [] u32, [] u64, [] u128, [] usize,\n+    [] i8, [] i16, [] i32, [] i64, [] i128, [] isize,\n+    [] bool, [] char,\n+    [T: ?Sized] *const T, [T: ?Sized] *mut T,\n+    [T: AlwaysApplicableOrd] &T,\n+    [T: AlwaysApplicableOrd] &mut T,\n+    [T: AlwaysApplicableOrd] Option<T>,\n+}\n+\n+#[doc(hidden)]\n+// intermediate trait for specialization of slice's Ord\n+trait SliceOrd: Sized {\n+    fn compare(left: &[Self], right: &[Self]) -> Ordering;\n+}\n+\n+impl<A: Ord> SliceOrd for A {\n+    default fn compare(left: &[Self], right: &[Self]) -> Ordering {\n+        let l = cmp::min(left.len(), right.len());\n+\n+        // Slice to the loop iteration range to enable bound check\n+        // elimination in the compiler\n+        let lhs = &left[..l];\n+        let rhs = &right[..l];\n+\n+        for i in 0..l {\n+            match lhs[i].cmp(&rhs[i]) {\n+                Ordering::Equal => (),\n+                non_eq => return non_eq,\n+            }\n+        }\n+\n+        left.len().cmp(&right.len())\n+    }\n+}\n+\n+// memcmp compares a sequence of unsigned bytes lexicographically.\n+// this matches the order we want for [u8], but no others (not even [i8]).\n+impl SliceOrd for u8 {\n+    #[inline]\n+    fn compare(left: &[Self], right: &[Self]) -> Ordering {\n+        let order =\n+            // SAFETY: `left` and `right` are references and are thus guaranteed to be valid.\n+            // We use the minimum of both lengths which guarantees that both regions are\n+            // valid for reads in that interval.\n+            unsafe { memcmp(left.as_ptr(), right.as_ptr(), cmp::min(left.len(), right.len())) };\n+        if order == 0 {\n+            left.len().cmp(&right.len())\n+        } else if order < 0 {\n+            Less\n+        } else {\n+            Greater\n+        }\n+    }\n+}\n+\n+// Hack to allow specializing on `Eq` even though `Eq` has a method.\n+#[rustc_unsafe_specialization_marker]\n+trait MarkerEq<T>: PartialEq<T> {}\n+\n+impl<T: Eq> MarkerEq<T> for T {}\n+\n+#[doc(hidden)]\n+/// Trait implemented for types that can be compared for equality using\n+/// their bytewise representation\n+#[rustc_specialization_trait]\n+trait BytewiseEquality<T>: MarkerEq<T> + Copy {}\n+\n+macro_rules! impl_marker_for {\n+    ($traitname:ident, $($ty:ty)*) => {\n+        $(\n+            impl $traitname<$ty> for $ty { }\n+        )*\n+    }\n+}\n+\n+impl_marker_for!(BytewiseEquality,\n+                 u8 i8 u16 i16 u32 i32 u64 i64 u128 i128 usize isize char bool);\n+\n+pub(super) trait SliceContains: Sized {\n+    fn slice_contains(&self, x: &[Self]) -> bool;\n+}\n+\n+impl<T> SliceContains for T\n+where\n+    T: PartialEq,\n+{\n+    default fn slice_contains(&self, x: &[Self]) -> bool {\n+        x.iter().any(|y| *y == *self)\n+    }\n+}\n+\n+impl SliceContains for u8 {\n+    fn slice_contains(&self, x: &[Self]) -> bool {\n+        memchr::memchr(*self, x).is_some()\n+    }\n+}\n+\n+impl SliceContains for i8 {\n+    fn slice_contains(&self, x: &[Self]) -> bool {\n+        let byte = *self as u8;\n+        // SAFETY: `i8` and `u8` have the same memory layout, thus casting `x.as_ptr()`\n+        // as `*const u8` is safe. The `x.as_ptr()` comes from a reference and is thus guaranteed\n+        // to be valid for reads for the length of the slice `x.len()`, which cannot be larger\n+        // than `isize::MAX`. The returned slice is never mutated.\n+        let bytes: &[u8] = unsafe { from_raw_parts(x.as_ptr() as *const u8, x.len()) };\n+        memchr::memchr(byte, bytes).is_some()\n+    }\n+}"}, {"sha": "d67e0ae536d9f9bc52f0c1482a88b3f7d566d4f8", "filename": "library/core/src/slice/index.rs", "status": "added", "additions": 455, "deletions": 0, "changes": 455, "blob_url": "https://github.com/rust-lang/rust/blob/fbad684e2ff11f58dc94d9c19bf31c5787afd98e/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbad684e2ff11f58dc94d9c19bf31c5787afd98e/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=fbad684e2ff11f58dc94d9c19bf31c5787afd98e", "patch": "@@ -0,0 +1,455 @@\n+//! Indexing implementations for `[T]`.\n+\n+use crate::ops;\n+use crate::ptr;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, I> ops::Index<I> for [T]\n+where\n+    I: SliceIndex<[T]>,\n+{\n+    type Output = I::Output;\n+\n+    #[inline]\n+    fn index(&self, index: I) -> &I::Output {\n+        index.index(self)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, I> ops::IndexMut<I> for [T]\n+where\n+    I: SliceIndex<[T]>,\n+{\n+    #[inline]\n+    fn index_mut(&mut self, index: I) -> &mut I::Output {\n+        index.index_mut(self)\n+    }\n+}\n+\n+#[inline(never)]\n+#[cold]\n+#[track_caller]\n+fn slice_start_index_len_fail(index: usize, len: usize) -> ! {\n+    panic!(\"range start index {} out of range for slice of length {}\", index, len);\n+}\n+\n+#[inline(never)]\n+#[cold]\n+#[track_caller]\n+pub(super) fn slice_end_index_len_fail(index: usize, len: usize) -> ! {\n+    panic!(\"range end index {} out of range for slice of length {}\", index, len);\n+}\n+\n+#[inline(never)]\n+#[cold]\n+#[track_caller]\n+pub(super) fn slice_index_order_fail(index: usize, end: usize) -> ! {\n+    panic!(\"slice index starts at {} but ends at {}\", index, end);\n+}\n+\n+#[inline(never)]\n+#[cold]\n+#[track_caller]\n+pub(super) fn slice_start_index_overflow_fail() -> ! {\n+    panic!(\"attempted to index slice from after maximum usize\");\n+}\n+\n+#[inline(never)]\n+#[cold]\n+#[track_caller]\n+pub(super) fn slice_end_index_overflow_fail() -> ! {\n+    panic!(\"attempted to index slice up to maximum usize\");\n+}\n+\n+mod private_slice_index {\n+    use super::ops;\n+    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n+    pub trait Sealed {}\n+\n+    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n+    impl Sealed for usize {}\n+    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n+    impl Sealed for ops::Range<usize> {}\n+    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n+    impl Sealed for ops::RangeTo<usize> {}\n+    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n+    impl Sealed for ops::RangeFrom<usize> {}\n+    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n+    impl Sealed for ops::RangeFull {}\n+    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n+    impl Sealed for ops::RangeInclusive<usize> {}\n+    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n+    impl Sealed for ops::RangeToInclusive<usize> {}\n+}\n+\n+/// A helper trait used for indexing operations.\n+///\n+/// Implementations of this trait have to promise that if the argument\n+/// to `get_(mut_)unchecked` is a safe reference, then so is the result.\n+#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n+#[rustc_on_unimplemented(\n+    on(T = \"str\", label = \"string indices are ranges of `usize`\",),\n+    on(\n+        all(any(T = \"str\", T = \"&str\", T = \"std::string::String\"), _Self = \"{integer}\"),\n+        note = \"you can use `.chars().nth()` or `.bytes().nth()`\\n\\\n+                for more information, see chapter 8 in The Book: \\\n+                <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n+    ),\n+    message = \"the type `{T}` cannot be indexed by `{Self}`\",\n+    label = \"slice indices are of type `usize` or ranges of `usize`\"\n+)]\n+pub unsafe trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n+    /// The output type returned by methods.\n+    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n+    type Output: ?Sized;\n+\n+    /// Returns a shared reference to the output at this location, if in\n+    /// bounds.\n+    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n+    fn get(self, slice: &T) -> Option<&Self::Output>;\n+\n+    /// Returns a mutable reference to the output at this location, if in\n+    /// bounds.\n+    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n+    fn get_mut(self, slice: &mut T) -> Option<&mut Self::Output>;\n+\n+    /// Returns a shared reference to the output at this location, without\n+    /// performing any bounds checking.\n+    /// Calling this method with an out-of-bounds index or a dangling `slice` pointer\n+    /// is *[undefined behavior]* even if the resulting reference is not used.\n+    ///\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n+    unsafe fn get_unchecked(self, slice: *const T) -> *const Self::Output;\n+\n+    /// Returns a mutable reference to the output at this location, without\n+    /// performing any bounds checking.\n+    /// Calling this method with an out-of-bounds index or a dangling `slice` pointer\n+    /// is *[undefined behavior]* even if the resulting reference is not used.\n+    ///\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n+    unsafe fn get_unchecked_mut(self, slice: *mut T) -> *mut Self::Output;\n+\n+    /// Returns a shared reference to the output at this location, panicking\n+    /// if out of bounds.\n+    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n+    #[track_caller]\n+    fn index(self, slice: &T) -> &Self::Output;\n+\n+    /// Returns a mutable reference to the output at this location, panicking\n+    /// if out of bounds.\n+    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n+    #[track_caller]\n+    fn index_mut(self, slice: &mut T) -> &mut Self::Output;\n+}\n+\n+#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n+unsafe impl<T> SliceIndex<[T]> for usize {\n+    type Output = T;\n+\n+    #[inline]\n+    fn get(self, slice: &[T]) -> Option<&T> {\n+        // SAFETY: `self` is checked to be in bounds.\n+        if self < slice.len() { unsafe { Some(&*self.get_unchecked(slice)) } } else { None }\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut T> {\n+        // SAFETY: `self` is checked to be in bounds.\n+        if self < slice.len() { unsafe { Some(&mut *self.get_unchecked_mut(slice)) } } else { None }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const T {\n+        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n+        // cannot be longer than `isize::MAX`. They also guarantee that\n+        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n+        // so the call to `add` is safe.\n+        unsafe { slice.as_ptr().add(self) }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut T {\n+        // SAFETY: see comments for `get_unchecked` above.\n+        unsafe { slice.as_mut_ptr().add(self) }\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &T {\n+        // N.B., use intrinsic indexing\n+        &(*slice)[self]\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut T {\n+        // N.B., use intrinsic indexing\n+        &mut (*slice)[self]\n+    }\n+}\n+\n+#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n+unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        if self.start > self.end || self.end > slice.len() {\n+            None\n+        } else {\n+            // SAFETY: `self` is checked to be valid and in bounds above.\n+            unsafe { Some(&*self.get_unchecked(slice)) }\n+        }\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        if self.start > self.end || self.end > slice.len() {\n+            None\n+        } else {\n+            // SAFETY: `self` is checked to be valid and in bounds above.\n+            unsafe { Some(&mut *self.get_unchecked_mut(slice)) }\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n+        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n+        // cannot be longer than `isize::MAX`. They also guarantee that\n+        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n+        // so the call to `add` is safe.\n+        unsafe { ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start) }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n+        // SAFETY: see comments for `get_unchecked` above.\n+        unsafe {\n+            ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n+        }\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &[T] {\n+        if self.start > self.end {\n+            slice_index_order_fail(self.start, self.end);\n+        } else if self.end > slice.len() {\n+            slice_end_index_len_fail(self.end, slice.len());\n+        }\n+        // SAFETY: `self` is checked to be valid and in bounds above.\n+        unsafe { &*self.get_unchecked(slice) }\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        if self.start > self.end {\n+            slice_index_order_fail(self.start, self.end);\n+        } else if self.end > slice.len() {\n+            slice_end_index_len_fail(self.end, slice.len());\n+        }\n+        // SAFETY: `self` is checked to be valid and in bounds above.\n+        unsafe { &mut *self.get_unchecked_mut(slice) }\n+    }\n+}\n+\n+#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        (0..self.end).get(slice)\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        (0..self.end).get_mut(slice)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (0..self.end).get_unchecked(slice) }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (0..self.end).get_unchecked_mut(slice) }\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &[T] {\n+        (0..self.end).index(slice)\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        (0..self.end).index_mut(slice)\n+    }\n+}\n+\n+#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        (self.start..slice.len()).get(slice)\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        (self.start..slice.len()).get_mut(slice)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (self.start..slice.len()).get_unchecked(slice) }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (self.start..slice.len()).get_unchecked_mut(slice) }\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &[T] {\n+        if self.start > slice.len() {\n+            slice_start_index_len_fail(self.start, slice.len());\n+        }\n+        // SAFETY: `self` is checked to be valid and in bounds above.\n+        unsafe { &*self.get_unchecked(slice) }\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        if self.start > slice.len() {\n+            slice_start_index_len_fail(self.start, slice.len());\n+        }\n+        // SAFETY: `self` is checked to be valid and in bounds above.\n+        unsafe { &mut *self.get_unchecked_mut(slice) }\n+    }\n+}\n+\n+#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeFull {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        Some(slice)\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        Some(slice)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n+        slice\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n+        slice\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &[T] {\n+        slice\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        slice\n+    }\n+}\n+\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        if *self.end() == usize::MAX { None } else { (*self.start()..self.end() + 1).get(slice) }\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        if *self.end() == usize::MAX {\n+            None\n+        } else {\n+            (*self.start()..self.end() + 1).get_mut(slice)\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &[T] {\n+        if *self.end() == usize::MAX {\n+            slice_end_index_overflow_fail();\n+        }\n+        (*self.start()..self.end() + 1).index(slice)\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        if *self.end() == usize::MAX {\n+            slice_end_index_overflow_fail();\n+        }\n+        (*self.start()..self.end() + 1).index_mut(slice)\n+    }\n+}\n+\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        (0..=self.end).get(slice)\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        (0..=self.end).get_mut(slice)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (0..=self.end).get_unchecked(slice) }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (0..=self.end).get_unchecked_mut(slice) }\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &[T] {\n+        (0..=self.end).index(slice)\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        (0..=self.end).index_mut(slice)\n+    }\n+}"}, {"sha": "6447543d0e715167d813afcad85526a14721bbb3", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 12, "deletions": 737, "changes": 749, "blob_url": "https://github.com/rust-lang/rust/blob/fbad684e2ff11f58dc94d9c19bf31c5787afd98e/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbad684e2ff11f58dc94d9c19bf31c5787afd98e/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=fbad684e2ff11f58dc94d9c19bf31c5787afd98e", "patch": "@@ -20,12 +20,11 @@\n // * The `raw` and `bytes` submodules.\n // * Boilerplate trait implementations.\n \n-use crate::cmp;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::intrinsics::assume;\n-use crate::marker::{self, Copy, Sized};\n+use crate::marker::{self, Copy};\n use crate::mem;\n-use crate::ops::{self, Bound, FnMut, Range, RangeBounds};\n+use crate::ops::{Bound, FnMut, Range, RangeBounds};\n use crate::option::Option;\n use crate::option::Option::{None, Some};\n use crate::ptr::{self, NonNull};\n@@ -40,6 +39,8 @@ use crate::result::Result::{Err, Ok};\n /// Pure rust memchr implementation, taken from rust-memchr\n pub mod memchr;\n \n+mod cmp;\n+mod index;\n mod iter;\n mod raw;\n mod rotate;\n@@ -79,6 +80,12 @@ pub use raw::{from_mut, from_ref};\n #[unstable(feature = \"sort_internals\", reason = \"internal to sort module\", issue = \"none\")]\n pub use sort::heapsort;\n \n+#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n+pub use index::SliceIndex;\n+\n+use index::{slice_end_index_len_fail, slice_index_order_fail};\n+use index::{slice_end_index_overflow_fail, slice_start_index_overflow_fail};\n+\n //\n // Extension traits\n //\n@@ -428,7 +435,7 @@ impl<T> [T] {\n     /// [10, 40, 30].check_range(1..=usize::MAX);\n     /// ```\n     ///\n-    /// [`Index::index`]: ops::Index::index\n+    /// [`Index::index`]: crate::ops::Index::index\n     #[track_caller]\n     #[unstable(feature = \"slice_check_range\", issue = \"76393\")]\n     pub fn check_range<R: RangeBounds<usize>>(&self, range: R) -> Range<usize> {\n@@ -1766,7 +1773,7 @@ impl<T> [T] {\n     where\n         T: PartialEq,\n     {\n-        x.slice_contains(self)\n+        cmp::SliceContains::slice_contains(x, self)\n     }\n \n     /// Returns `true` if `needle` is a prefix of the slice.\n@@ -3343,457 +3350,6 @@ fn is_ascii(s: &[u8]) -> bool {\n     !contains_nonascii(last_word)\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, I> ops::Index<I> for [T]\n-where\n-    I: SliceIndex<[T]>,\n-{\n-    type Output = I::Output;\n-\n-    #[inline]\n-    fn index(&self, index: I) -> &I::Output {\n-        index.index(self)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, I> ops::IndexMut<I> for [T]\n-where\n-    I: SliceIndex<[T]>,\n-{\n-    #[inline]\n-    fn index_mut(&mut self, index: I) -> &mut I::Output {\n-        index.index_mut(self)\n-    }\n-}\n-\n-#[inline(never)]\n-#[cold]\n-#[track_caller]\n-fn slice_start_index_len_fail(index: usize, len: usize) -> ! {\n-    panic!(\"range start index {} out of range for slice of length {}\", index, len);\n-}\n-\n-#[inline(never)]\n-#[cold]\n-#[track_caller]\n-fn slice_end_index_len_fail(index: usize, len: usize) -> ! {\n-    panic!(\"range end index {} out of range for slice of length {}\", index, len);\n-}\n-\n-#[inline(never)]\n-#[cold]\n-#[track_caller]\n-fn slice_index_order_fail(index: usize, end: usize) -> ! {\n-    panic!(\"slice index starts at {} but ends at {}\", index, end);\n-}\n-\n-#[inline(never)]\n-#[cold]\n-#[track_caller]\n-fn slice_start_index_overflow_fail() -> ! {\n-    panic!(\"attempted to index slice from after maximum usize\");\n-}\n-\n-#[inline(never)]\n-#[cold]\n-#[track_caller]\n-fn slice_end_index_overflow_fail() -> ! {\n-    panic!(\"attempted to index slice up to maximum usize\");\n-}\n-\n-mod private_slice_index {\n-    use super::ops;\n-    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n-    pub trait Sealed {}\n-\n-    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n-    impl Sealed for usize {}\n-    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n-    impl Sealed for ops::Range<usize> {}\n-    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n-    impl Sealed for ops::RangeTo<usize> {}\n-    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n-    impl Sealed for ops::RangeFrom<usize> {}\n-    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n-    impl Sealed for ops::RangeFull {}\n-    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n-    impl Sealed for ops::RangeInclusive<usize> {}\n-    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n-    impl Sealed for ops::RangeToInclusive<usize> {}\n-}\n-\n-/// A helper trait used for indexing operations.\n-///\n-/// Implementations of this trait have to promise that if the argument\n-/// to `get_(mut_)unchecked` is a safe reference, then so is the result.\n-#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n-#[rustc_on_unimplemented(\n-    on(T = \"str\", label = \"string indices are ranges of `usize`\",),\n-    on(\n-        all(any(T = \"str\", T = \"&str\", T = \"std::string::String\"), _Self = \"{integer}\"),\n-        note = \"you can use `.chars().nth()` or `.bytes().nth()`\\n\\\n-                for more information, see chapter 8 in The Book: \\\n-                <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n-    ),\n-    message = \"the type `{T}` cannot be indexed by `{Self}`\",\n-    label = \"slice indices are of type `usize` or ranges of `usize`\"\n-)]\n-pub unsafe trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n-    /// The output type returned by methods.\n-    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n-    type Output: ?Sized;\n-\n-    /// Returns a shared reference to the output at this location, if in\n-    /// bounds.\n-    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n-    fn get(self, slice: &T) -> Option<&Self::Output>;\n-\n-    /// Returns a mutable reference to the output at this location, if in\n-    /// bounds.\n-    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n-    fn get_mut(self, slice: &mut T) -> Option<&mut Self::Output>;\n-\n-    /// Returns a shared reference to the output at this location, without\n-    /// performing any bounds checking.\n-    /// Calling this method with an out-of-bounds index or a dangling `slice` pointer\n-    /// is *[undefined behavior]* even if the resulting reference is not used.\n-    ///\n-    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n-    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n-    unsafe fn get_unchecked(self, slice: *const T) -> *const Self::Output;\n-\n-    /// Returns a mutable reference to the output at this location, without\n-    /// performing any bounds checking.\n-    /// Calling this method with an out-of-bounds index or a dangling `slice` pointer\n-    /// is *[undefined behavior]* even if the resulting reference is not used.\n-    ///\n-    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n-    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n-    unsafe fn get_unchecked_mut(self, slice: *mut T) -> *mut Self::Output;\n-\n-    /// Returns a shared reference to the output at this location, panicking\n-    /// if out of bounds.\n-    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n-    #[track_caller]\n-    fn index(self, slice: &T) -> &Self::Output;\n-\n-    /// Returns a mutable reference to the output at this location, panicking\n-    /// if out of bounds.\n-    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n-    #[track_caller]\n-    fn index_mut(self, slice: &mut T) -> &mut Self::Output;\n-}\n-\n-#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-unsafe impl<T> SliceIndex<[T]> for usize {\n-    type Output = T;\n-\n-    #[inline]\n-    fn get(self, slice: &[T]) -> Option<&T> {\n-        // SAFETY: `self` is checked to be in bounds.\n-        if self < slice.len() { unsafe { Some(&*self.get_unchecked(slice)) } } else { None }\n-    }\n-\n-    #[inline]\n-    fn get_mut(self, slice: &mut [T]) -> Option<&mut T> {\n-        // SAFETY: `self` is checked to be in bounds.\n-        if self < slice.len() { unsafe { Some(&mut *self.get_unchecked_mut(slice)) } } else { None }\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked(self, slice: *const [T]) -> *const T {\n-        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n-        // cannot be longer than `isize::MAX`. They also guarantee that\n-        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n-        // so the call to `add` is safe.\n-        unsafe { slice.as_ptr().add(self) }\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut T {\n-        // SAFETY: see comments for `get_unchecked` above.\n-        unsafe { slice.as_mut_ptr().add(self) }\n-    }\n-\n-    #[inline]\n-    fn index(self, slice: &[T]) -> &T {\n-        // N.B., use intrinsic indexing\n-        &(*slice)[self]\n-    }\n-\n-    #[inline]\n-    fn index_mut(self, slice: &mut [T]) -> &mut T {\n-        // N.B., use intrinsic indexing\n-        &mut (*slice)[self]\n-    }\n-}\n-\n-#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn get(self, slice: &[T]) -> Option<&[T]> {\n-        if self.start > self.end || self.end > slice.len() {\n-            None\n-        } else {\n-            // SAFETY: `self` is checked to be valid and in bounds above.\n-            unsafe { Some(&*self.get_unchecked(slice)) }\n-        }\n-    }\n-\n-    #[inline]\n-    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        if self.start > self.end || self.end > slice.len() {\n-            None\n-        } else {\n-            // SAFETY: `self` is checked to be valid and in bounds above.\n-            unsafe { Some(&mut *self.get_unchecked_mut(slice)) }\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n-        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n-        // cannot be longer than `isize::MAX`. They also guarantee that\n-        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n-        // so the call to `add` is safe.\n-        unsafe { ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start) }\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n-        // SAFETY: see comments for `get_unchecked` above.\n-        unsafe {\n-            ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n-        }\n-    }\n-\n-    #[inline]\n-    fn index(self, slice: &[T]) -> &[T] {\n-        if self.start > self.end {\n-            slice_index_order_fail(self.start, self.end);\n-        } else if self.end > slice.len() {\n-            slice_end_index_len_fail(self.end, slice.len());\n-        }\n-        // SAFETY: `self` is checked to be valid and in bounds above.\n-        unsafe { &*self.get_unchecked(slice) }\n-    }\n-\n-    #[inline]\n-    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        if self.start > self.end {\n-            slice_index_order_fail(self.start, self.end);\n-        } else if self.end > slice.len() {\n-            slice_end_index_len_fail(self.end, slice.len());\n-        }\n-        // SAFETY: `self` is checked to be valid and in bounds above.\n-        unsafe { &mut *self.get_unchecked_mut(slice) }\n-    }\n-}\n-\n-#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-unsafe impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn get(self, slice: &[T]) -> Option<&[T]> {\n-        (0..self.end).get(slice)\n-    }\n-\n-    #[inline]\n-    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        (0..self.end).get_mut(slice)\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n-        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n-        unsafe { (0..self.end).get_unchecked(slice) }\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n-        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (0..self.end).get_unchecked_mut(slice) }\n-    }\n-\n-    #[inline]\n-    fn index(self, slice: &[T]) -> &[T] {\n-        (0..self.end).index(slice)\n-    }\n-\n-    #[inline]\n-    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (0..self.end).index_mut(slice)\n-    }\n-}\n-\n-#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-unsafe impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn get(self, slice: &[T]) -> Option<&[T]> {\n-        (self.start..slice.len()).get(slice)\n-    }\n-\n-    #[inline]\n-    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        (self.start..slice.len()).get_mut(slice)\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n-        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n-        unsafe { (self.start..slice.len()).get_unchecked(slice) }\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n-        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (self.start..slice.len()).get_unchecked_mut(slice) }\n-    }\n-\n-    #[inline]\n-    fn index(self, slice: &[T]) -> &[T] {\n-        if self.start > slice.len() {\n-            slice_start_index_len_fail(self.start, slice.len());\n-        }\n-        // SAFETY: `self` is checked to be valid and in bounds above.\n-        unsafe { &*self.get_unchecked(slice) }\n-    }\n-\n-    #[inline]\n-    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        if self.start > slice.len() {\n-            slice_start_index_len_fail(self.start, slice.len());\n-        }\n-        // SAFETY: `self` is checked to be valid and in bounds above.\n-        unsafe { &mut *self.get_unchecked_mut(slice) }\n-    }\n-}\n-\n-#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-unsafe impl<T> SliceIndex<[T]> for ops::RangeFull {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn get(self, slice: &[T]) -> Option<&[T]> {\n-        Some(slice)\n-    }\n-\n-    #[inline]\n-    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        Some(slice)\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n-        slice\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n-        slice\n-    }\n-\n-    #[inline]\n-    fn index(self, slice: &[T]) -> &[T] {\n-        slice\n-    }\n-\n-    #[inline]\n-    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        slice\n-    }\n-}\n-\n-#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-unsafe impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn get(self, slice: &[T]) -> Option<&[T]> {\n-        if *self.end() == usize::MAX { None } else { (*self.start()..self.end() + 1).get(slice) }\n-    }\n-\n-    #[inline]\n-    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        if *self.end() == usize::MAX {\n-            None\n-        } else {\n-            (*self.start()..self.end() + 1).get_mut(slice)\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n-        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n-        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n-    }\n-\n-    #[inline]\n-    fn index(self, slice: &[T]) -> &[T] {\n-        if *self.end() == usize::MAX {\n-            slice_end_index_overflow_fail();\n-        }\n-        (*self.start()..self.end() + 1).index(slice)\n-    }\n-\n-    #[inline]\n-    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        if *self.end() == usize::MAX {\n-            slice_end_index_overflow_fail();\n-        }\n-        (*self.start()..self.end() + 1).index_mut(slice)\n-    }\n-}\n-\n-#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-unsafe impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn get(self, slice: &[T]) -> Option<&[T]> {\n-        (0..=self.end).get(slice)\n-    }\n-\n-    #[inline]\n-    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        (0..=self.end).get_mut(slice)\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n-        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n-        unsafe { (0..=self.end).get_unchecked(slice) }\n-    }\n-\n-    #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n-        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (0..=self.end).get_unchecked_mut(slice) }\n-    }\n-\n-    #[inline]\n-    fn index(self, slice: &[T]) -> &[T] {\n-        (0..=self.end).index(slice)\n-    }\n-\n-    #[inline]\n-    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (0..=self.end).index_mut(slice)\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Common traits\n ////////////////////////////////////////////////////////////////////////////////\n@@ -3813,284 +3369,3 @@ impl<T> Default for &mut [T] {\n         &mut []\n     }\n }\n-\n-// Comparison traits\n-//\n-\n-extern \"C\" {\n-    /// Calls implementation provided memcmp.\n-    ///\n-    /// Interprets the data as u8.\n-    ///\n-    /// Returns 0 for equal, < 0 for less than and > 0 for greater\n-    /// than.\n-    // FIXME(#32610): Return type should be c_int\n-    fn memcmp(s1: *const u8, s2: *const u8, n: usize) -> i32;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> PartialEq<[B]> for [A]\n-where\n-    A: PartialEq<B>,\n-{\n-    fn eq(&self, other: &[B]) -> bool {\n-        SlicePartialEq::equal(self, other)\n-    }\n-\n-    fn ne(&self, other: &[B]) -> bool {\n-        SlicePartialEq::not_equal(self, other)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Eq> Eq for [T] {}\n-\n-/// Implements comparison of vectors lexicographically.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord> Ord for [T] {\n-    fn cmp(&self, other: &[T]) -> Ordering {\n-        SliceOrd::compare(self, other)\n-    }\n-}\n-\n-/// Implements comparison of vectors lexicographically.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialOrd> PartialOrd for [T] {\n-    fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n-        SlicePartialOrd::partial_compare(self, other)\n-    }\n-}\n-\n-#[doc(hidden)]\n-// intermediate trait for specialization of slice's PartialEq\n-trait SlicePartialEq<B> {\n-    fn equal(&self, other: &[B]) -> bool;\n-\n-    fn not_equal(&self, other: &[B]) -> bool {\n-        !self.equal(other)\n-    }\n-}\n-\n-// Generic slice equality\n-impl<A, B> SlicePartialEq<B> for [A]\n-where\n-    A: PartialEq<B>,\n-{\n-    default fn equal(&self, other: &[B]) -> bool {\n-        if self.len() != other.len() {\n-            return false;\n-        }\n-\n-        self.iter().zip(other.iter()).all(|(x, y)| x == y)\n-    }\n-}\n-\n-// Use an equal-pointer optimization when types are `Eq`\n-// We can't make `A` and `B` the same type because `min_specialization` won't\n-// allow it.\n-impl<A, B> SlicePartialEq<B> for [A]\n-where\n-    A: MarkerEq<B>,\n-{\n-    default fn equal(&self, other: &[B]) -> bool {\n-        if self.len() != other.len() {\n-            return false;\n-        }\n-\n-        // While performance would suffer if `guaranteed_eq` just returned `false`\n-        // for all arguments, correctness and return value of this function are not affected.\n-        if self.as_ptr().guaranteed_eq(other.as_ptr() as *const A) {\n-            return true;\n-        }\n-\n-        self.iter().zip(other.iter()).all(|(x, y)| x == y)\n-    }\n-}\n-\n-// Use memcmp for bytewise equality when the types allow\n-impl<A, B> SlicePartialEq<B> for [A]\n-where\n-    A: BytewiseEquality<B>,\n-{\n-    fn equal(&self, other: &[B]) -> bool {\n-        if self.len() != other.len() {\n-            return false;\n-        }\n-\n-        // While performance would suffer if `guaranteed_eq` just returned `false`\n-        // for all arguments, correctness and return value of this function are not affected.\n-        if self.as_ptr().guaranteed_eq(other.as_ptr() as *const A) {\n-            return true;\n-        }\n-        // SAFETY: `self` and `other` are references and are thus guaranteed to be valid.\n-        // The two slices have been checked to have the same size above.\n-        unsafe {\n-            let size = mem::size_of_val(self);\n-            memcmp(self.as_ptr() as *const u8, other.as_ptr() as *const u8, size) == 0\n-        }\n-    }\n-}\n-\n-#[doc(hidden)]\n-// intermediate trait for specialization of slice's PartialOrd\n-trait SlicePartialOrd: Sized {\n-    fn partial_compare(left: &[Self], right: &[Self]) -> Option<Ordering>;\n-}\n-\n-impl<A: PartialOrd> SlicePartialOrd for A {\n-    default fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n-        let l = cmp::min(left.len(), right.len());\n-\n-        // Slice to the loop iteration range to enable bound check\n-        // elimination in the compiler\n-        let lhs = &left[..l];\n-        let rhs = &right[..l];\n-\n-        for i in 0..l {\n-            match lhs[i].partial_cmp(&rhs[i]) {\n-                Some(Ordering::Equal) => (),\n-                non_eq => return non_eq,\n-            }\n-        }\n-\n-        left.len().partial_cmp(&right.len())\n-    }\n-}\n-\n-// This is the impl that we would like to have. Unfortunately it's not sound.\n-// See `partial_ord_slice.rs`.\n-/*\n-impl<A> SlicePartialOrd for A\n-where\n-    A: Ord,\n-{\n-    default fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n-        Some(SliceOrd::compare(left, right))\n-    }\n-}\n-*/\n-\n-impl<A: AlwaysApplicableOrd> SlicePartialOrd for A {\n-    fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n-        Some(SliceOrd::compare(left, right))\n-    }\n-}\n-\n-#[rustc_specialization_trait]\n-trait AlwaysApplicableOrd: SliceOrd + Ord {}\n-\n-macro_rules! always_applicable_ord {\n-    ($([$($p:tt)*] $t:ty,)*) => {\n-        $(impl<$($p)*> AlwaysApplicableOrd for $t {})*\n-    }\n-}\n-\n-always_applicable_ord! {\n-    [] u8, [] u16, [] u32, [] u64, [] u128, [] usize,\n-    [] i8, [] i16, [] i32, [] i64, [] i128, [] isize,\n-    [] bool, [] char,\n-    [T: ?Sized] *const T, [T: ?Sized] *mut T,\n-    [T: AlwaysApplicableOrd] &T,\n-    [T: AlwaysApplicableOrd] &mut T,\n-    [T: AlwaysApplicableOrd] Option<T>,\n-}\n-\n-#[doc(hidden)]\n-// intermediate trait for specialization of slice's Ord\n-trait SliceOrd: Sized {\n-    fn compare(left: &[Self], right: &[Self]) -> Ordering;\n-}\n-\n-impl<A: Ord> SliceOrd for A {\n-    default fn compare(left: &[Self], right: &[Self]) -> Ordering {\n-        let l = cmp::min(left.len(), right.len());\n-\n-        // Slice to the loop iteration range to enable bound check\n-        // elimination in the compiler\n-        let lhs = &left[..l];\n-        let rhs = &right[..l];\n-\n-        for i in 0..l {\n-            match lhs[i].cmp(&rhs[i]) {\n-                Ordering::Equal => (),\n-                non_eq => return non_eq,\n-            }\n-        }\n-\n-        left.len().cmp(&right.len())\n-    }\n-}\n-\n-// memcmp compares a sequence of unsigned bytes lexicographically.\n-// this matches the order we want for [u8], but no others (not even [i8]).\n-impl SliceOrd for u8 {\n-    #[inline]\n-    fn compare(left: &[Self], right: &[Self]) -> Ordering {\n-        let order =\n-            // SAFETY: `left` and `right` are references and are thus guaranteed to be valid.\n-            // We use the minimum of both lengths which guarantees that both regions are\n-            // valid for reads in that interval.\n-            unsafe { memcmp(left.as_ptr(), right.as_ptr(), cmp::min(left.len(), right.len())) };\n-        if order == 0 {\n-            left.len().cmp(&right.len())\n-        } else if order < 0 {\n-            Less\n-        } else {\n-            Greater\n-        }\n-    }\n-}\n-\n-// Hack to allow specializing on `Eq` even though `Eq` has a method.\n-#[rustc_unsafe_specialization_marker]\n-trait MarkerEq<T>: PartialEq<T> {}\n-\n-impl<T: Eq> MarkerEq<T> for T {}\n-\n-#[doc(hidden)]\n-/// Trait implemented for types that can be compared for equality using\n-/// their bytewise representation\n-#[rustc_specialization_trait]\n-trait BytewiseEquality<T>: MarkerEq<T> + Copy {}\n-\n-macro_rules! impl_marker_for {\n-    ($traitname:ident, $($ty:ty)*) => {\n-        $(\n-            impl $traitname<$ty> for $ty { }\n-        )*\n-    }\n-}\n-\n-impl_marker_for!(BytewiseEquality,\n-                 u8 i8 u16 i16 u32 i32 u64 i64 u128 i128 usize isize char bool);\n-\n-trait SliceContains: Sized {\n-    fn slice_contains(&self, x: &[Self]) -> bool;\n-}\n-\n-impl<T> SliceContains for T\n-where\n-    T: PartialEq,\n-{\n-    default fn slice_contains(&self, x: &[Self]) -> bool {\n-        x.iter().any(|y| *y == *self)\n-    }\n-}\n-\n-impl SliceContains for u8 {\n-    fn slice_contains(&self, x: &[Self]) -> bool {\n-        memchr::memchr(*self, x).is_some()\n-    }\n-}\n-\n-impl SliceContains for i8 {\n-    fn slice_contains(&self, x: &[Self]) -> bool {\n-        let byte = *self as u8;\n-        // SAFETY: `i8` and `u8` have the same memory layout, thus casting `x.as_ptr()`\n-        // as `*const u8` is safe. The `x.as_ptr()` comes from a reference and is thus guaranteed\n-        // to be valid for reads for the length of the slice `x.len()`, which cannot be larger\n-        // than `isize::MAX`. The returned slice is never mutated.\n-        let bytes: &[u8] = unsafe { from_raw_parts(x.as_ptr() as *const u8, x.len()) };\n-        memchr::memchr(byte, bytes).is_some()\n-    }\n-}"}]}