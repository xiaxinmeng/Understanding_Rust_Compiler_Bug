{"sha": "54c11a688f38a979e789fa50592088654ed56680", "node_id": "C_kwDOAAsO6NoAKDU0YzExYTY4OGYzOGE5NzllNzg5ZmE1MDU5MjA4ODY1NGVkNTY2ODA", "commit": {"author": {"name": "Alex Chi", "email": "iskyzh@gmail.com", "date": "2023-03-18T02:22:49Z"}, "committer": {"name": "Alex Chi", "email": "iskyzh@gmail.com", "date": "2023-04-14T15:39:35Z"}, "message": "better suggestion based on hir\n\nSigned-off-by: Alex Chi <iskyzh@gmail.com>", "tree": {"sha": "4301b8e627685ff4cbd4d770435b43c050428fc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4301b8e627685ff4cbd4d770435b43c050428fc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54c11a688f38a979e789fa50592088654ed56680", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54c11a688f38a979e789fa50592088654ed56680", "html_url": "https://github.com/rust-lang/rust/commit/54c11a688f38a979e789fa50592088654ed56680", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54c11a688f38a979e789fa50592088654ed56680/comments", "author": {"login": "skyzh", "id": 4198311, "node_id": "MDQ6VXNlcjQxOTgzMTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4198311?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skyzh", "html_url": "https://github.com/skyzh", "followers_url": "https://api.github.com/users/skyzh/followers", "following_url": "https://api.github.com/users/skyzh/following{/other_user}", "gists_url": "https://api.github.com/users/skyzh/gists{/gist_id}", "starred_url": "https://api.github.com/users/skyzh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skyzh/subscriptions", "organizations_url": "https://api.github.com/users/skyzh/orgs", "repos_url": "https://api.github.com/users/skyzh/repos", "events_url": "https://api.github.com/users/skyzh/events{/privacy}", "received_events_url": "https://api.github.com/users/skyzh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "skyzh", "id": 4198311, "node_id": "MDQ6VXNlcjQxOTgzMTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4198311?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skyzh", "html_url": "https://github.com/skyzh", "followers_url": "https://api.github.com/users/skyzh/followers", "following_url": "https://api.github.com/users/skyzh/following{/other_user}", "gists_url": "https://api.github.com/users/skyzh/gists{/gist_id}", "starred_url": "https://api.github.com/users/skyzh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skyzh/subscriptions", "organizations_url": "https://api.github.com/users/skyzh/orgs", "repos_url": "https://api.github.com/users/skyzh/repos", "events_url": "https://api.github.com/users/skyzh/events{/privacy}", "received_events_url": "https://api.github.com/users/skyzh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e17349b12ee5c8c76c742f4be96f6eba60a8a93", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e17349b12ee5c8c76c742f4be96f6eba60a8a93", "html_url": "https://github.com/rust-lang/rust/commit/6e17349b12ee5c8c76c742f4be96f6eba60a8a93"}], "stats": {"total": 245, "additions": 200, "deletions": 45}, "files": [{"sha": "992b07db1543dff0ab9a1494795a4d05f44329de", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c11a688f38a979e789fa50592088654ed56680/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c11a688f38a979e789fa50592088654ed56680/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=54c11a688f38a979e789fa50592088654ed56680", "patch": "@@ -1927,7 +1927,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         {\n             let span = self.tcx.def_span(def_id);\n             diag.span_note(span, \"this closure does not fulfill the lifetime requirements\");\n-            self.suggest_for_all_lifetime_closure(span, &exp_found, diag);\n+            self.suggest_for_all_lifetime_closure(span, self.tcx.hir().get_by_def_id(def_id), &exp_found, diag);\n         }\n \n         // It reads better to have the error origin as the final"}, {"sha": "ec0aa77cef38a37ee2377bd2636f72a097339b34", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 48, "deletions": 40, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/54c11a688f38a979e789fa50592088654ed56680/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c11a688f38a979e789fa50592088654ed56680/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=54c11a688f38a979e789fa50592088654ed56680", "patch": "@@ -542,54 +542,62 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     pub(super) fn suggest_for_all_lifetime_closure(\n         &self,\n         span: Span,\n+        hir: hir::Node<'_>,\n         exp_found: &ty::error::ExpectedFound<ty::PolyTraitRef<'tcx>>,\n         diag: &mut Diagnostic,\n     ) {\n+        // 0. Extract fn_decl from hir\n+        let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(hir::Closure { fn_decl, .. }), .. }) = hir else { return; };\n+\n         // 1. Get the substs of the closure.\n         // 2. Assume exp_found is FnOnce / FnMut / Fn, we can extract function parameters from [1].\n-        let expected = exp_found.expected.map_bound(|x| x.substs.get(1).cloned()).transpose();\n-        let found = exp_found.found.map_bound(|x| x.substs.get(1).cloned()).transpose();\n-\n+        let Some(expected) = exp_found.expected.skip_binder().substs.get(1) else { return; };\n+        let Some(found) = exp_found.found.skip_binder().substs.get(1) else { return; };\n+        let expected = expected.unpack();\n+        let found = found.unpack();\n         // 3. Extract the tuple type from Fn trait and suggest the change.\n-        if let (Some(expected), Some(found)) = (expected, found) {\n-            let expected = expected.skip_binder().unpack();\n-            let found = found.skip_binder().unpack();\n-            if let (GenericArgKind::Type(expected), GenericArgKind::Type(found)) = (expected, found)\n-             && let (ty::Tuple(expected), ty::Tuple(found)) = (expected.kind(), found.kind())\n-                    && expected.len() == found.len() {\n-                    let mut suggestion = \"|\".to_string();\n-                    let mut is_first = true;\n-                    let mut has_suggestion = false;\n-\n-                    for (expected, found) in expected.iter().zip(found.iter()) {\n-                        if is_first {\n-                            is_first = true;\n-                        } else {\n-                            suggestion += \", \";\n-                        }\n+        if let GenericArgKind::Type(expected) = expected &&\n+            let GenericArgKind::Type(found) = found &&\n+            let ty::Tuple(expected) = expected.kind() &&\n+            let ty::Tuple(found)= found.kind() &&\n+            expected.len() == found.len() {\n+            let mut suggestion = \"|\".to_string();\n+            let mut is_first = true;\n+            let mut has_suggestion = false;\n+\n+            for ((expected, found), arg_hir) in expected.iter().zip(found.iter()).zip(fn_decl.inputs.iter()) {\n+                if is_first {\n+                    is_first = false;\n+                } else {\n+                    suggestion += \", \";\n+                }\n \n-                        if let (ty::Ref(expected_region, _, _), ty::Ref(found_region, _, _)) = (expected.kind(), found.kind())\n-                            && expected_region.is_late_bound() && !found_region.is_late_bound() {\n-                            // If the expected region is late bound, and the found region is not, we can suggest adding `: &_`.\n-                            // FIXME: use the actual type + variable name provided by user instead of `_`.\n-                            suggestion += \"_: &_\";\n-                            has_suggestion = true;\n-                        } else {\n-                            // Otherwise, keep it as-is.\n-                            suggestion += \"_\";\n-                        }\n-                    }\n-                    suggestion += \"|\";\n-\n-                    if has_suggestion {\n-                        diag.span_suggestion_verbose(\n-                            span,\n-                            \"consider changing the type of the closure parameters\",\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n+                if let ty::Ref(expected_region, _, _) = expected.kind() &&\n+                    let ty::Ref(found_region, _, _) = found.kind() &&\n+                    expected_region.is_late_bound() &&\n+                    !found_region.is_late_bound() &&\n+                    let hir::TyKind::Infer = arg_hir.kind {\n+                    // If the expected region is late bound, the found region is not, and users are asking compiler\n+                    // to infer the type, we can suggest adding `: &_`.\n+                    let Ok(arg) = self.tcx.sess.source_map().span_to_snippet(arg_hir.span) else { return; };\n+                    suggestion += &format!(\"{}: &_\", arg);\n+                    has_suggestion = true;\n+                } else {\n+                    let Ok(arg) = self.tcx.sess.source_map().span_to_snippet(arg_hir.span) else { return; };\n+                    // Otherwise, keep it as-is.\n+                    suggestion += &arg;\n                 }\n+            }\n+            suggestion += \"|\";\n+\n+            if has_suggestion {\n+                diag.span_suggestion_verbose(\n+                    span,\n+                    \"consider specifying the type of the closure parameters\",\n+                    suggestion,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n         }\n     }\n }"}, {"sha": "a01fbef4b3bc40d4c71754e1ffc4361566403e6f", "filename": "tests/ui/lifetimes/issue-105675.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/54c11a688f38a979e789fa50592088654ed56680/tests%2Fui%2Flifetimes%2Fissue-105675.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c11a688f38a979e789fa50592088654ed56680/tests%2Fui%2Flifetimes%2Fissue-105675.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes%2Fissue-105675.rs?ref=54c11a688f38a979e789fa50592088654ed56680", "patch": "@@ -0,0 +1,16 @@\n+fn thing(x: impl FnOnce(&u32, &u32)) {}\n+\n+fn main() {\n+    let f = |_, _| ();\n+    thing(f);\n+    //~^ ERROR mismatched types\n+    //~^^ ERROR mismatched types\n+    //~^^^ ERROR implementation of `FnOnce` is not general enough\n+    //~^^^^ ERROR implementation of `FnOnce` is not general enough\n+    let f = |x, y| ();\n+    thing(f);\n+    //~^ ERROR mismatched types\n+    //~^^ ERROR mismatched types\n+    //~^^^ ERROR implementation of `FnOnce` is not general enough\n+    //~^^^^ ERROR implementation of `FnOnce` is not general enough\n+}"}, {"sha": "3d8172ad14a37e6df625592105b1eced9f231435", "filename": "tests/ui/lifetimes/issue-105675.stderr", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/54c11a688f38a979e789fa50592088654ed56680/tests%2Fui%2Flifetimes%2Fissue-105675.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/54c11a688f38a979e789fa50592088654ed56680/tests%2Fui%2Flifetimes%2Fissue-105675.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes%2Fissue-105675.stderr?ref=54c11a688f38a979e789fa50592088654ed56680", "patch": "@@ -0,0 +1,131 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-105675.rs:5:5\n+   |\n+LL |     thing(f);\n+   |     ^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected trait `for<'a, 'b> FnOnce<(&'a u32, &'b u32)>`\n+              found trait `FnOnce<(&u32, &u32)>`\n+note: this closure does not fulfill the lifetime requirements\n+  --> $DIR/issue-105675.rs:4:13\n+   |\n+LL |     let f = |_, _| ();\n+   |             ^^^^^^\n+note: the lifetime requirement is introduced here\n+  --> $DIR/issue-105675.rs:1:18\n+   |\n+LL | fn thing(x: impl FnOnce(&u32, &u32)) {}\n+   |                  ^^^^^^^^^^^^^^^^^^\n+help: consider specifying the type of the closure parameters\n+   |\n+LL |     let f = |_: &_, _: &_| ();\n+   |             ~~~~~~~~~~~~~~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-105675.rs:5:5\n+   |\n+LL |     thing(f);\n+   |     ^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected trait `for<'a, 'b> FnOnce<(&'a u32, &'b u32)>`\n+              found trait `FnOnce<(&u32, &u32)>`\n+note: this closure does not fulfill the lifetime requirements\n+  --> $DIR/issue-105675.rs:4:13\n+   |\n+LL |     let f = |_, _| ();\n+   |             ^^^^^^\n+note: the lifetime requirement is introduced here\n+  --> $DIR/issue-105675.rs:1:18\n+   |\n+LL | fn thing(x: impl FnOnce(&u32, &u32)) {}\n+   |                  ^^^^^^^^^^^^^^^^^^\n+help: consider specifying the type of the closure parameters\n+   |\n+LL |     let f = |_: &_, _: &_| ();\n+   |             ~~~~~~~~~~~~~~\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/issue-105675.rs:5:5\n+   |\n+LL |     thing(f);\n+   |     ^^^^^^^^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: closure with signature `fn(&'2 u32, &u32)` must implement `FnOnce<(&'1 u32, &u32)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 u32, &u32)>`, for some specific lifetime `'2`\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/issue-105675.rs:5:5\n+   |\n+LL |     thing(f);\n+   |     ^^^^^^^^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: closure with signature `fn(&u32, &'2 u32)` must implement `FnOnce<(&u32, &'1 u32)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&u32, &'2 u32)>`, for some specific lifetime `'2`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-105675.rs:11:5\n+   |\n+LL |     thing(f);\n+   |     ^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected trait `for<'a, 'b> FnOnce<(&'a u32, &'b u32)>`\n+              found trait `FnOnce<(&u32, &u32)>`\n+note: this closure does not fulfill the lifetime requirements\n+  --> $DIR/issue-105675.rs:10:13\n+   |\n+LL |     let f = |x, y| ();\n+   |             ^^^^^^\n+note: the lifetime requirement is introduced here\n+  --> $DIR/issue-105675.rs:1:18\n+   |\n+LL | fn thing(x: impl FnOnce(&u32, &u32)) {}\n+   |                  ^^^^^^^^^^^^^^^^^^\n+help: consider specifying the type of the closure parameters\n+   |\n+LL |     let f = |x: &_, y: &_| ();\n+   |             ~~~~~~~~~~~~~~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-105675.rs:11:5\n+   |\n+LL |     thing(f);\n+   |     ^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected trait `for<'a, 'b> FnOnce<(&'a u32, &'b u32)>`\n+              found trait `FnOnce<(&u32, &u32)>`\n+note: this closure does not fulfill the lifetime requirements\n+  --> $DIR/issue-105675.rs:10:13\n+   |\n+LL |     let f = |x, y| ();\n+   |             ^^^^^^\n+note: the lifetime requirement is introduced here\n+  --> $DIR/issue-105675.rs:1:18\n+   |\n+LL | fn thing(x: impl FnOnce(&u32, &u32)) {}\n+   |                  ^^^^^^^^^^^^^^^^^^\n+help: consider specifying the type of the closure parameters\n+   |\n+LL |     let f = |x: &_, y: &_| ();\n+   |             ~~~~~~~~~~~~~~\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/issue-105675.rs:11:5\n+   |\n+LL |     thing(f);\n+   |     ^^^^^^^^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: closure with signature `fn(&'2 u32, &u32)` must implement `FnOnce<(&'1 u32, &u32)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 u32, &u32)>`, for some specific lifetime `'2`\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/issue-105675.rs:11:5\n+   |\n+LL |     thing(f);\n+   |     ^^^^^^^^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: closure with signature `fn(&u32, &'2 u32)` must implement `FnOnce<(&u32, &'1 u32)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&u32, &'2 u32)>`, for some specific lifetime `'2`\n+\n+error: aborting due to 8 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "209f2b7b7398ab389a8c637dc92c1776c598afc3", "filename": "tests/ui/lifetimes/issue-79187.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c11a688f38a979e789fa50592088654ed56680/tests%2Fui%2Flifetimes%2Fissue-79187.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/54c11a688f38a979e789fa50592088654ed56680/tests%2Fui%2Flifetimes%2Fissue-79187.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes%2Fissue-79187.stderr?ref=54c11a688f38a979e789fa50592088654ed56680", "patch": "@@ -16,7 +16,7 @@ note: the lifetime requirement is introduced here\n    |\n LL | fn thing(x: impl FnOnce(&u32)) {}\n    |                  ^^^^^^^^^^^^\n-help: consider changing the type of the closure parameters\n+help: consider specifying the type of the closure parameters\n    |\n LL |     let f = |_: &_| ();\n    |             ~~~~~~~"}, {"sha": "c5b8270ba84d57534260069e5353b8d39171c0e2", "filename": "tests/ui/mismatched_types/closure-mismatch.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54c11a688f38a979e789fa50592088654ed56680/tests%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/54c11a688f38a979e789fa50592088654ed56680/tests%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr?ref=54c11a688f38a979e789fa50592088654ed56680", "patch": "@@ -25,7 +25,7 @@ note: the lifetime requirement is introduced here\n    |\n LL | fn baz<T: Foo>(_: T) {}\n    |           ^^^\n-help: consider changing the type of the closure parameters\n+help: consider specifying the type of the closure parameters\n    |\n LL |     baz(|_: &_| ());\n    |         ~~~~~~~\n@@ -57,9 +57,9 @@ note: the lifetime requirement is introduced here\n    |\n LL | fn baz<T: Foo>(_: T) {}\n    |           ^^^\n-help: consider changing the type of the closure parameters\n+help: consider specifying the type of the closure parameters\n    |\n-LL |     baz(|_: &_| ());\n+LL |     baz(|x: &_| ());\n    |         ~~~~~~~\n \n error: aborting due to 4 previous errors"}]}