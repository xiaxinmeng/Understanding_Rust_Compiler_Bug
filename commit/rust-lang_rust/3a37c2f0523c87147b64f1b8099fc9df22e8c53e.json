{"sha": "3a37c2f0523c87147b64f1b8099fc9df22e8c53e", "node_id": "C_kwDOAAsO6NoAKDNhMzdjMmYwNTIzYzg3MTQ3YjY0ZjFiODA5OWZjOWRmMjJlOGM1M2U", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-09T15:16:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-09T15:16:17Z"}, "message": "Auto merge of #111371 - compiler-errors:revert-110907, r=petrochenkov\n\nRevert \"Populate effective visibilities in `rustc_privacy`\"\n\nThis reverts commit cff85f22f5030fbe7266d272da74a9e76160523c, cc #110907. It needs to be fixed, but there are too many issues being reported that I wanted to put up a revert until a proper fix can be committed.\n\nFixes a ton of issues where private but still reachable impls were missing during codegen:\nFixes #111320\nFixes #111321\nFixes #111334\nFixes #111357\nFixes #111368\nFixes #111373\nFixes #111377\nFixes #111386\nFixes #111387\n\n`@bors` p=1\n\nr? `@petrochenkov`", "tree": {"sha": "bb57c2964b8ea32fccfd6128f53bec8d9d63f28c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb57c2964b8ea32fccfd6128f53bec8d9d63f28c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a37c2f0523c87147b64f1b8099fc9df22e8c53e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a37c2f0523c87147b64f1b8099fc9df22e8c53e", "html_url": "https://github.com/rust-lang/rust/commit/3a37c2f0523c87147b64f1b8099fc9df22e8c53e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a37c2f0523c87147b64f1b8099fc9df22e8c53e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7b831ac8a897273f78b9f47165cf8e54066ce4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7b831ac8a897273f78b9f47165cf8e54066ce4b", "html_url": "https://github.com/rust-lang/rust/commit/f7b831ac8a897273f78b9f47165cf8e54066ce4b"}, {"sha": "5fcf2e6edc07e38e24201146be9fb58fe6cd72a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fcf2e6edc07e38e24201146be9fb58fe6cd72a0", "html_url": "https://github.com/rust-lang/rust/commit/5fcf2e6edc07e38e24201146be9fb58fe6cd72a0"}], "stats": {"total": 359, "additions": 178, "deletions": 181}, "files": [{"sha": "967fed687b6a8de21f9d27c20d5c695766314fe4", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3a37c2f0523c87147b64f1b8099fc9df22e8c53e/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a37c2f0523c87147b64f1b8099fc9df22e8c53e/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=3a37c2f0523c87147b64f1b8099fc9df22e8c53e", "patch": "@@ -64,26 +64,14 @@ impl EffectiveVisibility {\n         self.at_level(level).is_public()\n     }\n \n-    pub const fn from_vis(vis: Visibility) -> EffectiveVisibility {\n+    pub fn from_vis(vis: Visibility) -> EffectiveVisibility {\n         EffectiveVisibility {\n             direct: vis,\n             reexported: vis,\n             reachable: vis,\n             reachable_through_impl_trait: vis,\n         }\n     }\n-\n-    #[must_use]\n-    pub fn min(mut self, lhs: EffectiveVisibility, tcx: TyCtxt<'_>) -> Self {\n-        for l in Level::all_levels() {\n-            let rhs_vis = self.at_level_mut(l);\n-            let lhs_vis = *lhs.at_level(l);\n-            if rhs_vis.is_at_least(lhs_vis, tcx) {\n-                *rhs_vis = lhs_vis;\n-            };\n-        }\n-        self\n-    }\n }\n \n /// Holds a map of effective visibilities for reachable HIR nodes.\n@@ -149,6 +137,24 @@ impl EffectiveVisibilities {\n         };\n     }\n \n+    pub fn set_public_at_level(\n+        &mut self,\n+        id: LocalDefId,\n+        lazy_private_vis: impl FnOnce() -> Visibility,\n+        level: Level,\n+    ) {\n+        let mut effective_vis = self\n+            .effective_vis(id)\n+            .copied()\n+            .unwrap_or_else(|| EffectiveVisibility::from_vis(lazy_private_vis()));\n+        for l in Level::all_levels() {\n+            if l <= level {\n+                *effective_vis.at_level_mut(l) = Visibility::Public;\n+            }\n+        }\n+        self.map.insert(id, effective_vis);\n+    }\n+\n     pub fn check_invariants(&self, tcx: TyCtxt<'_>, early: bool) {\n         if !cfg!(debug_assertions) {\n             return;\n@@ -213,7 +219,7 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n     pub fn update(\n         &mut self,\n         id: Id,\n-        nominal_vis: Option<Visibility>,\n+        nominal_vis: Visibility,\n         lazy_private_vis: impl FnOnce() -> Visibility,\n         inherited_effective_vis: EffectiveVisibility,\n         level: Level,\n@@ -237,11 +243,12 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n                 if !(inherited_effective_vis_at_prev_level == inherited_effective_vis_at_level\n                     && level != l)\n                 {\n-                    calculated_effective_vis = if let Some(nominal_vis) = nominal_vis && !nominal_vis.is_at_least(inherited_effective_vis_at_level, tcx) {\n-                        nominal_vis\n-                    } else {\n-                        inherited_effective_vis_at_level\n-                    }\n+                    calculated_effective_vis =\n+                        if nominal_vis.is_at_least(inherited_effective_vis_at_level, tcx) {\n+                            inherited_effective_vis_at_level\n+                        } else {\n+                            nominal_vis\n+                        };\n                 }\n                 // effective visibility can't be decreased at next update call for the\n                 // same id"}, {"sha": "d6eb5463870effcdc23efddef75926bd5fb1cc87", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 117, "deletions": 154, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/3a37c2f0523c87147b64f1b8099fc9df22e8c53e/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a37c2f0523c87147b64f1b8099fc9df22e8c53e/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=3a37c2f0523c87147b64f1b8099fc9df22e8c53e", "patch": "@@ -25,7 +25,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{AssocItemKind, HirIdSet, ItemId, Node, PatKind};\n use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::privacy::{EffectiveVisibilities, EffectiveVisibility, Level};\n+use rustc_middle::middle::privacy::{EffectiveVisibilities, Level};\n use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::InternalSubsts;\n@@ -38,7 +38,7 @@ use rustc_span::Span;\n \n use std::marker::PhantomData;\n use std::ops::ControlFlow;\n-use std::{fmt, mem};\n+use std::{cmp, fmt, mem};\n \n use errors::{\n     FieldIsPrivate, FieldIsPrivateLabel, FromPrivateDependencyInPublicInterface, InPublicInterface,\n@@ -408,9 +408,8 @@ impl VisibilityLike for ty::Visibility {\n         min(find.tcx.local_visibility(def_id), find.min, find.tcx)\n     }\n }\n-\n-impl VisibilityLike for Option<EffectiveVisibility> {\n-    const MAX: Self = Some(EffectiveVisibility::from_vis(ty::Visibility::Public));\n+impl VisibilityLike for Option<Level> {\n+    const MAX: Self = Some(Level::Direct);\n     // Type inference is very smart sometimes.\n     // It can make an impl reachable even some components of its type or trait are unreachable.\n     // E.g. methods of `impl ReachableTrait<UnreachableTy> for ReachableTy<UnreachableTy> { ... }`\n@@ -422,13 +421,7 @@ impl VisibilityLike for Option<EffectiveVisibility> {\n     // (which require reaching the `DefId`s in them).\n     const SHALLOW: bool = true;\n     fn new_min(find: &FindMin<'_, '_, Self>, def_id: LocalDefId) -> Self {\n-        if let Some(min) = find.min {\n-            return find\n-                .effective_visibilities\n-                .effective_vis(def_id)\n-                .map(|eff_vis| min.min(*eff_vis, find.tcx));\n-        }\n-        None\n+        cmp::min(find.effective_visibilities.public_at_level(def_id), find.min)\n     }\n }\n \n@@ -454,79 +447,49 @@ struct EmbargoVisitor<'tcx> {\n     ///     n::p::f()\n     /// }\n     macro_reachable: FxHashSet<(LocalDefId, LocalDefId)>,\n+    /// Previous visibility level; `None` means unreachable.\n+    prev_level: Option<Level>,\n     /// Has something changed in the level map?\n     changed: bool,\n }\n \n struct ReachEverythingInTheInterfaceVisitor<'a, 'tcx> {\n-    effective_vis: Option<EffectiveVisibility>,\n+    level: Option<Level>,\n     item_def_id: LocalDefId,\n     ev: &'a mut EmbargoVisitor<'tcx>,\n-    level: Level,\n }\n \n impl<'tcx> EmbargoVisitor<'tcx> {\n-    fn get(&self, def_id: LocalDefId) -> Option<EffectiveVisibility> {\n-        self.effective_visibilities.effective_vis(def_id).copied()\n-    }\n-\n-    // Updates node effective visibility.\n-    fn update(\n-        &mut self,\n-        def_id: LocalDefId,\n-        inherited_effective_vis: Option<EffectiveVisibility>,\n-        level: Level,\n-    ) {\n-        let nominal_vis = self.tcx.local_visibility(def_id);\n-        self.update_eff_vis(def_id, inherited_effective_vis, Some(nominal_vis), level);\n-    }\n-\n-    fn update_eff_vis(\n-        &mut self,\n-        def_id: LocalDefId,\n-        inherited_effective_vis: Option<EffectiveVisibility>,\n-        nominal_vis: Option<ty::Visibility>,\n-        level: Level,\n-    ) {\n-        if let Some(inherited_effective_vis) = inherited_effective_vis {\n-            let private_vis =\n-                ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id));\n-            if Some(private_vis) != nominal_vis {\n-                self.changed |= self.effective_visibilities.update(\n-                    def_id,\n-                    nominal_vis,\n-                    || private_vis,\n-                    inherited_effective_vis,\n-                    level,\n-                    self.tcx,\n-                );\n-            }\n+    fn get(&self, def_id: LocalDefId) -> Option<Level> {\n+        self.effective_visibilities.public_at_level(def_id)\n+    }\n+\n+    /// Updates node level and returns the updated level.\n+    fn update(&mut self, def_id: LocalDefId, level: Option<Level>) -> Option<Level> {\n+        let old_level = self.get(def_id);\n+        // Visibility levels can only grow.\n+        if level > old_level {\n+            self.effective_visibilities.set_public_at_level(\n+                def_id,\n+                || ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id)),\n+                level.unwrap(),\n+            );\n+            self.changed = true;\n+            level\n+        } else {\n+            old_level\n         }\n     }\n \n     fn reach(\n         &mut self,\n         def_id: LocalDefId,\n-        effective_vis: Option<EffectiveVisibility>,\n+        level: Option<Level>,\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n-            effective_vis,\n+            level: cmp::min(level, Some(Level::Reachable)),\n             item_def_id: def_id,\n             ev: self,\n-            level: Level::Reachable,\n-        }\n-    }\n-\n-    fn reach_through_impl_trait(\n-        &mut self,\n-        def_id: LocalDefId,\n-        effective_vis: Option<EffectiveVisibility>,\n-    ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n-        ReachEverythingInTheInterfaceVisitor {\n-            effective_vis,\n-            item_def_id: def_id,\n-            ev: self,\n-            level: Level::ReachableThroughImplTrait,\n         }\n     }\n \n@@ -547,18 +510,16 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             return;\n         }\n \n-        if self.effective_visibilities.public_at_level(local_def_id).is_none() {\n+        if self.get(local_def_id).is_none() {\n             return;\n         }\n \n         // Since we are starting from an externally visible module,\n         // all the parents in the loop below are also guaranteed to be modules.\n         let mut module_def_id = macro_module_def_id;\n-        let macro_ev = self.get(local_def_id);\n-        assert!(macro_ev.is_some());\n         loop {\n             let changed_reachability =\n-                self.update_macro_reachable(module_def_id, macro_module_def_id, macro_ev);\n+                self.update_macro_reachable(module_def_id, macro_module_def_id);\n             if changed_reachability || module_def_id == CRATE_DEF_ID {\n                 break;\n             }\n@@ -572,33 +533,21 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         &mut self,\n         module_def_id: LocalDefId,\n         defining_mod: LocalDefId,\n-        macro_ev: Option<EffectiveVisibility>,\n     ) -> bool {\n         if self.macro_reachable.insert((module_def_id, defining_mod)) {\n-            self.update_macro_reachable_mod(module_def_id, defining_mod, macro_ev);\n+            self.update_macro_reachable_mod(module_def_id, defining_mod);\n             true\n         } else {\n             false\n         }\n     }\n \n-    fn update_macro_reachable_mod(\n-        &mut self,\n-        module_def_id: LocalDefId,\n-        defining_mod: LocalDefId,\n-        macro_ev: Option<EffectiveVisibility>,\n-    ) {\n+    fn update_macro_reachable_mod(&mut self, module_def_id: LocalDefId, defining_mod: LocalDefId) {\n         let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in module.item_ids {\n             let def_kind = self.tcx.def_kind(item_id.owner_id);\n             let vis = self.tcx.local_visibility(item_id.owner_id.def_id);\n-            self.update_macro_reachable_def(\n-                item_id.owner_id.def_id,\n-                def_kind,\n-                vis,\n-                defining_mod,\n-                macro_ev,\n-            );\n+            self.update_macro_reachable_def(item_id.owner_id.def_id, def_kind, vis, defining_mod);\n         }\n         for child in self.tcx.module_children_local(module_def_id) {\n             // FIXME: Use module children for the logic above too.\n@@ -607,7 +556,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n                 && let Res::Def(def_kind, def_id) = child.res\n                 && let Some(def_id) = def_id.as_local() {\n                 let vis = self.tcx.local_visibility(def_id);\n-                self.update_macro_reachable_def(def_id, def_kind, vis, defining_mod, macro_ev);\n+                self.update_macro_reachable_def(def_id, def_kind, vis, defining_mod);\n             }\n         }\n     }\n@@ -618,14 +567,16 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         def_kind: DefKind,\n         vis: ty::Visibility,\n         module: LocalDefId,\n-        macro_ev: Option<EffectiveVisibility>,\n     ) {\n-        self.update(def_id, macro_ev, Level::Reachable);\n+        let level = Some(Level::Reachable);\n+        if vis.is_public() {\n+            self.update(def_id, level);\n+        }\n         match def_kind {\n             // No type privacy, so can be directly marked as reachable.\n             DefKind::Const | DefKind::Static(_) | DefKind::TraitAlias | DefKind::TyAlias => {\n                 if vis.is_accessible_from(module, self.tcx) {\n-                    self.update(def_id, macro_ev, Level::Reachable);\n+                    self.update(def_id, level);\n                 }\n             }\n \n@@ -637,7 +588,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n                 let item = self.tcx.hir().expect_item(def_id);\n                 if let hir::ItemKind::Macro(MacroDef { macro_rules: false, .. }, _) = item.kind {\n                     if vis.is_accessible_from(module, self.tcx) {\n-                        self.update(def_id, macro_ev, Level::Reachable);\n+                        self.update(def_id, level);\n                     }\n                 }\n             }\n@@ -648,24 +599,26 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             // the module, however may be reachable.\n             DefKind::Mod => {\n                 if vis.is_accessible_from(module, self.tcx) {\n-                    self.update_macro_reachable(def_id, module, macro_ev);\n+                    self.update_macro_reachable(def_id, module);\n                 }\n             }\n \n             DefKind::Struct | DefKind::Union => {\n                 // While structs and unions have type privacy, their fields do not.\n-                let item = self.tcx.hir().expect_item(def_id);\n-                if let hir::ItemKind::Struct(ref struct_def, _)\n-                | hir::ItemKind::Union(ref struct_def, _) = item.kind\n-                {\n-                    for field in struct_def.fields() {\n-                        let field_vis = self.tcx.local_visibility(field.def_id);\n-                        if field_vis.is_accessible_from(module, self.tcx) {\n-                            self.reach(field.def_id, macro_ev).ty();\n+                if vis.is_public() {\n+                    let item = self.tcx.hir().expect_item(def_id);\n+                    if let hir::ItemKind::Struct(ref struct_def, _)\n+                    | hir::ItemKind::Union(ref struct_def, _) = item.kind\n+                    {\n+                        for field in struct_def.fields() {\n+                            let field_vis = self.tcx.local_visibility(field.def_id);\n+                            if field_vis.is_accessible_from(module, self.tcx) {\n+                                self.reach(field.def_id, level).ty();\n+                            }\n                         }\n+                    } else {\n+                        bug!(\"item {:?} with DefKind {:?}\", item, def_kind);\n                     }\n-                } else {\n-                    bug!(\"item {:?} with DefKind {:?}\", item, def_kind);\n                 }\n             }\n \n@@ -709,16 +662,14 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let item_ev = match item.kind {\n+        let item_level = match item.kind {\n             hir::ItemKind::Impl { .. } => {\n-                let impl_ev = Option::<EffectiveVisibility>::of_impl(\n+                let impl_level = Option::<Level>::of_impl(\n                     item.owner_id.def_id,\n                     self.tcx,\n                     &self.effective_visibilities,\n                 );\n-\n-                self.update_eff_vis(item.owner_id.def_id, impl_ev, None, Level::Direct);\n-                impl_ev\n+                self.update(item.owner_id.def_id, impl_level)\n             }\n             _ => self.get(item.owner_id.def_id),\n         };\n@@ -727,40 +678,48 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         match item.kind {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in def.variants {\n-                    self.update(variant.def_id, item_ev, Level::Reachable);\n-                    let variant_ev = self.get(variant.def_id);\n+                    let variant_level = self.update(variant.def_id, item_level);\n                     if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n-                        self.update(ctor_def_id, variant_ev, Level::Reachable);\n+                        self.update(ctor_def_id, item_level);\n                     }\n                     for field in variant.data.fields() {\n-                        self.update(field.def_id, variant_ev, Level::Reachable);\n+                        self.update(field.def_id, variant_level);\n                     }\n                 }\n             }\n             hir::ItemKind::Impl(ref impl_) => {\n                 for impl_item_ref in impl_.items {\n-                    self.update(impl_item_ref.id.owner_id.def_id, item_ev, Level::Direct);\n+                    if impl_.of_trait.is_some()\n+                        || self.tcx.visibility(impl_item_ref.id.owner_id).is_public()\n+                    {\n+                        self.update(impl_item_ref.id.owner_id.def_id, item_level);\n+                    }\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n-                    self.update(trait_item_ref.id.owner_id.def_id, item_ev, Level::Reachable);\n+                    self.update(trait_item_ref.id.owner_id.def_id, item_level);\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n                 if let Some(ctor_def_id) = def.ctor_def_id() {\n-                    self.update(ctor_def_id, item_ev, Level::Reachable);\n+                    self.update(ctor_def_id, item_level);\n                 }\n                 for field in def.fields() {\n-                    self.update(field.def_id, item_ev, Level::Reachable);\n+                    let vis = self.tcx.visibility(field.def_id);\n+                    if vis.is_public() {\n+                        self.update(field.def_id, item_level);\n+                    }\n                 }\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n                 self.update_reachability_from_macro(item.owner_id.def_id, macro_def);\n             }\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    self.update(foreign_item.id.owner_id.def_id, item_ev, Level::Reachable);\n+                    if self.tcx.visibility(foreign_item.id.owner_id).is_public() {\n+                        self.update(foreign_item.id.owner_id.def_id, item_level);\n+                    }\n                 }\n             }\n \n@@ -795,30 +754,26 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     // FIXME: This is some serious pessimization intended to workaround deficiencies\n                     // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n                     // reachable if they are returned via `impl Trait`, even from private functions.\n-                    let exist_ev = Some(EffectiveVisibility::from_vis(ty::Visibility::Public));\n-                    self.reach_through_impl_trait(item.owner_id.def_id, exist_ev)\n-                        .generics()\n-                        .predicates()\n-                        .ty();\n+                    let exist_level = cmp::max(item_level, Some(Level::ReachableThroughImplTrait));\n+                    self.reach(item.owner_id.def_id, exist_level).generics().predicates().ty();\n                 }\n             }\n             // Visit everything.\n             hir::ItemKind::Const(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n-                if item_ev.is_some() {\n-                    self.reach(item.owner_id.def_id, item_ev).generics().predicates().ty();\n+                if item_level.is_some() {\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n-                if item_ev.is_some() {\n-                    self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n+                if item_level.is_some() {\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n                         let tcx = self.tcx;\n-                        let mut reach = self.reach(trait_item_ref.id.owner_id.def_id, item_ev);\n-\n+                        let mut reach = self.reach(trait_item_ref.id.owner_id.def_id, item_level);\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == AssocItemKind::Type\n@@ -832,24 +787,23 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n-                if item_ev.is_some() {\n-                    self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n+                if item_level.is_some() {\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n-                if item_ev.is_some() {\n-                    self.reach(item.owner_id.def_id, item_ev)\n+                if item_level.is_some() {\n+                    self.reach(item.owner_id.def_id, item_level)\n                         .generics()\n                         .predicates()\n                         .ty()\n                         .trait_ref();\n \n                     for impl_item_ref in impl_.items {\n-                        let impl_item_ev = self.get(impl_item_ref.id.owner_id.def_id);\n-\n-                        if impl_item_ev.is_some() {\n-                            self.reach(impl_item_ref.id.owner_id.def_id, impl_item_ev)\n+                        let impl_item_level = self.get(impl_item_ref.id.owner_id.def_id);\n+                        if impl_item_level.is_some() {\n+                            self.reach(impl_item_ref.id.owner_id.def_id, impl_item_level)\n                                 .generics()\n                                 .predicates()\n                                 .ty();\n@@ -860,33 +814,33 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n \n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n-                if item_ev.is_some() {\n-                    self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n+                if item_level.is_some() {\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n                 }\n                 for variant in def.variants {\n-                    let variant_ev = self.get(variant.def_id);\n-                    if variant_ev.is_some() {\n+                    let variant_level = self.get(variant.def_id);\n+                    if variant_level.is_some() {\n                         for field in variant.data.fields() {\n-                            self.reach(field.def_id, variant_ev).ty();\n+                            self.reach(field.def_id, variant_level).ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n-                        self.reach(item.owner_id.def_id, variant_ev).ty();\n+                        self.reach(item.owner_id.def_id, variant_level).ty();\n                     }\n                     if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n-                        let ctor_ev = self.get(ctor_def_id);\n-                        if ctor_ev.is_some() {\n-                            self.reach(item.owner_id.def_id, ctor_ev).ty();\n+                        let ctor_level = self.get(ctor_def_id);\n+                        if ctor_level.is_some() {\n+                            self.reach(item.owner_id.def_id, ctor_level).ty();\n                         }\n                     }\n                 }\n             }\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    let foreign_item_ev = self.get(foreign_item.id.owner_id.def_id);\n-                    if foreign_item_ev.is_some() {\n-                        self.reach(foreign_item.id.owner_id.def_id, foreign_item_ev)\n+                    let foreign_item_level = self.get(foreign_item.id.owner_id.def_id);\n+                    if foreign_item_level.is_some() {\n+                        self.reach(foreign_item.id.owner_id.def_id, foreign_item_level)\n                             .generics()\n                             .predicates()\n                             .ty();\n@@ -895,32 +849,36 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                if item_ev.is_some() {\n-                    self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n+                if item_level.is_some() {\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n                     for field in struct_def.fields() {\n-                        let field_ev = self.get(field.def_id);\n-                        if field_ev.is_some() {\n-                            self.reach(field.def_id, field_ev).ty();\n+                        let field_level = self.get(field.def_id);\n+                        if field_level.is_some() {\n+                            self.reach(field.def_id, field_level).ty();\n                         }\n                     }\n                 }\n                 if let Some(ctor_def_id) = struct_def.ctor_def_id() {\n-                    let ctor_ev = self.get(ctor_def_id);\n-                    if ctor_ev.is_some() {\n-                        self.reach(item.owner_id.def_id, ctor_ev).ty();\n+                    let ctor_level = self.get(ctor_def_id);\n+                    if ctor_level.is_some() {\n+                        self.reach(item.owner_id.def_id, ctor_level).ty();\n                     }\n                 }\n             }\n         }\n \n+        let orig_level = mem::replace(&mut self.prev_level, item_level);\n         intravisit::walk_item(self, item);\n+        self.prev_level = orig_level;\n     }\n \n     fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n         // Blocks can have public items, for example impls, but they always\n         // start as completely private regardless of publicity of a function,\n         // constant, type, field, etc., in which this block resides.\n+        let orig_level = mem::replace(&mut self.prev_level, None);\n         intravisit::walk_block(self, b);\n+        self.prev_level = orig_level;\n     }\n }\n \n@@ -974,7 +932,11 @@ impl<'tcx> DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx>\n         _descr: &dyn fmt::Display,\n     ) -> ControlFlow<Self::BreakTy> {\n         if let Some(def_id) = def_id.as_local() {\n-            self.ev.update_eff_vis(def_id, self.effective_vis, None, self.level);\n+            if let (ty::Visibility::Public, _) | (_, Some(Level::ReachableThroughImplTrait)) =\n+                (self.tcx().visibility(def_id.to_def_id()), self.level)\n+            {\n+                self.ev.update(def_id, self.level);\n+            }\n         }\n         ControlFlow::Continue(())\n     }\n@@ -2202,6 +2164,7 @@ fn effective_visibilities(tcx: TyCtxt<'_>, (): ()) -> &EffectiveVisibilities {\n         tcx,\n         effective_visibilities: tcx.resolutions(()).effective_visibilities.clone(),\n         macro_reachable: Default::default(),\n+        prev_level: Some(Level::Direct),\n         changed: false,\n     };\n "}, {"sha": "87067189a77580edd1948c21fc285203d115408e", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a37c2f0523c87147b64f1b8099fc9df22e8c53e/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a37c2f0523c87147b64f1b8099fc9df22e8c53e/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=3a37c2f0523c87147b64f1b8099fc9df22e8c53e", "patch": "@@ -199,7 +199,7 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         let tcx = self.r.tcx;\n         self.changed |= self.import_effective_visibilities.update(\n             binding,\n-            Some(nominal_vis),\n+            nominal_vis,\n             || cheap_private_vis.unwrap_or_else(|| self.r.private_vis_import(binding)),\n             inherited_eff_vis,\n             parent_id.level(),\n@@ -213,7 +213,7 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         let tcx = self.r.tcx;\n         self.changed |= self.def_effective_visibilities.update(\n             def_id,\n-            Some(nominal_vis),\n+            nominal_vis,\n             || cheap_private_vis.unwrap_or_else(|| self.r.private_vis_def(def_id)),\n             inherited_eff_vis,\n             parent_id.level(),"}, {"sha": "520ec9abcf0dcbb675756adedc40043535c8e91d", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a37c2f0523c87147b64f1b8099fc9df22e8c53e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a37c2f0523c87147b64f1b8099fc9df22e8c53e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=3a37c2f0523c87147b64f1b8099fc9df22e8c53e", "patch": "@@ -310,7 +310,6 @@ where\n /// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n /// this type.\n #[derive(Clone, Debug)]\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n struct FlattenCompat<I, U> {\n     iter: Fuse<I>,\n     frontiter: Option<U>,\n@@ -464,7 +463,6 @@ where\n     }\n }\n \n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n impl<I, U> Iterator for FlattenCompat<I, U>\n where\n     I: Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n@@ -579,7 +577,6 @@ where\n     }\n }\n \n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n where\n     I: DoubleEndedIterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n@@ -649,23 +646,20 @@ where\n     }\n }\n \n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<const N: usize, I, T> TrustedLen\n     for FlattenCompat<I, <[T; N] as IntoIterator>::IntoIter>\n where\n     I: TrustedLen<Item = [T; N]>,\n {\n }\n \n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, const N: usize, I, T> TrustedLen\n     for FlattenCompat<I, <&'a [T; N] as IntoIterator>::IntoIter>\n where\n     I: TrustedLen<Item = &'a [T; N]>,\n {\n }\n \n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, const N: usize, I, T> TrustedLen\n     for FlattenCompat<I, <&'a mut [T; N] as IntoIterator>::IntoIter>\n where"}, {"sha": "10dc0861461393aca28b611be970c4e48ac771d8", "filename": "tests/ui/reachable/auxiliary/foreign-priv-aux.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3a37c2f0523c87147b64f1b8099fc9df22e8c53e/tests%2Fui%2Freachable%2Fauxiliary%2Fforeign-priv-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a37c2f0523c87147b64f1b8099fc9df22e8c53e/tests%2Fui%2Freachable%2Fauxiliary%2Fforeign-priv-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freachable%2Fauxiliary%2Fforeign-priv-aux.rs?ref=3a37c2f0523c87147b64f1b8099fc9df22e8c53e", "patch": "@@ -0,0 +1,21 @@\n+trait PrivTrait {\n+    fn priv_fn(&self);\n+}\n+\n+pub struct ImplPrivTrait;\n+\n+impl PrivTrait for ImplPrivTrait {\n+    fn priv_fn(&self) {}\n+}\n+\n+pub struct Wrapper<T>(T);\n+\n+pub trait PubTrait {\n+    fn pub_fn(&self);\n+}\n+\n+impl<T: PrivTrait> PubTrait for Wrapper<T> {\n+    fn pub_fn(&self) {\n+        self.0.priv_fn()\n+    }\n+}"}, {"sha": "bf336b6be7ab6cffd8a34bfad4522950cbb148d6", "filename": "tests/ui/reachable/foreign-priv.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3a37c2f0523c87147b64f1b8099fc9df22e8c53e/tests%2Fui%2Freachable%2Fforeign-priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a37c2f0523c87147b64f1b8099fc9df22e8c53e/tests%2Fui%2Freachable%2Fforeign-priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freachable%2Fforeign-priv.rs?ref=3a37c2f0523c87147b64f1b8099fc9df22e8c53e", "patch": "@@ -0,0 +1,12 @@\n+// aux-build:foreign-priv-aux.rs\n+// build-pass\n+\n+#![crate_type = \"lib\"]\n+\n+extern crate foreign_priv_aux;\n+\n+use foreign_priv_aux::{ImplPrivTrait, PubTrait, Wrapper};\n+\n+pub fn foo(x: Wrapper<ImplPrivTrait>) {\n+    x.pub_fn();\n+}"}]}