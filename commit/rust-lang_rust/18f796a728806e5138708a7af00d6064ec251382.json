{"sha": "18f796a728806e5138708a7af00d6064ec251382", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4Zjc5NmE3Mjg4MDZlNTEzODcwOGE3YWYwMGQ2MDY0ZWMyNTEzODI=", "commit": {"author": {"name": "Joshua Warner", "email": "joshuawarner32@gmail.com", "date": "2021-06-05T22:29:29Z"}, "committer": {"name": "Joshua Warner", "email": "joshuawarner32@gmail.com", "date": "2021-06-05T22:29:29Z"}, "message": "Refactor to be just one assist", "tree": {"sha": "bfbdb2c523b82928d17d918fc1a6dbbb616c54b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfbdb2c523b82928d17d918fc1a6dbbb616c54b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18f796a728806e5138708a7af00d6064ec251382", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18f796a728806e5138708a7af00d6064ec251382", "html_url": "https://github.com/rust-lang/rust/commit/18f796a728806e5138708a7af00d6064ec251382", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18f796a728806e5138708a7af00d6064ec251382/comments", "author": {"login": "joshuawarner32", "id": 182686, "node_id": "MDQ6VXNlcjE4MjY4Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/182686?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joshuawarner32", "html_url": "https://github.com/joshuawarner32", "followers_url": "https://api.github.com/users/joshuawarner32/followers", "following_url": "https://api.github.com/users/joshuawarner32/following{/other_user}", "gists_url": "https://api.github.com/users/joshuawarner32/gists{/gist_id}", "starred_url": "https://api.github.com/users/joshuawarner32/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joshuawarner32/subscriptions", "organizations_url": "https://api.github.com/users/joshuawarner32/orgs", "repos_url": "https://api.github.com/users/joshuawarner32/repos", "events_url": "https://api.github.com/users/joshuawarner32/events{/privacy}", "received_events_url": "https://api.github.com/users/joshuawarner32/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joshuawarner32", "id": 182686, "node_id": "MDQ6VXNlcjE4MjY4Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/182686?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joshuawarner32", "html_url": "https://github.com/joshuawarner32", "followers_url": "https://api.github.com/users/joshuawarner32/followers", "following_url": "https://api.github.com/users/joshuawarner32/following{/other_user}", "gists_url": "https://api.github.com/users/joshuawarner32/gists{/gist_id}", "starred_url": "https://api.github.com/users/joshuawarner32/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joshuawarner32/subscriptions", "organizations_url": "https://api.github.com/users/joshuawarner32/orgs", "repos_url": "https://api.github.com/users/joshuawarner32/repos", "events_url": "https://api.github.com/users/joshuawarner32/events{/privacy}", "received_events_url": "https://api.github.com/users/joshuawarner32/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca9ffba0473cb32b06c01bc5d387e538d379f19e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca9ffba0473cb32b06c01bc5d387e538d379f19e", "html_url": "https://github.com/rust-lang/rust/commit/ca9ffba0473cb32b06c01bc5d387e538d379f19e"}], "stats": {"total": 860, "additions": 328, "deletions": 532}, "files": [{"sha": "53709e31fbf13d0ec8c5c96fc09ff1b6ebdcdad6", "filename": "crates/ide_assists/src/handlers/convert_tuple_struct_to_named_struct.rs", "status": "modified", "additions": 328, "deletions": 15, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/18f796a728806e5138708a7af00d6064ec251382/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f796a728806e5138708a7af00d6064ec251382/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs?ref=18f796a728806e5138708a7af00d6064ec251382", "patch": "@@ -1,3 +1,4 @@\n+use either::Either;\n use ide_db::defs::{Definition, NameRefClass};\n use syntax::{\n     ast::{self, AstNode, GenericParamsOwner, VisibilityOwner},\n@@ -8,7 +9,7 @@ use crate::{assist_context::AssistBuilder, AssistContext, AssistId, AssistKind,\n \n // Assist: convert_tuple_struct_to_named_struct\n //\n-// Converts tuple struct to struct with named fields.\n+// Converts tuple struct to struct with named fields, and analogously for tuple enum variants.\n //\n // ```\n // struct Point$0(f32, f32);\n@@ -49,14 +50,21 @@ pub(crate) fn convert_tuple_struct_to_named_struct(\n     acc: &mut Assists,\n     ctx: &AssistContext,\n ) -> Option<()> {\n-    let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n-    let tuple_fields = match strukt.field_list()? {\n+    let strukt = ctx\n+        .find_node_at_offset::<ast::Struct>()\n+        .map(Either::Left)\n+        .or_else(|| ctx.find_node_at_offset::<ast::Variant>().map(Either::Right))?;\n+    let field_list = strukt.as_ref().either(|s| s.field_list(), |v| v.field_list())?;\n+    let tuple_fields = match field_list {\n         ast::FieldList::TupleFieldList(it) => it,\n         ast::FieldList::RecordFieldList(_) => return None,\n     };\n-    let strukt_def = ctx.sema.to_def(&strukt)?;\n+    let strukt_def = match &strukt {\n+        Either::Left(s) => Either::Left(ctx.sema.to_def(s)?),\n+        Either::Right(v) => Either::Right(ctx.sema.to_def(v)?),\n+    };\n+    let target = strukt.as_ref().either(|s| s.syntax(), |v| v.syntax()).text_range();\n \n-    let target = strukt.syntax().text_range();\n     acc.add(\n         AssistId(\"convert_tuple_struct_to_named_struct\", AssistKind::RefactorRewrite),\n         \"Convert to named struct\",\n@@ -73,7 +81,7 @@ pub(crate) fn convert_tuple_struct_to_named_struct(\n fn edit_struct_def(\n     ctx: &AssistContext,\n     edit: &mut AssistBuilder,\n-    strukt: &ast::Struct,\n+    strukt: &Either<ast::Struct, ast::Variant>,\n     tuple_fields: ast::TupleFieldList,\n     names: Vec<ast::Name>,\n ) {\n@@ -86,27 +94,34 @@ fn edit_struct_def(\n \n     edit.edit_file(ctx.frange.file_id);\n \n-    if let Some(w) = strukt.where_clause() {\n-        edit.delete(w.syntax().text_range());\n-        edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_newline().text());\n-        edit.insert(tuple_fields_text_range.start(), w.syntax().text());\n-        edit.insert(tuple_fields_text_range.start(), \",\");\n-        edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_newline().text());\n+    if let Either::Left(strukt) = strukt {\n+        if let Some(w) = strukt.where_clause() {\n+            edit.delete(w.syntax().text_range());\n+            edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_newline().text());\n+            edit.insert(tuple_fields_text_range.start(), w.syntax().text());\n+            edit.insert(tuple_fields_text_range.start(), \",\");\n+            edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_newline().text());\n+        } else {\n+            edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_space().text());\n+        }\n+        strukt.semicolon_token().map(|t| edit.delete(t.text_range()));\n     } else {\n         edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_space().text());\n     }\n \n     edit.replace(tuple_fields_text_range, record_fields.to_string());\n-    strukt.semicolon_token().map(|t| edit.delete(t.text_range()));\n }\n \n fn edit_struct_references(\n     ctx: &AssistContext,\n     edit: &mut AssistBuilder,\n-    strukt: hir::Struct,\n+    strukt: Either<hir::Struct, hir::Variant>,\n     names: &[ast::Name],\n ) {\n-    let strukt_def = Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(strukt)));\n+    let strukt_def = match strukt {\n+        Either::Left(s) => Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(s))),\n+        Either::Right(v) => Definition::ModuleDef(hir::ModuleDef::Variant(v)),\n+    };\n     let usages = strukt_def.usages(&ctx.sema).include_self_refs().all();\n \n     let edit_node = |edit: &mut AssistBuilder, node: SyntaxNode| -> Option<()> {\n@@ -510,6 +525,304 @@ where\n     T: Display,\n { field1: T }\n \n+\"#,\n+        );\n+    }\n+    #[test]\n+    fn not_applicable_other_than_tuple_variant() {\n+        check_assist_not_applicable(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"enum Enum { Variant$0 { value: usize } };\"#,\n+        );\n+        check_assist_not_applicable(convert_tuple_struct_to_named_struct, r#\"enum Enum { Variant$0 }\"#);\n+    }\n+\n+    #[test]\n+    fn convert_simple_variant() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+enum A {\n+    $0Variant(usize),\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        A::Variant(value)\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            A::Variant(value) => value,\n+        }\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        A::Variant { field1: value }\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            A::Variant { field1: value } => value,\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_referenced_via_self_kw() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+enum A {\n+    $0Variant(usize),\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        Self::Variant(value)\n+    }\n+\n+    fn new_with_default() -> A {\n+        Self::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            Self::Variant(value) => value,\n+        }\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        Self::Variant { field1: value }\n+    }\n+\n+    fn new_with_default() -> A {\n+        Self::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            Self::Variant { field1: value } => value,\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_destructured_variant() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+enum A {\n+    $0Variant(usize),\n+}\n+\n+impl A {\n+    fn into_inner(self) -> usize {\n+        let A::Variant(first) = self;\n+        first\n+    }\n+\n+    fn into_inner_via_self(self) -> usize {\n+        let Self::Variant(first) = self;\n+        first\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn into_inner(self) -> usize {\n+        let A::Variant { field1: first } = self;\n+        first\n+    }\n+\n+    fn into_inner_via_self(self) -> usize {\n+        let Self::Variant { field1: first } = self;\n+        first\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_with_wrapped_references() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+enum Inner {\n+    $0Variant(usize),\n+}\n+enum Outer {\n+    Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant(42))\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant(x)) = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+enum Inner {\n+    Variant { field1: usize },\n+}\n+enum Outer {\n+    Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant { field1: 42 })\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant { field1: x }) = self;\n+        x\n+    }\n+}\"#,\n+        );\n+\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+enum Inner {\n+    Variant(usize),\n+}\n+enum Outer {\n+    $0Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant(42))\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant(x)) = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+enum Inner {\n+    Variant(usize),\n+}\n+enum Outer {\n+    Variant { field1: Inner },\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant { field1: Inner::Variant(42) }\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant { field1: Inner::Variant(x) } = self;\n+        x\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_with_multi_file_references() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    $0Variant(Inner),\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A::Variant(Inner);\n+}\n+\"#,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    Variant { field1: Inner },\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A::Variant { field1: Inner };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_directly_used_variant() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    $0Variant(Inner),\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A::Variant, Inner};\n+fn f() {\n+    let a = Variant(Inner);\n+}\n+\"#,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    Variant { field1: Inner },\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A::Variant, Inner};\n+fn f() {\n+    let a = Variant { field1: Inner };\n+}\n \"#,\n         );\n     }"}, {"sha": "586ad9809f504f53e66ecbd39685001ff21033f9", "filename": "crates/ide_assists/src/handlers/convert_tuple_variant_to_named_variant.rs", "status": "removed", "additions": 0, "deletions": 515, "changes": 515, "blob_url": "https://github.com/rust-lang/rust/blob/ca9ffba0473cb32b06c01bc5d387e538d379f19e/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_variant_to_named_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca9ffba0473cb32b06c01bc5d387e538d379f19e/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_variant_to_named_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_variant_to_named_variant.rs?ref=ca9ffba0473cb32b06c01bc5d387e538d379f19e", "patch": "@@ -1,515 +0,0 @@\n-use ide_db::defs::{Definition, NameRefClass};\n-use syntax::{\n-    ast::{self, AstNode, VisibilityOwner},\n-    match_ast, SyntaxNode,\n-};\n-\n-use crate::{assist_context::AssistBuilder, AssistContext, AssistId, AssistKind, Assists};\n-\n-// Assist: convert_tuple_variant_to_named_variant\n-//\n-// Converts tuple variant to variant with named fields.\n-//\n-// ```\n-// enum A {\n-//     Variant(usize),\n-// }\n-//\n-// impl A {\n-//     fn new(value: usize) -> A {\n-//         A::Variant(value)\n-//     }\n-//\n-//     fn new_with_default() -> A {\n-//         A::new(Default::default())\n-//     }\n-//\n-//     fn value(self) -> usize {\n-//         match self {\n-//             A::Variant(value) => value,\n-//         }\n-//     }\n-// }\n-// ```\n-// ->\n-// ```\n-// enum A {\n-//     Variant {\n-//         field1: usize\n-//     },\n-// }\n-//\n-// impl A {\n-//     fn new(value: usize) -> A {\n-//         A::Variant {\n-//             field1: value,\n-//         }\n-//     }\n-//\n-//     fn new_with_default() -> A {\n-//         A::new(Default::default())\n-//     }\n-//\n-//     fn value(self) -> usize {\n-//         match self {\n-//             A::Variant { field1: value } => value,\n-//         }\n-//     }\n-// }\n-// ```\n-pub(crate) fn convert_tuple_variant_to_named_variant(\n-    acc: &mut Assists,\n-    ctx: &AssistContext,\n-) -> Option<()> {\n-    let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n-    let tuple_fields = match variant.field_list()? {\n-        ast::FieldList::TupleFieldList(it) => it,\n-        ast::FieldList::RecordFieldList(_) => return None,\n-    };\n-    let variant_def = ctx.sema.to_def(&variant)?;\n-\n-    let target = variant.syntax().text_range();\n-    acc.add(\n-        AssistId(\"convert_tuple_variant_to_named_variant\", AssistKind::RefactorRewrite),\n-        \"Convert to named struct\",\n-        target,\n-        |edit| {\n-            let names = generate_names(tuple_fields.fields());\n-            edit_field_references(ctx, edit, tuple_fields.fields(), &names); // TODO: is this needed?\n-            edit_variant_references(ctx, edit, variant_def, &names);\n-            edit_variant_def(ctx, edit, tuple_fields, names);\n-        },\n-    )\n-}\n-\n-fn edit_variant_def(\n-    ctx: &AssistContext,\n-    edit: &mut AssistBuilder,\n-    tuple_fields: ast::TupleFieldList,\n-    names: Vec<ast::Name>,\n-) {\n-    let record_fields = tuple_fields\n-        .fields()\n-        .zip(names)\n-        .filter_map(|(f, name)| Some(ast::make::record_field(f.visibility(), name, f.ty()?)));\n-    let record_fields = ast::make::record_field_list(record_fields);\n-    let tuple_fields_text_range = tuple_fields.syntax().text_range();\n-\n-    edit.edit_file(ctx.frange.file_id);\n-\n-    edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_space().text());\n-\n-    edit.replace(tuple_fields_text_range, record_fields.to_string());\n-}\n-\n-fn edit_variant_references(\n-    ctx: &AssistContext,\n-    edit: &mut AssistBuilder,\n-    variant: hir::Variant,\n-    names: &[ast::Name],\n-) {\n-    let variant_def = Definition::ModuleDef(hir::ModuleDef::Variant(variant));\n-    let usages = variant_def.usages(&ctx.sema).include_self_refs().all();\n-\n-    let edit_node = |edit: &mut AssistBuilder, node: SyntaxNode| -> Option<()> {\n-        match_ast! {\n-            match node {\n-                ast::TupleStructPat(tuple_struct_pat) => {\n-                    edit.replace(\n-                        tuple_struct_pat.syntax().text_range(),\n-                        ast::make::record_pat_with_fields(\n-                            tuple_struct_pat.path()?,\n-                            ast::make::record_pat_field_list(tuple_struct_pat.fields().zip(names).map(\n-                                |(pat, name)| {\n-                                    ast::make::record_pat_field(\n-                                        ast::make::name_ref(&name.to_string()),\n-                                        pat,\n-                                    )\n-                                },\n-                            )),\n-                        )\n-                        .to_string(),\n-                    );\n-                },\n-                // for tuple struct creations like Foo(42)\n-                ast::CallExpr(call_expr) => {\n-                    let path = call_expr.syntax().descendants().find_map(ast::PathExpr::cast).and_then(|expr| expr.path())?;\n-\n-                    // this also includes method calls like Foo::new(42), we should skip them\n-                    if let Some(name_ref) = path.segment().and_then(|s| s.name_ref()) {\n-                        match NameRefClass::classify(&ctx.sema, &name_ref) {\n-                            Some(NameRefClass::Definition(Definition::SelfType(_))) => {},\n-                            Some(NameRefClass::Definition(def)) if def == variant_def => {},\n-                            _ => return None,\n-                        };\n-                    }\n-\n-                    let arg_list = call_expr.syntax().descendants().find_map(ast::ArgList::cast)?;\n-\n-                    edit.replace(\n-                        call_expr.syntax().text_range(),\n-                        ast::make::record_expr(\n-                            path,\n-                            ast::make::record_expr_field_list(arg_list.args().zip(names).map(\n-                                |(expr, name)| {\n-                                    ast::make::record_expr_field(\n-                                        ast::make::name_ref(&name.to_string()),\n-                                        Some(expr),\n-                                    )\n-                                },\n-                            )),\n-                        )\n-                        .to_string(),\n-                    );\n-                },\n-                _ => return None,\n-            }\n-        }\n-        Some(())\n-    };\n-\n-    for (file_id, refs) in usages {\n-        edit.edit_file(file_id);\n-        for r in refs {\n-            for node in r.name.syntax().ancestors() {\n-                if edit_node(edit, node).is_some() {\n-                    break;\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn edit_field_references(\n-    ctx: &AssistContext,\n-    edit: &mut AssistBuilder,\n-    fields: impl Iterator<Item = ast::TupleField>,\n-    names: &[ast::Name],\n-) {\n-    for (field, name) in fields.zip(names) {\n-        let field = match ctx.sema.to_def(&field) {\n-            Some(it) => it,\n-            None => continue,\n-        };\n-        let def = Definition::Field(field);\n-        let usages = def.usages(&ctx.sema).all();\n-        for (file_id, refs) in usages {\n-            edit.edit_file(file_id);\n-            for r in refs {\n-                if let Some(name_ref) = r.name.as_name_ref() {\n-                    edit.replace(name_ref.syntax().text_range(), name.text());\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn generate_names(fields: impl Iterator<Item = ast::TupleField>) -> Vec<ast::Name> {\n-    fields.enumerate().map(|(i, _)| ast::make::name(&format!(\"field{}\", i + 1))).collect()\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::tests::{check_assist, check_assist_not_applicable};\n-\n-    use super::*;\n-\n-    #[test]\n-    fn not_applicable_other_than_tuple_variant() {\n-        check_assist_not_applicable(\n-            convert_tuple_variant_to_named_variant,\n-            r#\"enum Enum { Variant$0 { value: usize } };\"#,\n-        );\n-        check_assist_not_applicable(convert_tuple_variant_to_named_variant, r#\"enum Enum { Variant$0 }\"#);\n-    }\n-\n-    #[test]\n-    fn convert_simple_variant() {\n-        check_assist(\n-            convert_tuple_variant_to_named_variant,\n-            r#\"\n-enum A {\n-    $0Variant(usize),\n-}\n-\n-impl A {\n-    fn new(value: usize) -> A {\n-        A::Variant(value)\n-    }\n-\n-    fn new_with_default() -> A {\n-        A::new(Default::default())\n-    }\n-\n-    fn value(self) -> usize {\n-        match self {\n-            A::Variant(value) => value,\n-        }\n-    }\n-}\"#,\n-            r#\"\n-enum A {\n-    Variant { field1: usize },\n-}\n-\n-impl A {\n-    fn new(value: usize) -> A {\n-        A::Variant { field1: value }\n-    }\n-\n-    fn new_with_default() -> A {\n-        A::new(Default::default())\n-    }\n-\n-    fn value(self) -> usize {\n-        match self {\n-            A::Variant { field1: value } => value,\n-        }\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn convert_variant_referenced_via_self_kw() {\n-        check_assist(\n-            convert_tuple_variant_to_named_variant,\n-            r#\"\n-enum A {\n-    $0Variant(usize),\n-}\n-\n-impl A {\n-    fn new(value: usize) -> A {\n-        Self::Variant(value)\n-    }\n-\n-    fn new_with_default() -> A {\n-        Self::new(Default::default())\n-    }\n-\n-    fn value(self) -> usize {\n-        match self {\n-            Self::Variant(value) => value,\n-        }\n-    }\n-}\"#,\n-            r#\"\n-enum A {\n-    Variant { field1: usize },\n-}\n-\n-impl A {\n-    fn new(value: usize) -> A {\n-        Self::Variant { field1: value }\n-    }\n-\n-    fn new_with_default() -> A {\n-        Self::new(Default::default())\n-    }\n-\n-    fn value(self) -> usize {\n-        match self {\n-            Self::Variant { field1: value } => value,\n-        }\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn convert_destructured_variant() {\n-        check_assist(\n-            convert_tuple_variant_to_named_variant,\n-            r#\"\n-enum A {\n-    $0Variant(usize),\n-}\n-\n-impl A {\n-    fn into_inner(self) -> usize {\n-        let A::Variant(first) = self;\n-        first\n-    }\n-\n-    fn into_inner_via_self(self) -> usize {\n-        let Self::Variant(first) = self;\n-        first\n-    }\n-}\"#,\n-            r#\"\n-enum A {\n-    Variant { field1: usize },\n-}\n-\n-impl A {\n-    fn into_inner(self) -> usize {\n-        let A::Variant { field1: first } = self;\n-        first\n-    }\n-\n-    fn into_inner_via_self(self) -> usize {\n-        let Self::Variant { field1: first } = self;\n-        first\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn convert_variant_with_wrapped_references() {\n-        check_assist(\n-            convert_tuple_variant_to_named_variant,\n-            r#\"\n-enum Inner {\n-    $0Variant(usize),\n-}\n-enum Outer {\n-    Variant(Inner),\n-}\n-\n-impl Outer {\n-    fn new() -> Self {\n-        Self::Variant(Inner::Variant(42))\n-    }\n-\n-    fn into_inner_destructed(self) -> u32 {\n-        let Outer::Variant(Inner::Variant(x)) = self;\n-        x\n-    }\n-}\"#,\n-            r#\"\n-enum Inner {\n-    Variant { field1: usize },\n-}\n-enum Outer {\n-    Variant(Inner),\n-}\n-\n-impl Outer {\n-    fn new() -> Self {\n-        Self::Variant(Inner::Variant { field1: 42 })\n-    }\n-\n-    fn into_inner_destructed(self) -> u32 {\n-        let Outer::Variant(Inner::Variant { field1: x }) = self;\n-        x\n-    }\n-}\"#,\n-        );\n-\n-        check_assist(\n-            convert_tuple_variant_to_named_variant,\n-            r#\"\n-enum Inner {\n-    Variant(usize),\n-}\n-enum Outer {\n-    $0Variant(Inner),\n-}\n-\n-impl Outer {\n-    fn new() -> Self {\n-        Self::Variant(Inner::Variant(42))\n-    }\n-\n-    fn into_inner_destructed(self) -> u32 {\n-        let Outer::Variant(Inner::Variant(x)) = self;\n-        x\n-    }\n-}\"#,\n-            r#\"\n-enum Inner {\n-    Variant(usize),\n-}\n-enum Outer {\n-    Variant { field1: Inner },\n-}\n-\n-impl Outer {\n-    fn new() -> Self {\n-        Self::Variant { field1: Inner::Variant(42) }\n-    }\n-\n-    fn into_inner_destructed(self) -> u32 {\n-        let Outer::Variant { field1: Inner::Variant(x) } = self;\n-        x\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn convert_variant_with_multi_file_references() {\n-        check_assist(\n-            convert_tuple_variant_to_named_variant,\n-            r#\"\n-//- /main.rs\n-struct Inner;\n-enum A {\n-    $0Variant(Inner),\n-}\n-\n-mod foo;\n-\n-//- /foo.rs\n-use crate::{A, Inner};\n-fn f() {\n-    let a = A::Variant(Inner);\n-}\n-\"#,\n-            r#\"\n-//- /main.rs\n-struct Inner;\n-enum A {\n-    Variant { field1: Inner },\n-}\n-\n-mod foo;\n-\n-//- /foo.rs\n-use crate::{A, Inner};\n-fn f() {\n-    let a = A::Variant { field1: Inner };\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn convert_directly_used_variant() {\n-        check_assist(\n-            convert_tuple_variant_to_named_variant,\n-            r#\"\n-//- /main.rs\n-struct Inner;\n-enum A {\n-    $0Variant(Inner),\n-}\n-\n-mod foo;\n-\n-//- /foo.rs\n-use crate::{A::Variant, Inner};\n-fn f() {\n-    let a = Variant(Inner);\n-}\n-\"#,\n-            r#\"\n-//- /main.rs\n-struct Inner;\n-enum A {\n-    Variant { field1: Inner },\n-}\n-\n-mod foo;\n-\n-//- /foo.rs\n-use crate::{A::Variant, Inner};\n-fn f() {\n-    let a = Variant { field1: Inner };\n-}\n-\"#,\n-        );\n-    }\n-}"}, {"sha": "16af72927b02137f440e6d7cdd1c092a17c717b2", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18f796a728806e5138708a7af00d6064ec251382/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f796a728806e5138708a7af00d6064ec251382/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=18f796a728806e5138708a7af00d6064ec251382", "patch": "@@ -186,7 +186,6 @@ mod handlers {\n     mod convert_iter_for_each_to_for;\n     mod convert_into_to_from;\n     mod convert_tuple_struct_to_named_struct;\n-    mod convert_tuple_variant_to_named_variant;\n     mod early_return;\n     mod expand_glob_import;\n     mod extract_function;\n@@ -257,7 +256,6 @@ mod handlers {\n             convert_iter_for_each_to_for::convert_iter_for_each_to_for,\n             convert_into_to_from::convert_into_to_from,\n             convert_tuple_struct_to_named_struct::convert_tuple_struct_to_named_struct,\n-            convert_tuple_variant_to_named_variant::convert_tuple_variant_to_named_variant,\n             early_return::convert_to_guarded_return,\n             expand_glob_import::expand_glob_import,\n             extract_struct_from_enum_variant::extract_struct_from_enum_variant,"}]}