{"sha": "4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYjUzMzYwNTQxYmFmM2U2ZGYzNmRjMGYwNzY2YmM3YzFjOWY4YmU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-18T00:04:51Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-24T21:21:57Z"}, "message": "Move as much I/O as possible off of native::io\n\nWhen uv's TTY I/O is used for the stdio streams, the file descriptors are put\ninto a non-blocking mode. This means that other concurrent writes to the same\nstream can fail with EAGAIN or EWOULDBLOCK. By all I/O to event-loop I/O, we\navoid this error.\n\nThere is one location which cannot move, which is the runtime's dumb_println\nfunction. This was implemented to handle the EAGAIN and EWOULDBLOCK errors and\nsimply retry again and again.", "tree": {"sha": "0b78ce834f9df44297595d66b38883831811b99f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b78ce834f9df44297595d66b38883831811b99f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "html_url": "https://github.com/rust-lang/rust/commit/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ce71eaca34526d0e3ee1ebf0658d2a20d388ef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ce71eaca34526d0e3ee1ebf0658d2a20d388ef2", "html_url": "https://github.com/rust-lang/rust/commit/4ce71eaca34526d0e3ee1ebf0658d2a20d388ef2"}], "stats": {"total": 266, "additions": 166, "deletions": 100}, "files": [{"sha": "35a3ca3cff05d7572794903d18c20717596199c1", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "patch": "@@ -112,7 +112,7 @@ pub fn log(_level: u32, args: &fmt::Arguments) {\n             }\n             None => {\n                 // There is no logger anywhere, just write to stderr\n-                let mut logger = StdErrLogger;\n+                let mut logger = StdErrLogger::new();\n                 logger.log(args);\n             }\n         }"}, {"sha": "240210880bfab669fa86dadfd5dc346fc9b3fa3e", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "patch": "@@ -370,6 +370,7 @@ pub enum IoErrorKind {\n     PathAlreadyExists,\n     PathDoesntExist,\n     MismatchedFileTypeForOperation,\n+    ResourceUnavailable,\n     IoUnavailable,\n }\n \n@@ -392,6 +393,7 @@ impl ToStr for IoErrorKind {\n             PathDoesntExist => ~\"PathDoesntExist\",\n             MismatchedFileTypeForOperation => ~\"MismatchedFileTypeForOperation\",\n             IoUnavailable => ~\"IoUnavailable\",\n+            ResourceUnavailable => ~\"ResourceUnavailable\",\n         }\n     }\n }"}, {"sha": "a2b2289679afce08cd4339fa6c114eda7cf1f921", "filename": "src/libstd/rt/io/native/file.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs?ref=4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "patch": "@@ -21,6 +21,12 @@ fn raise_error() {\n     // XXX: this should probably be a bit more descriptive...\n     let (kind, desc) = match os::errno() as i32 {\n         libc::EOF => (EndOfFile, \"end of file\"),\n+\n+        // These two constants can have the same value on some systems, but\n+        // different values on others, so we can't use a match clause\n+        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n+            (ResourceUnavailable, \"resource temporarily unavailable\"),\n+\n         _ => (OtherIoError, \"unknown error\"),\n     };\n "}, {"sha": "294df9a6442a180627ab1e06e06259acfed95b3d", "filename": "src/libstd/rt/io/stdio.rs", "status": "modified", "additions": 44, "deletions": 24, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fstdio.rs?ref=4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "patch": "@@ -8,20 +8,39 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*!\n+\n+This modules provides bindings to the local event loop's TTY interface, using it\n+to have synchronous, but non-blocking versions of stdio. These handles can be\n+inspected for information about terminal dimensions or related information\n+about the stream or terminal that it is attached to.\n+\n+# Example\n+\n+```rust\n+use std::rt::io;\n+\n+let mut out = io::stdout();\n+out.write(bytes!(\"Hello, world!\"));\n+```\n+\n+*/\n+\n use fmt;\n use libc;\n use option::{Option, Some, None};\n use result::{Ok, Err};\n use rt::rtio::{IoFactory, RtioTTY, with_local_io};\n use super::{Reader, Writer, io_error};\n \n-/// Creates a new non-blocking handle to the stdin of the current process.\n-///\n-/// See `stdout()` for notes about this function.\n-pub fn stdin() -> StdReader {\n+#[fixed_stack_segment] #[inline(never)]\n+fn tty<T>(fd: libc::c_int, f: &fn(~RtioTTY) -> T) -> T {\n     do with_local_io |io| {\n-        match io.tty_open(libc::STDIN_FILENO, true, false) {\n-            Ok(tty) => Some(StdReader { inner: tty }),\n+        // Always pass in readable as true, otherwise libuv turns our writes\n+        // into blocking writes. We also need to dup the file descriptor because\n+        // the tty will be closed when it's dropped.\n+        match io.tty_open(unsafe { libc::dup(fd) }, true) {\n+            Ok(tty) => Some(f(tty)),\n             Err(e) => {\n                 io_error::cond.raise(e);\n                 None\n@@ -30,37 +49,28 @@ pub fn stdin() -> StdReader {\n     }.unwrap()\n }\n \n+/// Creates a new non-blocking handle to the stdin of the current process.\n+///\n+/// See `stdout()` for notes about this function.\n+pub fn stdin() -> StdReader {\n+    do tty(libc::STDIN_FILENO) |tty| { StdReader { inner: tty } }\n+}\n+\n /// Creates a new non-blocking handle to the stdout of the current process.\n ///\n /// Note that this is a fairly expensive operation in that at least one memory\n /// allocation is performed. Additionally, this must be called from a runtime\n /// task context because the stream returned will be a non-blocking object using\n /// the local scheduler to perform the I/O.\n pub fn stdout() -> StdWriter {\n-    do with_local_io |io| {\n-        match io.tty_open(libc::STDOUT_FILENO, false, false) {\n-            Ok(tty) => Some(StdWriter { inner: tty }),\n-            Err(e) => {\n-                io_error::cond.raise(e);\n-                None\n-            }\n-        }\n-    }.unwrap()\n+    do tty(libc::STDOUT_FILENO) |tty| { StdWriter { inner: tty } }\n }\n \n /// Creates a new non-blocking handle to the stderr of the current process.\n ///\n /// See `stdout()` for notes about this function.\n pub fn stderr() -> StdWriter {\n-    do with_local_io |io| {\n-        match io.tty_open(libc::STDERR_FILENO, false, false) {\n-            Ok(tty) => Some(StdWriter { inner: tty }),\n-            Err(e) => {\n-                io_error::cond.raise(e);\n-                None\n-            }\n-        }\n-    }.unwrap()\n+    do tty(libc::STDERR_FILENO) |tty| { StdWriter { inner: tty } }\n }\n \n /// Prints a string to the stdout of the current process. No newline is emitted\n@@ -115,6 +125,11 @@ impl StdReader {\n             Err(e) => io_error::cond.raise(e),\n         }\n     }\n+\n+    /// Returns whether this tream is attached to a TTY instance or not.\n+    ///\n+    /// This is similar to libc's isatty() function\n+    pub fn isatty(&self) -> bool { self.inner.isatty() }\n }\n \n impl Reader for StdReader {\n@@ -170,6 +185,11 @@ impl StdWriter {\n             Err(e) => io_error::cond.raise(e),\n         }\n     }\n+\n+    /// Returns whether this tream is attached to a TTY instance or not.\n+    ///\n+    /// This is similar to libc's isatty() function\n+    pub fn isatty(&self) -> bool { self.inner.isatty() }\n }\n \n impl Writer for StdWriter {"}, {"sha": "31650ede7000d240b428e8300e5179499fa89de6", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "patch": "@@ -12,6 +12,7 @@ use fmt;\n use from_str::from_str;\n use libc::exit;\n use option::{Some, None, Option};\n+use rt::io;\n use rt::crate_map::{ModEntry, CrateMap, iter_crate_map, get_crate_map};\n use str::StrSlice;\n use u32;\n@@ -166,14 +167,23 @@ pub trait Logger {\n     fn log(&mut self, args: &fmt::Arguments);\n }\n \n-pub struct StdErrLogger;\n+/// This logger emits output to the stderr of the process, and contains a lazily\n+/// initialized event-loop driven handle to the stream.\n+pub struct StdErrLogger {\n+    priv handle: Option<io::stdio::StdWriter>,\n+}\n+\n+impl StdErrLogger {\n+    pub fn new() -> StdErrLogger { StdErrLogger { handle: None } }\n+}\n \n impl Logger for StdErrLogger {\n     fn log(&mut self, args: &fmt::Arguments) {\n-        // FIXME(#6846): this should not call the blocking version of println,\n-        //               or at least the default loggers for tasks shouldn't do\n-        //               that\n-        ::rt::util::dumb_println(args);\n+        // First time logging? Get a handle to the stderr of this process.\n+        if self.handle.is_none() {\n+            self.handle = Some(io::stderr());\n+        }\n+        fmt::writeln(self.handle.get_mut_ref() as &mut io::Writer, args);\n     }\n }\n "}, {"sha": "4a4ce4edcc2d630a093b2c6ad981fca8ae823626", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "patch": "@@ -97,7 +97,7 @@ pub trait IoFactory {\n     fn unix_bind(&mut self, path: &CString) ->\n         Result<~RtioUnixListener, IoError>;\n     fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError>;\n-    fn tty_open(&mut self, fd: c_int, readable: bool, close_on_drop: bool)\n+    fn tty_open(&mut self, fd: c_int, readable: bool)\n             -> Result<~RtioTTY, IoError>;\n }\n \n@@ -182,6 +182,7 @@ pub trait RtioTTY {\n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n     fn set_raw(&mut self, raw: bool) -> Result<(), IoError>;\n     fn get_winsize(&mut self) -> Result<(int, int), IoError>;\n+    fn isatty(&self) -> bool;\n }\n \n pub trait PausibleIdleCallback {"}, {"sha": "16ae28743c523bf36caac207e0aa2eb72272aa6a", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "patch": "@@ -132,7 +132,7 @@ impl Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(None),\n-            logger: StdErrLogger,\n+            logger: StdErrLogger::new(),\n             unwinder: Unwinder { unwinding: false },\n             taskgroup: None,\n             death: Death::new(),\n@@ -166,7 +166,7 @@ impl Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(None),\n-            logger: StdErrLogger,\n+            logger: StdErrLogger::new(),\n             unwinder: Unwinder { unwinding: false },\n             taskgroup: None,\n             death: Death::new(),\n@@ -188,7 +188,7 @@ impl Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(None),\n-            logger: StdErrLogger,\n+            logger: StdErrLogger::new(),\n             unwinder: Unwinder { unwinding: false },\n             taskgroup: None,\n             // FIXME(#7544) make watching optional\n@@ -549,6 +549,7 @@ pub fn begin_unwind(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     use rt::logging::Logger;\n     use str::Str;\n     use c_str::CString;\n+    use unstable::intrinsics;\n \n     unsafe {\n         let msg = CString::new(msg, false);\n@@ -557,35 +558,32 @@ pub fn begin_unwind(msg: *c_char, file: *c_char, line: size_t) -> ! {\n             Some(s) => s, None => rtabort!(\"message wasn't utf8?\")\n         };\n \n-        if in_green_task_context() {\n-            // Be careful not to allocate in this block, if we're failing we may\n-            // have been failing due to a lack of memory in the first place...\n-            do Local::borrow |task: &mut Task| {\n-                let n = task.name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n-\n-                match file.as_str() {\n-                    Some(file) => {\n-                        format_args!(|args| { task.logger.log(args) },\n-                                     \"task '{}' failed at '{}', {}:{}\",\n-                                     n, msg, file, line);\n-                    }\n-                    None => {\n-                        format_args!(|args| { task.logger.log(args) },\n-                                     \"task '{}' failed at '{}'\", n, msg);\n-                    }\n-                }\n-            }\n-        } else {\n+        if !in_green_task_context() {\n             match file.as_str() {\n                 Some(file) => {\n                     rterrln!(\"failed in non-task context at '{}', {}:{}\",\n                              msg, file, line as int);\n                 }\n-                None => rterrln!(\"failed in non-task context at '{}'\", msg),\n+                None => rterrln!(\"failed in non-task context at '{}'\", msg)\n             }\n+            intrinsics::abort();\n         }\n \n+        // Be careful not to allocate in this block, if we're failing we may\n+        // have been failing due to a lack of memory in the first place...\n         let task: *mut Task = Local::unsafe_borrow();\n+        let n = (*task).name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n+        match file.as_str() {\n+            Some(file) => {\n+                format_args!(|args| { (*task).logger.log(args) },\n+                             \"task '{}' failed at '{}', {}:{}\",\n+                             n, msg, file, line);\n+            }\n+            None => {\n+                format_args!(|args| { (*task).logger.log(args) },\n+                             \"task '{}' failed at '{}'\", n, msg);\n+            }\n+        }\n         if (*task).unwinder.unwinding {\n             rtabort!(\"unwinding again\");\n         }"}, {"sha": "f15aa01db954dec8ddd9819408fca52617f026f5", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "patch": "@@ -71,9 +71,18 @@ pub fn default_sched_threads() -> uint {\n \n pub fn dumb_println(args: &fmt::Arguments) {\n     use rt::io::native::stdio::stderr;\n-    use rt::io::Writer;\n+    use rt::io::{Writer, io_error, ResourceUnavailable};\n     let mut out = stderr();\n-    fmt::writeln(&mut out as &mut Writer, args);\n+\n+    let mut again = true;\n+    do io_error::cond.trap(|e| {\n+        again = e.kind == ResourceUnavailable;\n+    }).inside {\n+        while again {\n+            again = false;\n+            fmt::writeln(&mut out as &mut Writer, args);\n+        }\n+    }\n }\n \n pub fn abort(msg: &str) -> ! {"}, {"sha": "18c991577076344af929debad8f65fe67383c3e4", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "patch": "@@ -170,6 +170,7 @@ pub trait WatcherInterop {\n     fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData;\n     fn drop_watcher_data(&mut self);\n     fn close(self, cb: NullCallback);\n+    fn close_async(self);\n }\n \n impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n@@ -235,6 +236,16 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n             unsafe { uvll::free_handle(handle as *c_void) }\n         }\n     }\n+\n+    fn close_async(self) {\n+        unsafe { uvll::close(self.native_handle(), close_cb); }\n+\n+        extern fn close_cb(handle: *uvll::uv_handle_t) {\n+            let mut h: Handle = NativeHandle::from_native_handle(handle);\n+            h.drop_watcher_data();\n+            unsafe { uvll::free_handle(handle as *c_void) }\n+        }\n+    }\n }\n \n // XXX: Need to define the error constants like EOF so they can be"}, {"sha": "915c7d0da528b27f9af893a3642038231762b125", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "patch": "@@ -868,13 +868,13 @@ impl IoFactory for UvIoFactory {\n         return ret;\n     }\n \n-    fn tty_open(&mut self, fd: c_int, readable: bool, close_on_drop: bool)\n+    fn tty_open(&mut self, fd: c_int, readable: bool)\n             -> Result<~RtioTTY, IoError> {\n         match tty::TTY::new(self.uv_loop(), fd, readable) {\n             Ok(tty) => Ok(~UvTTY {\n                 home: get_handle_to_current_scheduler!(),\n                 tty: tty,\n-                close_on_drop: close_on_drop,\n+                fd: fd,\n             } as ~RtioTTY),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n@@ -1748,7 +1748,7 @@ impl RtioUnixListener for UvUnixListener {\n pub struct UvTTY {\n     tty: tty::TTY,\n     home: SchedHandle,\n-    close_on_drop: bool,\n+    fd: c_int,\n }\n \n impl HomingIO for UvTTY {\n@@ -1757,20 +1757,48 @@ impl HomingIO for UvTTY {\n \n impl Drop for UvTTY {\n     fn drop(&mut self) {\n-        if self.close_on_drop {\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task = Cell::new(task);\n-                do self.tty.close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task.take());\n-                }\n+        // TTY handles are used for the logger in a task, so this destructor is\n+        // run when a task is destroyed. When a task is being destroyed, a local\n+        // scheduler isn't available, so we can't do the normal \"take the\n+        // scheduler and resume once close is done\". Instead close operations on\n+        // a TTY are asynchronous.\n+\n+        self.tty.close_async();\n+    }\n+}\n+\n+impl RtioTTY for UvTTY {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            read_stream(self_.tty.as_stream(), scheduler, buf)\n+        }\n+    }\n+\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            write_stream(self_.tty.as_stream(), scheduler, buf)\n+        }\n+    }\n+\n+    fn set_raw(&mut self, raw: bool) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            match self_.tty.set_mode(raw) {\n+                Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n             }\n-        } else {\n-            self.tty.drop_watcher_data();\n-            unsafe { uvll::free_handle(self.tty.native_handle()) }\n         }\n     }\n+\n+    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n+        do self.home_for_io |self_| {\n+            match self_.tty.get_winsize() {\n+                Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n+            }\n+        }\n+    }\n+\n+    fn isatty(&self) -> bool {\n+        unsafe { uvll::guess_handle(self.fd) == uvll::UV_TTY }\n+    }\n }\n \n pub struct UvUnixAcceptor {\n@@ -1808,36 +1836,6 @@ impl RtioUnixAcceptor for UvUnixAcceptor {\n     }\n }\n \n-impl RtioTTY for UvTTY {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            read_stream(self_.tty.as_stream(), scheduler, buf)\n-        }\n-    }\n-\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            write_stream(self_.tty.as_stream(), scheduler, buf)\n-        }\n-    }\n-\n-    fn set_raw(&mut self, raw: bool) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            match self_.tty.set_mode(raw) {\n-                Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n-            }\n-        }\n-    }\n-\n-    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n-        do self.home_for_io |self_| {\n-            match self_.tty.get_winsize() {\n-                Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n-            }\n-        }\n-    }\n-}\n-\n // this function is full of lies\n unsafe fn local_io() -> &'static mut IoFactory {\n     do Local::borrow |sched: &mut Scheduler| {"}, {"sha": "8f8aea9d121695e6c1eadeb8500821f338fc2e66", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "patch": "@@ -986,6 +986,10 @@ pub unsafe fn tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n     #[fixed_stack_segment]; #[inline(never)];\n     rust_uv_tty_get_winsize(tty, width, height)\n }\n+pub unsafe fn guess_handle(fd: c_int) -> uv_handle_type {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_guess_handle(fd)\n+}\n \n pub struct uv_err_data {\n     priv err_name: ~str,\n@@ -1140,6 +1144,7 @@ extern {\n     fn rust_uv_tty_set_mode(tty: *uv_tty_t, mode: c_int) -> c_int;\n     fn rust_uv_tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n                                height: *c_int) -> c_int;\n+    fn rust_uv_guess_handle(fd: c_int) -> uv_handle_type;\n \n     // These should all really be constants...\n     #[rust_stack] pub fn rust_SOCK_STREAM() -> c_int;"}, {"sha": "7ab57e6909aa748cab6945c3b5aaa82d1148fa5a", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "patch": "@@ -681,3 +681,8 @@ extern \"C\" int\n rust_uv_tty_get_winsize(uv_tty_t *tty, int *width, int *height) {\n     return uv_tty_get_winsize(tty, width, height);\n }\n+\n+extern \"C\" uv_handle_type\n+rust_uv_guess_handle(int fd) {\n+    return uv_guess_handle(fd);\n+}"}, {"sha": "6c3988d6b01522b2188a1241a097ebb292735bd1", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "patch": "@@ -217,3 +217,4 @@ rust_uv_pipe_connect\n rust_uv_tty_init\n rust_uv_tty_set_mode\n rust_uv_tty_get_winsize\n+rust_uv_guess_handle"}]}