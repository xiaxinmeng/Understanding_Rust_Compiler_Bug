{"sha": "005f14d51809e385eb396bb2c1a115cf9ba21872", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNWYxNGQ1MTgwOWUzODVlYjM5NmJiMmMxYTExNWNmOWJhMjE4NzI=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-22T12:35:27Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-02-05T07:47:08Z"}, "message": "Move infer::canonical datatypes to infer::types.", "tree": {"sha": "a79acdf5a3635ae4514a0804be2d8dfbc9986b75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a79acdf5a3635ae4514a0804be2d8dfbc9986b75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/005f14d51809e385eb396bb2c1a115cf9ba21872", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/005f14d51809e385eb396bb2c1a115cf9ba21872", "html_url": "https://github.com/rust-lang/rust/commit/005f14d51809e385eb396bb2c1a115cf9ba21872", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/005f14d51809e385eb396bb2c1a115cf9ba21872/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c07dad7258fad6b7504f9e2569fece97fa394b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c07dad7258fad6b7504f9e2569fece97fa394b6", "html_url": "https://github.com/rust-lang/rust/commit/9c07dad7258fad6b7504f9e2569fece97fa394b6"}], "stats": {"total": 698, "additions": 364, "deletions": 334}, "files": [{"sha": "f157d805bcd8cb4f3f2cb2adf946d57e5b839596", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 5, "deletions": 334, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/005f14d51809e385eb396bb2c1a115cf9ba21872/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005f14d51809e385eb396bb2c1a115cf9ba21872/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=005f14d51809e385eb396bb2c1a115cf9ba21872", "patch": "@@ -21,284 +21,22 @@\n //!\n //! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n \n-use crate::infer::region_constraints::MemberConstraint;\n use crate::infer::{ConstVariableOrigin, ConstVariableOriginKind};\n use crate::infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::subst::GenericArg;\n-use crate::ty::{self, BoundVar, List, Region, TyCtxt};\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::subst::GenericArg;\n+use rustc::ty::{self, BoundVar, List};\n use rustc_index::vec::IndexVec;\n-use rustc_macros::HashStable;\n-use rustc_serialize::UseSpecializedDecodable;\n use rustc_span::source_map::Span;\n-use smallvec::SmallVec;\n-use std::ops::Index;\n+\n+pub use rustc::infer::types::canonical::*;\n \n mod canonicalizer;\n \n pub mod query_response;\n \n mod substitute;\n \n-/// A \"canonicalized\" type `V` is one where all free inference\n-/// variables have been rewritten to \"canonical vars\". These are\n-/// numbered starting from 0 in order of first appearance.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n-#[derive(HashStable, TypeFoldable, Lift)]\n-pub struct Canonical<'tcx, V> {\n-    pub max_universe: ty::UniverseIndex,\n-    pub variables: CanonicalVarInfos<'tcx>,\n-    pub value: V,\n-}\n-\n-pub type CanonicalVarInfos<'tcx> = &'tcx List<CanonicalVarInfo>;\n-\n-impl<'tcx> UseSpecializedDecodable for CanonicalVarInfos<'tcx> {}\n-\n-/// A set of values corresponding to the canonical variables from some\n-/// `Canonical`. You can give these values to\n-/// `canonical_value.substitute` to substitute them into the canonical\n-/// value at the right places.\n-///\n-/// When you canonicalize a value `V`, you get back one of these\n-/// vectors with the original values that were replaced by canonical\n-/// variables. You will need to supply it later to instantiate the\n-/// canonicalized query response.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n-#[derive(HashStable, TypeFoldable, Lift)]\n-pub struct CanonicalVarValues<'tcx> {\n-    pub var_values: IndexVec<BoundVar, GenericArg<'tcx>>,\n-}\n-\n-/// When we canonicalize a value to form a query, we wind up replacing\n-/// various parts of it with canonical variables. This struct stores\n-/// those replaced bits to remember for when we process the query\n-/// result.\n-#[derive(Clone, Debug)]\n-pub struct OriginalQueryValues<'tcx> {\n-    /// Map from the universes that appear in the query to the\n-    /// universes in the caller context. For the time being, we only\n-    /// ever put ROOT values into the query, so this map is very\n-    /// simple.\n-    pub universe_map: SmallVec<[ty::UniverseIndex; 4]>,\n-\n-    /// This is equivalent to `CanonicalVarValues`, but using a\n-    /// `SmallVec` yields a significant performance win.\n-    pub var_values: SmallVec<[GenericArg<'tcx>; 8]>,\n-}\n-\n-impl Default for OriginalQueryValues<'tcx> {\n-    fn default() -> Self {\n-        let mut universe_map = SmallVec::default();\n-        universe_map.push(ty::UniverseIndex::ROOT);\n-\n-        Self { universe_map, var_values: SmallVec::default() }\n-    }\n-}\n-\n-/// Information about a canonical variable that is included with the\n-/// canonical value. This is sufficient information for code to create\n-/// a copy of the canonical value in some other inference context,\n-/// with fresh inference variables replacing the canonical values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n-pub struct CanonicalVarInfo {\n-    pub kind: CanonicalVarKind,\n-}\n-\n-impl CanonicalVarInfo {\n-    pub fn universe(&self) -> ty::UniverseIndex {\n-        self.kind.universe()\n-    }\n-\n-    pub fn is_existential(&self) -> bool {\n-        match self.kind {\n-            CanonicalVarKind::Ty(_) => true,\n-            CanonicalVarKind::PlaceholderTy(_) => false,\n-            CanonicalVarKind::Region(_) => true,\n-            CanonicalVarKind::PlaceholderRegion(..) => false,\n-            CanonicalVarKind::Const(_) => true,\n-            CanonicalVarKind::PlaceholderConst(_) => false,\n-        }\n-    }\n-}\n-\n-/// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n-/// in the type-theory sense of the term -- i.e., a \"meta\" type system\n-/// that analyzes type-like values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n-pub enum CanonicalVarKind {\n-    /// Some kind of type inference variable.\n-    Ty(CanonicalTyVarKind),\n-\n-    /// A \"placeholder\" that represents \"any type\".\n-    PlaceholderTy(ty::PlaceholderType),\n-\n-    /// Region variable `'?R`.\n-    Region(ty::UniverseIndex),\n-\n-    /// A \"placeholder\" that represents \"any region\". Created when you\n-    /// are solving a goal like `for<'a> T: Foo<'a>` to represent the\n-    /// bound region `'a`.\n-    PlaceholderRegion(ty::PlaceholderRegion),\n-\n-    /// Some kind of const inference variable.\n-    Const(ty::UniverseIndex),\n-\n-    /// A \"placeholder\" that represents \"any const\".\n-    PlaceholderConst(ty::PlaceholderConst),\n-}\n-\n-impl CanonicalVarKind {\n-    pub fn universe(self) -> ty::UniverseIndex {\n-        match self {\n-            CanonicalVarKind::Ty(kind) => match kind {\n-                CanonicalTyVarKind::General(ui) => ui,\n-                CanonicalTyVarKind::Float | CanonicalTyVarKind::Int => ty::UniverseIndex::ROOT,\n-            },\n-\n-            CanonicalVarKind::PlaceholderTy(placeholder) => placeholder.universe,\n-            CanonicalVarKind::Region(ui) => ui,\n-            CanonicalVarKind::PlaceholderRegion(placeholder) => placeholder.universe,\n-            CanonicalVarKind::Const(ui) => ui,\n-            CanonicalVarKind::PlaceholderConst(placeholder) => placeholder.universe,\n-        }\n-    }\n-}\n-\n-/// Rust actually has more than one category of type variables;\n-/// notably, the type variables we create for literals (e.g., 22 or\n-/// 22.) can only be instantiated with integral/float types (e.g.,\n-/// usize or f32). In order to faithfully reproduce a type, we need to\n-/// know what set of types a given type variable can be unified with.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n-pub enum CanonicalTyVarKind {\n-    /// General type variable `?T` that can be unified with arbitrary types.\n-    General(ty::UniverseIndex),\n-\n-    /// Integral type variable `?I` (that can only be unified with integral types).\n-    Int,\n-\n-    /// Floating-point type variable `?F` (that can only be unified with float types).\n-    Float,\n-}\n-\n-/// After we execute a query with a canonicalized key, we get back a\n-/// `Canonical<QueryResponse<..>>`. You can use\n-/// `instantiate_query_result` to access the data in this result.\n-#[derive(Clone, Debug, HashStable, TypeFoldable, Lift)]\n-pub struct QueryResponse<'tcx, R> {\n-    pub var_values: CanonicalVarValues<'tcx>,\n-    pub region_constraints: QueryRegionConstraints<'tcx>,\n-    pub certainty: Certainty,\n-    pub value: R,\n-}\n-\n-#[derive(Clone, Debug, Default, HashStable, TypeFoldable, Lift)]\n-pub struct QueryRegionConstraints<'tcx> {\n-    pub outlives: Vec<QueryOutlivesConstraint<'tcx>>,\n-    pub member_constraints: Vec<MemberConstraint<'tcx>>,\n-}\n-\n-impl QueryRegionConstraints<'_> {\n-    /// Represents an empty (trivially true) set of region\n-    /// constraints.\n-    pub fn is_empty(&self) -> bool {\n-        self.outlives.is_empty() && self.member_constraints.is_empty()\n-    }\n-}\n-\n-pub type Canonicalized<'tcx, V> = Canonical<'tcx, V>;\n-\n-pub type CanonicalizedQueryResponse<'tcx, T> = &'tcx Canonical<'tcx, QueryResponse<'tcx, T>>;\n-\n-/// Indicates whether or not we were able to prove the query to be\n-/// true.\n-#[derive(Copy, Clone, Debug, HashStable)]\n-pub enum Certainty {\n-    /// The query is known to be true, presuming that you apply the\n-    /// given `var_values` and the region-constraints are satisfied.\n-    Proven,\n-\n-    /// The query is not known to be true, but also not known to be\n-    /// false. The `var_values` represent *either* values that must\n-    /// hold in order for the query to be true, or helpful tips that\n-    /// *might* make it true. Currently rustc's trait solver cannot\n-    /// distinguish the two (e.g., due to our preference for where\n-    /// clauses over impls).\n-    ///\n-    /// After some unifiations and things have been done, it makes\n-    /// sense to try and prove again -- of course, at that point, the\n-    /// canonical form will be different, making this a distinct\n-    /// query.\n-    Ambiguous,\n-}\n-\n-impl Certainty {\n-    pub fn is_proven(&self) -> bool {\n-        match self {\n-            Certainty::Proven => true,\n-            Certainty::Ambiguous => false,\n-        }\n-    }\n-\n-    pub fn is_ambiguous(&self) -> bool {\n-        !self.is_proven()\n-    }\n-}\n-\n-impl<'tcx, R> QueryResponse<'tcx, R> {\n-    pub fn is_proven(&self) -> bool {\n-        self.certainty.is_proven()\n-    }\n-\n-    pub fn is_ambiguous(&self) -> bool {\n-        !self.is_proven()\n-    }\n-}\n-\n-impl<'tcx, R> Canonical<'tcx, QueryResponse<'tcx, R>> {\n-    pub fn is_proven(&self) -> bool {\n-        self.value.is_proven()\n-    }\n-\n-    pub fn is_ambiguous(&self) -> bool {\n-        !self.is_proven()\n-    }\n-}\n-\n-impl<'tcx, V> Canonical<'tcx, V> {\n-    /// Allows you to map the `value` of a canonical while keeping the\n-    /// same set of bound variables.\n-    ///\n-    /// **WARNING:** This function is very easy to mis-use, hence the\n-    /// name!  In particular, the new value `W` must use all **the\n-    /// same type/region variables** in **precisely the same order**\n-    /// as the original! (The ordering is defined by the\n-    /// `TypeFoldable` implementation of the type in question.)\n-    ///\n-    /// An example of a **correct** use of this:\n-    ///\n-    /// ```rust,ignore (not real code)\n-    /// let a: Canonical<'_, T> = ...;\n-    /// let b: Canonical<'_, (T,)> = a.unchecked_map(|v| (v, ));\n-    /// ```\n-    ///\n-    /// An example of an **incorrect** use of this:\n-    ///\n-    /// ```rust,ignore (not real code)\n-    /// let a: Canonical<'tcx, T> = ...;\n-    /// let ty: Ty<'tcx> = ...;\n-    /// let b: Canonical<'tcx, (T, Ty<'tcx>)> = a.unchecked_map(|v| (v, ty));\n-    /// ```\n-    pub fn unchecked_map<W>(self, map_op: impl FnOnce(V) -> W) -> Canonical<'tcx, W> {\n-        let Canonical { max_universe, variables, value } = self;\n-        Canonical { max_universe, variables, value: map_op(value) }\n-    }\n-}\n-\n-pub type QueryOutlivesConstraint<'tcx> =\n-    ty::Binder<ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>;\n-\n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Creates a substitution S for the canonical value with fresh\n     /// inference variables and applies it to the canonical value.\n@@ -424,70 +162,3 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         }\n     }\n }\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    crate::infer::canonical::Certainty,\n-    crate::infer::canonical::CanonicalVarInfo,\n-    crate::infer::canonical::CanonicalVarKind,\n-}\n-\n-CloneTypeFoldableImpls! {\n-    for <'tcx> {\n-        crate::infer::canonical::CanonicalVarInfos<'tcx>,\n-    }\n-}\n-\n-impl<'tcx> CanonicalVarValues<'tcx> {\n-    pub fn len(&self) -> usize {\n-        self.var_values.len()\n-    }\n-\n-    /// Makes an identity substitution from this one: each bound var\n-    /// is matched to the same bound var, preserving the original kinds.\n-    /// For example, if we have:\n-    /// `self.var_values == [Type(u32), Lifetime('a), Type(u64)]`\n-    /// we'll return a substitution `subst` with:\n-    /// `subst.var_values == [Type(^0), Lifetime(^1), Type(^2)]`.\n-    pub fn make_identity(&self, tcx: TyCtxt<'tcx>) -> Self {\n-        use crate::ty::subst::GenericArgKind;\n-\n-        CanonicalVarValues {\n-            var_values: self\n-                .var_values\n-                .iter()\n-                .zip(0..)\n-                .map(|(kind, i)| match kind.unpack() {\n-                    GenericArgKind::Type(..) => {\n-                        tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i).into())).into()\n-                    }\n-                    GenericArgKind::Lifetime(..) => tcx\n-                        .mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(i)))\n-                        .into(),\n-                    GenericArgKind::Const(ct) => tcx\n-                        .mk_const(ty::Const {\n-                            ty: ct.ty,\n-                            val: ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i)),\n-                        })\n-                        .into(),\n-                })\n-                .collect(),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> IntoIterator for &'a CanonicalVarValues<'tcx> {\n-    type Item = GenericArg<'tcx>;\n-    type IntoIter = ::std::iter::Cloned<::std::slice::Iter<'a, GenericArg<'tcx>>>;\n-\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.var_values.iter().cloned()\n-    }\n-}\n-\n-impl<'tcx> Index<BoundVar> for CanonicalVarValues<'tcx> {\n-    type Output = GenericArg<'tcx>;\n-\n-    fn index(&self, value: BoundVar) -> &GenericArg<'tcx> {\n-        &self.var_values[value]\n-    }\n-}"}, {"sha": "133cf1b592862048616e6bc7de3eeb1f17b4f71b", "filename": "src/librustc/infer/types/canonical.rs", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/005f14d51809e385eb396bb2c1a115cf9ba21872/src%2Flibrustc%2Finfer%2Ftypes%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005f14d51809e385eb396bb2c1a115cf9ba21872/src%2Flibrustc%2Finfer%2Ftypes%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftypes%2Fcanonical.rs?ref=005f14d51809e385eb396bb2c1a115cf9ba21872", "patch": "@@ -0,0 +1,357 @@\n+//! **Canonicalization** is the key to constructing a query in the\n+//! middle of type inference. Ordinarily, it is not possible to store\n+//! types from type inference in query keys, because they contain\n+//! references to inference variables whose lifetimes are too short\n+//! and so forth. Canonicalizing a value T1 using `canonicalize_query`\n+//! produces two things:\n+//!\n+//! - a value T2 where each unbound inference variable has been\n+//!   replaced with a **canonical variable**;\n+//! - a map M (of type `CanonicalVarValues`) from those canonical\n+//!   variables back to the original.\n+//!\n+//! We can then do queries using T2. These will give back constraints\n+//! on the canonical variables which can be translated, using the map\n+//! M, into constraints in our source context. This process of\n+//! translating the results back is done by the\n+//! `instantiate_query_result` method.\n+//!\n+//! For a more detailed look at what is happening here, check\n+//! out the [chapter in the rustc guide][c].\n+//!\n+//! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n+\n+use crate::infer::region_constraints::MemberConstraint;\n+use crate::ty::subst::GenericArg;\n+use crate::ty::{self, BoundVar, List, Region, TyCtxt};\n+use rustc_index::vec::IndexVec;\n+use rustc_macros::HashStable;\n+use rustc_serialize::UseSpecializedDecodable;\n+use smallvec::SmallVec;\n+use std::ops::Index;\n+\n+/// A \"canonicalized\" type `V` is one where all free inference\n+/// variables have been rewritten to \"canonical vars\". These are\n+/// numbered starting from 0 in order of first appearance.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(HashStable, TypeFoldable, Lift)]\n+pub struct Canonical<'tcx, V> {\n+    pub max_universe: ty::UniverseIndex,\n+    pub variables: CanonicalVarInfos<'tcx>,\n+    pub value: V,\n+}\n+\n+pub type CanonicalVarInfos<'tcx> = &'tcx List<CanonicalVarInfo>;\n+\n+impl<'tcx> UseSpecializedDecodable for CanonicalVarInfos<'tcx> {}\n+\n+/// A set of values corresponding to the canonical variables from some\n+/// `Canonical`. You can give these values to\n+/// `canonical_value.substitute` to substitute them into the canonical\n+/// value at the right places.\n+///\n+/// When you canonicalize a value `V`, you get back one of these\n+/// vectors with the original values that were replaced by canonical\n+/// variables. You will need to supply it later to instantiate the\n+/// canonicalized query response.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(HashStable, TypeFoldable, Lift)]\n+pub struct CanonicalVarValues<'tcx> {\n+    pub var_values: IndexVec<BoundVar, GenericArg<'tcx>>,\n+}\n+\n+/// When we canonicalize a value to form a query, we wind up replacing\n+/// various parts of it with canonical variables. This struct stores\n+/// those replaced bits to remember for when we process the query\n+/// result.\n+#[derive(Clone, Debug)]\n+pub struct OriginalQueryValues<'tcx> {\n+    /// Map from the universes that appear in the query to the\n+    /// universes in the caller context. For the time being, we only\n+    /// ever put ROOT values into the query, so this map is very\n+    /// simple.\n+    pub universe_map: SmallVec<[ty::UniverseIndex; 4]>,\n+\n+    /// This is equivalent to `CanonicalVarValues`, but using a\n+    /// `SmallVec` yields a significant performance win.\n+    pub var_values: SmallVec<[GenericArg<'tcx>; 8]>,\n+}\n+\n+impl Default for OriginalQueryValues<'tcx> {\n+    fn default() -> Self {\n+        let mut universe_map = SmallVec::default();\n+        universe_map.push(ty::UniverseIndex::ROOT);\n+\n+        Self { universe_map, var_values: SmallVec::default() }\n+    }\n+}\n+\n+/// Information about a canonical variable that is included with the\n+/// canonical value. This is sufficient information for code to create\n+/// a copy of the canonical value in some other inference context,\n+/// with fresh inference variables replacing the canonical values.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n+pub struct CanonicalVarInfo {\n+    pub kind: CanonicalVarKind,\n+}\n+\n+impl CanonicalVarInfo {\n+    pub fn universe(&self) -> ty::UniverseIndex {\n+        self.kind.universe()\n+    }\n+\n+    pub fn is_existential(&self) -> bool {\n+        match self.kind {\n+            CanonicalVarKind::Ty(_) => true,\n+            CanonicalVarKind::PlaceholderTy(_) => false,\n+            CanonicalVarKind::Region(_) => true,\n+            CanonicalVarKind::PlaceholderRegion(..) => false,\n+            CanonicalVarKind::Const(_) => true,\n+            CanonicalVarKind::PlaceholderConst(_) => false,\n+        }\n+    }\n+}\n+\n+/// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n+/// in the type-theory sense of the term -- i.e., a \"meta\" type system\n+/// that analyzes type-like values.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n+pub enum CanonicalVarKind {\n+    /// Some kind of type inference variable.\n+    Ty(CanonicalTyVarKind),\n+\n+    /// A \"placeholder\" that represents \"any type\".\n+    PlaceholderTy(ty::PlaceholderType),\n+\n+    /// Region variable `'?R`.\n+    Region(ty::UniverseIndex),\n+\n+    /// A \"placeholder\" that represents \"any region\". Created when you\n+    /// are solving a goal like `for<'a> T: Foo<'a>` to represent the\n+    /// bound region `'a`.\n+    PlaceholderRegion(ty::PlaceholderRegion),\n+\n+    /// Some kind of const inference variable.\n+    Const(ty::UniverseIndex),\n+\n+    /// A \"placeholder\" that represents \"any const\".\n+    PlaceholderConst(ty::PlaceholderConst),\n+}\n+\n+impl CanonicalVarKind {\n+    pub fn universe(self) -> ty::UniverseIndex {\n+        match self {\n+            CanonicalVarKind::Ty(kind) => match kind {\n+                CanonicalTyVarKind::General(ui) => ui,\n+                CanonicalTyVarKind::Float | CanonicalTyVarKind::Int => ty::UniverseIndex::ROOT,\n+            },\n+\n+            CanonicalVarKind::PlaceholderTy(placeholder) => placeholder.universe,\n+            CanonicalVarKind::Region(ui) => ui,\n+            CanonicalVarKind::PlaceholderRegion(placeholder) => placeholder.universe,\n+            CanonicalVarKind::Const(ui) => ui,\n+            CanonicalVarKind::PlaceholderConst(placeholder) => placeholder.universe,\n+        }\n+    }\n+}\n+\n+/// Rust actually has more than one category of type variables;\n+/// notably, the type variables we create for literals (e.g., 22 or\n+/// 22.) can only be instantiated with integral/float types (e.g.,\n+/// usize or f32). In order to faithfully reproduce a type, we need to\n+/// know what set of types a given type variable can be unified with.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n+pub enum CanonicalTyVarKind {\n+    /// General type variable `?T` that can be unified with arbitrary types.\n+    General(ty::UniverseIndex),\n+\n+    /// Integral type variable `?I` (that can only be unified with integral types).\n+    Int,\n+\n+    /// Floating-point type variable `?F` (that can only be unified with float types).\n+    Float,\n+}\n+\n+/// After we execute a query with a canonicalized key, we get back a\n+/// `Canonical<QueryResponse<..>>`. You can use\n+/// `instantiate_query_result` to access the data in this result.\n+#[derive(Clone, Debug, HashStable, TypeFoldable, Lift)]\n+pub struct QueryResponse<'tcx, R> {\n+    pub var_values: CanonicalVarValues<'tcx>,\n+    pub region_constraints: QueryRegionConstraints<'tcx>,\n+    pub certainty: Certainty,\n+    pub value: R,\n+}\n+\n+#[derive(Clone, Debug, Default, HashStable, TypeFoldable, Lift)]\n+pub struct QueryRegionConstraints<'tcx> {\n+    pub outlives: Vec<QueryOutlivesConstraint<'tcx>>,\n+    pub member_constraints: Vec<MemberConstraint<'tcx>>,\n+}\n+\n+impl QueryRegionConstraints<'_> {\n+    /// Represents an empty (trivially true) set of region\n+    /// constraints.\n+    pub fn is_empty(&self) -> bool {\n+        self.outlives.is_empty() && self.member_constraints.is_empty()\n+    }\n+}\n+\n+pub type Canonicalized<'tcx, V> = Canonical<'tcx, V>;\n+\n+pub type CanonicalizedQueryResponse<'tcx, T> = &'tcx Canonical<'tcx, QueryResponse<'tcx, T>>;\n+\n+/// Indicates whether or not we were able to prove the query to be\n+/// true.\n+#[derive(Copy, Clone, Debug, HashStable)]\n+pub enum Certainty {\n+    /// The query is known to be true, presuming that you apply the\n+    /// given `var_values` and the region-constraints are satisfied.\n+    Proven,\n+\n+    /// The query is not known to be true, but also not known to be\n+    /// false. The `var_values` represent *either* values that must\n+    /// hold in order for the query to be true, or helpful tips that\n+    /// *might* make it true. Currently rustc's trait solver cannot\n+    /// distinguish the two (e.g., due to our preference for where\n+    /// clauses over impls).\n+    ///\n+    /// After some unifiations and things have been done, it makes\n+    /// sense to try and prove again -- of course, at that point, the\n+    /// canonical form will be different, making this a distinct\n+    /// query.\n+    Ambiguous,\n+}\n+\n+impl Certainty {\n+    pub fn is_proven(&self) -> bool {\n+        match self {\n+            Certainty::Proven => true,\n+            Certainty::Ambiguous => false,\n+        }\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+impl<'tcx, R> QueryResponse<'tcx, R> {\n+    pub fn is_proven(&self) -> bool {\n+        self.certainty.is_proven()\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+impl<'tcx, R> Canonical<'tcx, QueryResponse<'tcx, R>> {\n+    pub fn is_proven(&self) -> bool {\n+        self.value.is_proven()\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+impl<'tcx, V> Canonical<'tcx, V> {\n+    /// Allows you to map the `value` of a canonical while keeping the\n+    /// same set of bound variables.\n+    ///\n+    /// **WARNING:** This function is very easy to mis-use, hence the\n+    /// name!  In particular, the new value `W` must use all **the\n+    /// same type/region variables** in **precisely the same order**\n+    /// as the original! (The ordering is defined by the\n+    /// `TypeFoldable` implementation of the type in question.)\n+    ///\n+    /// An example of a **correct** use of this:\n+    ///\n+    /// ```rust,ignore (not real code)\n+    /// let a: Canonical<'_, T> = ...;\n+    /// let b: Canonical<'_, (T,)> = a.unchecked_map(|v| (v, ));\n+    /// ```\n+    ///\n+    /// An example of an **incorrect** use of this:\n+    ///\n+    /// ```rust,ignore (not real code)\n+    /// let a: Canonical<'tcx, T> = ...;\n+    /// let ty: Ty<'tcx> = ...;\n+    /// let b: Canonical<'tcx, (T, Ty<'tcx>)> = a.unchecked_map(|v| (v, ty));\n+    /// ```\n+    pub fn unchecked_map<W>(self, map_op: impl FnOnce(V) -> W) -> Canonical<'tcx, W> {\n+        let Canonical { max_universe, variables, value } = self;\n+        Canonical { max_universe, variables, value: map_op(value) }\n+    }\n+}\n+\n+pub type QueryOutlivesConstraint<'tcx> =\n+    ty::Binder<ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>;\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    crate::infer::canonical::Certainty,\n+    crate::infer::canonical::CanonicalVarInfo,\n+    crate::infer::canonical::CanonicalVarKind,\n+}\n+\n+CloneTypeFoldableImpls! {\n+    for <'tcx> {\n+        crate::infer::canonical::CanonicalVarInfos<'tcx>,\n+    }\n+}\n+\n+impl<'tcx> CanonicalVarValues<'tcx> {\n+    pub fn len(&self) -> usize {\n+        self.var_values.len()\n+    }\n+\n+    /// Makes an identity substitution from this one: each bound var\n+    /// is matched to the same bound var, preserving the original kinds.\n+    /// For example, if we have:\n+    /// `self.var_values == [Type(u32), Lifetime('a), Type(u64)]`\n+    /// we'll return a substitution `subst` with:\n+    /// `subst.var_values == [Type(^0), Lifetime(^1), Type(^2)]`.\n+    pub fn make_identity(&self, tcx: TyCtxt<'tcx>) -> Self {\n+        use crate::ty::subst::GenericArgKind;\n+\n+        CanonicalVarValues {\n+            var_values: self\n+                .var_values\n+                .iter()\n+                .zip(0..)\n+                .map(|(kind, i)| match kind.unpack() {\n+                    GenericArgKind::Type(..) => {\n+                        tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i).into())).into()\n+                    }\n+                    GenericArgKind::Lifetime(..) => tcx\n+                        .mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(i)))\n+                        .into(),\n+                    GenericArgKind::Const(ct) => tcx\n+                        .mk_const(ty::Const {\n+                            ty: ct.ty,\n+                            val: ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i)),\n+                        })\n+                        .into(),\n+                })\n+                .collect(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> IntoIterator for &'a CanonicalVarValues<'tcx> {\n+    type Item = GenericArg<'tcx>;\n+    type IntoIter = ::std::iter::Cloned<::std::slice::Iter<'a, GenericArg<'tcx>>>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.var_values.iter().cloned()\n+    }\n+}\n+\n+impl<'tcx> Index<BoundVar> for CanonicalVarValues<'tcx> {\n+    type Output = GenericArg<'tcx>;\n+\n+    fn index(&self, value: BoundVar) -> &GenericArg<'tcx> {\n+        &self.var_values[value]\n+    }\n+}"}, {"sha": "534f4cb179c4f78eb7d2e5f183b55343e69fc74e", "filename": "src/librustc/infer/types/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/005f14d51809e385eb396bb2c1a115cf9ba21872/src%2Flibrustc%2Finfer%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/005f14d51809e385eb396bb2c1a115cf9ba21872/src%2Flibrustc%2Finfer%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftypes%2Fmod.rs?ref=005f14d51809e385eb396bb2c1a115cf9ba21872", "patch": "@@ -1,3 +1,5 @@\n+pub mod canonical;\n+\n use crate::ty::Region;\n use crate::ty::Ty;\n use rustc_data_structures::sync::Lrc;"}]}