{"sha": "ae8ba88424652a0d263f193cd9c31e024a000546", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlOGJhODg0MjQ2NTJhMGQyNjNmMTkzY2Q5YzMxZTAyNGEwMDA1NDY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-11-29T04:09:12Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-12T06:11:59Z"}, "message": "Mostly non-behaviour-changing changes (style, etc.)", "tree": {"sha": "d239a149222447ca517f955e847185f9480f8a3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d239a149222447ca517f955e847185f9480f8a3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae8ba88424652a0d263f193cd9c31e024a000546", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae8ba88424652a0d263f193cd9c31e024a000546", "html_url": "https://github.com/rust-lang/rust/commit/ae8ba88424652a0d263f193cd9c31e024a000546", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae8ba88424652a0d263f193cd9c31e024a000546/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "397dda8aa08ee540cffd36f542ebd1140227d0bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/397dda8aa08ee540cffd36f542ebd1140227d0bd", "html_url": "https://github.com/rust-lang/rust/commit/397dda8aa08ee540cffd36f542ebd1140227d0bd"}], "stats": {"total": 173, "additions": 82, "deletions": 91}, "files": [{"sha": "4acda5bf659f32259bb5a5cc0dd16b75fa4fa010", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=ae8ba88424652a0d263f193cd9c31e024a000546", "patch": "@@ -435,7 +435,7 @@ pub fn get_symbol(data: &[u8], id: ast::NodeId) -> String {\n }\n \n // Something that a name can resolve to.\n-#[deriving(Clone)]\n+#[deriving(Clone,Show)]\n pub enum DefLike {\n     DlDef(def::Def),\n     DlImpl(ast::DefId),"}, {"sha": "59bda245f923305ae45cddc0c973be974ce6a50d", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=ae8ba88424652a0d263f193cd9c31e024a000546", "patch": "@@ -108,7 +108,7 @@ pub type ExportMap2 = NodeMap<Vec<Export2>>;\n \n pub struct Export2 {\n     pub name: String,        // The name of the target.\n-    pub def_id: DefId,     // The definition of the target.\n+    pub def_id: DefId,       // The definition of the target.\n }\n \n // This set contains all exported definitions from external crates. The set does\n@@ -314,7 +314,7 @@ impl<'a> Copy for TypeParameters<'a> {}\n \n // The rib kind controls the translation of local\n // definitions (`DefLocal`) to upvars (`DefUpvar`).\n-\n+#[deriving(Show)]\n enum RibKind {\n     // No translation needs to be applied.\n     NormalRibKind,\n@@ -340,6 +340,7 @@ enum RibKind {\n impl Copy for RibKind {}\n \n // Methods can be required or provided. RequiredMethod methods only occur in traits.\n+#[deriving(Show)]\n enum MethodSort {\n     RequiredMethod,\n     ProvidedMethod(NodeId)\n@@ -414,6 +415,7 @@ enum DuplicateCheckingMode {\n impl Copy for DuplicateCheckingMode {}\n \n /// One local scope.\n+#[deriving(Show)]\n struct Rib {\n     bindings: HashMap<Name, DefLike>,\n     kind: RibKind,\n@@ -728,8 +730,11 @@ impl NameBindings {\n         let type_def = self.type_def.borrow().clone();\n         match type_def {\n             None => {\n-                let module = Module::new(parent_link, def_id, kind,\n-                                         external, is_public);\n+                let module = Module::new(parent_link,\n+                                         def_id,\n+                                         kind,\n+                                         external,\n+                                         is_public);\n                 *self.type_def.borrow_mut() = Some(TypeNsDef {\n                     modifiers: modifiers,\n                     module_def: Some(Rc::new(module)),\n@@ -774,9 +779,9 @@ impl NameBindings {\n             }\n             Some(type_def) => {\n                 *self.type_def.borrow_mut() = Some(TypeNsDef {\n+                    module_def: type_def.module_def,\n                     type_def: Some(def),\n                     type_span: Some(sp),\n-                    module_def: type_def.module_def,\n                     modifiers: modifiers,\n                 });\n             }\n@@ -1286,7 +1291,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn get_parent_link(&mut self, parent: ReducedGraphParent, name: Name)\n-                           -> ParentLink {\n+                       -> ParentLink {\n         match parent {\n             ModuleReducedGraphParent(module_) => {\n                 return ModuleParentLink(module_.downgrade(), name);\n@@ -1578,14 +1583,14 @@ impl<'a> Resolver<'a> {\n \n             ItemImpl(_, Some(_), _, _) => parent,\n \n-            ItemTrait(_, _, _, ref methods) => {\n+            ItemTrait(_, _, _, ref items) => {\n                 let name_bindings =\n                     self.add_child(name,\n                                    parent.clone(),\n                                    ForbidDuplicateTypesAndModules,\n                                    sp);\n \n-                // Add all the methods within to a new module.\n+                // Add all the items within to a new module.\n                 let parent_link = self.get_parent_link(parent.clone(), name);\n                 name_bindings.define_module(parent_link,\n                                             Some(local_def(item.id)),\n@@ -1598,13 +1603,12 @@ impl<'a> Resolver<'a> {\n \n                 let def_id = local_def(item.id);\n \n-                // Add the names of all the methods to the trait info.\n-                for method in methods.iter() {\n-                    let (name, kind) = match *method {\n+                // Add the names of all the items to the trait info.\n+                for trait_item in items.iter() {\n+                    let (name, kind) = match *trait_item {\n                         ast::RequiredMethod(_) |\n                         ast::ProvidedMethod(_) => {\n-                            let ty_m =\n-                                ast_util::trait_item_to_ty_method(method);\n+                            let ty_m = ast_util::trait_item_to_ty_method(trait_item);\n \n                             let name = ty_m.ident.name;\n \n@@ -3353,7 +3357,7 @@ impl<'a> Resolver<'a> {\n                            use_lexical_scope: UseLexicalScopeFlag,\n                            span: Span,\n                            name_search_type: NameSearchType)\n-                               -> ResolveResult<(Rc<Module>, LastPrivate)> {\n+                           -> ResolveResult<(Rc<Module>, LastPrivate)> {\n         let module_path_len = module_path.len();\n         assert!(module_path_len > 0);\n \n@@ -3382,7 +3386,9 @@ impl<'a> Resolver<'a> {\n                                             mpath.slice_to(idx - 1));\n                         return Failed(Some((span, msg)));\n                     },\n-                    None => return Failed(None),\n+                    None => {\n+                        return Failed(None)\n+                    }\n                 }\n             }\n             Failed(err) => return Failed(err),\n@@ -3575,8 +3581,7 @@ impl<'a> Resolver<'a> {\n                                 -> ResolveResult<Rc<Module>> {\n         // If this module is an anonymous module, resolve the item in the\n         // lexical scope. Otherwise, resolve the item from the crate root.\n-        let resolve_result = self.resolve_item_in_lexical_scope(\n-            module_, name, TypeNS);\n+        let resolve_result = self.resolve_item_in_lexical_scope(module_, name, TypeNS);\n         match resolve_result {\n             Success((target, _)) => {\n                 let bindings = &*target.bindings;\n@@ -5327,15 +5332,15 @@ impl<'a> Resolver<'a> {\n \n     // resolve a single identifier (used as a varref)\n     fn resolve_identifier(&mut self,\n-                              identifier: Ident,\n-                              namespace: Namespace,\n-                              check_ribs: bool,\n-                              span: Span)\n-                              -> Option<(Def, LastPrivate)> {\n+                          identifier: Ident,\n+                          namespace: Namespace,\n+                          check_ribs: bool,\n+                          span: Span)\n+                          -> Option<(Def, LastPrivate)> {\n         if check_ribs {\n             match self.resolve_identifier_in_local_ribs(identifier,\n-                                                      namespace,\n-                                                      span) {\n+                                                        namespace,\n+                                                        span) {\n                 Some(def) => {\n                     return Some((def, LastMod(AllPublic)));\n                 }\n@@ -5353,7 +5358,7 @@ impl<'a> Resolver<'a> {\n                                             containing_module: Rc<Module>,\n                                             name: Name,\n                                             namespace: Namespace)\n-                                                -> NameDefinition {\n+                                            -> NameDefinition {\n         // First, search children.\n         self.populate_module_if_necessary(&containing_module);\n \n@@ -5423,9 +5428,9 @@ impl<'a> Resolver<'a> {\n \n     // resolve a \"module-relative\" path, e.g. a::b::c\n     fn resolve_module_relative_path(&mut self,\n-                                        path: &Path,\n-                                        namespace: Namespace)\n-                                        -> Option<(Def, LastPrivate)> {\n+                                    path: &Path,\n+                                    namespace: Namespace)\n+                                    -> Option<(Def, LastPrivate)> {\n         let module_path = path.segments.init().iter()\n                                               .map(|ps| ps.identifier.name)\n                                               .collect::<Vec<_>>();\n@@ -5442,9 +5447,8 @@ impl<'a> Resolver<'a> {\n                 let (span, msg) = match err {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n-                        let msg = format!(\"Use of undeclared module `{}`\",\n-                                          self.names_to_string(\n-                                               module_path.as_slice()));\n+                        let msg = format!(\"Use of undeclared type or module `{}`\",\n+                                          self.names_to_string(module_path.as_slice()));\n                         (path.span, msg)\n                     }\n                 };\n@@ -5538,10 +5542,10 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_identifier_in_local_ribs(&mut self,\n-                                            ident: Ident,\n-                                            namespace: Namespace,\n-                                            span: Span)\n-                                            -> Option<Def> {\n+                                        ident: Ident,\n+                                        namespace: Namespace,\n+                                        span: Span)\n+                                        -> Option<Def> {\n         // Check the local set of ribs.\n         let search_result = match namespace {\n             ValueNS => {"}, {"sha": "d3b1c2d2afc4d0174f7c6336bf53ffb1b8972413", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=ae8ba88424652a0d263f193cd9c31e024a000546", "patch": "@@ -112,7 +112,7 @@ impl<'tcx> Substs<'tcx> {\n         }\n     }\n \n-pub fn self_ty(&self) -> Option<Ty<'tcx>> {\n+    pub fn self_ty(&self) -> Option<Ty<'tcx>> {\n         self.types.get_self().map(|&t| t)\n     }\n "}, {"sha": "159b6961782c04a55c4015aeedd8c024ef35de49", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=ae8ba88424652a0d263f193cd9c31e024a000546", "patch": "@@ -139,7 +139,7 @@ impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n }\n \n // determine the `self` type, using fresh variables for all variables\n-// declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`\n+// declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n pub fn fresh_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,"}, {"sha": "3f555ec5c4cbe1b6e6598699f09ec74ce953afbc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ae8ba88424652a0d263f193cd9c31e024a000546", "patch": "@@ -1613,7 +1613,7 @@ pub struct RegionParameterDef {\n     pub bounds: Vec<ty::Region>,\n }\n \n-/// Information about the type/lifetime parameters associated with an\n+/// Information about the formal type/lifetime parameters associated with an\n /// item or method. Analogous to ast::Generics.\n #[deriving(Clone, Show)]\n pub struct Generics<'tcx> {"}, {"sha": "b65dbff2f6106c7d323fa5c93bb1bb833853e3fd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ae8ba88424652a0d263f193cd9c31e024a000546", "patch": "@@ -522,16 +522,6 @@ fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n     vec![input_ty, output]\n }\n \n-pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n-    this: &AC,\n-    rscope: &RS,\n-    ast_trait_ref: &ast::PolyTraitRef,\n-    self_ty: Option<Ty<'tcx>>)\n-    -> Rc<ty::TraitRef<'tcx>>\n-    where AC: AstConv<'tcx>, RS: RegionScope\n-{\n-    instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty)\n-}\n \n /// Instantiates the path for the given trait reference, assuming that it's bound to a valid trait\n /// type. Returns the def_id for the defining trait. Fails if the type is a type other than a trait\n@@ -637,7 +627,6 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                         rscope,\n                                         did,\n                                         &generics,\n-                                        None,\n                                         path);\n     let ty = decl_ty.subst(tcx, &substs);\n     TypeAndSubsts { substs: substs, ty: ty }\n@@ -678,7 +667,7 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n         Substs::new(VecPerParamSpace::params_from_type(type_params),\n                     VecPerParamSpace::params_from_type(region_params))\n     } else {\n-        ast_path_substs_for_ty(this, rscope, did, &generics, None, path)\n+        ast_path_substs_for_ty(this, rscope, did, &generics, path)\n     };\n \n     let ty = decl_ty.subst(tcx, &substs);\n@@ -777,7 +766,7 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n             }\n         }\n         _ => {\n-            span_err!(this.tcx().sess, ty.span, E0171,\n+            span_err!(this.tcx().sess, ty.span, E0178,\n                       \"expected a path on the left-hand side of `+`, not `{}`\",\n                       pprust::ty_to_string(ty));\n             match ty.node {\n@@ -788,8 +777,7 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                pprust::ty_to_string(&*mut_ty.ty),\n                                pprust::bounds_to_string(bounds));\n                 }\n-\n-                ast::TyRptr(Some(ref lt), ref mut_ty) => {\n+               ast::TyRptr(Some(ref lt), ref mut_ty) => {\n                     span_note!(this.tcx().sess, ty.span,\n                                \"perhaps you meant `&{} {}({} +{})`? (per RFC 248)\",\n                                pprust::lifetime_to_string(lt),\n@@ -806,7 +794,6 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n             Err(ErrorReported)\n         }\n     }\n-\n }\n \n fn trait_ref_to_object_type<'tcx,AC,RS>(this: &AC,"}, {"sha": "cc60b2962677a7efe6b4d3d183a9a3d8662242c4", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ae8ba88424652a0d263f193cd9c31e024a000546", "patch": "@@ -1020,7 +1020,7 @@ fn get_method_index<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // iterating down the supertraits of the object's trait until\n     // we find the trait the method came from, counting up the\n     // methods from them.\n-    let mut method_count = 0;\n+    let mut method_count = n_method;\n     ty::each_bound_trait_and_supertraits(tcx, &[subtrait], |bound_ref| {\n         if bound_ref.def_id == trait_ref.def_id {\n             false\n@@ -1035,7 +1035,7 @@ fn get_method_index<'tcx>(tcx: &ty::ctxt<'tcx>,\n             true\n         }\n     });\n-    method_count + n_method\n+    method_count\n }\n \n impl<'tcx> Candidate<'tcx> {"}, {"sha": "80ea8d9026856c2075309ce76009924d8042dcae", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ae8ba88424652a0d263f193cd9c31e024a000546", "patch": "@@ -5355,6 +5355,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         region_count,\n                         data.lifetimes.len());\n                     substs.mut_regions().truncate(space, 0);\n+                    break;\n                 }\n             }\n         }"}, {"sha": "0830bd476a2e552907c8be882520e174f0642465", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8ba88424652a0d263f193cd9c31e024a000546/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ae8ba88424652a0d263f193cd9c31e024a000546", "patch": "@@ -663,48 +663,43 @@ fn is_associated_type_valid_for_param(ty: Ty,\n \n fn find_associated_type_in_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                           span: Span,\n-                                          ty: Option<Ty<'tcx>>,\n+                                          self_ty: Option<Ty<'tcx>>,\n                                           associated_type_id: ast::DefId,\n                                           generics: &ty::Generics<'tcx>)\n-                                          -> Ty<'tcx>\n+                                          -> Option<Ty<'tcx>>\n {\n     debug!(\"find_associated_type_in_generics(ty={}, associated_type_id={}, generics={}\",\n-           ty.repr(tcx), associated_type_id.repr(tcx), generics.repr(tcx));\n+           self_ty.repr(tcx), associated_type_id.repr(tcx), generics.repr(tcx));\n \n-    let ty = match ty {\n+    let self_ty = match self_ty {\n         None => {\n-            tcx.sess.span_bug(span,\n-                              \"find_associated_type_in_generics(): no self \\\n-                               type\")\n+            return None;\n         }\n         Some(ty) => ty,\n     };\n \n-    match ty.sty {\n+    match self_ty.sty {\n         ty::ty_param(ref param_ty) => {\n-            /*let type_parameter = generics.types.get(param_ty.space,\n-                                                    param_ty.idx);\n-            let param_id = type_parameter.def_id;*/\n             let param_id = param_ty.def_id;\n             for type_parameter in generics.types.iter() {\n                 if type_parameter.def_id == associated_type_id\n                     && type_parameter.associated_with == Some(param_id) {\n-                    return ty::mk_param_from_def(tcx, type_parameter);\n+                    return Some(ty::mk_param_from_def(tcx, type_parameter));\n                 }\n             }\n \n             tcx.sess.span_err(\n                 span,\n                 format!(\"no suitable bound on `{}`\",\n-                        ty.user_string(tcx))[]);\n-            ty::mk_err()\n+                        self_ty.user_string(tcx))[]);\n+            Some(ty::mk_err())\n         }\n         _ => {\n             tcx.sess.span_err(\n                 span,\n                 \"it is currently unsupported to access associated types except \\\n                  through a type parameter; this restriction will be lifted in time\");\n-            ty::mk_err()\n+            Some(ty::mk_err())\n         }\n     }\n }\n@@ -762,16 +757,16 @@ impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty<'tcx>>,\n+                               self_ty: Option<Ty<'tcx>>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty<'tcx>\n+                               -> Option<Ty<'tcx>>\n     {\n-        let trait_def = ty::lookup_trait_def(self.tcx(), trait_id);\n         match self.opt_trait_ref_id {\n+            // It's an associated type on the trait that we're\n+            // implementing.\n             Some(trait_ref_id) if trait_ref_id == trait_id => {\n-                // It's an associated type on the trait that we're\n-                // implementing.\n+                let trait_def = ty::lookup_trait_def(self.tcx(), trait_id);\n                 assert!(trait_def.generics.types\n                         .get_slice(subst::AssocSpace)\n                         .iter()\n@@ -801,7 +796,7 @@ impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n         // our bounds.\n         find_associated_type_in_generics(self.ccx.tcx,\n                                          span,\n-                                         ty,\n+                                         self_ty,\n                                          associated_type_id,\n                                          self.impl_generics)\n     }\n@@ -840,17 +835,17 @@ impl<'a,'tcx> AstConv<'tcx> for FnCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty<'tcx>>,\n+                               self_ty: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty<'tcx> {\n+                               -> Option<Ty<'tcx>> {\n         debug!(\"collect::FnCtxt::associated_type_binding()\");\n \n         // The ID should map to an associated type on one of the traits in\n         // our bounds.\n         find_associated_type_in_generics(self.ccx.tcx,\n                                          span,\n-                                         ty,\n+                                         self_ty,\n                                          associated_type_id,\n                                          self.generics)\n     }\n@@ -887,17 +882,17 @@ impl<'a,'tcx> AstConv<'tcx> for ImplMethodCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty<'tcx>>,\n+                               self_ty: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty<'tcx> {\n+                               -> Option<Ty<'tcx>> {\n         debug!(\"collect::ImplMethodCtxt::associated_type_binding()\");\n \n         // The ID should map to an associated type on one of the traits in\n         // our bounds.\n         find_associated_type_in_generics(self.ccx.tcx,\n                                          span,\n-                                         ty,\n+                                         self_ty,\n                                          associated_type_id,\n                                          self.method_generics)\n     }\n@@ -979,7 +974,7 @@ impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n         // our bounds.\n         find_associated_type_in_generics(self.ccx.tcx,\n                                          span,\n-                                         ty,\n+                                         self_ty,\n                                          associated_type_id,\n                                          self.method_generics)\n     }\n@@ -1020,17 +1015,17 @@ impl<'a,'tcx,AC:AstConv<'tcx>> AstConv<'tcx> for GenericsCtxt<'a,'tcx,AC> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty<'tcx>>,\n+                               self_ty: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty<'tcx> {\n+                               -> Option<Ty<'tcx>> {\n         debug!(\"collect::GenericsCtxt::associated_type_binding()\");\n \n         // The ID should map to an associated type on one of the traits in\n         // our bounds.\n         find_associated_type_in_generics(self.chain.tcx(),\n                                          span,\n-                                         ty,\n+                                         self_ty,\n                                          associated_type_id,\n                                          self.associated_types_generics)\n     }\n@@ -1364,8 +1359,12 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let self_param_ty = ty::ParamTy::for_self(def_id);\n \n-    let bounds = compute_bounds(ccx, token::SELF_KEYWORD_NAME, self_param_ty,\n-                                bounds.as_slice(), unbound, it.span,\n+    let bounds = compute_bounds(ccx,\n+                                token::SELF_KEYWORD_NAME,\n+                                self_param_ty,\n+                                bounds.as_slice(),\n+                                unbound,\n+                                it.span,\n                                 &generics.where_clause);\n \n     let substs = mk_item_substs(ccx, &ty_generics);\n@@ -1791,7 +1790,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n \n     return result;\n \n-    fn create_type_parameters_for_associated_types<'tcx,AC>(\n+    fn create_type_parameters_for_associated_types<'tcx, AC>(\n         this: &AC,\n         space: subst::ParamSpace,\n         types: &[ast::TyParam],"}]}