{"sha": "d88497ddf2f4a26f6328561a070ab4dd4a053bd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ODQ5N2RkZjJmNGEyNmY2MzI4NTYxYTA3MGFiNGRkNGEwNTNiZDE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-10T02:04:17Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-10T02:04:30Z"}, "message": "tutorial: Overhaul task section", "tree": {"sha": "5c1736fe81bcfa488e8e517790ccc65b8120bfee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c1736fe81bcfa488e8e517790ccc65b8120bfee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d88497ddf2f4a26f6328561a070ab4dd4a053bd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d88497ddf2f4a26f6328561a070ab4dd4a053bd1", "html_url": "https://github.com/rust-lang/rust/commit/d88497ddf2f4a26f6328561a070ab4dd4a053bd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d88497ddf2f4a26f6328561a070ab4dd4a053bd1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "172bf3a03851fee9ddbc808c3a526744c138f767", "url": "https://api.github.com/repos/rust-lang/rust/commits/172bf3a03851fee9ddbc808c3a526744c138f767", "html_url": "https://github.com/rust-lang/rust/commit/172bf3a03851fee9ddbc808c3a526744c138f767"}], "stats": {"total": 113, "additions": 63, "deletions": 50}, "files": [{"sha": "8f44bdb34817c58de955c598eca41289425049eb", "filename": "doc/tutorial.md", "status": "modified", "additions": 63, "deletions": 50, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/d88497ddf2f4a26f6328561a070ab4dd4a053bd1/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/d88497ddf2f4a26f6328561a070ab4dd4a053bd1/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=d88497ddf2f4a26f6328561a070ab4dd4a053bd1", "patch": "@@ -2830,8 +2830,8 @@ supposed to point at, this is safe.\n Rust supports a system of lightweight tasks, similar to what is found\n in Erlang or other actor systems. Rust tasks communicate via messages\n and do not share data. However, it is possible to send data without\n-copying it by making use of [unique boxes](#unique-boxes), which allow\n-the sending task to release ownership of a value, so that the\n+copying it by making use of [the exchange heap](#unique-boxes), which\n+allow the sending task to release ownership of a value, so that the\n receiving task can keep on using it.\n \n > ***Note:*** As Rust evolves, we expect the task API to grow and\n@@ -2843,10 +2843,13 @@ Spawning a task is done using the various spawn functions in the\n module `task`.  Let's begin with the simplest one, `task::spawn()`:\n \n ~~~~\n+import task::spawn;\n+import io::println;\n+\n let some_value = 22;\n-do task::spawn {\n-    io::println(\"This executes in the child task.\");\n-    io::println(#fmt(\"%d\", some_value));\n+do spawn {\n+    println(\"This executes in the child task.\");\n+    println(#fmt(\"%d\", some_value));\n }\n ~~~~\n \n@@ -2866,44 +2869,54 @@ For example, imagine we wish to perform two expensive computations\n in parallel.  We might write something like:\n \n ~~~~\n-# fn some_expensive_computation() -> int { 42 }\n-# fn some_other_expensive_computation() {}\n-let port = comm::port::<int>();\n-let chan = comm::chan::<int>(port);\n-do task::spawn {\n+import task::spawn;\n+import comm::{port, chan, methods};\n+\n+let port = port();\n+let chan = port.chan();\n+\n+do spawn {\n     let result = some_expensive_computation();\n-    comm::send(chan, result);\n+    chan.send(result);\n }\n+\n some_other_expensive_computation();\n-let result = comm::recv(port);\n+let result = port.recv();\n+\n+# fn some_expensive_computation() -> int { 42 }\n+# fn some_other_expensive_computation() {}\n ~~~~\n \n Let's walk through this code line-by-line.  The first line creates a\n port for receiving integers:\n \n+~~~~ {.ignore}\n+# import comm::port;\n+let port = port();\n ~~~~\n-let port = comm::port::<int>();\n \n-~~~~\n This port is where we will receive the message from the child task\n once it is complete.  The second line creates a channel for sending\n integers to the port `port`:\n \n ~~~~\n-# let port = comm::port::<int>();\n-let chan = comm::chan::<int>(port);\n+# import comm::{port, chan, methods};\n+# let port = port::<int>();\n+let chan = port.chan();\n ~~~~\n \n The channel will be used by the child to send a message to the port.\n The next statement actually spawns the child:\n \n ~~~~\n+# import task::{spawn};\n+# import comm::{port, chan, methods};\n # fn some_expensive_computation() -> int { 42 }\n-# let port = comm::port::<int>();\n-# let chan = comm::chan::<int>(port);\n-do task::spawn {\n+# let port = port();\n+# let chan = port.chan();\n+do spawn {\n     let result = some_expensive_computation();\n-    comm::send(chan, result);\n+    chan.send(result);\n }\n ~~~~\n \n@@ -2913,12 +2926,13 @@ some other expensive computation and then waiting for the child's result\n to arrive on the port:\n \n ~~~~\n+# import comm::{port, chan, methods};\n # fn some_other_expensive_computation() {}\n-# let port = comm::port::<int>();\n-# let chan = comm::chan::<int>(port);\n-# comm::send(chan, 0);\n+# let port = port::<int>();\n+# let chan = chan::<int>(port);\n+# chan.send(0);\n some_other_expensive_computation();\n-let result = comm::recv(port);\n+let result = port.recv();\n ~~~~\n \n ## Creating a task with a bi-directional communication path\n@@ -2934,12 +2948,13 @@ the string in response.  The child terminates when `0` is received.\n Here is the function which implements the child task:\n \n ~~~~\n-fn stringifier(from_parent: comm::port<uint>,\n-               to_parent: comm::chan<str>) {\n+# import comm::{port, chan, methods};\n+fn stringifier(from_parent: port<uint>,\n+               to_parent: chan<str>) {\n     let mut value: uint;\n     loop {\n-        value = comm::recv(from_parent);\n-        comm::send(to_parent, uint::to_str(value, 10u));\n+        value = from_parent.recv();\n+        to_parent.send(uint::to_str(value, 10u));\n         if value == 0u { break; }\n     }\n }\n@@ -2956,25 +2971,32 @@ simply the strified version of the received value,\n Here is the code for the parent task:\n \n ~~~~\n+# import task::{spawn_listener};\n+# import comm::{chan, port, methods};\n # fn stringifier(from_parent: comm::port<uint>,\n #                to_parent: comm::chan<str>) {\n #     comm::send(to_parent, \"22\");\n #     comm::send(to_parent, \"23\");\n #     comm::send(to_parent, \"0\");\n # }\n-fn main() {\n-    let from_child = comm::port();\n-    let to_parent = comm::chan(from_child);\n-    let to_child = do task::spawn_listener |from_parent| {\n-        stringifier(from_parent, to_parent);\n-    };\n-    comm::send(to_child, 22u);\n-    assert comm::recv(from_child) == \"22\";\n-    comm::send(to_child, 23u);\n-    assert comm::recv(from_child) == \"23\";\n-    comm::send(to_child, 0u);\n-    assert comm::recv(from_child) == \"0\";\n-}\n+# fn main() {\n+\n+let from_child = port();\n+let to_parent = from_child.chan();\n+let to_child = do spawn_listener |from_parent| {\n+    stringifier(from_parent, to_parent);\n+};\n+\n+to_child.send(22u);\n+assert from_child.recv() == \"22\";\n+\n+to_child.send(23u);\n+assert from_child.recv() == \"23\";\n+\n+to_child.send(0u);\n+assert from_child.recv() == \"0\";\n+\n+# }\n ~~~~\n \n The parent first sets up a port to receive data from and a channel\n@@ -2986,15 +3008,6 @@ the associated channel. Finally, the closure passed to\n `to_parent` channel in its environment, so both parent and child\n can send and receive data to and from the other.\n \n-## The supervisor relationship\n-\n-By default, failures in Rust propagate upward through the task tree.\n-We say that each task is supervised by its parent, meaning that if the\n-task fails, that failure is propagated to the parent task, which will\n-fail sometime later.  This propagation can be disabled by using the\n-function `task::unsupervise()`, which disables error propagation from\n-the current task to its parent.\n-\n # Testing\n \n The Rust language has a facility for testing built into the language."}]}