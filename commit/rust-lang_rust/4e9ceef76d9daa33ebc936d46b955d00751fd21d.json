{"sha": "4e9ceef76d9daa33ebc936d46b955d00751fd21d", "node_id": "C_kwDOAAsO6NoAKDRlOWNlZWY3NmQ5ZGFhMzNlYmM5MzZkNDZiOTU1ZDAwNzUxZmQyMWQ", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-13T12:02:52Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-19T19:07:18Z"}, "message": "Refactor `must_use` lint into two parts\n\nBefore, the lint did the checking for `must_use` and pretty printing the\ntypes in a special format in one pass, causing quite complex and\nuntranslatable code.\nNow the collection and printing is split in two. That should also make\nit easier to translate or extract the type pretty printing in the\nfuture.\n\nAlso fixes an integer overflow in the array length pluralization\ncalculation.", "tree": {"sha": "252768f211cfaecc9e0461717f243c6a71bec011", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/252768f211cfaecc9e0461717f243c6a71bec011"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e9ceef76d9daa33ebc936d46b955d00751fd21d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAADMAAAALc3NoLWVkMjU1MTkAAAAgbSfWKRQb2tiqhuHtakDJeupmrF\nChDbM0msU+PXaBOk8AAAADZ2l0AAAAAAAAAAZzaGE1MTIAAABTAAAAC3NzaC1lZDI1NTE5\nAAAAQNLnUsztyhKZpQ1/P5+Sv58T/Dq81X/CeEqrxZQutmpUfM3gqbYxkOYX1O8G+s+WcH\ndaQZ+bnQA8kpHF85o1cgo=\n-----END SSH SIGNATURE-----", "payload": "tree 252768f211cfaecc9e0461717f243c6a71bec011\nparent 62c627c7a3a9b3e193a5ae6e1ec7348bc5136301\nauthor Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1668340972 +0100\ncommitter Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1668884838 +0100\n\nRefactor `must_use` lint into two parts\n\nBefore, the lint did the checking for `must_use` and pretty printing the\ntypes in a special format in one pass, causing quite complex and\nuntranslatable code.\nNow the collection and printing is split in two. That should also make\nit easier to translate or extract the type pretty printing in the\nfuture.\n\nAlso fixes an integer overflow in the array length pluralization\ncalculation.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e9ceef76d9daa33ebc936d46b955d00751fd21d", "html_url": "https://github.com/rust-lang/rust/commit/4e9ceef76d9daa33ebc936d46b955d00751fd21d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e9ceef76d9daa33ebc936d46b955d00751fd21d/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62c627c7a3a9b3e193a5ae6e1ec7348bc5136301", "url": "https://api.github.com/repos/rust-lang/rust/commits/62c627c7a3a9b3e193a5ae6e1ec7348bc5136301", "html_url": "https://github.com/rust-lang/rust/commit/62c627c7a3a9b3e193a5ae6e1ec7348bc5136301"}], "stats": {"total": 405, "additions": 259, "deletions": 146}, "files": [{"sha": "5c4c46f84d7178426f93e78f57dcdfebd52ecfd4", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 203, "deletions": 113, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/4e9ceef76d9daa33ebc936d46b955d00751fd21d/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9ceef76d9daa33ebc936d46b955d00751fd21d/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=4e9ceef76d9daa33ebc936d46b955d00751fd21d", "patch": "@@ -13,6 +13,7 @@ use rustc_middle::ty::{self, DefIdTree, Ty};\n use rustc_span::symbol::Symbol;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{BytePos, Span};\n+use std::iter;\n \n declare_lint! {\n     /// The `unused_must_use` lint detects unused result of a type flagged as\n@@ -113,30 +114,19 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n         }\n \n         let ty = cx.typeck_results().expr_ty(&expr);\n-        let type_permits_lack_of_use = check_must_use_ty(cx, ty, &expr, expr.span, \"\", \"\", 1);\n \n-        let mut fn_warned = false;\n-        let mut op_warned = false;\n-        let maybe_def_id = match expr.kind {\n-            hir::ExprKind::Call(ref callee, _) => {\n-                match callee.kind {\n-                    hir::ExprKind::Path(ref qpath) => {\n-                        match cx.qpath_res(qpath, callee.hir_id) {\n-                            Res::Def(DefKind::Fn | DefKind::AssocFn, def_id) => Some(def_id),\n-                            // `Res::Local` if it was a closure, for which we\n-                            // do not currently support must-use linting\n-                            _ => None,\n-                        }\n-                    }\n-                    _ => None,\n-                }\n+        let must_use_result = is_ty_must_use(cx, ty, &expr, expr.span);\n+        let type_lint_emitted_or_suppressed = match must_use_result {\n+            Some(path) => {\n+                emit_must_use_untranslated(cx, &path, \"\", \"\", 1);\n+                true\n             }\n-            hir::ExprKind::MethodCall(..) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n-            _ => None,\n+            None => false,\n         };\n-        if let Some(def_id) = maybe_def_id {\n-            fn_warned = check_must_use_def(cx, def_id, expr.span, \"return value of \", \"\");\n-        } else if type_permits_lack_of_use {\n+\n+        let fn_warned = check_fn_must_use(cx, expr);\n+\n+        if !fn_warned && type_lint_emitted_or_suppressed {\n             // We don't warn about unused unit or uninhabited types.\n             // (See https://github.com/rust-lang/rust/issues/43806 for details.)\n             return;\n@@ -170,6 +160,8 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             _ => None,\n         };\n \n+        let mut op_warned = false;\n+\n         if let Some(must_use_op) = must_use_op {\n             cx.struct_span_lint(UNUSED_MUST_USE, expr.span, fluent::lint_unused_op, |lint| {\n                 lint.set_arg(\"op\", must_use_op)\n@@ -184,110 +176,229 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             op_warned = true;\n         }\n \n-        if !(type_permits_lack_of_use || fn_warned || op_warned) {\n+        if !(type_lint_emitted_or_suppressed || fn_warned || op_warned) {\n             cx.struct_span_lint(UNUSED_RESULTS, s.span, fluent::lint_unused_result, |lint| {\n                 lint.set_arg(\"ty\", ty)\n             });\n         }\n \n-        // Returns whether an error has been emitted (and thus another does not need to be later).\n-        fn check_must_use_ty<'tcx>(\n+        fn check_fn_must_use(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n+            let maybe_def_id = match expr.kind {\n+                hir::ExprKind::Call(ref callee, _) => {\n+                    match callee.kind {\n+                        hir::ExprKind::Path(ref qpath) => {\n+                            match cx.qpath_res(qpath, callee.hir_id) {\n+                                Res::Def(DefKind::Fn | DefKind::AssocFn, def_id) => Some(def_id),\n+                                // `Res::Local` if it was a closure, for which we\n+                                // do not currently support must-use linting\n+                                _ => None,\n+                            }\n+                        }\n+                        _ => None,\n+                    }\n+                }\n+                hir::ExprKind::MethodCall(..) => {\n+                    cx.typeck_results().type_dependent_def_id(expr.hir_id)\n+                }\n+                _ => None,\n+            };\n+            if let Some(def_id) = maybe_def_id {\n+                check_must_use_def(cx, def_id, expr.span, \"return value of \", \"\")\n+            } else {\n+                false\n+            }\n+        }\n+\n+        /// A path through a type to a must_use source. Contains useful info for the lint.\n+        #[derive(Debug)]\n+        enum MustUsePath {\n+            /// Suppress must_use checking.\n+            Suppressed,\n+            /// The root of the normal must_use lint with an optional message.\n+            Def(Span, DefId, Option<Symbol>),\n+            Boxed(Box<Self>),\n+            Opaque(Box<Self>),\n+            TraitObject(Box<Self>),\n+            TupleElement(Vec<(usize, Self)>),\n+            Array(Box<Self>, u64),\n+            /// The root of the unused_closures lint.\n+            Closure(Span),\n+            /// The root of the unused_generators lint.\n+            Generator(Span),\n+        }\n+\n+        #[instrument(skip(cx, expr), level = \"debug\", ret)]\n+        fn is_ty_must_use<'tcx>(\n             cx: &LateContext<'tcx>,\n             ty: Ty<'tcx>,\n             expr: &hir::Expr<'_>,\n             span: Span,\n-            descr_pre: &str,\n-            descr_post: &str,\n-            plural_len: usize,\n-        ) -> bool {\n+        ) -> Option<MustUsePath> {\n             if ty.is_unit()\n                 || cx.tcx.is_ty_uninhabited_from(\n                     cx.tcx.parent_module(expr.hir_id).to_def_id(),\n                     ty,\n                     cx.param_env,\n                 )\n             {\n-                return true;\n+                return Some(MustUsePath::Suppressed);\n             }\n \n-            let plural_suffix = pluralize!(plural_len);\n-\n             match *ty.kind() {\n                 ty::Adt(..) if ty.is_box() => {\n                     let boxed_ty = ty.boxed_ty();\n-                    let descr_pre = &format!(\"{}boxed \", descr_pre);\n-                    check_must_use_ty(cx, boxed_ty, expr, span, descr_pre, descr_post, plural_len)\n+                    is_ty_must_use(cx, boxed_ty, expr, span)\n+                        .map(|inner| MustUsePath::Boxed(Box::new(inner)))\n                 }\n-                ty::Adt(def, _) => check_must_use_def(cx, def.did(), span, descr_pre, descr_post),\n+                ty::Adt(def, _) => is_def_must_use(cx, def.did(), span),\n                 ty::Opaque(def, _) => {\n-                    let mut has_emitted = false;\n-                    for obligation in elaborate_predicates_with_span(\n+                    elaborate_predicates_with_span(\n                         cx.tcx,\n                         cx.tcx.explicit_item_bounds(def).iter().cloned(),\n-                    ) {\n+                    )\n+                    .filter_map(|obligation| {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n                         if let ty::PredicateKind::Trait(ref poly_trait_predicate) =\n                             obligation.predicate.kind().skip_binder()\n                         {\n                             let def_id = poly_trait_predicate.trait_ref.def_id;\n-                            let descr_pre =\n-                                &format!(\"{}implementer{} of \", descr_pre, plural_suffix,);\n-                            if check_must_use_def(cx, def_id, span, descr_pre, descr_post) {\n-                                has_emitted = true;\n-                                break;\n-                            }\n+\n+                            is_def_must_use(cx, def_id, span)\n+                        } else {\n+                            None\n                         }\n-                    }\n-                    has_emitted\n+                    })\n+                    .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n+                    .next()\n                 }\n-                ty::Dynamic(binder, _, _) => {\n-                    let mut has_emitted = false;\n-                    for predicate in binder.iter() {\n+                ty::Dynamic(binders, _, _) => binders\n+                    .iter()\n+                    .filter_map(|predicate| {\n                         if let ty::ExistentialPredicate::Trait(ref trait_ref) =\n                             predicate.skip_binder()\n                         {\n                             let def_id = trait_ref.def_id;\n-                            let descr_post =\n-                                &format!(\" trait object{}{}\", plural_suffix, descr_post,);\n-                            if check_must_use_def(cx, def_id, span, descr_pre, descr_post) {\n-                                has_emitted = true;\n-                                break;\n-                            }\n+                            is_def_must_use(cx, def_id, span)\n+                        } else {\n+                            None\n                         }\n-                    }\n-                    has_emitted\n-                }\n-                ty::Tuple(ref tys) => {\n-                    let mut has_emitted = false;\n-                    let comps = if let hir::ExprKind::Tup(comps) = expr.kind {\n-                        debug_assert_eq!(comps.len(), tys.len());\n-                        comps\n+                        .map(|inner| MustUsePath::TraitObject(Box::new(inner)))\n+                    })\n+                    .next(),\n+                ty::Tuple(tys) => {\n+                    let elem_exprs = if let hir::ExprKind::Tup(elem_exprs) = expr.kind {\n+                        debug_assert_eq!(elem_exprs.len(), tys.len());\n+                        elem_exprs\n                     } else {\n                         &[]\n                     };\n-                    for (i, ty) in tys.iter().enumerate() {\n-                        let descr_post = &format!(\" in tuple element {}\", i);\n-                        let e = comps.get(i).unwrap_or(expr);\n-                        let span = e.span;\n-                        if check_must_use_ty(cx, ty, e, span, descr_pre, descr_post, plural_len) {\n-                            has_emitted = true;\n-                        }\n+\n+                    // Default to `expr`.\n+                    let elem_exprs = elem_exprs.iter().chain(iter::repeat(expr));\n+\n+                    let nested_must_use = tys\n+                        .iter()\n+                        .zip(elem_exprs)\n+                        .enumerate()\n+                        .filter_map(|(i, (ty, expr))| {\n+                            is_ty_must_use(cx, ty, expr, expr.span).map(|path| (i, path))\n+                        })\n+                        .collect::<Vec<_>>();\n+\n+                    if !nested_must_use.is_empty() {\n+                        Some(MustUsePath::TupleElement(nested_must_use))\n+                    } else {\n+                        None\n                     }\n-                    has_emitted\n                 }\n                 ty::Array(ty, len) => match len.try_eval_usize(cx.tcx, cx.param_env) {\n                     // If the array is empty we don't lint, to avoid false positives\n-                    Some(0) | None => false,\n+                    Some(0) | None => None,\n                     // If the array is definitely non-empty, we can do `#[must_use]` checking.\n-                    Some(n) => {\n-                        let descr_pre = &format!(\"{}array{} of \", descr_pre, plural_suffix,);\n-                        check_must_use_ty(cx, ty, expr, span, descr_pre, descr_post, n as usize + 1)\n-                    }\n+                    Some(len) => is_ty_must_use(cx, ty, expr, span)\n+                        .map(|inner| MustUsePath::Array(Box::new(inner), len)),\n                 },\n-                ty::Closure(..) => {\n+                ty::Closure(..) => Some(MustUsePath::Closure(span)),\n+                ty::Generator(..) => Some(MustUsePath::Generator(span)),\n+                _ => None,\n+            }\n+        }\n+\n+        fn is_def_must_use(cx: &LateContext<'_>, def_id: DefId, span: Span) -> Option<MustUsePath> {\n+            if let Some(attr) = cx.tcx.get_attr(def_id, sym::must_use) {\n+                // check for #[must_use = \"...\"]\n+                let reason = attr.value_str();\n+                Some(MustUsePath::Def(span, def_id, reason))\n+            } else {\n+                None\n+            }\n+        }\n+\n+        // Returns whether further errors should be suppressed because either a lint has been emitted or the type should be ignored.\n+        fn check_must_use_def(\n+            cx: &LateContext<'_>,\n+            def_id: DefId,\n+            span: Span,\n+            descr_pre_path: &str,\n+            descr_post_path: &str,\n+        ) -> bool {\n+            is_def_must_use(cx, def_id, span)\n+                .map(|must_use_path| {\n+                    emit_must_use_untranslated(\n+                        cx,\n+                        &must_use_path,\n+                        descr_pre_path,\n+                        descr_post_path,\n+                        1,\n+                    )\n+                })\n+                .is_some()\n+        }\n+\n+        #[instrument(skip(cx), level = \"debug\")]\n+        fn emit_must_use_untranslated(\n+            cx: &LateContext<'_>,\n+            path: &MustUsePath,\n+            descr_pre: &str,\n+            descr_post: &str,\n+            plural_len: usize,\n+        ) {\n+            let plural_suffix = pluralize!(plural_len);\n+\n+            match path {\n+                MustUsePath::Suppressed => {}\n+                MustUsePath::Boxed(path) => {\n+                    let descr_pre = &format!(\"{}boxed \", descr_pre);\n+                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                }\n+                MustUsePath::Opaque(path) => {\n+                    let descr_pre = &format!(\"{}implementer{} of \", descr_pre, plural_suffix);\n+                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                }\n+                MustUsePath::TraitObject(path) => {\n+                    let descr_post = &format!(\" trait object{}{}\", plural_suffix, descr_post);\n+                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                }\n+                MustUsePath::TupleElement(elems) => {\n+                    for (index, path) in elems {\n+                        let descr_post = &format!(\" in tuple element {}\", index);\n+                        emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                    }\n+                }\n+                MustUsePath::Array(path, len) => {\n+                    let descr_pre = &format!(\"{}array{} of \", descr_pre, plural_suffix);\n+                    emit_must_use_untranslated(\n+                        cx,\n+                        path,\n+                        descr_pre,\n+                        descr_post,\n+                        plural_len.saturating_add(usize::try_from(*len).unwrap_or(usize::MAX)),\n+                    );\n+                }\n+                MustUsePath::Closure(span) => {\n                     cx.struct_span_lint(\n                         UNUSED_MUST_USE,\n-                        span,\n+                        *span,\n                         fluent::lint_unused_closure,\n                         |lint| {\n                             // FIXME(davidtwco): this isn't properly translatable because of the\n@@ -298,12 +409,11 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                                 .note(fluent::note)\n                         },\n                     );\n-                    true\n                 }\n-                ty::Generator(..) => {\n+                MustUsePath::Generator(span) => {\n                     cx.struct_span_lint(\n                         UNUSED_MUST_USE,\n-                        span,\n+                        *span,\n                         fluent::lint_unused_generator,\n                         |lint| {\n                             // FIXME(davidtwco): this isn't properly translatable because of the\n@@ -314,40 +424,20 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                                 .note(fluent::note)\n                         },\n                     );\n-                    true\n                 }\n-                _ => false,\n-            }\n-        }\n-\n-        // Returns whether an error has been emitted (and thus another does not need to be later).\n-        // FIXME: Args desc_{pre,post}_path could be made lazy by taking Fn() -> &str, but this\n-        // would make calling it a big awkward. Could also take String (so args are moved), but\n-        // this would still require a copy into the format string, which would only be executed\n-        // when needed.\n-        fn check_must_use_def(\n-            cx: &LateContext<'_>,\n-            def_id: DefId,\n-            span: Span,\n-            descr_pre_path: &str,\n-            descr_post_path: &str,\n-        ) -> bool {\n-            if let Some(attr) = cx.tcx.get_attr(def_id, sym::must_use) {\n-                cx.struct_span_lint(UNUSED_MUST_USE, span, fluent::lint_unused_def, |lint| {\n-                    // FIXME(davidtwco): this isn't properly translatable because of the pre/post\n-                    // strings\n-                    lint.set_arg(\"pre\", descr_pre_path);\n-                    lint.set_arg(\"post\", descr_post_path);\n-                    lint.set_arg(\"def\", cx.tcx.def_path_str(def_id));\n-                    // check for #[must_use = \"...\"]\n-                    if let Some(note) = attr.value_str() {\n-                        lint.note(note.as_str());\n-                    }\n-                    lint\n-                });\n-                true\n-            } else {\n-                false\n+                MustUsePath::Def(span, def_id, reason) => {\n+                    cx.struct_span_lint(UNUSED_MUST_USE, *span, fluent::lint_unused_def, |lint| {\n+                        // FIXME(davidtwco): this isn't properly translatable because of the pre/post\n+                        // strings\n+                        lint.set_arg(\"pre\", descr_pre);\n+                        lint.set_arg(\"post\", descr_post);\n+                        lint.set_arg(\"def\", cx.tcx.def_path_str(*def_id));\n+                        if let Some(note) = reason {\n+                            lint.note(note.as_str());\n+                        }\n+                        lint\n+                    });\n+                }\n             }\n         }\n     }"}, {"sha": "60f877aa8b30327ad6f60fe740ae995cf02d7716", "filename": "src/test/ui/lint/unused/must-use-ops.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4e9ceef76d9daa33ebc936d46b955d00751fd21d/src%2Ftest%2Fui%2Flint%2Funused%2Fmust-use-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9ceef76d9daa33ebc936d46b955d00751fd21d/src%2Ftest%2Fui%2Flint%2Funused%2Fmust-use-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Fmust-use-ops.rs?ref=4e9ceef76d9daa33ebc936d46b955d00751fd21d", "patch": "@@ -3,39 +3,49 @@\n // check-pass\n \n #![warn(unused_must_use)]\n+#![feature(never_type)]\n+\n+fn deref_never(x: &!) {\n+    // Don't lint for uninhabited typess\n+    *x;\n+}\n \n fn main() {\n     let val = 1;\n     let val_pointer = &val;\n \n-// Comparison Operators\n+    // Comparison Operators\n     val == 1; //~ WARNING unused comparison\n     val < 1; //~ WARNING unused comparison\n     val <= 1; //~ WARNING unused comparison\n     val != 1; //~ WARNING unused comparison\n     val >= 1; //~ WARNING unused comparison\n     val > 1; //~ WARNING unused comparison\n \n-// Arithmetic Operators\n+    // Arithmetic Operators\n     val + 2; //~ WARNING unused arithmetic operation\n     val - 2; //~ WARNING unused arithmetic operation\n     val / 2; //~ WARNING unused arithmetic operation\n     val * 2; //~ WARNING unused arithmetic operation\n     val % 2; //~ WARNING unused arithmetic operation\n \n-// Logical Operators\n+    // Logical Operators\n     true && true; //~ WARNING unused logical operation\n     false || true; //~ WARNING unused logical operation\n \n-// Bitwise Operators\n+    // Bitwise Operators\n     5 ^ val; //~ WARNING unused bitwise operation\n     5 & val; //~ WARNING unused bitwise operation\n     5 | val; //~ WARNING unused bitwise operation\n     5 << val; //~ WARNING unused bitwise operation\n     5 >> val; //~ WARNING unused bitwise operation\n \n-// Unary Operators\n+    // Unary Operators\n     !val; //~ WARNING unused unary operation\n     -val; //~ WARNING unused unary operation\n     *val_pointer; //~ WARNING unused unary operation\n+\n+    if false {\n+        deref_never(&panic!());\n+    }\n }"}, {"sha": "79a53d39cbf1023f086879f747f4c62575b579a7", "filename": "src/test/ui/lint/unused/must-use-ops.stderr", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4e9ceef76d9daa33ebc936d46b955d00751fd21d/src%2Ftest%2Fui%2Flint%2Funused%2Fmust-use-ops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e9ceef76d9daa33ebc936d46b955d00751fd21d/src%2Ftest%2Fui%2Flint%2Funused%2Fmust-use-ops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Fmust-use-ops.stderr?ref=4e9ceef76d9daa33ebc936d46b955d00751fd21d", "patch": "@@ -1,5 +1,5 @@\n warning: unused comparison that must be used\n-  --> $DIR/must-use-ops.rs:12:5\n+  --> $DIR/must-use-ops.rs:18:5\n    |\n LL |     val == 1;\n    |     ^^^^^^^^ the comparison produces a value\n@@ -15,7 +15,7 @@ LL |     let _ = val == 1;\n    |     +++++++\n \n warning: unused comparison that must be used\n-  --> $DIR/must-use-ops.rs:13:5\n+  --> $DIR/must-use-ops.rs:19:5\n    |\n LL |     val < 1;\n    |     ^^^^^^^ the comparison produces a value\n@@ -26,7 +26,7 @@ LL |     let _ = val < 1;\n    |     +++++++\n \n warning: unused comparison that must be used\n-  --> $DIR/must-use-ops.rs:14:5\n+  --> $DIR/must-use-ops.rs:20:5\n    |\n LL |     val <= 1;\n    |     ^^^^^^^^ the comparison produces a value\n@@ -37,7 +37,7 @@ LL |     let _ = val <= 1;\n    |     +++++++\n \n warning: unused comparison that must be used\n-  --> $DIR/must-use-ops.rs:15:5\n+  --> $DIR/must-use-ops.rs:21:5\n    |\n LL |     val != 1;\n    |     ^^^^^^^^ the comparison produces a value\n@@ -48,7 +48,7 @@ LL |     let _ = val != 1;\n    |     +++++++\n \n warning: unused comparison that must be used\n-  --> $DIR/must-use-ops.rs:16:5\n+  --> $DIR/must-use-ops.rs:22:5\n    |\n LL |     val >= 1;\n    |     ^^^^^^^^ the comparison produces a value\n@@ -59,7 +59,7 @@ LL |     let _ = val >= 1;\n    |     +++++++\n \n warning: unused comparison that must be used\n-  --> $DIR/must-use-ops.rs:17:5\n+  --> $DIR/must-use-ops.rs:23:5\n    |\n LL |     val > 1;\n    |     ^^^^^^^ the comparison produces a value\n@@ -70,7 +70,7 @@ LL |     let _ = val > 1;\n    |     +++++++\n \n warning: unused arithmetic operation that must be used\n-  --> $DIR/must-use-ops.rs:20:5\n+  --> $DIR/must-use-ops.rs:26:5\n    |\n LL |     val + 2;\n    |     ^^^^^^^ the arithmetic operation produces a value\n@@ -81,7 +81,7 @@ LL |     let _ = val + 2;\n    |     +++++++\n \n warning: unused arithmetic operation that must be used\n-  --> $DIR/must-use-ops.rs:21:5\n+  --> $DIR/must-use-ops.rs:27:5\n    |\n LL |     val - 2;\n    |     ^^^^^^^ the arithmetic operation produces a value\n@@ -92,7 +92,7 @@ LL |     let _ = val - 2;\n    |     +++++++\n \n warning: unused arithmetic operation that must be used\n-  --> $DIR/must-use-ops.rs:22:5\n+  --> $DIR/must-use-ops.rs:28:5\n    |\n LL |     val / 2;\n    |     ^^^^^^^ the arithmetic operation produces a value\n@@ -103,7 +103,7 @@ LL |     let _ = val / 2;\n    |     +++++++\n \n warning: unused arithmetic operation that must be used\n-  --> $DIR/must-use-ops.rs:23:5\n+  --> $DIR/must-use-ops.rs:29:5\n    |\n LL |     val * 2;\n    |     ^^^^^^^ the arithmetic operation produces a value\n@@ -114,7 +114,7 @@ LL |     let _ = val * 2;\n    |     +++++++\n \n warning: unused arithmetic operation that must be used\n-  --> $DIR/must-use-ops.rs:24:5\n+  --> $DIR/must-use-ops.rs:30:5\n    |\n LL |     val % 2;\n    |     ^^^^^^^ the arithmetic operation produces a value\n@@ -125,7 +125,7 @@ LL |     let _ = val % 2;\n    |     +++++++\n \n warning: unused logical operation that must be used\n-  --> $DIR/must-use-ops.rs:27:5\n+  --> $DIR/must-use-ops.rs:33:5\n    |\n LL |     true && true;\n    |     ^^^^^^^^^^^^ the logical operation produces a value\n@@ -136,7 +136,7 @@ LL |     let _ = true && true;\n    |     +++++++\n \n warning: unused logical operation that must be used\n-  --> $DIR/must-use-ops.rs:28:5\n+  --> $DIR/must-use-ops.rs:34:5\n    |\n LL |     false || true;\n    |     ^^^^^^^^^^^^^ the logical operation produces a value\n@@ -147,7 +147,7 @@ LL |     let _ = false || true;\n    |     +++++++\n \n warning: unused bitwise operation that must be used\n-  --> $DIR/must-use-ops.rs:31:5\n+  --> $DIR/must-use-ops.rs:37:5\n    |\n LL |     5 ^ val;\n    |     ^^^^^^^ the bitwise operation produces a value\n@@ -158,7 +158,7 @@ LL |     let _ = 5 ^ val;\n    |     +++++++\n \n warning: unused bitwise operation that must be used\n-  --> $DIR/must-use-ops.rs:32:5\n+  --> $DIR/must-use-ops.rs:38:5\n    |\n LL |     5 & val;\n    |     ^^^^^^^ the bitwise operation produces a value\n@@ -169,7 +169,7 @@ LL |     let _ = 5 & val;\n    |     +++++++\n \n warning: unused bitwise operation that must be used\n-  --> $DIR/must-use-ops.rs:33:5\n+  --> $DIR/must-use-ops.rs:39:5\n    |\n LL |     5 | val;\n    |     ^^^^^^^ the bitwise operation produces a value\n@@ -180,7 +180,7 @@ LL |     let _ = 5 | val;\n    |     +++++++\n \n warning: unused bitwise operation that must be used\n-  --> $DIR/must-use-ops.rs:34:5\n+  --> $DIR/must-use-ops.rs:40:5\n    |\n LL |     5 << val;\n    |     ^^^^^^^^ the bitwise operation produces a value\n@@ -191,7 +191,7 @@ LL |     let _ = 5 << val;\n    |     +++++++\n \n warning: unused bitwise operation that must be used\n-  --> $DIR/must-use-ops.rs:35:5\n+  --> $DIR/must-use-ops.rs:41:5\n    |\n LL |     5 >> val;\n    |     ^^^^^^^^ the bitwise operation produces a value\n@@ -202,7 +202,7 @@ LL |     let _ = 5 >> val;\n    |     +++++++\n \n warning: unused unary operation that must be used\n-  --> $DIR/must-use-ops.rs:38:5\n+  --> $DIR/must-use-ops.rs:44:5\n    |\n LL |     !val;\n    |     ^^^^ the unary operation produces a value\n@@ -213,7 +213,7 @@ LL |     let _ = !val;\n    |     +++++++\n \n warning: unused unary operation that must be used\n-  --> $DIR/must-use-ops.rs:39:5\n+  --> $DIR/must-use-ops.rs:45:5\n    |\n LL |     -val;\n    |     ^^^^ the unary operation produces a value\n@@ -224,7 +224,7 @@ LL |     let _ = -val;\n    |     +++++++\n \n warning: unused unary operation that must be used\n-  --> $DIR/must-use-ops.rs:40:5\n+  --> $DIR/must-use-ops.rs:46:5\n    |\n LL |     *val_pointer;\n    |     ^^^^^^^^^^^^ the unary operation produces a value"}, {"sha": "b7bae4b0acf1223df7534d2833f90c6abd77cc31", "filename": "src/test/ui/lint/unused/must_use-array.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4e9ceef76d9daa33ebc936d46b955d00751fd21d/src%2Ftest%2Fui%2Flint%2Funused%2Fmust_use-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9ceef76d9daa33ebc936d46b955d00751fd21d/src%2Ftest%2Fui%2Flint%2Funused%2Fmust_use-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Fmust_use-array.rs?ref=4e9ceef76d9daa33ebc936d46b955d00751fd21d", "patch": "@@ -1,6 +1,7 @@\n #![deny(unused_must_use)]\n \n #[must_use]\n+#[derive(Clone, Copy)]\n struct S;\n \n struct A;\n@@ -34,6 +35,10 @@ fn array_of_arrays_of_arrays() -> [[[S; 1]; 2]; 1] {\n     [[[S], [S]]]\n }\n \n+fn usize_max() -> [S; usize::MAX] {\n+    [S; usize::MAX]\n+}\n+\n fn main() {\n     empty(); // ok\n     singleton(); //~ ERROR unused array of `S` that must be used\n@@ -44,4 +49,6 @@ fn main() {\n     //~^ ERROR unused array of boxed `T` trait objects in tuple element 1 that must be used\n     array_of_arrays_of_arrays();\n     //~^ ERROR unused array of arrays of arrays of `S` that must be used\n+    usize_max();\n+    //~^ ERROR unused array of `S` that must be used\n }"}, {"sha": "61ef2088d30e555354af5d2bf1161117a46345d7", "filename": "src/test/ui/lint/unused/must_use-array.stderr", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4e9ceef76d9daa33ebc936d46b955d00751fd21d/src%2Ftest%2Fui%2Flint%2Funused%2Fmust_use-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e9ceef76d9daa33ebc936d46b955d00751fd21d/src%2Ftest%2Fui%2Flint%2Funused%2Fmust_use-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Fmust_use-array.stderr?ref=4e9ceef76d9daa33ebc936d46b955d00751fd21d", "patch": "@@ -1,5 +1,5 @@\n error: unused array of `S` that must be used\n-  --> $DIR/must_use-array.rs:39:5\n+  --> $DIR/must_use-array.rs:44:5\n    |\n LL |     singleton();\n    |     ^^^^^^^^^^^\n@@ -11,34 +11,40 @@ LL | #![deny(unused_must_use)]\n    |         ^^^^^^^^^^^^^^^\n \n error: unused array of `S` that must be used\n-  --> $DIR/must_use-array.rs:40:5\n+  --> $DIR/must_use-array.rs:45:5\n    |\n LL |     many();\n    |     ^^^^^^\n \n error: unused array of `S` in tuple element 0 that must be used\n-  --> $DIR/must_use-array.rs:41:6\n+  --> $DIR/must_use-array.rs:46:6\n    |\n LL |     ([S], 0, ());\n    |      ^^^\n \n error: unused array of implementers of `T` that must be used\n-  --> $DIR/must_use-array.rs:42:5\n+  --> $DIR/must_use-array.rs:47:5\n    |\n LL |     array_of_impl_trait();\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: unused array of boxed `T` trait objects in tuple element 1 that must be used\n-  --> $DIR/must_use-array.rs:43:5\n+  --> $DIR/must_use-array.rs:48:5\n    |\n LL |     impl_array();\n    |     ^^^^^^^^^^^^\n \n error: unused array of arrays of arrays of `S` that must be used\n-  --> $DIR/must_use-array.rs:45:5\n+  --> $DIR/must_use-array.rs:50:5\n    |\n LL |     array_of_arrays_of_arrays();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 6 previous errors\n+error: unused array of `S` that must be used\n+  --> $DIR/must_use-array.rs:52:5\n+   |\n+LL |     usize_max();\n+   |     ^^^^^^^^^^^\n+\n+error: aborting due to 7 previous errors\n "}]}