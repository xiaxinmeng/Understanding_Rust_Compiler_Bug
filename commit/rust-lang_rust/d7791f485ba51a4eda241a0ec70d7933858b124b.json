{"sha": "d7791f485ba51a4eda241a0ec70d7933858b124b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3NzkxZjQ4NWJhNTFhNGVkYTI0MWEwZWM3MGQ3OTMzODU4YjEyNGI=", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2020-10-09T09:20:28Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2020-10-14T02:14:32Z"}, "message": "Remove unused code from rustc_middle", "tree": {"sha": "999889ab45f2527fa71c16aca488bf90d410163e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/999889ab45f2527fa71c16aca488bf90d410163e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7791f485ba51a4eda241a0ec70d7933858b124b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7791f485ba51a4eda241a0ec70d7933858b124b", "html_url": "https://github.com/rust-lang/rust/commit/d7791f485ba51a4eda241a0ec70d7933858b124b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7791f485ba51a4eda241a0ec70d7933858b124b/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f243a2ad904705a1e340a08639dca105605b4175", "url": "https://api.github.com/repos/rust-lang/rust/commits/f243a2ad904705a1e340a08639dca105605b4175", "html_url": "https://github.com/rust-lang/rust/commit/f243a2ad904705a1e340a08639dca105605b4175"}], "stats": {"total": 221, "additions": 7, "deletions": 214}, "files": [{"sha": "254b57a005e8e7438148954c9e17fd05cc50321c", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=d7791f485ba51a4eda241a0ec70d7933858b124b", "patch": "@@ -3,7 +3,6 @@\n //! which are available for use externally when compiled as a library.\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::DefIdSet;\n use rustc_hir::HirId;\n use rustc_macros::HashStable;\n use std::fmt;\n@@ -59,7 +58,3 @@ impl<Id: Hash + Eq + fmt::Debug> fmt::Debug for AccessLevels<Id> {\n         fmt::Debug::fmt(&self.map, f)\n     }\n }\n-\n-/// A set containing all exported definitions from external crates.\n-/// The set does not contain any entries from local crates.\n-pub type ExternalExports = DefIdSet;"}, {"sha": "cb8782ce8170a4e61655a0cc10b0f51034291edb", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=d7791f485ba51a4eda241a0ec70d7933858b124b", "patch": "@@ -56,15 +56,6 @@ impl<'tcx> ConstValue<'tcx> {\n         }\n     }\n \n-    pub fn try_to_str_slice(&self) -> Option<&'tcx str> {\n-        if let ConstValue::Slice { data, start, end } = *self {\n-            std::str::from_utf8(data.inspect_with_uninit_and_ptr_outside_interpreter(start..end))\n-                .ok()\n-        } else {\n-            None\n-        }\n-    }\n-\n     pub fn try_to_bits(&self, size: Size) -> Option<u128> {\n         self.try_to_scalar()?.to_bits(size).ok()\n     }"}, {"sha": "16472c787572c8f614ea7833d40c84107700da0a", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 55, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=d7791f485ba51a4eda241a0ec70d7933858b124b", "patch": "@@ -3,7 +3,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/mir/index.html\n \n use crate::mir::coverage::{CodeRegion, CoverageKind};\n-use crate::mir::interpret::{Allocation, ConstValue, GlobalAlloc, Scalar};\n+use crate::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n@@ -460,17 +460,6 @@ impl<'tcx> Body<'tcx> {\n         }\n     }\n \n-    /// Checks if `sub` is a sub scope of `sup`\n-    pub fn is_sub_scope(&self, mut sub: SourceScope, sup: SourceScope) -> bool {\n-        while sub != sup {\n-            match self.source_scopes[sub].parent_scope {\n-                None => return false,\n-                Some(p) => sub = p,\n-            }\n-        }\n-        true\n-    }\n-\n     /// Returns the return type; it always return first element from `local_decls` array.\n     #[inline]\n     pub fn return_ty(&self) -> Ty<'tcx> {\n@@ -1978,45 +1967,6 @@ impl<'tcx> Operand<'tcx> {\n         })\n     }\n \n-    /// Convenience helper to make a `Scalar` from the given `Operand`, assuming that `Operand`\n-    /// wraps a constant literal value. Panics if this is not the case.\n-    pub fn scalar_from_const(operand: &Operand<'tcx>) -> Scalar {\n-        match operand {\n-            Operand::Constant(constant) => match constant.literal.val.try_to_scalar() {\n-                Some(scalar) => scalar,\n-                _ => panic!(\"{:?}: Scalar value expected\", constant.literal.val),\n-            },\n-            _ => panic!(\"{:?}: Constant expected\", operand),\n-        }\n-    }\n-\n-    /// Convenience helper to make a literal-like constant from a given `&str` slice.\n-    /// Since this is used to synthesize MIR, assumes `user_ty` is None.\n-    pub fn const_from_str(tcx: TyCtxt<'tcx>, val: &str, span: Span) -> Operand<'tcx> {\n-        let tcx = tcx;\n-        let allocation = Allocation::from_byte_aligned_bytes(val.as_bytes());\n-        let allocation = tcx.intern_const_alloc(allocation);\n-        let const_val = ConstValue::Slice { data: allocation, start: 0, end: val.len() };\n-        let ty = tcx.mk_imm_ref(tcx.lifetimes.re_erased, tcx.types.str_);\n-        Operand::Constant(box Constant {\n-            span,\n-            user_ty: None,\n-            literal: ty::Const::from_value(tcx, const_val, ty),\n-        })\n-    }\n-\n-    /// Convenience helper to make a `ConstValue` from the given `Operand`, assuming that `Operand`\n-    /// wraps a constant value (such as a `&str` slice). Panics if this is not the case.\n-    pub fn value_from_const(operand: &Operand<'tcx>) -> ConstValue<'tcx> {\n-        match operand {\n-            Operand::Constant(constant) => match constant.literal.val.try_to_value() {\n-                Some(const_value) => const_value,\n-                _ => panic!(\"{:?}: ConstValue expected\", constant.literal.val),\n-            },\n-            _ => panic!(\"{:?}: Constant expected\", operand),\n-        }\n-    }\n-\n     pub fn to_copy(&self) -> Self {\n         match *self {\n             Operand::Copy(_) | Operand::Constant(_) => self.clone(),\n@@ -2413,10 +2363,6 @@ impl<'tcx> UserTypeProjections {\n         self.contents.is_empty()\n     }\n \n-    pub fn from_projections(projs: impl Iterator<Item = (UserTypeProjection, Span)>) -> Self {\n-        UserTypeProjections { contents: projs.collect() }\n-    }\n-\n     pub fn projections_and_spans(\n         &self,\n     ) -> impl Iterator<Item = &(UserTypeProjection, Span)> + ExactSizeIterator {"}, {"sha": "6022194342d02961a8dfa7fa4a475d0f04134fe6", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=d7791f485ba51a4eda241a0ec70d7933858b124b", "patch": "@@ -413,18 +413,6 @@ pub struct CoverageInfo {\n /// For more information on why this is needed, consider looking\n /// at the docs for `WithOptConstParam` itself.\n impl<'tcx> TyCtxt<'tcx> {\n-    #[inline]\n-    pub fn mir_borrowck_opt_const_arg(\n-        self,\n-        def: ty::WithOptConstParam<LocalDefId>,\n-    ) -> &'tcx BorrowCheckResult<'tcx> {\n-        if let Some(param_did) = def.const_param_did {\n-            self.mir_borrowck_const_arg((def.did, param_did))\n-        } else {\n-            self.mir_borrowck(def.did)\n-        }\n-    }\n-\n     #[inline]\n     pub fn mir_const_qualif_opt_const_arg(\n         self,"}, {"sha": "58dd0bc00d2040eb761367ee091ebc3cc91ffe53", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=d7791f485ba51a4eda241a0ec70d7933858b124b", "patch": "@@ -1186,16 +1186,6 @@ impl PlaceContext {\n         )\n     }\n \n-    /// Returns `true` if this place context represents a storage live marker.\n-    pub fn is_storage_live_marker(&self) -> bool {\n-        matches!(self, PlaceContext::NonUse(NonUseContext::StorageLive))\n-    }\n-\n-    /// Returns `true` if this place context represents a storage dead marker.\n-    pub fn is_storage_dead_marker(&self) -> bool {\n-        matches!(self, PlaceContext::NonUse(NonUseContext::StorageDead))\n-    }\n-\n     /// Returns `true` if this place context represents a use that potentially changes the value.\n     pub fn is_mutating_use(&self) -> bool {\n         matches!(self, PlaceContext::MutatingUse(..))"}, {"sha": "aaf6a8570437cf953731d11110a8beaf2a78b5bc", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=d7791f485ba51a4eda241a0ec70d7933858b124b", "patch": "@@ -182,14 +182,6 @@ pub trait TyDecoder<'tcx>: Decoder {\n     where\n         F: FnOnce(&mut Self) -> Result<Ty<'tcx>, Self::Error>;\n \n-    fn cached_predicate_for_shorthand<F>(\n-        &mut self,\n-        shorthand: usize,\n-        or_insert_with: F,\n-    ) -> Result<ty::Predicate<'tcx>, Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<ty::Predicate<'tcx>, Self::Error>;\n-\n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R;"}, {"sha": "2e794128eaca06ed17147b9b29c482196fe00634", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=d7791f485ba51a4eda241a0ec70d7933858b124b", "patch": "@@ -534,10 +534,6 @@ impl<'tcx> TypeckResults<'tcx> {\n         self.node_type(pat.hir_id)\n     }\n \n-    pub fn pat_ty_opt(&self, pat: &hir::Pat<'_>) -> Option<Ty<'tcx>> {\n-        self.node_type_opt(pat.hir_id)\n-    }\n-\n     // Returns the type of an expression as a monotype.\n     //\n     // NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in"}, {"sha": "5524d91a6d5331f7b71de2c2bd53062948236843", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 6, "deletions": 45, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=d7791f485ba51a4eda241a0ec70d7933858b124b", "patch": "@@ -97,9 +97,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_infer_types_or_consts(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_CT_INFER)\n     }\n-    fn has_infer_consts(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_CT_INFER)\n-    }\n     fn needs_infer(&self) -> bool {\n         self.has_type_flags(TypeFlags::NEEDS_INFER)\n     }\n@@ -113,9 +110,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn needs_subst(&self) -> bool {\n         self.has_type_flags(TypeFlags::NEEDS_SUBST)\n     }\n-    fn has_re_placeholders(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_RE_PLACEHOLDER)\n-    }\n     /// \"Free\" regions in this context means that it has any region\n     /// that is not (a) erased or (b) late-bound.\n     fn has_free_regions(&self) -> bool {\n@@ -719,21 +713,15 @@ impl<'tcx> TyCtxt<'tcx> {\n // vars. See comment on `shift_vars_through_binders` method in\n // `subst.rs` for more details.\n \n-enum Direction {\n-    In,\n-    Out,\n-}\n-\n struct Shifter<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     current_index: ty::DebruijnIndex,\n     amount: u32,\n-    direction: Direction,\n }\n \n impl Shifter<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>, amount: u32, direction: Direction) -> Self {\n-        Shifter { tcx, current_index: ty::INNERMOST, amount, direction }\n+    pub fn new(tcx: TyCtxt<'tcx>, amount: u32) -> Self {\n+        Shifter { tcx, current_index: ty::INNERMOST, amount }\n     }\n }\n \n@@ -755,13 +743,7 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n                 if self.amount == 0 || debruijn < self.current_index {\n                     r\n                 } else {\n-                    let debruijn = match self.direction {\n-                        Direction::In => debruijn.shifted_in(self.amount),\n-                        Direction::Out => {\n-                            assert!(debruijn.as_u32() >= self.amount);\n-                            debruijn.shifted_out(self.amount)\n-                        }\n-                    };\n+                    let debruijn = debruijn.shifted_in(self.amount);\n                     let shifted = ty::ReLateBound(debruijn, br);\n                     self.tcx.mk_region(shifted)\n                 }\n@@ -776,13 +758,7 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n                 if self.amount == 0 || debruijn < self.current_index {\n                     ty\n                 } else {\n-                    let debruijn = match self.direction {\n-                        Direction::In => debruijn.shifted_in(self.amount),\n-                        Direction::Out => {\n-                            assert!(debruijn.as_u32() >= self.amount);\n-                            debruijn.shifted_out(self.amount)\n-                        }\n-                    };\n+                    let debruijn = debruijn.shifted_in(self.amount);\n                     self.tcx.mk_ty(ty::Bound(debruijn, bound_ty))\n                 }\n             }\n@@ -796,13 +772,7 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n             if self.amount == 0 || debruijn < self.current_index {\n                 ct\n             } else {\n-                let debruijn = match self.direction {\n-                    Direction::In => debruijn.shifted_in(self.amount),\n-                    Direction::Out => {\n-                        assert!(debruijn.as_u32() >= self.amount);\n-                        debruijn.shifted_out(self.amount)\n-                    }\n-                };\n+                let debruijn = debruijn.shifted_in(self.amount);\n                 self.tcx.mk_const(ty::Const { val: ty::ConstKind::Bound(debruijn, bound_ct), ty })\n             }\n         } else {\n@@ -830,16 +800,7 @@ where\n {\n     debug!(\"shift_vars(value={:?}, amount={})\", value, amount);\n \n-    value.fold_with(&mut Shifter::new(tcx, amount, Direction::In))\n-}\n-\n-pub fn shift_out_vars<'tcx, T>(tcx: TyCtxt<'tcx>, value: &T, amount: u32) -> T\n-where\n-    T: TypeFoldable<'tcx>,\n-{\n-    debug!(\"shift_out_vars(value={:?}, amount={})\", value, amount);\n-\n-    value.fold_with(&mut Shifter::new(tcx, amount, Direction::Out))\n+    value.fold_with(&mut Shifter::new(tcx, amount))\n }\n \n /// An \"escaping var\" is a bound var whose binder is not part of `t`. A bound var can be a"}, {"sha": "bf1f5b81c9fd1c1b2d734df02684d5c008a366f2", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=d7791f485ba51a4eda241a0ec70d7933858b124b", "patch": "@@ -104,14 +104,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         // ```\n         ty.uninhabited_from(self, param_env).contains(self, module)\n     }\n-\n-    pub fn is_ty_uninhabited_from_any_module(\n-        self,\n-        ty: Ty<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> bool {\n-        !ty.uninhabited_from(self, param_env).is_empty()\n-    }\n }\n \n impl<'tcx> AdtDef {"}, {"sha": "275888b0ce24752c32a3aa8a8de9f9e071377af8", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=d7791f485ba51a4eda241a0ec70d7933858b124b", "patch": "@@ -7,7 +7,6 @@ pub use self::Variance::*;\n \n use crate::hir::exports::ExportMap;\n use crate::ich::StableHashingContext;\n-use crate::infer::canonical::Canonical;\n use crate::middle::cstore::CrateStoreDyn;\n use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n use crate::mir::interpret::ErrorHandled;\n@@ -656,8 +655,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n #[rustc_diagnostic_item = \"Ty\"]\n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n-pub type CanonicalTy<'tcx> = Canonical<'tcx, Ty<'tcx>>;\n-\n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub struct UpvarPath {\n     pub hir_id: hir::HirId,\n@@ -767,10 +764,6 @@ pub enum IntVarValue {\n pub struct FloatVarValue(pub ast::FloatTy);\n \n impl ty::EarlyBoundRegion {\n-    pub fn to_bound_region(&self) -> ty::BoundRegion {\n-        ty::BoundRegion::BrNamed(self.def_id, self.name)\n-    }\n-\n     /// Does this early bound region have a name? Early bound regions normally\n     /// always have names except when using anonymous lifetimes (`'_`).\n     pub fn has_name(&self) -> bool {\n@@ -821,14 +814,6 @@ impl GenericParamDef {\n             bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n         }\n     }\n-\n-    pub fn to_bound_region(&self) -> ty::BoundRegion {\n-        if let GenericParamDefKind::Lifetime = self.kind {\n-            self.to_early_bound_region_data().to_bound_region()\n-        } else {\n-            bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n-        }\n-    }\n }\n \n #[derive(Default)]\n@@ -1003,22 +988,6 @@ impl<'tcx> GenericPredicates<'tcx> {\n         instantiated.predicates.extend(self.predicates.iter().map(|(p, _)| p));\n         instantiated.spans.extend(self.predicates.iter().map(|(_, s)| s));\n     }\n-\n-    pub fn instantiate_supertrait(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        poly_trait_ref: &ty::PolyTraitRef<'tcx>,\n-    ) -> InstantiatedPredicates<'tcx> {\n-        assert_eq!(self.parent, None);\n-        InstantiatedPredicates {\n-            predicates: self\n-                .predicates\n-                .iter()\n-                .map(|(pred, _)| pred.subst_supertrait(tcx, poly_trait_ref))\n-                .collect(),\n-            spans: self.predicates.iter().map(|(_, sp)| *sp).collect(),\n-        }\n-    }\n }\n \n #[derive(Debug)]\n@@ -1303,7 +1272,6 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct OutlivesPredicate<A, B>(pub A, pub B); // `A: B`\n-pub type PolyOutlivesPredicate<A, B> = ty::Binder<OutlivesPredicate<A, B>>;\n pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>;\n pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;\n pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<RegionOutlivesPredicate<'tcx>>;"}, {"sha": "173e9a31928b5d89f0dfbf56a8abc7569098bc87", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=d7791f485ba51a4eda241a0ec70d7933858b124b", "patch": "@@ -601,29 +601,6 @@ impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n         Ok(ty)\n     }\n \n-    fn cached_predicate_for_shorthand<F>(\n-        &mut self,\n-        shorthand: usize,\n-        or_insert_with: F,\n-    ) -> Result<ty::Predicate<'tcx>, Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<ty::Predicate<'tcx>, Self::Error>,\n-    {\n-        let tcx = self.tcx();\n-\n-        let cache_key =\n-            ty::CReaderCacheKey { cnum: CrateNum::ReservedForIncrCompCache, pos: shorthand };\n-\n-        if let Some(&pred) = tcx.pred_rcache.borrow().get(&cache_key) {\n-            return Ok(pred);\n-        }\n-\n-        let pred = or_insert_with(self)?;\n-        // This may overwrite the entry, but it should overwrite with the same value.\n-        tcx.pred_rcache.borrow_mut().insert_same(cache_key, pred);\n-        Ok(pred)\n-    }\n-\n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,"}, {"sha": "7d96adb7c8b4e41373726d3d0c122c6c6cecc5e7", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7791f485ba51a4eda241a0ec70d7933858b124b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=d7791f485ba51a4eda241a0ec70d7933858b124b", "patch": "@@ -1,6 +1,5 @@\n // Type substitutions.\n \n-use crate::infer::canonical::Canonical;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::sty::{ClosureSubsts, GeneratorSubsts};\n@@ -648,8 +647,6 @@ impl<'a, 'tcx> SubstFolder<'a, 'tcx> {\n     }\n }\n \n-pub type CanonicalUserSubsts<'tcx> = Canonical<'tcx, UserSubsts<'tcx>>;\n-\n /// Stores the user-given substs to reach some fully qualified path\n /// (e.g., `<T>::Item` or `<T as Trait>::Item`).\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]"}]}