{"sha": "19423b59440f464c6cbe6be442d447e37b50fe3c", "node_id": "C_kwDOAAsO6NoAKDE5NDIzYjU5NDQwZjQ2NGM2Y2JlNmJlNDQyZDQ0N2UzN2I1MGZlM2M", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-19T14:05:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-19T14:05:07Z"}, "message": "Auto merge of #106910 - aliemjay:alias-ty-in-regionck, r=oli-obk\n\neven more unify Projection/Opaque handling in region outlives code\n\nedit: This continues ate the same pace as #106829. New changes are described in https://github.com/rust-lang/rust/pull/106910#issuecomment-1383251254.\n\n~This touches `OutlivesBound`, `Component`, `GenericKind` enums.~\n\nr? `@oli-obk` (because of overlap with #95474)", "tree": {"sha": "ea5466cf57618f9288489f21cef1bf672c053990", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea5466cf57618f9288489f21cef1bf672c053990"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19423b59440f464c6cbe6be442d447e37b50fe3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19423b59440f464c6cbe6be442d447e37b50fe3c", "html_url": "https://github.com/rust-lang/rust/commit/19423b59440f464c6cbe6be442d447e37b50fe3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19423b59440f464c6cbe6be442d447e37b50fe3c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79335f1ac4f6bc72795d4ac84764aa185648b5f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/79335f1ac4f6bc72795d4ac84764aa185648b5f2", "html_url": "https://github.com/rust-lang/rust/commit/79335f1ac4f6bc72795d4ac84764aa185648b5f2"}, {"sha": "e40567b2cf50c4694c75b1ac34aff6108e529700", "url": "https://api.github.com/repos/rust-lang/rust/commits/e40567b2cf50c4694c75b1ac34aff6108e529700", "html_url": "https://github.com/rust-lang/rust/commit/e40567b2cf50c4694c75b1ac34aff6108e529700"}], "stats": {"total": 259, "additions": 108, "deletions": 151}, "files": [{"sha": "82ff862479e81824e1f47c6606e6b54cca6e6c86", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=19423b59440f464c6cbe6be442d447e37b50fe3c", "patch": "@@ -359,9 +359,9 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                         .insert(ty::OutlivesPredicate(GenericKind::Param(param_b), r_a));\n                 }\n \n-                OutlivesBound::RegionSubAlias(r_a, kind, alias_b) => {\n+                OutlivesBound::RegionSubAlias(r_a, alias_b) => {\n                     self.region_bound_pairs\n-                        .insert(ty::OutlivesPredicate(GenericKind::Alias(kind, alias_b), r_a));\n+                        .insert(ty::OutlivesPredicate(GenericKind::Alias(alias_b), r_a));\n                 }\n             }\n         }"}, {"sha": "9459c5f54abbf7c0105f3666c1c347b39efb5964", "filename": "compiler/rustc_hir_analysis/src/outlives/utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs?ref=19423b59440f464c6cbe6be442d447e37b50fe3c", "patch": "@@ -80,7 +80,7 @@ pub(crate) fn insert_outlives_predicate<'tcx>(\n                             .or_insert(span);\n                     }\n \n-                    Component::Alias(kind, alias) => {\n+                    Component::Alias(alias_ty) => {\n                         // This would either arise from something like:\n                         //\n                         // ```\n@@ -99,13 +99,13 @@ pub(crate) fn insert_outlives_predicate<'tcx>(\n                         //\n                         // Here we want to add an explicit `where <T as Iterator>::Item: 'a`\n                         // or `Opaque<T>: 'a` depending on the alias kind.\n-                        let ty: Ty<'tcx> = tcx.mk_ty(ty::Alias(kind, alias));\n+                        let ty = alias_ty.to_ty(tcx);\n                         required_predicates\n                             .entry(ty::OutlivesPredicate(ty.into(), outlived_region))\n                             .or_insert(span);\n                     }\n \n-                    Component::EscapingProjection(_) => {\n+                    Component::EscapingAlias(_) => {\n                         // As above, but the projection involves\n                         // late-bound regions. Therefore, the WF\n                         // requirement is not checked in type definition"}, {"sha": "28fd03b878b2b69b2da3ef46b59a09823f1ea5f3", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=19423b59440f464c6cbe6be442d447e37b50fe3c", "patch": "@@ -2272,13 +2272,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),\n-            GenericKind::Alias(ty::Projection, ref p) => format!(\"the associated type `{}`\", p),\n-            GenericKind::Alias(ty::Opaque, ref p) => {\n-                format!(\n-                    \"the opaque type `{}`\",\n-                    self.tcx.def_path_str_with_substs(p.def_id, p.substs)\n-                )\n-            }\n+            GenericKind::Alias(ref p) => match p.kind(self.tcx) {\n+                ty::AliasKind::Projection => format!(\"the associated type `{}`\", p),\n+                ty::AliasKind::Opaque => format!(\"the opaque type `{}`\", p),\n+            },\n         };\n \n         if let Some(SubregionOrigin::CompareImplItemObligation {"}, {"sha": "3d86279b03cc621f6ba372c973b0c8b70ea8f013", "filename": "compiler/rustc_infer/src/infer/outlives/components.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs?ref=19423b59440f464c6cbe6be442d447e37b50fe3c", "patch": "@@ -22,7 +22,7 @@ pub enum Component<'tcx> {\n     // is not in a position to judge which is the best technique, so\n     // we just product the projection as a component and leave it to\n     // the consumer to decide (but see `EscapingProjection` below).\n-    Alias(ty::AliasKind, ty::AliasTy<'tcx>),\n+    Alias(ty::AliasTy<'tcx>),\n \n     // In the case where a projection has escaping regions -- meaning\n     // regions bound within the type itself -- we always use\n@@ -44,7 +44,7 @@ pub enum Component<'tcx> {\n     // projection, so that implied bounds code can avoid relying on\n     // them. This gives us room to improve the regionck reasoning in\n     // the future without breaking backwards compat.\n-    EscapingProjection(Vec<Component<'tcx>>),\n+    EscapingAlias(Vec<Component<'tcx>>),\n }\n \n /// Push onto `out` all the things that must outlive `'a` for the condition\n@@ -120,17 +120,6 @@ fn compute_components<'tcx>(\n                 out.push(Component::Param(p));\n             }\n \n-            // Ignore lifetimes found in opaque types. Opaque types can\n-            // have lifetimes in their substs which their hidden type doesn't\n-            // actually use. If we inferred that an opaque type is outlived by\n-            // its parameter lifetimes, then we could prove that any lifetime\n-            // outlives any other lifetime, which is unsound.\n-            // See https://github.com/rust-lang/rust/issues/84305 for\n-            // more details.\n-            ty::Alias(ty::Opaque, data) => {\n-                out.push(Component::Alias(ty::Opaque, data));\n-            },\n-\n             // For projections, we prefer to generate an obligation like\n             // `<P0 as Trait<P1...Pn>>::Foo: 'a`, because this gives the\n             // regionck more ways to prove that it holds. However,\n@@ -139,23 +128,23 @@ fn compute_components<'tcx>(\n             // trait-ref. Therefore, if we see any higher-ranked regions,\n             // we simply fallback to the most restrictive rule, which\n             // requires that `Pi: 'a` for all `i`.\n-            ty::Alias(ty::Projection, data) => {\n-                if !data.has_escaping_bound_vars() {\n+            ty::Alias(_, alias_ty) => {\n+                if !alias_ty.has_escaping_bound_vars() {\n                     // best case: no escaping regions, so push the\n                     // projection and skip the subtree (thus generating no\n                     // constraints for Pi). This defers the choice between\n                     // the rules OutlivesProjectionEnv,\n                     // OutlivesProjectionTraitDef, and\n                     // OutlivesProjectionComponents to regionck.\n-                    out.push(Component::Alias(ty::Projection, data));\n+                    out.push(Component::Alias(alias_ty));\n                 } else {\n                     // fallback case: hard code\n                     // OutlivesProjectionComponents. Continue walking\n                     // through and constrain Pi.\n                     let mut subcomponents = smallvec![];\n                     let mut subvisited = SsoHashSet::new();\n                     compute_components_recursive(tcx, ty.into(), &mut subcomponents, &mut subvisited);\n-                    out.push(Component::EscapingProjection(subcomponents.into_iter().collect()));\n+                    out.push(Component::EscapingAlias(subcomponents.into_iter().collect()));\n                 }\n             }\n "}, {"sha": "24e3c34dd94fc40d28b22d2ea7675f62b7618144", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=19423b59440f464c6cbe6be442d447e37b50fe3c", "patch": "@@ -138,9 +138,9 @@ impl<'tcx> OutlivesEnvironmentBuilder<'tcx> {\n                     self.region_bound_pairs\n                         .insert(ty::OutlivesPredicate(GenericKind::Param(param_b), r_a));\n                 }\n-                OutlivesBound::RegionSubAlias(r_a, kind, projection_b) => {\n+                OutlivesBound::RegionSubAlias(r_a, alias_b) => {\n                     self.region_bound_pairs\n-                        .insert(ty::OutlivesPredicate(GenericKind::Alias(kind, projection_b), r_a));\n+                        .insert(ty::OutlivesPredicate(GenericKind::Alias(alias_b), r_a));\n                 }\n                 OutlivesBound::RegionSubRegion(r_a, r_b) => {\n                     if let (ReEarlyBound(_) | ReFree(_), ReVar(vid_b)) = (r_a.kind(), r_b.kind()) {"}, {"sha": "0194549a8868d3c5c3506a7ddd839715fca57bfe", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 19, "deletions": 62, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=19423b59440f464c6cbe6be442d447e37b50fe3c", "patch": "@@ -67,7 +67,6 @@ use crate::infer::{\n };\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::undo_log::UndoLogs;\n-use rustc_hir::def_id::DefId;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Region, SubstsRef, Ty, TyCtxt, TypeVisitable};\n@@ -266,10 +265,8 @@ where\n                 Component::Param(param_ty) => {\n                     self.param_ty_must_outlive(origin, region, *param_ty);\n                 }\n-                Component::Alias(kind, data) => {\n-                    self.alias_must_outlive(*kind, *data, origin, region)\n-                }\n-                Component::EscapingProjection(subcomponents) => {\n+                Component::Alias(alias_ty) => self.alias_ty_must_outlive(origin, region, *alias_ty),\n+                Component::EscapingAlias(subcomponents) => {\n                     self.components_must_outlive(origin, &subcomponents, region, category);\n                 }\n                 Component::UnresolvedInferenceVariable(v) => {\n@@ -285,61 +282,26 @@ where\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn param_ty_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         region: ty::Region<'tcx>,\n         param_ty: ty::ParamTy,\n     ) {\n-        debug!(\n-            \"param_ty_must_outlive(region={:?}, param_ty={:?}, origin={:?})\",\n-            region, param_ty, origin\n-        );\n-\n-        let generic = GenericKind::Param(param_ty);\n         let verify_bound = self.verify_bound.param_bound(param_ty);\n-        self.delegate.push_verify(origin, generic, region, verify_bound);\n+        self.delegate.push_verify(origin, GenericKind::Param(param_ty), region, verify_bound);\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n-    fn alias_must_outlive(\n+    fn alias_ty_must_outlive(\n         &mut self,\n-        kind: ty::AliasKind,\n-        data: ty::AliasTy<'tcx>,\n         origin: infer::SubregionOrigin<'tcx>,\n         region: ty::Region<'tcx>,\n-    ) {\n-        self.generic_must_outlive(\n-            origin,\n-            region,\n-            GenericKind::Alias(kind, data),\n-            data.def_id,\n-            data.substs,\n-            kind == ty::Opaque,\n-            |ty| match *ty.kind() {\n-                ty::Alias(filter_kind, ty::AliasTy { def_id, substs, .. })\n-                    if kind == filter_kind =>\n-                {\n-                    (def_id, substs)\n-                }\n-                _ => bug!(\"expected only projection types from env, not {:?}\", ty),\n-            },\n-        );\n-    }\n-\n-    #[instrument(level = \"debug\", skip(self, filter))]\n-    fn generic_must_outlive(\n-        &mut self,\n-        origin: infer::SubregionOrigin<'tcx>,\n-        region: ty::Region<'tcx>,\n-        generic: GenericKind<'tcx>,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n-        is_opaque: bool,\n-        filter: impl Fn(Ty<'tcx>) -> (DefId, SubstsRef<'tcx>),\n+        alias_ty: ty::AliasTy<'tcx>,\n     ) {\n         // An optimization for a common case with opaque types.\n-        if substs.is_empty() {\n+        if alias_ty.substs.is_empty() {\n             return;\n         }\n \n@@ -361,14 +323,14 @@ where\n         // These are guaranteed to apply, no matter the inference\n         // results.\n         let trait_bounds: Vec<_> =\n-            self.verify_bound.declared_region_bounds(def_id, substs).collect();\n+            self.verify_bound.declared_bounds_from_definition(alias_ty).collect();\n \n         debug!(?trait_bounds);\n \n         // Compute the bounds we can derive from the environment. This\n         // is an \"approximate\" match -- in some cases, these bounds\n         // may not apply.\n-        let mut approx_env_bounds = self.verify_bound.approx_declared_bounds_from_env(generic);\n+        let mut approx_env_bounds = self.verify_bound.approx_declared_bounds_from_env(alias_ty);\n         debug!(?approx_env_bounds);\n \n         // Remove outlives bounds that we get from the environment but\n@@ -383,8 +345,8 @@ where\n             // If the declaration is `trait Trait<'b> { type Item: 'b; }`, then `projection_declared_bounds_from_trait`\n             // will be invoked with `['b => ^1]` and so we will get `^1` returned.\n             let bound = bound_outlives.skip_binder();\n-            let (def_id, substs) = filter(bound.0);\n-            self.verify_bound.declared_region_bounds(def_id, substs).all(|r| r != bound.1)\n+            let ty::Alias(_, alias_ty) = bound.0.kind() else { bug!(\"expected AliasTy\") };\n+            self.verify_bound.declared_bounds_from_definition(*alias_ty).all(|r| r != bound.1)\n         });\n \n         // If declared bounds list is empty, the only applicable rule is\n@@ -401,12 +363,12 @@ where\n         // the problem is to add `T: 'r`, which isn't true. So, if there are no\n         // inference variables, we use a verify constraint instead of adding\n         // edges, which winds up enforcing the same condition.\n-        let needs_infer = substs.needs_infer();\n-        if approx_env_bounds.is_empty() && trait_bounds.is_empty() && (needs_infer || is_opaque) {\n+        if approx_env_bounds.is_empty()\n+            && trait_bounds.is_empty()\n+            && (alias_ty.needs_infer() || alias_ty.kind(self.tcx) == ty::Opaque)\n+        {\n             debug!(\"no declared bounds\");\n-\n-            self.substs_must_outlive(substs, origin, region);\n-\n+            self.substs_must_outlive(alias_ty.substs, origin, region);\n             return;\n         }\n \n@@ -447,14 +409,9 @@ where\n         // projection outlive; in some cases, this may add insufficient\n         // edges into the inference graph, leading to inference failures\n         // even though a satisfactory solution exists.\n-        let verify_bound = self.verify_bound.projection_opaque_bounds(\n-            generic,\n-            def_id,\n-            substs,\n-            &mut Default::default(),\n-        );\n-        debug!(\"projection_must_outlive: pushing {:?}\", verify_bound);\n-        self.delegate.push_verify(origin, generic, region, verify_bound);\n+        let verify_bound = self.verify_bound.alias_bound(alias_ty, &mut Default::default());\n+        debug!(\"alias_must_outlive: pushing {:?}\", verify_bound);\n+        self.delegate.push_verify(origin, GenericKind::Alias(alias_ty), region, verify_bound);\n     }\n \n     fn substs_must_outlive("}, {"sha": "94de9bc2d02283be28c98c6c576ff4f5c1499027", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 25, "deletions": 37, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=19423b59440f464c6cbe6be442d447e37b50fe3c", "patch": "@@ -1,11 +1,10 @@\n use crate::infer::outlives::components::{compute_components_recursive, Component};\n use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::region_constraints::VerifyIfEq;\n-use crate::infer::{GenericKind, VerifyBound};\n+use crate::infer::VerifyBound;\n use rustc_data_structures::sso::SsoHashSet;\n-use rustc_hir::def_id::DefId;\n use rustc_middle::ty::GenericArg;\n-use rustc_middle::ty::{self, OutlivesPredicate, SubstsRef, Ty, TyCtxt};\n+use rustc_middle::ty::{self, OutlivesPredicate, Ty, TyCtxt};\n \n use smallvec::smallvec;\n \n@@ -94,29 +93,26 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     /// this list.\n     pub fn approx_declared_bounds_from_env(\n         &self,\n-        generic: GenericKind<'tcx>,\n+        alias_ty: ty::AliasTy<'tcx>,\n     ) -> Vec<ty::Binder<'tcx, ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>> {\n-        let projection_ty = generic.to_ty(self.tcx);\n-        let erased_projection_ty = self.tcx.erase_regions(projection_ty);\n-        self.declared_generic_bounds_from_env_for_erased_ty(erased_projection_ty)\n+        let erased_alias_ty = self.tcx.erase_regions(alias_ty.to_ty(self.tcx));\n+        self.declared_generic_bounds_from_env_for_erased_ty(erased_alias_ty)\n     }\n \n     #[instrument(level = \"debug\", skip(self, visited))]\n-    pub fn projection_opaque_bounds(\n+    pub fn alias_bound(\n         &self,\n-        generic: GenericKind<'tcx>,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n+        alias_ty: ty::AliasTy<'tcx>,\n         visited: &mut SsoHashSet<GenericArg<'tcx>>,\n     ) -> VerifyBound<'tcx> {\n-        let generic_ty = generic.to_ty(self.tcx);\n+        let alias_ty_as_ty = alias_ty.to_ty(self.tcx);\n \n         // Search the env for where clauses like `P: 'a`.\n-        let projection_opaque_bounds = self\n-            .approx_declared_bounds_from_env(generic)\n+        let env_bounds = self\n+            .approx_declared_bounds_from_env(alias_ty)\n             .into_iter()\n             .map(|binder| {\n-                if let Some(ty::OutlivesPredicate(ty, r)) = binder.no_bound_vars() && ty == generic_ty {\n+                if let Some(ty::OutlivesPredicate(ty, r)) = binder.no_bound_vars() && ty == alias_ty_as_ty {\n                     // Micro-optimize if this is an exact match (this\n                     // occurs often when there are no region variables\n                     // involved).\n@@ -126,19 +122,19 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n                     VerifyBound::IfEq(verify_if_eq_b)\n                 }\n             });\n-        // Extend with bounds that we can find from the trait.\n-        let trait_bounds =\n-            self.declared_region_bounds(def_id, substs).map(|r| VerifyBound::OutlivedBy(r));\n+\n+        // Extend with bounds that we can find from the definition.\n+        let definition_bounds =\n+            self.declared_bounds_from_definition(alias_ty).map(|r| VerifyBound::OutlivedBy(r));\n \n         // see the extensive comment in projection_must_outlive\n         let recursive_bound = {\n             let mut components = smallvec![];\n-            compute_components_recursive(self.tcx, generic_ty.into(), &mut components, visited);\n+            compute_components_recursive(self.tcx, alias_ty_as_ty.into(), &mut components, visited);\n             self.bound_from_components(&components, visited)\n         };\n \n-        VerifyBound::AnyBound(projection_opaque_bounds.chain(trait_bounds).collect())\n-            .or(recursive_bound)\n+        VerifyBound::AnyBound(env_bounds.chain(definition_bounds).collect()).or(recursive_bound)\n     }\n \n     fn bound_from_components(\n@@ -149,10 +145,8 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         let mut bounds = components\n             .iter()\n             .map(|component| self.bound_from_single_component(component, visited))\n-            .filter(|bound| {\n-                // Remove bounds that must hold, since they are not interesting.\n-                !bound.must_hold()\n-            });\n+            // Remove bounds that must hold, since they are not interesting.\n+            .filter(|bound| !bound.must_hold());\n \n         match (bounds.next(), bounds.next()) {\n             (Some(first), None) => first,\n@@ -170,13 +164,8 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         match *component {\n             Component::Region(lt) => VerifyBound::OutlivedBy(lt),\n             Component::Param(param_ty) => self.param_bound(param_ty),\n-            Component::Alias(kind, data) => self.projection_opaque_bounds(\n-                GenericKind::Alias(kind, data),\n-                data.def_id,\n-                data.substs,\n-                visited,\n-            ),\n-            Component::EscapingProjection(ref components) => {\n+            Component::Alias(alias_ty) => self.alias_bound(alias_ty, visited),\n+            Component::EscapingAlias(ref components) => {\n                 self.bound_from_components(components, visited)\n             }\n             Component::UnresolvedInferenceVariable(v) => {\n@@ -292,16 +281,15 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     ///\n     /// This is for simplicity, and because we are not really smart\n     /// enough to cope with such bounds anywhere.\n-    pub fn declared_region_bounds(\n+    pub fn declared_bounds_from_definition(\n         &self,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n+        alias_ty: ty::AliasTy<'tcx>,\n     ) -> impl Iterator<Item = ty::Region<'tcx>> {\n         let tcx = self.tcx;\n-        let bounds = tcx.item_bounds(def_id);\n+        let bounds = tcx.item_bounds(alias_ty.def_id);\n         trace!(\"{:#?}\", bounds.0);\n         bounds\n-            .subst_iter(tcx, substs)\n+            .subst_iter(tcx, alias_ty.substs)\n             .filter_map(|p| p.to_opt_type_outlives())\n             .filter_map(|p| p.no_bound_vars())\n             .map(|OutlivesPredicate(_, r)| r)"}, {"sha": "0428481b7ff0282fff2ba59b311733e25c1fbd39", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=19423b59440f464c6cbe6be442d447e37b50fe3c", "patch": "@@ -167,7 +167,7 @@ pub struct Verify<'tcx> {\n #[derive(Copy, Clone, PartialEq, Eq, Hash, TypeFoldable, TypeVisitable)]\n pub enum GenericKind<'tcx> {\n     Param(ty::ParamTy),\n-    Alias(ty::AliasKind, ty::AliasTy<'tcx>),\n+    Alias(ty::AliasTy<'tcx>),\n }\n \n /// Describes the things that some `GenericKind` value `G` is known to\n@@ -746,10 +746,7 @@ impl<'tcx> fmt::Debug for GenericKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             GenericKind::Param(ref p) => write!(f, \"{:?}\", p),\n-            GenericKind::Alias(ty::Projection, ref p) => write!(f, \"{:?}\", p),\n-            GenericKind::Alias(ty::Opaque, ref p) => ty::tls::with(|tcx| {\n-                write!(f, \"{}\", tcx.def_path_str_with_substs(p.def_id, tcx.lift(p.substs).unwrap()))\n-            }),\n+            GenericKind::Alias(ref p) => write!(f, \"{:?}\", p),\n         }\n     }\n }\n@@ -758,10 +755,7 @@ impl<'tcx> fmt::Display for GenericKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             GenericKind::Param(ref p) => write!(f, \"{}\", p),\n-            GenericKind::Alias(ty::Projection, ref p) => write!(f, \"{}\", p),\n-            GenericKind::Alias(ty::Opaque, ref p) => ty::tls::with(|tcx| {\n-                write!(f, \"{}\", tcx.def_path_str_with_substs(p.def_id, tcx.lift(p.substs).unwrap()))\n-            }),\n+            GenericKind::Alias(ref p) => write!(f, \"{}\", p),\n         }\n     }\n }\n@@ -770,7 +764,7 @@ impl<'tcx> GenericKind<'tcx> {\n     pub fn to_ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             GenericKind::Param(ref p) => p.to_ty(tcx),\n-            GenericKind::Alias(kind, data) => tcx.mk_ty(ty::Alias(kind, data)),\n+            GenericKind::Alias(ref p) => p.to_ty(tcx),\n         }\n     }\n }"}, {"sha": "cd5bde2a791309c6c0f6d5aa6d73a55e412e0e36", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=19423b59440f464c6cbe6be442d447e37b50fe3c", "patch": "@@ -261,14 +261,15 @@ impl<'tcx> Elaborator<'tcx> {\n \n                             Component::UnresolvedInferenceVariable(_) => None,\n \n-                            Component::Alias(kind, data) => {\n-                                let ty = tcx.mk_ty(ty::Alias(kind, data));\n+                            Component::Alias(alias_ty) => {\n+                                // We might end up here if we have `Foo<<Bar as Baz>::Assoc>: 'a`.\n+                                // With this, we can deduce that `<Bar as Baz>::Assoc: 'a`.\n                                 Some(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n-                                    ty::OutlivesPredicate(ty, r_min),\n+                                    ty::OutlivesPredicate(alias_ty.to_ty(tcx), r_min),\n                                 )))\n                             }\n \n-                            Component::EscapingProjection(_) => {\n+                            Component::EscapingAlias(_) => {\n                                 // We might be able to do more here, but we don't\n                                 // want to deal with escaping vars right now.\n                                 None"}, {"sha": "615154a55e586dee13ce18a7e4fbb0d87ea96310", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=19423b59440f464c6cbe6be442d447e37b50fe3c", "patch": "@@ -213,5 +213,5 @@ pub struct NormalizationResult<'tcx> {\n pub enum OutlivesBound<'tcx> {\n     RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n     RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n-    RegionSubAlias(ty::Region<'tcx>, ty::AliasKind, ty::AliasTy<'tcx>),\n+    RegionSubAlias(ty::Region<'tcx>, ty::AliasTy<'tcx>),\n }"}, {"sha": "6a7b23e40a7792edb3cb7f72000cbb2f6a7321f3", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=19423b59440f464c6cbe6be442d447e37b50fe3c", "patch": "@@ -1245,19 +1245,34 @@ pub struct AliasTy<'tcx> {\n     /// aka. `tcx.parent(def_id)`.\n     pub def_id: DefId,\n \n-    /// This field exists to prevent the creation of `ProjectionTy` without using\n+    /// This field exists to prevent the creation of `AliasTy` without using\n     /// [TyCtxt::mk_alias_ty].\n     pub(super) _use_mk_alias_ty_instead: (),\n }\n \n+impl<'tcx> AliasTy<'tcx> {\n+    pub fn kind(self, tcx: TyCtxt<'tcx>) -> ty::AliasKind {\n+        match tcx.def_kind(self.def_id) {\n+            DefKind::AssocTy | DefKind::ImplTraitPlaceholder => ty::Projection,\n+            DefKind::OpaqueTy => ty::Opaque,\n+            kind => bug!(\"unexpected DefKind in AliasTy: {kind:?}\"),\n+        }\n+    }\n+\n+    pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+        tcx.mk_ty(ty::Alias(self.kind(tcx), self))\n+    }\n+}\n+\n+/// The following methods work only with associated type projections.\n impl<'tcx> AliasTy<'tcx> {\n     pub fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId {\n         match tcx.def_kind(self.def_id) {\n             DefKind::AssocTy | DefKind::AssocConst => tcx.parent(self.def_id),\n             DefKind::ImplTraitPlaceholder => {\n                 tcx.parent(tcx.impl_trait_in_trait_parent(self.def_id))\n             }\n-            kind => bug!(\"unexpected DefKind in ProjectionTy: {kind:?}\"),\n+            kind => bug!(\"expected a projection AliasTy; found {kind:?}\"),\n         }\n     }\n "}, {"sha": "7d2d8433c932d8d9d40b5656c1a78c99af9694de", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19423b59440f464c6cbe6be442d447e37b50fe3c/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=19423b59440f464c6cbe6be442d447e37b50fe3c", "patch": "@@ -154,10 +154,8 @@ fn implied_bounds_from_components<'tcx>(\n             match component {\n                 Component::Region(r) => Some(OutlivesBound::RegionSubRegion(sub_region, r)),\n                 Component::Param(p) => Some(OutlivesBound::RegionSubParam(sub_region, p)),\n-                Component::Alias(kind, p) => {\n-                    Some(OutlivesBound::RegionSubAlias(sub_region, kind, p))\n-                }\n-                Component::EscapingProjection(_) =>\n+                Component::Alias(p) => Some(OutlivesBound::RegionSubAlias(sub_region, p)),\n+                Component::EscapingAlias(_) =>\n                 // If the projection has escaping regions, don't\n                 // try to infer any implied bounds even for its\n                 // free components. This is conservative, because"}, {"sha": "b8fac45b76db7072eb2f6f3722aa0c6b843400a1", "filename": "tests/ui/type-alias-impl-trait/outlives-bound-var.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/19423b59440f464c6cbe6be442d447e37b50fe3c/tests%2Fui%2Ftype-alias-impl-trait%2Foutlives-bound-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19423b59440f464c6cbe6be442d447e37b50fe3c/tests%2Fui%2Ftype-alias-impl-trait%2Foutlives-bound-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Foutlives-bound-var.rs?ref=19423b59440f464c6cbe6be442d447e37b50fe3c", "patch": "@@ -0,0 +1,18 @@\n+// Here we process outlive obligations involving\n+// opaque types with bound vars in substs.\n+// This was an ICE.\n+//\n+// check-pass\n+#![feature(type_alias_impl_trait)]\n+\n+type Ty<'a> = impl Sized + 'a;\n+fn define<'a>() -> Ty<'a> {}\n+\n+// Ty<'^0>: 'static\n+fn test1(_: &'static fn(Ty<'_>)) {}\n+\n+fn test2() {\n+    None::<&fn(Ty<'_>)>;\n+}\n+\n+fn main() { }"}]}