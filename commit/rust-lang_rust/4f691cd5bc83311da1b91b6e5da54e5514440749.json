{"sha": "4f691cd5bc83311da1b91b6e5da54e5514440749", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNjkxY2Q1YmM4MzMxMWRhMWI5MWI2ZTVkYTU0ZTU1MTQ0NDA3NDk=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-09-24T01:25:41Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-09-24T01:25:41Z"}, "message": "visit::Visitor refactor: fold moves.rs VisitContext into ComputeModesVisitor.", "tree": {"sha": "e7d344c91528354295e65a4f11762fd2cdc3b27d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7d344c91528354295e65a4f11762fd2cdc3b27d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f691cd5bc83311da1b91b6e5da54e5514440749", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f691cd5bc83311da1b91b6e5da54e5514440749", "html_url": "https://github.com/rust-lang/rust/commit/4f691cd5bc83311da1b91b6e5da54e5514440749", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f691cd5bc83311da1b91b6e5da54e5514440749/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7eed184dbb07c18b27dab8d444e62a96e85313cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7eed184dbb07c18b27dab8d444e62a96e85313cc", "html_url": "https://github.com/rust-lang/rust/commit/7eed184dbb07c18b27dab8d444e62a96e85313cc"}], "stats": {"total": 198, "additions": 90, "deletions": 108}, "files": [{"sha": "17f07bb7b70181837d8f996e8ba3e290f624de12", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f691cd5bc83311da1b91b6e5da54e5514440749/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f691cd5bc83311da1b91b6e5da54e5514440749/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=4f691cd5bc83311da1b91b6e5da54e5514440749", "patch": "@@ -375,8 +375,6 @@ enum AnyVisitor {\n     NewVisitor(@mut visit::Visitor<()>),\n }\n \n-type VCObj = @mut Visitor<@mut Context>;\n-\n struct Context {\n     // All known lint modes (string versions)\n     dict: @LintDict,"}, {"sha": "b7bdb9a1e5d66a6e9fecf4a07c7358278fa1119b", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 90, "deletions": 106, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/4f691cd5bc83311da1b91b6e5da54e5514440749/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f691cd5bc83311da1b91b6e5da54e5514440749/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=4f691cd5bc83311da1b91b6e5da54e5514440749", "patch": "@@ -191,27 +191,24 @@ enum UseMode {\n     Read         // Read no matter what the type.\n }\n \n-struct ComputeModesVisitor;\n-\n-impl visit::Visitor<VisitContext> for ComputeModesVisitor {\n+impl visit::Visitor<()> for VisitContext {\n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&fn_decl,\n-                b:&Block, s:Span, n:NodeId, e:VisitContext) {\n-        compute_modes_for_fn(*self, fk, fd, b, s, n, e);\n+                b:&Block, s:Span, n:NodeId, _:()) {\n+        compute_modes_for_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_expr(&mut self, ex:@Expr, e:VisitContext) {\n-        compute_modes_for_expr(*self, ex, e);\n+    fn visit_expr(&mut self, ex:@Expr, _:()) {\n+        compute_modes_for_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l:@Local, e:VisitContext) {\n-        compute_modes_for_local(*self, l, e);\n+    fn visit_local(&mut self, l:@Local, _:()) {\n+        compute_modes_for_local(self, l);\n     }\n }\n \n pub fn compute_moves(tcx: ty::ctxt,\n                      method_map: method_map,\n                      crate: &Crate) -> MoveMaps\n {\n-    let mut visitor = ComputeModesVisitor;\n-    let visit_cx = VisitContext {\n+    let mut visit_cx = VisitContext {\n         tcx: tcx,\n         method_map: method_map,\n         move_maps: MoveMaps {\n@@ -220,7 +217,8 @@ pub fn compute_moves(tcx: ty::ctxt,\n             moved_variables_set: @mut HashSet::new()\n         }\n     };\n-    visit::walk_crate(&mut visitor, crate, visit_cx);\n+    let visit_cx = &mut visit_cx;\n+    visit::walk_crate(visit_cx, crate, ());\n     return visit_cx.move_maps;\n }\n \n@@ -238,44 +236,40 @@ pub fn moved_variable_node_id_from_def(def: Def) -> Option<NodeId> {\n ///////////////////////////////////////////////////////////////////////////\n // Expressions\n \n-fn compute_modes_for_local<'a>(v: ComputeModesVisitor,\n-                               local: @Local,\n-                               cx: VisitContext) {\n+fn compute_modes_for_local<'a>(cx: &mut VisitContext,\n+                               local: @Local) {\n     cx.use_pat(local.pat);\n     for &init in local.init.iter() {\n-        cx.use_expr(init, Read, v);\n+        cx.use_expr(init, Read);\n     }\n }\n \n-fn compute_modes_for_fn(v: ComputeModesVisitor,\n+fn compute_modes_for_fn(cx: &mut VisitContext,\n                         fk: &visit::fn_kind,\n                         decl: &fn_decl,\n                         body: &Block,\n                         span: Span,\n-                        id: NodeId,\n-                        cx: VisitContext) {\n-    let mut v = v;\n+                        id: NodeId) {\n     for a in decl.inputs.iter() {\n         cx.use_pat(a.pat);\n     }\n-    visit::walk_fn(&mut v, fk, decl, body, span, id, cx);\n+    visit::walk_fn(cx, fk, decl, body, span, id, ());\n }\n \n-fn compute_modes_for_expr(v: ComputeModesVisitor,\n-                          expr: @Expr,\n-                          cx: VisitContext)\n+fn compute_modes_for_expr(cx: &mut VisitContext,\n+                          expr: @Expr)\n {\n-    cx.consume_expr(expr, v);\n+    cx.consume_expr(expr);\n }\n \n impl VisitContext {\n-    pub fn consume_exprs(&self, exprs: &[@Expr], visitor: ComputeModesVisitor) {\n+    pub fn consume_exprs(&mut self, exprs: &[@Expr]) {\n         for expr in exprs.iter() {\n-            self.consume_expr(*expr, visitor);\n+            self.consume_expr(*expr);\n         }\n     }\n \n-    pub fn consume_expr(&self, expr: @Expr, visitor: ComputeModesVisitor) {\n+    pub fn consume_expr(&mut self, expr: @Expr) {\n         /*!\n          * Indicates that the value of `expr` will be consumed,\n          * meaning either copied or moved depending on its type.\n@@ -287,13 +281,13 @@ impl VisitContext {\n         let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n         if ty::type_moves_by_default(self.tcx, expr_ty) {\n             self.move_maps.moves_map.insert(expr.id);\n-            self.use_expr(expr, Move, visitor);\n+            self.use_expr(expr, Move);\n         } else {\n-            self.use_expr(expr, Read, visitor);\n+            self.use_expr(expr, Read);\n         };\n     }\n \n-    pub fn consume_block(&self, blk: &Block, visitor: ComputeModesVisitor) {\n+    pub fn consume_block(&mut self, blk: &Block) {\n         /*!\n          * Indicates that the value of `blk` will be consumed,\n          * meaning either copied or moved depending on its type.\n@@ -302,19 +296,17 @@ impl VisitContext {\n         debug!(\"consume_block(blk.id=%?)\", blk.id);\n \n         for stmt in blk.stmts.iter() {\n-            let mut v = visitor;\n-            v.visit_stmt(*stmt, *self);\n+            self.visit_stmt(*stmt, ());\n         }\n \n         for tail_expr in blk.expr.iter() {\n-            self.consume_expr(*tail_expr, visitor);\n+            self.consume_expr(*tail_expr);\n         }\n     }\n \n-    pub fn use_expr(&self,\n+    pub fn use_expr(&mut self,\n                     expr: @Expr,\n-                    expr_mode: UseMode,\n-                    visitor: ComputeModesVisitor) {\n+                    expr_mode: UseMode) {\n         /*!\n          * Indicates that `expr` is used with a given mode.  This will\n          * in turn trigger calls to the subcomponents of `expr`.\n@@ -351,25 +343,23 @@ impl VisitContext {\n             }\n \n             ExprUnary(_, UnDeref, base) => {       // *base\n-                if !self.use_overloaded_operator(\n-                    expr, base, [], visitor)\n+                if !self.use_overloaded_operator(expr, base, [])\n                 {\n                     // Moving out of *base moves out of base.\n-                    self.use_expr(base, comp_mode, visitor);\n+                    self.use_expr(base, comp_mode);\n                 }\n             }\n \n             ExprField(base, _, _) => {        // base.f\n                 // Moving out of base.f moves out of base.\n-                self.use_expr(base, comp_mode, visitor);\n+                self.use_expr(base, comp_mode);\n             }\n \n             ExprIndex(_, lhs, rhs) => {          // lhs[rhs]\n-                if !self.use_overloaded_operator(\n-                    expr, lhs, [rhs], visitor)\n+                if !self.use_overloaded_operator(expr, lhs, [rhs])\n                 {\n-                    self.use_expr(lhs, comp_mode, visitor);\n-                    self.consume_expr(rhs, visitor);\n+                    self.use_expr(lhs, comp_mode);\n+                    self.consume_expr(rhs);\n                 }\n             }\n \n@@ -394,20 +384,20 @@ impl VisitContext {\n                 if mode == Move {\n                     self.move_maps.moves_map.insert(callee.id);\n                 }\n-                self.use_expr(callee, mode, visitor);\n-                self.use_fn_args(callee.id, *args, visitor);\n+                self.use_expr(callee, mode);\n+                self.use_fn_args(callee.id, *args);\n             }\n \n             ExprMethodCall(callee_id, rcvr, _, _, ref args, _) => { // callee.m(args)\n                 // Implicit self is equivalent to & mode, but every\n                 // other kind should be + mode.\n-                self.use_receiver(rcvr, visitor);\n-                self.use_fn_args(callee_id, *args, visitor);\n+                self.use_receiver(rcvr);\n+                self.use_fn_args(callee_id, *args);\n             }\n \n             ExprStruct(_, ref fields, opt_with) => {\n                 for field in fields.iter() {\n-                    self.consume_expr(field.expr, visitor);\n+                    self.consume_expr(field.expr);\n                 }\n \n                 for with_expr in opt_with.iter() {\n@@ -449,50 +439,50 @@ impl VisitContext {\n                                                          which defines the `Drop` trait\",\n                                                         with_ty.user_string(self.tcx)));\n                         }\n-                        self.consume_expr(*with_expr, visitor);\n+                        self.consume_expr(*with_expr);\n                     } else {\n-                        self.use_expr(*with_expr, Read, visitor);\n+                        self.use_expr(*with_expr, Read);\n                     }\n                 }\n             }\n \n             ExprTup(ref exprs) => {\n-                self.consume_exprs(*exprs, visitor);\n+                self.consume_exprs(*exprs);\n             }\n \n             ExprIf(cond_expr, ref then_blk, opt_else_expr) => {\n-                self.consume_expr(cond_expr, visitor);\n-                self.consume_block(then_blk, visitor);\n+                self.consume_expr(cond_expr);\n+                self.consume_block(then_blk);\n                 for else_expr in opt_else_expr.iter() {\n-                    self.consume_expr(*else_expr, visitor);\n+                    self.consume_expr(*else_expr);\n                 }\n             }\n \n             ExprMatch(discr, ref arms) => {\n                 // We must do this first so that `arms_have_by_move_bindings`\n                 // below knows which bindings are moves.\n                 for arm in arms.iter() {\n-                    self.consume_arm(arm, visitor);\n+                    self.consume_arm(arm);\n                 }\n \n                 // The discriminant may, in fact, be partially moved\n                 // if there are by-move bindings, but borrowck deals\n                 // with that itself.\n-                self.use_expr(discr, Read, visitor);\n+                self.use_expr(discr, Read);\n             }\n \n             ExprParen(base) => {\n                 // Note: base is not considered a *component* here, so\n                 // use `expr_mode` not `comp_mode`.\n-                self.use_expr(base, expr_mode, visitor);\n+                self.use_expr(base, expr_mode);\n             }\n \n             ExprVec(ref exprs, _) => {\n-                self.consume_exprs(*exprs, visitor);\n+                self.consume_exprs(*exprs);\n             }\n \n             ExprAddrOf(_, base) => {   // &base\n-                self.use_expr(base, Read, visitor);\n+                self.use_expr(base, Read);\n             }\n \n             ExprLogLevel |\n@@ -502,70 +492,67 @@ impl VisitContext {\n             ExprLit(*) => {}\n \n             ExprLoop(ref blk, _) => {\n-                self.consume_block(blk, visitor);\n+                self.consume_block(blk);\n             }\n \n             ExprWhile(cond_expr, ref blk) => {\n-                self.consume_expr(cond_expr, visitor);\n-                self.consume_block(blk, visitor);\n+                self.consume_expr(cond_expr);\n+                self.consume_block(blk);\n             }\n \n             ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n \n             ExprUnary(_, _, lhs) => {\n-                if !self.use_overloaded_operator(\n-                    expr, lhs, [], visitor)\n+                if !self.use_overloaded_operator(expr, lhs, [])\n                 {\n-                    self.consume_expr(lhs, visitor);\n+                    self.consume_expr(lhs);\n                 }\n             }\n \n             ExprBinary(_, _, lhs, rhs) => {\n-                if !self.use_overloaded_operator(\n-                    expr, lhs, [rhs], visitor)\n+                if !self.use_overloaded_operator(expr, lhs, [rhs])\n                 {\n-                    self.consume_expr(lhs, visitor);\n-                    self.consume_expr(rhs, visitor);\n+                    self.consume_expr(lhs);\n+                    self.consume_expr(rhs);\n                 }\n             }\n \n             ExprBlock(ref blk) => {\n-                self.consume_block(blk, visitor);\n+                self.consume_block(blk);\n             }\n \n             ExprRet(ref opt_expr) => {\n                 for expr in opt_expr.iter() {\n-                    self.consume_expr(*expr, visitor);\n+                    self.consume_expr(*expr);\n                 }\n             }\n \n             ExprAssign(lhs, rhs) => {\n-                self.use_expr(lhs, Read, visitor);\n-                self.consume_expr(rhs, visitor);\n+                self.use_expr(lhs, Read);\n+                self.consume_expr(rhs);\n             }\n \n             ExprCast(base, _) => {\n-                self.consume_expr(base, visitor);\n+                self.consume_expr(base);\n             }\n \n             ExprAssignOp(_, _, lhs, rhs) => {\n                 // FIXME(#4712) --- Overloaded operators?\n                 //\n-                // if !self.use_overloaded_operator(\n-                //     expr, DoDerefArgs, lhs, [rhs], visitor)\n+                // if !self.use_overloaded_operator(expr, DoDerefArgs, lhs, [rhs])\n                 // {\n-                self.consume_expr(lhs, visitor);\n-                self.consume_expr(rhs, visitor);\n+                self.consume_expr(lhs);\n+                self.consume_expr(rhs);\n                 // }\n             }\n \n             ExprRepeat(base, count, _) => {\n-                self.consume_expr(base, visitor);\n-                self.consume_expr(count, visitor);\n+                self.consume_expr(base);\n+                self.consume_expr(count);\n             }\n \n             ExprDoBody(base) => {\n-                self.use_expr(base, comp_mode, visitor);\n+                self.use_expr(base, comp_mode);\n             }\n \n             ExprFnBlock(ref decl, ref body) => {\n@@ -574,11 +561,11 @@ impl VisitContext {\n                 }\n                 let cap_vars = self.compute_captures(expr.id);\n                 self.move_maps.capture_map.insert(expr.id, cap_vars);\n-                self.consume_block(body, visitor);\n+                self.consume_block(body);\n             }\n \n             ExprVstore(base, _) => {\n-                self.use_expr(base, comp_mode, visitor);\n+                self.use_expr(base, comp_mode);\n             }\n \n             ExprMac(*) => {\n@@ -589,40 +576,39 @@ impl VisitContext {\n         }\n     }\n \n-    pub fn use_overloaded_operator(&self,\n+    pub fn use_overloaded_operator(&mut self,\n                                    expr: &Expr,\n                                    receiver_expr: @Expr,\n-                                   arg_exprs: &[@Expr],\n-                                   visitor: ComputeModesVisitor)\n+                                   arg_exprs: &[@Expr])\n                                    -> bool {\n         if !self.method_map.contains_key(&expr.id) {\n             return false;\n         }\n \n-        self.use_receiver(receiver_expr, visitor);\n+        self.use_receiver(receiver_expr);\n \n         // for overloaded operatrs, we are always passing in a\n         // borrowed pointer, so it's always read mode:\n         for arg_expr in arg_exprs.iter() {\n-            self.use_expr(*arg_expr, Read, visitor);\n+            self.use_expr(*arg_expr, Read);\n         }\n \n         return true;\n     }\n \n-    pub fn consume_arm(&self, arm: &Arm, visitor: ComputeModesVisitor) {\n+    pub fn consume_arm(&mut self, arm: &Arm) {\n         for pat in arm.pats.iter() {\n             self.use_pat(*pat);\n         }\n \n         for guard in arm.guard.iter() {\n-            self.consume_expr(*guard, visitor);\n+            self.consume_expr(*guard);\n         }\n \n-        self.consume_block(&arm.body, visitor);\n+        self.consume_block(&arm.body);\n     }\n \n-    pub fn use_pat(&self, pat: @Pat) {\n+    pub fn use_pat(&mut self, pat: @Pat) {\n         /*!\n          *\n          * Decides whether each binding in a pattern moves the value\n@@ -651,28 +637,26 @@ impl VisitContext {\n         }\n     }\n \n-    pub fn use_receiver(&self,\n-                        receiver_expr: @Expr,\n-                        visitor: ComputeModesVisitor) {\n-        self.use_fn_arg(receiver_expr, visitor);\n+    pub fn use_receiver(&mut self,\n+                        receiver_expr: @Expr) {\n+        self.use_fn_arg(receiver_expr);\n     }\n \n-    pub fn use_fn_args(&self,\n+    pub fn use_fn_args(&mut self,\n                        _: NodeId,\n-                       arg_exprs: &[@Expr],\n-                       visitor: ComputeModesVisitor) {\n+                       arg_exprs: &[@Expr]) {\n         //! Uses the argument expressions.\n         for arg_expr in arg_exprs.iter() {\n-            self.use_fn_arg(*arg_expr, visitor);\n+            self.use_fn_arg(*arg_expr);\n         }\n     }\n \n-    pub fn use_fn_arg(&self, arg_expr: @Expr, visitor: ComputeModesVisitor) {\n+    pub fn use_fn_arg(&mut self, arg_expr: @Expr) {\n         //! Uses the argument.\n-        self.consume_expr(arg_expr, visitor)\n+        self.consume_expr(arg_expr)\n     }\n \n-    pub fn arms_have_by_move_bindings(&self,\n+    pub fn arms_have_by_move_bindings(&mut self,\n                                       moves_map: MovesMap,\n                                       arms: &[Arm])\n                                       -> Option<@Pat> {\n@@ -693,7 +677,7 @@ impl VisitContext {\n         ret\n     }\n \n-    pub fn compute_captures(&self, fn_expr_id: NodeId) -> @[CaptureVar] {\n+    pub fn compute_captures(&mut self, fn_expr_id: NodeId) -> @[CaptureVar] {\n         debug!(\"compute_capture_vars(fn_expr_id=%?)\", fn_expr_id);\n         let _indenter = indenter();\n "}]}