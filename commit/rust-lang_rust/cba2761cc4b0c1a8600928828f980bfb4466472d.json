{"sha": "cba2761cc4b0c1a8600928828f980bfb4466472d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiYTI3NjFjYzRiMGMxYTg2MDA5Mjg4MjhmOTgwYmZiNDQ2NjQ3MmQ=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-16T22:52:00Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-22T22:31:38Z"}, "message": "A new version of the sequential BFS. This uses the same approach as the parallel one, but without using the parallel vector oeprators.", "tree": {"sha": "c2caa5cc1a22494d7c20a363a8f2bf14b1ddfc83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2caa5cc1a22494d7c20a363a8f2bf14b1ddfc83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cba2761cc4b0c1a8600928828f980bfb4466472d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cba2761cc4b0c1a8600928828f980bfb4466472d", "html_url": "https://github.com/rust-lang/rust/commit/cba2761cc4b0c1a8600928828f980bfb4466472d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cba2761cc4b0c1a8600928828f980bfb4466472d/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4312fa44b9cab69aa08834016484cfec47f19843", "url": "https://api.github.com/repos/rust-lang/rust/commits/4312fa44b9cab69aa08834016484cfec47f19843", "html_url": "https://github.com/rust-lang/rust/commit/4312fa44b9cab69aa08834016484cfec47f19843"}], "stats": {"total": 91, "additions": 91, "deletions": 0}, "files": [{"sha": "14a0ea9d87a1047d359f743bdbfebe6908d55a76", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/cba2761cc4b0c1a8600928828f980bfb4466472d/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cba2761cc4b0c1a8600928828f980bfb4466472d/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=cba2761cc4b0c1a8600928828f980bfb4466472d", "patch": "@@ -168,6 +168,78 @@ fn bfs(graph: graph, key: node_id) -> bfs_result {\n     vec::from_mut(marks)\n }\n \n+#[doc=\"Another version of the bfs function.\n+\n+This one uses the same algorithm as the parallel one, just without\n+using the parallel vector operators.\"]\n+fn bfs2(graph: graph, key: node_id) -> bfs_result {\n+    // This works by doing functional updates of a color vector.\n+\n+    enum color {\n+        white,\n+        // node_id marks which node turned this gray/black.\n+        // the node id later becomes the parent.\n+        gray(node_id),\n+        black(node_id)\n+    };\n+\n+    let mut colors = vec::from_fn(graph.len()) {|i|\n+        if i as node_id == key {\n+            gray(key)\n+        }\n+        else {\n+            white\n+        }\n+    };\n+\n+    fn is_gray(c: color) -> bool {\n+        alt c {\n+          gray(_) { true }\n+          _ { false }\n+        }\n+    }\n+\n+    let mut i = 0u;\n+    while vec::any(colors, is_gray) {\n+        // Do the BFS.\n+        log(info, #fmt(\"PBFS iteration %?\", i));\n+        i += 1u;\n+        colors = colors.mapi() {|i, c|\n+            let c : color = c;\n+            alt c {\n+              white {\n+                let i = i as node_id;\n+                \n+                let neighbors = graph[i];\n+                \n+                let mut color = white;\n+\n+                neighbors.each() {|k|\n+                    if is_gray(colors[k]) {\n+                        color = gray(k);\n+                        false\n+                    }\n+                    else { true }\n+                };\n+\n+                color\n+              }\n+              gray(parent) { black(parent) }\n+              black(parent) { black(parent) }\n+            }\n+        }\n+    }\n+\n+    // Convert the results.\n+    vec::map(colors) {|c|\n+        alt c {\n+          white { -1 }\n+          black(parent) { parent }\n+          _ { fail \"Found remaining gray nodes in BFS\" }\n+        }\n+    }\n+}\n+\n #[doc=\"A parallel version of the bfs function.\"]\n fn pbfs(graph: graph, key: node_id) -> bfs_result {\n     // This works by doing functional updates of a color vector.\n@@ -378,6 +450,25 @@ fn main() {\n                                          stop - start));\n         }\n \n+        let start = time::precise_time_s();\n+        let bfs_tree = bfs2(graph, root);\n+        let stop = time::precise_time_s();\n+\n+        //total_seq += stop - start;\n+\n+        io::stdout().write_line(\n+            #fmt(\"Slow Sequential BFS completed in %? seconds.\",\n+                 stop - start));\n+\n+        if do_validate {\n+            let start = time::precise_time_s();\n+            assert(validate(edges, root, bfs_tree));\n+            let stop = time::precise_time_s();\n+            \n+            io::stdout().write_line(#fmt(\"Validation completed in %? seconds.\",\n+                                         stop - start));\n+        }\n+\n         let start = time::precise_time_s();\n         let bfs_tree = pbfs(graph, root);\n         let stop = time::precise_time_s();"}]}