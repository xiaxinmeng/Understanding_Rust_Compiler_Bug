{"sha": "c7466c9531c1a282380183c78001014c35dc9fac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NDY2Yzk1MzFjMWEyODIzODAxODNjNzgwMDEwMTRjMzVkYzlmYWM=", "commit": {"author": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-03-28T01:40:54Z"}, "committer": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-04-05T15:32:01Z"}, "message": "Add TerminationInfo::Deadlock, use in mutex shim", "tree": {"sha": "c0dbaf0d74bcf32075d322ffa56cba6feaed6095", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0dbaf0d74bcf32075d322ffa56cba6feaed6095"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7466c9531c1a282380183c78001014c35dc9fac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7466c9531c1a282380183c78001014c35dc9fac", "html_url": "https://github.com/rust-lang/rust/commit/c7466c9531c1a282380183c78001014c35dc9fac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7466c9531c1a282380183c78001014c35dc9fac/comments", "author": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de29546414cc5a987fd3317a9c3e5415e15a133b", "url": "https://api.github.com/repos/rust-lang/rust/commits/de29546414cc5a987fd3317a9c3e5415e15a133b", "html_url": "https://github.com/rust-lang/rust/commit/de29546414cc5a987fd3317a9c3e5415e15a133b"}], "stats": {"total": 82, "additions": 13, "deletions": 69}, "files": [{"sha": "2b53efe864e541b7454429cb1b316342b0113d6e", "filename": "src/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7466c9531c1a282380183c78001014c35dc9fac/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7466c9531c1a282380183c78001014c35dc9fac/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=c7466c9531c1a282380183c78001014c35dc9fac", "patch": "@@ -12,7 +12,8 @@ pub enum TerminationInfo {\n     Exit(i64),\n     Abort(Option<String>),\n     UnsupportedInIsolation(String),\n-    ExperimentalUb { msg: String, url: String }\n+    ExperimentalUb { msg: String, url: String },\n+    Deadlock,\n }\n \n impl fmt::Debug for TerminationInfo {\n@@ -29,6 +30,8 @@ impl fmt::Debug for TerminationInfo {\n                 write!(f, \"{}\", msg),\n             ExperimentalUb { msg, .. } =>\n                 write!(f, \"{}\", msg),\n+            Deadlock =>\n+                write!(f, \"the evaluated program deadlocked\"),\n         }\n     }\n }\n@@ -60,6 +63,7 @@ pub fn report_error<'tcx, 'mir>(\n                     \"unsupported operation\",\n                 ExperimentalUb { .. } =>\n                     \"Undefined Behavior\",\n+                Deadlock => \"deadlock\",\n             };\n             let helps = match info {\n                 UnsupportedInIsolation(_) =>"}, {"sha": "94e563353b8877686ec7a1aeecca31f8cca1f819", "filename": "src/shims/sync.rs", "status": "modified", "additions": 8, "deletions": 68, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c7466c9531c1a282380183c78001014c35dc9fac/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7466c9531c1a282380183c78001014c35dc9fac/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=c7466c9531c1a282380183c78001014c35dc9fac", "patch": "@@ -1,7 +1,5 @@\n-use std::sync::atomic::{AtomicU64, Ordering};\n-\n use rustc_middle::ty::{TyKind, TypeAndMut};\n-use rustc_target::abi::{FieldsShape, LayoutOf, Size};\n+use rustc_target::abi::{LayoutOf, Size};\n \n use crate::stacked_borrows::Tag;\n use crate::*;\n@@ -102,7 +100,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 mutex_set_locked_count(this, mutex_op, Scalar::from_u32(1))?;\n                 Ok(0)\n             } else {\n-                throw_unsup_format!(\"Deadlock due to locking a PTHREAD_MUTEX_NORMAL mutex twice\");\n+                throw_machine_stop!(TerminationInfo::Deadlock);\n             }\n         } else if kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")? {\n             if locked_count == 0 {\n@@ -404,58 +402,6 @@ fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n // bytes 12-15 or 16-19 (depending on platform): mutex kind, as an i32\n // (the kind has to be at its offset for compatibility with static initializer macros)\n \n-static LIBC_MUTEX_KIND_OFFSET_CACHE: AtomicU64 = AtomicU64::new(0);\n-\n-fn libc_mutex_kind_offset<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-) -> InterpResult<'tcx, u64> {\n-    // Check if this offset has already been found and memoized\n-    let cached_value = LIBC_MUTEX_KIND_OFFSET_CACHE.load(Ordering::Relaxed);\n-    if cached_value != 0 {\n-        return Ok(cached_value);\n-    }\n-\n-    // This function infers the offset of the `kind` field of libc's pthread_mutex_t\n-    // C struct by examining the array inside libc::PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP.\n-    // At time of writing, it is always all zero bytes except for a one byte at one of\n-    // four positions, depending on the target OS's C struct layout and the endianness of the\n-    // target architecture. This offset will then be used in getters and setters below, so that\n-    // mutexes created from static initializers can be emulated with the correct behavior.\n-    let initializer_path = [\"libc\", \"PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP\"];\n-    let initializer_instance = ecx.resolve_path(&initializer_path);\n-    let initializer_cid = GlobalId { instance: initializer_instance, promoted: None };\n-    let initializer_const_val = ecx.const_eval_raw(initializer_cid)?;\n-    let array_mplacety = ecx.mplace_field(initializer_const_val, 0)?;\n-    let array_length = match array_mplacety.layout.fields {\n-        FieldsShape::Array { count, .. } => count,\n-        _ => bug!(\"Couldn't get array length from type {:?}\", array_mplacety.layout.ty),\n-    };\n-\n-    let kind_offset = if array_length < 20 {\n-        bug!(\"libc::PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP array was shorter than expected\");\n-    } else if ecx.read_scalar(ecx.mplace_field(array_mplacety, 16)?.into())?.to_u8()? != 0 {\n-        // for little-endian architectures\n-        16\n-    } else if ecx.read_scalar(ecx.mplace_field(array_mplacety, 19)?.into())?.to_u8()? != 0 {\n-        // for big-endian architectures\n-        // (note that the i32 spans bytes 16 through 19, so the offset of the kind field is 16)\n-        16\n-    } else if ecx.read_scalar(ecx.mplace_field(array_mplacety, 12)?.into())?.to_u8()? != 0 {\n-        // for little-endian architectures\n-        12\n-    } else if ecx.read_scalar(ecx.mplace_field(array_mplacety, 15)?.into())?.to_u8()? != 0 {\n-        // for big-endian architectures\n-        // (note that the i32 spans bytes 12 through 15, so the offset of the kind field is 12)\n-        12\n-    } else {\n-        bug!(\"Couldn't determine offset of `kind` in pthread_mutex_t\");\n-    };\n-\n-    // Save offset to memoization cache for future calls\n-    LIBC_MUTEX_KIND_OFFSET_CACHE.store(kind_offset, Ordering::Relaxed);\n-    Ok(kind_offset)\n-}\n-\n fn mutex_get_locked_count<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     mutex_op: OpTy<'tcx, Tag>,\n@@ -491,12 +437,9 @@ fn mutex_get_kind<'mir, 'tcx: 'mir>(\n     assert_ptr_target_min_size(ecx, mutex_op, 20)?;\n     let mutex_place = ecx.deref_operand(mutex_op)?;\n     let i32_layout = ecx.layout_of(ecx.tcx.types.i32)?;\n-    let kind_place = mutex_place.offset(\n-        Size::from_bytes(libc_mutex_kind_offset(ecx)?),\n-        MemPlaceMeta::None,\n-        i32_layout,\n-        ecx,\n-    )?;\n+    let kind_offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n+    let kind_place =\n+        mutex_place.offset(Size::from_bytes(kind_offset), MemPlaceMeta::None, i32_layout, ecx)?;\n     ecx.read_scalar(kind_place.into())\n }\n \n@@ -509,12 +452,9 @@ fn mutex_set_kind<'mir, 'tcx: 'mir>(\n     assert_ptr_target_min_size(ecx, mutex_op, 20)?;\n     let mutex_place = ecx.deref_operand(mutex_op)?;\n     let i32_layout = ecx.layout_of(ecx.tcx.types.i32)?;\n-    let kind_place = mutex_place.offset(\n-        Size::from_bytes(libc_mutex_kind_offset(ecx)?),\n-        MemPlaceMeta::None,\n-        i32_layout,\n-        ecx,\n-    )?;\n+    let kind_offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n+    let kind_place =\n+        mutex_place.offset(Size::from_bytes(kind_offset), MemPlaceMeta::None, i32_layout, ecx)?;\n     ecx.write_scalar(kind.into(), kind_place.into())\n }\n "}]}