{"sha": "662ed41ebcb1cd221b32be95d08b5bf5f10ae525", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MmVkNDFlYmNiMWNkMjIxYjMyYmU5NWQwOGI1YmY1ZjEwYWU1MjU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-09-25T14:57:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-25T14:57:15Z"}, "message": "Merge #6073\n\n6073: Dont unnecessarily unnest imports r=matklad a=Veykril\n\nFixes #6071\r\n\r\nThis has the side effect that paths that refer to items inside of the current module get prefixed with `self`. Changing this behavior is unfortunately not straightforward should it be unwanted, though I don't see a problem with this as prefixing imports like this with `self` is what I do personally anyways \ud83d\ude05. You can see what I mean with this in one of the tests which had to be changed in `crates/ssr/src/tests.rs`.\r\n\r\nThere is one test that i still have to look at though, ~~which I by accident pushed with `#[ignore]` on it~~, which is `different_crate_renamed`, for some reason this now doesn't use the crate alias. This also makes me believe that aliases in general will break with this. So maybe this is not as straight forwards as I'd hoped for, but I don't really know how aliases work here.\r\n\r\nEdit: The failing test should work now\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "943ef1bbcd95d9854975da1d2d9c6a3aa24e11ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/943ef1bbcd95d9854975da1d2d9c6a3aa24e11ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/662ed41ebcb1cd221b32be95d08b5bf5f10ae525", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfbgVLCRBK7hj4Ov3rIwAAdHIIACpzOp6Aq5w4m1jw0HykB4+p\nhMi3CxTmSH1W0M/wudOW+BQxYyzSiRE9fsFEx9/dCdSiNX6izLiGK7CUlgkyiicS\npCuU+5Np2tKargticLuueDRf3V556FMHGLw7jL7WJwAWema/UFHOCw74Q7Jes5QR\n5Y27P22DpTKSJ3b6BXGNbl3QDFV2Du+CBxBJ3qAHwJ4u1sM0cJywNmKFHBdNIHlB\nx04lX4mS9eKYsxWaMkGuyfeqjCA/6l8mD7WuVQZV9+Tk0MvleFXiIGOX67+G4osB\nzqHfObnkCUzeNmxVbDpQR/LONqRagryTIpOq4rBbPdwqlJElF+xwCR4UPojjw14=\n=FI6S\n-----END PGP SIGNATURE-----\n", "payload": "tree 943ef1bbcd95d9854975da1d2d9c6a3aa24e11ba\nparent dc09f1597fea78900a6b67d4871edfbb6fafbcdc\nparent 747f6f64d7f8fae3a40be6ffacc9640bca068bd0\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1601045835 +0000\ncommitter GitHub <noreply@github.com> 1601045835 +0000\n\nMerge #6073\n\n6073: Dont unnecessarily unnest imports r=matklad a=Veykril\n\nFixes #6071\r\n\r\nThis has the side effect that paths that refer to items inside of the current module get prefixed with `self`. Changing this behavior is unfortunately not straightforward should it be unwanted, though I don't see a problem with this as prefixing imports like this with `self` is what I do personally anyways \ud83d\ude05. You can see what I mean with this in one of the tests which had to be changed in `crates/ssr/src/tests.rs`.\r\n\r\nThere is one test that i still have to look at though, ~~which I by accident pushed with `#[ignore]` on it~~, which is `different_crate_renamed`, for some reason this now doesn't use the crate alias. This also makes me believe that aliases in general will break with this. So maybe this is not as straight forwards as I'd hoped for, but I don't really know how aliases work here.\r\n\r\nEdit: The failing test should work now\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/662ed41ebcb1cd221b32be95d08b5bf5f10ae525", "html_url": "https://github.com/rust-lang/rust/commit/662ed41ebcb1cd221b32be95d08b5bf5f10ae525", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/662ed41ebcb1cd221b32be95d08b5bf5f10ae525/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc09f1597fea78900a6b67d4871edfbb6fafbcdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc09f1597fea78900a6b67d4871edfbb6fafbcdc", "html_url": "https://github.com/rust-lang/rust/commit/dc09f1597fea78900a6b67d4871edfbb6fafbcdc"}, {"sha": "747f6f64d7f8fae3a40be6ffacc9640bca068bd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/747f6f64d7f8fae3a40be6ffacc9640bca068bd0", "html_url": "https://github.com/rust-lang/rust/commit/747f6f64d7f8fae3a40be6ffacc9640bca068bd0"}], "stats": {"total": 258, "additions": 203, "deletions": 55}, "files": [{"sha": "1ac5fefd6a66c46c3270b4906dfaacfbd19b1758", "filename": "crates/assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/662ed41ebcb1cd221b32be95d08b5bf5f10ae525/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662ed41ebcb1cd221b32be95d08b5bf5f10ae525/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=662ed41ebcb1cd221b32be95d08b5bf5f10ae525", "patch": "@@ -414,6 +414,41 @@ impl foo::Foo for S {\n         );\n     }\n \n+    #[test]\n+    fn test_qualify_path_2() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Bar;\n+        pub trait Foo { fn foo(&self, bar: Bar); }\n+    }\n+}\n+\n+use foo::bar;\n+\n+struct S;\n+impl bar::Foo for S { <|> }\"#,\n+            r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Bar;\n+        pub trait Foo { fn foo(&self, bar: Bar); }\n+    }\n+}\n+\n+use foo::bar;\n+\n+struct S;\n+impl bar::Foo for S {\n+    fn foo(&self, bar: bar::Bar) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_qualify_path_generic() {\n         check_assist("}, {"sha": "ee7277c043604f2a2a212496a6383cb797aad923", "filename": "crates/assists/src/handlers/auto_import.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/662ed41ebcb1cd221b32be95d08b5bf5f10ae525/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662ed41ebcb1cd221b32be95d08b5bf5f10ae525/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=662ed41ebcb1cd221b32be95d08b5bf5f10ae525", "patch": "@@ -196,10 +196,10 @@ impl AutoImportAssets {\n             })\n             .filter_map(|candidate| match candidate {\n                 Either::Left(module_def) => {\n-                    self.module_with_name_to_import.find_use_path(db, module_def)\n+                    self.module_with_name_to_import.find_use_path_prefixed(db, module_def)\n                 }\n                 Either::Right(macro_def) => {\n-                    self.module_with_name_to_import.find_use_path(db, macro_def)\n+                    self.module_with_name_to_import.find_use_path_prefixed(db, macro_def)\n                 }\n             })\n             .filter(|use_path| !use_path.segments.is_empty())\n@@ -290,6 +290,35 @@ mod tests {\n     use super::*;\n     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n+    #[test]\n+    fn applicable_when_found_an_import_partial() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            mod std {\n+                pub mod fmt {\n+                    pub struct Formatter;\n+                }\n+            }\n+\n+            use std::fmt;\n+\n+            <|>Formatter\n+            \",\n+            r\"\n+            mod std {\n+                pub mod fmt {\n+                    pub struct Formatter;\n+                }\n+            }\n+\n+            use std::fmt::{self, Formatter};\n+\n+            Formatter\n+            \",\n+        );\n+    }\n+\n     #[test]\n     fn applicable_when_found_an_import() {\n         check_assist("}, {"sha": "5719b06af2d9cff4231268f62fac1563a30af8e0", "filename": "crates/assists/src/utils/insert_use.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/662ed41ebcb1cd221b32be95d08b5bf5f10ae525/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662ed41ebcb1cd221b32be95d08b5bf5f10ae525/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=662ed41ebcb1cd221b32be95d08b5bf5f10ae525", "patch": "@@ -809,16 +809,6 @@ use std::io;\",\n         // FIXME: have it emit `use {self, *}`?\n     }\n \n-    #[test]\n-    #[ignore] // FIXME: Support this\n-    fn merge_partial_path() {\n-        check_full(\n-            \"ast::Foo\",\n-            r\"use syntax::{ast, algo};\",\n-            r\"use syntax::{ast::{self, Foo}, algo};\",\n-        )\n-    }\n-\n     #[test]\n     fn merge_glob_nested() {\n         check_full("}, {"sha": "567fd91afb43b92bc507da86e45bd2d79e979bab", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/662ed41ebcb1cd221b32be95d08b5bf5f10ae525/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662ed41ebcb1cd221b32be95d08b5bf5f10ae525/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=662ed41ebcb1cd221b32be95d08b5bf5f10ae525", "patch": "@@ -383,6 +383,16 @@ impl Module {\n     pub fn find_use_path(self, db: &dyn DefDatabase, item: impl Into<ItemInNs>) -> Option<ModPath> {\n         hir_def::find_path::find_path(db, item.into(), self.into())\n     }\n+\n+    /// Finds a path that can be used to refer to the given item from within\n+    /// this module, if possible. This is used for returning import paths for use-statements.\n+    pub fn find_use_path_prefixed(\n+        self,\n+        db: &dyn DefDatabase,\n+        item: impl Into<ItemInNs>,\n+    ) -> Option<ModPath> {\n+        hir_def::find_path::find_path_prefixed(db, item.into(), self.into())\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "baf3741448d2775f8cfffa096d2221a794c526b9", "filename": "crates/hir_def/src/find_path.rs", "status": "modified", "additions": 127, "deletions": 43, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/662ed41ebcb1cd221b32be95d08b5bf5f10ae525/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662ed41ebcb1cd221b32be95d08b5bf5f10ae525/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ffind_path.rs?ref=662ed41ebcb1cd221b32be95d08b5bf5f10ae525", "patch": "@@ -4,6 +4,7 @@ use hir_expand::name::{known, AsName, Name};\n use rustc_hash::FxHashSet;\n use test_utils::mark;\n \n+use crate::nameres::CrateDefMap;\n use crate::{\n     db::DefDatabase,\n     item_scope::ItemInNs,\n@@ -18,7 +19,12 @@ use crate::{\n /// *from where* you're referring to the item, hence the `from` parameter.\n pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n     let _p = profile::span(\"find_path\");\n-    find_path_inner(db, item, from, MAX_PATH_LEN)\n+    find_path_inner(db, item, from, MAX_PATH_LEN, Prefixed::Not)\n+}\n+\n+pub fn find_path_prefixed(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n+    let _p = profile::span(\"find_path_absolute\");\n+    find_path_inner(db, item, from, MAX_PATH_LEN, Prefixed::Plain)\n }\n \n const MAX_PATH_LEN: usize = 15;\n@@ -36,11 +42,67 @@ impl ModPath {\n     }\n }\n \n+fn check_crate_self_super(\n+    def_map: &CrateDefMap,\n+    item: ItemInNs,\n+    from: ModuleId,\n+) -> Option<ModPath> {\n+    // - if the item is the crate root, return `crate`\n+    if item\n+        == ItemInNs::Types(ModuleDefId::ModuleId(ModuleId {\n+            krate: from.krate,\n+            local_id: def_map.root,\n+        }))\n+    {\n+        Some(ModPath::from_segments(PathKind::Crate, Vec::new()))\n+    } else if item == ItemInNs::Types(from.into()) {\n+        // - if the item is the module we're in, use `self`\n+        Some(ModPath::from_segments(PathKind::Super(0), Vec::new()))\n+    } else {\n+        if let Some(parent_id) = def_map.modules[from.local_id].parent {\n+            // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n+            if item\n+                == ItemInNs::Types(ModuleDefId::ModuleId(ModuleId {\n+                    krate: from.krate,\n+                    local_id: parent_id,\n+                }))\n+            {\n+                return Some(ModPath::from_segments(PathKind::Super(1), Vec::new()));\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub enum Prefixed {\n+    Not,\n+    BySelf,\n+    Plain,\n+}\n+\n+impl Prefixed {\n+    #[inline]\n+    fn prefix(self) -> Option<PathKind> {\n+        match self {\n+            Prefixed::Not => None,\n+            Prefixed::BySelf => Some(PathKind::Super(0)),\n+            Prefixed::Plain => Some(PathKind::Plain),\n+        }\n+    }\n+\n+    #[inline]\n+    fn prefixed(self) -> bool {\n+        self != Prefixed::Not\n+    }\n+}\n+\n fn find_path_inner(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n     max_len: usize,\n+    prefixed: Prefixed,\n ) -> Option<ModPath> {\n     if max_len == 0 {\n         return None;\n@@ -51,41 +113,22 @@ fn find_path_inner(\n     // - if the item is already in scope, return the name under which it is\n     let def_map = db.crate_def_map(from.krate);\n     let from_scope: &crate::item_scope::ItemScope = &def_map.modules[from.local_id].scope;\n-    if let Some((name, _)) = from_scope.name_of(item) {\n-        return Some(ModPath::from_segments(PathKind::Plain, vec![name.clone()]));\n+    let scope_name =\n+        if let Some((name, _)) = from_scope.name_of(item) { Some(name.clone()) } else { None };\n+    if !prefixed.prefixed() && scope_name.is_some() {\n+        return scope_name\n+            .map(|scope_name| ModPath::from_segments(PathKind::Plain, vec![scope_name]));\n     }\n \n-    // - if the item is the crate root, return `crate`\n-    if item\n-        == ItemInNs::Types(ModuleDefId::ModuleId(ModuleId {\n-            krate: from.krate,\n-            local_id: def_map.root,\n-        }))\n-    {\n-        return Some(ModPath::from_segments(PathKind::Crate, Vec::new()));\n-    }\n-\n-    // - if the item is the module we're in, use `self`\n-    if item == ItemInNs::Types(from.into()) {\n-        return Some(ModPath::from_segments(PathKind::Super(0), Vec::new()));\n-    }\n-\n-    // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n-    if let Some(parent_id) = def_map.modules[from.local_id].parent {\n-        if item\n-            == ItemInNs::Types(ModuleDefId::ModuleId(ModuleId {\n-                krate: from.krate,\n-                local_id: parent_id,\n-            }))\n-        {\n-            return Some(ModPath::from_segments(PathKind::Super(1), Vec::new()));\n-        }\n+    if let modpath @ Some(_) = check_crate_self_super(&def_map, item, from) {\n+        return modpath;\n     }\n \n     // - if the item is the crate root of a dependency crate, return the name from the extern prelude\n     for (name, def_id) in &def_map.extern_prelude {\n         if item == ItemInNs::Types(*def_id) {\n-            return Some(ModPath::from_segments(PathKind::Plain, vec![name.clone()]));\n+            let name = scope_name.unwrap_or_else(|| name.clone());\n+            return Some(ModPath::from_segments(PathKind::Plain, vec![name]));\n         }\n     }\n \n@@ -138,6 +181,7 @@ fn find_path_inner(\n                 ItemInNs::Types(ModuleDefId::ModuleId(module_id)),\n                 from,\n                 best_path_len - 1,\n+                prefixed,\n             ) {\n                 path.segments.push(name);\n \n@@ -165,6 +209,7 @@ fn find_path_inner(\n                     ItemInNs::Types(ModuleDefId::ModuleId(info.container)),\n                     from,\n                     best_path_len - 1,\n+                    prefixed,\n                 )?;\n                 path.segments.push(info.path.segments.last().unwrap().clone());\n                 Some(path)\n@@ -181,7 +226,13 @@ fn find_path_inner(\n         }\n     }\n \n-    best_path\n+    if let Some(prefix) = prefixed.prefix() {\n+        best_path.or_else(|| {\n+            scope_name.map(|scope_name| ModPath::from_segments(prefix, vec![scope_name]))\n+        })\n+    } else {\n+        best_path\n+    }\n }\n \n fn select_best_path(old_path: ModPath, new_path: ModPath, prefer_no_std: bool) -> ModPath {\n@@ -304,7 +355,7 @@ mod tests {\n     /// `code` needs to contain a cursor marker; checks that `find_path` for the\n     /// item the `path` refers to returns that same path when called from the\n     /// module the cursor is in.\n-    fn check_found_path(ra_fixture: &str, path: &str) {\n+    fn check_found_path_(ra_fixture: &str, path: &str, absolute: bool) {\n         let (db, pos) = TestDB::with_position(ra_fixture);\n         let module = db.module_for_file(pos.file_id);\n         let parsed_path_file = syntax::SourceFile::parse(&format!(\"use {};\", path));\n@@ -324,9 +375,20 @@ mod tests {\n             .take_types()\n             .unwrap();\n \n-        let found_path = find_path(&db, ItemInNs::Types(resolved), module);\n+        let found_path = if absolute { find_path_prefixed } else { find_path }(\n+            &db,\n+            ItemInNs::Types(resolved),\n+            module,\n+        );\n+        assert_eq!(found_path, Some(mod_path), \"absolute {}\", absolute);\n+    }\n+\n+    fn check_found_path(ra_fixture: &str, path: &str) {\n+        check_found_path_(ra_fixture, path, false);\n+    }\n \n-        assert_eq!(found_path, Some(mod_path));\n+    fn check_found_path_abs(ra_fixture: &str, path: &str) {\n+        check_found_path_(ra_fixture, path, true);\n     }\n \n     #[test]\n@@ -337,6 +399,7 @@ mod tests {\n             <|>\n         \"#;\n         check_found_path(code, \"S\");\n+        check_found_path_abs(code, \"S\");\n     }\n \n     #[test]\n@@ -347,6 +410,7 @@ mod tests {\n             <|>\n         \"#;\n         check_found_path(code, \"E::A\");\n+        check_found_path_abs(code, \"E::A\");\n     }\n \n     #[test]\n@@ -359,6 +423,7 @@ mod tests {\n             <|>\n         \"#;\n         check_found_path(code, \"foo::S\");\n+        check_found_path_abs(code, \"foo::S\");\n     }\n \n     #[test]\n@@ -373,6 +438,7 @@ mod tests {\n             <|>\n         \"#;\n         check_found_path(code, \"super::S\");\n+        check_found_path_abs(code, \"super::S\");\n     }\n \n     #[test]\n@@ -384,6 +450,7 @@ mod tests {\n             <|>\n         \"#;\n         check_found_path(code, \"self\");\n+        check_found_path_abs(code, \"self\");\n     }\n \n     #[test]\n@@ -395,6 +462,7 @@ mod tests {\n             <|>\n         \"#;\n         check_found_path(code, \"crate\");\n+        check_found_path_abs(code, \"crate\");\n     }\n \n     #[test]\n@@ -407,6 +475,7 @@ mod tests {\n             <|>\n         \"#;\n         check_found_path(code, \"crate::S\");\n+        check_found_path_abs(code, \"crate::S\");\n     }\n \n     #[test]\n@@ -418,6 +487,7 @@ mod tests {\n             pub struct S;\n         \"#;\n         check_found_path(code, \"std::S\");\n+        check_found_path_abs(code, \"std::S\");\n     }\n \n     #[test]\n@@ -430,14 +500,14 @@ mod tests {\n             pub struct S;\n         \"#;\n         check_found_path(code, \"std_renamed::S\");\n+        check_found_path_abs(code, \"std_renamed::S\");\n     }\n \n     #[test]\n     fn partially_imported() {\n         // Tests that short paths are used even for external items, when parts of the path are\n         // already in scope.\n-        check_found_path(\n-            r#\"\n+        let code = r#\"\n             //- /main.rs crate:main deps:syntax\n \n             use syntax::ast;\n@@ -449,12 +519,11 @@ mod tests {\n                     A, B, C,\n                 }\n             }\n-        \"#,\n-            \"ast::ModuleItem\",\n-        );\n+        \"#;\n+        check_found_path(code, \"ast::ModuleItem\");\n+        check_found_path_abs(code, \"syntax::ast::ModuleItem\");\n \n-        check_found_path(\n-            r#\"\n+        let code = r#\"\n             //- /main.rs crate:main deps:syntax\n \n             <|>\n@@ -465,9 +534,9 @@ mod tests {\n                     A, B, C,\n                 }\n             }\n-        \"#,\n-            \"syntax::ast::ModuleItem\",\n-        );\n+        \"#;\n+        check_found_path(code, \"syntax::ast::ModuleItem\");\n+        check_found_path_abs(code, \"syntax::ast::ModuleItem\");\n     }\n \n     #[test]\n@@ -481,6 +550,7 @@ mod tests {\n             <|>\n         \"#;\n         check_found_path(code, \"bar::S\");\n+        check_found_path_abs(code, \"bar::S\");\n     }\n \n     #[test]\n@@ -494,6 +564,7 @@ mod tests {\n             <|>\n         \"#;\n         check_found_path(code, \"bar::U\");\n+        check_found_path_abs(code, \"bar::U\");\n     }\n \n     #[test]\n@@ -507,6 +578,7 @@ mod tests {\n             pub struct S;\n         \"#;\n         check_found_path(code, \"std::S\");\n+        check_found_path_abs(code, \"std::S\");\n     }\n \n     #[test]\n@@ -520,6 +592,7 @@ mod tests {\n             pub use prelude::*;\n         \"#;\n         check_found_path(code, \"S\");\n+        check_found_path_abs(code, \"S\");\n     }\n \n     #[test]\n@@ -537,6 +610,8 @@ mod tests {\n         \"#;\n         check_found_path(code, \"None\");\n         check_found_path(code, \"Some\");\n+        check_found_path_abs(code, \"None\");\n+        check_found_path_abs(code, \"Some\");\n     }\n \n     #[test]\n@@ -553,6 +628,7 @@ mod tests {\n             pub use crate::foo::bar::S;\n         \"#;\n         check_found_path(code, \"baz::S\");\n+        check_found_path_abs(code, \"baz::S\");\n     }\n \n     #[test]\n@@ -567,6 +643,7 @@ mod tests {\n         \"#;\n         // crate::S would be shorter, but using private imports seems wrong\n         check_found_path(code, \"crate::bar::S\");\n+        check_found_path_abs(code, \"crate::bar::S\");\n     }\n \n     #[test]\n@@ -585,6 +662,7 @@ mod tests {\n             pub use super::foo;\n         \"#;\n         check_found_path(code, \"crate::foo::S\");\n+        check_found_path_abs(code, \"crate::foo::S\");\n     }\n \n     #[test]\n@@ -605,6 +683,7 @@ mod tests {\n         }\n         \"#;\n         check_found_path(code, \"std::sync::Arc\");\n+        check_found_path_abs(code, \"std::sync::Arc\");\n     }\n \n     #[test]\n@@ -629,6 +708,7 @@ mod tests {\n         }\n         \"#;\n         check_found_path(code, \"core::fmt::Error\");\n+        check_found_path_abs(code, \"core::fmt::Error\");\n     }\n \n     #[test]\n@@ -652,6 +732,7 @@ mod tests {\n         }\n         \"#;\n         check_found_path(code, \"alloc::sync::Arc\");\n+        check_found_path_abs(code, \"alloc::sync::Arc\");\n     }\n \n     #[test]\n@@ -669,6 +750,7 @@ mod tests {\n         pub struct Arc;\n         \"#;\n         check_found_path(code, \"megaalloc::Arc\");\n+        check_found_path_abs(code, \"megaalloc::Arc\");\n     }\n \n     #[test]\n@@ -683,5 +765,7 @@ mod tests {\n         \"#;\n         check_found_path(code, \"u8\");\n         check_found_path(code, \"u16\");\n+        check_found_path_abs(code, \"u8\");\n+        check_found_path_abs(code, \"u16\");\n     }\n }"}]}