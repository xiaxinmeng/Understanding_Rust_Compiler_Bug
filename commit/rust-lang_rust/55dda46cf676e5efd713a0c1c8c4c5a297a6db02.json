{"sha": "55dda46cf676e5efd713a0c1c8c4c5a297a6db02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZGRhNDZjZjY3NmU1ZWZkNzEzYTBjMWM4YzRjNWEyOTdhNmRiMDI=", "commit": {"author": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-06-20T17:51:04Z"}, "committer": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-06-20T17:51:04Z"}, "message": "Merge remote-tracking branch 'upstream/io' into io", "tree": {"sha": "3531f11ec1bd3614733efec48ade027593a77d54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3531f11ec1bd3614733efec48ade027593a77d54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55dda46cf676e5efd713a0c1c8c4c5a297a6db02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55dda46cf676e5efd713a0c1c8c4c5a297a6db02", "html_url": "https://github.com/rust-lang/rust/commit/55dda46cf676e5efd713a0c1c8c4c5a297a6db02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/comments", "author": null, "committer": null, "parents": [{"sha": "36c0e04e57f165681408baeb0149f9a164479599", "url": "https://api.github.com/repos/rust-lang/rust/commits/36c0e04e57f165681408baeb0149f9a164479599", "html_url": "https://github.com/rust-lang/rust/commit/36c0e04e57f165681408baeb0149f9a164479599"}, {"sha": "b548c781aa959085474d9e16f11a4dffb8420af5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b548c781aa959085474d9e16f11a4dffb8420af5", "html_url": "https://github.com/rust-lang/rust/commit/b548c781aa959085474d9e16f11a4dffb8420af5"}], "stats": {"total": 332, "additions": 249, "deletions": 83}, "files": [{"sha": "7748c43efcd28b7eddf8fd356061d9e4f2c0a715", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=55dda46cf676e5efd713a0c1c8c4c5a297a6db02", "patch": "@@ -10,18 +10,16 @@\n \n #[macro_escape];\n \n+macro_rules! rterrln (\n+    ($( $arg:expr),+) => ( {\n+        ::rt::util::dumb_println(fmt!( $($arg),+ ));\n+    } )\n+)\n+\n // Some basic logging\n macro_rules! rtdebug_ (\n     ($( $arg:expr),+) => ( {\n-        dumb_println(fmt!( $($arg),+ ));\n-\n-        fn dumb_println(s: &str) {\n-            use io::WriterUtil;\n-            let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n-            dbg.write_str(s);\n-            dbg.write_str(\"\\n\");\n-        }\n-\n+        rterrln!( $($arg),+ )\n     } )\n )\n \n@@ -33,24 +31,15 @@ macro_rules! rtdebug (\n macro_rules! rtassert (\n     ( $arg:expr ) => ( {\n         if !$arg {\n-            abort!(\"assertion failed: %s\", stringify!($arg));\n+            rtabort!(\"assertion failed: %s\", stringify!($arg));\n         }\n     } )\n )\n \n \n-// The do_abort function was originally inside the abort macro, but\n-// this was ICEing the compiler so it has been moved outside. Now this\n-// seems to work?\n-#[allow(missing_doc)]\n-pub fn do_abort() -> ! {\n-    unsafe { ::libc::abort(); }\n-}\n-\n-macro_rules! abort(\n+macro_rules! rtabort(\n     ($( $msg:expr),+) => ( {\n-        rtdebug!($($msg),+);\n-        ::macros::do_abort();\n+        ::rt::util::abort(fmt!($($msg),+));\n     } )\n )\n "}, {"sha": "e89df2b1c93f5bcb7aec84c98c0cdae9a7e6466b", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=55dda46cf676e5efd713a0c1c8c4c5a297a6db02", "patch": "@@ -14,7 +14,7 @@ use c_malloc = libc::malloc;\n use c_free = libc::free;\n use managed::raw::{BoxHeaderRepr, BoxRepr};\n use cast::transmute;\n-use unstable::intrinsics::{atomic_xadd,atomic_xsub};\n+use unstable::intrinsics::{atomic_xadd,atomic_xsub, atomic_load};\n use ptr::null;\n use intrinsic::TyDesc;\n \n@@ -34,8 +34,7 @@ pub unsafe fn malloc(td: *TypeDesc, size: uint) -> *c_void {\n     box.header.prev = null();\n     box.header.next = null();\n \n-    let exchange_count = &mut *exchange_count_ptr();\n-    atomic_xadd(exchange_count, 1);\n+    inc_count();\n \n     return transmute(box);\n }\n@@ -48,21 +47,46 @@ pub unsafe fn malloc_raw(size: uint) -> *c_void {\n     if p.is_null() {\n         fail!(\"Failure in malloc_raw: result ptr is null\");\n     }\n+    inc_count();\n     p\n }\n \n pub unsafe fn free(ptr: *c_void) {\n-    let exchange_count = &mut *exchange_count_ptr();\n-    atomic_xsub(exchange_count, 1);\n-\n     assert!(ptr.is_not_null());\n+    dec_count();\n     c_free(ptr);\n }\n ///Thin wrapper around libc::free, as with exchange_alloc::malloc_raw\n pub unsafe fn free_raw(ptr: *c_void) {\n+    assert!(ptr.is_not_null());\n+    dec_count();\n     c_free(ptr);\n }\n \n+fn inc_count() {\n+    unsafe {\n+        let exchange_count = &mut *exchange_count_ptr();\n+        atomic_xadd(exchange_count, 1);\n+    }\n+}\n+\n+fn dec_count() {\n+    unsafe {\n+        let exchange_count = &mut *exchange_count_ptr();\n+        atomic_xsub(exchange_count, 1);\n+    }\n+}\n+\n+pub fn cleanup() {\n+    unsafe {\n+        let count_ptr = exchange_count_ptr();\n+        let allocations = atomic_load(&*count_ptr);\n+        if allocations != 0 {\n+            rtabort!(\"exchange heap not empty on exit - %i dangling allocations\", allocations);\n+        }\n+    }\n+}\n+\n fn get_box_size(body_size: uint, body_align: uint) -> uint {\n     let header_size = size_of::<BoxHeaderRepr>();\n     // FIXME (#2699): This alignment calculation is suspicious. Is it right?"}, {"sha": "6df1ffaa453f3482b256206cfcab077e5a9ee8bf", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=55dda46cf676e5efd713a0c1c8c4c5a297a6db02", "patch": "@@ -38,25 +38,25 @@ impl Local for Scheduler {\n         }\n         match res {\n             Some(r) => { r }\n-            None => abort!(\"function failed!\")\n+            None => rtabort!(\"function failed!\")\n         }\n     }\n     unsafe fn unsafe_borrow() -> *mut Scheduler { local_ptr::unsafe_borrow() }\n-    unsafe fn try_unsafe_borrow() -> Option<*mut Scheduler> { abort!(\"unimpl\") }\n+    unsafe fn try_unsafe_borrow() -> Option<*mut Scheduler> { rtabort!(\"unimpl\") }\n }\n \n impl Local for Task {\n-    fn put(_value: ~Task) { abort!(\"unimpl\") }\n-    fn take() -> ~Task { abort!(\"unimpl\") }\n-    fn exists() -> bool { abort!(\"unimpl\") }\n+    fn put(_value: ~Task) { rtabort!(\"unimpl\") }\n+    fn take() -> ~Task { rtabort!(\"unimpl\") }\n+    fn exists() -> bool { rtabort!(\"unimpl\") }\n     fn borrow<T>(f: &fn(&mut Task) -> T) -> T {\n         do Local::borrow::<Scheduler, T> |sched| {\n             match sched.current_task {\n                 Some(~ref mut task) => {\n                     f(&mut *task.task)\n                 }\n                 None => {\n-                    abort!(\"no scheduler\")\n+                    rtabort!(\"no scheduler\")\n                 }\n             }\n         }\n@@ -69,7 +69,7 @@ impl Local for Task {\n             }\n             None => {\n                 // Don't fail. Infinite recursion\n-                abort!(\"no scheduler\")\n+                rtabort!(\"no scheduler\")\n             }\n         }\n     }\n@@ -84,16 +84,16 @@ impl Local for Task {\n \n // XXX: This formulation won't work once ~IoFactoryObject is a real trait pointer\n impl Local for IoFactoryObject {\n-    fn put(_value: ~IoFactoryObject) { abort!(\"unimpl\") }\n-    fn take() -> ~IoFactoryObject { abort!(\"unimpl\") }\n-    fn exists() -> bool { abort!(\"unimpl\") }\n-    fn borrow<T>(_f: &fn(&mut IoFactoryObject) -> T) -> T { abort!(\"unimpl\") }\n+    fn put(_value: ~IoFactoryObject) { rtabort!(\"unimpl\") }\n+    fn take() -> ~IoFactoryObject { rtabort!(\"unimpl\") }\n+    fn exists() -> bool { rtabort!(\"unimpl\") }\n+    fn borrow<T>(_f: &fn(&mut IoFactoryObject) -> T) -> T { rtabort!(\"unimpl\") }\n     unsafe fn unsafe_borrow() -> *mut IoFactoryObject {\n         let sched = Local::unsafe_borrow::<Scheduler>();\n         let io: *mut IoFactoryObject = (*sched).event_loop.io().unwrap();\n         return io;\n     }\n-    unsafe fn try_unsafe_borrow() -> Option<*mut IoFactoryObject> { abort!(\"unimpl\") }\n+    unsafe fn try_unsafe_borrow() -> Option<*mut IoFactoryObject> { rtabort!(\"unimpl\") }\n }\n \n #[cfg(test)]"}, {"sha": "cd7c5daa444d7998970024b414c145ed22491cab", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=55dda46cf676e5efd713a0c1c8c4c5a297a6db02", "patch": "@@ -109,7 +109,7 @@ pub unsafe fn unsafe_borrow<T>() -> *mut T {\n fn tls_key() -> tls::Key {\n     match maybe_tls_key() {\n         Some(key) => key,\n-        None => abort!(\"runtime tls key not initialized\")\n+        None => rtabort!(\"runtime tls key not initialized\")\n     }\n }\n "}, {"sha": "581e3addff0f49abe8264a73972355aef89cb3b3", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 84, "deletions": 15, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=55dda46cf676e5efd713a0c1c8c4c5a297a6db02", "patch": "@@ -60,7 +60,21 @@ Several modules in `core` are clients of `rt`:\n #[deny(unused_variable)];\n \n use cell::Cell;\n+use clone::Clone;\n+use container::Container;\n+use from_str::FromStr;\n+use iterator::IteratorUtil;\n+use option::{Some, None};\n+use os;\n use ptr::RawPtr;\n+use uint;\n+use rt::sched::{Scheduler, Coroutine, Shutdown};\n+use rt::sleeper_list::SleeperList;\n+use rt::task::Task;\n+use rt::thread::Thread;\n+use rt::work_queue::WorkQueue;\n+use rt::uv::uvio::UvEventLoop;\n+use vec::{OwnedVector, MutableVector};\n \n /// The global (exchange) heap.\n pub mod global_heap;\n@@ -139,6 +153,9 @@ pub mod join_latch;\n \n pub mod metrics;\n \n+// FIXME #5248 shouldn't be pub\n+/// Just stuff\n+pub mod util;\n \n /// Set up a default runtime configuration, given compiler-supplied arguments.\n ///\n@@ -156,22 +173,9 @@ pub mod metrics;\n /// The return value is used as the process return code. 0 on success, 101 on error.\n pub fn start(_argc: int, _argv: **u8, crate_map: *u8, main: ~fn()) -> int {\n \n-    use self::sched::{Scheduler, Coroutine};\n-    use self::work_queue::WorkQueue;\n-    use self::uv::uvio::UvEventLoop;\n-    use self::sleeper_list::SleeperList;\n-\n     init(crate_map);\n-\n-    let loop_ = ~UvEventLoop::new();\n-    let work_queue = WorkQueue::new();\n-    let sleepers = SleeperList::new();\n-    let mut sched = ~Scheduler::new(loop_, work_queue, sleepers);\n-    sched.no_sleep = true;\n-    let main_task = ~Coroutine::new_root(&mut sched.stack_pool, main);\n-\n-    sched.enqueue_task(main_task);\n-    sched.run();\n+    run(main);\n+    cleanup();\n \n     return 0;\n }\n@@ -182,6 +186,71 @@ pub fn init(crate_map: *u8) {\n     logging::init(crate_map);\n }\n \n+pub fn cleanup() {\n+    global_heap::cleanup();\n+}\n+\n+pub fn run(main: ~fn()) {\n+    let nthreads = match os::getenv(\"RUST_THREADS\") {\n+        Some(nstr) => FromStr::from_str(nstr).get(),\n+        None => unsafe {\n+            // Using more threads than cores in test code\n+            // to force the OS to preempt them frequently.\n+            // Assuming that this help stress test concurrent types.\n+            util::num_cpus() * 2\n+        }\n+    };\n+\n+    let sleepers = SleeperList::new();\n+    let work_queue = WorkQueue::new();\n+\n+    let mut handles = ~[];\n+    let mut scheds = ~[];\n+\n+    for uint::range(0, nthreads) |_| {\n+        let loop_ = ~UvEventLoop::new();\n+        let mut sched = ~Scheduler::new(loop_, work_queue.clone(), sleepers.clone());\n+        let handle = sched.make_handle();\n+\n+        handles.push(handle);\n+        scheds.push(sched);\n+    }\n+\n+    let main_cell = Cell::new(main);\n+    let handles = Cell::new(handles);\n+    let mut new_task = ~Task::new_root();\n+    let on_exit: ~fn(bool) = |exit_status| {\n+\n+        let mut handles = handles.take();\n+        // Tell schedulers to exit\n+        for handles.mut_iter().advance |handle| {\n+            handle.send(Shutdown);\n+        }\n+\n+        rtassert!(exit_status);\n+    };\n+    new_task.on_exit = Some(on_exit);\n+    let main_task = ~Coroutine::with_task(&mut scheds[0].stack_pool,\n+                                          new_task, main_cell.take());\n+    scheds[0].enqueue_task(main_task);\n+\n+    let mut threads = ~[];\n+\n+    while !scheds.is_empty() {\n+        let sched = scheds.pop();\n+        let sched_cell = Cell::new(sched);\n+        let thread = do Thread::start {\n+            let sched = sched_cell.take();\n+            sched.run();\n+        };\n+\n+        threads.push(thread);\n+    }\n+\n+    // Wait for schedulers\n+    let _threads = threads;\n+}\n+\n /// Possible contexts in which Rust code may be executing.\n /// Different runtime services are available depending on context.\n /// Mostly used for determining if we're using the new scheduler"}, {"sha": "453d3303db668bc9fb9d58bf4a0e8bfd9cf69880", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=55dda46cf676e5efd713a0c1c8c4c5a297a6db02", "patch": "@@ -357,7 +357,7 @@ impl Scheduler {\n                 home_handle.send(PinnedTask(task));\n             }\n             AnySched => {\n-                abort!(\"error: cannot send anysched task home\");\n+                rtabort!(\"error: cannot send anysched task home\");\n             }\n         }\n     }\n@@ -381,51 +381,43 @@ impl Scheduler {\n                     match home {\n                         &Some(Sched(ref home_handle))\n                         if home_handle.sched_id != this.sched_id() => {\n-                            0\n+                            SendHome\n                         }\n                         &Some(AnySched) if this.run_anything => {\n-                            1\n+                            ResumeNow\n                         }\n                         &Some(AnySched) => {\n-                            2\n+                            Requeue\n                         }\n                         &Some(Sched(_)) => {\n-                            3\n+                            ResumeNow\n                         }\n                         &None => {\n-                            4\n+                            Homeless\n                         }\n                     }\n                 };\n \n                 match action_id {\n-                    0 => {\n+                    SendHome => {\n                         rtdebug!(\"sending task home\");\n                         Scheduler::send_task_home(task);\n                         Local::put(this);\n                         return false;\n                     }\n-                    1 => {\n+                    ResumeNow => {\n                         rtdebug!(\"resuming now\");\n                         this.resume_task_immediately(task);\n                         return true;\n                     }\n-                    2 => {\n+                    Requeue => {\n                         rtdebug!(\"re-queueing\")\n                         this.enqueue_task(task);\n                         Local::put(this);\n                         return false;\n                     }\n-                    3 => {\n-                        rtdebug!(\"resuming now\");\n-                        this.resume_task_immediately(task);\n-                        return true;\n-                    }\n-                    4 => {\n-                        abort!(\"task home was None!\");\n-                    }\n-                    _ => {\n-                        abort!(\"literally, you should not be here\");\n+                    Homeless => {\n+                        rtabort!(\"task home was None!\");\n                     }\n                 }\n             }\n@@ -452,7 +444,7 @@ impl Scheduler {\n             dead_task.take().recycle(&mut sched.stack_pool);\n         }\n \n-        abort!(\"control reached end of task\");\n+        rtabort!(\"control reached end of task\");\n     }\n \n     pub fn schedule_task(~self, task: ~Coroutine) {\n@@ -654,6 +646,14 @@ impl Scheduler {\n     }\n }\n \n+// The cases for the below function.                                              \n+enum ResumeAction {\n+    SendHome,\n+    Requeue,\n+    ResumeNow,\n+    Homeless                                                                      \n+}\n+\n impl SchedHandle {\n     pub fn send(&mut self, msg: SchedMessage) {\n         self.queue.push(msg);\n@@ -672,7 +672,7 @@ impl Coroutine {\n                 Some(Sched(SchedHandle { sched_id: ref id, _ })) => {\n                     *id == sched.sched_id()\n                 }\n-                None => { abort!(\"error: homeless task!\"); }\n+                None => { rtabort!(\"error: homeless task!\"); }\n             }\n         }\n     }\n@@ -696,7 +696,7 @@ impl Coroutine {\n         match self.task.home {\n             Some(AnySched) => { false }\n             Some(Sched(_)) => { true }\n-            None => { abort!(\"error: homeless task!\");\n+            None => { rtabort!(\"error: homeless task!\");\n                     }\n         }\n     }\n@@ -710,7 +710,7 @@ impl Coroutine {\n             Some(Sched(SchedHandle { sched_id: ref id, _})) => {\n                 *id == sched.sched_id()\n             }\n-            None => { abort!(\"error: homeless task!\"); }\n+            None => { rtabort!(\"error: homeless task!\"); }\n         }\n     }\n "}, {"sha": "36efcd91834b8fd82a613e1d47ebd4e2c3decb70", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=55dda46cf676e5efd713a0c1c8c4c5a297a6db02", "patch": "@@ -63,11 +63,11 @@ pub fn run_in_newsched_task(f: ~fn()) {\n /// in one of the schedulers. The schedulers will stay alive\n /// until the function `f` returns.\n pub fn run_in_mt_newsched_task(f: ~fn()) {\n-    use libc;\n     use os;\n     use from_str::FromStr;\n     use rt::uv::uvio::UvEventLoop;\n     use rt::sched::Shutdown;\n+    use rt::util;\n \n     let f_cell = Cell::new(f);\n \n@@ -78,7 +78,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n                 // Using more threads than cores in test code\n                 // to force the OS to preempt them frequently.\n                 // Assuming that this help stress test concurrent types.\n-                rust_get_num_cpus() * 2\n+                util::num_cpus() * 2\n             }\n         };\n \n@@ -132,9 +132,6 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n         let _threads = threads;\n     }\n \n-    extern {\n-        fn rust_get_num_cpus() -> libc::uintptr_t;\n-    }\n }\n \n // THIS IS AWFUL. Copy-pasted the above initialization function but"}, {"sha": "904b2f8bbb932a254daafd57c1e636fa98ac3ce3", "filename": "src/libstd/rt/util.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55dda46cf676e5efd713a0c1c8c4c5a297a6db02/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=55dda46cf676e5efd713a0c1c8c4c5a297a6db02", "patch": "@@ -0,0 +1,87 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use container::Container;\n+use iterator::IteratorUtil;\n+use libc;\n+use str::StrSlice;\n+\n+/// Get the number of cores available\n+pub fn num_cpus() -> uint {\n+    unsafe {\n+        return rust_get_num_cpus();\n+    }\n+\n+    extern {\n+        fn rust_get_num_cpus() -> libc::uintptr_t;\n+    }\n+}\n+\n+pub fn dumb_println(s: &str) {\n+    use io::WriterUtil;\n+    let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n+    dbg.write_str(s);\n+    dbg.write_str(\"\\n\");\n+}\n+\n+pub fn abort(msg: &str) -> ! {\n+    let msg = if !msg.is_empty() { msg } else { \"aborted\" };\n+    let hash = msg.iter().fold(0, |accum, val| accum + (val as uint) );\n+    let quote = match hash % 10 {\n+        0 => \"\n+It was from the artists and poets that the pertinent answers came, and I\n+know that panic would have broken loose had they been able to compare notes.\n+As it was, lacking their original letters, I half suspected the compiler of\n+having asked leading questions, or of having edited the correspondence in\n+corroboration of what he had latently resolved to see.\",\n+        1 => \"\n+There are not many persons who know what wonders are opened to them in the\n+stories and visions of their youth; for when as children we listen and dream,\n+we think but half-formed thoughts, and when as men we try to remember, we are\n+dulled and prosaic with the poison of life. But some of us awake in the night\n+with strange phantasms of enchanted hills and gardens, of fountains that sing\n+in the sun, of golden cliffs overhanging murmuring seas, of plains that stretch\n+down to sleeping cities of bronze and stone, and of shadowy companies of heroes\n+that ride caparisoned white horses along the edges of thick forests; and then\n+we know that we have looked back through the ivory gates into that world of\n+wonder which was ours before we were wise and unhappy.\",\n+        2 => \"\n+Instead of the poems I had hoped for, there came only a shuddering blackness\n+and ineffable loneliness; and I saw at last a fearful truth which no one had\n+ever dared to breathe before \u2014 the unwhisperable secret of secrets \u2014 The fact\n+that this city of stone and stridor is not a sentient perpetuation of Old New\n+York as London is of Old London and Paris of Old Paris, but that it is in fact\n+quite dead, its sprawling body imperfectly embalmed and infested with queer\n+animate things which have nothing to do with it as it was in life.\",\n+        3 => \"\n+The ocean ate the last of the land and poured into the smoking gulf, thereby\n+giving up all it had ever conquered. From the new-flooded lands it flowed\n+again, uncovering death and decay; and from its ancient and immemorial bed it\n+trickled loathsomely, uncovering nighted secrets of the years when Time was\n+young and the gods unborn. Above the waves rose weedy remembered spires. The\n+moon laid pale lilies of light on dead London, and Paris stood up from its damp\n+grave to be sanctified with star-dust. Then rose spires and monoliths that were\n+weedy but not remembered; terrible spires and monoliths of lands that men never\n+knew were lands...\",\n+        4 => \"\n+There was a night when winds from unknown spaces whirled us irresistibly into\n+limitless vacum beyond all thought and entity. Perceptions of the most\n+maddeningly untransmissible sort thronged upon us; perceptions of infinity\n+which at the time convulsed us with joy, yet which are now partly lost to my\n+memory and partly incapable of presentation to others.\",\n+        _ => \"You've met with a terrible fate, haven't you?\"\n+    };\n+    rterrln!(\"%s\", \"\");\n+    rterrln!(\"%s\", quote);\n+    rterrln!(\"%s\", \"\");\n+    rterrln!(\"fatal runtime error: %s\", msg);\n+\n+    unsafe { libc::abort(); }\n+}"}]}