{"sha": "2c0f4d51f90f8705a33f59c5e186740c6e159458", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMGY0ZDUxZjkwZjg3MDVhMzNmNTljNWUxODY3NDBjNmUxNTk0NTg=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-29T01:38:27Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-29T01:40:17Z"}, "message": "Change the way freevars stores its information again.", "tree": {"sha": "8081d9e58e227ade34da8a5e409b12cdee41c8aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8081d9e58e227ade34da8a5e409b12cdee41c8aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c0f4d51f90f8705a33f59c5e186740c6e159458", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c0f4d51f90f8705a33f59c5e186740c6e159458", "html_url": "https://github.com/rust-lang/rust/commit/2c0f4d51f90f8705a33f59c5e186740c6e159458", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c0f4d51f90f8705a33f59c5e186740c6e159458/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5068ae4771d9abd23b955bdec97b397396a312a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5068ae4771d9abd23b955bdec97b397396a312a4", "html_url": "https://github.com/rust-lang/rust/commit/5068ae4771d9abd23b955bdec97b397396a312a4"}], "stats": {"total": 83, "additions": 37, "deletions": 46}, "files": [{"sha": "e5230bb466def2ab97ac822933ede143f995c5dd", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2c0f4d51f90f8705a33f59c5e186740c6e159458/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0f4d51f90f8705a33f59c5e186740c6e159458/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=2c0f4d51f90f8705a33f59c5e186740c6e159458", "patch": "@@ -18,13 +18,19 @@ export freevar_set;\n export freevar_map;\n export get_freevar_info;\n export get_freevars;\n-export get_freevar_uses;\n+export get_freevar_refs;\n export has_freevars;\n export is_freevar_of;\n export def_lookup;\n \n+// Throughout the compiler, variables are generally dealt with using the\n+// node_ids of the reference sites and not the def_id of the definition\n+// site. Thus we store a set are the definitions along with a vec of one\n+// referencing node_id per free variable. The set is useful for testing\n+// membership, the list of referencing sites is what you want for most\n+// other things.\n type freevar_set = hashset[ast::node_id];\n-type freevar_info = {defs: freevar_set, uses: @ast::node_id[]};\n+type freevar_info = {defs: freevar_set, refs: @ast::node_id[]};\n type freevar_map = hashmap[ast::node_id, freevar_info];\n \n // Searches through part of the AST for all references to locals or\n@@ -83,17 +89,17 @@ fn collect_freevars(def_map: &resolve::def_map, sess: &session::session,\n     // Calculate (refs - decls). This is the set of captured upvars.\n     // We build a vec of the node ids of the uses and a set of the\n     // node ids of the definitions.\n-    let uses = ~[];\n+    let refs = ~[];\n     let defs = new_int_hash();\n     for ref_id_: ast::node_id  in e.refs {\n         let ref_id = ref_id_;\n         let def_id = ast::def_id_of_def(def_map.get(ref_id)).node;\n-        if !decls.contains_key(def_id) {\n-            uses += ~[ref_id];\n+        if !decls.contains_key(def_id) && !defs.contains_key(def_id) {\n+            refs += ~[ref_id];\n             set_add(defs, def_id);\n         }\n     }\n-    ret {defs: defs, uses: @uses};\n+    ret {defs: defs, refs: @refs};\n }\n \n // Build a map from every function and for-each body to a set of the\n@@ -150,17 +156,17 @@ fn get_freevar_info(tcx: &ty::ctxt, fid: ast::node_id) -> freevar_info {\n       some(d) { ret d; }\n     }\n }\n-fn get_freevars(tcx: &ty::ctxt, fid: ast::node_id) -> freevar_set {\n+fn get_freevar_refs(tcx: &ty::ctxt, fid: ast::node_id) -> freevar_set {\n     ret get_freevar_info(tcx, fid).defs;\n }\n-fn get_freevar_uses(tcx: &ty::ctxt, fid: ast::node_id) -> @ast::node_id[] {\n-    ret get_freevar_info(tcx, fid).uses;\n+fn get_freevars(tcx: &ty::ctxt, fid: ast::node_id) -> @ast::node_id[] {\n+    ret get_freevar_info(tcx, fid).refs;\n }\n fn has_freevars(tcx: &ty::ctxt, fid: ast::node_id) -> bool {\n-    ret get_freevars(tcx, fid).size() != 0u;\n+    ret get_freevar_refs(tcx, fid).size() != 0u;\n }\n-fn is_freevar_of(tcx: &ty::ctxt, var: ast::node_id, f: ast::node_id) -> bool {\n-    ret get_freevars(tcx, f).contains_key(var);\n+fn is_freevar_of(tcx: &ty::ctxt, def: ast::node_id, f: ast::node_id) -> bool {\n+    ret get_freevar_refs(tcx, f).contains_key(def);\n }\n fn def_lookup(tcx: &ty::ctxt, f: ast::node_id, id: ast::node_id) ->\n    option::t[ast::def] {"}, {"sha": "27bc8a6aa9ca754a194a7538f412a6545fab5a5f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 18, "deletions": 33, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2c0f4d51f90f8705a33f59c5e186740c6e159458/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0f4d51f90f8705a33f59c5e186740c6e159458/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=2c0f4d51f90f8705a33f59c5e186740c6e159458", "patch": "@@ -3677,30 +3677,6 @@ fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n \n // Iterator translation\n \n-// Finds the ValueRef associated with a variable in a function\n-// context. It checks locals, upvars, and args.\n-fn find_variable(cx: &@block_ctxt, nid: ast::node_id) -> lval_result {\n-    let fcx = cx.fcx;\n-    let llval = alt fcx.lllocals.find(nid) {\n-      none. {\n-        alt fcx.llupvars.find(nid) {\n-          none. {\n-            alt fcx.llargs.find(nid) {\n-              some(llval) { llval }\n-              _ {\n-                fcx.lcx.ccx.sess.bug(\"unbound var in build_environment \"\n-                                     + int::str(nid))\n-              }\n-            }\n-          }\n-          some(llval) { llval }\n-        }\n-      }\n-      some(llval) { llval }\n-    };\n-    ret lval_mem(cx, llval);\n-}\n-\n // build_environment_heap and build_environment are very similar. It\n // would be nice to unify them.\n \n@@ -3781,21 +3757,21 @@ fn build_environment_heap(bcx: @block_ctxt, lltydescs: ValueRef[],\n // Given a block context and a list of upvars, construct a closure that\n // contains pointers to all of the upvars and all of the tydescs in\n // scope. Return the ValueRef and TypeRef corresponding to the closure.\n-fn build_environment(cx: &@block_ctxt, upvars: &freevar_set) ->\n+fn build_environment(cx: &@block_ctxt, upvars: &@ast::node_id[]) ->\n    {ptr: ValueRef, ptrty: TypeRef} {\n     let has_iterbody = !option::is_none(cx.fcx.lliterbody);\n     let llbindingsptr;\n \n-    if upvars.size() > 0u || has_iterbody {\n+    if std::ivec::len(*upvars) > 0u || has_iterbody {\n         // Gather up the upvars.\n         let llbindings: ValueRef[] = ~[];\n         let llbindingtys: TypeRef[] = ~[];\n         if has_iterbody {\n             llbindings += ~[option::get(cx.fcx.lliterbody)];\n             llbindingtys += ~[val_ty(llbindings.(0))];\n         }\n-        for each nid: ast::node_id  in upvars.keys() {\n-            let llbinding = find_variable(cx, nid).res.val;\n+        for nid: ast::node_id  in *upvars {\n+            let llbinding = trans_var(cx, cx.sp, nid).res.val;\n             llbindings += ~[llbinding];\n             llbindingtys += ~[val_ty(llbinding)];\n         }\n@@ -3847,7 +3823,7 @@ fn build_environment(cx: &@block_ctxt, upvars: &freevar_set) ->\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n fn load_environment(cx: &@block_ctxt, fcx: &@fn_ctxt, llenvptrty: TypeRef,\n-                    upvars: &freevar_set) {\n+                    upvars: &@ast::node_id[]) {\n     let copy_args_bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n \n     // Populate the upvars from the environment.\n@@ -3869,12 +3845,13 @@ fn load_environment(cx: &@block_ctxt, fcx: &@fn_ctxt, llenvptrty: TypeRef,\n         let lliterbody = copy_args_bcx.build.Load(lliterbodyptr);\n         fcx.lliterbody = some(lliterbody);\n     }\n-    for each upvar_id: ast::node_id  in upvars.keys() {\n+    for upvar_id: ast::node_id  in *upvars {\n         let llupvarptrptr =\n             copy_args_bcx.build.GEP(llremotebindingsptr,\n                                     ~[C_int(0), C_int(i as int)]);\n         let llupvarptr = copy_args_bcx.build.Load(llupvarptrptr);\n-        fcx.llupvars.insert(upvar_id, llupvarptr);\n+        let def_id = ast::def_id_of_def(bcx_tcx(cx).def_map.get(upvar_id));\n+        fcx.llupvars.insert(def_id.node, llupvarptr);\n         i += 1u;\n     }\n \n@@ -4092,9 +4069,12 @@ fn lookup_discriminant(lcx: &@local_ctxt, tid: &ast::def_id,\n     }\n }\n \n-fn trans_path(cx: &@block_ctxt, p: &ast::path, id: ast::node_id) ->\n+fn trans_var(cx: &@block_ctxt, sp: &span, id: ast::node_id) ->\n    lval_result {\n     let ccx = bcx_ccx(cx);\n+    // If we had a good way to get at the node_id for the function we\n+    // are in, we could do a freevars::def_lookup and avoid having to\n+    // check the llupvars case in all of the other cases...\n     alt bcx_tcx(cx).def_map.find(id) {\n       some(ast::def_arg(did)) {\n         alt cx.fcx.llargs.find(did.node) {\n@@ -4144,7 +4124,7 @@ fn trans_path(cx: &@block_ctxt, p: &ast::path, id: ast::node_id) ->\n             let tag_ty = node_id_type(ccx, id);\n             let alloc_result = alloc_ty(cx, tag_ty);\n             let lltagblob = alloc_result.val;\n-            let lltagty = type_of_tag(ccx, p.span, tid, tag_ty);\n+            let lltagty = type_of_tag(ccx, sp, tid, tag_ty);\n             let bcx = alloc_result.bcx;\n             let lltagptr = bcx.build.PointerCast(lltagblob, T_ptr(lltagty));\n             if std::ivec::len(ty::tag_variants(ccx.tcx, tid)) != 1u {\n@@ -4180,6 +4160,11 @@ fn trans_path(cx: &@block_ctxt, p: &ast::path, id: ast::node_id) ->\n     }\n }\n \n+fn trans_path(cx: &@block_ctxt, p: &ast::path, id: ast::node_id) ->\n+   lval_result {\n+    ret trans_var(cx, p.span, id);\n+}\n+\n fn trans_field(cx: &@block_ctxt, sp: &span, v: ValueRef, t0: &ty::t,\n                field: &ast::ident, id: ast::node_id) -> lval_result {\n     let r = autoderef(cx, v, t0);"}, {"sha": "0ed3f6af968acf7751aa37915b86bc73c2ab1d35", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c0f4d51f90f8705a33f59c5e186740c6e159458/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0f4d51f90f8705a33f59c5e186740c6e159458/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=2c0f4d51f90f8705a33f59c5e186740c6e159458", "patch": "@@ -371,7 +371,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n       expr_fn(f) {\n         let rslt = expr_pp(fcx.ccx, e);\n         clear_pp(rslt);\n-        let upvars = freevars::get_freevar_uses(fcx.ccx.tcx, e.id);\n+        let upvars = freevars::get_freevars(fcx.ccx.tcx, e.id);\n         for id: node_id  in *upvars { handle_var(fcx, rslt, id, \"upvar\"); }\n       }\n       expr_block(b) {"}]}