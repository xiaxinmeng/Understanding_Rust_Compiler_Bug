{"sha": "4dcbad1b086368beb97dc9d20b154a634c5c84af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkY2JhZDFiMDg2MzY4YmViOTdkYzlkMjBiMTU0YTYzNGM1Yzg0YWY=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-21T10:19:07Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-21T10:19:07Z"}, "message": "const folding for eq_op", "tree": {"sha": "22b77b6423dfbcb34a875715254d34960d7c4f11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22b77b6423dfbcb34a875715254d34960d7c4f11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4dcbad1b086368beb97dc9d20b154a634c5c84af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4dcbad1b086368beb97dc9d20b154a634c5c84af", "html_url": "https://github.com/rust-lang/rust/commit/4dcbad1b086368beb97dc9d20b154a634c5c84af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4dcbad1b086368beb97dc9d20b154a634c5c84af/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c91857c62d59639a8eb25d3789f75833484828f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c91857c62d59639a8eb25d3789f75833484828f5", "html_url": "https://github.com/rust-lang/rust/commit/c91857c62d59639a8eb25d3789f75833484828f5"}], "stats": {"total": 141, "additions": 73, "deletions": 68}, "files": [{"sha": "6202dcc3670bc754a6d29618cb6daa272853a148", "filename": "src/eq_op.rs", "status": "modified", "additions": 66, "deletions": 62, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/4dcbad1b086368beb97dc9d20b154a634c5c84af/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcbad1b086368beb97dc9d20b154a634c5c84af/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=4dcbad1b086368beb97dc9d20b154a634c5c84af", "patch": "@@ -4,6 +4,7 @@ use syntax::ast_util as ast_util;\n use syntax::ptr::P;\n use syntax::codemap as code;\n \n+use consts::constant;\n use utils::span_lint;\n \n declare_lint! {\n@@ -22,7 +23,7 @@ impl LintPass for EqOp {\n \n     fn check_expr(&mut self, cx: &Context, e: &Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n-            if is_cmp_or_bit(op) && is_exp_equal(left, right) {\n+            if is_cmp_or_bit(op) && is_exp_equal(cx, left, right) {\n                 span_lint(cx, EQ_OP, e.span, &format!(\n                     \"equal expressions as operands to {}\",\n                         ast_util::binop_to_string(op.node)));\n@@ -31,45 +32,48 @@ impl LintPass for EqOp {\n     }\n }\n \n-pub fn is_exp_equal(left : &Expr, right : &Expr) -> bool {\n+pub fn is_exp_equal(cx: &Context, left : &Expr, right : &Expr) -> bool {\n     match (&left.node, &right.node) {\n         (&ExprBinary(ref lop, ref ll, ref lr),\n                 &ExprBinary(ref rop, ref rl, ref rr)) =>\n             lop.node == rop.node &&\n-            is_exp_equal(ll, rl) && is_exp_equal(lr, rr),\n+            is_exp_equal(cx, ll, rl) && is_exp_equal(cx, lr, rr),\n         (&ExprBox(ref lpl, ref lbox), &ExprBox(ref rpl, ref rbox)) =>\n-            both(lpl, rpl, |l, r| is_exp_equal(l, r)) &&\n-                is_exp_equal(lbox, rbox),\n+            both(lpl, rpl, |l, r| is_exp_equal(cx, l, r)) &&\n+                is_exp_equal(cx, lbox, rbox),\n         (&ExprCall(ref lcallee, ref largs),\n-         &ExprCall(ref rcallee, ref rargs)) => is_exp_equal(lcallee,\n-            rcallee) && is_exps_equal(largs, rargs),\n+         &ExprCall(ref rcallee, ref rargs)) => is_exp_equal(cx, lcallee,\n+            rcallee) && is_exps_equal(cx, largs, rargs),\n         (&ExprCast(ref lc, ref lty), &ExprCast(ref rc, ref rty)) =>\n-            is_ty_equal(lty, rty) && is_exp_equal(lc, rc),\n+            is_ty_equal(cx, lty, rty) && is_exp_equal(cx, lc, rc),\n         (&ExprField(ref lfexp, ref lfident),\n                 &ExprField(ref rfexp, ref rfident)) =>\n-            lfident.node == rfident.node && is_exp_equal(lfexp, rfexp),\n+            lfident.node == rfident.node && is_exp_equal(cx, lfexp, rfexp),\n         (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n         (&ExprMethodCall(ref lident, ref lcty, ref lmargs),\n                 &ExprMethodCall(ref rident, ref rcty, ref rmargs)) =>\n-            lident.node == rident.node && is_tys_equal(lcty, rcty) &&\n-                is_exps_equal(lmargs, rmargs),\n-        (&ExprParen(ref lparen), _) => is_exp_equal(lparen, right),\n-        (_, &ExprParen(ref rparen)) => is_exp_equal(left, rparen),\n+            lident.node == rident.node && is_tys_equal(cx, lcty, rcty) &&\n+                is_exps_equal(cx, lmargs, rmargs),\n+        (&ExprParen(ref lparen), _) => is_exp_equal(cx, lparen, right),\n+        (_, &ExprParen(ref rparen)) => is_exp_equal(cx, left, rparen),\n         (&ExprPath(ref lqself, ref lsubpath),\n                 &ExprPath(ref rqself, ref rsubpath)) =>\n             both(lqself, rqself, |l, r| is_qself_equal(l, r)) &&\n                 is_path_equal(lsubpath, rsubpath),\n         (&ExprTup(ref ltup), &ExprTup(ref rtup)) =>\n-            is_exps_equal(ltup, rtup),\n+            is_exps_equal(cx, ltup, rtup),\n         (&ExprUnary(lunop, ref l), &ExprUnary(runop, ref r)) =>\n-            lunop == runop && is_exp_equal(l, r),\n-        (&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(l, r),\n+            lunop == runop && is_exp_equal(cx, l, r),\n+        (&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(cx, l, r),\n+        _ => false\n+    } || match (constant(cx, left), constant(cx, right)) {\n+        (Some(l), Some(r)) => l == r,\n         _ => false\n     }\n }\n \n-fn is_exps_equal(left : &[P<Expr>], right : &[P<Expr>]) -> bool {\n-    over(left, right, |l, r| is_exp_equal(l, r))\n+fn is_exps_equal(cx: &Context, left : &[P<Expr>], right : &[P<Expr>]) -> bool {\n+    over(left, right, |l, r| is_exp_equal(cx, l, r))\n }\n \n fn is_path_equal(left : &Path, right : &Path) -> bool {\n@@ -85,29 +89,29 @@ fn is_qself_equal(left : &QSelf, right : &QSelf) -> bool {\n     left.ty.node == right.ty.node && left.position == right.position\n }\n \n-fn is_ty_equal(left : &Ty, right : &Ty) -> bool {\n+fn is_ty_equal(cx: &Context, left : &Ty, right : &Ty) -> bool {\n     match (&left.node, &right.node) {\n-    (&TyVec(ref lvec), &TyVec(ref rvec)) => is_ty_equal(lvec, rvec),\n+    (&TyVec(ref lvec), &TyVec(ref rvec)) => is_ty_equal(cx, lvec, rvec),\n     (&TyFixedLengthVec(ref lfvty, ref lfvexp),\n             &TyFixedLengthVec(ref rfvty, ref rfvexp)) =>\n-        is_ty_equal(lfvty, rfvty) && is_exp_equal(lfvexp, rfvexp),\n-    (&TyPtr(ref lmut), &TyPtr(ref rmut)) => is_mut_ty_equal(lmut, rmut),\n+        is_ty_equal(cx, lfvty, rfvty) && is_exp_equal(cx, lfvexp, rfvexp),\n+    (&TyPtr(ref lmut), &TyPtr(ref rmut)) => is_mut_ty_equal(cx, lmut, rmut),\n     (&TyRptr(ref ltime, ref lrmut), &TyRptr(ref rtime, ref rrmut)) =>\n         both(ltime, rtime, is_lifetime_equal) &&\n-        is_mut_ty_equal(lrmut, rrmut),\n+        is_mut_ty_equal(cx, lrmut, rrmut),\n     (&TyBareFn(ref lbare), &TyBareFn(ref rbare)) =>\n-        is_bare_fn_ty_equal(lbare, rbare),\n-    (&TyTup(ref ltup), &TyTup(ref rtup)) => is_tys_equal(ltup, rtup),\n+        is_bare_fn_ty_equal(cx, lbare, rbare),\n+    (&TyTup(ref ltup), &TyTup(ref rtup)) => is_tys_equal(cx, ltup, rtup),\n     (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) =>\n         both(lq, rq, is_qself_equal) && is_path_equal(lpath, rpath),\n     (&TyObjectSum(ref lsumty, ref lobounds),\n             &TyObjectSum(ref rsumty, ref robounds)) =>\n-        is_ty_equal(lsumty, rsumty) &&\n+        is_ty_equal(cx, lsumty, rsumty) &&\n         is_param_bounds_equal(lobounds, robounds),\n     (&TyPolyTraitRef(ref ltbounds), &TyPolyTraitRef(ref rtbounds)) =>\n         is_param_bounds_equal(ltbounds, rtbounds),\n-    (&TyParen(ref lty), &TyParen(ref rty)) => is_ty_equal(lty, rty),\n-    (&TyTypeof(ref lof), &TyTypeof(ref rof)) => is_exp_equal(lof, rof),\n+    (&TyParen(ref lty), &TyParen(ref rty)) => is_ty_equal(cx, lty, rty),\n+    (&TyTypeof(ref lof), &TyTypeof(ref rof)) => is_exp_equal(cx, lof, rof),\n     (&TyInfer, &TyInfer) => true,\n     _ => false\n     }\n@@ -136,41 +140,41 @@ fn is_param_bounds_equal(left : &TyParamBounds, right : &TyParamBounds)\n     over(left, right, is_param_bound_equal)\n }\n \n-fn is_mut_ty_equal(left : &MutTy, right : &MutTy) -> bool {\n-    left.mutbl == right.mutbl && is_ty_equal(&left.ty, &right.ty)\n+fn is_mut_ty_equal(cx: &Context, left : &MutTy, right : &MutTy) -> bool {\n+    left.mutbl == right.mutbl && is_ty_equal(cx, &left.ty, &right.ty)\n }\n \n-fn is_bare_fn_ty_equal(left : &BareFnTy, right : &BareFnTy) -> bool {\n+fn is_bare_fn_ty_equal(cx: &Context, left : &BareFnTy, right : &BareFnTy) -> bool {\n     left.unsafety == right.unsafety && left.abi == right.abi &&\n         is_lifetimedefs_equal(&left.lifetimes, &right.lifetimes) &&\n-            is_fndecl_equal(&left.decl, &right.decl)\n+            is_fndecl_equal(cx, &left.decl, &right.decl)\n }\n \n-fn is_fndecl_equal(left : &P<FnDecl>, right : &P<FnDecl>) -> bool {\n+fn is_fndecl_equal(cx: &Context, left : &P<FnDecl>, right : &P<FnDecl>) -> bool {\n     left.variadic == right.variadic &&\n-        is_args_equal(&left.inputs, &right.inputs) &&\n-        is_fnret_ty_equal(&left.output, &right.output)\n+        is_args_equal(cx, &left.inputs, &right.inputs) &&\n+        is_fnret_ty_equal(cx, &left.output, &right.output)\n }\n \n-fn is_fnret_ty_equal(left : &FunctionRetTy, right : &FunctionRetTy)\n-        -> bool {\n+fn is_fnret_ty_equal(cx: &Context, left : &FunctionRetTy,\n+        right : &FunctionRetTy) -> bool {\n     match (left, right) {\n     (&NoReturn(_), &NoReturn(_)) |\n     (&DefaultReturn(_), &DefaultReturn(_)) => true,\n-    (&Return(ref lty), &Return(ref rty)) => is_ty_equal(lty, rty),\n+    (&Return(ref lty), &Return(ref rty)) => is_ty_equal(cx, lty, rty),\n     _ => false\n     }\n }\n \n-fn is_arg_equal(l: &Arg, r : &Arg) -> bool {\n-    is_ty_equal(&l.ty, &r.ty) && is_pat_equal(&l.pat, &r.pat)\n+fn is_arg_equal(cx: &Context, l: &Arg, r : &Arg) -> bool {\n+    is_ty_equal(cx, &l.ty, &r.ty) && is_pat_equal(cx, &l.pat, &r.pat)\n }\n \n-fn is_args_equal(left : &[Arg], right : &[Arg]) -> bool {\n-    over(left, right, is_arg_equal)\n+fn is_args_equal(cx: &Context, left : &[Arg], right : &[Arg]) -> bool {\n+    over(left, right, |l, r| is_arg_equal(cx, l, r))\n }\n \n-fn is_pat_equal(left : &Pat, right : &Pat) -> bool {\n+fn is_pat_equal(cx: &Context, left : &Pat, right : &Pat) -> bool {\n     match(&left.node, &right.node) {\n     (&PatWild(lwild), &PatWild(rwild)) => lwild == rwild,\n     (&PatIdent(ref lmode, ref lident, Option::None),\n@@ -179,51 +183,51 @@ fn is_pat_equal(left : &Pat, right : &Pat) -> bool {\n     (&PatIdent(ref lmode, ref lident, Option::Some(ref lpat)),\n             &PatIdent(ref rmode, ref rident, Option::Some(ref rpat))) =>\n         lmode == rmode && is_ident_equal(&lident.node, &rident.node) &&\n-            is_pat_equal(lpat, rpat),\n+            is_pat_equal(cx, lpat, rpat),\n     (&PatEnum(ref lpath, ref lenum), &PatEnum(ref rpath, ref renum)) =>\n         is_path_equal(lpath, rpath) && both(lenum, renum, |l, r|\n-            is_pats_equal(l, r)),\n+            is_pats_equal(cx, l, r)),\n     (&PatStruct(ref lpath, ref lfieldpat, lbool),\n             &PatStruct(ref rpath, ref rfieldpat, rbool)) =>\n         lbool == rbool && is_path_equal(lpath, rpath) &&\n-            is_spanned_fieldpats_equal(lfieldpat, rfieldpat),\n-    (&PatTup(ref ltup), &PatTup(ref rtup)) => is_pats_equal(ltup, rtup),\n+            is_spanned_fieldpats_equal(cx, lfieldpat, rfieldpat),\n+    (&PatTup(ref ltup), &PatTup(ref rtup)) => is_pats_equal(cx, ltup, rtup),\n     (&PatBox(ref lboxed), &PatBox(ref rboxed)) =>\n-        is_pat_equal(lboxed, rboxed),\n+        is_pat_equal(cx, lboxed, rboxed),\n     (&PatRegion(ref lpat, ref lmut), &PatRegion(ref rpat, ref rmut)) =>\n-        is_pat_equal(lpat, rpat) && lmut == rmut,\n-    (&PatLit(ref llit), &PatLit(ref rlit)) => is_exp_equal(llit, rlit),\n+        is_pat_equal(cx, lpat, rpat) && lmut == rmut,\n+    (&PatLit(ref llit), &PatLit(ref rlit)) => is_exp_equal(cx, llit, rlit),\n     (&PatRange(ref lfrom, ref lto), &PatRange(ref rfrom, ref rto)) =>\n-        is_exp_equal(lfrom, rfrom) && is_exp_equal(lto, rto),\n+        is_exp_equal(cx, lfrom, rfrom) && is_exp_equal(cx, lto, rto),\n     (&PatVec(ref lfirst, Option::None, ref llast),\n             &PatVec(ref rfirst, Option::None, ref rlast)) =>\n-        is_pats_equal(lfirst, rfirst) && is_pats_equal(llast, rlast),\n+        is_pats_equal(cx, lfirst, rfirst) && is_pats_equal(cx, llast, rlast),\n     (&PatVec(ref lfirst, Option::Some(ref lpat), ref llast),\n             &PatVec(ref rfirst, Option::Some(ref rpat), ref rlast)) =>\n-        is_pats_equal(lfirst, rfirst) && is_pat_equal(lpat, rpat) &&\n-            is_pats_equal(llast, rlast),\n+        is_pats_equal(cx, lfirst, rfirst) && is_pat_equal(cx, lpat, rpat) &&\n+            is_pats_equal(cx, llast, rlast),\n     // I don't match macros for now, the code is slow enough as is ;-)\n     _ => false\n     }\n }\n \n-fn is_spanned_fieldpats_equal(left : &[code::Spanned<FieldPat>],\n+fn is_spanned_fieldpats_equal(cx: &Context, left : &[code::Spanned<FieldPat>],\n         right : &[code::Spanned<FieldPat>]) -> bool {\n-    over(left, right, |l, r| is_fieldpat_equal(&l.node, &r.node))\n+    over(left, right, |l, r| is_fieldpat_equal(cx, &l.node, &r.node))\n }\n \n-fn is_fieldpat_equal(left : &FieldPat, right : &FieldPat) -> bool {\n+fn is_fieldpat_equal(cx: &Context, left : &FieldPat, right : &FieldPat) -> bool {\n     left.is_shorthand == right.is_shorthand &&\n         is_ident_equal(&left.ident, &right.ident) &&\n-        is_pat_equal(&left.pat, &right.pat)\n+        is_pat_equal(cx, &left.pat, &right.pat)\n }\n \n fn is_ident_equal(left : &Ident, right : &Ident) -> bool {\n     &left.name == &right.name && left.ctxt == right.ctxt\n }\n \n-fn is_pats_equal(left : &[P<Pat>], right : &[P<Pat>]) -> bool {\n-    over(left, right, |l, r| is_pat_equal(l, r))\n+fn is_pats_equal(cx: &Context, left : &[P<Pat>], right : &[P<Pat>]) -> bool {\n+    over(left, right, |l, r| is_pat_equal(cx, l, r))\n }\n \n fn is_lifetimedef_equal(left : &LifetimeDef, right : &LifetimeDef)\n@@ -241,8 +245,8 @@ fn is_lifetime_equal(left : &Lifetime, right : &Lifetime) -> bool {\n     left.name == right.name\n }\n \n-fn is_tys_equal(left : &[P<Ty>], right : &[P<Ty>]) -> bool {\n-    over(left, right, |l, r| is_ty_equal(l, r))\n+fn is_tys_equal(cx: &Context, left : &[P<Ty>], right : &[P<Ty>]) -> bool {\n+    over(left, right, |l, r| is_ty_equal(cx, l, r))\n }\n \n fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool"}, {"sha": "b1da93d71e355e4fd1c719c05da4572727d07e8e", "filename": "src/strings.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4dcbad1b086368beb97dc9d20b154a634c5c84af/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcbad1b086368beb97dc9d20b154a634c5c84af/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=4dcbad1b086368beb97dc9d20b154a634c5c84af", "patch": "@@ -41,7 +41,7 @@ impl LintPass for StringAdd {\n                     if let Some(ref p) = parent {\n                         if let &ExprAssign(ref target, _) = &p.node {\n                             // avoid duplicate matches\n-                            if is_exp_equal(target, left) { return; }\n+                            if is_exp_equal(cx, target, left) { return; }\n                         }\n                     }\n                 }\n@@ -51,7 +51,7 @@ impl LintPass for StringAdd {\n                          Consider using `String::push_str()` instead\")\n             }\n         } else if let &ExprAssign(ref target, ref  src) = &e.node {\n-            if is_string(cx, target) && is_add(src, target) {\n+            if is_string(cx, target) && is_add(cx, src, target) {\n                 span_lint(cx, STRING_ADD_ASSIGN, e.span,\n                     \"you assigned the result of adding something to this string. \\\n                      Consider using `String::push_str()` instead\")\n@@ -67,13 +67,14 @@ fn is_string(cx: &Context, e: &Expr) -> bool {\n     } else { false }\n }\n \n-fn is_add(src: &Expr, target: &Expr) -> bool {\n+fn is_add(cx: &Context, src: &Expr, target: &Expr) -> bool {\n     match &src.node {\n         &ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) =>\n-            is_exp_equal(target, left),\n+            is_exp_equal(cx, target, left),\n         &ExprBlock(ref block) => block.stmts.is_empty() &&\n-            block.expr.as_ref().map_or(false, |expr| is_add(&*expr, target)),\n-        &ExprParen(ref expr) => is_add(&*expr, target),\n+            block.expr.as_ref().map_or(false,\n+                |expr| is_add(cx, &*expr, target)),\n+        &ExprParen(ref expr) => is_add(cx, &*expr, target),\n         _ => false\n     }\n }"}]}