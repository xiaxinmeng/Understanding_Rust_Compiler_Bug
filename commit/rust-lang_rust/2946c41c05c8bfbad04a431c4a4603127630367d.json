{"sha": "2946c41c05c8bfbad04a431c4a4603127630367d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5NDZjNDFjMDVjOGJmYmFkMDRhNDMxYzRhNDYwMzEyNzYzMDM2N2Q=", "commit": {"author": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-03-30T14:23:46Z"}, "committer": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-03-30T14:23:46Z"}, "message": "More consistent wording", "tree": {"sha": "6b5dffb65a55e159fb7aae1b1ae333a2b135a7ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b5dffb65a55e159fb7aae1b1ae333a2b135a7ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2946c41c05c8bfbad04a431c4a4603127630367d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2946c41c05c8bfbad04a431c4a4603127630367d", "html_url": "https://github.com/rust-lang/rust/commit/2946c41c05c8bfbad04a431c4a4603127630367d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2946c41c05c8bfbad04a431c4a4603127630367d/comments", "author": null, "committer": null, "parents": [{"sha": "3fa28cc11eb5559b169f0d2fc7523f933e188e13", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fa28cc11eb5559b169f0d2fc7523f933e188e13", "html_url": "https://github.com/rust-lang/rust/commit/3fa28cc11eb5559b169f0d2fc7523f933e188e13"}], "stats": {"total": 35, "additions": 25, "deletions": 10}, "files": [{"sha": "12c1287b4f65c85b20dfd593634998894fe88ee1", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2946c41c05c8bfbad04a431c4a4603127630367d/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2946c41c05c8bfbad04a431c4a4603127630367d/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=2946c41c05c8bfbad04a431c4a4603127630367d", "patch": "@@ -296,7 +296,7 @@ impl AtomicBool {\n         }\n     }\n \n-    /// Stores a value into the bool, returning the old value.\n+    /// Stores a value into the bool, returning the previous value.\n     ///\n     /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n@@ -703,7 +703,7 @@ impl<T> AtomicPtr<T> {\n         }\n     }\n \n-    /// Stores a value into the pointer, returning the old value.\n+    /// Stores a value into the pointer, returning the previous value.\n     ///\n     /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n@@ -1015,7 +1015,7 @@ macro_rules! atomic_int {\n                 unsafe { atomic_store(self.v.get(), val, order); }\n             }\n \n-            /// Stores a value into the atomic integer, returning the old value.\n+            /// Stores a value into the atomic integer, returning the previous value.\n             ///\n             /// `swap` takes an [`Ordering`] argument which describes the memory ordering of this\n             /// operation.\n@@ -1169,7 +1169,7 @@ macro_rules! atomic_int {\n                 }\n             }\n \n-            /// Add to the current value, returning the previous value.\n+            /// Adds to the current value, returning the previous value.\n             ///\n             /// This operation wraps around on overflow.\n             ///\n@@ -1188,7 +1188,7 @@ macro_rules! atomic_int {\n                 unsafe { atomic_add(self.v.get(), val, order) }\n             }\n \n-            /// Subtract from the current value, returning the previous value.\n+            /// Subtracts from the current value, returning the previous value.\n             ///\n             /// This operation wraps around on overflow.\n             ///\n@@ -1207,7 +1207,12 @@ macro_rules! atomic_int {\n                 unsafe { atomic_sub(self.v.get(), val, order) }\n             }\n \n-            /// Bitwise and with the current value, returning the previous value.\n+            /// Bitwise \"and\" with the current value.\n+            ///\n+            /// Performs a bitwise \"and\" operation on the current value and the argument `val`, and\n+            /// sets the new value to the result.\n+            ///\n+            /// Returns the previous value.\n             ///\n             /// # Examples\n             ///\n@@ -1223,7 +1228,12 @@ macro_rules! atomic_int {\n                 unsafe { atomic_and(self.v.get(), val, order) }\n             }\n \n-            /// Bitwise or with the current value, returning the previous value.\n+            /// Bitwise \"or\" with the current value.\n+            ///\n+            /// Performs a bitwise \"or\" operation on the current value and the argument `val`, and\n+            /// sets the new value to the result.\n+            ///\n+            /// Returns the previous value.\n             ///\n             /// # Examples\n             ///\n@@ -1239,7 +1249,12 @@ macro_rules! atomic_int {\n                 unsafe { atomic_or(self.v.get(), val, order) }\n             }\n \n-            /// Bitwise xor with the current value, returning the previous value.\n+            /// Bitwise \"xor\" with the current value.\n+            ///\n+            /// Performs a bitwise \"xor\" operation on the current value and the argument `val`, and\n+            /// sets the new value to the result.\n+            ///\n+            /// Returns the previous value.\n             ///\n             /// # Examples\n             ///\n@@ -1387,7 +1402,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     }\n }\n \n-/// Returns the old value (like __sync_fetch_and_add).\n+/// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n@@ -1400,7 +1415,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     }\n }\n \n-/// Returns the old value (like __sync_fetch_and_sub).\n+/// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {"}]}