{"sha": "d86339bb5c2024d48cacf127d55fece303c14df3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NjMzOWJiNWMyMDI0ZDQ4Y2FjZjEyN2Q1NWZlY2UzMDNjMTRkZjM=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-30T14:09:09Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-30T14:09:09Z"}, "message": "Simpler patch for \"Remove atomics from libcore\"", "tree": {"sha": "46d0ff1688a5312b89d01a508a1d4c114908bdac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46d0ff1688a5312b89d01a508a1d4c114908bdac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d86339bb5c2024d48cacf127d55fece303c14df3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d86339bb5c2024d48cacf127d55fece303c14df3", "html_url": "https://github.com/rust-lang/rust/commit/d86339bb5c2024d48cacf127d55fece303c14df3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d86339bb5c2024d48cacf127d55fece303c14df3/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4901a66df16d2bd75444fb79e76b9bee167f7f83", "url": "https://api.github.com/repos/rust-lang/rust/commits/4901a66df16d2bd75444fb79e76b9bee167f7f83", "html_url": "https://github.com/rust-lang/rust/commit/4901a66df16d2bd75444fb79e76b9bee167f7f83"}], "stats": {"total": 2162, "additions": 1, "deletions": 2161}, "files": [{"sha": "5e5eaf2a4a2ac8ff66804e055688762c53e144d0", "filename": "0003-Remove-atomics-from-libcore.patch", "status": "modified", "additions": 1, "deletions": 2161, "changes": 2162, "blob_url": "https://github.com/rust-lang/rust/blob/d86339bb5c2024d48cacf127d55fece303c14df3/0003-Remove-atomics-from-libcore.patch", "raw_url": "https://github.com/rust-lang/rust/raw/d86339bb5c2024d48cacf127d55fece303c14df3/0003-Remove-atomics-from-libcore.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/0003-Remove-atomics-from-libcore.patch?ref=d86339bb5c2024d48cacf127d55fece303c14df3", "patch": "@@ -5,11 +5,7 @@ Subject: [PATCH] Remove atomics from libcore\n \n ---\n  src/libcore/lib.rs         |    1 -\n- src/libcore/sync/atomic.rs | 2128 --------------------------------------------\n- src/libcore/sync/mod.rs    |   15 -\n- 3 files changed, 2144 deletions(-)\n- delete mode 100644 src/libcore/sync/atomic.rs\n- delete mode 100644 src/libcore/sync/mod.rs\n+ 1 files changed, 1 deletions(-)\n \n diff --git a/src/libcore/lib.rs b/src/libcore/lib.rs\n index 3aa79087db..71fcff2e8b 100644\n@@ -23,2161 +19,5 @@ index 3aa79087db..71fcff2e8b 100644\n  pub mod cell;\n  pub mod char;\n  pub mod panic;\n-diff --git a/src/libcore/sync/atomic.rs b/src/libcore/sync/atomic.rs\n-deleted file mode 100644\n-index 1e2b18bf9b..0000000000\n---- a/src/libcore/sync/atomic.rs\n-+++ /dev/null\n-@@ -1,2128 +0,0 @@\n--// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n--// file at the top-level directory of this distribution and at\n--// http://rust-lang.org/COPYRIGHT.\n--//\n--// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n--// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n--// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n--// option. This file may not be copied, modified, or distributed\n--// except according to those terms.\n--\n--//! Atomic types\n--//!\n--//! Atomic types provide primitive shared-memory communication between\n--//! threads, and are the building blocks of other concurrent\n--//! types.\n--//!\n--//! This module defines atomic versions of a select number of primitive\n--//! types, including [`AtomicBool`], [`AtomicIsize`], and [`AtomicUsize`].\n--//! Atomic types present operations that, when used correctly, synchronize\n--//! updates between threads.\n--//!\n--//! [`AtomicBool`]: struct.AtomicBool.html\n--//! [`AtomicIsize`]: struct.AtomicIsize.html\n--//! [`AtomicUsize`]: struct.AtomicUsize.html\n--//!\n--//! Each method takes an [`Ordering`] which represents the strength of\n--//! the memory barrier for that operation. These orderings are the\n--//! same as [LLVM atomic orderings][1]. For more information see the [nomicon][2].\n--//!\n--//! [`Ordering`]: enum.Ordering.html\n--//!\n--//! [1]: http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\n--//! [2]: ../../../nomicon/atomics.html\n--//!\n--//! Atomic variables are safe to share between threads (they implement [`Sync`])\n--//! but they do not themselves provide the mechanism for sharing and follow the\n--//! [threading model](../../../std/thread/index.html#the-threading-model) of rust.\n--//! The most common way to share an atomic variable is to put it into an [`Arc`][arc] (an\n--//! atomically-reference-counted shared pointer).\n--//!\n--//! [`Sync`]: ../../marker/trait.Sync.html\n--//! [arc]: ../../../std/sync/struct.Arc.html\n--//!\n--//! Most atomic types may be stored in static variables, initialized using\n--//! the provided static initializers like [`ATOMIC_BOOL_INIT`]. Atomic statics\n--//! are often used for lazy global initialization.\n--//!\n--//! [`ATOMIC_BOOL_INIT`]: constant.ATOMIC_BOOL_INIT.html\n--//!\n--//! # Examples\n--//!\n--//! A simple spinlock:\n--//!\n--//! ```\n--//! use std::sync::Arc;\n--//! use std::sync::atomic::{AtomicUsize, Ordering};\n--//! use std::thread;\n--//!\n--//! fn main() {\n--//!     let spinlock = Arc::new(AtomicUsize::new(1));\n--//!\n--//!     let spinlock_clone = spinlock.clone();\n--//!     let thread = thread::spawn(move|| {\n--//!         spinlock_clone.store(0, Ordering::SeqCst);\n--//!     });\n--//!\n--//!     // Wait for the other thread to release the lock\n--//!     while spinlock.load(Ordering::SeqCst) != 0 {}\n--//!\n--//!     if let Err(panic) = thread.join() {\n--//!         println!(\"Thread had an error: {:?}\", panic);\n--//!     }\n--//! }\n--//! ```\n--//!\n--//! Keep a global count of live threads:\n--//!\n--//! ```\n--//! use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n--//!\n--//! static GLOBAL_THREAD_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n--//!\n--//! let old_thread_count = GLOBAL_THREAD_COUNT.fetch_add(1, Ordering::SeqCst);\n--//! println!(\"live threads: {}\", old_thread_count + 1);\n--//! ```\n--\n--#![stable(feature = \"rust1\", since = \"1.0.0\")]\n--#![cfg_attr(not(target_has_atomic = \"8\"), allow(dead_code))]\n--#![cfg_attr(not(target_has_atomic = \"8\"), allow(unused_imports))]\n--\n--use self::Ordering::*;\n--\n--use intrinsics;\n--use cell::UnsafeCell;\n--use fmt;\n--\n--/// Save power or switch hyperthreads in a busy-wait spin-loop.\n--///\n--/// This function is deliberately more primitive than\n--/// [`std::thread::yield_now`](../../../std/thread/fn.yield_now.html) and\n--/// does not directly yield to the system's scheduler.\n--/// In some cases it might be useful to use a combination of both functions.\n--/// Careful benchmarking is advised.\n--///\n--/// On some platforms this function may not do anything at all.\n--#[inline]\n--#[stable(feature = \"spin_loop_hint\", since = \"1.24.0\")]\n--pub fn spin_loop_hint() {\n--    #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n--    unsafe {\n--        asm!(\"pause\" ::: \"memory\" : \"volatile\");\n--    }\n--\n--    #[cfg(target_arch = \"aarch64\")]\n--    unsafe {\n--        asm!(\"yield\" ::: \"memory\" : \"volatile\");\n--    }\n--}\n--\n--/// A boolean type which can be safely shared between threads.\n--///\n--/// This type has the same in-memory representation as a [`bool`].\n--///\n--/// [`bool`]: ../../../std/primitive.bool.html\n--#[cfg(target_has_atomic = \"8\")]\n--#[stable(feature = \"rust1\", since = \"1.0.0\")]\n--#[repr(transparent)]\n--pub struct AtomicBool {\n--    v: UnsafeCell<u8>,\n--}\n--\n--#[cfg(target_has_atomic = \"8\")]\n--#[stable(feature = \"rust1\", since = \"1.0.0\")]\n--impl Default for AtomicBool {\n--    /// Creates an `AtomicBool` initialized to `false`.\n--    fn default() -> Self {\n--        Self::new(false)\n--    }\n--}\n--\n--// Send is implicitly implemented for AtomicBool.\n--#[cfg(target_has_atomic = \"8\")]\n--#[stable(feature = \"rust1\", since = \"1.0.0\")]\n--unsafe impl Sync for AtomicBool {}\n--\n--/// A raw pointer type which can be safely shared between threads.\n--///\n--/// This type has the same in-memory representation as a `*mut T`.\n--#[cfg(target_has_atomic = \"ptr\")]\n--#[stable(feature = \"rust1\", since = \"1.0.0\")]\n--#[repr(transparent)]\n--pub struct AtomicPtr<T> {\n--    p: UnsafeCell<*mut T>,\n--}\n--\n--#[cfg(target_has_atomic = \"ptr\")]\n--#[stable(feature = \"rust1\", since = \"1.0.0\")]\n--impl<T> Default for AtomicPtr<T> {\n--    /// Creates a null `AtomicPtr<T>`.\n--    fn default() -> AtomicPtr<T> {\n--        AtomicPtr::new(::ptr::null_mut())\n--    }\n--}\n--\n--#[cfg(target_has_atomic = \"ptr\")]\n--#[stable(feature = \"rust1\", since = \"1.0.0\")]\n--unsafe impl<T> Send for AtomicPtr<T> {}\n--#[cfg(target_has_atomic = \"ptr\")]\n--#[stable(feature = \"rust1\", since = \"1.0.0\")]\n--unsafe impl<T> Sync for AtomicPtr<T> {}\n--\n--/// Atomic memory orderings\n--///\n--/// Memory orderings limit the ways that both the compiler and CPU may reorder\n--/// instructions around atomic operations. At its most restrictive,\n--/// \"sequentially consistent\" atomics allow neither reads nor writes\n--/// to be moved either before or after the atomic operation; on the other end\n--/// \"relaxed\" atomics allow all reorderings.\n--///\n--/// Rust's memory orderings are [the same as\n--/// LLVM's](http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations).\n--///\n--/// For more information see the [nomicon].\n--///\n--/// [nomicon]: ../../../nomicon/atomics.html\n--#[stable(feature = \"rust1\", since = \"1.0.0\")]\n--#[derive(Copy, Clone, Debug)]\n--pub enum Ordering {\n--    /// No ordering constraints, only atomic operations.\n--    ///\n--    /// Corresponds to LLVM's [`Monotonic`] ordering.\n--    ///\n--    /// [`Monotonic`]: http://llvm.org/docs/Atomics.html#monotonic\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    Relaxed,\n--    /// When coupled with a store, all previous writes become visible\n--    /// to the other threads that perform a load with [`Acquire`] ordering\n--    /// on the same value.\n--    ///\n--    /// [`Acquire`]: http://llvm.org/docs/Atomics.html#acquire\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    Release,\n--    /// When coupled with a load, all subsequent loads will see data\n--    /// written before a store with [`Release`] ordering on the same value\n--    /// in other threads.\n--    ///\n--    /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    Acquire,\n--    /// Has the effects of both [`Acquire`] and [`Release`] together.\n--    ///\n--    /// This ordering is only applicable for operations that combine both loads and stores.\n--    ///\n--    /// For loads it uses [`Acquire`] ordering. For stores it uses the [`Release`] ordering.\n--    ///\n--    /// [`Acquire`]: http://llvm.org/docs/Atomics.html#acquire\n--    /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    AcqRel,\n--    /// Like `AcqRel` with the additional guarantee that all threads see all\n--    /// sequentially consistent operations in the same order.\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    SeqCst,\n--    // Prevent exhaustive matching to allow for future extension\n--    #[doc(hidden)]\n--    #[unstable(feature = \"future_atomic_orderings\", issue = \"0\")]\n--    __Nonexhaustive,\n--}\n--\n--/// An [`AtomicBool`] initialized to `false`.\n--///\n--/// [`AtomicBool`]: struct.AtomicBool.html\n--#[cfg(target_has_atomic = \"8\")]\n--#[stable(feature = \"rust1\", since = \"1.0.0\")]\n--pub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n--\n--#[cfg(target_has_atomic = \"8\")]\n--impl AtomicBool {\n--    /// Creates a new `AtomicBool`.\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::AtomicBool;\n--    ///\n--    /// let atomic_true  = AtomicBool::new(true);\n--    /// let atomic_false = AtomicBool::new(false);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    pub const fn new(v: bool) -> AtomicBool {\n--        AtomicBool { v: UnsafeCell::new(v as u8) }\n--    }\n--\n--    /// Returns a mutable reference to the underlying [`bool`].\n--    ///\n--    /// This is safe because the mutable reference guarantees that no other threads are\n--    /// concurrently accessing the atomic data.\n--    ///\n--    /// [`bool`]: ../../../std/primitive.bool.html\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicBool, Ordering};\n--    ///\n--    /// let mut some_bool = AtomicBool::new(true);\n--    /// assert_eq!(*some_bool.get_mut(), true);\n--    /// *some_bool.get_mut() = false;\n--    /// assert_eq!(some_bool.load(Ordering::SeqCst), false);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n--    pub fn get_mut(&mut self) -> &mut bool {\n--        unsafe { &mut *(self.v.get() as *mut bool) }\n--    }\n--\n--    /// Consumes the atomic and returns the contained value.\n--    ///\n--    /// This is safe because passing `self` by value guarantees that no other threads are\n--    /// concurrently accessing the atomic data.\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::AtomicBool;\n--    ///\n--    /// let some_bool = AtomicBool::new(true);\n--    /// assert_eq!(some_bool.into_inner(), true);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n--    pub fn into_inner(self) -> bool {\n--        self.v.into_inner() != 0\n--    }\n--\n--    /// Loads a value from the bool.\n--    ///\n--    /// `load` takes an [`Ordering`] argument which describes the memory ordering\n--    /// of this operation.\n--    ///\n--    /// # Panics\n--    ///\n--    /// Panics if `order` is [`Release`] or [`AcqRel`].\n--    ///\n--    /// [`Ordering`]: enum.Ordering.html\n--    /// [`Release`]: enum.Ordering.html#variant.Release\n--    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicBool, Ordering};\n--    ///\n--    /// let some_bool = AtomicBool::new(true);\n--    ///\n--    /// assert_eq!(some_bool.load(Ordering::Relaxed), true);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    pub fn load(&self, order: Ordering) -> bool {\n--        unsafe { atomic_load(self.v.get(), order) != 0 }\n--    }\n--\n--    /// Stores a value into the bool.\n--    ///\n--    /// `store` takes an [`Ordering`] argument which describes the memory ordering\n--    /// of this operation.\n--    ///\n--    /// [`Ordering`]: enum.Ordering.html\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicBool, Ordering};\n--    ///\n--    /// let some_bool = AtomicBool::new(true);\n--    ///\n--    /// some_bool.store(false, Ordering::Relaxed);\n--    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n--    /// ```\n--    ///\n--    /// # Panics\n--    ///\n--    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n--    ///\n--    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n--    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n--    #[inline]\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    pub fn store(&self, val: bool, order: Ordering) {\n--        unsafe {\n--            atomic_store(self.v.get(), val as u8, order);\n--        }\n--    }\n--\n--    /// Stores a value into the bool, returning the previous value.\n--    ///\n--    /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n--    /// of this operation.\n--    ///\n--    /// [`Ordering`]: enum.Ordering.html\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicBool, Ordering};\n--    ///\n--    /// let some_bool = AtomicBool::new(true);\n--    ///\n--    /// assert_eq!(some_bool.swap(false, Ordering::Relaxed), true);\n--    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n--    pub fn swap(&self, val: bool, order: Ordering) -> bool {\n--        unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n--    }\n--\n--    /// Stores a value into the [`bool`] if the current value is the same as the `current` value.\n--    ///\n--    /// The return value is always the previous value. If it is equal to `current`, then the value\n--    /// was updated.\n--    ///\n--    /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n--    /// ordering of this operation.\n--    ///\n--    /// [`Ordering`]: enum.Ordering.html\n--    /// [`bool`]: ../../../std/primitive.bool.html\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicBool, Ordering};\n--    ///\n--    /// let some_bool = AtomicBool::new(true);\n--    ///\n--    /// assert_eq!(some_bool.compare_and_swap(true, false, Ordering::Relaxed), true);\n--    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n--    ///\n--    /// assert_eq!(some_bool.compare_and_swap(true, true, Ordering::Relaxed), false);\n--    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n--    pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n--        match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n--            Ok(x) => x,\n--            Err(x) => x,\n--        }\n--    }\n--\n--    /// Stores a value into the [`bool`] if the current value is the same as the `current` value.\n--    ///\n--    /// The return value is a result indicating whether the new value was written and containing\n--    /// the previous value. On success this value is guaranteed to be equal to `current`.\n--    ///\n--    /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n--    /// ordering of this operation. The first describes the required ordering if the\n--    /// operation succeeds while the second describes the required ordering when the\n--    /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and must\n--    /// be equivalent or weaker than the success ordering.\n--    ///\n--    /// [`bool`]: ../../../std/primitive.bool.html\n--    /// [`Ordering`]: enum.Ordering.html\n--    /// [`Release`]: enum.Ordering.html#variant.Release\n--    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicBool, Ordering};\n--    ///\n--    /// let some_bool = AtomicBool::new(true);\n--    ///\n--    /// assert_eq!(some_bool.compare_exchange(true,\n--    ///                                       false,\n--    ///                                       Ordering::Acquire,\n--    ///                                       Ordering::Relaxed),\n--    ///            Ok(true));\n--    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n--    ///\n--    /// assert_eq!(some_bool.compare_exchange(true, true,\n--    ///                                       Ordering::SeqCst,\n--    ///                                       Ordering::Acquire),\n--    ///            Err(false));\n--    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n--    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n--    pub fn compare_exchange(&self,\n--                            current: bool,\n--                            new: bool,\n--                            success: Ordering,\n--                            failure: Ordering)\n--                            -> Result<bool, bool> {\n--        match unsafe {\n--            atomic_compare_exchange(self.v.get(), current as u8, new as u8, success, failure)\n--        } {\n--            Ok(x) => Ok(x != 0),\n--            Err(x) => Err(x != 0),\n--        }\n--    }\n--\n--    /// Stores a value into the [`bool`] if the current value is the same as the `current` value.\n--    ///\n--    /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n--    /// comparison succeeds, which can result in more efficient code on some platforms. The\n--    /// return value is a result indicating whether the new value was written and containing the\n--    /// previous value.\n--    ///\n--    /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n--    /// ordering of this operation. The first describes the required ordering if the operation\n--    /// succeeds while the second describes the required ordering when the operation fails. The\n--    /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n--    /// weaker than the success ordering.\n--    ///\n--    /// [`bool`]: ../../../std/primitive.bool.html\n--    /// [`compare_exchange`]: #method.compare_exchange\n--    /// [`Ordering`]: enum.Ordering.html\n--    /// [`Release`]: enum.Ordering.html#variant.Release\n--    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicBool, Ordering};\n--    ///\n--    /// let val = AtomicBool::new(false);\n--    ///\n--    /// let new = true;\n--    /// let mut old = val.load(Ordering::Relaxed);\n--    /// loop {\n--    ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n--    ///         Ok(_) => break,\n--    ///         Err(x) => old = x,\n--    ///     }\n--    /// }\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n--    pub fn compare_exchange_weak(&self,\n--                                 current: bool,\n--                                 new: bool,\n--                                 success: Ordering,\n--                                 failure: Ordering)\n--                                 -> Result<bool, bool> {\n--        match unsafe {\n--            atomic_compare_exchange_weak(self.v.get(), current as u8, new as u8, success, failure)\n--        } {\n--            Ok(x) => Ok(x != 0),\n--            Err(x) => Err(x != 0),\n--        }\n--    }\n--\n--    /// Logical \"and\" with a boolean value.\n--    ///\n--    /// Performs a logical \"and\" operation on the current value and the argument `val`, and sets\n--    /// the new value to the result.\n--    ///\n--    /// Returns the previous value.\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicBool, Ordering};\n--    ///\n--    /// let foo = AtomicBool::new(true);\n--    /// assert_eq!(foo.fetch_and(false, Ordering::SeqCst), true);\n--    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n--    ///\n--    /// let foo = AtomicBool::new(true);\n--    /// assert_eq!(foo.fetch_and(true, Ordering::SeqCst), true);\n--    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n--    ///\n--    /// let foo = AtomicBool::new(false);\n--    /// assert_eq!(foo.fetch_and(false, Ordering::SeqCst), false);\n--    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n--    pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n--        unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }\n--    }\n--\n--    /// Logical \"nand\" with a boolean value.\n--    ///\n--    /// Performs a logical \"nand\" operation on the current value and the argument `val`, and sets\n--    /// the new value to the result.\n--    ///\n--    /// Returns the previous value.\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicBool, Ordering};\n--    ///\n--    /// let foo = AtomicBool::new(true);\n--    /// assert_eq!(foo.fetch_nand(false, Ordering::SeqCst), true);\n--    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n--    ///\n--    /// let foo = AtomicBool::new(true);\n--    /// assert_eq!(foo.fetch_nand(true, Ordering::SeqCst), true);\n--    /// assert_eq!(foo.load(Ordering::SeqCst) as usize, 0);\n--    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n--    ///\n--    /// let foo = AtomicBool::new(false);\n--    /// assert_eq!(foo.fetch_nand(false, Ordering::SeqCst), false);\n--    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n--    pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n--        // We can't use atomic_nand here because it can result in a bool with\n--        // an invalid value. This happens because the atomic operation is done\n--        // with an 8-bit integer internally, which would set the upper 7 bits.\n--        // So we just use fetch_xor or swap instead.\n--        if val {\n--            // !(x & true) == !x\n--            // We must invert the bool.\n--            self.fetch_xor(true, order)\n--        } else {\n--            // !(x & false) == true\n--            // We must set the bool to true.\n--            self.swap(true, order)\n--        }\n--    }\n--\n--    /// Logical \"or\" with a boolean value.\n--    ///\n--    /// Performs a logical \"or\" operation on the current value and the argument `val`, and sets the\n--    /// new value to the result.\n--    ///\n--    /// Returns the previous value.\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicBool, Ordering};\n--    ///\n--    /// let foo = AtomicBool::new(true);\n--    /// assert_eq!(foo.fetch_or(false, Ordering::SeqCst), true);\n--    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n--    ///\n--    /// let foo = AtomicBool::new(true);\n--    /// assert_eq!(foo.fetch_or(true, Ordering::SeqCst), true);\n--    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n--    ///\n--    /// let foo = AtomicBool::new(false);\n--    /// assert_eq!(foo.fetch_or(false, Ordering::SeqCst), false);\n--    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n--    pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n--        unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }\n--    }\n--\n--    /// Logical \"xor\" with a boolean value.\n--    ///\n--    /// Performs a logical \"xor\" operation on the current value and the argument `val`, and sets\n--    /// the new value to the result.\n--    ///\n--    /// Returns the previous value.\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicBool, Ordering};\n--    ///\n--    /// let foo = AtomicBool::new(true);\n--    /// assert_eq!(foo.fetch_xor(false, Ordering::SeqCst), true);\n--    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n--    ///\n--    /// let foo = AtomicBool::new(true);\n--    /// assert_eq!(foo.fetch_xor(true, Ordering::SeqCst), true);\n--    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n--    ///\n--    /// let foo = AtomicBool::new(false);\n--    /// assert_eq!(foo.fetch_xor(false, Ordering::SeqCst), false);\n--    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n--    pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n--        unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n--    }\n--}\n--\n--#[cfg(target_has_atomic = \"ptr\")]\n--impl<T> AtomicPtr<T> {\n--    /// Creates a new `AtomicPtr`.\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::AtomicPtr;\n--    ///\n--    /// let ptr = &mut 5;\n--    /// let atomic_ptr  = AtomicPtr::new(ptr);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    pub const fn new(p: *mut T) -> AtomicPtr<T> {\n--        AtomicPtr { p: UnsafeCell::new(p) }\n--    }\n--\n--    /// Returns a mutable reference to the underlying pointer.\n--    ///\n--    /// This is safe because the mutable reference guarantees that no other threads are\n--    /// concurrently accessing the atomic data.\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicPtr, Ordering};\n--    ///\n--    /// let mut atomic_ptr = AtomicPtr::new(&mut 10);\n--    /// *atomic_ptr.get_mut() = &mut 5;\n--    /// assert_eq!(unsafe { *atomic_ptr.load(Ordering::SeqCst) }, 5);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n--    pub fn get_mut(&mut self) -> &mut *mut T {\n--        unsafe { &mut *self.p.get() }\n--    }\n--\n--    /// Consumes the atomic and returns the contained value.\n--    ///\n--    /// This is safe because passing `self` by value guarantees that no other threads are\n--    /// concurrently accessing the atomic data.\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::AtomicPtr;\n--    ///\n--    /// let atomic_ptr = AtomicPtr::new(&mut 5);\n--    /// assert_eq!(unsafe { *atomic_ptr.into_inner() }, 5);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n--    pub fn into_inner(self) -> *mut T {\n--        self.p.into_inner()\n--    }\n--\n--    /// Loads a value from the pointer.\n--    ///\n--    /// `load` takes an [`Ordering`] argument which describes the memory ordering\n--    /// of this operation.\n--    ///\n--    /// # Panics\n--    ///\n--    /// Panics if `order` is [`Release`] or [`AcqRel`].\n--    ///\n--    /// [`Ordering`]: enum.Ordering.html\n--    /// [`Release`]: enum.Ordering.html#variant.Release\n--    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicPtr, Ordering};\n--    ///\n--    /// let ptr = &mut 5;\n--    /// let some_ptr  = AtomicPtr::new(ptr);\n--    ///\n--    /// let value = some_ptr.load(Ordering::Relaxed);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    pub fn load(&self, order: Ordering) -> *mut T {\n--        unsafe { atomic_load(self.p.get() as *mut usize, order) as *mut T }\n--    }\n--\n--    /// Stores a value into the pointer.\n--    ///\n--    /// `store` takes an [`Ordering`] argument which describes the memory ordering\n--    /// of this operation.\n--    ///\n--    /// [`Ordering`]: enum.Ordering.html\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicPtr, Ordering};\n--    ///\n--    /// let ptr = &mut 5;\n--    /// let some_ptr  = AtomicPtr::new(ptr);\n--    ///\n--    /// let other_ptr = &mut 10;\n--    ///\n--    /// some_ptr.store(other_ptr, Ordering::Relaxed);\n--    /// ```\n--    ///\n--    /// # Panics\n--    ///\n--    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n--    ///\n--    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n--    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n--    #[inline]\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    pub fn store(&self, ptr: *mut T, order: Ordering) {\n--        unsafe {\n--            atomic_store(self.p.get() as *mut usize, ptr as usize, order);\n--        }\n--    }\n--\n--    /// Stores a value into the pointer, returning the previous value.\n--    ///\n--    /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n--    /// of this operation.\n--    ///\n--    /// [`Ordering`]: enum.Ordering.html\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicPtr, Ordering};\n--    ///\n--    /// let ptr = &mut 5;\n--    /// let some_ptr  = AtomicPtr::new(ptr);\n--    ///\n--    /// let other_ptr = &mut 10;\n--    ///\n--    /// let value = some_ptr.swap(other_ptr, Ordering::Relaxed);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n--    pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n--        unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n--    }\n--\n--    /// Stores a value into the pointer if the current value is the same as the `current` value.\n--    ///\n--    /// The return value is always the previous value. If it is equal to `current`, then the value\n--    /// was updated.\n--    ///\n--    /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n--    /// ordering of this operation.\n--    ///\n--    /// [`Ordering`]: enum.Ordering.html\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicPtr, Ordering};\n--    ///\n--    /// let ptr = &mut 5;\n--    /// let some_ptr  = AtomicPtr::new(ptr);\n--    ///\n--    /// let other_ptr   = &mut 10;\n--    /// let another_ptr = &mut 10;\n--    ///\n--    /// let value = some_ptr.compare_and_swap(other_ptr, another_ptr, Ordering::Relaxed);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n--    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n--    pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n--        match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n--            Ok(x) => x,\n--            Err(x) => x,\n--        }\n--    }\n--\n--    /// Stores a value into the pointer if the current value is the same as the `current` value.\n--    ///\n--    /// The return value is a result indicating whether the new value was written and containing\n--    /// the previous value. On success this value is guaranteed to be equal to `current`.\n--    ///\n--    /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n--    /// ordering of this operation. The first describes the required ordering if\n--    /// the operation succeeds while the second describes the required ordering when\n--    /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`]\n--    /// and must be equivalent or weaker than the success ordering.\n--    ///\n--    /// [`Ordering`]: enum.Ordering.html\n--    /// [`Release`]: enum.Ordering.html#variant.Release\n--    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicPtr, Ordering};\n--    ///\n--    /// let ptr = &mut 5;\n--    /// let some_ptr  = AtomicPtr::new(ptr);\n--    ///\n--    /// let other_ptr   = &mut 10;\n--    /// let another_ptr = &mut 10;\n--    ///\n--    /// let value = some_ptr.compare_exchange(other_ptr, another_ptr,\n--    ///                                       Ordering::SeqCst, Ordering::Relaxed);\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n--    #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n--    pub fn compare_exchange(&self,\n--                            current: *mut T,\n--                            new: *mut T,\n--                            success: Ordering,\n--                            failure: Ordering)\n--                            -> Result<*mut T, *mut T> {\n--        unsafe {\n--            let res = atomic_compare_exchange(self.p.get() as *mut usize,\n--                                              current as usize,\n--                                              new as usize,\n--                                              success,\n--                                              failure);\n--            match res {\n--                Ok(x) => Ok(x as *mut T),\n--                Err(x) => Err(x as *mut T),\n--            }\n--        }\n--    }\n--\n--    /// Stores a value into the pointer if the current value is the same as the `current` value.\n--    ///\n--    /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n--    /// comparison succeeds, which can result in more efficient code on some platforms. The\n--    /// return value is a result indicating whether the new value was written and containing the\n--    /// previous value.\n--    ///\n--    /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n--    /// ordering of this operation. The first describes the required ordering if the operation\n--    /// succeeds while the second describes the required ordering when the operation fails. The\n--    /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n--    /// weaker than the success ordering.\n--    ///\n--    /// [`compare_exchange`]: #method.compare_exchange\n--    /// [`Ordering`]: enum.Ordering.html\n--    /// [`Release`]: enum.Ordering.html#variant.Release\n--    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::sync::atomic::{AtomicPtr, Ordering};\n--    ///\n--    /// let some_ptr = AtomicPtr::new(&mut 5);\n--    ///\n--    /// let new = &mut 10;\n--    /// let mut old = some_ptr.load(Ordering::Relaxed);\n--    /// loop {\n--    ///     match some_ptr.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n--    ///         Ok(_) => break,\n--    ///         Err(x) => old = x,\n--    ///     }\n--    /// }\n--    /// ```\n--    #[inline]\n--    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n--    pub fn compare_exchange_weak(&self,\n--                                 current: *mut T,\n--                                 new: *mut T,\n--                                 success: Ordering,\n--                                 failure: Ordering)\n--                                 -> Result<*mut T, *mut T> {\n--        unsafe {\n--            let res = atomic_compare_exchange_weak(self.p.get() as *mut usize,\n--                                                   current as usize,\n--                                                   new as usize,\n--                                                   success,\n--                                                   failure);\n--            match res {\n--                Ok(x) => Ok(x as *mut T),\n--                Err(x) => Err(x as *mut T),\n--            }\n--        }\n--    }\n--}\n--\n--#[cfg(target_has_atomic = \"8\")]\n--#[stable(feature = \"atomic_bool_from\", since = \"1.24.0\")]\n--impl From<bool> for AtomicBool {\n--    #[inline]\n--    fn from(b: bool) -> Self { Self::new(b) }\n--}\n--\n--#[cfg(target_has_atomic = \"ptr\")]\n--#[stable(feature = \"atomic_from\", since = \"1.23.0\")]\n--impl<T> From<*mut T> for AtomicPtr<T> {\n--    #[inline]\n--    fn from(p: *mut T) -> Self { Self::new(p) }\n--}\n--\n--#[cfg(target_has_atomic = \"ptr\")]\n--macro_rules! atomic_int {\n--    ($stable:meta,\n--     $stable_cxchg:meta,\n--     $stable_debug:meta,\n--     $stable_access:meta,\n--     $stable_from:meta,\n--     $stable_nand:meta,\n--     $s_int_type:expr, $int_ref:expr,\n--     $extra_feature:expr,\n--     $min_fn:ident, $max_fn:ident,\n--     $int_type:ident $atomic_type:ident $atomic_init:ident) => {\n--        /// An integer type which can be safely shared between threads.\n--        ///\n--        /// This type has the same in-memory representation as the underlying\n--        /// integer type, [`\n--        #[doc = $s_int_type]\n--        /// `](\n--        #[doc = $int_ref]\n--        /// ). For more about the differences between atomic types and\n--        /// non-atomic types, please see the [module-level documentation].\n--        ///\n--        /// [module-level documentation]: index.html\n--        #[$stable]\n--        #[repr(transparent)]\n--        pub struct $atomic_type {\n--            v: UnsafeCell<$int_type>,\n--        }\n--\n--        /// An atomic integer initialized to `0`.\n--        #[$stable]\n--        pub const $atomic_init: $atomic_type = $atomic_type::new(0);\n--\n--        #[$stable]\n--        impl Default for $atomic_type {\n--            fn default() -> Self {\n--                Self::new(Default::default())\n--            }\n--        }\n--\n--        #[$stable_from]\n--        impl From<$int_type> for $atomic_type {\n--            #[inline]\n--            fn from(v: $int_type) -> Self { Self::new(v) }\n--        }\n--\n--        #[$stable_debug]\n--        impl fmt::Debug for $atomic_type {\n--            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n--                fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n--            }\n--        }\n--\n--        // Send is implicitly implemented.\n--        #[$stable]\n--        unsafe impl Sync for $atomic_type {}\n--\n--        impl $atomic_type {\n--            doc_comment! {\n--                concat!(\"Creates a new atomic integer.\n--\n--# Examples\n--\n--```\n--\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n--\n--let atomic_forty_two = \", stringify!($atomic_type), \"::new(42);\n--```\"),\n--                #[inline]\n--                #[$stable]\n--                pub const fn new(v: $int_type) -> Self {\n--                    $atomic_type {v: UnsafeCell::new(v)}\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Returns a mutable reference to the underlying integer.\n--\n--This is safe because the mutable reference guarantees that no other threads are\n--concurrently accessing the atomic data.\n--\n--# Examples\n--\n--```\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let mut some_var = \", stringify!($atomic_type), \"::new(10);\n--assert_eq!(*some_var.get_mut(), 10);\n--*some_var.get_mut() = 5;\n--assert_eq!(some_var.load(Ordering::SeqCst), 5);\n--```\"),\n--                #[inline]\n--                #[$stable_access]\n--                pub fn get_mut(&mut self) -> &mut $int_type {\n--                    unsafe { &mut *self.v.get() }\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Consumes the atomic and returns the contained value.\n--\n--This is safe because passing `self` by value guarantees that no other threads are\n--concurrently accessing the atomic data.\n--\n--# Examples\n--\n--```\n--\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n--\n--let some_var = \", stringify!($atomic_type), \"::new(5);\n--assert_eq!(some_var.into_inner(), 5);\n--```\"),\n--                #[inline]\n--                #[$stable_access]\n--                pub fn into_inner(self) -> $int_type {\n--                    self.v.into_inner()\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Loads a value from the atomic integer.\n--\n--`load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n--\n--# Panics\n--\n--Panics if `order` is [`Release`] or [`AcqRel`].\n--\n--[`Ordering`]: enum.Ordering.html\n--[`Release`]: enum.Ordering.html#variant.Release\n--[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n--\n--# Examples\n--\n--```\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let some_var = \", stringify!($atomic_type), \"::new(5);\n--\n--assert_eq!(some_var.load(Ordering::Relaxed), 5);\n--```\"),\n--                #[inline]\n--                #[$stable]\n--                pub fn load(&self, order: Ordering) -> $int_type {\n--                    unsafe { atomic_load(self.v.get(), order) }\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Stores a value into the atomic integer.\n--\n--`store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n--\n--[`Ordering`]: enum.Ordering.html\n--\n--# Examples\n--\n--```\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let some_var = \", stringify!($atomic_type), \"::new(5);\n--\n--some_var.store(10, Ordering::Relaxed);\n--assert_eq!(some_var.load(Ordering::Relaxed), 10);\n--```\n--\n--# Panics\n--\n--Panics if `order` is [`Acquire`] or [`AcqRel`].\n--\n--[`Acquire`]: enum.Ordering.html#variant.Acquire\n--[`AcqRel`]: enum.Ordering.html#variant.AcqRel\"),\n--                #[inline]\n--                #[$stable]\n--                pub fn store(&self, val: $int_type, order: Ordering) {\n--                    unsafe { atomic_store(self.v.get(), val, order); }\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Stores a value into the atomic integer, returning the previous value.\n--\n--`swap` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n--\n--[`Ordering`]: enum.Ordering.html\n--\n--# Examples\n--\n--```\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let some_var = \", stringify!($atomic_type), \"::new(5);\n--\n--assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n--```\"),\n--                #[inline]\n--                #[$stable]\n--                #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n--                pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n--                    unsafe { atomic_swap(self.v.get(), val, order) }\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Stores a value into the atomic integer if the current value is the same as\n--the `current` value.\n--\n--The return value is always the previous value. If it is equal to `current`, then the\n--value was updated.\n--\n--`compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n--ordering of this operation.\n--\n--[`Ordering`]: enum.Ordering.html\n--\n--# Examples\n--\n--```\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let some_var = \", stringify!($atomic_type), \"::new(5);\n--\n--assert_eq!(some_var.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n--assert_eq!(some_var.load(Ordering::Relaxed), 10);\n--\n--assert_eq!(some_var.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n--assert_eq!(some_var.load(Ordering::Relaxed), 10);\n--```\"),\n--                #[inline]\n--                #[$stable]\n--                #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n--                pub fn compare_and_swap(&self,\n--                                        current: $int_type,\n--                                        new: $int_type,\n--                                        order: Ordering) -> $int_type {\n--                    match self.compare_exchange(current,\n--                                                new,\n--                                                order,\n--                                                strongest_failure_ordering(order)) {\n--                        Ok(x) => x,\n--                        Err(x) => x,\n--                    }\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Stores a value into the atomic integer if the current value is the same as\n--the `current` value.\n--\n--The return value is a result indicating whether the new value was written and\n--containing the previous value. On success this value is guaranteed to be equal to\n--`current`.\n--\n--`compare_exchange` takes two [`Ordering`] arguments to describe the memory\n--ordering of this operation. The first describes the required ordering if\n--the operation succeeds while the second describes the required ordering when\n--the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n--must be equivalent or weaker than the success ordering.\n--\n--[`Ordering`]: enum.Ordering.html\n--[`Release`]: enum.Ordering.html#variant.Release\n--[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n--\n--# Examples\n--\n--```\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let some_var = \", stringify!($atomic_type), \"::new(5);\n--\n--assert_eq!(some_var.compare_exchange(5, 10,\n--                                     Ordering::Acquire,\n--                                     Ordering::Relaxed),\n--           Ok(5));\n--assert_eq!(some_var.load(Ordering::Relaxed), 10);\n--\n--assert_eq!(some_var.compare_exchange(6, 12,\n--                                     Ordering::SeqCst,\n--                                     Ordering::Acquire),\n--           Err(10));\n--assert_eq!(some_var.load(Ordering::Relaxed), 10);\n--```\"),\n--                #[inline]\n--                #[$stable_cxchg]\n--                #[cfg(any(stage0, target_has_atomic = \"cas\"))]\n--                pub fn compare_exchange(&self,\n--                                        current: $int_type,\n--                                        new: $int_type,\n--                                        success: Ordering,\n--                                        failure: Ordering) -> Result<$int_type, $int_type> {\n--                    unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Stores a value into the atomic integer if the current value is the same as\n--the `current` value.\n--\n--Unlike [`compare_exchange`], this function is allowed to spuriously fail even\n--when the comparison succeeds, which can result in more efficient code on some\n--platforms. The return value is a result indicating whether the new value was\n--written and containing the previous value.\n--\n--`compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n--ordering of this operation. The first describes the required ordering if the\n--operation succeeds while the second describes the required ordering when the\n--operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n--must be equivalent or weaker than the success ordering.\n--\n--[`compare_exchange`]: #method.compare_exchange\n--[`Ordering`]: enum.Ordering.html\n--[`Release`]: enum.Ordering.html#variant.Release\n--[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n--\n--# Examples\n--\n--```\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let val = \", stringify!($atomic_type), \"::new(4);\n--\n--let mut old = val.load(Ordering::Relaxed);\n--loop {\n--    let new = old * 2;\n--    match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n--        Ok(_) => break,\n--        Err(x) => old = x,\n--    }\n--}\n--```\"),\n--                #[inline]\n--                #[$stable_cxchg]\n--                pub fn compare_exchange_weak(&self,\n--                                             current: $int_type,\n--                                             new: $int_type,\n--                                             success: Ordering,\n--                                             failure: Ordering) -> Result<$int_type, $int_type> {\n--                    unsafe {\n--                        atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n--                    }\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Adds to the current value, returning the previous value.\n--\n--This operation wraps around on overflow.\n--\n--# Examples\n--\n--```\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let foo = \", stringify!($atomic_type), \"::new(0);\n--assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n--assert_eq!(foo.load(Ordering::SeqCst), 10);\n--```\"),\n--                #[inline]\n--                #[$stable]\n--                pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n--                    unsafe { atomic_add(self.v.get(), val, order) }\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Subtracts from the current value, returning the previous value.\n--\n--This operation wraps around on overflow.\n--\n--# Examples\n--\n--```\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let foo = \", stringify!($atomic_type), \"::new(20);\n--assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 20);\n--assert_eq!(foo.load(Ordering::SeqCst), 10);\n--```\"),\n--                #[inline]\n--                #[$stable]\n--                pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n--                    unsafe { atomic_sub(self.v.get(), val, order) }\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Bitwise \\\"and\\\" with the current value.\n--\n--Performs a bitwise \\\"and\\\" operation on the current value and the argument `val`, and\n--sets the new value to the result.\n--\n--Returns the previous value.\n--\n--# Examples\n--\n--```\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let foo = \", stringify!($atomic_type), \"::new(0b101101);\n--assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n--assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n--```\"),\n--                #[inline]\n--                #[$stable]\n--                pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n--                    unsafe { atomic_and(self.v.get(), val, order) }\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Bitwise \\\"nand\\\" with the current value.\n--\n--Performs a bitwise \\\"nand\\\" operation on the current value and the argument `val`, and\n--sets the new value to the result.\n--\n--Returns the previous value.\n--\n--# Examples\n--\n--```\n--\", $extra_feature, \"\n--use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let foo = \", stringify!($atomic_type), \"::new(0x13);\n--assert_eq!(foo.fetch_nand(0x31, Ordering::SeqCst), 0x13);\n--assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n--```\"),\n--                #[inline]\n--                #[$stable_nand]\n--                pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n--                    unsafe { atomic_nand(self.v.get(), val, order) }\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Bitwise \\\"or\\\" with the current value.\n--\n--Performs a bitwise \\\"or\\\" operation on the current value and the argument `val`, and\n--sets the new value to the result.\n--\n--Returns the previous value.\n--\n--# Examples\n--\n--```\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let foo = \", stringify!($atomic_type), \"::new(0b101101);\n--assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n--assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n--```\"),\n--                #[inline]\n--                #[$stable]\n--                pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n--                    unsafe { atomic_or(self.v.get(), val, order) }\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Bitwise \\\"xor\\\" with the current value.\n--\n--Performs a bitwise \\\"xor\\\" operation on the current value and the argument `val`, and\n--sets the new value to the result.\n--\n--Returns the previous value.\n--\n--# Examples\n--\n--```\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let foo = \", stringify!($atomic_type), \"::new(0b101101);\n--assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n--assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n--```\"),\n--                #[inline]\n--                #[$stable]\n--                pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n--                    unsafe { atomic_xor(self.v.get(), val, order) }\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Fetches the value, and applies a function to it that returns an optional\n--new value. Returns a `Result` of `Ok(previous_value)` if the function returned `Some(_)`, else\n--`Err(previous_value)`.\n--\n--Note: This may call the function multiple times if the value has been changed from other threads in\n--the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n--but once to the stored value.\n--\n--# Examples\n--\n--```rust\n--#![feature(no_more_cas)]\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let x = \", stringify!($atomic_type), \"::new(7);\n--assert_eq!(x.fetch_update(|_| None, Ordering::SeqCst, Ordering::SeqCst), Err(7));\n--assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(7));\n--assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(8));\n--assert_eq!(x.load(Ordering::SeqCst), 9);\n--```\"),\n--                #[inline]\n--                #[unstable(feature = \"no_more_cas\",\n--                       reason = \"no more CAS loops in user code\",\n--                       issue = \"48655\")]\n--                pub fn fetch_update<F>(&self,\n--                                       mut f: F,\n--                                       fetch_order: Ordering,\n--                                       set_order: Ordering) -> Result<$int_type, $int_type>\n--                where F: FnMut($int_type) -> Option<$int_type> {\n--                    let mut prev = self.load(fetch_order);\n--                    while let Some(next) = f(prev) {\n--                        match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n--                            x @ Ok(_) => return x,\n--                            Err(next_prev) => prev = next_prev\n--                        }\n--                    }\n--                    Err(prev)\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Maximum with the current value.\n--\n--Finds the maximum of the current value and the argument `val`, and\n--sets the new value to the result.\n--\n--Returns the previous value.\n--\n--# Examples\n--\n--```\n--#![feature(atomic_min_max)]\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let foo = \", stringify!($atomic_type), \"::new(23);\n--assert_eq!(foo.fetch_max(42, Ordering::SeqCst), 23);\n--assert_eq!(foo.load(Ordering::SeqCst), 42);\n--```\n--\n--If you want to obtain the maximum value in one step, you can use the following:\n--\n--```\n--#![feature(atomic_min_max)]\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let foo = \", stringify!($atomic_type), \"::new(23);\n--let bar = 42;\n--let max_foo = foo.fetch_max(bar, Ordering::SeqCst).max(bar);\n--assert!(max_foo == 42);\n--```\"),\n--                #[inline]\n--                #[unstable(feature = \"atomic_min_max\",\n--                       reason = \"easier and faster min/max than writing manual CAS loop\",\n--                       issue = \"48655\")]\n--                pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n--                    unsafe { $max_fn(self.v.get(), val, order) }\n--                }\n--            }\n--\n--            doc_comment! {\n--                concat!(\"Minimum with the current value.\n--\n--Finds the minimum of the current value and the argument `val`, and\n--sets the new value to the result.\n--\n--Returns the previous value.\n--\n--# Examples\n--\n--```\n--#![feature(atomic_min_max)]\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let foo = \", stringify!($atomic_type), \"::new(23);\n--assert_eq!(foo.fetch_min(42, Ordering::Relaxed), 23);\n--assert_eq!(foo.load(Ordering::Relaxed), 23);\n--assert_eq!(foo.fetch_min(22, Ordering::Relaxed), 23);\n--assert_eq!(foo.load(Ordering::Relaxed), 22);\n--```\n--\n--If you want to obtain the minimum value in one step, you can use the following:\n--\n--```\n--#![feature(atomic_min_max)]\n--\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n--\n--let foo = \", stringify!($atomic_type), \"::new(23);\n--let bar = 12;\n--let min_foo = foo.fetch_min(bar, Ordering::SeqCst).min(bar);\n--assert_eq!(min_foo, 12);\n--```\"),\n--                #[inline]\n--                #[unstable(feature = \"atomic_min_max\",\n--                       reason = \"easier and faster min/max than writing manual CAS loop\",\n--                       issue = \"48655\")]\n--                pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n--                    unsafe { $min_fn(self.v.get(), val, order) }\n--                }\n--            }\n--\n--        }\n--    }\n--}\n--\n--#[cfg(target_has_atomic = \"8\")]\n--atomic_int! {\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    \"i8\", \"../../../std/primitive.i8.html\",\n--    \"#![feature(integer_atomics)]\\n\\n\",\n--    atomic_min, atomic_max,\n--    i8 AtomicI8 ATOMIC_I8_INIT\n--}\n--#[cfg(target_has_atomic = \"8\")]\n--atomic_int! {\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    \"u8\", \"../../../std/primitive.u8.html\",\n--    \"#![feature(integer_atomics)]\\n\\n\",\n--    atomic_umin, atomic_umax,\n--    u8 AtomicU8 ATOMIC_U8_INIT\n--}\n--#[cfg(target_has_atomic = \"16\")]\n--atomic_int! {\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    \"i16\", \"../../../std/primitive.i16.html\",\n--    \"#![feature(integer_atomics)]\\n\\n\",\n--    atomic_min, atomic_max,\n--    i16 AtomicI16 ATOMIC_I16_INIT\n--}\n--#[cfg(target_has_atomic = \"16\")]\n--atomic_int! {\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    \"u16\", \"../../../std/primitive.u16.html\",\n--    \"#![feature(integer_atomics)]\\n\\n\",\n--    atomic_umin, atomic_umax,\n--    u16 AtomicU16 ATOMIC_U16_INIT\n--}\n--#[cfg(target_has_atomic = \"32\")]\n--atomic_int! {\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    \"i32\", \"../../../std/primitive.i32.html\",\n--    \"#![feature(integer_atomics)]\\n\\n\",\n--    atomic_min, atomic_max,\n--    i32 AtomicI32 ATOMIC_I32_INIT\n--}\n--#[cfg(target_has_atomic = \"32\")]\n--atomic_int! {\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    \"u32\", \"../../../std/primitive.u32.html\",\n--    \"#![feature(integer_atomics)]\\n\\n\",\n--    atomic_umin, atomic_umax,\n--    u32 AtomicU32 ATOMIC_U32_INIT\n--}\n--#[cfg(target_has_atomic = \"64\")]\n--atomic_int! {\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    \"i64\", \"../../../std/primitive.i64.html\",\n--    \"#![feature(integer_atomics)]\\n\\n\",\n--    atomic_min, atomic_max,\n--    i64 AtomicI64 ATOMIC_I64_INIT\n--}\n--#[cfg(target_has_atomic = \"64\")]\n--atomic_int! {\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    \"u64\", \"../../../std/primitive.u64.html\",\n--    \"#![feature(integer_atomics)]\\n\\n\",\n--    atomic_umin, atomic_umax,\n--    u64 AtomicU64 ATOMIC_U64_INIT\n--}\n--#[cfg(target_has_atomic = \"ptr\")]\n--atomic_int!{\n--    stable(feature = \"rust1\", since = \"1.0.0\"),\n--    stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n--    stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n--    stable(feature = \"atomic_access\", since = \"1.15.0\"),\n--    stable(feature = \"atomic_from\", since = \"1.23.0\"),\n--    stable(feature = \"atomic_nand\", since = \"1.27.0\"),\n--    \"isize\", \"../../../std/primitive.isize.html\",\n--    \"\",\n--    atomic_min, atomic_max,\n--    isize AtomicIsize ATOMIC_ISIZE_INIT\n--}\n--#[cfg(target_has_atomic = \"ptr\")]\n--atomic_int!{\n--    stable(feature = \"rust1\", since = \"1.0.0\"),\n--    stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n--    stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n--    stable(feature = \"atomic_access\", since = \"1.15.0\"),\n--    stable(feature = \"atomic_from\", since = \"1.23.0\"),\n--    stable(feature = \"atomic_nand\", since = \"1.27.0\"),\n--    \"usize\", \"../../../std/primitive.usize.html\",\n--    \"\",\n--    atomic_umin, atomic_umax,\n--    usize AtomicUsize ATOMIC_USIZE_INIT\n--}\n--\n--#[inline]\n--#[cfg(any(stage0, target_has_atomic = \"cas\"))]\n--fn strongest_failure_ordering(order: Ordering) -> Ordering {\n--    match order {\n--        Release => Relaxed,\n--        Relaxed => Relaxed,\n--        SeqCst => SeqCst,\n--        Acquire => Acquire,\n--        AcqRel => Acquire,\n--        __Nonexhaustive => __Nonexhaustive,\n--    }\n--}\n--\n--#[inline]\n--unsafe fn atomic_store<T>(dst: *mut T, val: T, order: Ordering) {\n--    match order {\n--        Release => intrinsics::atomic_store_rel(dst, val),\n--        Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n--        SeqCst => intrinsics::atomic_store(dst, val),\n--        Acquire => panic!(\"there is no such thing as an acquire store\"),\n--        AcqRel => panic!(\"there is no such thing as an acquire/release store\"),\n--        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n--    }\n--}\n--\n--#[inline]\n--unsafe fn atomic_load<T>(dst: *const T, order: Ordering) -> T {\n--    match order {\n--        Acquire => intrinsics::atomic_load_acq(dst),\n--        Relaxed => intrinsics::atomic_load_relaxed(dst),\n--        SeqCst => intrinsics::atomic_load(dst),\n--        Release => panic!(\"there is no such thing as a release load\"),\n--        AcqRel => panic!(\"there is no such thing as an acquire/release load\"),\n--        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n--    }\n--}\n--\n--#[inline]\n--#[cfg(any(stage0, target_has_atomic = \"cas\"))]\n--unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n--    match order {\n--        Acquire => intrinsics::atomic_xchg_acq(dst, val),\n--        Release => intrinsics::atomic_xchg_rel(dst, val),\n--        AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),\n--        Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n--        SeqCst => intrinsics::atomic_xchg(dst, val),\n--        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n--    }\n--}\n--\n--/// Returns the previous value (like __sync_fetch_and_add).\n--#[inline]\n--unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n--    match order {\n--        Acquire => intrinsics::atomic_xadd_acq(dst, val),\n--        Release => intrinsics::atomic_xadd_rel(dst, val),\n--        AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),\n--        Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n--        SeqCst => intrinsics::atomic_xadd(dst, val),\n--        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n--    }\n--}\n--\n--/// Returns the previous value (like __sync_fetch_and_sub).\n--#[inline]\n--unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n--    match order {\n--        Acquire => intrinsics::atomic_xsub_acq(dst, val),\n--        Release => intrinsics::atomic_xsub_rel(dst, val),\n--        AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),\n--        Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n--        SeqCst => intrinsics::atomic_xsub(dst, val),\n--        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n--    }\n--}\n--\n--#[inline]\n--#[cfg(any(stage0, target_has_atomic = \"cas\"))]\n--unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n--                                     old: T,\n--                                     new: T,\n--                                     success: Ordering,\n--                                     failure: Ordering)\n--                                     -> Result<T, T> {\n--    let (val, ok) = match (success, failure) {\n--        (Acquire, Acquire) => intrinsics::atomic_cxchg_acq(dst, old, new),\n--        (Release, Relaxed) => intrinsics::atomic_cxchg_rel(dst, old, new),\n--        (AcqRel, Acquire) => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n--        (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n--        (SeqCst, SeqCst) => intrinsics::atomic_cxchg(dst, old, new),\n--        (Acquire, Relaxed) => intrinsics::atomic_cxchg_acq_failrelaxed(dst, old, new),\n--        (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n--        (SeqCst, Relaxed) => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n--        (SeqCst, Acquire) => intrinsics::atomic_cxchg_failacq(dst, old, new),\n--        (__Nonexhaustive, _) => panic!(\"invalid memory ordering\"),\n--        (_, __Nonexhaustive) => panic!(\"invalid memory ordering\"),\n--        (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n--        (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n--        _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n--    };\n--    if ok { Ok(val) } else { Err(val) }\n--}\n--\n--#[inline]\n--unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n--                                          old: T,\n--                                          new: T,\n--                                          success: Ordering,\n--                                          failure: Ordering)\n--                                          -> Result<T, T> {\n--    let (val, ok) = match (success, failure) {\n--        (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acq(dst, old, new),\n--        (Release, Relaxed) => intrinsics::atomic_cxchgweak_rel(dst, old, new),\n--        (AcqRel, Acquire) => intrinsics::atomic_cxchgweak_acqrel(dst, old, new),\n--        (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed(dst, old, new),\n--        (SeqCst, SeqCst) => intrinsics::atomic_cxchgweak(dst, old, new),\n--        (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acq_failrelaxed(dst, old, new),\n--        (AcqRel, Relaxed) => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n--        (SeqCst, Relaxed) => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n--        (SeqCst, Acquire) => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n--        (__Nonexhaustive, _) => panic!(\"invalid memory ordering\"),\n--        (_, __Nonexhaustive) => panic!(\"invalid memory ordering\"),\n--        (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n--        (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n--        _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n--    };\n--    if ok { Ok(val) } else { Err(val) }\n--}\n--\n--#[inline]\n--unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n--    match order {\n--        Acquire => intrinsics::atomic_and_acq(dst, val),\n--        Release => intrinsics::atomic_and_rel(dst, val),\n--        AcqRel => intrinsics::atomic_and_acqrel(dst, val),\n--        Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n--        SeqCst => intrinsics::atomic_and(dst, val),\n--        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n--    }\n--}\n--\n--#[inline]\n--unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n--    match order {\n--        Acquire => intrinsics::atomic_nand_acq(dst, val),\n--        Release => intrinsics::atomic_nand_rel(dst, val),\n--        AcqRel => intrinsics::atomic_nand_acqrel(dst, val),\n--        Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n--        SeqCst => intrinsics::atomic_nand(dst, val),\n--        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n--    }\n--}\n--\n--#[inline]\n--unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n--    match order {\n--        Acquire => intrinsics::atomic_or_acq(dst, val),\n--        Release => intrinsics::atomic_or_rel(dst, val),\n--        AcqRel => intrinsics::atomic_or_acqrel(dst, val),\n--        Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n--        SeqCst => intrinsics::atomic_or(dst, val),\n--        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n--    }\n--}\n--\n--#[inline]\n--unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n--    match order {\n--        Acquire => intrinsics::atomic_xor_acq(dst, val),\n--        Release => intrinsics::atomic_xor_rel(dst, val),\n--        AcqRel => intrinsics::atomic_xor_acqrel(dst, val),\n--        Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n--        SeqCst => intrinsics::atomic_xor(dst, val),\n--        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n--    }\n--}\n--\n--/// returns the max value (signed comparison)\n--#[inline]\n--unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n--    match order {\n--        Acquire => intrinsics::atomic_max_acq(dst, val),\n--        Release => intrinsics::atomic_max_rel(dst, val),\n--        AcqRel => intrinsics::atomic_max_acqrel(dst, val),\n--        Relaxed => intrinsics::atomic_max_relaxed(dst, val),\n--        SeqCst => intrinsics::atomic_max(dst, val),\n--        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n--    }\n--}\n--\n--/// returns the min value (signed comparison)\n--#[inline]\n--unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n--    match order {\n--        Acquire => intrinsics::atomic_min_acq(dst, val),\n--        Release => intrinsics::atomic_min_rel(dst, val),\n--        AcqRel => intrinsics::atomic_min_acqrel(dst, val),\n--        Relaxed => intrinsics::atomic_min_relaxed(dst, val),\n--        SeqCst => intrinsics::atomic_min(dst, val),\n--        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n--    }\n--}\n--\n--/// returns the max value (signed comparison)\n--#[inline]\n--unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n--    match order {\n--        Acquire => intrinsics::atomic_umax_acq(dst, val),\n--        Release => intrinsics::atomic_umax_rel(dst, val),\n--        AcqRel => intrinsics::atomic_umax_acqrel(dst, val),\n--        Relaxed => intrinsics::atomic_umax_relaxed(dst, val),\n--        SeqCst => intrinsics::atomic_umax(dst, val),\n--        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n--    }\n--}\n--\n--/// returns the min value (signed comparison)\n--#[inline]\n--unsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {\n--    match order {\n--        Acquire => intrinsics::atomic_umin_acq(dst, val),\n--        Release => intrinsics::atomic_umin_rel(dst, val),\n--        AcqRel => intrinsics::atomic_umin_acqrel(dst, val),\n--        Relaxed => intrinsics::atomic_umin_relaxed(dst, val),\n--        SeqCst => intrinsics::atomic_umin(dst, val),\n--        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n--    }\n--}\n--\n--/// An atomic fence.\n--///\n--/// Depending on the specified order, a fence prevents the compiler and CPU from\n--/// reordering certain types of memory operations around it.\n--/// That creates synchronizes-with relationships between it and atomic operations\n--/// or fences in other threads.\n--///\n--/// A fence 'A' which has (at least) [`Release`] ordering semantics, synchronizes\n--/// with a fence 'B' with (at least) [`Acquire`] semantics, if and only if there\n--/// exist operations X and Y, both operating on some atomic object 'M' such\n--/// that A is sequenced before X, Y is synchronized before B and Y observes\n--/// the change to M. This provides a happens-before dependence between A and B.\n--///\n--/// ```text\n--///     Thread 1                                          Thread 2\n--///\n--/// fence(Release);      A --------------\n--/// x.store(3, Relaxed); X ---------    |\n--///                                |    |\n--///                                |    |\n--///                                -------------> Y  if x.load(Relaxed) == 3 {\n--///                                     |-------> B      fence(Acquire);\n--///                                                      ...\n--///                                                  }\n--/// ```\n--///\n--/// Atomic operations with [`Release`] or [`Acquire`] semantics can also synchronize\n--/// with a fence.\n--///\n--/// A fence which has [`SeqCst`] ordering, in addition to having both [`Acquire`]\n--/// and [`Release`] semantics, participates in the global program order of the\n--/// other [`SeqCst`] operations and/or fences.\n--///\n--/// Accepts [`Acquire`], [`Release`], [`AcqRel`] and [`SeqCst`] orderings.\n--///\n--/// # Panics\n--///\n--/// Panics if `order` is [`Relaxed`].\n--///\n--/// # Examples\n--///\n--/// ```\n--/// use std::sync::atomic::AtomicBool;\n--/// use std::sync::atomic::fence;\n--/// use std::sync::atomic::Ordering;\n--///\n--/// // A mutual exclusion primitive based on spinlock.\n--/// pub struct Mutex {\n--///     flag: AtomicBool,\n--/// }\n--///\n--/// impl Mutex {\n--///     pub fn new() -> Mutex {\n--///         Mutex {\n--///             flag: AtomicBool::new(false),\n--///         }\n--///     }\n--///\n--///     pub fn lock(&self) {\n--///         while !self.flag.compare_and_swap(false, true, Ordering::Relaxed) {}\n--///         // This fence synchronizes-with store in `unlock`.\n--///         fence(Ordering::Acquire);\n--///     }\n--///\n--///     pub fn unlock(&self) {\n--///         self.flag.store(false, Ordering::Release);\n--///     }\n--/// }\n--/// ```\n--///\n--/// [`Ordering`]: enum.Ordering.html\n--/// [`Acquire`]: enum.Ordering.html#variant.Acquire\n--/// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n--/// [`Release`]: enum.Ordering.html#variant.Release\n--/// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n--/// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n--#[inline]\n--#[stable(feature = \"rust1\", since = \"1.0.0\")]\n--pub fn fence(order: Ordering) {\n--    unsafe {\n--        match order {\n--            Acquire => intrinsics::atomic_fence_acq(),\n--            Release => intrinsics::atomic_fence_rel(),\n--            AcqRel => intrinsics::atomic_fence_acqrel(),\n--            SeqCst => intrinsics::atomic_fence(),\n--            Relaxed => panic!(\"there is no such thing as a relaxed fence\"),\n--            __Nonexhaustive => panic!(\"invalid memory ordering\"),\n--        }\n--    }\n--}\n--\n--\n--/// A compiler memory fence.\n--///\n--/// `compiler_fence` does not emit any machine code, but restricts the kinds\n--/// of memory re-ordering the compiler is allowed to do. Specifically, depending on\n--/// the given [`Ordering`] semantics, the compiler may be disallowed from moving reads\n--/// or writes from before or after the call to the other side of the call to\n--/// `compiler_fence`. Note that it does **not** prevent the *hardware*\n--/// from doing such re-ordering. This is not a problem in a single-threaded,\n--/// execution context, but when other threads may modify memory at the same\n--/// time, stronger synchronization primitives such as [`fence`] are required.\n--///\n--/// The re-ordering prevented by the different ordering semantics are:\n--///\n--///  - with [`SeqCst`], no re-ordering of reads and writes across this point is allowed.\n--///  - with [`Release`], preceding reads and writes cannot be moved past subsequent writes.\n--///  - with [`Acquire`], subsequent reads and writes cannot be moved ahead of preceding reads.\n--///  - with [`AcqRel`], both of the above rules are enforced.\n--///\n--/// `compiler_fence` is generally only useful for preventing a thread from\n--/// racing *with itself*. That is, if a given thread is executing one piece\n--/// of code, and is then interrupted, and starts executing code elsewhere\n--/// (while still in the same thread, and conceptually still on the same\n--/// core). In traditional programs, this can only occur when a signal\n--/// handler is registered. In more low-level code, such situations can also\n--/// arise when handling interrupts, when implementing green threads with\n--/// pre-emption, etc. Curious readers are encouraged to read the Linux kernel's\n--/// discussion of [memory barriers].\n--///\n--/// # Panics\n--///\n--/// Panics if `order` is [`Relaxed`].\n--///\n--/// # Examples\n--///\n--/// Without `compiler_fence`, the `assert_eq!` in following code\n--/// is *not* guaranteed to succeed, despite everything happening in a single thread.\n--/// To see why, remember that the compiler is free to swap the stores to\n--/// `IMPORTANT_VARIABLE` and `IS_READ` since they are both\n--/// `Ordering::Relaxed`. If it does, and the signal handler is invoked right\n--/// after `IS_READY` is updated, then the signal handler will see\n--/// `IS_READY=1`, but `IMPORTANT_VARIABLE=0`.\n--/// Using a `compiler_fence` remedies this situation.\n--///\n--/// ```\n--/// use std::sync::atomic::{AtomicBool, AtomicUsize};\n--/// use std::sync::atomic::{ATOMIC_BOOL_INIT, ATOMIC_USIZE_INIT};\n--/// use std::sync::atomic::Ordering;\n--/// use std::sync::atomic::compiler_fence;\n--///\n--/// static IMPORTANT_VARIABLE: AtomicUsize = ATOMIC_USIZE_INIT;\n--/// static IS_READY: AtomicBool = ATOMIC_BOOL_INIT;\n--///\n--/// fn main() {\n--///     IMPORTANT_VARIABLE.store(42, Ordering::Relaxed);\n--///     // prevent earlier writes from being moved beyond this point\n--///     compiler_fence(Ordering::Release);\n--///     IS_READY.store(true, Ordering::Relaxed);\n--/// }\n--///\n--/// fn signal_handler() {\n--///     if IS_READY.load(Ordering::Relaxed) {\n--///         assert_eq!(IMPORTANT_VARIABLE.load(Ordering::Relaxed), 42);\n--///     }\n--/// }\n--/// ```\n--///\n--/// [`fence`]: fn.fence.html\n--/// [`Ordering`]: enum.Ordering.html\n--/// [`Acquire`]: enum.Ordering.html#variant.Acquire\n--/// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n--/// [`Release`]: enum.Ordering.html#variant.Release\n--/// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n--/// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n--/// [memory barriers]: https://www.kernel.org/doc/Documentation/memory-barriers.txt\n--#[inline]\n--#[stable(feature = \"compiler_fences\", since = \"1.21.0\")]\n--pub fn compiler_fence(order: Ordering) {\n--    unsafe {\n--        match order {\n--            Acquire => intrinsics::atomic_singlethreadfence_acq(),\n--            Release => intrinsics::atomic_singlethreadfence_rel(),\n--            AcqRel => intrinsics::atomic_singlethreadfence_acqrel(),\n--            SeqCst => intrinsics::atomic_singlethreadfence(),\n--            Relaxed => panic!(\"there is no such thing as a relaxed compiler fence\"),\n--            __Nonexhaustive => panic!(\"invalid memory ordering\"),\n--        }\n--    }\n--}\n--\n--\n--#[cfg(target_has_atomic = \"8\")]\n--#[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n--impl fmt::Debug for AtomicBool {\n--    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n--        fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n--    }\n--}\n--\n--#[cfg(target_has_atomic = \"ptr\")]\n--#[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n--impl<T> fmt::Debug for AtomicPtr<T> {\n--    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n--        fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n--    }\n--}\n--\n--#[cfg(target_has_atomic = \"ptr\")]\n--#[stable(feature = \"atomic_pointer\", since = \"1.24.0\")]\n--impl<T> fmt::Pointer for AtomicPtr<T> {\n--    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n--        fmt::Pointer::fmt(&self.load(Ordering::SeqCst), f)\n--    }\n--}\n-diff --git a/src/libcore/sync/mod.rs b/src/libcore/sync/mod.rs\n-deleted file mode 100644\n-index 0080e0b5e4..0000000000\n---- a/src/libcore/sync/mod.rs\n-+++ /dev/null\n-@@ -1,15 +0,0 @@\n--// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n--// file at the top-level directory of this distribution and at\n--// http://rust-lang.org/COPYRIGHT.\n--//\n--// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n--// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n--// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n--// option. This file may not be copied, modified, or distributed\n--// except according to those terms.\n--\n--//! Synchronization primitives\n--\n--#![stable(feature = \"rust1\", since = \"1.0.0\")]\n--\n--pub mod atomic;\n--- \n 2.11.0\n "}]}