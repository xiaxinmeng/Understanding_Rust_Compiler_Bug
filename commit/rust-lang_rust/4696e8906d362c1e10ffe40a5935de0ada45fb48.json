{"sha": "4696e8906d362c1e10ffe40a5935de0ada45fb48", "node_id": "C_kwDOAAsO6NoAKDQ2OTZlODkwNmQzNjJjMWUxMGZmZTQwYTU5MzVkZTBhZGE0NWZiNDg", "commit": {"author": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-10-22T22:47:21Z"}, "committer": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-11-19T15:47:42Z"}, "message": "Schr\u00f6dinger's pointer\n\nIt's aligned *and* not aligned!", "tree": {"sha": "828144a6d1e1efcd90155f1c5eb082eca6e1b3e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/828144a6d1e1efcd90155f1c5eb082eca6e1b3e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4696e8906d362c1e10ffe40a5935de0ada45fb48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4696e8906d362c1e10ffe40a5935de0ada45fb48", "html_url": "https://github.com/rust-lang/rust/commit/4696e8906d362c1e10ffe40a5935de0ada45fb48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4696e8906d362c1e10ffe40a5935de0ada45fb48/comments", "author": null, "committer": null, "parents": [{"sha": "df0bcfe6448793e423bd6b8fd5294f10798dd469", "url": "https://api.github.com/repos/rust-lang/rust/commits/df0bcfe6448793e423bd6b8fd5294f10798dd469", "html_url": "https://github.com/rust-lang/rust/commit/df0bcfe6448793e423bd6b8fd5294f10798dd469"}], "stats": {"total": 84, "additions": 84, "deletions": 0}, "files": [{"sha": "d042f22f0266f1f4660a4b9356f55f9c1c41f865", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4696e8906d362c1e10ffe40a5935de0ada45fb48/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4696e8906d362c1e10ffe40a5935de0ada45fb48/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=4696e8906d362c1e10ffe40a5935de0ada45fb48", "patch": "@@ -1402,6 +1402,27 @@ impl<T: ?Sized> *const T {\n     /// };\n     /// ```\n     ///\n+    /// Due to this behavior, it is possible that a runtime pointer derived from a compiletime\n+    /// pointer is aligned, even if the compiletime pointer wasn't aligned.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// // At compiletime, neither `CONST_PTR` nor `CONST_PTR + 1` is aligned.\n+    /// const CONST_PTR: *const i32 = &42;\n+    /// const _: () = assert!(!CONST_PTR.cast::<i64>().is_aligned());\n+    /// const _: () = assert!(!CONST_PTR.wrapping_add(1).cast::<i64>().is_aligned());\n+    ///\n+    /// // At runtime, either `runtime_ptr` or `runtime_ptr + 1` is aligned.\n+    /// let runtime_ptr = CONST_PTR;\n+    /// assert_ne!(\n+    ///     runtime_ptr.cast::<i64>().is_aligned(),\n+    ///     runtime_ptr.wrapping_add(1).cast::<i64>().is_aligned(),\n+    /// );\n+    /// ```\n+    ///\n     /// If a pointer is created from a fixed address, this function behaves the same during\n     /// runtime and compiletime.\n     ///\n@@ -1492,6 +1513,27 @@ impl<T: ?Sized> *const T {\n     /// };\n     /// ```\n     ///\n+    /// Due to this behavior, it is possible that a runtime pointer derived from a compiletime\n+    /// pointer is aligned, even if the compiletime pointer wasn't aligned.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// // At compiletime, neither `CONST_PTR` nor `CONST_PTR + 1` is aligned.\n+    /// const CONST_PTR: *const i32 = &42;\n+    /// const _: () = assert!(!CONST_PTR.is_aligned_to(8));\n+    /// const _: () = assert!(!CONST_PTR.wrapping_add(1).is_aligned_to(8));\n+    ///\n+    /// // At runtime, either `runtime_ptr` or `runtime_ptr + 1` is aligned.\n+    /// let runtime_ptr = CONST_PTR;\n+    /// assert_ne!(\n+    ///     runtime_ptr.is_aligned_to(8),\n+    ///     runtime_ptr.wrapping_add(1).is_aligned_to(8),\n+    /// );\n+    /// ```\n+    ///\n     /// If a pointer is created from a fixed address, this function behaves the same during\n     /// runtime and compiletime.\n     ///"}, {"sha": "764fa9d8ba8124f1d2bd01c5e38ec9b27cc0f66e", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4696e8906d362c1e10ffe40a5935de0ada45fb48/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4696e8906d362c1e10ffe40a5935de0ada45fb48/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=4696e8906d362c1e10ffe40a5935de0ada45fb48", "patch": "@@ -1670,6 +1670,27 @@ impl<T: ?Sized> *mut T {\n     /// };\n     /// ```\n     ///\n+    /// Due to this behavior, it is possible that a runtime pointer derived from a compiletime\n+    /// pointer is aligned, even if the compiletime pointer wasn't aligned.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// // At compiletime, neither `CONST_PTR` nor `CONST_PTR + 1` is aligned.\n+    /// const CONST_PTR: *const i32 = &42;\n+    /// const _: () = assert!(!CONST_PTR.cast::<i64>().is_aligned());\n+    /// const _: () = assert!(!CONST_PTR.wrapping_add(1).cast::<i64>().is_aligned());\n+    ///\n+    /// // At runtime, either `runtime_ptr` or `runtime_ptr + 1` is aligned.\n+    /// let runtime_ptr = CONST_PTR;\n+    /// assert_ne!(\n+    ///     runtime_ptr.cast::<i64>().is_aligned(),\n+    ///     runtime_ptr.wrapping_add(1).cast::<i64>().is_aligned(),\n+    /// );\n+    /// ```\n+    ///\n     /// If a pointer is created from a fixed address, this function behaves the same during\n     /// runtime and compiletime.\n     ///\n@@ -1760,6 +1781,27 @@ impl<T: ?Sized> *mut T {\n     /// };\n     /// ```\n     ///\n+    /// Due to this behavior, it is possible that a runtime pointer derived from a compiletime\n+    /// pointer is aligned, even if the compiletime pointer wasn't aligned.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// // At compiletime, neither `CONST_PTR` nor `CONST_PTR + 1` is aligned.\n+    /// const CONST_PTR: *const i32 = &42;\n+    /// const _: () = assert!(!CONST_PTR.is_aligned_to(8));\n+    /// const _: () = assert!(!CONST_PTR.wrapping_add(1).is_aligned_to(8));\n+    ///\n+    /// // At runtime, either `runtime_ptr` or `runtime_ptr + 1` is aligned.\n+    /// let runtime_ptr = CONST_PTR;\n+    /// assert_ne!(\n+    ///     runtime_ptr.is_aligned_to(8),\n+    ///     runtime_ptr.wrapping_add(1).is_aligned_to(8),\n+    /// );\n+    /// ```\n+    ///\n     /// If a pointer is created from a fixed address, this function behaves the same during\n     /// runtime and compiletime.\n     ///"}]}