{"sha": "354a5cb250fe386075d33539a6c2e9a75d9d7fc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NGE1Y2IyNTBmZTM4NjA3NWQzMzUzOWE2YzJlOWE3NWQ5ZDdmYzU=", "commit": {"author": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-10-15T20:28:49Z"}, "committer": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-11-07T19:13:19Z"}, "message": "Make trans const eval error on overflow and NaN, matching  HIR const eval.", "tree": {"sha": "9ce68d88b3305a81b5b8c3545dc1abfb4e2b5716", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ce68d88b3305a81b5b8c3545dc1abfb4e2b5716"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/354a5cb250fe386075d33539a6c2e9a75d9d7fc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/354a5cb250fe386075d33539a6c2e9a75d9d7fc5", "html_url": "https://github.com/rust-lang/rust/commit/354a5cb250fe386075d33539a6c2e9a75d9d7fc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/354a5cb250fe386075d33539a6c2e9a75d9d7fc5/comments", "author": null, "committer": null, "parents": [{"sha": "e999e7b8b2e35a495d6b9630ab987c0703c6ab48", "url": "https://api.github.com/repos/rust-lang/rust/commits/e999e7b8b2e35a495d6b9630ab987c0703c6ab48", "html_url": "https://github.com/rust-lang/rust/commit/e999e7b8b2e35a495d6b9630ab987c0703c6ab48"}], "stats": {"total": 234, "additions": 154, "deletions": 80}, "files": [{"sha": "09c9cecdceee6ffa016aa62af12dfa598be33ae8", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/354a5cb250fe386075d33539a6c2e9a75d9d7fc5/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354a5cb250fe386075d33539a6c2e9a75d9d7fc5/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=354a5cb250fe386075d33539a6c2e9a75d9d7fc5", "patch": "@@ -96,7 +96,7 @@ impl Status {\n }\n \n impl<T> StatusAnd<T> {\n-    fn map<F: FnOnce(T) -> U, U>(self, f: F) -> StatusAnd<U> {\n+    pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> StatusAnd<U> {\n         StatusAnd {\n             status: self.status,\n             value: f(self.value),"}, {"sha": "ac0e4dde0c1024e95bbc2f3c91ad49e96a1423c3", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/354a5cb250fe386075d33539a6c2e9a75d9d7fc5/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354a5cb250fe386075d33539a6c2e9a75d9d7fc5/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=354a5cb250fe386075d33539a6c2e9a75d9d7fc5", "patch": "@@ -628,8 +628,6 @@ extern \"C\" {\n     pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n     pub fn LLVMRustConstInt128Get(ConstantVal: ValueRef, SExt: bool,\n                                   high: *mut u64, low: *mut u64) -> bool;\n-    pub fn LLVMRustIsConstantFP(ConstantVal: ValueRef) -> bool;\n-    pub fn LLVMRustConstFloatGetBits(ConstantVal: ValueRef) -> u64;\n \n \n     // Operations on composite constants"}, {"sha": "6573e507bd32554e26acd6398a9b7cde2d8c2a24", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 40, "deletions": 25, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/354a5cb250fe386075d33539a6c2e9a75d9d7fc5/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354a5cb250fe386075d33539a6c2e9a75d9d7fc5/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=354a5cb250fe386075d33539a6c2e9a75d9d7fc5", "patch": "@@ -21,7 +21,7 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::layout::{self, LayoutTyper};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::{Kind, Substs, Subst};\n-use rustc_apfloat::{ieee, Float};\n+use rustc_apfloat::{ieee, Float, Status};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use {adt, base, machine};\n use abi::{self, Abi};\n@@ -690,16 +690,18 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                     llvm::LLVMConstIntCast(llval, ll_t_out.to_ref(), s)\n                                 }\n                                 (CastTy::Int(_), CastTy::Float) => {\n-                                    const_cast_int_to_float(self.ccx, llval, signed, ll_t_out)\n+                                    cast_const_int_to_float(self.ccx, llval, signed, ll_t_out)\n                                 }\n                                 (CastTy::Float, CastTy::Float) => {\n                                     llvm::LLVMConstFPCast(llval, ll_t_out.to_ref())\n                                 }\n                                 (CastTy::Float, CastTy::Int(IntTy::I)) => {\n-                                    const_cast_from_float(&operand, true, ll_t_out)\n+                                    cast_const_float_to_int(self.ccx, &operand,\n+                                                            true, ll_t_out, span)\n                                 }\n                                 (CastTy::Float, CastTy::Int(_)) => {\n-                                    const_cast_from_float(&operand, false, ll_t_out)\n+                                    cast_const_float_to_int(self.ccx, &operand,\n+                                                            false, ll_t_out, span)\n                                 }\n                                 (CastTy::Ptr(_), CastTy::Ptr(_)) |\n                                 (CastTy::FnPtr, CastTy::Ptr(_)) |\n@@ -952,36 +954,49 @@ pub fn const_scalar_checked_binop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-unsafe fn const_cast_from_float(operand: &Const, signed: bool, int_ty: Type) -> ValueRef {\n+unsafe fn cast_const_float_to_int(ccx: &CrateContext,\n+                                  operand: &Const,\n+                                  signed: bool,\n+                                  int_ty: Type,\n+                                  span: Span) -> ValueRef {\n     let llval = operand.llval;\n-    // Note: this breaks if addresses can be turned into integers (is that possible?)\n-    // But at least an ICE is better than producing undef.\n-    assert!(llvm::LLVMRustIsConstantFP(llval),\n-            \"const_cast_from_float: invalid llval {:?}\", Value(llval));\n-    let bits = llvm::LLVMRustConstFloatGetBits(llval) as u128;\n-    let int_width = int_ty.int_width() as usize;\n     let float_bits = match operand.ty.sty {\n         ty::TyFloat(fty) => fty.bit_width(),\n-        _ => bug!(\"const_cast_from_float: operand not a float\"),\n+        _ => bug!(\"cast_const_float_to_int: operand not a float\"),\n     };\n-    // Ignore the Status, to_i128 does the Right Thing(tm) on overflow and NaN even though it\n-    // sets INVALID_OP.\n+    // Note: this breaks if llval is a complex constant expression rather than a simple constant.\n+    // One way that might happen would be if addresses could be turned into integers in constant\n+    // expressions, but that doesn't appear to be possible?\n+    // In any case, an ICE is better than producing undef.\n+    let llval_bits = consts::bitcast(llval, Type::ix(ccx, float_bits as u64));\n+    let bits = const_to_opt_u128(llval_bits, false).unwrap_or_else(|| {\n+        panic!(\"could not get bits of constant float {:?}\",\n+               Value(llval));\n+    });\n+    let int_width = int_ty.int_width() as usize;\n+    // Try to convert, but report an error for overflow and NaN. This matches HIR const eval.\n     let cast_result = match float_bits {\n-        32 if signed => ieee::Single::from_bits(bits).to_i128(int_width).value as u128,\n-        64 if signed => ieee::Double::from_bits(bits).to_i128(int_width).value as u128,\n-        32 => ieee::Single::from_bits(bits).to_u128(int_width).value,\n-        64 => ieee::Double::from_bits(bits).to_u128(int_width).value,\n+        32 if signed => ieee::Single::from_bits(bits).to_i128(int_width).map(|v| v as u128),\n+        64 if signed => ieee::Double::from_bits(bits).to_i128(int_width).map(|v| v as u128),\n+        32 => ieee::Single::from_bits(bits).to_u128(int_width),\n+        64 => ieee::Double::from_bits(bits).to_u128(int_width),\n         n => bug!(\"unsupported float width {}\", n),\n     };\n-    C_big_integral(int_ty, cast_result)\n+    if cast_result.status.contains(Status::INVALID_OP) {\n+        let err = ConstEvalErr { span: span, kind: ErrKind::CannotCast };\n+        err.report(ccx.tcx(), span, \"expression\");\n+    }\n+    C_big_integral(int_ty, cast_result.value)\n }\n \n-unsafe fn const_cast_int_to_float(ccx: &CrateContext,\n-                           llval: ValueRef,\n-                           signed: bool,\n-                           float_ty: Type) -> ValueRef {\n-    // Note: this breaks if addresses can be turned into integers (is that possible?)\n-    // But at least an ICE is better than producing undef.\n+unsafe fn cast_const_int_to_float(ccx: &CrateContext,\n+                                  llval: ValueRef,\n+                                  signed: bool,\n+                                  float_ty: Type) -> ValueRef {\n+    // Note: this breaks if llval is a complex constant expression rather than a simple constant.\n+    // One way that might happen would be if addresses could be turned into integers in constant\n+    // expressions, but that doesn't appear to be possible?\n+    // In any case, an ICE is better than producing undef.\n     let value = const_to_opt_u128(llval, signed).unwrap_or_else(|| {\n         panic!(\"could not get z128 value of constant integer {:?}\",\n                Value(llval));"}, {"sha": "20ea8d70302205f1084b7745ef24475b86e8c2c4", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/354a5cb250fe386075d33539a6c2e9a75d9d7fc5/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/354a5cb250fe386075d33539a6c2e9a75d9d7fc5/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=354a5cb250fe386075d33539a6c2e9a75d9d7fc5", "patch": "@@ -1373,19 +1373,6 @@ extern \"C\" bool LLVMRustConstInt128Get(LLVMValueRef CV, bool sext, uint64_t *hig\n     return true;\n }\n \n-extern \"C\" uint64_t LLVMRustConstFloatGetBits(LLVMValueRef CV) {\n-    auto C = unwrap<llvm::ConstantFP>(CV);\n-    APInt Bits = C->getValueAPF().bitcastToAPInt();\n-    if (!Bits.isIntN(64)) {\n-      report_fatal_error(\"Float bit pattern >64 bits\");\n-    }\n-    return Bits.getLimitedValue();\n-}\n-\n-extern \"C\" bool LLVMRustIsConstantFP(LLVMValueRef CV) {\n-  return isa<llvm::ConstantFP>(unwrap<llvm::Value>(CV));\n-}\n-\n extern \"C\" LLVMContextRef LLVMRustGetValueContext(LLVMValueRef V) {\n   return wrap(&unwrap(V)->getContext());\n }"}, {"sha": "2efefd926919fd6c885ce3264e60d59794af52a7", "filename": "src/test/compile-fail/float-int-invalid-const-cast.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/354a5cb250fe386075d33539a6c2e9a75d9d7fc5/src%2Ftest%2Fcompile-fail%2Ffloat-int-invalid-const-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354a5cb250fe386075d33539a6c2e9a75d9d7fc5/src%2Ftest%2Fcompile-fail%2Ffloat-int-invalid-const-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffloat-int-invalid-const-cast.rs?ref=354a5cb250fe386075d33539a6c2e9a75d9d7fc5", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(i128_type)]\n+#![allow(const_err)] // this test is only about hard errors\n+\n+use std::{f32, f64};\n+\n+// Forces evaluation of constants, triggering hard error\n+fn force<T>(_: T) {}\n+\n+fn main() {\n+    { const X: u16 = -1. as u16; force(X); } //~ ERROR constant evaluation error\n+    { const X: u128 = -100. as u128; force(X); } //~ ERROR constant evaluation error\n+\n+    { const X: i8 = f32::NAN as i8; force(X); } //~ ERROR constant evaluation error\n+    { const X: i32 = f32::NAN as i32; force(X); } //~ ERROR constant evaluation error\n+    { const X: u64 = f32::NAN as u64; force(X); } //~ ERROR constant evaluation error\n+    { const X: u128 = f32::NAN as u128; force(X); } //~ ERROR constant evaluation error\n+\n+    { const X: i8 = f32::INFINITY as i8; force(X); } //~ ERROR constant evaluation error\n+    { const X: u32 = f32::INFINITY as u32; force(X); } //~ ERROR constant evaluation error\n+    { const X: i128 = f32::INFINITY as i128; force(X); } //~ ERROR constant evaluation error\n+    { const X: u128 = f32::INFINITY as u128; force(X); } //~ ERROR constant evaluation error\n+\n+    { const X: u8 = f32::NEG_INFINITY as u8; force(X); } //~ ERROR constant evaluation error\n+    { const X: u16 = f32::NEG_INFINITY as u16; force(X); } //~ ERROR constant evaluation error\n+    { const X: i64 = f32::NEG_INFINITY as i64; force(X); } //~ ERROR constant evaluation error\n+    { const X: i128 = f32::NEG_INFINITY as i128; force(X); } //~ ERROR constant evaluation error\n+\n+    { const X: i8 = f64::NAN as i8; force(X); } //~ ERROR constant evaluation error\n+    { const X: i32 = f64::NAN as i32; force(X); } //~ ERROR constant evaluation error\n+    { const X: u64 = f64::NAN as u64; force(X); } //~ ERROR constant evaluation error\n+    { const X: u128 = f64::NAN as u128; force(X); } //~ ERROR constant evaluation error\n+\n+    { const X: i8 = f64::INFINITY as i8; force(X); } //~ ERROR constant evaluation error\n+    { const X: u32 = f64::INFINITY as u32; force(X); } //~ ERROR constant evaluation error\n+    { const X: i128 = f64::INFINITY as i128; force(X); } //~ ERROR constant evaluation error\n+    { const X: u128 = f64::INFINITY as u128; force(X); } //~ ERROR constant evaluation error\n+\n+    { const X: u8 = f64::NEG_INFINITY as u8; force(X); } //~ ERROR constant evaluation error\n+    { const X: u16 = f64::NEG_INFINITY as u16; force(X); } //~ ERROR constant evaluation error\n+    { const X: i64 = f64::NEG_INFINITY as i64; force(X); } //~ ERROR constant evaluation error\n+    { const X: i128 = f64::NEG_INFINITY as i128; force(X); } //~ ERROR constant evaluation error\n+\n+    { const X: u8 = 256. as u8; force(X); } //~ ERROR constant evaluation error\n+    { const X: i8 = -129. as i8; force(X); } //~ ERROR constant evaluation error\n+    { const X: i8 = 128. as i8; force(X); } //~ ERROR constant evaluation error\n+    { const X: i32 = 2147483648. as i32; force(X); } //~ ERROR constant evaluation error\n+    { const X: i32 = -2147483904. as i32; force(X); } //~ ERROR constant evaluation error\n+    { const X: u32 = 4294967296. as u32; force(X); } //~ ERROR constant evaluation error\n+    { const X: u128 = 1e40 as u128; force(X); } //~ ERROR constant evaluation error\n+    { const X: i128 = 1e40 as i128; force(X); } //~ ERROR constant evaluation error\n+}\n\\ No newline at end of file"}, {"sha": "1a30013c05d1e41a346e2594bc24c32db04c21cb", "filename": "src/test/run-pass/saturating-float-casts.rs", "status": "modified", "additions": 52, "deletions": 39, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/354a5cb250fe386075d33539a6c2e9a75d9d7fc5/src%2Ftest%2Frun-pass%2Fsaturating-float-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354a5cb250fe386075d33539a6c2e9a75d9d7fc5/src%2Ftest%2Frun-pass%2Fsaturating-float-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsaturating-float-casts.rs?ref=354a5cb250fe386075d33539a6c2e9a75d9d7fc5", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -22,15 +22,28 @@ macro_rules! test {\n     ($val:expr, $src_ty:ident -> $dest_ty:ident, $expected:expr) => (\n         // black_box disables constant evaluation to test run-time conversions:\n         assert_eq!(black_box::<$src_ty>($val) as $dest_ty, $expected,\n-                    \"run time {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n-        // ... whereas this variant triggers constant evaluation:\n+                    \"run-time {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n+    );\n+\n+    ($fval:expr, f* -> $ity:ident, $ival:expr) => (\n+        test!($fval, f32 -> $ity, $ival);\n+        test!($fval, f64 -> $ity, $ival);\n+    )\n+}\n+\n+// This macro tests const eval in addition to run-time evaluation.\n+// If and when saturating casts are adopted, this macro should be merged with test!() to ensure\n+// that run-time and const eval agree on inputs that currently trigger a const eval error.\n+macro_rules! test_c {\n+    ($val:expr, $src_ty:ident -> $dest_ty:ident, $expected:expr) => ({\n+        test!($val, $src_ty -> $dest_ty, $expected);\n         {\n             const X: $src_ty = $val;\n             const Y: $dest_ty = X as $dest_ty;\n             assert_eq!(Y, $expected,\n                         \"const eval {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n         }\n-    );\n+    });\n \n     ($fval:expr, f* -> $ity:ident, $ival:expr) => (\n         test!($fval, f32 -> $ity, $ival);\n@@ -48,11 +61,11 @@ macro_rules! common_fptoi_tests {\n         // as well, the test is just slightly misplaced.\n         test!($ity::MIN as $fty, $fty -> $ity, $ity::MIN);\n         test!($ity::MAX as $fty, $fty -> $ity, $ity::MAX);\n-        test!(0., $fty -> $ity, 0);\n-        test!($fty::MIN_POSITIVE, $fty -> $ity, 0);\n+        test_c!(0., $fty -> $ity, 0);\n+        test_c!($fty::MIN_POSITIVE, $fty -> $ity, 0);\n         test!(-0.9, $fty -> $ity, 0);\n-        test!(1., $fty -> $ity, 1);\n-        test!(42., $fty -> $ity, 42);\n+        test_c!(1., $fty -> $ity, 1);\n+        test_c!(42., $fty -> $ity, 42);\n     )+ });\n \n     (f* -> $($ity:ident)+) => ({\n@@ -84,58 +97,58 @@ pub fn main() {\n \n     // The following tests cover edge cases for some integer types.\n \n-    // u8\n-    test!(254., f* -> u8, 254);\n+    // # u8\n+    test_c!(254., f* -> u8, 254);\n     test!(256., f* -> u8, 255);\n \n-    // i8\n-    test!(-127., f* -> i8, -127);\n+    // # i8\n+    test_c!(-127., f* -> i8, -127);\n     test!(-129., f* -> i8, -128);\n-    test!(126., f* -> i8, 126);\n+    test_c!(126., f* -> i8, 126);\n     test!(128., f* -> i8, 127);\n \n-    // i32\n+    // # i32\n     // -2147483648. is i32::MIN (exactly)\n-    test!(-2147483648., f* -> i32, i32::MIN);\n+    test_c!(-2147483648., f* -> i32, i32::MIN);\n     // 2147483648. is i32::MAX rounded up\n     test!(2147483648., f32 -> i32, 2147483647);\n     // With 24 significand bits, floats with magnitude in [2^30 + 1, 2^31] are rounded to\n     // multiples of 2^7. Therefore, nextDown(round(i32::MAX)) is 2^31 - 128:\n-    test!(2147483520., f32 -> i32, 2147483520);\n+    test_c!(2147483520., f32 -> i32, 2147483520);\n     // Similarly, nextUp(i32::MIN) is i32::MIN + 2^8 and nextDown(i32::MIN) is i32::MIN - 2^7\n     test!(-2147483904., f* -> i32, i32::MIN);\n-    test!(-2147483520., f* -> i32, -2147483520);\n+    test_c!(-2147483520., f* -> i32, -2147483520);\n \n-    // u32 -- round(MAX) and nextUp(round(MAX))\n-    test!(4294967040., f* -> u32, 4294967040);\n+    // # u32\n+    // round(MAX) and nextUp(round(MAX))\n+    test_c!(4294967040., f* -> u32, 4294967040);\n     test!(4294967296., f* -> u32, 4294967295);\n \n-    // u128\n-    // # float->int\n-    test!(f32::MAX, f32 -> u128, 0xffffff00000000000000000000000000);\n+    // # u128\n+    // float->int:\n+    test_c!(f32::MAX, f32 -> u128, 0xffffff00000000000000000000000000);\n     // nextDown(f32::MAX) = 2^128 - 2 * 2^104\n     const SECOND_LARGEST_F32: f32 = 340282326356119256160033759537265639424.;\n-    test!(SECOND_LARGEST_F32, f32 -> u128, 0xfffffe00000000000000000000000000);\n-    // # int->float\n+    test_c!(SECOND_LARGEST_F32, f32 -> u128, 0xfffffe00000000000000000000000000);\n+\n+    // int->float:\n     // f32::MAX - 0.5 ULP and smaller should be rounded down\n-    test!(0xfffffe00000000000000000000000000, u128 -> f32, SECOND_LARGEST_F32);\n-    test!(0xfffffe7fffffffffffffffffffffffff, u128 -> f32, SECOND_LARGEST_F32);\n-    test!(0xfffffe80000000000000000000000000, u128 -> f32, SECOND_LARGEST_F32);\n+    test_c!(0xfffffe00000000000000000000000000, u128 -> f32, SECOND_LARGEST_F32);\n+    test_c!(0xfffffe7fffffffffffffffffffffffff, u128 -> f32, SECOND_LARGEST_F32);\n+    test_c!(0xfffffe80000000000000000000000000, u128 -> f32, SECOND_LARGEST_F32);\n     // numbers within < 0.5 ULP of f32::MAX it should be rounded to f32::MAX\n-    test!(0xfffffe80000000000000000000000001, u128 -> f32, f32::MAX);\n-    test!(0xfffffeffffffffffffffffffffffffff, u128 -> f32, f32::MAX);\n-    test!(0xffffff00000000000000000000000000, u128 -> f32, f32::MAX);\n-    test!(0xffffff00000000000000000000000001, u128 -> f32, f32::MAX);\n-    test!(0xffffff7fffffffffffffffffffffffff, u128 -> f32, f32::MAX);\n+    test_c!(0xfffffe80000000000000000000000001, u128 -> f32, f32::MAX);\n+    test_c!(0xfffffeffffffffffffffffffffffffff, u128 -> f32, f32::MAX);\n+    test_c!(0xffffff00000000000000000000000000, u128 -> f32, f32::MAX);\n+    test_c!(0xffffff00000000000000000000000001, u128 -> f32, f32::MAX);\n+    test_c!(0xffffff7fffffffffffffffffffffffff, u128 -> f32, f32::MAX);\n     // f32::MAX + 0.5 ULP and greater should be rounded to infinity\n-    test!(0xffffff80000000000000000000000000, u128 -> f32, f32::INFINITY);\n-    test!(0xffffff80000000f00000000000000000, u128 -> f32, f32::INFINITY);\n-    test!(0xffffff87ffffffffffffffff00000001, u128 -> f32, f32::INFINITY);\n-\n-    test!(!0, u128 -> f32, f32::INFINITY);\n+    test_c!(0xffffff80000000000000000000000000, u128 -> f32, f32::INFINITY);\n+    test_c!(0xffffff80000000f00000000000000000, u128 -> f32, f32::INFINITY);\n+    test_c!(0xffffff87ffffffffffffffff00000001, u128 -> f32, f32::INFINITY);\n \n     // u128->f64 should not be affected by the u128->f32 checks\n-    test!(0xffffff80000000000000000000000000, u128 -> f64,\n+    test_c!(0xffffff80000000000000000000000000, u128 -> f64,\n           340282356779733661637539395458142568448.0);\n-    test!(u128::MAX, u128 -> f64, 340282366920938463463374607431768211455.0);\n+    test_c!(u128::MAX, u128 -> f64, 340282366920938463463374607431768211455.0);\n }"}]}