{"sha": "0fade3a714f7a7f9bff5c11f9f37528d0ab168a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmYWRlM2E3MTRmN2E3ZjliZmY1YzExZjlmMzc1MjhkMGFiMTY4YTE=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-11-14T07:46:47Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-11-23T05:19:53Z"}, "message": "Introduce Mut<T> to libstd\n\nBased off of blake2-ppc's work in #9429.", "tree": {"sha": "1cb937b524ddb7c7bc223cab00ccea916ceaf131", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cb937b524ddb7c7bc223cab00ccea916ceaf131"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fade3a714f7a7f9bff5c11f9f37528d0ab168a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fade3a714f7a7f9bff5c11f9f37528d0ab168a1", "html_url": "https://github.com/rust-lang/rust/commit/0fade3a714f7a7f9bff5c11f9f37528d0ab168a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fade3a714f7a7f9bff5c11f9f37528d0ab168a1/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb279aa02a7ff2ed069791f60a5159d73c8ed993", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb279aa02a7ff2ed069791f60a5159d73c8ed993", "html_url": "https://github.com/rust-lang/rust/commit/fb279aa02a7ff2ed069791f60a5159d73c8ed993"}], "stats": {"total": 317, "additions": 317, "deletions": 0}, "files": [{"sha": "10887369b159f0e42be28290ed5a738e520ecbd7", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0fade3a714f7a7f9bff5c11f9f37528d0ab168a1/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fade3a714f7a7f9bff5c11f9f37528d0ab168a1/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0fade3a714f7a7f9bff5c11f9f37528d0ab168a1", "patch": "@@ -164,6 +164,7 @@ pub mod result;\n pub mod either;\n pub mod hashmap;\n pub mod cell;\n+pub mod mutable;\n pub mod trie;\n \n "}, {"sha": "63caa52d3af1d4d2b2d824df104a4bd442543b3a", "filename": "src/libstd/mutable.rs", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/0fade3a714f7a7f9bff5c11f9f37528d0ab168a1/src%2Flibstd%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fade3a714f7a7f9bff5c11f9f37528d0ab168a1/src%2Flibstd%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmutable.rs?ref=0fade3a714f7a7f9bff5c11f9f37528d0ab168a1", "patch": "@@ -0,0 +1,298 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A mutable memory location with dynamically checked borrow rules\n+\n+use prelude::*;\n+\n+use cast;\n+use util::NonCopyable;\n+\n+/// A mutable memory location with dynamically checked borrow rules\n+#[no_freeze]\n+pub struct Mut<T> {\n+    priv value: T,\n+    priv borrow: BorrowFlag,\n+    priv nc: NonCopyable\n+}\n+\n+// Values [1, MAX-1] represent the number of `Ref` active\n+// (will not outgrow its range since `uint` is the size of the address space)\n+type BorrowFlag = uint;\n+static UNUSED: BorrowFlag = 0;\n+static WRITING: BorrowFlag = -1;\n+\n+impl<T> Mut<T> {\n+    /// Create a new `Mut` containing `value`\n+    pub fn new(value: T) -> Mut<T> {\n+        Mut {\n+            value: value,\n+            borrow: UNUSED,\n+            nc: NonCopyable\n+        }\n+    }\n+\n+    /// Consumes the `Mut`, returning the wrapped value.\n+    pub fn unwrap(self) -> T {\n+        assert!(self.borrow == UNUSED);\n+        self.value\n+    }\n+\n+    unsafe fn as_mut<'a>(&'a self) -> &'a mut Mut<T> {\n+        cast::transmute_mut(self)\n+    }\n+\n+    /// Attempts to immutably borrow the wrapped value.\n+    ///\n+    /// The borrow lasts until the returned `Ref` exits scope. Multiple\n+    /// immutable borrows can be taken out at the same time.\n+    ///\n+    /// Returns `None` if the value is currently mutably borrowed.\n+    pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n+        match self.borrow {\n+            WRITING => None,\n+            _ => {\n+                unsafe { self.as_mut().borrow += 1; }\n+                Some(Ref { parent: self })\n+            }\n+        }\n+    }\n+\n+    /// Immutably borrows the wrapped value.\n+    ///\n+    /// The borrow lasts until the returned `Ref` exits scope. Multiple\n+    /// immutable borrows can be taken out at the same time.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value is currently mutably borrowed.\n+    pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n+        match self.try_borrow() {\n+            Some(ptr) => ptr,\n+            None => fail!(\"Mut<T> already mutably borrowed\")\n+        }\n+    }\n+\n+    /// Mutably borrows the wrapped value.\n+    ///\n+    /// The borrow lasts untile the returned `MutRef` exits scope. The value\n+    /// cannot be borrowed while this borrow is active.\n+    ///\n+    /// Returns `None` if the value is currently borrowed.\n+    pub fn try_borrow_mut<'a>(&'a self) -> Option<MutRef<'a, T>> {\n+        match self.borrow {\n+            UNUSED => unsafe {\n+                let mut_self = self.as_mut();\n+                mut_self.borrow = WRITING;\n+                Some(MutRef { parent: mut_self })\n+            },\n+            _ => None\n+        }\n+    }\n+\n+    /// Mutably borrows the wrapped value.\n+    ///\n+    /// The borrow lasts untile the returned `MutRef` exits scope. The value\n+    /// cannot be borrowed while this borrow is active.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value is currently borrowed.\n+    pub fn borrow_mut<'a>(&'a self) -> MutRef<'a, T> {\n+        match self.try_borrow_mut() {\n+            Some(ptr) => ptr,\n+            None => fail!(\"Mut<T> already borrowed\")\n+        }\n+    }\n+\n+    /// Immutably borrows the wrapped value and applies `blk` to it.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value is currently mutably borrowed.\n+    #[inline]\n+    pub fn map<U>(&self, blk: |&T| -> U) -> U {\n+        let ptr = self.borrow();\n+        blk(ptr.get())\n+    }\n+\n+    /// Mutably borrows the wrapped value and applies `blk` to it.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value is currently borrowed.\n+    #[inline]\n+    pub fn map_mut<U>(&self, blk: |&mut T| -> U) -> U {\n+        let mut ptr = self.borrow_mut();\n+        blk(ptr.get())\n+    }\n+}\n+\n+impl<T: Clone> Clone for Mut<T> {\n+    fn clone(&self) -> Mut<T> {\n+        let x = self.borrow();\n+        Mut::new(x.get().clone())\n+    }\n+}\n+\n+impl<T: DeepClone> DeepClone for Mut<T> {\n+    fn deep_clone(&self) -> Mut<T> {\n+        let x = self.borrow();\n+        Mut::new(x.get().deep_clone())\n+    }\n+}\n+\n+impl<T: Eq> Eq for Mut<T> {\n+    fn eq(&self, other: &Mut<T>) -> bool {\n+        let a = self.borrow();\n+        let b = other.borrow();\n+        a.get() == b.get()\n+    }\n+}\n+\n+/// Wraps a borrowed reference to a value in a `Mut` box.\n+pub struct Ref<'box, T> {\n+    priv parent: &'box Mut<T>\n+}\n+\n+#[unsafe_destructor]\n+impl<'box, T> Drop for Ref<'box, T> {\n+    fn drop(&mut self) {\n+        assert!(self.parent.borrow != WRITING && self.parent.borrow != UNUSED);\n+        unsafe { self.parent.as_mut().borrow -= 1; }\n+    }\n+}\n+\n+impl<'box, T> Ref<'box, T> {\n+    /// Retrieve an immutable reference to the stored value.\n+    #[inline]\n+    pub fn get<'a>(&'a self) -> &'a T {\n+        &self.parent.value\n+    }\n+}\n+\n+/// Wraps a mutable borrowed reference to a value in a `Mut` box.\n+pub struct MutRef<'box, T> {\n+    priv parent: &'box mut Mut<T>\n+}\n+\n+#[unsafe_destructor]\n+impl<'box, T> Drop for MutRef<'box, T> {\n+    fn drop(&mut self) {\n+        assert!(self.parent.borrow == WRITING);\n+        unsafe { self.parent.as_mut().borrow = UNUSED; }\n+    }\n+}\n+\n+impl<'box, T> MutRef<'box, T> {\n+    /// Retrieve a mutable reference to the stored value.\n+    #[inline]\n+    pub fn get<'a>(&'a mut self) -> &'a mut T {\n+        &mut self.parent.value\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn double_imm_borrow() {\n+        let x = Mut::new(0);\n+        let _b1 = x.borrow();\n+        x.borrow();\n+    }\n+\n+    #[test]\n+    fn no_mut_then_imm_borrow() {\n+        let x = Mut::new(0);\n+        let _b1 = x.borrow_mut();\n+        assert!(x.try_borrow().is_none());\n+    }\n+\n+    #[test]\n+    fn no_imm_then_borrow_mut() {\n+        let x = Mut::new(0);\n+        let _b1 = x.borrow();\n+        assert!(x.try_borrow_mut().is_none());\n+    }\n+\n+    #[test]\n+    fn no_double_borrow_mut() {\n+        let x = Mut::new(0);\n+        let _b1 = x.borrow_mut();\n+        assert!(x.try_borrow_mut().is_none());\n+    }\n+\n+    #[test]\n+    fn imm_release_borrow_mut() {\n+        let x = Mut::new(0);\n+        {\n+            let _b1 = x.borrow();\n+        }\n+        x.borrow_mut();\n+    }\n+\n+    #[test]\n+    fn mut_release_borrow_mut() {\n+        let x = Mut::new(0);\n+        {\n+            let _b1 = x.borrow_mut();\n+        }\n+        x.borrow();\n+    }\n+\n+    #[test]\n+    fn double_borrow_single_release_no_borrow_mut() {\n+        let x = Mut::new(0);\n+        let _b1 = x.borrow();\n+        {\n+            let _b2 = x.borrow();\n+        }\n+        assert!(x.try_borrow_mut().is_none());\n+    }\n+\n+    #[test]\n+    fn map_ok() {\n+        let x = Mut::new(0);\n+        assert_eq!(1, x.map(|x| *x+1));\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn mut_borrow_map() {\n+        let x = Mut::new(0);\n+        let _b1 = x.borrow_mut();\n+        x.map(|x| *x+1);\n+    }\n+\n+    #[test]\n+    fn borrow_map() {\n+        let x = Mut::new(0);\n+        let _b1 = x.borrow();\n+        assert_eq!(1, x.map(|x| *x+1));\n+    }\n+\n+    #[test]\n+    fn map_mut_ok() {\n+        let x = Mut::new(0);\n+        x.map_mut(|x| *x += 1);\n+        let b = x.borrow();\n+        assert_eq!(1, *b.get());\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn borrow_map_mut() {\n+        let x = Mut::new(0);\n+        let _b = x.borrow();\n+        x.map_mut(|x| *x += 1);\n+    }\n+}"}, {"sha": "9a9669cbb3bbdf79fe041e315da15aaa7e0993b9", "filename": "src/test/compile-fail/mut-not-freeze.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0fade3a714f7a7f9bff5c11f9f37528d0ab168a1/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fade3a714f7a7f9bff5c11f9f37528d0ab168a1/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs?ref=0fade3a714f7a7f9bff5c11f9f37528d0ab168a1", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mutable::Mut;\n+\n+fn f<T: Freeze>(_: T) {}\n+\n+fn main() {\n+    let x = Mut::new(0);\n+    f(x); //~ ERROR: which does not fulfill `Freeze`\n+}"}]}