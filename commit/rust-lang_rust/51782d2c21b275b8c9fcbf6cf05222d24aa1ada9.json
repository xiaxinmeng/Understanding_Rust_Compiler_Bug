{"sha": "51782d2c21b275b8c9fcbf6cf05222d24aa1ada9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNzgyZDJjMjFiMjc1YjhjOWZjYmY2Y2YwNTIyMmQyNGFhMWFkYTk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-16T23:12:47Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-16T23:13:04Z"}, "message": "rustc: Add a type fold mechanism to the typechecker", "tree": {"sha": "bd4239a03e343c4f88c520e425ba5df2686ca43f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd4239a03e343c4f88c520e425ba5df2686ca43f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51782d2c21b275b8c9fcbf6cf05222d24aa1ada9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51782d2c21b275b8c9fcbf6cf05222d24aa1ada9", "html_url": "https://github.com/rust-lang/rust/commit/51782d2c21b275b8c9fcbf6cf05222d24aa1ada9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51782d2c21b275b8c9fcbf6cf05222d24aa1ada9/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6c6e8679e2a04624be710c00828bd59d1f4cc3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6c6e8679e2a04624be710c00828bd59d1f4cc3b", "html_url": "https://github.com/rust-lang/rust/commit/a6c6e8679e2a04624be710c00828bd59d1f4cc3b"}], "stats": {"total": 146, "additions": 83, "deletions": 63}, "files": [{"sha": "26bb8871f86c466261961f361c1dd275ee8f2dab", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 83, "deletions": 63, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/51782d2c21b275b8c9fcbf6cf05222d24aa1ada9/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51782d2c21b275b8c9fcbf6cf05222d24aa1ada9/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=51782d2c21b275b8c9fcbf6cf05222d24aa1ada9", "patch": "@@ -261,75 +261,26 @@ fn ty_to_str(&@ty typ) -> str {\n \n // Replaces parameter types inside a type with type variables.\n fn generalize_ty(@crate_ctxt cx, @ty t) -> @ty {\n-    fn rewrap(@ty orig, &sty new) -> @ty {\n-        ret @rec(struct=new, mut=orig.mut, cname=orig.cname);\n-    }\n-\n-    fn recur(@crate_ctxt cx, @ty t,\n-             &hashmap[ast.def_id,@ty] ty_params_to_ty_vars) -> @ty {\n-        alt (t.struct) {\n-            case (ty_box(?subty)) {\n-                auto new_subty = recur(cx, subty, ty_params_to_ty_vars);\n-                ret rewrap(t, ty_box(new_subty));\n-            }\n-            case (ty_vec(?subty)) {\n-                auto new_subty = recur(cx, subty, ty_params_to_ty_vars);\n-                ret rewrap(t, ty_vec(new_subty));\n-            }\n-            case (ty_tup(?subtys)) {\n-                let vec[@ty] new_subtys = vec();\n-                for (@ty subty in subtys) {\n-                    new_subtys += vec(recur(cx, subty, ty_params_to_ty_vars));\n-                }\n-                ret rewrap(t, ty_tup(new_subtys));\n-            }\n-            case (ty_rec(?fields)) {\n-                let vec[field] new_fields = vec();\n-                for (field fld in fields) {\n-                    auto new_ty = recur(cx, fld.ty, ty_params_to_ty_vars);\n-                    new_fields += vec(rec(ident=fld.ident, ty=new_ty));\n-                }\n-                ret rewrap(t, ty_rec(new_fields));\n-            }\n-            case (ty_fn(?args, ?ret_ty)) {\n-                let vec[arg] new_args = vec();\n-                for (arg a in args) {\n-                    auto new_ty = recur(cx, a.ty, ty_params_to_ty_vars);\n-                    new_args += vec(rec(mode=a.mode, ty=new_ty));\n-                }\n-                auto new_ret_ty = recur(cx, ret_ty, ty_params_to_ty_vars);\n-                ret rewrap(t, ty_fn(new_args, new_ret_ty));\n-            }\n-            case (ty_obj(?methods)) {\n-                let vec[method] new_methods = vec();\n-                for (method m in methods) {\n-                    let vec[arg] new_args = vec();\n-                    for (arg a in m.inputs) {\n-                        auto new_ty = recur(cx, a.ty, ty_params_to_ty_vars);\n-                        new_args += vec(rec(mode=a.mode, ty=new_ty));\n+    state obj ty_generalizer(@crate_ctxt cx,\n+                             @hashmap[ast.def_id,@ty] ty_params_to_ty_vars) {\n+        fn fold_simple_ty(@ty t) -> @ty {\n+            alt (t.struct) {\n+                case (ty_param(?pid)) {\n+                    if (ty_params_to_ty_vars.contains_key(pid)) {\n+                        ret ty_params_to_ty_vars.get(pid);\n                     }\n-                    auto new_rty = recur(cx, m.output, ty_params_to_ty_vars);\n-                    new_methods += vec(rec(ident=m.ident, inputs=new_args,\n-                                           output=new_rty));\n-                }\n-                ret rewrap(t, ty_obj(new_methods));\n-            }\n-            case (ty_param(?pid)) {\n-                if (ty_params_to_ty_vars.contains_key(pid)) {\n-                    ret ty_params_to_ty_vars.get(pid);\n+                    auto var_ty = next_ty_var(cx);\n+                    ty_params_to_ty_vars.insert(pid, var_ty);\n+                    ret var_ty;\n                 }\n-                auto var_ty = next_ty_var(cx);\n-                ty_params_to_ty_vars.insert(pid, var_ty);\n-                ret var_ty;\n+                case (_) { /* fall through */ }\n             }\n-            case (_) { /* fall through */ }\n+            ret t;\n         }\n-\n-        ret t;\n     }\n \n-    auto ty_params_to_ty_vars = common.new_def_hash[@ty]();\n-    ret recur(cx, t, ty_params_to_ty_vars);\n+    auto generalizer = ty_generalizer(cx, @common.new_def_hash[@ty]());\n+    ret fold_ty(generalizer, t);\n }\n \n // Parses the programmer's textual representation of a type into our internal\n@@ -779,6 +730,75 @@ fn is_lval(@ast.expr expr) -> bool {\n     }\n }\n \n+// Type folds\n+\n+type ty_fold = state obj {\n+    fn fold_simple_ty(@ty ty) -> @ty;\n+};\n+\n+fn fold_ty(ty_fold fld, @ty t) -> @ty {\n+    fn rewrap(@ty orig, &sty new) -> @ty {\n+        ret @rec(struct=new, mut=orig.mut, cname=orig.cname);\n+    }\n+\n+    alt (t.struct) {\n+        case (ty_nil)           { ret fld.fold_simple_ty(t); }\n+        case (ty_bool)          { ret fld.fold_simple_ty(t); }\n+        case (ty_int)           { ret fld.fold_simple_ty(t); }\n+        case (ty_uint)          { ret fld.fold_simple_ty(t); }\n+        case (ty_machine(_))    { ret fld.fold_simple_ty(t); }\n+        case (ty_char)          { ret fld.fold_simple_ty(t); }\n+        case (ty_str)           { ret fld.fold_simple_ty(t); }\n+        case (ty_tag(_))        { ret fld.fold_simple_ty(t); }\n+        case (ty_box(?subty)) {\n+            ret rewrap(t, ty_box(fold_ty(fld, subty)));\n+        }\n+        case (ty_vec(?subty)) {\n+            ret rewrap(t, ty_vec(fold_ty(fld, subty)));\n+        }\n+        case (ty_tup(?subtys)) {\n+            let vec[@ty] new_subtys = vec();\n+            for (@ty subty in subtys) {\n+                new_subtys += vec(fold_ty(fld, subty));\n+            }\n+            ret rewrap(t, ty_tup(new_subtys));\n+        }\n+        case (ty_rec(?fields)) {\n+            let vec[field] new_fields = vec();\n+            for (field fl in fields) {\n+                auto new_ty = fold_ty(fld, fl.ty);\n+                new_fields += vec(rec(ident=fl.ident, ty=new_ty));\n+            }\n+            ret rewrap(t, ty_rec(new_fields));\n+        }\n+        case (ty_fn(?args, ?ret_ty)) {\n+            let vec[arg] new_args = vec();\n+            for (arg a in args) {\n+                auto new_ty = fold_ty(fld, a.ty);\n+                new_args += vec(rec(mode=a.mode, ty=new_ty));\n+            }\n+            ret rewrap(t, ty_fn(new_args, fold_ty(fld, ret_ty)));\n+        }\n+        case (ty_obj(?methods)) {\n+            let vec[method] new_methods = vec();\n+            for (method m in methods) {\n+                let vec[arg] new_args = vec();\n+                for (arg a in m.inputs) {\n+                    new_args += vec(rec(mode=a.mode, ty=fold_ty(fld, a.ty)));\n+                }\n+                new_methods += vec(rec(ident=m.ident, inputs=new_args,\n+                                       output=fold_ty(fld, m.output)));\n+            }\n+            ret rewrap(t, ty_obj(new_methods));\n+        }\n+        case (ty_var(_))        { ret fld.fold_simple_ty(t); }\n+        case (ty_local(_))      { ret fld.fold_simple_ty(t); }\n+        case (ty_param(_))      { ret fld.fold_simple_ty(t); }\n+    }\n+\n+    ret t;\n+}\n+\n // Type utilities\n \n // FIXME: remove me when == works on these tags."}]}