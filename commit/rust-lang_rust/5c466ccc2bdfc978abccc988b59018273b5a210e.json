{"sha": "5c466ccc2bdfc978abccc988b59018273b5a210e", "node_id": "C_kwDOAAsO6NoAKDVjNDY2Y2NjMmJkZmM5NzhhYmNjYzk4OGI1OTAxODI3M2I1YTIxMGU", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-06-01T13:04:38Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-06-01T13:04:38Z"}, "message": "Refactor out some crate wide data in DefMap into nested struct", "tree": {"sha": "f0b05b8b2c8f69ee104d6d589e75db49018b4469", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0b05b8b2c8f69ee104d6d589e75db49018b4469"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c466ccc2bdfc978abccc988b59018273b5a210e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c466ccc2bdfc978abccc988b59018273b5a210e", "html_url": "https://github.com/rust-lang/rust/commit/5c466ccc2bdfc978abccc988b59018273b5a210e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c466ccc2bdfc978abccc988b59018273b5a210e/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "html_url": "https://github.com/rust-lang/rust/commit/dc7c6d43c77c2edb549f574188da8aff4ac0fba4"}], "stats": {"total": 131, "additions": 73, "deletions": 58}, "files": [{"sha": "6e77744f21539f6e3d08c9c6149640b37261d14f", "filename": "crates/hir-def/src/body/tests/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c466ccc2bdfc978abccc988b59018273b5a210e/crates%2Fhir-def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c466ccc2bdfc978abccc988b59018273b5a210e/crates%2Fhir-def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Ftests%2Fblock.rs?ref=5c466ccc2bdfc978abccc988b59018273b5a210e", "patch": "@@ -148,8 +148,8 @@ fn f() {\n }\n     \"#,\n         expect![[r#\"\n-            BlockId(1) in ModuleId { krate: Idx::<CrateData>(0), block: Some(BlockId(0)), local_id: Idx::<ModuleData>(1) }\n-            BlockId(0) in ModuleId { krate: Idx::<CrateData>(0), block: None, local_id: Idx::<ModuleData>(0) }\n+            BlockId(1) in BlockRelativeModuleId { block: Some(BlockId(0)), local_id: Idx::<ModuleData>(1) }\n+            BlockId(0) in BlockRelativeModuleId { block: None, local_id: Idx::<ModuleData>(0) }\n             crate scope\n         \"#]],\n     );"}, {"sha": "86ba9052031c68faab05b93c2aac5a7964acd10a", "filename": "crates/hir-def/src/nameres.rs", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5c466ccc2bdfc978abccc988b59018273b5a210e/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c466ccc2bdfc978abccc988b59018273b5a210e/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=5c466ccc2bdfc978abccc988b59018273b5a210e", "patch": "@@ -109,14 +109,23 @@ pub struct DefMap {\n     /// this contains all kinds of macro, not just `macro_rules!` macro.\n     macro_use_prelude: FxHashMap<Name, MacroId>,\n \n+    /// Tracks which custom derives are in scope for an item, to allow resolution of derive helper\n+    /// attributes.\n+    derive_helpers_in_scope: FxHashMap<AstId<ast::Item>, Vec<(Name, MacroId, MacroCallId)>>,\n+\n+    diagnostics: Vec<DefDiagnostic>,\n+\n+    // FIXME: Arc this so we can share it with block def maps\n+    data: CrateData,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+struct CrateData {\n     /// Side table for resolving derive helpers.\n     exported_derives: FxHashMap<MacroDefId, Box<[Name]>>,\n     fn_proc_macro_mapping: FxHashMap<FunctionId, ProcMacroId>,\n     /// The error that occurred when failing to load the proc-macro dll.\n     proc_macro_loading_error: Option<Box<str>>,\n-    /// Tracks which custom derives are in scope for an item, to allow resolution of derive helper\n-    /// attributes.\n-    derive_helpers_in_scope: FxHashMap<AstId<ast::Item>, Vec<(Name, MacroId, MacroCallId)>>,\n \n     /// Custom attributes registered with `#![register_attr]`.\n     registered_attrs: Vec<SmolStr>,\n@@ -131,7 +140,6 @@ pub struct DefMap {\n \n     edition: Edition,\n     recursion_limit: Option<u32>,\n-    diagnostics: Vec<DefDiagnostic>,\n }\n \n /// For `DefMap`s computed for a block expression, this stores its location in the parent map.\n@@ -278,7 +286,7 @@ impl DefMap {\n         let module_data =\n             ModuleData::new(ModuleOrigin::BlockExpr { block: block.ast_id }, visibility);\n \n-        let mut def_map = DefMap::empty(krate, parent_map.edition, module_data);\n+        let mut def_map = DefMap::empty(krate, parent_map.data.edition, module_data);\n         def_map.block = Some(BlockInfo {\n             block: block_id,\n             parent: BlockRelativeModuleId {\n@@ -300,23 +308,25 @@ impl DefMap {\n             _c: Count::new(),\n             block: None,\n             krate,\n-            edition,\n-            recursion_limit: None,\n             extern_prelude: FxHashMap::default(),\n             macro_use_prelude: FxHashMap::default(),\n-            exported_derives: FxHashMap::default(),\n-            fn_proc_macro_mapping: FxHashMap::default(),\n-            proc_macro_loading_error: None,\n             derive_helpers_in_scope: FxHashMap::default(),\n             prelude: None,\n             modules,\n-            registered_attrs: Vec::new(),\n-            registered_tools: Vec::new(),\n-            unstable_features: FxHashSet::default(),\n             diagnostics: Vec::new(),\n-            rustc_coherence_is_core: false,\n-            no_core: false,\n-            no_std: false,\n+            data: CrateData {\n+                recursion_limit: None,\n+                exported_derives: FxHashMap::default(),\n+                fn_proc_macro_mapping: FxHashMap::default(),\n+                proc_macro_loading_error: None,\n+                registered_attrs: Vec::new(),\n+                registered_tools: Vec::new(),\n+                unstable_features: FxHashSet::default(),\n+                rustc_coherence_is_core: false,\n+                no_core: false,\n+                no_std: false,\n+                edition,\n+            },\n         }\n     }\n \n@@ -339,31 +349,31 @@ impl DefMap {\n     }\n \n     pub fn registered_tools(&self) -> &[SmolStr] {\n-        &self.registered_tools\n+        &self.data.registered_tools\n     }\n \n     pub fn registered_attrs(&self) -> &[SmolStr] {\n-        &self.registered_attrs\n+        &self.data.registered_attrs\n     }\n \n     pub fn is_unstable_feature_enabled(&self, feature: &str) -> bool {\n-        self.unstable_features.contains(feature)\n+        self.data.unstable_features.contains(feature)\n     }\n \n     pub fn is_rustc_coherence_is_core(&self) -> bool {\n-        self.rustc_coherence_is_core\n+        self.data.rustc_coherence_is_core\n     }\n \n     pub fn is_no_std(&self) -> bool {\n-        self.no_std || self.no_core\n+        self.data.no_std || self.data.no_core\n     }\n \n     pub fn fn_as_proc_macro(&self, id: FunctionId) -> Option<ProcMacroId> {\n-        self.fn_proc_macro_mapping.get(&id).copied()\n+        self.data.fn_proc_macro_mapping.get(&id).copied()\n     }\n \n     pub fn proc_macro_loading_error(&self) -> Option<&str> {\n-        self.proc_macro_loading_error.as_deref()\n+        self.data.proc_macro_loading_error.as_deref()\n     }\n \n     pub fn krate(&self) -> CrateId {\n@@ -540,25 +550,28 @@ impl DefMap {\n         // Exhaustive match to require handling new fields.\n         let Self {\n             _c: _,\n-            exported_derives,\n             extern_prelude,\n             macro_use_prelude,\n             diagnostics,\n             modules,\n-            registered_attrs,\n-            registered_tools,\n-            fn_proc_macro_mapping,\n             derive_helpers_in_scope,\n-            unstable_features,\n-            proc_macro_loading_error: _,\n             block: _,\n-            edition: _,\n-            recursion_limit: _,\n             krate: _,\n             prelude: _,\n-            rustc_coherence_is_core: _,\n-            no_core: _,\n-            no_std: _,\n+            data:\n+                CrateData {\n+                    exported_derives,\n+                    fn_proc_macro_mapping,\n+                    registered_attrs,\n+                    registered_tools,\n+                    unstable_features,\n+                    proc_macro_loading_error: _,\n+                    rustc_coherence_is_core: _,\n+                    no_core: _,\n+                    no_std: _,\n+                    edition: _,\n+                    recursion_limit: _,\n+                },\n         } = self;\n \n         extern_prelude.shrink_to_fit();\n@@ -583,7 +596,7 @@ impl DefMap {\n     }\n \n     pub fn recursion_limit(&self) -> Option<u32> {\n-        self.recursion_limit\n+        self.data.recursion_limit\n     }\n }\n "}, {"sha": "a7abf445918aa4147965f1039b7a873f7823ac94", "filename": "crates/hir-def/src/nameres/attr_resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c466ccc2bdfc978abccc988b59018273b5a210e/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c466ccc2bdfc978abccc988b59018273b5a210e/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs?ref=5c466ccc2bdfc978abccc988b59018273b5a210e", "patch": "@@ -78,15 +78,15 @@ impl DefMap {\n             let name = name.to_smol_str();\n             let pred = |n: &_| *n == name;\n \n-            let registered = self.registered_tools.iter().map(SmolStr::as_str);\n+            let registered = self.data.registered_tools.iter().map(SmolStr::as_str);\n             let is_tool = TOOL_MODULES.iter().copied().chain(registered).any(pred);\n             // FIXME: tool modules can be shadowed by actual modules\n             if is_tool {\n                 return true;\n             }\n \n             if segments.len() == 1 {\n-                let mut registered = self.registered_attrs.iter().map(SmolStr::as_str);\n+                let mut registered = self.data.registered_attrs.iter().map(SmolStr::as_str);\n                 let is_inert = find_builtin_attr_idx(&name).is_some() || registered.any(pred);\n                 return is_inert;\n             }"}, {"sha": "53e12733412d1928163743e6e37c7289efa9e317", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5c466ccc2bdfc978abccc988b59018273b5a210e/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c466ccc2bdfc978abccc988b59018273b5a210e/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=5c466ccc2bdfc978abccc988b59018273b5a210e", "patch": "@@ -98,11 +98,11 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n                     .collect()\n             }\n             Some(Err(e)) => {\n-                def_map.proc_macro_loading_error = Some(e.clone().into_boxed_str());\n+                def_map.data.proc_macro_loading_error = Some(e.clone().into_boxed_str());\n                 Vec::new()\n             }\n             None => {\n-                def_map.proc_macro_loading_error =\n+                def_map.data.proc_macro_loading_error =\n                     Some(\"No proc-macros present for crate\".to_owned().into_boxed_str());\n                 Vec::new()\n             }\n@@ -306,7 +306,7 @@ impl DefCollector<'_> {\n             if *attr_name == hir_expand::name![recursion_limit] {\n                 if let Some(limit) = attr.string_value() {\n                     if let Ok(limit) = limit.parse() {\n-                        self.def_map.recursion_limit = Some(limit);\n+                        self.def_map.data.recursion_limit = Some(limit);\n                     }\n                 }\n                 continue;\n@@ -320,17 +320,17 @@ impl DefCollector<'_> {\n             }\n \n             if *attr_name == hir_expand::name![no_core] {\n-                self.def_map.no_core = true;\n+                self.def_map.data.no_core = true;\n                 continue;\n             }\n \n             if *attr_name == hir_expand::name![no_std] {\n-                self.def_map.no_std = true;\n+                self.def_map.data.no_std = true;\n                 continue;\n             }\n \n             if attr_name.as_text().as_deref() == Some(\"rustc_coherence_is_core\") {\n-                self.def_map.rustc_coherence_is_core = true;\n+                self.def_map.data.rustc_coherence_is_core = true;\n                 continue;\n             }\n \n@@ -344,7 +344,7 @@ impl DefCollector<'_> {\n                         [name] => Some(name.to_smol_str()),\n                         _ => None,\n                     });\n-                self.def_map.unstable_features.extend(features);\n+                self.def_map.data.unstable_features.extend(features);\n             }\n \n             let attr_is_register_like = *attr_name == hir_expand::name![register_attr]\n@@ -359,10 +359,10 @@ impl DefCollector<'_> {\n             };\n \n             if *attr_name == hir_expand::name![register_attr] {\n-                self.def_map.registered_attrs.push(registered_name.to_smol_str());\n+                self.def_map.data.registered_attrs.push(registered_name.to_smol_str());\n                 cov_mark::hit!(register_attr);\n             } else {\n-                self.def_map.registered_tools.push(registered_name.to_smol_str());\n+                self.def_map.data.registered_tools.push(registered_name.to_smol_str());\n                 cov_mark::hit!(register_tool);\n             }\n         }\n@@ -530,12 +530,12 @@ impl DefCollector<'_> {\n     fn inject_prelude(&mut self) {\n         // See compiler/rustc_builtin_macros/src/standard_library_imports.rs\n \n-        if self.def_map.no_core {\n+        if self.def_map.data.no_core {\n             // libcore does not get a prelude.\n             return;\n         }\n \n-        let krate = if self.def_map.no_std {\n+        let krate = if self.def_map.data.no_std {\n             name![core]\n         } else {\n             let std = name![std];\n@@ -548,13 +548,13 @@ impl DefCollector<'_> {\n             }\n         };\n \n-        let edition = match self.def_map.edition {\n+        let edition = match self.def_map.data.edition {\n             Edition::Edition2015 => name![rust_2015],\n             Edition::Edition2018 => name![rust_2018],\n             Edition::Edition2021 => name![rust_2021],\n         };\n \n-        let path_kind = match self.def_map.edition {\n+        let path_kind = match self.def_map.data.edition {\n             Edition::Edition2015 => PathKind::Plain,\n             _ => PathKind::Abs,\n         };\n@@ -611,10 +611,11 @@ impl DefCollector<'_> {\n         self.define_proc_macro(def.name.clone(), proc_macro_id);\n         if let ProcMacroKind::CustomDerive { helpers } = def.kind {\n             self.def_map\n+                .data\n                 .exported_derives\n                 .insert(macro_id_to_def_id(self.db, proc_macro_id.into()), helpers);\n         }\n-        self.def_map.fn_proc_macro_mapping.insert(fn_id, proc_macro_id);\n+        self.def_map.data.fn_proc_macro_mapping.insert(fn_id, proc_macro_id);\n     }\n \n     /// Define a macro with `macro_rules`.\n@@ -773,7 +774,7 @@ impl DefCollector<'_> {\n     fn resolve_import(&self, module_id: LocalModuleId, import: &Import) -> PartialResolvedImport {\n         let _p = profile::span(\"resolve_import\")\n             .detail(|| format!(\"{}\", import.path.display(self.db.upcast())));\n-        tracing::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.edition);\n+        tracing::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.data.edition);\n         if import.is_extern_crate {\n             let name = import\n                 .path\n@@ -1153,7 +1154,7 @@ impl DefCollector<'_> {\n                         // Record its helper attributes.\n                         if def_id.krate != self.def_map.krate {\n                             let def_map = self.db.crate_def_map(def_id.krate);\n-                            if let Some(helpers) = def_map.exported_derives.get(&def_id) {\n+                            if let Some(helpers) = def_map.data.exported_derives.get(&def_id) {\n                                 self.def_map\n                                     .derive_helpers_in_scope\n                                     .entry(ast_id.ast_id.map(|it| it.upcast()))\n@@ -2166,6 +2167,7 @@ impl ModCollector<'_, '_> {\n         if let Some(helpers) = helpers_opt {\n             self.def_collector\n                 .def_map\n+                .data\n                 .exported_derives\n                 .insert(macro_id_to_def_id(self.def_collector.db, macro_id.into()), helpers);\n         }"}, {"sha": "bfba6eab6dfe99701d44fb6dab3a663d20c82a79", "filename": "crates/hir-def/src/nameres/path_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c466ccc2bdfc978abccc988b59018273b5a210e/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c466ccc2bdfc978abccc988b59018273b5a210e/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=5c466ccc2bdfc978abccc988b59018273b5a210e", "patch": "@@ -218,7 +218,7 @@ impl DefMap {\n             // rust-lang/rust#57745)\n             // FIXME there must be a nicer way to write this condition\n             PathKind::Plain | PathKind::Abs\n-                if self.edition == Edition::Edition2015\n+                if self.data.edition == Edition::Edition2015\n                     && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n             {\n                 let (_, segment) = match segments.next() {"}, {"sha": "f4cca8d68d0ac71ac3ddf7d7f21209b2be6c9367", "filename": "crates/hir-def/src/nameres/tests/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c466ccc2bdfc978abccc988b59018273b5a210e/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c466ccc2bdfc978abccc988b59018273b5a210e/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=5c466ccc2bdfc978abccc988b59018273b5a210e", "patch": "@@ -1094,8 +1094,8 @@ pub fn derive_macro_2(_item: TokenStream) -> TokenStream {\n     let krate = db.crate_graph().iter().next().unwrap();\n     let def_map = db.crate_def_map(krate);\n \n-    assert_eq!(def_map.exported_derives.len(), 1);\n-    match def_map.exported_derives.values().next() {\n+    assert_eq!(def_map.data.exported_derives.len(), 1);\n+    match def_map.data.exported_derives.values().next() {\n         Some(helpers) => match &**helpers {\n             [attr] => assert_eq!(attr.display(&db).to_string(), \"helper_attr\"),\n             _ => unreachable!(),"}]}