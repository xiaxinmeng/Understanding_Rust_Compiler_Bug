{"sha": "377b0900aede976b2d37a499bbd7b62c2e39b358", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3N2IwOTAwYWVkZTk3NmIyZDM3YTQ5OWJiZDdiNjJjMmUzOWIzNTg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-05-27T08:18:36Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-05-27T08:19:03Z"}, "message": "Use `const fn` to abstract away the contents of UnsafeCell & friends.", "tree": {"sha": "b4a5a4431d36ed1a4e0a39c7d2ef2563ecac9bf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4a5a4431d36ed1a4e0a39c7d2ef2563ecac9bf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/377b0900aede976b2d37a499bbd7b62c2e39b358", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/377b0900aede976b2d37a499bbd7b62c2e39b358", "html_url": "https://github.com/rust-lang/rust/commit/377b0900aede976b2d37a499bbd7b62c2e39b358", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/377b0900aede976b2d37a499bbd7b62c2e39b358/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "html_url": "https://github.com/rust-lang/rust/commit/6e8e4f847c2ea02fec021ea15dfb2de6beac797a"}], "stats": {"total": 942, "additions": 417, "deletions": 525}, "files": [{"sha": "b4d3d0b1a22815d75000a21ceeff7ee5ac45ad58", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -399,7 +399,7 @@ fn test_map_in_place_zero_sized() {\n \n #[test]\n fn test_map_in_place_zero_drop_count() {\n-    use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n \n     #[derive(Clone, PartialEq, Debug)]\n     struct Nothing;\n@@ -413,7 +413,7 @@ fn test_map_in_place_zero_drop_count() {\n         }\n     }\n     const NUM_ELEMENTS: usize = 2;\n-    static DROP_COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n+    static DROP_COUNTER: AtomicUsize = AtomicUsize::new(0);\n \n     let v = repeat(Nothing).take(NUM_ELEMENTS).collect::<Vec<_>>();\n "}, {"sha": "56b459f5f17d809915d45bc9f1a3a3e6de1b756e", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -76,7 +76,6 @@ use marker::Sync;\n \n use intrinsics;\n use cell::UnsafeCell;\n-use marker::PhantomData;\n \n use default::Default;\n \n@@ -87,8 +86,8 @@ pub struct AtomicBool {\n }\n \n impl Default for AtomicBool {\n-    fn default() -> AtomicBool {\n-        ATOMIC_BOOL_INIT\n+    fn default() -> Self {\n+        Self::new(Default::default())\n     }\n }\n \n@@ -101,8 +100,8 @@ pub struct AtomicIsize {\n }\n \n impl Default for AtomicIsize {\n-    fn default() -> AtomicIsize {\n-        ATOMIC_ISIZE_INIT\n+    fn default() -> Self {\n+        Self::new(Default::default())\n     }\n }\n \n@@ -115,8 +114,8 @@ pub struct AtomicUsize {\n }\n \n impl Default for AtomicUsize {\n-    fn default() -> AtomicUsize {\n-        ATOMIC_USIZE_INIT\n+    fn default() -> Self {\n+        Self::new(Default::default())\n     }\n }\n \n@@ -125,8 +124,7 @@ unsafe impl Sync for AtomicUsize {}\n /// A raw pointer type which can be safely shared between threads.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicPtr<T> {\n-    p: UnsafeCell<usize>,\n-    _marker: PhantomData<*mut T>,\n+    p: UnsafeCell<*mut T>,\n }\n \n impl<T> Default for AtomicPtr<T> {\n@@ -175,16 +173,13 @@ pub enum Ordering {\n \n /// An `AtomicBool` initialized to `false`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const ATOMIC_BOOL_INIT: AtomicBool =\n-        AtomicBool { v: UnsafeCell { value: 0 } };\n+pub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n /// An `AtomicIsize` initialized to `0`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const ATOMIC_ISIZE_INIT: AtomicIsize =\n-        AtomicIsize { v: UnsafeCell { value: 0 } };\n+pub const ATOMIC_ISIZE_INIT: AtomicIsize = AtomicIsize::new(0);\n /// An `AtomicUsize` initialized to `0`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const ATOMIC_USIZE_INIT: AtomicUsize =\n-        AtomicUsize { v: UnsafeCell { value: 0, } };\n+pub const ATOMIC_USIZE_INIT: AtomicUsize = AtomicUsize::new(0);\n \n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n const UINT_TRUE: usize = !0;\n@@ -202,9 +197,8 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(v: bool) -> AtomicBool {\n-        let val = if v { UINT_TRUE } else { 0 };\n-        AtomicBool { v: UnsafeCell::new(val) }\n+    pub const fn new(v: bool) -> AtomicBool {\n+        AtomicBool { v: UnsafeCell::new(-(v as isize) as usize) }\n     }\n \n     /// Loads a value from the bool.\n@@ -445,7 +439,7 @@ impl AtomicIsize {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(v: isize) -> AtomicIsize {\n+    pub const fn new(v: isize) -> AtomicIsize {\n         AtomicIsize {v: UnsafeCell::new(v)}\n     }\n \n@@ -633,7 +627,7 @@ impl AtomicUsize {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(v: usize) -> AtomicUsize {\n+    pub const fn new(v: usize) -> AtomicUsize {\n         AtomicUsize { v: UnsafeCell::new(v) }\n     }\n \n@@ -821,9 +815,8 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(p: *mut T) -> AtomicPtr<T> {\n-        AtomicPtr { p: UnsafeCell::new(p as usize),\n-                    _marker: PhantomData }\n+    pub const fn new(p: *mut T) -> AtomicPtr<T> {\n+        AtomicPtr { p: UnsafeCell::new(p) }\n     }\n \n     /// Loads a value from the pointer.\n@@ -848,7 +841,7 @@ impl<T> AtomicPtr<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe {\n-            atomic_load(self.p.get(), order) as *mut T\n+            atomic_load(self.p.get() as *mut usize, order) as *mut T\n         }\n     }\n \n@@ -875,7 +868,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n-        unsafe { atomic_store(self.p.get(), ptr as usize, order); }\n+        unsafe { atomic_store(self.p.get() as *mut usize, ptr as usize, order); }\n     }\n \n     /// Stores a value into the pointer, returning the old value.\n@@ -897,7 +890,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n-        unsafe { atomic_swap(self.p.get(), ptr as usize, order) as *mut T }\n+        unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n     }\n \n     /// Stores a value into the pointer if the current value is the same as the expected value.\n@@ -925,7 +918,7 @@ impl<T> AtomicPtr<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n-            atomic_compare_and_swap(self.p.get(), old as usize,\n+            atomic_compare_and_swap(self.p.get() as *mut usize, old as usize,\n                                     new as usize, order) as *mut T\n         }\n     }"}, {"sha": "c83421d3067cd0579e1dbfbf6efeffc2015bc2a1", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -170,7 +170,7 @@ impl<T:Copy> Cell<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn new(value: T) -> Cell<T> {\n+    pub const fn new(value: T) -> Cell<T> {\n         Cell {\n             value: UnsafeCell::new(value),\n         }\n@@ -302,7 +302,7 @@ impl<T> RefCell<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn new(value: T) -> RefCell<T> {\n+    pub const fn new(value: T) -> RefCell<T> {\n         RefCell {\n             value: UnsafeCell::new(value),\n             borrow: Cell::new(UNUSED),\n@@ -663,7 +663,7 @@ impl<T> UnsafeCell<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn new(value: T) -> UnsafeCell<T> {\n+    pub const fn new(value: T) -> UnsafeCell<T> {\n         UnsafeCell { value: value }\n     }\n "}, {"sha": "9dfaec0095a5a6e648799f7ceae90c9826aecd3d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -74,6 +74,7 @@\n #![feature(concat_idents)]\n #![feature(reflect)]\n #![feature(custom_attribute)]\n+#![feature(const_fn)]\n \n #[macro_use]\n mod macros;"}, {"sha": "c50f18c235233ff57dfd2e5b897c657b7dbd7412", "filename": "src/libcoretest/atomic.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibcoretest%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibcoretest%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fatomic.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -70,13 +70,15 @@ fn int_xor() {\n     assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n }\n \n-static S_BOOL : AtomicBool = ATOMIC_BOOL_INIT;\n-static S_INT  : AtomicIsize  = ATOMIC_ISIZE_INIT;\n-static S_UINT : AtomicUsize = ATOMIC_USIZE_INIT;\n+static S_FALSE: AtomicBool = AtomicBool::new(false);\n+static S_TRUE: AtomicBool = AtomicBool::new(true);\n+static S_INT: AtomicIsize  = AtomicIsize::new(0);\n+static S_UINT: AtomicUsize = AtomicUsize::new(0);\n \n #[test]\n fn static_init() {\n-    assert!(!S_BOOL.load(SeqCst));\n+    assert!(!S_FALSE.load(SeqCst));\n+    assert!(S_TRUE.load(SeqCst));\n     assert!(S_INT.load(SeqCst) == 0);\n     assert!(S_UINT.load(SeqCst) == 0);\n }"}, {"sha": "4c92162b2d6dcc34546a1bd5a95221588c0362f3", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -184,7 +184,7 @@ use std::mem;\n use std::env;\n use std::rt;\n use std::slice;\n-use std::sync::{Once, ONCE_INIT, StaticMutex, MUTEX_INIT};\n+use std::sync::{Once, StaticMutex};\n \n use directive::LOG_LEVEL_NAMES;\n \n@@ -200,7 +200,7 @@ pub const MAX_LOG_LEVEL: u32 = 255;\n /// The default logging level of a crate if no other is specified.\n const DEFAULT_LOG_LEVEL: u32 = 1;\n \n-static LOCK: StaticMutex = MUTEX_INIT;\n+static LOCK: StaticMutex = StaticMutex::new();\n \n /// An unsafe constant that is the maximum logging level of any module\n /// specified. This is the first line of defense to determining whether a\n@@ -367,7 +367,7 @@ pub struct LogLocation {\n /// module's log statement should be emitted or not.\n #[doc(hidden)]\n pub fn mod_enabled(level: u32, module: &str) -> bool {\n-    static INIT: Once = ONCE_INIT;\n+    static INIT: Once = Once::new();\n     INIT.call_once(init);\n \n     // It's possible for many threads are in this function, only one of them"}, {"sha": "5a06a5193bf1c16c6fcd5a8ea6ef156730c19359", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -32,7 +32,7 @@ use std::env;\n use std::fs::File;\n use std::io;\n use std::io::prelude::*;\n-use std::sync::atomic::{AtomicBool, Ordering, ATOMIC_BOOL_INIT};\n+use std::sync::atomic::{AtomicBool, Ordering};\n use syntax::ast;\n \n fn print_help_message() {\n@@ -76,7 +76,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     let output_path = {\n         let output_template = match requested_output {\n             Ok(ref s) if &**s == \"help\" => {\n-                static PRINTED_YET: AtomicBool = ATOMIC_BOOL_INIT;\n+                static PRINTED_YET: AtomicBool = AtomicBool::new(false);\n                 if !PRINTED_YET.load(Ordering::SeqCst) {\n                     print_help_message();\n                     PRINTED_YET.store(true, Ordering::SeqCst);"}, {"sha": "bd16e018bc465462acd42e6dc73ccd7e230441d8", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -1005,8 +1005,8 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n }\n \n unsafe fn configure_llvm(sess: &Session) {\n-    use std::sync::{Once, ONCE_INIT};\n-    static INIT: Once = ONCE_INIT;\n+    use std::sync::Once;\n+    static INIT: Once = Once::new();\n \n     // Copy what clang does by turning on loop vectorization at O2 and\n     // slp vectorization at O3"}, {"sha": "8866e7ff19dccd3247651816d5c2c9ba06b7d11d", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -39,6 +39,7 @@\n #![feature(path_ext)]\n #![feature(fs)]\n #![feature(path_relative_from)]\n+#![feature(std_misc)]\n \n #![allow(trivial_casts)]\n "}, {"sha": "c3f614c8cc06ac3e34472f9a56eb8d4e20926ca2", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -2653,8 +2653,8 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n \n     // Before we touch LLVM, make sure that multithreading is enabled.\n     unsafe {\n-        use std::sync::{Once, ONCE_INIT};\n-        static INIT: Once = ONCE_INIT;\n+        use std::sync::Once;\n+        static INIT: Once = Once::new();\n         static mut POISONED: bool = false;\n         INIT.call_once(|| {\n             if llvm::LLVMStartMultithreaded() != 1 {"}, {"sha": "ebdc049bc7f5daffec0a94874e201c69e92cd381", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -211,8 +211,8 @@ mod dl {\n     pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where\n         F: FnOnce() -> T,\n     {\n-        use sync::{StaticMutex, MUTEX_INIT};\n-        static LOCK: StaticMutex = MUTEX_INIT;\n+        use sync::StaticMutex;\n+        static LOCK: StaticMutex = StaticMutex::new();\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n             // sequence"}, {"sha": "0b9c659ea2e5bbe13c605aaccb507713c63b7f70", "filename": "src/libstd/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -23,8 +23,8 @@ use ffi::{OsStr, OsString};\n use fmt;\n use io;\n use path::{Path, PathBuf};\n-use sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT, Ordering};\n-use sync::{StaticMutex, MUTEX_INIT};\n+use sync::atomic::{AtomicIsize, Ordering};\n+use sync::StaticMutex;\n use sys::os as os_imp;\n \n /// Returns the current working directory as a `PathBuf`.\n@@ -70,7 +70,7 @@ pub fn set_current_dir<P: AsRef<Path>>(p: P) -> io::Result<()> {\n     os_imp::chdir(p.as_ref())\n }\n \n-static ENV_LOCK: StaticMutex = MUTEX_INIT;\n+static ENV_LOCK: StaticMutex = StaticMutex::new();\n \n /// An iterator over a snapshot of the environment variables of this process.\n ///\n@@ -475,7 +475,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     os_imp::current_exe()\n }\n \n-static EXIT_STATUS: AtomicIsize = ATOMIC_ISIZE_INIT;\n+static EXIT_STATUS: AtomicIsize = AtomicIsize::new(0);\n \n /// Sets the process exit code\n ///"}, {"sha": "d398cb88af458a156760df6fd676f76f4dde7c3c", "filename": "src/libstd/io/lazy.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -11,31 +11,31 @@\n use prelude::v1::*;\n \n use boxed;\n-use cell::UnsafeCell;\n+use cell::Cell;\n use rt;\n use sync::{StaticMutex, Arc};\n \n pub struct Lazy<T> {\n-    pub lock: StaticMutex,\n-    pub ptr: UnsafeCell<*mut Arc<T>>,\n-    pub init: fn() -> Arc<T>,\n+    lock: StaticMutex,\n+    ptr: Cell<*mut Arc<T>>,\n+    init: fn() -> Arc<T>,\n }\n \n unsafe impl<T> Sync for Lazy<T> {}\n \n-macro_rules! lazy_init {\n-    ($init:expr) => (::io::lazy::Lazy {\n-        lock: ::sync::MUTEX_INIT,\n-        ptr: ::cell::UnsafeCell { value: 0 as *mut _ },\n-        init: $init,\n-    })\n-}\n-\n impl<T: Send + Sync + 'static> Lazy<T> {\n+    pub const fn new(init: fn() -> Arc<T>) -> Lazy<T> {\n+        Lazy {\n+            lock: StaticMutex::new(),\n+            ptr: Cell::new(0 as *mut _),\n+            init: init\n+        }\n+    }\n+\n     pub fn get(&'static self) -> Option<Arc<T>> {\n         let _g = self.lock.lock();\n+        let ptr = self.ptr.get();\n         unsafe {\n-            let ptr = *self.ptr.get();\n             if ptr.is_null() {\n                 Some(self.init())\n             } else if ptr as usize == 1 {\n@@ -53,14 +53,14 @@ impl<T: Send + Sync + 'static> Lazy<T> {\n         // `Arc`.\n         let registered = rt::at_exit(move || {\n             let g = self.lock.lock();\n-            let ptr = *self.ptr.get();\n-            *self.ptr.get() = 1 as *mut _;\n+            let ptr = self.ptr.get();\n+            self.ptr.set(1 as *mut _);\n             drop(g);\n             drop(Box::from_raw(ptr))\n         });\n         let ret = (self.init)();\n         if registered.is_ok() {\n-            *self.ptr.get() = boxed::into_raw(Box::new(ret.clone()));\n+            self.ptr.set(boxed::into_raw(Box::new(ret.clone())));\n         }\n         return ret\n     }"}, {"sha": "c664def304e09e55c7847874184d589f86ea8a31", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -36,13 +36,12 @@ pub use self::stdio::{StdoutLock, StderrLock, StdinLock};\n #[doc(no_inline, hidden)]\n pub use self::stdio::{set_panic, set_print};\n \n-#[macro_use] mod lazy;\n-\n pub mod prelude;\n mod buffered;\n mod cursor;\n mod error;\n mod impls;\n+mod lazy;\n mod util;\n mod stdio;\n "}, {"sha": "9885ccfaae0850f2ac92db487b8977bac613e080", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -122,7 +122,7 @@ pub struct StdinLock<'a> {\n /// locked version, `StdinLock`, implements both `Read` and `BufRead`, however.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdin() -> Stdin {\n-    static INSTANCE: Lazy<Mutex<BufReader<StdinRaw>>> = lazy_init!(stdin_init);\n+    static INSTANCE: Lazy<Mutex<BufReader<StdinRaw>>> = Lazy::new(stdin_init);\n     return Stdin {\n         inner: INSTANCE.get().expect(\"cannot access stdin during shutdown\"),\n     };\n@@ -236,7 +236,7 @@ pub struct StdoutLock<'a> {\n /// The returned handle implements the `Write` trait.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdout() -> Stdout {\n-    static INSTANCE: Lazy<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = lazy_init!(stdout_init);\n+    static INSTANCE: Lazy<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = Lazy::new(stdout_init);\n     return Stdout {\n         inner: INSTANCE.get().expect(\"cannot access stdout during shutdown\"),\n     };\n@@ -308,7 +308,7 @@ pub struct StderrLock<'a> {\n /// The returned handle implements the `Write` trait.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stderr() -> Stderr {\n-    static INSTANCE: Lazy<ReentrantMutex<RefCell<StderrRaw>>> = lazy_init!(stderr_init);\n+    static INSTANCE: Lazy<ReentrantMutex<RefCell<StderrRaw>>> = Lazy::new(stderr_init);\n     return Stderr {\n         inner: INSTANCE.get().expect(\"cannot access stderr during shutdown\"),\n     };"}, {"sha": "8305088057c41ed654338a4a0418d9d01ced1bc6", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -109,6 +109,7 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(const_fn)]\n #![feature(into_cow)]\n #![feature(lang_items)]\n #![feature(libc)]"}, {"sha": "c6d839d55a865d97c8e45285d4b263b1cc0564f0", "filename": "src/libstd/net/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftest.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -12,9 +12,9 @@ use prelude::v1::*;\n \n use env;\n use net::{SocketAddr, SocketAddrV4, SocketAddrV6, Ipv4Addr, Ipv6Addr, ToSocketAddrs};\n-use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+use sync::atomic::{AtomicUsize, Ordering};\n \n-static PORT: AtomicUsize = ATOMIC_USIZE_INIT;\n+static PORT: AtomicUsize = AtomicUsize::new(0);\n \n pub fn next_test_ip4() -> SocketAddr {\n     let port = PORT.fetch_add(1, Ordering::SeqCst) as u16 + base_port();"}, {"sha": "a2e6915a6a6f7db90769bf238cc0d8b7559ee2ee", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -96,11 +96,11 @@ mod imp {\n                   target_arch = \"aarch64\",\n                   target_arch = \"powerpc\")))]\n     fn is_getrandom_available() -> bool {\n-        use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Ordering};\n-        use sync::{Once, ONCE_INIT};\n+        use sync::atomic::{AtomicBool, Ordering};\n+        use sync::Once;\n \n-        static CHECKER: Once = ONCE_INIT;\n-        static AVAILABLE: AtomicBool = ATOMIC_BOOL_INIT;\n+        static CHECKER: Once = Once::new();\n+        static AVAILABLE: AtomicBool = AtomicBool::new(false);\n \n         CHECKER.call_once(|| {\n             let mut buf: [u8; 0] = [];"}, {"sha": "d23a124a6ecda21ddc572d19f8dc37aa7f9dd2e2", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -52,10 +52,10 @@ mod imp {\n     use mem;\n     use ffi::CStr;\n \n-    use sync::{StaticMutex, MUTEX_INIT};\n+    use sync::StaticMutex;\n \n     static mut GLOBAL_ARGS_PTR: usize = 0;\n-    static LOCK: StaticMutex = MUTEX_INIT;\n+    static LOCK: StaticMutex = StaticMutex::new();\n \n     pub unsafe fn init(argc: isize, argv: *const *const u8) {\n         let args = load_argc_and_argv(argc, argv);"}, {"sha": "19a17be4ccf495b02dd58df5a46f7c4d65d59912", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -20,15 +20,15 @@ use boxed;\n use boxed::Box;\n use vec::Vec;\n use thunk::Thunk;\n-use sys_common::mutex::{Mutex, MUTEX_INIT};\n+use sys_common::mutex::Mutex;\n \n type Queue = Vec<Thunk<'static>>;\n \n // NB these are specifically not types from `std::sync` as they currently rely\n // on poisoning and this module needs to operate at a lower level than requiring\n // the thread infrastructure to be in place (useful on the borders of\n // initialization/destruction).\n-static LOCK: Mutex = MUTEX_INIT;\n+static LOCK: Mutex = Mutex::new();\n static mut QUEUE: *mut Queue = 0 as *mut Queue;\n \n // The maximum number of times the cleanup routines will be run. While running"}, {"sha": "2eadf36a6b4f0424abc762efff0c632bf8092dc1", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -22,7 +22,7 @@ pub use sys::backtrace::write;\n // For now logging is turned off by default, and this function checks to see\n // whether the magical environment variable is present to see if it's turned on.\n pub fn log_enabled() -> bool {\n-    static ENABLED: atomic::AtomicIsize = atomic::ATOMIC_ISIZE_INIT;\n+    static ENABLED: atomic::AtomicIsize = atomic::AtomicIsize::new(0);\n     match ENABLED.load(Ordering::SeqCst) {\n         1 => return false,\n         2 => return true,"}, {"sha": "c403976745aa4769af0e9ad3730d0714ab572a10", "filename": "src/libstd/rt/unwind/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Frt%2Funwind%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Frt%2Funwind%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fmod.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -72,7 +72,7 @@ use intrinsics;\n use libc::c_void;\n use mem;\n use sync::atomic::{self, Ordering};\n-use sys_common::mutex::{Mutex, MUTEX_INIT};\n+use sys_common::mutex::Mutex;\n \n // The actual unwinding implementation is cfg'd here, and we've got two current\n // implementations. One goes through SEH on Windows and the other goes through\n@@ -89,15 +89,15 @@ pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: u32);\n // For more information, see below.\n const MAX_CALLBACKS: usize = 16;\n static CALLBACKS: [atomic::AtomicUsize; MAX_CALLBACKS] =\n-        [atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT];\n-static CALLBACK_CNT: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+        [atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n+         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n+         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n+         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n+         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n+         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n+         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n+         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0)];\n+static CALLBACK_CNT: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n \n thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n \n@@ -243,7 +243,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>,\n     // `std::sync` one as accessing TLS can cause weird recursive problems (and\n     // we don't need poison checking).\n     unsafe {\n-        static LOCK: Mutex = MUTEX_INIT;\n+        static LOCK: Mutex = Mutex::new();\n         static mut INIT: bool = false;\n         LOCK.lock();\n         if !INIT {"}, {"sha": "b53219db245fc18a40dd801a0323ecc2dba9ab47", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -42,7 +42,7 @@ pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool {\n }\n \n pub fn min_stack() -> usize {\n-    static MIN: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+    static MIN: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n     match MIN.load(Ordering::SeqCst) {\n         0 => {}\n         n => return n - 1,"}, {"sha": "f2c389f9426ebe3a273e6ac8bb4ff963aabc1d12", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -10,7 +10,7 @@\n \n use prelude::v1::*;\n \n-use sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n+use sync::atomic::{AtomicUsize, Ordering};\n use sync::{mutex, MutexGuard, PoisonError};\n use sys_common::condvar as sys;\n use sys_common::mutex as sys_mutex;\n@@ -84,10 +84,7 @@ pub struct StaticCondvar {\n /// Constant initializer for a statically allocated condition variable.\n #[unstable(feature = \"static_condvar\",\n            reason = \"may be merged with Condvar in the future\")]\n-pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n-    inner: sys::CONDVAR_INIT,\n-    mutex: ATOMIC_USIZE_INIT,\n-};\n+pub const CONDVAR_INIT: StaticCondvar = StaticCondvar::new();\n \n impl Condvar {\n     /// Creates a new condition variable which is ready to be waited on and\n@@ -96,7 +93,7 @@ impl Condvar {\n     pub fn new() -> Condvar {\n         Condvar {\n             inner: box StaticCondvar {\n-                inner: unsafe { sys::Condvar::new() },\n+                inner: sys::Condvar::new(),\n                 mutex: AtomicUsize::new(0),\n             }\n         }\n@@ -234,6 +231,16 @@ impl Drop for Condvar {\n }\n \n impl StaticCondvar {\n+    /// Creates a new condition variable\n+    #[unstable(feature = \"static_condvar\",\n+               reason = \"may be merged with Condvar in the future\")]\n+    pub const fn new() -> StaticCondvar {\n+        StaticCondvar {\n+            inner: sys::Condvar::new(),\n+            mutex: AtomicUsize::new(0),\n+        }\n+    }\n+\n     /// Blocks the current thread until this condition variable receives a\n     /// notification.\n     ///\n@@ -388,10 +395,10 @@ impl StaticCondvar {\n mod tests {\n     use prelude::v1::*;\n \n-    use super::{StaticCondvar, CONDVAR_INIT};\n+    use super::StaticCondvar;\n     use sync::mpsc::channel;\n-    use sync::{StaticMutex, MUTEX_INIT, Condvar, Mutex, Arc};\n-    use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+    use sync::{StaticMutex, Condvar, Mutex, Arc};\n+    use sync::atomic::{AtomicUsize, Ordering};\n     use thread;\n     use time::Duration;\n     use u32;\n@@ -405,16 +412,16 @@ mod tests {\n \n     #[test]\n     fn static_smoke() {\n-        static C: StaticCondvar = CONDVAR_INIT;\n+        static C: StaticCondvar = StaticCondvar::new();\n         C.notify_one();\n         C.notify_all();\n         unsafe { C.destroy(); }\n     }\n \n     #[test]\n     fn notify_one() {\n-        static C: StaticCondvar = CONDVAR_INIT;\n-        static M: StaticMutex = MUTEX_INIT;\n+        static C: StaticCondvar = StaticCondvar::new();\n+        static M: StaticMutex = StaticMutex::new();\n \n         let g = M.lock().unwrap();\n         let _t = thread::spawn(move|| {\n@@ -464,8 +471,8 @@ mod tests {\n \n     #[test]\n     fn wait_timeout_ms() {\n-        static C: StaticCondvar = CONDVAR_INIT;\n-        static M: StaticMutex = MUTEX_INIT;\n+        static C: StaticCondvar = StaticCondvar::new();\n+        static M: StaticMutex = StaticMutex::new();\n \n         let g = M.lock().unwrap();\n         let (g, _no_timeout) = C.wait_timeout_ms(g, 1).unwrap();\n@@ -483,9 +490,9 @@ mod tests {\n \n     #[test]\n     fn wait_timeout_with() {\n-        static C: StaticCondvar = CONDVAR_INIT;\n-        static M: StaticMutex = MUTEX_INIT;\n-        static S: AtomicUsize = ATOMIC_USIZE_INIT;\n+        static C: StaticCondvar = StaticCondvar::new();\n+        static M: StaticMutex = StaticMutex::new();\n+        static S: AtomicUsize = AtomicUsize::new(0);\n \n         let g = M.lock().unwrap();\n         let (g, success) = C.wait_timeout_with(g, Duration::new(0, 1000), |_| {\n@@ -530,9 +537,9 @@ mod tests {\n     #[test]\n     #[should_panic]\n     fn two_mutexes() {\n-        static M1: StaticMutex = MUTEX_INIT;\n-        static M2: StaticMutex = MUTEX_INIT;\n-        static C: StaticCondvar = CONDVAR_INIT;\n+        static M1: StaticMutex = StaticMutex::new();\n+        static M2: StaticMutex = StaticMutex::new();\n+        static C: StaticCondvar = StaticCondvar::new();\n \n         let mut g = M1.lock().unwrap();\n         let _t = thread::spawn(move|| {"}, {"sha": "0e5a98591168b5d6864a092f6a3b0a55d9ce5c6a", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -11,7 +11,7 @@\n //! Generic support for building blocking abstractions.\n \n use thread::{self, Thread};\n-use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Ordering};\n+use sync::atomic::{AtomicBool, Ordering};\n use sync::Arc;\n use marker::{Sync, Send};\n use mem;\n@@ -41,7 +41,7 @@ impl !Sync for WaitToken {}\n pub fn tokens() -> (WaitToken, SignalToken) {\n     let inner = Arc::new(Inner {\n         thread: thread::current(),\n-        woken: ATOMIC_BOOL_INIT,\n+        woken: AtomicBool::new(false),\n     });\n     let wait_token = WaitToken {\n         inner: inner.clone(),"}, {"sha": "fd22d723ebdb1c371403126520ad5f8f67fd393b", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -178,17 +178,14 @@ impl<'a, T: ?Sized> !marker::Send for MutexGuard<'a, T> {}\n /// other mutex constants.\n #[unstable(feature = \"std_misc\",\n            reason = \"may be merged with Mutex in the future\")]\n-pub const MUTEX_INIT: StaticMutex = StaticMutex {\n-    lock: sys::MUTEX_INIT,\n-    poison: poison::FLAG_INIT,\n-};\n+pub const MUTEX_INIT: StaticMutex = StaticMutex::new();\n \n impl<T> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> Mutex<T> {\n         Mutex {\n-            inner: box MUTEX_INIT,\n+            inner: box StaticMutex::new(),\n             data: UnsafeCell::new(t),\n         }\n     }\n@@ -271,9 +268,19 @@ impl<T: ?Sized + fmt::Debug + 'static> fmt::Debug for Mutex<T> {\n \n struct Dummy(UnsafeCell<()>);\n unsafe impl Sync for Dummy {}\n-static DUMMY: Dummy = Dummy(UnsafeCell { value: () });\n+static DUMMY: Dummy = Dummy(UnsafeCell::new(()));\n \n impl StaticMutex {\n+    /// Creates a new mutex in an unlocked state ready for use.\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with Mutex in the future\")]\n+    pub const fn new() -> StaticMutex {\n+        StaticMutex {\n+            lock: sys::Mutex::new(),\n+            poison: poison::Flag::new(),\n+        }\n+    }\n+\n     /// Acquires this lock, see `Mutex::lock`\n     #[inline]\n     #[unstable(feature = \"std_misc\",\n@@ -365,7 +372,7 @@ mod tests {\n     use prelude::v1::*;\n \n     use sync::mpsc::channel;\n-    use sync::{Arc, Mutex, StaticMutex, MUTEX_INIT, Condvar};\n+    use sync::{Arc, Mutex, StaticMutex, Condvar};\n     use thread;\n \n     struct Packet<T: Send>(Arc<(Mutex<T>, Condvar)>);\n@@ -382,7 +389,7 @@ mod tests {\n \n     #[test]\n     fn smoke_static() {\n-        static M: StaticMutex = MUTEX_INIT;\n+        static M: StaticMutex = StaticMutex::new();\n         unsafe {\n             drop(M.lock().unwrap());\n             drop(M.lock().unwrap());\n@@ -392,7 +399,7 @@ mod tests {\n \n     #[test]\n     fn lots_and_lots() {\n-        static M: StaticMutex = MUTEX_INIT;\n+        static M: StaticMutex = StaticMutex::new();\n         static mut CNT: u32 = 0;\n         const J: u32 = 1000;\n         const K: u32 = 3;"}, {"sha": "269affff20855ba52bfd130495d48d31f4341453", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -16,8 +16,8 @@\n use prelude::v1::*;\n \n use isize;\n-use sync::atomic::{AtomicIsize, Ordering, ATOMIC_ISIZE_INIT};\n-use sync::{StaticMutex, MUTEX_INIT};\n+use sync::atomic::{AtomicIsize, Ordering};\n+use sync::StaticMutex;\n \n /// A synchronization primitive which can be used to run a one-time global\n /// initialization. Useful for one-time initialization for FFI or related\n@@ -44,13 +44,19 @@ pub struct Once {\n \n /// Initialization value for static `Once` values.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const ONCE_INIT: Once = Once {\n-    mutex: MUTEX_INIT,\n-    cnt: ATOMIC_ISIZE_INIT,\n-    lock_cnt: ATOMIC_ISIZE_INIT,\n-};\n+pub const ONCE_INIT: Once = Once::new();\n \n impl Once {\n+    /// Creates a new `Once` value.\n+    #[unstable(feature = \"std_misc\")]\n+    pub const fn new() -> Once {\n+        Once {\n+            mutex: StaticMutex::new(),\n+            cnt: AtomicIsize::new(0),\n+            lock_cnt: AtomicIsize::new(0),\n+        }\n+    }\n+\n     /// Performs an initialization routine once and only once. The given closure\n     /// will be executed if this is the first time `call_once` has been called,\n     /// and otherwise the routine will *not* be invoked.\n@@ -129,12 +135,12 @@ mod tests {\n     use prelude::v1::*;\n \n     use thread;\n-    use super::{ONCE_INIT, Once};\n+    use super::Once;\n     use sync::mpsc::channel;\n \n     #[test]\n     fn smoke_once() {\n-        static O: Once = ONCE_INIT;\n+        static O: Once = Once::new();\n         let mut a = 0;\n         O.call_once(|| a += 1);\n         assert_eq!(a, 1);\n@@ -144,7 +150,7 @@ mod tests {\n \n     #[test]\n     fn stampede_once() {\n-        static O: Once = ONCE_INIT;\n+        static O: Once = Once::new();\n         static mut run: bool = false;\n \n         let (tx, rx) = channel();"}, {"sha": "e7c3d744c179ab0fdb1096f283bc73f8434518d5", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -102,10 +102,7 @@ pub struct StaticRwLock {\n /// Constant initialization for a statically-initialized rwlock.\n #[unstable(feature = \"std_misc\",\n            reason = \"may be merged with RwLock in the future\")]\n-pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock {\n-    lock: sys::RWLOCK_INIT,\n-    poison: poison::FLAG_INIT,\n-};\n+pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock::new();\n \n /// RAII structure used to release the shared read access of a lock when\n /// dropped.\n@@ -142,7 +139,7 @@ impl<T> RwLock<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> RwLock<T> {\n-        RwLock { inner: box RW_LOCK_INIT, data: UnsafeCell::new(t) }\n+        RwLock { inner: box StaticRwLock::new(), data: UnsafeCell::new(t) }\n     }\n }\n \n@@ -280,9 +277,19 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T> {\n \n struct Dummy(UnsafeCell<()>);\n unsafe impl Sync for Dummy {}\n-static DUMMY: Dummy = Dummy(UnsafeCell { value: () });\n+static DUMMY: Dummy = Dummy(UnsafeCell::new(()));\n \n impl StaticRwLock {\n+    /// Creates a new rwlock.\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"may be merged with RwLock in the future\")]\n+    pub const fn new() -> StaticRwLock {\n+        StaticRwLock {\n+            lock: sys::RWLock::new(),\n+            poison: poison::Flag::new(),\n+        }\n+    }\n+\n     /// Locks this rwlock with shared read access, blocking the current thread\n     /// until it can be acquired.\n     ///\n@@ -420,7 +427,7 @@ mod tests {\n     use rand::{self, Rng};\n     use sync::mpsc::channel;\n     use thread;\n-    use sync::{Arc, RwLock, StaticRwLock, TryLockError, RW_LOCK_INIT};\n+    use sync::{Arc, RwLock, StaticRwLock, TryLockError};\n \n     #[test]\n     fn smoke() {\n@@ -433,7 +440,7 @@ mod tests {\n \n     #[test]\n     fn static_smoke() {\n-        static R: StaticRwLock = RW_LOCK_INIT;\n+        static R: StaticRwLock = StaticRwLock::new();\n         drop(R.read().unwrap());\n         drop(R.write().unwrap());\n         drop((R.read().unwrap(), R.read().unwrap()));\n@@ -443,7 +450,7 @@ mod tests {\n \n     #[test]\n     fn frob() {\n-        static R: StaticRwLock = RW_LOCK_INIT;\n+        static R: StaticRwLock = StaticRwLock::new();\n         const N: usize = 10;\n         const M: usize = 1000;\n "}, {"sha": "33734a88cf32b18467beae65149f94a01b6fc3b9", "filename": "src/libstd/sys/common/condvar.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fcommon%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fcommon%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fcondvar.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -20,16 +20,12 @@ use sys::condvar as imp;\n /// this type.\n pub struct Condvar(imp::Condvar);\n \n-/// Static initializer for condition variables.\n-pub const CONDVAR_INIT: Condvar = Condvar(imp::CONDVAR_INIT);\n-\n impl Condvar {\n     /// Creates a new condition variable for use.\n     ///\n     /// Behavior is undefined if the condition variable is moved after it is\n     /// first used with any of the functions below.\n-    #[inline]\n-    pub unsafe fn new() -> Condvar { Condvar(imp::Condvar::new()) }\n+    pub const fn new() -> Condvar { Condvar(imp::Condvar::new()) }\n \n     /// Signals one waiter on this condition variable to wake up.\n     #[inline]"}, {"sha": "5a6dfe7fb1a1507739b6b47447490ec60d426b92", "filename": "src/libstd/sys/common/mutex.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -20,10 +20,13 @@ pub struct Mutex(imp::Mutex);\n \n unsafe impl Sync for Mutex {}\n \n-/// Constant initializer for statically allocated mutexes.\n-pub const MUTEX_INIT: Mutex = Mutex(imp::MUTEX_INIT);\n-\n impl Mutex {\n+    /// Creates a new mutex for use.\n+    ///\n+    /// Behavior is undefined if the mutex is moved after it is\n+    /// first used with any of the functions below.\n+    pub const fn new() -> Mutex { Mutex(imp::Mutex::new()) }\n+\n     /// Locks the mutex blocking the current thread until it is available.\n     ///\n     /// Behavior is undefined if the mutex has been moved between this and any"}, {"sha": "48c8198272588f8f1401252ac21b4731bb6d41fb", "filename": "src/libstd/sys/common/poison.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -10,26 +10,28 @@\n \n use prelude::v1::*;\n \n-use marker::Reflect;\n-use cell::UnsafeCell;\n+use cell::Cell;\n use error::{Error};\n use fmt;\n+use marker::Reflect;\n use thread;\n \n-pub struct Flag { failed: UnsafeCell<bool> }\n+pub struct Flag { failed: Cell<bool> }\n \n // This flag is only ever accessed with a lock previously held. Note that this\n // a totally private structure.\n unsafe impl Send for Flag {}\n unsafe impl Sync for Flag {}\n \n-pub const FLAG_INIT: Flag = Flag { failed: UnsafeCell { value: false } };\n-\n impl Flag {\n+    pub const fn new() -> Flag {\n+        Flag { failed: Cell::new(false) }\n+    }\n+\n     #[inline]\n     pub fn borrow(&self) -> LockResult<Guard> {\n         let ret = Guard { panicking: thread::panicking() };\n-        if unsafe { *self.failed.get() } {\n+        if self.get() {\n             Err(PoisonError::new(ret))\n         } else {\n             Ok(ret)\n@@ -39,13 +41,13 @@ impl Flag {\n     #[inline]\n     pub fn done(&self, guard: &Guard) {\n         if !guard.panicking && thread::panicking() {\n-            unsafe { *self.failed.get() = true; }\n+            self.failed.set(true);\n         }\n     }\n \n     #[inline]\n     pub fn get(&self) -> bool {\n-        unsafe { *self.failed.get() }\n+        self.failed.get()\n     }\n }\n "}, {"sha": "72f8453233a4108ffffca4d6dfa0eb4b3bf754dc", "filename": "src/libstd/sys/common/remutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -54,7 +54,7 @@ impl<T> ReentrantMutex<T> {\n         unsafe {\n             let mut mutex = ReentrantMutex {\n                 inner: box sys::ReentrantMutex::uninitialized(),\n-                poison: poison::FLAG_INIT,\n+                poison: poison::Flag::new(),\n                 data: t,\n             };\n             mutex.inner.init();"}, {"sha": "71a4f01ec4cab9f2d3edcee78af3373f2484e24f", "filename": "src/libstd/sys/common/rwlock.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -17,10 +17,13 @@ use sys::rwlock as imp;\n /// safer types at the top level of this crate instead of this type.\n pub struct RWLock(imp::RWLock);\n \n-/// Constant initializer for static RWLocks.\n-pub const RWLOCK_INIT: RWLock = RWLock(imp::RWLOCK_INIT);\n-\n impl RWLock {\n+    /// Creates a new reader-writer lock for use.\n+    ///\n+    /// Behavior is undefined if the reader-writer lock is moved after it is\n+    /// first used with any of the functions below.\n+    pub const fn new() -> RWLock { RWLock(imp::RWLock::new()) }\n+\n     /// Acquires shared access to the underlying lock, blocking the current\n     /// thread to do so.\n     ///"}, {"sha": "eb4cbfcfbcdda5a8c59b52c0604f95cc161b2a88", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -86,19 +86,13 @@ use sys::thread_local as imp;\n /// }\n /// ```\n pub struct StaticKey {\n-    /// Inner static TLS key (internals), created with by `INIT_INNER` in this\n-    /// module.\n-    pub inner: StaticKeyInner,\n+    /// Inner static TLS key (internals).\n+    key: AtomicUsize,\n     /// Destructor for the TLS value.\n     ///\n     /// See `Key::new` for information about when the destructor runs and how\n     /// it runs.\n-    pub dtor: Option<unsafe extern fn(*mut u8)>,\n-}\n-\n-/// Inner contents of `StaticKey`, created by the `INIT_INNER` constant.\n-pub struct StaticKeyInner {\n-    key: AtomicUsize,\n+    dtor: Option<unsafe extern fn(*mut u8)>,\n }\n \n /// A type for a safely managed OS-based TLS slot.\n@@ -129,19 +123,16 @@ pub struct Key {\n /// Constant initialization value for static TLS keys.\n ///\n /// This value specifies no destructor by default.\n-pub const INIT: StaticKey = StaticKey {\n-    inner: INIT_INNER,\n-    dtor: None,\n-};\n-\n-/// Constant initialization value for the inner part of static TLS keys.\n-///\n-/// This value allows specific configuration of the destructor for a TLS key.\n-pub const INIT_INNER: StaticKeyInner = StaticKeyInner {\n-    key: atomic::ATOMIC_USIZE_INIT,\n-};\n+pub const INIT: StaticKey = StaticKey::new(None);\n \n impl StaticKey {\n+    pub const fn new(dtor: Option<unsafe extern fn(*mut u8)>) -> StaticKey {\n+        StaticKey {\n+            key: atomic::AtomicUsize::new(0),\n+            dtor: dtor\n+        }\n+    }\n+\n     /// Gets the value associated with this TLS key\n     ///\n     /// This will lazily allocate a TLS key from the OS if one has not already\n@@ -164,15 +155,15 @@ impl StaticKey {\n     /// Note that this does *not* run the user-provided destructor if one was\n     /// specified at definition time. Doing so must be done manually.\n     pub unsafe fn destroy(&self) {\n-        match self.inner.key.swap(0, Ordering::SeqCst) {\n+        match self.key.swap(0, Ordering::SeqCst) {\n             0 => {}\n             n => { imp::destroy(n as imp::Key) }\n         }\n     }\n \n     #[inline]\n     unsafe fn key(&self) -> imp::Key {\n-        match self.inner.key.load(Ordering::Relaxed) {\n+        match self.key.load(Ordering::Relaxed) {\n             0 => self.lazy_init() as imp::Key,\n             n => n as imp::Key\n         }\n@@ -197,7 +188,7 @@ impl StaticKey {\n             key2\n         };\n         assert!(key != 0);\n-        match self.inner.key.compare_and_swap(0, key as usize, Ordering::SeqCst) {\n+        match self.key.compare_and_swap(0, key as usize, Ordering::SeqCst) {\n             // The CAS succeeded, so we've created the actual key\n             0 => key as usize,\n             // If someone beat us to the punch, use their key instead\n@@ -245,7 +236,7 @@ impl Drop for Key {\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;\n-    use super::{Key, StaticKey, INIT_INNER};\n+    use super::{Key, StaticKey};\n \n     fn assert_sync<T: Sync>() {}\n     fn assert_send<T: Send>() {}\n@@ -267,8 +258,8 @@ mod tests {\n \n     #[test]\n     fn statik() {\n-        static K1: StaticKey = StaticKey { inner: INIT_INNER, dtor: None };\n-        static K2: StaticKey = StaticKey { inner: INIT_INNER, dtor: None };\n+        static K1: StaticKey = StaticKey::new(None);\n+        static K2: StaticKey = StaticKey::new(None);\n \n         unsafe {\n             assert!(K1.get().is_null());"}, {"sha": "b23a3eee1a1738e03e69f9706901a3d5e82b21fa", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -91,7 +91,7 @@ use io;\n use libc;\n use mem;\n use str;\n-use sync::{StaticMutex, MUTEX_INIT};\n+use sync::StaticMutex;\n \n use sys_common::backtrace::*;\n \n@@ -117,7 +117,7 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n     // while it doesn't requires lock for work as everything is\n     // local, it still displays much nicer backtraces when a\n     // couple of threads panic simultaneously\n-    static LOCK: StaticMutex = MUTEX_INIT;\n+    static LOCK: StaticMutex = StaticMutex::new();\n     let _g = LOCK.lock();\n \n     try!(writeln!(w, \"stack backtrace:\"));\n@@ -148,7 +148,7 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n     // is semi-reasonable in terms of printing anyway, and we know that all\n     // I/O done here is blocking I/O, not green I/O, so we don't have to\n     // worry about this being a native vs green mutex.\n-    static LOCK: StaticMutex = MUTEX_INIT;\n+    static LOCK: StaticMutex = StaticMutex::new();\n     let _g = LOCK.lock();\n \n     try!(writeln!(w, \"stack backtrace:\"));"}, {"sha": "c8708190a2e18c6f6fef8b5f3a322508a15417b7", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -23,13 +23,8 @@ pub struct Condvar { inner: UnsafeCell<ffi::pthread_cond_t> }\n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n-pub const CONDVAR_INIT: Condvar = Condvar {\n-    inner: UnsafeCell { value: ffi::PTHREAD_COND_INITIALIZER },\n-};\n-\n impl Condvar {\n-    #[inline]\n-    pub unsafe fn new() -> Condvar {\n+    pub const fn new() -> Condvar {\n         // Might be moved and address is changing it is better to avoid\n         // initialization of potentially opaque OS data before it landed\n         Condvar { inner: UnsafeCell::new(ffi::PTHREAD_COND_INITIALIZER) }"}, {"sha": "6eed403dfc08071cdd70ed404154e6a873b372e6", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -21,20 +21,15 @@ pub unsafe fn raw(m: &Mutex) -> *mut ffi::pthread_mutex_t {\n     m.inner.get()\n }\n \n-pub const MUTEX_INIT: Mutex = Mutex {\n-    inner: UnsafeCell { value: ffi::PTHREAD_MUTEX_INITIALIZER },\n-};\n-\n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n \n #[allow(dead_code)] // sys isn't exported yet\n impl Mutex {\n-    #[inline]\n-    pub unsafe fn new() -> Mutex {\n+    pub const fn new() -> Mutex {\n         // Might be moved and address is changing it is better to avoid\n         // initialization of potentially opaque OS data before it landed\n-        MUTEX_INIT\n+        Mutex { inner: UnsafeCell::new(ffi::PTHREAD_MUTEX_INITIALIZER) }\n     }\n     #[inline]\n     pub unsafe fn lock(&self) {"}, {"sha": "5178d7b8fb1a0ac962ddb058a68fb0b31ff65a20", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -216,8 +216,8 @@ pub fn current_exe() -> io::Result<PathBuf> {\n \n #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n-    use sync::{StaticMutex, MUTEX_INIT};\n-    static LOCK: StaticMutex = MUTEX_INIT;\n+    use sync::StaticMutex;\n+    static LOCK: StaticMutex = StaticMutex::new();\n \n     extern {\n         fn rust_current_exe() -> *const c_char;"}, {"sha": "ee687f350f02129c42988c775130d650cc997b37", "filename": "src/libstd/sys/unix/rwlock.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -16,14 +16,13 @@ use sys::sync as ffi;\n \n pub struct RWLock { inner: UnsafeCell<ffi::pthread_rwlock_t> }\n \n-pub const RWLOCK_INIT: RWLock = RWLock {\n-    inner: UnsafeCell { value: ffi::PTHREAD_RWLOCK_INITIALIZER },\n-};\n-\n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n impl RWLock {\n+    pub const fn new() -> RWLock {\n+        RWLock { inner: UnsafeCell::new(ffi::PTHREAD_RWLOCK_INITIALIZER) }\n+    }\n     #[inline]\n     pub unsafe fn read(&self) {\n         let r = ffi::pthread_rwlock_rdlock(self.inner.get());"}, {"sha": "bb0e12e8df89944afeca8653820c5e4c661c9905", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -330,10 +330,10 @@ pub mod guard {\n #[cfg(target_os = \"linux\")]\n fn min_stack_size(attr: *const libc::pthread_attr_t) -> usize {\n     use dynamic_lib::DynamicLibrary;\n-    use sync::{Once, ONCE_INIT};\n+    use sync::Once;\n \n     type F = unsafe extern \"C\" fn(*const libc::pthread_attr_t) -> libc::size_t;\n-    static INIT: Once = ONCE_INIT;\n+    static INIT: Once = Once::new();\n     static mut __pthread_get_minstack: Option<F> = None;\n \n     INIT.call_once(|| {"}, {"sha": "3afe84b25804c3c5d11836da16d80052984b7ec0", "filename": "src/libstd/sys/unix/thread_local.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(dead_code)] // sys isn't exported yet\n+\n use prelude::v1::*;\n use libc::c_int;\n "}, {"sha": "6b84baeca7dc9d6a2d0f298c253f53d196de2a62", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -17,7 +17,7 @@ mod inner {\n     use libc;\n     use time::Duration;\n     use ops::Sub;\n-    use sync::{Once, ONCE_INIT};\n+    use sync::Once;\n     use super::NSEC_PER_SEC;\n \n     pub struct SteadyTime {\n@@ -42,7 +42,7 @@ mod inner {\n             numer: 0,\n             denom: 0,\n         };\n-        static ONCE: Once = ONCE_INIT;\n+        static ONCE: Once = Once::new();\n \n         unsafe {\n             ONCE.call_once(|| {"}, {"sha": "3f595762fc71b58b0149f4fdf27461daf1fccd46", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -36,7 +36,7 @@ use mem;\n use path::Path;\n use ptr;\n use str;\n-use sync::{StaticMutex, MUTEX_INIT};\n+use sync::StaticMutex;\n \n use sys_common::backtrace::*;\n \n@@ -295,7 +295,7 @@ impl Drop for Cleanup {\n pub fn write(w: &mut Write) -> io::Result<()> {\n     // According to windows documentation, all dbghelp functions are\n     // single-threaded.\n-    static LOCK: StaticMutex = MUTEX_INIT;\n+    static LOCK: StaticMutex = StaticMutex::new();\n     let _g = LOCK.lock();\n \n     // Open up dbghelp.dll, we don't link to it explicitly because it can't"}, {"sha": "3c9b2ef1b986ecbef40a4201ed11c51771b410aa", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -340,10 +340,10 @@ pub mod compat {\n                                       -> $rettype:ty { $fallback:expr }) => (\n             #[inline(always)]\n             pub unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n-                use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+                use sync::atomic::{AtomicUsize, Ordering};\n                 use mem;\n \n-                static PTR: AtomicUsize = ATOMIC_USIZE_INIT;\n+                static PTR: AtomicUsize = AtomicUsize::new(0);\n \n                 fn load() -> usize {\n                     ::sys::c::compat::store_func(&PTR,"}, {"sha": "baa7d1ceea3316d41923f13ec0fafee8a5dbd6cc", "filename": "src/libstd/sys/windows/condvar.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -22,13 +22,10 @@ pub struct Condvar { inner: UnsafeCell<ffi::CONDITION_VARIABLE> }\n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n-pub const CONDVAR_INIT: Condvar = Condvar {\n-    inner: UnsafeCell { value: ffi::CONDITION_VARIABLE_INIT }\n-};\n-\n impl Condvar {\n-    #[inline]\n-    pub unsafe fn new() -> Condvar { CONDVAR_INIT }\n+    pub const fn new() -> Condvar {\n+        Condvar { inner: UnsafeCell::new(ffi::CONDITION_VARIABLE_INIT) }\n+    }\n \n     #[inline]\n     pub unsafe fn wait(&self, mutex: &Mutex) {"}, {"sha": "29e370698ad744b727f4c202c5d333a9ee6ea193", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -16,10 +16,6 @@ use mem;\n \n pub struct Mutex { inner: UnsafeCell<ffi::SRWLOCK> }\n \n-pub const MUTEX_INIT: Mutex = Mutex {\n-    inner: UnsafeCell { value: ffi::SRWLOCK_INIT }\n-};\n-\n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n \n@@ -41,6 +37,9 @@ pub unsafe fn raw(m: &Mutex) -> ffi::PSRWLOCK {\n //    is there there are no guarantees of fairness.\n \n impl Mutex {\n+    pub const fn new() -> Mutex {\n+        Mutex { inner: UnsafeCell::new(ffi::SRWLOCK_INIT) }\n+    }\n     #[inline]\n     pub unsafe fn lock(&self) {\n         ffi::AcquireSRWLockExclusive(self.inner.get())"}, {"sha": "71e064bcc6b82e971a556529f2260eb8fe4e7bb7", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -18,7 +18,7 @@ use net::SocketAddr;\n use num::One;\n use ops::Neg;\n use rt;\n-use sync::{Once, ONCE_INIT};\n+use sync::Once;\n use sys::c;\n use sys_common::{AsInner, FromInner};\n \n@@ -29,7 +29,7 @@ pub struct Socket(libc::SOCKET);\n /// Checks whether the Windows socket interface has been started already, and\n /// if not, starts it.\n pub fn init() {\n-    static START: Once = ONCE_INIT;\n+    static START: Once = Once::new();\n \n     START.call_once(|| unsafe {\n         let mut data: c::WSADATA = mem::zeroed();"}, {"sha": "178b6ea42d2bb20f6900b854e59c2c89ede8af8d", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -24,7 +24,7 @@ use mem;\n use os::windows::ffi::OsStrExt;\n use path::Path;\n use ptr;\n-use sync::{StaticMutex, MUTEX_INIT};\n+use sync::StaticMutex;\n use sys::c;\n use sys::fs::{OpenOptions, File};\n use sys::handle::Handle;\n@@ -169,7 +169,7 @@ impl Process {\n         try!(unsafe {\n             // `CreateProcess` is racy!\n             // http://support.microsoft.com/kb/315939\n-            static CREATE_PROCESS_LOCK: StaticMutex = MUTEX_INIT;\n+            static CREATE_PROCESS_LOCK: StaticMutex = StaticMutex::new();\n             let _lock = CREATE_PROCESS_LOCK.lock();\n \n             cvt(CreateProcessW(ptr::null(),"}, {"sha": "e727638e3e9b5cddf67a2dfd14792649627a1080", "filename": "src/libstd/sys/windows/rwlock.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -15,14 +15,13 @@ use sys::sync as ffi;\n \n pub struct RWLock { inner: UnsafeCell<ffi::SRWLOCK> }\n \n-pub const RWLOCK_INIT: RWLock = RWLock {\n-    inner: UnsafeCell { value: ffi::SRWLOCK_INIT }\n-};\n-\n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n impl RWLock {\n+    pub const fn new() -> RWLock {\n+        RWLock { inner: UnsafeCell::new(ffi::SRWLOCK_INIT) }\n+    }\n     #[inline]\n     pub unsafe fn read(&self) {\n         ffi::AcquireSRWLockShared(self.inner.get())"}, {"sha": "a3d522d1757a97fa11d5280dc053b4e00c5ce947", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -15,7 +15,7 @@ use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n use boxed;\n use ptr;\n use rt;\n-use sys_common::mutex::{MUTEX_INIT, Mutex};\n+use sys_common::mutex::Mutex;\n \n pub type Key = DWORD;\n pub type Dtor = unsafe extern fn(*mut u8);\n@@ -58,7 +58,7 @@ pub type Dtor = unsafe extern fn(*mut u8);\n // on poisoning and this module needs to operate at a lower level than requiring\n // the thread infrastructure to be in place (useful on the borders of\n // initialization/destruction).\n-static DTOR_LOCK: Mutex = MUTEX_INIT;\n+static DTOR_LOCK: Mutex = Mutex::new();\n static mut DTORS: *mut Vec<(Key, Dtor)> = 0 as *mut _;\n \n // -------------------------------------------------------------------------"}, {"sha": "f5a70ccc90743a34ba1be9cc27b17b498c78d7b9", "filename": "src/libstd/sys/windows/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -10,7 +10,7 @@\n use libc;\n use ops::Sub;\n use time::Duration;\n-use sync::{Once, ONCE_INIT};\n+use sync::Once;\n \n const NANOS_PER_SEC: u64 = 1_000_000_000;\n \n@@ -28,7 +28,7 @@ impl SteadyTime {\n \n fn frequency() -> libc::LARGE_INTEGER {\n     static mut FREQUENCY: libc::LARGE_INTEGER = 0;\n-    static ONCE: Once = ONCE_INIT;\n+    static ONCE: Once = Once::new();\n \n     unsafe {\n         ONCE.call_once(|| {"}, {"sha": "0eafd4d5f12e952817ea91c94b48c762a7b3fd1d", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 87, "deletions": 159, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -18,12 +18,7 @@ use cell::UnsafeCell;\n \n // Sure wish we had macro hygiene, no?\n #[doc(hidden)]\n-pub mod __impl {\n-    pub use super::imp::Key as KeyInner;\n-    pub use super::imp::destroy_value;\n-    pub use sys_common::thread_local::INIT_INNER as OS_INIT_INNER;\n-    pub use sys_common::thread_local::StaticKey as OsStaticKey;\n-}\n+pub use self::imp::Key as __KeyInner;\n \n /// A thread local storage key which owns its contents.\n ///\n@@ -76,55 +71,10 @@ pub struct LocalKey<T> {\n     //\n     // This is trivially devirtualizable by LLVM because we never store anything\n     // to this field and rustc can declare the `static` as constant as well.\n-    #[doc(hidden)]\n-    pub inner: fn() -> &'static __impl::KeyInner<UnsafeCell<Option<T>>>,\n+    inner: fn() -> &'static __KeyInner<T>,\n \n     // initialization routine to invoke to create a value\n-    #[doc(hidden)]\n-    pub init: fn() -> T,\n-}\n-\n-/// Declare a new thread local storage key of type `std::thread::LocalKey`.\n-///\n-/// See [LocalKey documentation](thread/struct.LocalKey.html) for more information.\n-#[macro_export]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n-macro_rules! thread_local {\n-    (static $name:ident: $t:ty = $init:expr) => (\n-        static $name: ::std::thread::LocalKey<$t> = {\n-            use std::cell::UnsafeCell as __UnsafeCell;\n-            use std::thread::__local::KeyInner as __KeyInner;\n-            use std::option::Option as __Option;\n-            use std::option::Option::None as __None;\n-\n-            __thread_local_inner!(static __KEY: __UnsafeCell<__Option<$t>> = {\n-                __UnsafeCell { value: __None }\n-            });\n-            fn __init() -> $t { $init }\n-            fn __getit() -> &'static __KeyInner<__UnsafeCell<__Option<$t>>> {\n-                &__KEY\n-            }\n-            ::std::thread::LocalKey { inner: __getit, init: __init }\n-        };\n-    );\n-    (pub static $name:ident: $t:ty = $init:expr) => (\n-        pub static $name: ::std::thread::LocalKey<$t> = {\n-            use std::cell::UnsafeCell as __UnsafeCell;\n-            use std::thread::__local::KeyInner as __KeyInner;\n-            use std::option::Option as __Option;\n-            use std::option::Option::None as __None;\n-\n-            __thread_local_inner!(static __KEY: __UnsafeCell<__Option<$t>> = {\n-                __UnsafeCell { value: __None }\n-            });\n-            fn __init() -> $t { $init }\n-            fn __getit() -> &'static __KeyInner<__UnsafeCell<__Option<$t>>> {\n-                &__KEY\n-            }\n-            ::std::thread::LocalKey { inner: __getit, init: __init }\n-        };\n-    );\n+    init: fn() -> T,\n }\n \n // Macro pain #4586:\n@@ -147,50 +97,37 @@ macro_rules! thread_local {\n // To get around this, we're forced to inject the #[cfg] logic into the macro\n // itself. Woohoo.\n \n+/// Declare a new thread local storage key of type `std::thread::LocalKey`.\n+///\n+/// See [LocalKey documentation](thread/struct.LocalKey.html) for more information.\n #[macro_export]\n-#[doc(hidden)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable]\n-macro_rules! __thread_local_inner {\n+macro_rules! thread_local {\n     (static $name:ident: $t:ty = $init:expr) => (\n-        #[cfg_attr(all(any(target_os = \"macos\", target_os = \"linux\"),\n-                       not(target_arch = \"aarch64\")),\n-                   thread_local)]\n-        static $name: ::std::thread::__local::KeyInner<$t> =\n-            __thread_local_inner!($init, $t);\n+        static $name: ::std::thread::LocalKey<$t> = {\n+            #[cfg_attr(all(any(target_os = \"macos\", target_os = \"linux\"),\n+                           not(target_arch = \"aarch64\")),\n+                       thread_local)]\n+            static __KEY: ::std::thread::__LocalKeyInner<$t> =\n+                ::std::thread::__LocalKeyInner::new();\n+            fn __init() -> $t { $init }\n+            fn __getit() -> &'static ::std::thread::__LocalKeyInner<$t> { &__KEY }\n+            ::std::thread::LocalKey::new(__getit, __init)\n+        };\n     );\n     (pub static $name:ident: $t:ty = $init:expr) => (\n-        #[cfg_attr(all(any(target_os = \"macos\", target_os = \"linux\"),\n-                       not(target_arch = \"aarch64\")),\n-                   thread_local)]\n-        pub static $name: ::std::thread::__local::KeyInner<$t> =\n-            __thread_local_inner!($init, $t);\n-    );\n-    ($init:expr, $t:ty) => ({\n-        #[cfg(all(any(target_os = \"macos\", target_os = \"linux\"), not(target_arch = \"aarch64\")))]\n-        const _INIT: ::std::thread::__local::KeyInner<$t> = {\n-            ::std::thread::__local::KeyInner {\n-                inner: ::std::cell::UnsafeCell { value: $init },\n-                dtor_registered: ::std::cell::UnsafeCell { value: false },\n-                dtor_running: ::std::cell::UnsafeCell { value: false },\n-            }\n-        };\n-\n-        #[allow(trivial_casts)]\n-        #[cfg(any(not(any(target_os = \"macos\", target_os = \"linux\")), target_arch = \"aarch64\"))]\n-        const _INIT: ::std::thread::__local::KeyInner<$t> = {\n-            ::std::thread::__local::KeyInner {\n-                inner: ::std::cell::UnsafeCell { value: $init },\n-                os: ::std::thread::__local::OsStaticKey {\n-                    inner: ::std::thread::__local::OS_INIT_INNER,\n-                    dtor: ::std::option::Option::Some(\n-                        ::std::thread::__local::destroy_value::<$t>\n-                    ),\n-                },\n-            }\n+        pub static $name: ::std::thread::LocalKey<$t> = {\n+            #[cfg_attr(all(any(target_os = \"macos\", target_os = \"linux\"),\n+                           not(target_arch = \"aarch64\")),\n+                       thread_local)]\n+            static __KEY: ::std::thread::__LocalKeyInner<$t> =\n+                ::std::thread::__LocalKeyInner::new();\n+            fn __init() -> $t { $init }\n+            fn __getit() -> &'static ::std::thread::__LocalKeyInner<$t> { &__KEY }\n+            ::std::thread::LocalKey::new(__getit, __init)\n         };\n-\n-        _INIT\n-    });\n+    );\n }\n \n /// Indicator of the state of a thread local storage key.\n@@ -225,6 +162,14 @@ pub enum LocalKeyState {\n }\n \n impl<T: 'static> LocalKey<T> {\n+    #[doc(hidden)]\n+    pub const fn new(inner: fn() -> &'static __KeyInner<T>, init: fn() -> T) -> LocalKey<T> {\n+        LocalKey {\n+            inner: inner,\n+            init: init\n+        }\n+    }\n+\n     /// Acquires a reference to the value in this TLS key.\n     ///\n     /// This will lazily initialize the value if this thread has not referenced\n@@ -300,44 +245,45 @@ impl<T: 'static> LocalKey<T> {\n mod imp {\n     use prelude::v1::*;\n \n-    use cell::UnsafeCell;\n+    use cell::{Cell, UnsafeCell};\n     use intrinsics;\n-    use ptr;\n \n     pub struct Key<T> {\n-        // Place the inner bits in an `UnsafeCell` to currently get around the\n-        // \"only Sync statics\" restriction. This allows any type to be placed in\n-        // the cell.\n-        //\n-        // Note that all access requires `T: 'static` so it can't be a type with\n-        // any borrowed pointers still.\n-        pub inner: UnsafeCell<T>,\n+        inner: UnsafeCell<Option<T>>,\n \n         // Metadata to keep track of the state of the destructor. Remember that\n         // these variables are thread-local, not global.\n-        pub dtor_registered: UnsafeCell<bool>, // should be Cell\n-        pub dtor_running: UnsafeCell<bool>, // should be Cell\n+        dtor_registered: Cell<bool>,\n+        dtor_running: Cell<bool>,\n     }\n \n     unsafe impl<T> ::marker::Sync for Key<T> { }\n \n     impl<T> Key<T> {\n-        pub unsafe fn get(&'static self) -> Option<&'static T> {\n-            if intrinsics::needs_drop::<T>() && *self.dtor_running.get() {\n+        pub const fn new() -> Key<T> {\n+            Key {\n+                inner: UnsafeCell::new(None),\n+                dtor_registered: Cell::new(false),\n+                dtor_running: Cell::new(false)\n+            }\n+        }\n+\n+        pub unsafe fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n+            if intrinsics::needs_drop::<T>() && self.dtor_running.get() {\n                 return None\n             }\n             self.register_dtor();\n-            Some(&*self.inner.get())\n+            Some(&self.inner)\n         }\n \n         unsafe fn register_dtor(&self) {\n-            if !intrinsics::needs_drop::<T>() || *self.dtor_registered.get() {\n+            if !intrinsics::needs_drop::<T>() || self.dtor_registered.get() {\n                 return\n             }\n \n             register_dtor(self as *const _ as *mut u8,\n                           destroy_value::<T>);\n-            *self.dtor_registered.get() = true;\n+            self.dtor_registered.set(true);\n         }\n     }\n \n@@ -354,6 +300,7 @@ mod imp {\n     unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n         use boxed;\n         use mem;\n+        use ptr;\n         use libc;\n         use sys_common::thread_local as os;\n \n@@ -381,10 +328,7 @@ mod imp {\n         // *should* be the case that this loop always terminates because we\n         // provide the guarantee that a TLS key cannot be set after it is\n         // flagged for destruction.\n-        static DTORS: os::StaticKey = os::StaticKey {\n-            inner: os::INIT_INNER,\n-            dtor: Some(run_dtors as unsafe extern \"C\" fn(*mut u8)),\n-        };\n+        static DTORS: os::StaticKey = os::StaticKey::new(Some(run_dtors));\n         type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n         if DTORS.get().is_null() {\n             let v: Box<List> = box Vec::new();\n@@ -422,8 +366,8 @@ mod imp {\n         // Right before we run the user destructor be sure to flag the\n         // destructor as running for this thread so calls to `get` will return\n         // `None`.\n-        *(*ptr).dtor_running.get() = true;\n-        ptr::read((*ptr).inner.get());\n+        (*ptr).dtor_running.set(true);\n+        intrinsics::drop_in_place((*ptr).inner.get());\n     }\n }\n \n@@ -433,54 +377,50 @@ mod imp {\n     use prelude::v1::*;\n \n     use alloc::boxed;\n-    use cell::UnsafeCell;\n-    use mem;\n+    use cell::{Cell, UnsafeCell};\n+    use marker;\n     use ptr;\n     use sys_common::thread_local::StaticKey as OsStaticKey;\n \n     pub struct Key<T> {\n-        // Statically allocated initialization expression, using an `UnsafeCell`\n-        // for the same reasons as above.\n-        pub inner: UnsafeCell<T>,\n-\n         // OS-TLS key that we'll use to key off.\n-        pub os: OsStaticKey,\n+        os: OsStaticKey,\n+        marker: marker::PhantomData<Cell<T>>,\n     }\n \n     unsafe impl<T> ::marker::Sync for Key<T> { }\n \n     struct Value<T: 'static> {\n         key: &'static Key<T>,\n-        value: T,\n+        value: UnsafeCell<Option<T>>,\n     }\n \n-    impl<T> Key<T> {\n-        pub unsafe fn get(&'static self) -> Option<&'static T> {\n-            self.ptr().map(|p| &*p)\n+    impl<T: 'static> Key<T> {\n+        pub const fn new() -> Key<T> {\n+            Key {\n+                os: OsStaticKey::new(Some(destroy_value::<T>)),\n+                marker: marker::PhantomData\n+            }\n         }\n \n-        unsafe fn ptr(&'static self) -> Option<*mut T> {\n+        pub unsafe fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n             let ptr = self.os.get() as *mut Value<T>;\n             if !ptr.is_null() {\n                 if ptr as usize == 1 {\n                     return None\n                 }\n-                return Some(&mut (*ptr).value as *mut T);\n+                return Some(&(*ptr).value);\n             }\n \n             // If the lookup returned null, we haven't initialized our own local\n             // copy, so do that now.\n-            //\n-            // Also note that this transmute_copy should be ok because the value\n-            // `inner` is already validated to be a valid `static` value, so we\n-            // should be able to freely copy the bits.\n             let ptr: Box<Value<T>> = box Value {\n                 key: self,\n-                value: mem::transmute_copy(&self.inner),\n+                value: UnsafeCell::new(None),\n             };\n             let ptr = boxed::into_raw(ptr);\n             self.os.set(ptr as *mut u8);\n-            Some(&mut (*ptr).value as *mut T)\n+            Some(&(*ptr).value)\n         }\n     }\n \n@@ -505,7 +445,7 @@ mod tests {\n     use prelude::v1::*;\n \n     use sync::mpsc::{channel, Sender};\n-    use cell::UnsafeCell;\n+    use cell::{Cell, UnsafeCell};\n     use super::LocalKeyState;\n     use thread;\n \n@@ -520,23 +460,23 @@ mod tests {\n \n     #[test]\n     fn smoke_no_dtor() {\n-        thread_local!(static FOO: UnsafeCell<i32> = UnsafeCell { value: 1 });\n+        thread_local!(static FOO: Cell<i32> = Cell::new(1));\n \n-        FOO.with(|f| unsafe {\n-            assert_eq!(*f.get(), 1);\n-            *f.get() = 2;\n+        FOO.with(|f| {\n+            assert_eq!(f.get(), 1);\n+            f.set(2);\n         });\n         let (tx, rx) = channel();\n         let _t = thread::spawn(move|| {\n-            FOO.with(|f| unsafe {\n-                assert_eq!(*f.get(), 1);\n+            FOO.with(|f| {\n+                assert_eq!(f.get(), 1);\n             });\n             tx.send(()).unwrap();\n         });\n         rx.recv().unwrap();\n \n-        FOO.with(|f| unsafe {\n-            assert_eq!(*f.get(), 2);\n+        FOO.with(|f| {\n+            assert_eq!(f.get(), 2);\n         });\n     }\n \n@@ -565,9 +505,7 @@ mod tests {\n \n     #[test]\n     fn smoke_dtor() {\n-        thread_local!(static FOO: UnsafeCell<Option<Foo>> = UnsafeCell {\n-            value: None\n-        });\n+        thread_local!(static FOO: UnsafeCell<Option<Foo>> = UnsafeCell::new(None));\n \n         let (tx, rx) = channel();\n         let _t = thread::spawn(move|| unsafe {\n@@ -583,12 +521,8 @@ mod tests {\n     fn circular() {\n         struct S1;\n         struct S2;\n-        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell {\n-            value: None\n-        });\n-        thread_local!(static K2: UnsafeCell<Option<S2>> = UnsafeCell {\n-            value: None\n-        });\n+        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n+        thread_local!(static K2: UnsafeCell<Option<S2>> = UnsafeCell::new(None));\n         static mut HITS: u32 = 0;\n \n         impl Drop for S1 {\n@@ -626,9 +560,7 @@ mod tests {\n     #[test]\n     fn self_referential() {\n         struct S1;\n-        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell {\n-            value: None\n-        });\n+        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n \n         impl Drop for S1 {\n             fn drop(&mut self) {\n@@ -644,12 +576,8 @@ mod tests {\n     #[test]\n     fn dtors_in_dtors_in_dtors() {\n         struct S1(Sender<()>);\n-        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell {\n-            value: None\n-        });\n-        thread_local!(static K2: UnsafeCell<Option<Foo>> = UnsafeCell {\n-            value: None\n-        });\n+        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n+        thread_local!(static K2: UnsafeCell<Option<Foo>> = UnsafeCell::new(None));\n \n         impl Drop for S1 {\n             fn drop(&mut self) {"}, {"sha": "f090d3e77ddfc75a054717c49efa40f67b67f7e2", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -216,8 +216,7 @@ pub use self::local::{LocalKey, LocalKeyState};\n                       consider stabilizing its interface\")]\n pub use self::scoped_tls::ScopedKey;\n \n-#[doc(hidden)] pub use self::local::__impl as __local;\n-#[doc(hidden)] pub use self::scoped_tls::__impl as __scoped;\n+#[doc(hidden)] pub use self::local::__KeyInner as __LocalKeyInner;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Builder"}, {"sha": "dda1db9aecea4a80b3a5fa484311d229194a78de", "filename": "src/libstd/thread/scoped_tls.rs", "status": "modified", "additions": 26, "deletions": 65, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fthread%2Fscoped_tls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Flibstd%2Fthread%2Fscoped_tls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fscoped_tls.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -43,13 +43,6 @@\n \n use prelude::v1::*;\n \n-// macro hygiene sure would be nice, wouldn't it?\n-#[doc(hidden)]\n-pub mod __impl {\n-    pub use super::imp::KeyInner;\n-    pub use sys_common::thread_local::INIT as OS_INIT;\n-}\n-\n /// Type representing a thread local storage key corresponding to a reference\n /// to the type parameter `T`.\n ///\n@@ -60,7 +53,7 @@ pub mod __impl {\n #[unstable(feature = \"scoped_tls\",\n            reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n                      stabilizing its interface\")]\n-pub struct ScopedKey<T> { #[doc(hidden)] pub inner: __impl::KeyInner<T> }\n+pub struct ScopedKey<T> { inner: imp::KeyInner<T> }\n \n /// Declare a new scoped thread local storage key.\n ///\n@@ -71,18 +64,6 @@ pub struct ScopedKey<T> { #[doc(hidden)] pub inner: __impl::KeyInner<T> }\n #[macro_export]\n #[allow_internal_unstable]\n macro_rules! scoped_thread_local {\n-    (static $name:ident: $t:ty) => (\n-        __scoped_thread_local_inner!(static $name: $t);\n-    );\n-    (pub static $name:ident: $t:ty) => (\n-        __scoped_thread_local_inner!(pub static $name: $t);\n-    );\n-}\n-\n-#[macro_export]\n-#[doc(hidden)]\n-#[allow_internal_unstable]\n-macro_rules! __scoped_thread_local_inner {\n     (static $name:ident: $t:ty) => (\n         #[cfg_attr(not(any(windows,\n                            target_os = \"android\",\n@@ -91,7 +72,7 @@ macro_rules! __scoped_thread_local_inner {\n                            target_arch = \"aarch64\")),\n                    thread_local)]\n         static $name: ::std::thread::ScopedKey<$t> =\n-            __scoped_thread_local_inner!($t);\n+            ::std::thread::ScopedKey::new();\n     );\n     (pub static $name:ident: $t:ty) => (\n         #[cfg_attr(not(any(windows,\n@@ -101,42 +82,19 @@ macro_rules! __scoped_thread_local_inner {\n                            target_arch = \"aarch64\")),\n                    thread_local)]\n         pub static $name: ::std::thread::ScopedKey<$t> =\n-            __scoped_thread_local_inner!($t);\n+            ::std::thread::ScopedKey::new();\n     );\n-    ($t:ty) => ({\n-        use std::thread::ScopedKey as __Key;\n-\n-        #[cfg(not(any(windows,\n-                      target_os = \"android\",\n-                      target_os = \"ios\",\n-                      target_os = \"openbsd\",\n-                      target_arch = \"aarch64\")))]\n-        const _INIT: __Key<$t> = __Key {\n-            inner: ::std::thread::__scoped::KeyInner {\n-                inner: ::std::cell::UnsafeCell { value: 0 as *mut _ },\n-            }\n-        };\n-\n-        #[cfg(any(windows,\n-                  target_os = \"android\",\n-                  target_os = \"ios\",\n-                  target_os = \"openbsd\",\n-                  target_arch = \"aarch64\"))]\n-        const _INIT: __Key<$t> = __Key {\n-            inner: ::std::thread::__scoped::KeyInner {\n-                inner: ::std::thread::__scoped::OS_INIT,\n-                marker: ::std::marker::PhantomData::<::std::cell::Cell<$t>>,\n-            }\n-        };\n-\n-        _INIT\n-    })\n }\n \n #[unstable(feature = \"scoped_tls\",\n            reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n                      stabilizing its interface\")]\n impl<T> ScopedKey<T> {\n+    #[doc(hidden)]\n+    pub const fn new() -> ScopedKey<T> {\n+        ScopedKey { inner: imp::KeyInner::new() }\n+    }\n+\n     /// Inserts a value into this scoped thread local storage slot for a\n     /// duration of a closure.\n     ///\n@@ -170,7 +128,7 @@ impl<T> ScopedKey<T> {\n         F: FnOnce() -> R,\n     {\n         struct Reset<'a, T: 'a> {\n-            key: &'a __impl::KeyInner<T>,\n+            key: &'a imp::KeyInner<T>,\n             val: *mut T,\n         }\n                 impl<'a, T> Drop for Reset<'a, T> {\n@@ -231,19 +189,18 @@ impl<T> ScopedKey<T> {\n               target_os = \"openbsd\",\n               target_arch = \"aarch64\")))]\n mod imp {\n-    use std::cell::UnsafeCell;\n+    use std::cell::Cell;\n \n-    #[doc(hidden)]\n-    pub struct KeyInner<T> { pub inner: UnsafeCell<*mut T> }\n+    pub struct KeyInner<T> { inner: Cell<*mut T> }\n \n     unsafe impl<T> ::marker::Sync for KeyInner<T> { }\n \n-    #[doc(hidden)]\n     impl<T> KeyInner<T> {\n-        #[doc(hidden)]\n-        pub unsafe fn set(&self, ptr: *mut T) { *self.inner.get() = ptr; }\n-        #[doc(hidden)]\n-        pub unsafe fn get(&self) -> *mut T { *self.inner.get() }\n+        pub const fn new() -> KeyInner<T> {\n+            KeyInner { inner: Cell::new(0 as *mut _) }\n+        }\n+        pub unsafe fn set(&self, ptr: *mut T) { self.inner.set(ptr); }\n+        pub unsafe fn get(&self) -> *mut T { self.inner.get() }\n     }\n }\n \n@@ -253,23 +210,27 @@ mod imp {\n           target_os = \"openbsd\",\n           target_arch = \"aarch64\"))]\n mod imp {\n+    use prelude::v1::*;\n+\n+    use cell::Cell;\n     use marker;\n-    use std::cell::Cell;\n     use sys_common::thread_local::StaticKey as OsStaticKey;\n \n-    #[doc(hidden)]\n     pub struct KeyInner<T> {\n         pub inner: OsStaticKey,\n         pub marker: marker::PhantomData<Cell<T>>,\n     }\n \n-    unsafe impl<T> ::marker::Sync for KeyInner<T> { }\n+    unsafe impl<T> marker::Sync for KeyInner<T> { }\n \n-    #[doc(hidden)]\n     impl<T> KeyInner<T> {\n-        #[doc(hidden)]\n+        pub const fn new() -> KeyInner<T> {\n+            KeyInner {\n+                inner: OsStaticKey::new(None),\n+                marker: marker::PhantomData\n+            }\n+        }\n         pub unsafe fn set(&self, ptr: *mut T) { self.inner.set(ptr as *mut _) }\n-        #[doc(hidden)]\n         pub unsafe fn get(&self) -> *mut T { self.inner.get() as *mut _ }\n     }\n }"}, {"sha": "b347e674f0a9f1995def749c41c9d5ebd2240e72", "filename": "src/test/auxiliary/issue-17718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fauxiliary%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fauxiliary%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-17718.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -11,12 +11,12 @@\n use std::sync::atomic;\n \n pub const C1: usize = 1;\n-pub const C2: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+pub const C2: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n pub const C3: fn() = foo;\n pub const C4: usize = C1 * C1 + C1 / C1;\n pub const C5: &'static usize = &C4;\n \n pub static S1: usize = 3;\n-pub static S2: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+pub static S2: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n \n fn foo() {}"}, {"sha": "c9713ebcebe986dccee88d3b11266d90d7044820", "filename": "src/test/compile-fail/dropck_arr_cycle_checked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -18,9 +18,9 @@ use id::Id;\n \n mod s {\n     #![allow(unstable)]\n-    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n \n-    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n+    static S_COUNT: AtomicUsize = AtomicUsize::new(0);\n \n     pub fn next_count() -> usize {\n         S_COUNT.fetch_add(1, Ordering::SeqCst) + 1"}, {"sha": "9309f5a243cd38408d13987af80cacc2d37f4f5b", "filename": "src/test/compile-fail/dropck_tarena_cycle_checked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -26,9 +26,9 @@ use id::Id;\n \n mod s {\n     #![allow(unstable)]\n-    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n \n-    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n+    static S_COUNT: AtomicUsize = AtomicUsize::new(0);\n \n     pub fn next_count() -> usize {\n         S_COUNT.fetch_add(1, Ordering::SeqCst) + 1"}, {"sha": "1d8c7e9ac3e823e7b8647a7d1b0f976976b17180", "filename": "src/test/compile-fail/dropck_trait_cycle_checked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -17,9 +17,9 @@ use std::cell::Cell;\n use id::Id;\n \n mod s {\n-    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n \n-    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n+    static S_COUNT: AtomicUsize = AtomicUsize::new(0);\n \n     pub fn next_count() -> usize {\n         S_COUNT.fetch_add(1, Ordering::SeqCst) + 1"}, {"sha": "8722246bb4eaa513f3551d40e2f70411a633c407", "filename": "src/test/compile-fail/dropck_vec_cycle_checked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -17,9 +17,9 @@ use id::Id;\n \n mod s {\n     #![allow(unstable)]\n-    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n \n-    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n+    static S_COUNT: AtomicUsize = AtomicUsize::new(0);\n \n     pub fn next_count() -> usize {\n         S_COUNT.fetch_add(1, Ordering::SeqCst) + 1"}, {"sha": "3f41401eb69c12275b58d7968e2526f8bc0204d7", "filename": "src/test/compile-fail/functional-struct-update-respects-privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-respects-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-respects-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-respects-privacy.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -16,7 +16,7 @@ use self::foo::S;\n mod foo {\n     use std::cell::{UnsafeCell};\n \n-    static mut count : UnsafeCell<u64> = UnsafeCell { value: 1 };\n+    static mut count : UnsafeCell<u64> = UnsafeCell::new(1);\n \n     pub struct S { pub a: u8, pub b: String, secret_uid: u64 }\n "}, {"sha": "12a9a27463157e5eeab176d17fcb275d94256995", "filename": "src/test/compile-fail/issue-17718-const-borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-borrow.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -10,12 +10,12 @@\n \n use std::cell::UnsafeCell;\n \n-const A: UnsafeCell<usize> = UnsafeCell { value: 1 };\n+const A: UnsafeCell<usize> = UnsafeCell::new(1);\n const B: &'static UnsafeCell<usize> = &A;\n //~^ ERROR: cannot borrow a constant which contains interior mutability\n \n struct C { a: UnsafeCell<usize> }\n-const D: C = C { a: UnsafeCell { value: 1 } };\n+const D: C = C { a: UnsafeCell::new(1) };\n const E: &'static UnsafeCell<usize> = &D.a;\n //~^ ERROR: cannot borrow a constant which contains interior mutability\n const F: &'static C = &D;"}, {"sha": "999e5f9db2dfc05d5a0c0d9117252fa5f41c69c7", "filename": "src/test/compile-fail/issue-7364.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -17,6 +17,5 @@ static boxed: Box<RefCell<isize>> = box RefCell::new(0);\n //~^ ERROR allocations are not allowed in statics\n //~| ERROR the trait `core::marker::Sync` is not implemented for the type\n //~| ERROR the trait `core::marker::Sync` is not implemented for the type\n-//~| ERROR E0015\n \n fn main() { }"}, {"sha": "35877db610e34e70607b613ab73968120ff153ab", "filename": "src/test/compile-fail/std-uncopyable-atomics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -15,11 +15,11 @@ use std::sync::atomic::*;\n use std::ptr;\n \n fn main() {\n-    let x = ATOMIC_BOOL_INIT;\n+    let x = AtomicBool::new(false);\n     let x = *&x; //~ ERROR: cannot move out of borrowed content\n-    let x = ATOMIC_ISIZE_INIT;\n+    let x = AtomicIsize::new(0);\n     let x = *&x; //~ ERROR: cannot move out of borrowed content\n-    let x = ATOMIC_USIZE_INIT;\n+    let x = AtomicUsize::new(0);\n     let x = *&x; //~ ERROR: cannot move out of borrowed content\n     let x: AtomicPtr<usize> = AtomicPtr::new(ptr::null_mut());\n     let x = *&x; //~ ERROR: cannot move out of borrowed content"}, {"sha": "0b2112edf728069dc39a341a628eb103695a07a8", "filename": "src/test/compile-fail/vec-must-not-hide-type-from-dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -28,9 +28,9 @@ use id::Id;\n \n mod s {\n     #![allow(unstable)]\n-    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n \n-    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n+    static S_COUNT: AtomicUsize = AtomicUsize::new(0);\n \n     /// generates globally unique count (global across the current\n     /// process, that is)"}, {"sha": "72448ca2e001fc823b0dba9df9b71615e3babdb4", "filename": "src/test/debuginfo/constant-debug-locs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -19,7 +19,7 @@\n // This test makes sure that the compiler doesn't crash when trying to assign\n // debug locations to const-expressions.\n \n-use std::sync::MUTEX_INIT;\n+use std::sync::StaticMutex;\n use std::cell::UnsafeCell;\n \n const CONSTANT: u64 = 3 + 4;\n@@ -49,7 +49,7 @@ const VEC: [u32; 8] = [0; 8];\n \n const NESTED: (Struct, TupleStruct) = (STRUCT, TUPLE_STRUCT);\n \n-const UNSAFE_CELL: UnsafeCell<bool> = UnsafeCell { value: false };\n+const UNSAFE_CELL: UnsafeCell<bool> = UnsafeCell::new(false);\n \n fn main() {\n     let mut _constant = CONSTANT;\n@@ -61,6 +61,6 @@ fn main() {\n     let mut _string = STRING;\n     let mut _vec = VEC;\n     let mut _nested = NESTED;\n-    let mut _extern = MUTEX_INIT;\n+    let mut _extern = StaticMutex::new();\n     let mut _unsafe_cell = UNSAFE_CELL;\n }"}, {"sha": "2c3d7ef39e497123ab6ff1c749a20f792c40f1af", "filename": "src/test/run-pass-valgrind/cast-enum-with-dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -22,7 +22,7 @@ enum E {\n     C = 2\n }\n \n-static FLAG: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+static FLAG: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n \n impl Drop for E {\n     fn drop(&mut self) {"}, {"sha": "5ceb1013ad811dae95339b9f71300b0bac42e718", "filename": "src/test/run-pass/associated-types-project-from-type-param-via-bound-in-where-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -13,10 +13,10 @@\n // `T`. Issue #20300.\n \n use std::marker::{PhantomData};\n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n+use std::sync::atomic::{AtomicUsize};\n use std::sync::atomic::Ordering::SeqCst;\n \n-static COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n+static COUNTER: AtomicUsize = AtomicUsize::new(0);\n \n // Preamble.\n trait Trait { type Item; }"}, {"sha": "1c7359a0fad9d40b08480babf181df99a9b3da41", "filename": "src/test/run-pass/box-of-array-of-drop-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-1.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -12,9 +12,9 @@\n // destructor.\n \n use std::thread;\n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n \n-static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+static LOG: AtomicUsize = AtomicUsize::new(0);\n \n struct D(u8);\n "}, {"sha": "ad781f00356d715c3efc976c521eb9bc2dd13dd8", "filename": "src/test/run-pass/box-of-array-of-drop-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-2.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -12,9 +12,9 @@\n // destructor.\n \n use std::thread;\n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n \n-static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+static LOG: AtomicUsize = AtomicUsize::new(0);\n \n struct D(u8);\n "}, {"sha": "c18d51e84d84f5ffaf829318d6df83ebc88a0fef", "filename": "src/test/run-pass/issue-17718-static-unsafe-interior.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -38,8 +38,8 @@ unsafe impl<T: Send> Sync for UnsafeEnum<T> {}\n \n static STATIC1: UnsafeEnum<isize> = UnsafeEnum::VariantSafe;\n \n-static STATIC2: MyUnsafePack<isize> = MyUnsafePack(UnsafeCell { value: 1 });\n-const CONST: MyUnsafePack<isize> = MyUnsafePack(UnsafeCell { value: 1 });\n+static STATIC2: MyUnsafePack<isize> = MyUnsafePack(UnsafeCell::new(1));\n+const CONST: MyUnsafePack<isize> = MyUnsafePack(UnsafeCell::new(1));\n static STATIC3: MyUnsafe<isize> = MyUnsafe{value: CONST};\n \n static STATIC4: &'static MyUnsafePack<isize> = &STATIC2;\n@@ -50,7 +50,7 @@ struct Wrap<T> {\n \n unsafe impl<T: Send> Sync for Wrap<T> {}\n \n-static UNSAFE: MyUnsafePack<isize> = MyUnsafePack(UnsafeCell{value: 2});\n+static UNSAFE: MyUnsafePack<isize> = MyUnsafePack(UnsafeCell::new(2));\n static WRAPPED_UNSAFE: Wrap<&'static MyUnsafePack<isize>> = Wrap { value: &UNSAFE };\n \n fn main() {"}, {"sha": "457bbb23e18204a9e5251bbc6802631581a9115e", "filename": "src/test/run-pass/issue-17718.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -15,10 +15,10 @@\n \n extern crate issue_17718 as other;\n \n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n \n const C1: usize = 1;\n-const C2: AtomicUsize = ATOMIC_USIZE_INIT;\n+const C2: AtomicUsize = AtomicUsize::new(0);\n const C3: fn() = foo;\n const C4: usize = C1 * C1 + C1 / C1;\n const C5: &'static usize = &C4;\n@@ -28,7 +28,7 @@ const C6: usize = {\n };\n \n static S1: usize = 3;\n-static S2: AtomicUsize = ATOMIC_USIZE_INIT;\n+static S2: AtomicUsize = AtomicUsize::new(0);\n \n mod test {\n     static A: usize = 4;"}, {"sha": "c20237f1f86b462aa4c38f31bfbfb60a2f20aec8", "filename": "src/test/run-pass/issue-21486.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fissue-21486.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fissue-21486.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21486.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -13,7 +13,7 @@\n // construction.\n \n \n-use std::sync::atomic::{Ordering, AtomicUsize, ATOMIC_USIZE_INIT};\n+use std::sync::atomic::{Ordering, AtomicUsize};\n \n #[derive(Debug)]\n struct Noisy(u8);\n@@ -69,7 +69,7 @@ pub fn main() {\n     assert_eq!(0x03_04, event_log());\n }\n \n-static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+static LOG: AtomicUsize = AtomicUsize::new(0);\n \n fn reset_log() {\n     LOG.store(0, Ordering::SeqCst);"}, {"sha": "e59900caf07ec50be8869c5e1592b4b6b31d93f4", "filename": "src/test/run-pass/nested-vec-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fnested-vec-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fnested-vec-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-vec-3.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -14,9 +14,9 @@\n \n \n use std::thread;\n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n \n-static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+static LOG: AtomicUsize = AtomicUsize::new(0);\n \n struct D(u8);\n "}, {"sha": "c0ed4ea3ce82f63a7084198ea62d089f61988212", "filename": "src/test/run-pass/struct-order-of-eval-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-3.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -12,7 +12,7 @@\n // even when no Drop-implementations are involved.\n \n \n-use std::sync::atomic::{Ordering, AtomicUsize, ATOMIC_USIZE_INIT};\n+use std::sync::atomic::{Ordering, AtomicUsize};\n \n struct W { wrapped: u32 }\n struct S { f0: W, _f1: i32 }\n@@ -34,7 +34,7 @@ pub fn main() {\n             \"expect: 0x{:x} actual: 0x{:x}\", expect, actual);\n }\n \n-static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+static LOG: AtomicUsize = AtomicUsize::new(0);\n \n fn event_log() -> usize {\n     LOG.load(Ordering::SeqCst)"}, {"sha": "83ea0e3ab74eab2babbfbe933ded8c0ff0113f4e", "filename": "src/test/run-pass/struct-order-of-eval-4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-4.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -12,7 +12,7 @@\n // even when no Drop-implementations are involved.\n \n \n-use std::sync::atomic::{Ordering, AtomicUsize, ATOMIC_USIZE_INIT};\n+use std::sync::atomic::{Ordering, AtomicUsize};\n \n struct W { wrapped: u32 }\n struct S { f0: W, _f1: i32 }\n@@ -31,7 +31,7 @@ pub fn main() {\n             \"expect: 0x{:x} actual: 0x{:x}\", expect, actual);\n }\n \n-static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+static LOG: AtomicUsize = AtomicUsize::new(0);\n \n fn event_log() -> usize {\n     LOG.load(Ordering::SeqCst)"}, {"sha": "f3c4ecb035e51da3d76ae5c02e5c07ba869b6a73", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b0900aede976b2d37a499bbd7b62c2e39b358/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=377b0900aede976b2d37a499bbd7b62c2e39b358", "patch": "@@ -11,7 +11,7 @@\n \n #![feature(rand, core)]\n \n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n use std::__rand::{thread_rng, Rng};\n use std::thread;\n \n@@ -20,20 +20,20 @@ const MAX_LEN: usize = 32;\n static drop_counts: [AtomicUsize;  MAX_LEN] =\n     // FIXME #5244: AtomicUsize is not Copy.\n     [\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n-        ATOMIC_USIZE_INIT, ATOMIC_USIZE_INIT,\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+        AtomicUsize::new(0), AtomicUsize::new(0),\n      ];\n \n-static creation_count: AtomicUsize = ATOMIC_USIZE_INIT;\n+static creation_count: AtomicUsize = AtomicUsize::new(0);\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord)]\n struct DropCounter { x: u32, creation_id: usize }"}]}