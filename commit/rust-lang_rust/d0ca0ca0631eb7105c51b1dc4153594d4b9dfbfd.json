{"sha": "d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwY2EwY2EwNjMxZWI3MTA1YzUxYjFkYzQxNTM1OTRkNGI5ZGZiZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-19T08:50:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-19T08:50:53Z"}, "message": "Auto merge of #33694 - arielb1:fuzzy-on-unimplemented, r=nikomatsakis\n\nimplement fuzzy matching in on_unimplemented\n\nFixes #31062\n\nr? @nikomatsakis", "tree": {"sha": "f347778c327fcff46b8a18727b61f257a2c0c5dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f347778c327fcff46b8a18727b61f257a2c0c5dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd", "html_url": "https://github.com/rust-lang/rust/commit/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c5d651d0bb9e0471795bd743c8ecfd8f9a89844", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c5d651d0bb9e0471795bd743c8ecfd8f9a89844", "html_url": "https://github.com/rust-lang/rust/commit/0c5d651d0bb9e0471795bd743c8ecfd8f9a89844"}, {"sha": "b9a201c6dff196fc759fb1f1d3d292691fc5d99a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9a201c6dff196fc759fb1f1d3d292691fc5d99a", "html_url": "https://github.com/rust-lang/rust/commit/b9a201c6dff196fc759fb1f1d3d292691fc5d99a"}], "stats": {"total": 211, "additions": 165, "deletions": 46}, "files": [{"sha": "542dfcbe6284f7b1111a4fbb4692706561dc266f", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd", "patch": "@@ -523,8 +523,7 @@ impl<T> SliceExt for [T] {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(unused_attributes)]\n-#[rustc_on_unimplemented = \"a usize is required to index into a slice\"]\n+#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n impl<T> ops::Index<usize> for [T] {\n     type Output = T;\n \n@@ -535,8 +534,7 @@ impl<T> ops::Index<usize> for [T] {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(unused_attributes)]\n-#[rustc_on_unimplemented = \"a usize is required to index into a slice\"]\n+#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n impl<T> ops::IndexMut<usize> for [T] {\n     #[inline]\n     fn index_mut(&mut self, index: usize) -> &mut T {\n@@ -570,6 +568,7 @@ fn slice_index_order_fail(index: usize, end: usize) -> ! {\n /// Requires that `begin <= end` and `end <= self.len()`,\n /// otherwise slicing will panic.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n impl<T> ops::Index<ops::Range<usize>> for [T] {\n     type Output = [T];\n \n@@ -596,6 +595,7 @@ impl<T> ops::Index<ops::Range<usize>> for [T] {\n ///\n /// Equivalent to `&self[0 .. end]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n     type Output = [T];\n \n@@ -611,6 +611,7 @@ impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n ///\n /// Equivalent to `&self[begin .. self.len()]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n impl<T> ops::Index<ops::RangeFrom<usize>> for [T] {\n     type Output = [T];\n \n@@ -636,6 +637,7 @@ impl<T> ops::Index<RangeFull> for [T] {\n }\n \n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n impl<T> ops::Index<ops::RangeInclusive<usize>> for [T] {\n     type Output = [T];\n \n@@ -651,6 +653,7 @@ impl<T> ops::Index<ops::RangeInclusive<usize>> for [T] {\n     }\n }\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n impl<T> ops::Index<ops::RangeToInclusive<usize>> for [T] {\n     type Output = [T];\n \n@@ -671,6 +674,7 @@ impl<T> ops::Index<ops::RangeToInclusive<usize>> for [T] {\n /// Requires that `begin <= end` and `end <= self.len()`,\n /// otherwise slicing will panic.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n     #[inline]\n     fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n@@ -695,6 +699,7 @@ impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n ///\n /// Equivalent to `&mut self[0 .. end]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for [T] {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n@@ -708,6 +713,7 @@ impl<T> ops::IndexMut<ops::RangeTo<usize>> for [T] {\n ///\n /// Equivalent to `&mut self[begin .. self.len()]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n@@ -730,6 +736,7 @@ impl<T> ops::IndexMut<RangeFull> for [T] {\n }\n \n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n impl<T> ops::IndexMut<ops::RangeInclusive<usize>> for [T] {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut [T] {\n@@ -743,6 +750,7 @@ impl<T> ops::IndexMut<ops::RangeInclusive<usize>> for [T] {\n     }\n }\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n impl<T> ops::IndexMut<ops::RangeToInclusive<usize>> for [T] {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut [T] {\n@@ -1933,4 +1941,3 @@ macro_rules! impl_marker_for {\n \n impl_marker_for!(BytewiseEquality,\n                  u8 i8 u16 i16 u32 i32 u64 i64 usize isize char bool);\n-"}, {"sha": "9a69958fea01432a3b2ad518e91d7784d8ed4f4d", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 72, "deletions": 26, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd", "patch": "@@ -30,7 +30,7 @@ use infer::{InferCtxt};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n-use ty::subst::{self, Subst};\n+use ty::subst::{self, Subst, TypeSpace};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use std::cmp;\n@@ -135,65 +135,111 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         let ity = tcx.lookup_item_type(did);\n         let (tps, rps, _) =\n-            (ity.generics.types.get_slice(subst::TypeSpace),\n-             ity.generics.regions.get_slice(subst::TypeSpace),\n+            (ity.generics.types.get_slice(TypeSpace),\n+             ity.generics.regions.get_slice(TypeSpace),\n              ity.ty);\n \n         let rps = self.region_vars_for_defs(obligation.cause.span, rps);\n         let mut substs = subst::Substs::new(\n             subst::VecPerParamSpace::empty(),\n             subst::VecPerParamSpace::new(rps, Vec::new(), Vec::new()));\n         self.type_vars_for_defs(obligation.cause.span,\n-                                subst::ParamSpace::TypeSpace,\n+                                TypeSpace,\n                                 &mut substs,\n                                 tps);\n         substs\n     }\n \n-    fn impl_with_self_type_of(&self,\n-                              trait_ref: ty::PolyTraitRef<'tcx>,\n-                              obligation: &PredicateObligation<'tcx>)\n-                              -> Option<DefId>\n+    fn fuzzy_match_tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+        /// returns the fuzzy category of a given type, or None\n+        /// if the type can be equated to any type.\n+        fn type_category<'tcx>(t: Ty<'tcx>) -> Option<u32> {\n+            match t.sty {\n+                ty::TyBool => Some(0),\n+                ty::TyChar => Some(1),\n+                ty::TyStr => Some(2),\n+                ty::TyInt(..) | ty::TyUint(..) |\n+                ty::TyInfer(ty::IntVar(..)) => Some(3),\n+                ty::TyFloat(..) | ty::TyInfer(ty::FloatVar(..)) => Some(4),\n+                ty::TyEnum(..) => Some(5),\n+                ty::TyStruct(..) => Some(6),\n+                ty::TyBox(..) | ty::TyRef(..) | ty::TyRawPtr(..) => Some(7),\n+                ty::TyArray(..) | ty::TySlice(..) => Some(8),\n+                ty::TyFnDef(..) | ty::TyFnPtr(..) => Some(9),\n+                ty::TyTrait(..) => Some(10),\n+                ty::TyClosure(..) => Some(11),\n+                ty::TyTuple(..) => Some(12),\n+                ty::TyProjection(..) => Some(13),\n+                ty::TyParam(..) => Some(14),\n+                ty::TyInfer(..) | ty::TyError => None\n+            }\n+        }\n+\n+        match (type_category(a), type_category(b)) {\n+            (Some(cat_a), Some(cat_b)) => match (&a.sty, &b.sty) {\n+                (&ty::TyStruct(def_a, _), &ty::TyStruct(def_b, _)) |\n+                (&ty::TyEnum(def_a, _), &ty::TyEnum(def_b, _)) =>\n+                    def_a == def_b,\n+                _ => cat_a == cat_b\n+            },\n+            // infer and error can be equated to all types\n+            _ => true\n+        }\n+    }\n+\n+    fn impl_similar_to(&self,\n+                       trait_ref: ty::PolyTraitRef<'tcx>,\n+                       obligation: &PredicateObligation<'tcx>)\n+                       -> Option<DefId>\n     {\n         let tcx = self.tcx;\n-        let mut result = None;\n-        let mut ambiguous = false;\n \n-        let trait_self_ty = tcx.erase_late_bound_regions(&trait_ref).self_ty();\n+        let trait_ref = tcx.erase_late_bound_regions(&trait_ref);\n+        let trait_self_ty = trait_ref.self_ty();\n \n-        if trait_self_ty.is_ty_var() {\n-            return None;\n-        }\n+        let mut self_match_impls = vec![];\n+        let mut fuzzy_match_impls = vec![];\n \n-        self.tcx.lookup_trait_def(trait_ref.def_id())\n+        self.tcx.lookup_trait_def(trait_ref.def_id)\n             .for_each_relevant_impl(self.tcx, trait_self_ty, |def_id| {\n-                let impl_self_ty = tcx\n+                let impl_trait_ref = tcx\n                     .impl_trait_ref(def_id)\n                     .unwrap()\n-                    .self_ty()\n                     .subst(tcx, &self.impl_substs(def_id, obligation.clone()));\n \n-                if !tcx.has_attr(def_id, \"rustc_on_unimplemented\") {\n-                    return;\n-                }\n+                let impl_self_ty = impl_trait_ref.self_ty();\n \n                 if let Ok(..) = self.can_equate(&trait_self_ty, &impl_self_ty) {\n-                    ambiguous = result.is_some();\n-                    result = Some(def_id);\n+                    self_match_impls.push(def_id);\n+\n+                    if trait_ref.substs.types.get_slice(TypeSpace).iter()\n+                        .zip(impl_trait_ref.substs.types.get_slice(TypeSpace))\n+                        .all(|(u,v)| self.fuzzy_match_tys(u, v))\n+                    {\n+                        fuzzy_match_impls.push(def_id);\n+                    }\n                 }\n             });\n \n-        if ambiguous {\n-            None\n+        let impl_def_id = if self_match_impls.len() == 1 {\n+            self_match_impls[0]\n+        } else if fuzzy_match_impls.len() == 1 {\n+            fuzzy_match_impls[0]\n         } else {\n-            result\n+            return None\n+        };\n+\n+        if tcx.has_attr(impl_def_id, \"rustc_on_unimplemented\") {\n+            Some(impl_def_id)\n+        } else {\n+            None\n         }\n     }\n \n     fn on_unimplemented_note(&self,\n                              trait_ref: ty::PolyTraitRef<'tcx>,\n                              obligation: &PredicateObligation<'tcx>) -> Option<String> {\n-        let def_id = self.impl_with_self_type_of(trait_ref, obligation)\n+        let def_id = self.impl_similar_to(trait_ref, obligation)\n             .unwrap_or(trait_ref.def_id());\n         let trait_ref = trait_ref.skip_binder();\n "}, {"sha": "2b972af07ff91f64120c79bd46ba9e620eed9a67", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd", "patch": "@@ -247,8 +247,7 @@ pub const tag_rustc_version: usize = 0x10f;\n pub fn rustc_version() -> String {\n     format!(\n         \"rustc {}\",\n-//        option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\")\n-        \"nightly edition\"\n+        option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\")\n     )\n }\n "}, {"sha": "264003bb62b816d02d0021842b4c4e7545a28c76", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd", "patch": "@@ -732,17 +732,26 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n           let impl_def_id = ccx.tcx.map.local_def_id(it.id);\n           match ccx.tcx.impl_trait_ref(impl_def_id) {\n               Some(impl_trait_ref) => {\n-                check_impl_items_against_trait(ccx,\n-                                               it.span,\n-                                               impl_def_id,\n-                                               &impl_trait_ref,\n-                                               impl_items);\n+                  let trait_def_id = impl_trait_ref.def_id;\n+\n+                  check_impl_items_against_trait(ccx,\n+                                                 it.span,\n+                                                 impl_def_id,\n+                                                 &impl_trait_ref,\n+                                                 impl_items);\n+                  check_on_unimplemented(\n+                      ccx,\n+                      &ccx.tcx.lookup_trait_def(trait_def_id).generics,\n+                      it,\n+                      ccx.tcx.item_name(trait_def_id));\n               }\n               None => { }\n           }\n       }\n-      hir::ItemTrait(_, ref generics, _, _) => {\n-        check_trait_on_unimplemented(ccx, generics, it);\n+      hir::ItemTrait(..) => {\n+        let def_id = ccx.tcx.map.local_def_id(it.id);\n+        let generics = &ccx.tcx.lookup_trait_def(def_id).generics;\n+        check_on_unimplemented(ccx, generics, it, it.name);\n       }\n       hir::ItemStruct(..) => {\n         check_struct(ccx, it.id, it.span);\n@@ -854,15 +863,16 @@ fn check_trait_fn_not_const<'a,'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                               generics: &hir::Generics,\n-                               item: &hir::Item) {\n+fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                    generics: &ty::Generics,\n+                                    item: &hir::Item,\n+                                    name: ast::Name) {\n     if let Some(ref attr) = item.attrs.iter().find(|a| {\n         a.check_name(\"rustc_on_unimplemented\")\n     }) {\n         if let Some(ref istring) = attr.value_str() {\n             let parser = Parser::new(&istring);\n-            let types = &generics.ty_params;\n+            let types = &generics.types;\n             for token in parser {\n                 match token {\n                     Piece::String(_) => (), // Normal string, no need to check it\n@@ -878,7 +888,7 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 span_err!(ccx.tcx.sess, attr.span, E0230,\n                                                  \"there is no type parameter \\\n                                                           {} on trait {}\",\n-                                                           s, item.name);\n+                                                           s, name);\n                             }\n                         },\n                         // `{:1}` and `{}` are not to be used"}, {"sha": "8580749084d22da1b39a356468d43611f01a0c57", "filename": "src/test/compile-fail/on-unimplemented/bad-annotation.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fbad-annotation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fbad-annotation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fbad-annotation.rs?ref=d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd", "previous_filename": "src/test/compile-fail/on-unimplemented-bad-anno.rs"}, {"sha": "0df8c41ffe1a8e52ae7fa2f710305af478c78348", "filename": "src/test/compile-fail/on-unimplemented/multiple-impls.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fmultiple-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fmultiple-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fmultiple-impls.rs?ref=d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test if the on_unimplemented message override works\n+\n+#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n+\n+struct Foo<T>(T);\n+struct Bar<T>(T);\n+\n+#[rustc_on_unimplemented = \"trait message\"]\n+trait Index<Idx: ?Sized> {\n+    type Output: ?Sized;\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+#[rustc_on_unimplemented = \"on impl for Foo\"]\n+impl Index<Foo<usize>> for [i32] {\n+    type Output = i32;\n+    fn index(&self, _index: Foo<usize>) -> &i32 {\n+        loop {}\n+    }\n+}\n+\n+#[rustc_on_unimplemented = \"on impl for Bar\"]\n+impl Index<Bar<usize>> for [i32] {\n+    type Output = i32;\n+    fn index(&self, _index: Bar<usize>) -> &i32 {\n+        loop {}\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() {\n+    Index::index(&[] as &[i32], 2u32);\n+    //~^ ERROR E0277\n+    //~| NOTE trait message\n+    //~| NOTE required by\n+    Index::index(&[] as &[i32], Foo(2u32));\n+    //~^ ERROR E0277\n+    //~| NOTE on impl for Foo\n+    //~| NOTE required by\n+    Index::index(&[] as &[i32], Bar(2u32));\n+    //~^ ERROR E0277\n+    //~| NOTE on impl for Bar\n+    //~| NOTE required by\n+}"}, {"sha": "4471b625d7912fd4b79ac1913aaaa3cb687e4774", "filename": "src/test/compile-fail/on-unimplemented/on-impl.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-impl.rs?ref=d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd", "previous_filename": "src/test/compile-fail/check_on_unimplemented.rs"}, {"sha": "39ce1b33ca13122b275642f24761987f645aab0f", "filename": "src/test/compile-fail/on-unimplemented/on-trait.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs?ref=d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd", "previous_filename": "src/test/compile-fail/on-unimplemented.rs"}, {"sha": "6a8f9d471e1692254619e788ed400abfec7299a3", "filename": "src/test/compile-fail/on-unimplemented/slice-index.rs", "status": "renamed", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fslice-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fslice-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fslice-index.rs?ref=d0ca0ca0631eb7105c51b1dc4153594d4b9dfbfd", "patch": "@@ -18,5 +18,7 @@ use std::ops::Index;\n fn main() {\n     let x = &[1, 2, 3] as &[i32];\n     x[1i32]; //~ ERROR E0277\n-             //~| NOTE a usize is required\n+             //~| NOTE slice indices are of type `usize`\n+    x[..1i32]; //~ ERROR E0277\n+               //~| NOTE slice indices are of type `usize`\n }", "previous_filename": "src/test/compile-fail/check_on_unimplemented_on_slice.rs"}]}