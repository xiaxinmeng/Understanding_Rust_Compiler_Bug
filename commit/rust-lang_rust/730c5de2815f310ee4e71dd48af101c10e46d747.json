{"sha": "730c5de2815f310ee4e71dd48af101c10e46d747", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMGM1ZGUyODE1ZjMxMGVlNGU3MWRkNDhhZjEwMWMxMGU0NmQ3NDc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-09-02T01:57:56Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-09-10T21:30:44Z"}, "message": "resolve: Support resolving identifier macros without their own ID\n\nInvocation/expansion ID (aka `Mark`) is not really necessary for resolving a macro path.\nWhat is really necessary is its parent module, parent expansion and parent legacy scope.\nThis is required for validation resolutions of built-in attributes, which don't get their own `Mark`s", "tree": {"sha": "bb0003d21981010ddbb0235eaf69c11c6a6746ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb0003d21981010ddbb0235eaf69c11c6a6746ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/730c5de2815f310ee4e71dd48af101c10e46d747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/730c5de2815f310ee4e71dd48af101c10e46d747", "html_url": "https://github.com/rust-lang/rust/commit/730c5de2815f310ee4e71dd48af101c10e46d747", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/730c5de2815f310ee4e71dd48af101c10e46d747/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "551244f05b92f90fe327f8f0a6d9a6e674eaab1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/551244f05b92f90fe327f8f0a6d9a6e674eaab1b", "html_url": "https://github.com/rust-lang/rust/commit/551244f05b92f90fe327f8f0a6d9a6e674eaab1b"}], "stats": {"total": 95, "additions": 48, "deletions": 47}, "files": [{"sha": "2bf110d2723e72577b187b9db5d42cc61c37c7d0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/730c5de2815f310ee4e71dd48af101c10e46d747/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730c5de2815f310ee4e71dd48af101c10e46d747/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=730c5de2815f310ee4e71dd48af101c10e46d747", "patch": "@@ -81,7 +81,7 @@ use std::mem::replace;\n use rustc_data_structures::sync::Lrc;\n \n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n-use macros::{InvocationData, LegacyBinding};\n+use macros::{InvocationData, LegacyBinding, LegacyScope};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -1010,7 +1010,7 @@ pub struct ModuleData<'a> {\n     normal_ancestor_id: DefId,\n \n     resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    legacy_macro_resolutions: RefCell<Vec<(Mark, Ident, MacroKind, Option<Def>)>>,\n+    legacy_macro_resolutions: RefCell<Vec<(Ident, MacroKind, Mark, LegacyScope<'a>, Option<Def>)>>,\n     macro_resolutions: RefCell<Vec<(Box<[Ident]>, Span)>>,\n \n     // Macro invocations that can expand into items in this module.\n@@ -1276,19 +1276,18 @@ impl<'a> NameBinding<'a> {\n         if self.is_extern_crate() { \"extern crate\" } else { self.def().kind_name() }\n     }\n \n-    // Suppose that we resolved macro invocation with `invoc_id` to binding `binding` at some\n-    // expansion round `max(invoc_id, binding)` when they both emerged from macros.\n+    // Suppose that we resolved macro invocation with `invoc_parent_expansion` to binding `binding`\n+    // at some expansion round `max(invoc, binding)` when they both emerged from macros.\n     // Then this function returns `true` if `self` may emerge from a macro *after* that\n     // in some later round and screw up our previously found resolution.\n     // See more detailed explanation in\n     // https://github.com/rust-lang/rust/pull/53778#issuecomment-419224049\n-    fn may_appear_after(&self, invoc_id: Mark, binding: &NameBinding) -> bool {\n-        // self > max(invoc_id, binding) => !(self <= invoc_id || self <= binding)\n+    fn may_appear_after(&self, invoc_parent_expansion: Mark, binding: &NameBinding) -> bool {\n+        // self > max(invoc, binding) => !(self <= invoc || self <= binding)\n         // Expansions are partially ordered, so \"may appear after\" is an inversion of\n         // \"certainly appears before or simultaneously\" and includes unordered cases.\n         let self_parent_expansion = self.expansion;\n         let other_parent_expansion = binding.expansion;\n-        let invoc_parent_expansion = invoc_id.parent();\n         let certainly_before_other_or_simultaneously =\n             other_parent_expansion.is_descendant_of(self_parent_expansion);\n         let certainly_before_invoc_or_simultaneously =\n@@ -3493,16 +3492,16 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         path_span: Span,\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n-        self.resolve_path_with_invoc_id(base_module, path, opt_ns, Mark::root(),\n-                                        record_used, path_span, crate_lint)\n+        self.resolve_path_with_parent_expansion(base_module, path, opt_ns, Mark::root(),\n+                                                record_used, path_span, crate_lint)\n     }\n \n-    fn resolve_path_with_invoc_id(\n+    fn resolve_path_with_parent_expansion(\n         &mut self,\n         base_module: Option<ModuleOrUniformRoot<'a>>,\n         path: &[Ident],\n         opt_ns: Option<Namespace>, // `None` indicates a module path\n-        invoc_id: Mark,\n+        parent_expansion: Mark,\n         record_used: bool,\n         path_span: Span,\n         crate_lint: CrateLint,\n@@ -3595,7 +3594,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 self.resolve_ident_in_module(module, ident, ns, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n-                self.resolve_lexical_macro_path_segment(ident, ns, invoc_id, record_used,\n+                self.resolve_lexical_macro_path_segment(ident, ns, parent_expansion, record_used,\n                                                         record_used, false, path_span)\n                                                         .map(|(binding, _)| binding)\n             } else {"}, {"sha": "920d8a6341b3d935eb6168107c2fbb7602d14294", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/730c5de2815f310ee4e71dd48af101c10e46d747/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730c5de2815f310ee4e71dd48af101c10e46d747/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=730c5de2815f310ee4e71dd48af101c10e46d747", "patch": "@@ -313,7 +313,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         None\n     }\n \n-    fn resolve_macro_invocation(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n+    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n         let (path, kind, derives_in_scope) = match invoc.kind {\n             InvocationKind::Attr { attr: None, .. } =>\n@@ -326,7 +326,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n                 (path, MacroKind::Derive, &[][..]),\n         };\n \n-        let (def, ext) = self.resolve_macro_to_def(path, kind, scope, derives_in_scope, force)?;\n+        let (def, ext) = self.resolve_macro_to_def(path, kind, invoc_id, derives_in_scope, force)?;\n \n         if let Def::Macro(def_id, _) = def {\n             self.macro_defs.insert(invoc.expansion_data.mark, def_id);\n@@ -341,10 +341,10 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         Ok(Some(ext))\n     }\n \n-    fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, scope: Mark,\n+    fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n                           derives_in_scope: &[ast::Path], force: bool)\n                           -> Result<Lrc<SyntaxExtension>, Determinacy> {\n-        Ok(self.resolve_macro_to_def(path, kind, scope, derives_in_scope, force)?.1)\n+        Ok(self.resolve_macro_to_def(path, kind, invoc_id, derives_in_scope, force)?.1)\n     }\n \n     fn check_unused_macros(&self) {\n@@ -366,10 +366,10 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n }\n \n impl<'a, 'cl> Resolver<'a, 'cl> {\n-    fn resolve_macro_to_def(&mut self, path: &ast::Path, kind: MacroKind, scope: Mark,\n+    fn resolve_macro_to_def(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n                             derives_in_scope: &[ast::Path], force: bool)\n                             -> Result<(Def, Lrc<SyntaxExtension>), Determinacy> {\n-        let def = self.resolve_macro_to_def_inner(path, kind, scope, derives_in_scope, force);\n+        let def = self.resolve_macro_to_def_inner(path, kind, invoc_id, derives_in_scope, force);\n \n         // Report errors and enforce feature gates for the resolved macro.\n         if def != Err(Determinacy::Undetermined) {\n@@ -439,8 +439,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let ast::Path { ref segments, span } = *path;\n         let mut path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n         let invocation = self.invocations[&invoc_id];\n-        let module = invocation.module.get();\n-        self.current_module = if module.is_trait() { module.parent.unwrap() } else { module };\n+        let parent_expansion = invoc_id.parent();\n+        let parent_legacy_scope = invocation.parent_legacy_scope.get();\n+        self.current_module = invocation.module.get().nearest_item_scope();\n \n         // Possibly apply the macro helper hack\n         if kind == MacroKind::Bang && path.len() == 1 &&\n@@ -450,8 +451,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         if path.len() > 1 {\n-            let def = match self.resolve_path_with_invoc_id(None, &path, Some(MacroNS), invoc_id,\n-                                                            false, span, CrateLint::No) {\n+            let def = match self.resolve_path_with_parent_expansion(None, &path, Some(MacroNS),\n+                                                                    parent_expansion, false, span,\n+                                                                    CrateLint::No) {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => {\n@@ -471,19 +473,19 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     Err(Determinacy::Determined)\n                 },\n             };\n-            self.current_module.nearest_item_scope().macro_resolutions.borrow_mut()\n+            self.current_module.macro_resolutions.borrow_mut()\n                 .push((path.into_boxed_slice(), span));\n             return def;\n         }\n \n         let legacy_resolution = self.resolve_legacy_scope(\n-            path[0], invoc_id, invocation.parent_legacy_scope.get(), false, kind == MacroKind::Attr\n+            path[0], parent_expansion, parent_legacy_scope, false, kind == MacroKind::Attr\n         );\n         let result = if let Some(legacy_binding) = legacy_resolution {\n             Ok(legacy_binding.def())\n         } else {\n-            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, invoc_id, false, force,\n-                                                          kind == MacroKind::Attr, span) {\n+            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, parent_expansion, false,\n+                                                          force, kind == MacroKind::Attr, span) {\n                 Ok((binding, _)) => Ok(binding.def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n                 Err(Determinacy::Determined) => {\n@@ -493,8 +495,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n         };\n \n-        self.current_module.nearest_item_scope().legacy_macro_resolutions.borrow_mut()\n-            .push((invoc_id, path[0], kind, result.ok()));\n+        self.current_module.legacy_macro_resolutions.borrow_mut()\n+            .push((path[0], kind, parent_expansion, parent_legacy_scope, result.ok()));\n \n         if let Ok(Def::NonMacroAttr(NonMacroAttrKind::Custom)) = result {} else {\n             return result;\n@@ -541,7 +543,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         &mut self,\n         mut ident: Ident,\n         ns: Namespace,\n-        invoc_id: Mark,\n+        parent_expansion: Mark,\n         record_used: bool,\n         force: bool,\n         is_attr: bool,\n@@ -754,7 +756,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         // Found another solution, if the first one was \"weak\", report an error.\n                         if result.0.def() != innermost_result.0.def() &&\n                            (innermost_result.0.is_glob_import() ||\n-                            innermost_result.0.may_appear_after(invoc_id, result.0)) {\n+                            innermost_result.0.may_appear_after(parent_expansion, result.0)) {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 ident,\n                                 b1: innermost_result.0,\n@@ -798,8 +800,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n     fn resolve_legacy_scope(&mut self,\n                             ident: Ident,\n-                            invoc_id: Mark,\n-                            invoc_parent_legacy_scope: LegacyScope<'a>,\n+                            parent_expansion: Mark,\n+                            parent_legacy_scope: LegacyScope<'a>,\n                             record_used: bool,\n                             is_attr: bool)\n                             -> Option<&'a NameBinding<'a>> {\n@@ -826,7 +828,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let mut innermost_result: Option<&NameBinding> = None;\n \n         // Go through all the scopes and try to resolve the name.\n-        let mut where_to_resolve = invoc_parent_legacy_scope;\n+        let mut where_to_resolve = parent_legacy_scope;\n         loop {\n             let result = match where_to_resolve {\n                 LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n@@ -854,7 +856,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     if let Some(innermost_result) = innermost_result {\n                         // Found another solution, if the first one was \"weak\", report an error.\n                         if result.def() != innermost_result.def() &&\n-                           innermost_result.may_appear_after(invoc_id, result) {\n+                           innermost_result.may_appear_after(parent_expansion, result) {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 ident,\n                                 b1: innermost_result,\n@@ -891,14 +893,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n         }\n \n-        for &(invoc_id, ident, kind, def) in module.legacy_macro_resolutions.borrow().iter() {\n+        for &(ident, kind, parent_expansion, parent_legacy_scope, def)\n+                in module.legacy_macro_resolutions.borrow().iter() {\n             let span = ident.span;\n-            let invocation = self.invocations[&invoc_id];\n             let legacy_resolution = self.resolve_legacy_scope(\n-                ident, invoc_id, invocation.parent_legacy_scope.get(), true, kind == MacroKind::Attr\n+                ident, parent_expansion, parent_legacy_scope, true, kind == MacroKind::Attr\n             );\n             let resolution = self.resolve_lexical_macro_path_segment(\n-                ident, MacroNS, invoc_id, true, true, kind == MacroKind::Attr, span\n+                ident, MacroNS, parent_expansion, true, true, kind == MacroKind::Attr, span\n             );\n \n             let check_consistency = |this: &Self, new_def: Def| {\n@@ -932,12 +934,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     err.emit();\n                 },\n                 (Some(legacy_binding), Ok((binding, FromPrelude(from_prelude))))\n-                        if !from_prelude || legacy_binding.may_appear_after(invoc_id, binding) => {\n-                    if legacy_binding.def_ignoring_ambiguity() != binding.def_ignoring_ambiguity() {\n-                        self.report_ambiguity_error(ident, legacy_binding, binding);\n-                    }\n+                        if legacy_binding.def() != binding.def_ignoring_ambiguity() &&\n+                           (!from_prelude ||\n+                            legacy_binding.may_appear_after(parent_expansion, binding)) => {\n+                    self.report_ambiguity_error(ident, legacy_binding, binding);\n                 },\n                 // OK, non-macro-expanded legacy wins over prelude even if defs are different\n+                // Also, legacy and modern can co-exist if their defs are same\n                 (Some(legacy_binding), Ok(_)) |\n                 // OK, unambiguous resolution\n                 (Some(legacy_binding), Err(_)) => {"}, {"sha": "07c3e578e5b04c88ae28d08574c60b88a47998a0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/730c5de2815f310ee4e71dd48af101c10e46d747/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730c5de2815f310ee4e71dd48af101c10e46d747/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=730c5de2815f310ee4e71dd48af101c10e46d747", "patch": "@@ -727,10 +727,9 @@ pub trait Resolver {\n     fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>, allow_derive: bool)\n                               -> Option<Attribute>;\n \n-    fn resolve_macro_invocation(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n+    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Determinacy>;\n-\n-    fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, scope: Mark,\n+    fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n                           derives_in_scope: &[ast::Path], force: bool)\n                           -> Result<Lrc<SyntaxExtension>, Determinacy>;\n \n@@ -764,11 +763,11 @@ impl Resolver for DummyResolver {\n     fn resolve_imports(&mut self) {}\n     fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>, _allow_derive: bool)\n                               -> Option<Attribute> { None }\n-    fn resolve_macro_invocation(&mut self, _invoc: &Invocation, _scope: Mark, _force: bool)\n+    fn resolve_macro_invocation(&mut self, _invoc: &Invocation, _invoc_id: Mark, _force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n         Err(Determinacy::Determined)\n     }\n-    fn resolve_macro_path(&mut self, _path: &ast::Path, _kind: MacroKind, _scope: Mark,\n+    fn resolve_macro_path(&mut self, _path: &ast::Path, _kind: MacroKind, _invoc_id: Mark,\n                           _derives_in_scope: &[ast::Path], _force: bool)\n                           -> Result<Lrc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)"}]}