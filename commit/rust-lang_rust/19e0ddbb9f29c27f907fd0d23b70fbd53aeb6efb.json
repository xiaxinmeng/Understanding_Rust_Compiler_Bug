{"sha": "19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZTBkZGJiOWYyOWMyN2Y5MDdmZDBkMjNiNzBmYmQ1M2FlYjZlZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-30T00:38:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-30T00:38:51Z"}, "message": "Auto merge of #61212 - alexcrichton:skip-rustc, r=pietroalbini\n\nci: Attempt to skip a full rustc compile on dist*\n\nCurrently when we're preparing cross-compiled compilers it can take\nquite some time because we have to build the compiler itself three\ndifferent times. The first is the normal bootstrap, the second is a\nsecond build for the build platform, and the third is the actual target\narchitecture compiler. The second compiler was historically built\nexclusively for procedural macros, and long ago we didn't actually need\nit.\n\nThis commit tries out avoiding that second compiled compiler, meaning we\nonly compile rustc for the build platform only once. Some local testing\nshows that this is promising, but bors is of course the ultimate test!", "tree": {"sha": "21030ef19b0b4b91121ec32b1cff1408d7f7b291", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21030ef19b0b4b91121ec32b1cff1408d7f7b291"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb", "html_url": "https://github.com/rust-lang/rust/commit/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "413790186c65e782e2c0183e933686f7bf35e158", "url": "https://api.github.com/repos/rust-lang/rust/commits/413790186c65e782e2c0183e933686f7bf35e158", "html_url": "https://github.com/rust-lang/rust/commit/413790186c65e782e2c0183e933686f7bf35e158"}, {"sha": "7b362bb84178b9c87b2b9246b7d3d107820e932a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b362bb84178b9c87b2b9246b7d3d107820e932a", "html_url": "https://github.com/rust-lang/rust/commit/7b362bb84178b9c87b2b9246b7d3d107820e932a"}], "stats": {"total": 477, "additions": 253, "deletions": 224}, "files": [{"sha": "1d3b4fe33c8119b40cea14d1ba1c9cee96331311", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 82, "deletions": 51, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb", "patch": "@@ -581,6 +581,30 @@ impl<'a> Builder<'a> {\n         })\n     }\n \n+    /// Similar to `compiler`, except handles the full-bootstrap option to\n+    /// silently use the stage1 compiler instead of a stage2 compiler if one is\n+    /// requested.\n+    ///\n+    /// Note that this does *not* have the side effect of creating\n+    /// `compiler(stage, host)`, unlike `compiler` above which does have such\n+    /// a side effect. The returned compiler here can only be used to compile\n+    /// new artifacts, it can't be used to rely on the presence of a particular\n+    /// sysroot.\n+    ///\n+    /// See `force_use_stage1` for documentation on what each argument is.\n+    pub fn compiler_for(\n+        &self,\n+        stage: u32,\n+        host: Interned<String>,\n+        target: Interned<String>,\n+    ) -> Compiler {\n+        if self.build.force_use_stage1(Compiler { stage, host }, target) {\n+            self.compiler(1, self.config.build)\n+        } else {\n+            self.compiler(stage, host)\n+        }\n+    }\n+\n     pub fn sysroot(&self, compiler: Compiler) -> Interned<PathBuf> {\n         self.ensure(compile::Sysroot { compiler })\n     }\n@@ -754,11 +778,7 @@ impl<'a> Builder<'a> {\n         // This is for the original compiler, but if we're forced to use stage 1, then\n         // std/test/rustc stamps won't exist in stage 2, so we need to get those from stage 1, since\n         // we copy the libs forward.\n-        let cmp = if self.force_use_stage1(compiler, target) {\n-            self.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let cmp = self.compiler_for(compiler.stage, compiler.host, target);\n \n         let libstd_stamp = match cmd {\n             \"check\" | \"clippy\" | \"fix\" => check::libstd_stamp(self, cmp, target),\n@@ -1358,7 +1378,7 @@ mod __test {\n \n         assert_eq!(\n             first(builder.cache.all::<dist::Docs>()),\n-            &[dist::Docs { stage: 2, host: a },]\n+            &[dist::Docs { host: a },]\n         );\n         assert_eq!(\n             first(builder.cache.all::<dist::Mingw>()),\n@@ -1373,7 +1393,7 @@ mod __test {\n         assert_eq!(\n             first(builder.cache.all::<dist::Std>()),\n             &[dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n+                compiler: Compiler { host: a, stage: 1 },\n                 target: a,\n             },]\n         );\n@@ -1392,8 +1412,8 @@ mod __test {\n         assert_eq!(\n             first(builder.cache.all::<dist::Docs>()),\n             &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n+                dist::Docs { host: a },\n+                dist::Docs { host: b },\n             ]\n         );\n         assert_eq!(\n@@ -1410,7 +1430,7 @@ mod __test {\n             first(builder.cache.all::<dist::Std>()),\n             &[\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: a,\n                 },\n                 dist::Std {\n@@ -1434,8 +1454,8 @@ mod __test {\n         assert_eq!(\n             first(builder.cache.all::<dist::Docs>()),\n             &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n+                dist::Docs { host: a },\n+                dist::Docs { host: b },\n             ]\n         );\n         assert_eq!(\n@@ -1457,18 +1477,52 @@ mod __test {\n             first(builder.cache.all::<dist::Std>()),\n             &[\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: a,\n                 },\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: b,\n                 },\n             ]\n         );\n         assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n+    #[test]\n+    fn dist_only_cross_host() {\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let mut build = Build::new(configure(&[\"B\"], &[]));\n+        build.config.docs = false;\n+        build.config.extended = true;\n+        build.hosts = vec![b];\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 }\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Rustc>()),\n+            &[\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+    }\n+\n     #[test]\n     fn dist_with_targets_and_hosts() {\n         let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n@@ -1482,9 +1536,9 @@ mod __test {\n         assert_eq!(\n             first(builder.cache.all::<dist::Docs>()),\n             &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n-                dist::Docs { stage: 2, host: c },\n+                dist::Docs { host: a },\n+                dist::Docs { host: b },\n+                dist::Docs { host: c },\n             ]\n         );\n         assert_eq!(\n@@ -1510,11 +1564,11 @@ mod __test {\n             first(builder.cache.all::<dist::Std>()),\n             &[\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: a,\n                 },\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: b,\n                 },\n                 dist::Std {\n@@ -1541,9 +1595,9 @@ mod __test {\n         assert_eq!(\n             first(builder.cache.all::<dist::Docs>()),\n             &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n-                dist::Docs { stage: 2, host: c },\n+                dist::Docs { host: a },\n+                dist::Docs { host: b },\n+                dist::Docs { host: c },\n             ]\n         );\n         assert_eq!(\n@@ -1559,11 +1613,11 @@ mod __test {\n             first(builder.cache.all::<dist::Std>()),\n             &[\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: a,\n                 },\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: b,\n                 },\n                 dist::Std {\n@@ -1587,8 +1641,8 @@ mod __test {\n         assert_eq!(\n             first(builder.cache.all::<dist::Docs>()),\n             &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n+                dist::Docs { host: a },\n+                dist::Docs { host: b },\n             ]\n         );\n         assert_eq!(\n@@ -1610,11 +1664,11 @@ mod __test {\n             first(builder.cache.all::<dist::Std>()),\n             &[\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: a,\n                 },\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: b,\n                 },\n             ]\n@@ -1664,10 +1718,6 @@ mod __test {\n                     compiler: Compiler { host: a, stage: 1 },\n                     target: b,\n                 },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n             ]\n         );\n         assert_eq!(\n@@ -1720,10 +1770,6 @@ mod __test {\n                     compiler: Compiler { host: b, stage: 2 },\n                     target: a,\n                 },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: b,\n-                },\n                 compile::Rustc {\n                     compiler: Compiler { host: a, stage: 1 },\n                     target: b,\n@@ -1758,10 +1804,6 @@ mod __test {\n                     compiler: Compiler { host: b, stage: 2 },\n                     target: a,\n                 },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: b,\n-                },\n                 compile::Test {\n                     compiler: Compiler { host: a, stage: 1 },\n                     target: b,\n@@ -1808,9 +1850,6 @@ mod __test {\n                 compile::Assemble {\n                     target_compiler: Compiler { host: a, stage: 1 },\n                 },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: b, stage: 1 },\n-                },\n                 compile::Assemble {\n                     target_compiler: Compiler { host: a, stage: 2 },\n                 },\n@@ -1830,10 +1869,6 @@ mod __test {\n                     compiler: Compiler { host: a, stage: 1 },\n                     target: a,\n                 },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: b,\n-                },\n                 compile::Rustc {\n                     compiler: Compiler { host: a, stage: 1 },\n                     target: b,\n@@ -1860,10 +1895,6 @@ mod __test {\n                     compiler: Compiler { host: b, stage: 2 },\n                     target: a,\n                 },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: b,\n-                },\n                 compile::Test {\n                     compiler: Compiler { host: a, stage: 1 },\n                     target: b,"}, {"sha": "4515c7d672d8a5652f0949bcd76e2c78141d401d", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb", "patch": "@@ -70,20 +70,20 @@ impl Step for Std {\n \n         builder.ensure(StartupObjects { compiler, target });\n \n-        if builder.force_use_stage1(compiler, target) {\n-            let from = builder.compiler(1, builder.config.build);\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n             builder.ensure(Std {\n-                compiler: from,\n+                compiler: compiler_to_use,\n                 target,\n             });\n-            builder.info(&format!(\"Uplifting stage1 std ({} -> {})\", from.host, target));\n+            builder.info(&format!(\"Uplifting stage1 std ({} -> {})\", compiler_to_use.host, target));\n \n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the third party objects needed by various targets.\n             copy_third_party_objects(builder, &compiler, target);\n \n             builder.ensure(StdLink {\n-                compiler: from,\n+                compiler: compiler_to_use,\n                 target_compiler: compiler,\n                 target,\n             });\n@@ -403,15 +403,16 @@ impl Step for Test {\n             return;\n         }\n \n-        if builder.force_use_stage1(compiler, target) {\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n             builder.ensure(Test {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target,\n             });\n             builder.info(\n                 &format!(\"Uplifting stage1 test ({} -> {})\", builder.config.build, target));\n             builder.ensure(TestLink {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target_compiler: compiler,\n                 target,\n             });\n@@ -529,15 +530,16 @@ impl Step for Rustc {\n             return;\n         }\n \n-        if builder.force_use_stage1(compiler, target) {\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n             builder.ensure(Rustc {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target,\n             });\n             builder.info(&format!(\"Uplifting stage1 rustc ({} -> {})\",\n                 builder.config.build, target));\n             builder.ensure(RustcLink {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target_compiler: compiler,\n                 target,\n             });\n@@ -687,9 +689,10 @@ impl Step for CodegenBackend {\n             return;\n         }\n \n-        if builder.force_use_stage1(compiler, target) {\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n             builder.ensure(CodegenBackend {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target,\n                 backend,\n             });"}, {"sha": "274961916183afff56f22f5a704553dcb770fa49", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 88, "deletions": 71, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb", "patch": "@@ -68,7 +68,6 @@ fn missing_tool(tool_name: &str, skip: bool) {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Docs {\n-    pub stage: u32,\n     pub host: Interned<String>,\n }\n \n@@ -82,7 +81,6 @@ impl Step for Docs {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Docs {\n-            stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n@@ -130,7 +128,6 @@ impl Step for Docs {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustcDocs {\n-    pub stage: u32,\n     pub host: Interned<String>,\n }\n \n@@ -144,7 +141,6 @@ impl Step for RustcDocs {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(RustcDocs {\n-            stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n@@ -647,7 +643,11 @@ impl Step for Std {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Std {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n@@ -737,7 +737,14 @@ impl Step for Analysis {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Analysis {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n+            // Find the actual compiler (handling the full bootstrap option) which\n+            // produced the save-analysis data because that data isn't copied\n+            // through the sysroot uplifting.\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n@@ -757,14 +764,6 @@ impl Step for Analysis {\n \n         builder.ensure(Std { compiler, target });\n \n-        // Package save-analysis from stage1 if not doing a full bootstrap, as the\n-        // stage2 artifacts is simply copied from stage1 in that case.\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler.clone()\n-        };\n-\n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n \n         let src = builder.stage_out(compiler, Mode::Std)\n@@ -1066,7 +1065,7 @@ pub fn sanitize_sh(path: &Path) -> String {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Cargo {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1080,16 +1079,20 @@ impl Step for Cargo {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Cargo {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n \n-        builder.info(&format!(\"Dist cargo stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist cargo stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/cargo\");\n         let etc = src.join(\"src/etc\");\n         let release_num = builder.release_num(\"cargo\");\n@@ -1104,10 +1107,7 @@ impl Step for Cargo {\n         // Prepare the image directory\n         builder.create_dir(&image.join(\"share/zsh/site-functions\"));\n         builder.create_dir(&image.join(\"etc/bash_completion.d\"));\n-        let cargo = builder.ensure(tool::Cargo {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target\n-        });\n+        let cargo = builder.ensure(tool::Cargo { compiler, target });\n         builder.install(&cargo, &image.join(\"bin\"), 0o755);\n         for man in t!(etc.join(\"man\").read_dir()) {\n             let man = t!(man);\n@@ -1152,7 +1152,7 @@ impl Step for Cargo {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rls {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1166,17 +1166,21 @@ impl Step for Rls {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rls {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        builder.info(&format!(\"Dist RLS stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist RLS stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/rls\");\n         let release_num = builder.release_num(\"rls\");\n         let name = pkgname(builder, \"rls\");\n@@ -1191,8 +1195,9 @@ impl Step for Rls {\n         // We expect RLS to build, because we've exited this step above if tool\n         // state for RLS isn't testing.\n         let rls = builder.ensure(tool::Rls {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"RLS\", builder.build.config.missing_tools); None })?;\n \n         builder.install(&rls, &image.join(\"bin\"), 0o755);\n@@ -1231,7 +1236,7 @@ impl Step for Rls {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Clippy {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1245,17 +1250,21 @@ impl Step for Clippy {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Clippy {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        builder.info(&format!(\"Dist clippy stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist clippy stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/clippy\");\n         let release_num = builder.release_num(\"clippy\");\n         let name = pkgname(builder, \"clippy\");\n@@ -1270,11 +1279,12 @@ impl Step for Clippy {\n         // We expect clippy to build, because we've exited this step above if tool\n         // state for clippy isn't testing.\n         let clippy = builder.ensure(tool::Clippy {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"clippy\", builder.build.config.missing_tools); None })?;\n         let cargoclippy = builder.ensure(tool::CargoClippy {\n-            compiler: builder.compiler(stage, builder.config.build),\n+            compiler,\n             target, extra_features: Vec::new()\n         }).or_else(|| { missing_tool(\"cargo clippy\", builder.build.config.missing_tools); None })?;\n \n@@ -1315,7 +1325,7 @@ impl Step for Clippy {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Miri {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1329,17 +1339,21 @@ impl Step for Miri {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Miri {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        builder.info(&format!(\"Dist miri stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist miri stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/miri\");\n         let release_num = builder.release_num(\"miri\");\n         let name = pkgname(builder, \"miri\");\n@@ -1354,12 +1368,14 @@ impl Step for Miri {\n         // We expect miri to build, because we've exited this step above if tool\n         // state for miri isn't testing.\n         let miri = builder.ensure(tool::Miri {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"miri\", builder.build.config.missing_tools); None })?;\n         let cargomiri = builder.ensure(tool::CargoMiri {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new()\n         }).or_else(|| { missing_tool(\"cargo miri\", builder.build.config.missing_tools); None })?;\n \n         builder.install(&miri, &image.join(\"bin\"), 0o755);\n@@ -1399,7 +1415,7 @@ impl Step for Miri {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustfmt {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1413,16 +1429,20 @@ impl Step for Rustfmt {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustfmt {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n \n-        builder.info(&format!(\"Dist Rustfmt stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist Rustfmt stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/rustfmt\");\n         let release_num = builder.release_num(\"rustfmt\");\n         let name = pkgname(builder, \"rustfmt\");\n@@ -1435,12 +1455,14 @@ impl Step for Rustfmt {\n \n         // Prepare the image directory\n         let rustfmt = builder.ensure(tool::Rustfmt {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"Rustfmt\", builder.build.config.missing_tools); None })?;\n         let cargofmt = builder.ensure(tool::Cargofmt {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"Cargofmt\", builder.build.config.missing_tools); None })?;\n \n         builder.install(&rustfmt, &image.join(\"bin\"), 0o755);\n@@ -1505,30 +1527,28 @@ impl Step for Extended {\n \n     /// Creates a combined installer for the specified target in the provided stage.\n     fn run(self, builder: &Builder<'_>) {\n-        let stage = self.stage;\n         let target = self.target;\n+        let stage = self.stage;\n+        let compiler = builder.compiler_for(self.stage, self.host, self.target);\n \n-        builder.info(&format!(\"Dist extended stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist extended stage{} ({})\", compiler.stage, target));\n \n         let rustc_installer = builder.ensure(Rustc {\n             compiler: builder.compiler(stage, target),\n         });\n-        let cargo_installer = builder.ensure(Cargo { stage, target });\n-        let rustfmt_installer = builder.ensure(Rustfmt { stage, target });\n-        let rls_installer = builder.ensure(Rls { stage, target });\n-        let llvm_tools_installer = builder.ensure(LlvmTools { stage, target });\n-        let clippy_installer = builder.ensure(Clippy { stage, target });\n-        let miri_installer = builder.ensure(Miri { stage, target });\n+        let cargo_installer = builder.ensure(Cargo { compiler, target });\n+        let rustfmt_installer = builder.ensure(Rustfmt { compiler, target });\n+        let rls_installer = builder.ensure(Rls { compiler, target });\n+        let llvm_tools_installer = builder.ensure(LlvmTools { target });\n+        let clippy_installer = builder.ensure(Clippy { compiler, target });\n+        let miri_installer = builder.ensure(Miri { compiler, target });\n         let lldb_installer = builder.ensure(Lldb { target });\n         let mingw_installer = builder.ensure(Mingw { host: target });\n-        let analysis_installer = builder.ensure(Analysis {\n-            compiler: builder.compiler(stage, self.host),\n-            target\n-        });\n+        let analysis_installer = builder.ensure(Analysis { compiler, target });\n \n-        let docs_installer = builder.ensure(Docs { stage, host: target, });\n+        let docs_installer = builder.ensure(Docs { host: target, });\n         let std_installer = builder.ensure(Std {\n-            compiler: builder.compiler(stage, self.host),\n+            compiler: builder.compiler(stage, target),\n             target,\n         });\n \n@@ -2076,7 +2096,6 @@ pub fn maybe_install_llvm_dylib(builder: &Builder<'_>,\n \n #[derive(Clone, Debug, Eq, Hash, PartialEq)]\n pub struct LlvmTools {\n-    pub stage: u32,\n     pub target: Interned<String>,\n }\n \n@@ -2090,26 +2109,24 @@ impl Step for LlvmTools {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(LlvmTools {\n-            stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n         /* run only if llvm-config isn't used */\n         if let Some(config) = builder.config.target_config.get(&target) {\n             if let Some(ref _s) = config.llvm_config {\n-                builder.info(&format!(\"Skipping LlvmTools stage{} ({}): external LLVM\",\n-                    stage, target));\n+                builder.info(&format!(\"Skipping LlvmTools ({}): external LLVM\",\n+                    target));\n                 return None;\n             }\n         }\n \n-        builder.info(&format!(\"Dist LlvmTools stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist LlvmTools ({})\", target));\n         let src = builder.src.join(\"src/llvm-project/llvm\");\n         let name = pkgname(builder, \"llvm-tools\");\n "}, {"sha": "12bdfa5691dc744a7479a6074d6d546ccb3965b0", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 5, "deletions": 30, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb", "patch": "@@ -475,12 +475,7 @@ impl Step for Std {\n         builder.info(&format!(\"Documenting stage{} std ({})\", stage, target));\n         let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         builder.ensure(compile::Std { compiler, target });\n         let out_dir = builder.stage_out(compiler, Mode::Std)\n@@ -563,12 +558,7 @@ impl Step for Test {\n         builder.info(&format!(\"Documenting stage{} test ({})\", stage, target));\n         let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         // Build libstd docs so that we generate relative links\n         builder.ensure(Std { stage, target });\n@@ -632,12 +622,7 @@ impl Step for WhitelistedRustc {\n         builder.info(&format!(\"Documenting stage{} whitelisted compiler ({})\", stage, target));\n         let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         // Build libstd docs so that we generate relative links\n         builder.ensure(Std { stage, target });\n@@ -706,12 +691,7 @@ impl Step for Rustc {\n         t!(fs::create_dir_all(&out));\n \n         // Get the correct compiler for this stage.\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         if !builder.config.compiler_docs {\n             builder.info(\"\\tskipping - compiler/librustdoc docs disabled\");\n@@ -807,12 +787,7 @@ impl Step for Rustdoc {\n         t!(fs::create_dir_all(&out));\n \n         // Get the correct compiler for this stage.\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         if !builder.config.compiler_docs {\n             builder.info(\"\\tskipping - compiler/librustdoc docs disabled\");"}, {"sha": "0047be4d5951b95a4fbc77bcdac5e6f902f1827b", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb", "patch": "@@ -5,12 +5,13 @@\n \n use std::env;\n use std::fs;\n-use std::path::{Path, PathBuf, Component};\n+use std::path::{Component, Path, PathBuf};\n use std::process::Command;\n \n use build_helper::t;\n \n use crate::dist::{self, pkgname, sanitize_sh, tmpdir};\n+use crate::Compiler;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::cache::Interned;\n@@ -58,7 +59,7 @@ fn install_sh(\n     package: &str,\n     name: &str,\n     stage: u32,\n-    host: Option<Interned<String>>\n+    host: Option<Interned<String>>,\n ) {\n     builder.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n \n@@ -144,9 +145,8 @@ macro_rules! install {\n         $(\n             #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n-            pub stage: u32,\n+            pub compiler: Compiler,\n             pub target: Interned<String>,\n-            pub host: Interned<String>,\n         }\n \n         impl $name {\n@@ -175,9 +175,8 @@ macro_rules! install {\n \n             fn make_run(run: RunConfig<'_>) {\n                 run.builder.ensure($name {\n-                    stage: run.builder.top_stage,\n+                    compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n                     target: run.target,\n-                    host: run.builder.config.build,\n                 });\n             }\n \n@@ -190,67 +189,78 @@ macro_rules! install {\n \n install!((self, builder, _config),\n     Docs, \"src/doc\", _config.docs, only_hosts: false, {\n-        builder.ensure(dist::Docs { stage: self.stage, host: self.target });\n-        install_docs(builder, self.stage, self.target);\n+        builder.ensure(dist::Docs { host: self.target });\n+        install_docs(builder, self.compiler.stage, self.target);\n     };\n     Std, \"src/libstd\", true, only_hosts: true, {\n         for target in &builder.targets {\n             builder.ensure(dist::Std {\n-                compiler: builder.compiler(self.stage, self.host),\n+                compiler: self.compiler,\n                 target: *target\n             });\n-            install_std(builder, self.stage, *target);\n+            install_std(builder, self.compiler.stage, *target);\n         }\n     };\n     Cargo, \"cargo\", Self::should_build(_config), only_hosts: true, {\n-        builder.ensure(dist::Cargo { stage: self.stage, target: self.target });\n-        install_cargo(builder, self.stage, self.target);\n+        builder.ensure(dist::Cargo { compiler: self.compiler, target: self.target });\n+        install_cargo(builder, self.compiler.stage, self.target);\n     };\n     Rls, \"rls\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Rls { stage: self.stage, target: self.target }).is_some() ||\n+        if builder.ensure(dist::Rls { compiler: self.compiler, target: self.target }).is_some() ||\n             Self::should_install(builder) {\n-            install_rls(builder, self.stage, self.target);\n+            install_rls(builder, self.compiler.stage, self.target);\n         } else {\n-            builder.info(&format!(\"skipping Install RLS stage{} ({})\", self.stage, self.target));\n+            builder.info(\n+                &format!(\"skipping Install RLS stage{} ({})\", self.compiler.stage, self.target),\n+            );\n         }\n     };\n     Clippy, \"clippy\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Clippy { stage: self.stage, target: self.target }).is_some() ||\n-            Self::should_install(builder) {\n-            install_clippy(builder, self.stage, self.target);\n+        if builder.ensure(dist::Clippy {\n+            compiler: self.compiler,\n+            target: self.target,\n+        }).is_some() || Self::should_install(builder) {\n+            install_clippy(builder, self.compiler.stage, self.target);\n         } else {\n-            builder.info(&format!(\"skipping Install clippy stage{} ({})\", self.stage, self.target));\n+            builder.info(\n+                &format!(\"skipping Install clippy stage{} ({})\", self.compiler.stage, self.target),\n+            );\n         }\n     };\n     Miri, \"miri\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Miri { stage: self.stage, target: self.target }).is_some() ||\n+        if builder.ensure(dist::Miri { compiler: self.compiler, target: self.target }).is_some() ||\n             Self::should_install(builder) {\n-            install_miri(builder, self.stage, self.target);\n+            install_miri(builder, self.compiler.stage, self.target);\n         } else {\n-            builder.info(&format!(\"skipping Install miri stage{} ({})\", self.stage, self.target));\n+            builder.info(\n+                &format!(\"skipping Install miri stage{} ({})\", self.compiler.stage, self.target),\n+            );\n         }\n     };\n     Rustfmt, \"rustfmt\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Rustfmt { stage: self.stage, target: self.target }).is_some() ||\n-            Self::should_install(builder) {\n-            install_rustfmt(builder, self.stage, self.target);\n+        if builder.ensure(dist::Rustfmt {\n+            compiler: self.compiler,\n+            target: self.target\n+        }).is_some() || Self::should_install(builder) {\n+            install_rustfmt(builder, self.compiler.stage, self.target);\n         } else {\n             builder.info(\n-                &format!(\"skipping Install Rustfmt stage{} ({})\", self.stage, self.target));\n+                &format!(\"skipping Install Rustfmt stage{} ({})\", self.compiler.stage, self.target),\n+            );\n         }\n     };\n     Analysis, \"analysis\", Self::should_build(_config), only_hosts: false, {\n         builder.ensure(dist::Analysis {\n-            compiler: builder.compiler(self.stage, self.host),\n+            compiler: self.compiler,\n             target: self.target\n         });\n-        install_analysis(builder, self.stage, self.target);\n+        install_analysis(builder, self.compiler.stage, self.target);\n     };\n     Rustc, \"src/librustc\", true, only_hosts: true, {\n         builder.ensure(dist::Rustc {\n-            compiler: builder.compiler(self.stage, self.target),\n+            compiler: self.compiler,\n         });\n-        install_rustc(builder, self.stage, self.target);\n+        install_rustc(builder, self.compiler.stage, self.target);\n     };\n );\n \n@@ -266,15 +276,12 @@ impl Step for Src {\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let config = &run.builder.config;\n-        let cond = config.extended &&\n-            config.tools.as_ref().map_or(true, |t| t.contains(\"src\"));\n+        let cond = config.extended && config.tools.as_ref().map_or(true, |t| t.contains(\"src\"));\n         run.path(\"src\").default_condition(cond)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Src {\n-            stage: run.builder.top_stage,\n-        });\n+        run.builder.ensure(Src { stage: run.builder.top_stage });\n     }\n \n     fn run(self, builder: &Builder<'_>) {"}, {"sha": "74caaae2840c5b2b88b2b960321ef12e241d3a94", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb", "patch": "@@ -1690,15 +1690,11 @@ impl Step for Crate {\n         builder.ensure(compile::Test { compiler, target });\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n-        // If we're not doing a full bootstrap but we're testing a stage2 version of\n-        // libstd, then what we're actually testing is the libstd produced in\n-        // stage1. Reflect that here by updating the compiler that we're working\n-        // with automatically.\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler.clone()\n-        };\n+        // If we're not doing a full bootstrap but we're testing a stage2\n+        // version of libstd, then what we're actually testing is the libstd\n+        // produced in stage1. Reflect that here by updating the compiler that\n+        // we're working with automatically.\n+        let compiler = builder.compiler_for(compiler.stage, compiler.host, target);\n \n         let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n         match mode {"}, {"sha": "3b6f02c9368c9570eac86af2bd92566df32de586", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=19e0ddbb9f29c27f907fd0d23b70fbd53aeb6efb", "patch": "@@ -535,9 +535,9 @@ impl Step for Cargo {\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        // Cargo depends on procedural macros, which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // Cargo depends on procedural macros, so make sure the host\n+        // libstd/libproc_macro is available.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n@@ -609,26 +609,26 @@ macro_rules! tool_extended {\n tool_extended!((self, builder),\n     Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", {};\n     CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {\n-        // Clippy depends on procedural macros (serde), which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // Clippy depends on procedural macros, so make sure that's built for\n+        // the compiler itself.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n     };\n     Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {\n-        // Clippy depends on procedural macros (serde), which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // Clippy depends on procedural macros, so make sure that's built for\n+        // the compiler itself.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n     };\n     Miri, miri, \"src/tools/miri\", \"miri\", {};\n     CargoMiri, miri, \"src/tools/miri\", \"cargo-miri\", {\n-        // Miri depends on procedural macros (serde), which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // Miri depends on procedural macros, so make sure that's built for\n+        // the compiler itself.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n@@ -642,9 +642,9 @@ tool_extended!((self, builder),\n         if clippy.is_some() {\n             self.extra_features.push(\"clippy\".to_owned());\n         }\n-        // RLS depends on procedural macros, which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // RLS depends on procedural macros, so make sure that's built for\n+        // the compiler itself.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });"}]}