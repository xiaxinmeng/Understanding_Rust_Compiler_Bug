{"sha": "ae076e1e3b037e557b613d97698a9f28a1683d8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMDc2ZTFlM2IwMzdlNTU3YjYxM2Q5NzY5OGE5ZjI4YTE2ODNkOGI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-29T10:17:51Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-29T22:30:12Z"}, "message": "Implement deref coercions (rust-lang/rfcs#241).", "tree": {"sha": "ffb459e911e1704bad2cf34eb478e4c55b838c95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffb459e911e1704bad2cf34eb478e4c55b838c95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae076e1e3b037e557b613d97698a9f28a1683d8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae076e1e3b037e557b613d97698a9f28a1683d8b", "html_url": "https://github.com/rust-lang/rust/commit/ae076e1e3b037e557b613d97698a9f28a1683d8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae076e1e3b037e557b613d97698a9f28a1683d8b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b48c4c8cf4f6366fd88693d2b359afc2b94bc575", "url": "https://api.github.com/repos/rust-lang/rust/commits/b48c4c8cf4f6366fd88693d2b359afc2b94bc575", "html_url": "https://github.com/rust-lang/rust/commit/b48c4c8cf4f6366fd88693d2b359afc2b94bc575"}], "stats": {"total": 321, "additions": 261, "deletions": 60}, "files": [{"sha": "e37c1ab7f0cb7d77ce722276bc0d13bd12d7b5b8", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae076e1e3b037e557b613d97698a9f28a1683d8b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae076e1e3b037e557b613d97698a9f28a1683d8b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=ae076e1e3b037e557b613d97698a9f28a1683d8b", "patch": "@@ -21,6 +21,7 @@ use super::LvaluePreference;\n use super::method;\n use super::structurally_resolved_type;\n use super::TupleArgumentsFlag;\n+use super::UnresolvedTypeAction;\n use super::write_call;\n \n use middle::infer;\n@@ -77,6 +78,7 @@ pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                   callee_expr.span,\n                   original_callee_ty,\n                   Some(callee_expr),\n+                  UnresolvedTypeAction::Error,\n                   LvaluePreference::NoPreference,\n                   |adj_ty, idx| {\n                       let autoderefref = ty::AutoDerefRef { autoderefs: idx, autoref: None };"}, {"sha": "8bac89ac1843fb357d16e1957b57230c9ea105be", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 60, "deletions": 20, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ae076e1e3b037e557b613d97698a9f28a1683d8b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae076e1e3b037e557b613d97698a9f28a1683d8b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=ae076e1e3b037e557b613d97698a9f28a1683d8b", "patch": "@@ -60,7 +60,7 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use check::FnCtxt;\n+use check::{autoderef, FnCtxt, NoPreference, PreferMutLvalue, UnresolvedTypeAction};\n \n use middle::infer::{self, cres, Coercion, TypeTrace};\n use middle::infer::combine::Combine;\n@@ -98,7 +98,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         f(self.fcx.infcx().shallow_resolve(a))\n     }\n \n-    fn coerce(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n+    fn coerce(&self,\n+              expr_a: &ast::Expr,\n+              a: Ty<'tcx>,\n+              b: Ty<'tcx>)\n+              -> CoerceResult<'tcx> {\n         debug!(\"Coerce.tys({} => {})\",\n                a.repr(self.tcx()),\n                b.repr(self.tcx()));\n@@ -124,7 +128,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n             ty::ty_rptr(_, mt_b) => {\n                 return self.unpack_actual_value(a, |a| {\n-                    self.coerce_borrowed_pointer(a, b, mt_b.mutbl)\n+                    self.coerce_borrowed_pointer(expr_a, a, b, mt_b.mutbl)\n                 });\n             }\n \n@@ -147,8 +151,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         })\n     }\n \n-    // ~T -> &T or &mut T -> &T (including where T = [U] or str)\n+    /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n+    /// To match `A` with `B`, autoderef will be performed,\n+    /// calling `deref`/`deref_mut` where necessary.\n     fn coerce_borrowed_pointer(&self,\n+                               expr_a: &ast::Expr,\n                                a: Ty<'tcx>,\n                                b: Ty<'tcx>,\n                                mutbl_b: ast::Mutability)\n@@ -163,29 +170,62 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // to type check, we will construct the type that `&M*expr` would\n         // yield.\n \n-        let coercion = Coercion(self.trace.clone());\n-        let r_borrow = self.fcx.infcx().next_region_var(coercion);\n-\n-        let inner_ty = match a.sty {\n+        match a.sty {\n             ty::ty_rptr(_, mt_a) => {\n                 if !can_coerce_mutbls(mt_a.mutbl, mutbl_b) {\n                     return Err(ty::terr_mutability);\n                 }\n-                mt_a.ty\n             }\n             _ => return self.subtype(a, b)\n-        };\n+        }\n \n-        let a_borrowed = ty::mk_rptr(self.tcx(),\n-                                     self.tcx().mk_region(r_borrow),\n-                                     mt {ty: inner_ty, mutbl: mutbl_b});\n-        try!(self.subtype(a_borrowed, b));\n-        if let Err(original_err) = self.subtype(a_borrowed, b) {\n+        let coercion = Coercion(self.trace.clone());\n+        let r_borrow = self.fcx.infcx().next_region_var(coercion);\n+        let autoref = Some(AutoPtr(r_borrow, mutbl_b, None));\n \n-        Ok(Some(AdjustDerefRef(AutoDerefRef {\n-            autoderefs: 1,\n-            autoref: Some(AutoPtr(r_borrow, mutbl_b, None))\n-        })))\n+        let r_borrow = self.tcx().mk_region(r_borrow);\n+        let lvalue_pref = match mutbl_b {\n+            ast::MutMutable => PreferMutLvalue,\n+            ast::MutImmutable => NoPreference\n+        };\n+        let mut first_error = None;\n+        let (_, autoderefs, success) = autoderef(self.fcx,\n+                                                 expr_a.span,\n+                                                 a,\n+                                                 Some(expr_a),\n+                                                 UnresolvedTypeAction::Ignore,\n+                                                 lvalue_pref,\n+                                                 |inner_ty, autoderef| {\n+            if autoderef == 0 {\n+                // Don't let this pass, otherwise it would cause\n+                // &T to autoref to &&T.\n+                return None;\n+            }\n+            let ty = ty::mk_rptr(self.tcx(), r_borrow,\n+                                 mt {ty: inner_ty, mutbl: mutbl_b});\n+            if let Err(err) = self.fcx.infcx().try(|_| self.subtype(ty, b)) {\n+                if first_error.is_none() {\n+                    first_error = Some(err);\n+                }\n+                None\n+            } else {\n+                Some(())\n+            }\n+        });\n+\n+        match success {\n+            Some(_) => {\n+                Ok(Some(AdjustDerefRef(AutoDerefRef {\n+                    autoderefs: autoderefs,\n+                    autoref: autoref\n+                })))\n+            }\n+            None => {\n+                // Return original error as if overloaded deref was never\n+                // attempted, to avoid irrelevant/confusing error messages.\n+                Err(first_error.expect(\"coerce_borrowed_pointer failed with no error?\"))\n+            }\n+        }\n     }\n \n \n@@ -426,7 +466,7 @@ pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             Coerce {\n                 fcx: fcx,\n                 trace: infer::TypeTrace::types(origin, false, a, b)\n-            }.coerce(a, b)\n+            }.coerce(expr, a, b)\n         })\n     }));\n     if let Some(adjustment) = adjustment {"}, {"sha": "56a32186c9eac2040ad9c910ef275fb2e013cba7", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ae076e1e3b037e557b613d97698a9f28a1683d8b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae076e1e3b037e557b613d97698a9f28a1683d8b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=ae076e1e3b037e557b613d97698a9f28a1683d8b", "patch": "@@ -11,6 +11,7 @@\n use super::probe;\n \n use check::{self, FnCtxt, NoPreference, PreferMutLvalue, callee, demand};\n+use check::UnresolvedTypeAction;\n use middle::mem_categorization::Typer;\n use middle::subst::{self};\n use middle::traits;\n@@ -141,10 +142,19 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // Commit the autoderefs by calling `autoderef again, but this\n         // time writing the results into the various tables.\n-        let (autoderefd_ty, n, result) =\n-            check::autoderef(\n-                self.fcx, self.span, unadjusted_self_ty, Some(self.self_expr), NoPreference,\n-                |_, n| if n == auto_deref_ref.autoderefs { Some(()) } else { None });\n+        let (autoderefd_ty, n, result) = check::autoderef(self.fcx,\n+                                                          self.span,\n+                                                          unadjusted_self_ty,\n+                                                          Some(self.self_expr),\n+                                                          UnresolvedTypeAction::Error,\n+                                                          NoPreference,\n+                                                          |_, n| {\n+            if n == auto_deref_ref.autoderefs {\n+                Some(())\n+            } else {\n+                None\n+            }\n+        });\n         assert_eq!(n, auto_deref_ref.autoderefs);\n         assert_eq!(result, Some(()));\n \n@@ -302,15 +312,18 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // yield an object-type (e.g., `&Object` or `Box<Object>`\n         // etc).\n \n-        let (_, _, result) =\n-            check::autoderef(\n-                self.fcx, self.span, self_ty, None, NoPreference,\n-                |ty, _| {\n-                    match ty.sty {\n-                        ty::ty_trait(ref data) => Some(closure(self, ty, &**data)),\n-                        _ => None,\n-                    }\n-                });\n+        let (_, _, result) = check::autoderef(self.fcx,\n+                                              self.span,\n+                                              self_ty,\n+                                              None,\n+                                              UnresolvedTypeAction::Error,\n+                                              NoPreference,\n+                                              |ty, _| {\n+            match ty.sty {\n+                ty::ty_trait(ref data) => Some(closure(self, ty, &**data)),\n+                _ => None,\n+            }\n+        });\n \n         match result {\n             Some(r) => r,\n@@ -517,6 +530,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                  expr.span,\n                                  self.fcx.expr_ty(expr),\n                                  Some(expr),\n+                                 UnresolvedTypeAction::Error,\n                                  PreferMutLvalue,\n                                  |_, autoderefs| {\n                                      if autoderefs == autoderef_count + 1 {"}, {"sha": "2e366f4450744b443485a6edf85d7599bc2ac672", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ae076e1e3b037e557b613d97698a9f28a1683d8b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae076e1e3b037e557b613d97698a9f28a1683d8b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ae076e1e3b037e557b613d97698a9f28a1683d8b", "patch": "@@ -14,7 +14,7 @@ use super::{CandidateSource,ImplSource,TraitSource};\n use super::suggest;\n \n use check;\n-use check::{FnCtxt, NoPreference};\n+use check::{FnCtxt, NoPreference, UnresolvedTypeAction};\n use middle::fast_reject;\n use middle::subst;\n use middle::subst::Subst;\n@@ -169,16 +169,19 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                           -> Option<Vec<CandidateStep<'tcx>>> {\n     let mut steps = Vec::new();\n \n-    let (fully_dereferenced_ty, dereferences, _) =\n-        check::autoderef(\n-            fcx, span, self_ty, None, NoPreference,\n-            |t, d| {\n-                let adjustment = AutoDeref(d);\n-                steps.push(CandidateStep { self_ty: t, adjustment: adjustment });\n-                None::<()> // keep iterating until we can't anymore\n-            });\n-\n-    match fully_dereferenced_ty.sty {\n+    let (final_ty, dereferences, _) = check::autoderef(fcx,\n+                                                       span,\n+                                                       self_ty,\n+                                                       None,\n+                                                       UnresolvedTypeAction::Error,\n+                                                       NoPreference,\n+                                                       |t, d| {\n+        let adjustment = AutoDeref(d);\n+        steps.push(CandidateStep { self_ty: t, adjustment: adjustment });\n+        None::<()> // keep iterating until we can't anymore\n+    });\n+\n+    match final_ty.sty {\n         ty::ty_vec(elem_ty, Some(len)) => {\n             steps.push(CandidateStep {\n                 self_ty: ty::mk_vec(fcx.tcx(), elem_ty, None),"}, {"sha": "1f04cab572a4be2774f4b5fc2bee15cedff176a0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ae076e1e3b037e557b613d97698a9f28a1683d8b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae076e1e3b037e557b613d97698a9f28a1683d8b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ae076e1e3b037e557b613d97698a9f28a1683d8b", "patch": "@@ -1865,6 +1865,17 @@ pub enum LvaluePreference {\n     NoPreference\n }\n \n+/// Whether `autoderef` requires types to resolve.\n+#[derive(Copy, Show, PartialEq, Eq)]\n+pub enum UnresolvedTypeAction {\n+    /// Produce an error and return `ty_err` whenever a type cannot\n+    /// be resolved (i.e. it is `ty_infer`).\n+    Error,\n+    /// Go on without emitting any errors, and return the unresolved\n+    /// type. Useful for probing, e.g. in coercions.\n+    Ignore\n+}\n+\n /// Executes an autoderef loop for the type `t`. At each step, invokes `should_stop` to decide\n /// whether to terminate the loop. Returns the final type and number of derefs that it performed.\n ///\n@@ -1874,6 +1885,7 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  sp: Span,\n                                  base_ty: Ty<'tcx>,\n                                  opt_expr: Option<&ast::Expr>,\n+                                 unresolved_type_action: UnresolvedTypeAction,\n                                  mut lvalue_pref: LvaluePreference,\n                                  mut should_stop: F)\n                                  -> (Ty<'tcx>, uint, Option<T>)\n@@ -1886,11 +1898,22 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n     let mut t = base_ty;\n     for autoderefs in 0..fcx.tcx().sess.recursion_limit.get() {\n-        let resolved_t = structurally_resolved_type(fcx, sp, t);\n-\n-        if ty::type_is_error(resolved_t) {\n-            return (resolved_t, autoderefs, None);\n-        }\n+        let resolved_t = match unresolved_type_action {\n+            UnresolvedTypeAction::Error => {\n+                let resolved_t = structurally_resolved_type(fcx, sp, t);\n+                if ty::type_is_error(resolved_t) {\n+                    return (resolved_t, autoderefs, None);\n+                }\n+                resolved_t\n+            }\n+            UnresolvedTypeAction::Ignore => {\n+                // We can continue even when the type cannot be resolved\n+                // (i.e. it is an inference variable) because `ty::deref`\n+                // and `try_overloaded_deref` both simply return `None`\n+                // in such a case without producing spurious errors.\n+                fcx.resolve_type_vars_if_possible(t)\n+            }\n+        };\n \n         match should_stop(resolved_t, autoderefs) {\n             Some(x) => return (resolved_t, autoderefs, Some(x)),\n@@ -2011,8 +2034,13 @@ fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n     // autoderef that normal method probing does. They could likely be\n     // consolidated.\n \n-    let (ty, autoderefs, final_mt) =\n-        autoderef(fcx, base_expr.span, base_ty, Some(base_expr), lvalue_pref, |adj_ty, idx| {\n+    let (ty, autoderefs, final_mt) = autoderef(fcx,\n+                                               base_expr.span,\n+                                               base_ty,\n+                                               Some(base_expr),\n+                                               UnresolvedTypeAction::Error,\n+                                               lvalue_pref,\n+                                               |adj_ty, idx| {\n             let autoderefref = ty::AutoDerefRef { autoderefs: idx, autoref: None };\n             step(adj_ty, autoderefref)\n         });\n@@ -3053,8 +3081,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n                                                 fcx.expr_ty(base));\n         // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n-        let (_, autoderefs, field_ty) =\n-            autoderef(fcx, expr.span, expr_t, Some(base), lvalue_pref, |base_t, _| {\n+        let (_, autoderefs, field_ty) = autoderef(fcx,\n+                                                  expr.span,\n+                                                  expr_t,\n+                                                  Some(base),\n+                                                  UnresolvedTypeAction::Error,\n+                                                  lvalue_pref,\n+                                                  |base_t, _| {\n                 match base_t.sty {\n                     ty::ty_struct(base_id, substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n@@ -3146,8 +3179,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 fcx.expr_ty(base));\n         let mut tuple_like = false;\n         // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n-        let (_, autoderefs, field_ty) =\n-            autoderef(fcx, expr.span, expr_t, Some(base), lvalue_pref, |base_t, _| {\n+        let (_, autoderefs, field_ty) = autoderef(fcx,\n+                                                  expr.span,\n+                                                  expr_t,\n+                                                  Some(base),\n+                                                  UnresolvedTypeAction::Error,\n+                                                  lvalue_pref,\n+                                                  |base_t, _| {\n                 match base_t.sty {\n                     ty::ty_struct(base_id, substs) => {\n                         tuple_like = ty::is_tuple_struct(tcx, base_id);"}, {"sha": "14fbc34c43bb491ab7aed4247ce64e7dc216bf1e", "filename": "src/test/compile-fail/coerce-overloaded-autoderef.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ae076e1e3b037e557b613d97698a9f28a1683d8b/src%2Ftest%2Fcompile-fail%2Fcoerce-overloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae076e1e3b037e557b613d97698a9f28a1683d8b/src%2Ftest%2Fcompile-fail%2Fcoerce-overloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-overloaded-autoderef.rs?ref=ae076e1e3b037e557b613d97698a9f28a1683d8b", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn borrow_mut<T>(x: &mut T) -> &mut T { x }\n+fn borrow<T>(x: &T) -> &T { x }\n+\n+fn borrow_mut2<T>(_: &mut T, _: &mut T) {}\n+fn borrow2<T>(_: &mut T, _: &T) {}\n+\n+fn double_mut_borrow<T>(x: &mut Box<T>) {\n+    let y = borrow_mut(x);\n+    let z = borrow_mut(x);\n+    //~^ ERROR cannot borrow `*x` as mutable more than once at a time\n+}\n+\n+fn double_imm_borrow(x: &mut Box<i32>) {\n+    let y = borrow(x);\n+    let z = borrow(x);\n+    **x += 1;\n+    //~^ ERROR cannot assign to `**x` because it is borrowed\n+}\n+\n+fn double_mut_borrow2<T>(x: &mut Box<T>) {\n+    borrow_mut2(x, x);\n+    //~^ ERROR cannot borrow `*x` as mutable more than once at a time\n+}\n+\n+fn double_borrow2<T>(x: &mut Box<T>) {\n+    borrow2(x, x);\n+    //~^ ERROR cannot borrow `*x` as immutable because it is also borrowed as mutable\n+}\n+\n+pub fn main() {}"}, {"sha": "98b9e453889c1deb6cdf4dd425b25644e7e24de9", "filename": "src/test/compile-fail/method-self-arg-1.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae076e1e3b037e557b613d97698a9f28a1683d8b/src%2Ftest%2Fcompile-fail%2Fmethod-self-arg-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae076e1e3b037e557b613d97698a9f28a1683d8b/src%2Ftest%2Fcompile-fail%2Fmethod-self-arg-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-self-arg-1.rs?ref=ae076e1e3b037e557b613d97698a9f28a1683d8b", "patch": "@@ -23,11 +23,6 @@ fn main() {\n                  //~| found `Foo`\n                  //~| expected &-ptr\n                  //~| found struct `Foo`\n-    Foo::bar(&&x); //~  ERROR mismatched types\n-                   //~| expected `&Foo`\n-                   //~| found `&&Foo`\n-                   //~| expected struct `Foo`\n-                   //~| found &-ptr\n     Foo::bar(&42is); //~  ERROR mismatched types\n                      //~| expected `&Foo`\n                      //~| found `&isize`"}, {"sha": "ae4db40411553d4efb4f165f9e97218c76d25b5c", "filename": "src/test/run-pass/coerce-overloaded-autoderef.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ae076e1e3b037e557b613d97698a9f28a1683d8b/src%2Ftest%2Frun-pass%2Fcoerce-overloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae076e1e3b037e557b613d97698a9f28a1683d8b/src%2Ftest%2Frun-pass%2Fcoerce-overloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-overloaded-autoderef.rs?ref=ae076e1e3b037e557b613d97698a9f28a1683d8b", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+\n+// Examples from the \"deref coercions\" RFC, at rust-lang/rfcs#241.\n+\n+fn use_ref<T>(_: &T) {}\n+fn use_mut<T>(_: &mut T) {}\n+\n+fn use_rc<T>(t: Rc<T>) {\n+    use_ref(&*t);  // what you have to write today\n+    use_ref(&t);   // what you'd be able to write\n+    use_ref(&&&&&&t);\n+    use_ref(&mut &&&&&t);\n+    use_ref(&&&mut &&&t);\n+}\n+\n+fn use_mut_box<T>(mut t: &mut Box<T>) {\n+    use_mut(&mut *t); // what you have to write today\n+    use_mut(t);       // what you'd be able to write\n+    use_mut(&mut &mut &mut t);\n+\n+    use_ref(&*t);      // what you have to write today\n+    use_ref(t);        // what you'd be able to write\n+    use_ref(&&&&&&t);\n+    use_ref(&mut &&&&&t);\n+    use_ref(&&&mut &&&t);\n+}\n+\n+fn use_nested<T>(t: &Box<T>) {\n+    use_ref(&**t);  // what you have to write today\n+    use_ref(t);     // what you'd be able to write (note: recursive deref)\n+    use_ref(&&&&&&t);\n+    use_ref(&mut &&&&&t);\n+    use_ref(&&&mut &&&t);\n+}\n+\n+fn use_slice(_: &[u8]) {}\n+fn use_slice_mut(_: &mut [u8]) {}\n+\n+fn use_vec(mut v: Vec<u8>) {\n+    use_slice_mut(&mut v[]); // what you have to write today\n+    use_slice_mut(&mut v);   // what you'd be able to write\n+    use_slice_mut(&mut &mut &mut v);\n+\n+    use_slice(&v[]);    // what you have to write today\n+    use_slice(&v);      // what you'd be able to write\n+    use_slice(&&&&&&v);\n+    use_slice(&mut &&&&&v);\n+    use_slice(&&&mut &&&v);\n+}\n+\n+fn use_vec_ref(v: &Vec<u8>) {\n+    use_slice(&v[]);    // what you have to write today\n+    use_slice(v);       // what you'd be able to write\n+    use_slice(&&&&&&v);\n+    use_slice(&mut &&&&&v);\n+    use_slice(&&&mut &&&v);\n+}\n+\n+pub fn main() {}"}]}