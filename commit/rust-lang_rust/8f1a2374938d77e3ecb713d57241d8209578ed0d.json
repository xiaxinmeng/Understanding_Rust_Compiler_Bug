{"sha": "8f1a2374938d77e3ecb713d57241d8209578ed0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMWEyMzc0OTM4ZDc3ZTNlY2I3MTNkNTcyNDFkODIwOTU3OGVkMGQ=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-21T18:44:48Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-22T12:34:39Z"}, "message": "&-matches: dogfood fixes!", "tree": {"sha": "e1bd315e1686dcc5ee2769c882ef0dabb94c69ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1bd315e1686dcc5ee2769c882ef0dabb94c69ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f1a2374938d77e3ecb713d57241d8209578ed0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f1a2374938d77e3ecb713d57241d8209578ed0d", "html_url": "https://github.com/rust-lang/rust/commit/8f1a2374938d77e3ecb713d57241d8209578ed0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f1a2374938d77e3ecb713d57241d8209578ed0d/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "017dac23017e2dcf8fe350b66821a9e50d39bbd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/017dac23017e2dcf8fe350b66821a9e50d39bbd1", "html_url": "https://github.com/rust-lang/rust/commit/017dac23017e2dcf8fe350b66821a9e50d39bbd1"}], "stats": {"total": 70, "additions": 35, "deletions": 35}, "files": [{"sha": "3e0ba4eb669f8e20941033c4c6b3558da1c2f5e6", "filename": "src/approx_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f1a2374938d77e3ecb713d57241d8209578ed0d/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1a2374938d77e3ecb713d57241d8209578ed0d/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=8f1a2374938d77e3ecb713d57241d8209578ed0d", "patch": "@@ -37,10 +37,10 @@ impl LintPass for ApproxConstant {\n }\n \n fn check_lit(cx: &Context, lit: &Lit, span: Span) {\n-    match &lit.node {\n-        &LitFloat(ref str, TyF32) => check_known_consts(cx, span, str, \"f32\"),\n-        &LitFloat(ref str, TyF64) => check_known_consts(cx, span, str, \"f64\"),\n-        &LitFloatUnsuffixed(ref str) => check_known_consts(cx, span, str, \"f{32, 64}\"),\n+    match lit.node {\n+        LitFloat(ref str, TyF32) => check_known_consts(cx, span, str, \"f32\"),\n+        LitFloat(ref str, TyF64) => check_known_consts(cx, span, str, \"f64\"),\n+        LitFloatUnsuffixed(ref str) => check_known_consts(cx, span, str, \"f{32, 64}\"),\n         _ => ()\n     }\n }"}, {"sha": "6537fcf4c1abb77be0211a1e01cdf0b26c969491", "filename": "src/bit_mask.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f1a2374938d77e3ecb713d57241d8209578ed0d/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1a2374938d77e3ecb713d57241d8209578ed0d/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=8f1a2374938d77e3ecb713d57241d8209578ed0d", "patch": "@@ -82,9 +82,9 @@ fn invert_cmp(cmp : BinOp_) -> BinOp_ {\n \n \n fn check_compare(cx: &Context, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u64, span: &Span) {\n-    match &bit_op.node {\n-        &ExprParen(ref subexp) => check_compare(cx, subexp, cmp_op, cmp_value, span),\n-        &ExprBinary(ref op, ref left, ref right) => {\n+    match bit_op.node {\n+        ExprParen(ref subexp) => check_compare(cx, subexp, cmp_op, cmp_value, span),\n+        ExprBinary(ref op, ref left, ref right) => {\n             if op.node != BiBitAnd && op.node != BiBitOr { return; }\n             fetch_int_literal(cx, right).or_else(|| fetch_int_literal(\n                 cx, left)).map_or((), |mask| check_bit_mask(cx, op.node,\n@@ -182,13 +182,13 @@ fn check_ineffective_gt(cx: &Context, span: Span, m: u64, c: u64, op: &str) {\n }\n \n fn fetch_int_literal(cx: &Context, lit : &Expr) -> Option<u64> {\n-    match &lit.node {\n-        &ExprLit(ref lit_ptr) => {\n+    match lit.node {\n+        ExprLit(ref lit_ptr) => {\n             if let &LitInt(value, _) = &lit_ptr.node {\n                 Option::Some(value) //TODO: Handle sign\n             } else { Option::None }\n         },\n-        &ExprPath(_, _) => {\n+        ExprPath(_, _) => {\n             // Important to let the borrow expire before the const lookup to avoid double\n             // borrowing.\n             let def_map = cx.tcx.def_map.borrow();"}, {"sha": "25e967b07e54d45df7b50349a2aa3e85ea5d2f36", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f1a2374938d77e3ecb713d57241d8209578ed0d/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1a2374938d77e3ecb713d57241d8209578ed0d/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=8f1a2374938d77e3ecb713d57241d8209578ed0d", "patch": "@@ -18,9 +18,9 @@ impl LintPass for EtaPass {\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-        match &expr.node {\n-            &ExprCall(_, ref args) |\n-            &ExprMethodCall(_, _, ref args) => {\n+        match expr.node {\n+            ExprCall(_, ref args) |\n+            ExprMethodCall(_, _, ref args) => {\n                 for arg in args {\n                     check_closure(cx, &*arg)\n                 }"}, {"sha": "5eaa0256402df186e0d37341cfc55e862ac11a11", "filename": "src/len_zero.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f1a2374938d77e3ecb713d57241d8209578ed0d/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1a2374938d77e3ecb713d57241d8209578ed0d/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=8f1a2374938d77e3ecb713d57241d8209578ed0d", "patch": "@@ -22,10 +22,10 @@ impl LintPass for LenZero {\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &Item) {\n-        match &item.node {\n-            &ItemTrait(_, _, _, ref trait_items) =>\n+        match item.node {\n+            ItemTrait(_, _, _, ref trait_items) =>\n                 check_trait_items(cx, item, trait_items),\n-            &ItemImpl(_, _, _, None, _, ref impl_items) => // only non-trait\n+            ItemImpl(_, _, _, None, _, ref impl_items) => // only non-trait\n                 check_impl_items(cx, item, impl_items),\n             _ => ()\n         }\n@@ -100,7 +100,7 @@ fn check_cmp(cx: &Context, span: Span, left: &Expr, right: &Expr, op: &str) {\n \n fn check_len_zero(cx: &Context, span: Span, method: &SpannedIdent,\n                   args: &[P<Expr>], lit: &Lit, op: &str) {\n-    if let &Spanned{node: LitInt(0, _), ..} = lit {\n+    if let Spanned{node: LitInt(0, _), ..} = *lit {\n         if method.node.name == \"len\" && args.len() == 1 &&\n             has_is_empty(cx, &*args[0]) {\n                 span_lint(cx, LEN_ZERO, span, &format!("}, {"sha": "81b03db5e143eabf04b214428d515f55aaab65a2", "filename": "src/misc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f1a2374938d77e3ecb713d57241d8209578ed0d/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1a2374938d77e3ecb713d57241d8209578ed0d/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=8f1a2374938d77e3ecb713d57241d8209578ed0d", "patch": "@@ -175,8 +175,8 @@ impl LintPass for CmpOwned {\n }\n \n fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n-    match &expr.node {\n-        &ExprMethodCall(Spanned{node: ref ident, ..}, _, ref args) => {\n+    match expr.node {\n+        ExprMethodCall(Spanned{node: ref ident, ..}, _, ref args) => {\n             let name = ident.name;\n             if name == \"to_string\" ||\n                 name == \"to_owned\" && is_str_arg(cx, args) {\n@@ -186,7 +186,7 @@ fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n                         snippet(cx, other_span, \"..\")))\n                 }\n         },\n-        &ExprCall(ref path, _) => {\n+        ExprCall(ref path, _) => {\n             if let &ExprPath(None, ref path) = &path.node {\n                 if match_path(path, &[\"String\", \"from_str\"]) ||\n                     match_path(path, &[\"String\", \"from\"]) {"}, {"sha": "7671d63a35d4fde92ed9aaf90de040759c311b70", "filename": "src/needless_bool.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f1a2374938d77e3ecb713d57241d8209578ed0d/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1a2374938d77e3ecb713d57241d8209578ed0d/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=8f1a2374938d77e3ecb713d57241d8209578ed0d", "patch": "@@ -60,9 +60,9 @@ fn fetch_bool_block(block: &Block) -> Option<bool> {\n }\n \n fn fetch_bool_expr(expr: &Expr) -> Option<bool> {\n-    match &expr.node {\n-        &ExprBlock(ref block) => fetch_bool_block(block),\n-        &ExprLit(ref lit_ptr) => if let &LitBool(value) = &lit_ptr.node {\n+    match expr.node {\n+        ExprBlock(ref block) => fetch_bool_block(block),\n+        ExprLit(ref lit_ptr) => if let LitBool(value) = lit_ptr.node {\n             Some(value) } else { None },\n         _ => None\n     }"}, {"sha": "b24ea345244aeedbb9d13281558393cc0afa2b3e", "filename": "src/strings.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f1a2374938d77e3ecb713d57241d8209578ed0d/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1a2374938d77e3ecb713d57241d8209578ed0d/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=8f1a2374938d77e3ecb713d57241d8209578ed0d", "patch": "@@ -65,13 +65,13 @@ fn is_string(cx: &Context, e: &Expr) -> bool {\n }\n \n fn is_add(cx: &Context, src: &Expr, target: &Expr) -> bool {\n-    match &src.node {\n-        &ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) =>\n+    match src.node {\n+        ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) =>\n             is_exp_equal(cx, target, left),\n-        &ExprBlock(ref block) => block.stmts.is_empty() &&\n+        ExprBlock(ref block) => block.stmts.is_empty() &&\n             block.expr.as_ref().map_or(false,\n                 |expr| is_add(cx, &*expr, target)),\n-        &ExprParen(ref expr) => is_add(cx, &*expr, target),\n+        ExprParen(ref expr) => is_add(cx, &*expr, target),\n         _ => false\n     }\n }"}, {"sha": "cb85fd6e0c65d612dd53ea5eeb4aa463819d5dc1", "filename": "src/types.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f1a2374938d77e3ecb713d57241d8209578ed0d/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1a2374938d77e3ecb713d57241d8209578ed0d/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=8f1a2374938d77e3ecb713d57241d8209578ed0d", "patch": "@@ -116,10 +116,10 @@ declare_lint!(pub CAST_POSSIBLE_TRUNCATION, Allow,\n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n-    let n = match &typ.sty {\n-    &ty::TyInt(i) =>  4 << (i as usize),\n-    &ty::TyUint(u) => 4 << (u as usize),\n-    _ => 0\n+    let n = match typ.sty {\n+        ty::TyInt(i) =>  4 << (i as usize),\n+        ty::TyUint(u) => 4 << (u as usize),\n+        _ => 0\n     };\n     // n == 4 is the usize/isize case\n     if n == 4 { ::std::usize::BITS } else { n }\n@@ -139,16 +139,16 @@ impl LintPass for CastPass {\n                 match (cast_from.is_integral(), cast_to.is_integral()) {\n                     (true, false) => {\n                         let from_nbits = int_ty_to_nbits(cast_from);\n-                        let to_nbits : usize = match &cast_to.sty {\n-                            &ty::TyFloat(ast::TyF32) => 32,\n-                            &ty::TyFloat(ast::TyF64) => 64,\n+                        let to_nbits : usize = match cast_to.sty {\n+                            ty::TyFloat(ast::TyF32) => 32,\n+                            ty::TyFloat(ast::TyF64) => 64,\n                             _ => 0\n                         };\n                         if from_nbits != 0 {\n                             if from_nbits >= to_nbits {\n                                 span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n                                           &format!(\"converting from {0} to {1}, which causes a loss of precision \\\n-                                          \t\t\t({0} is {2} bits wide, but {1}'s mantissa is only {3} bits wide)\",\n+                                                    ({0} is {2} bits wide, but {1}'s mantissa is only {3} bits wide)\",\n                                                    cast_from, cast_to, from_nbits, if to_nbits == 64 {52} else {23} ));\n                             }\n                         }"}]}