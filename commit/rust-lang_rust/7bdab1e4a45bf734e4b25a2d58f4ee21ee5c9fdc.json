{"sha": "7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiZGFiMWU0YTQ1YmY3MzRlNGIyNWEyZDU4ZjRlZTIxZWU1YzlmZGM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-08T16:00:23Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-08T16:00:23Z"}, "message": "Revert \"remove ctor from ast\"\n\nThis reverts commit ed3689d57c988e1dd477930d957c4308c37d1a64.", "tree": {"sha": "b24c818211cffeb1f2b8cc7bf7bc31fe3eecfdc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b24c818211cffeb1f2b8cc7bf7bc31fe3eecfdc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "html_url": "https://github.com/rust-lang/rust/commit/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79603f573e504163db7b5c2afa0917c27e3f98ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/79603f573e504163db7b5c2afa0917c27e3f98ed", "html_url": "https://github.com/rust-lang/rust/commit/79603f573e504163db7b5c2afa0917c27e3f98ed"}], "stats": {"total": 771, "additions": 651, "deletions": 120}, "files": [{"sha": "1c279f81cc39332b26bbd0dcf38bb5cd64013fdf", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -135,7 +135,7 @@ enum def {\n               @def,     // closed over def\n               node_id,  // expr node that creates the closure\n               node_id), // id for the block/body of the closure expr\n-    def_class(def_id),\n+    def_class(def_id, bool /* has constructor */),\n     def_typaram_binder(node_id), /* class, impl or trait that has ty params */\n     def_region(node_id),\n     def_label(node_id)\n@@ -235,9 +235,9 @@ impl def : cmp::Eq {\n                     _ => false\n                 }\n             }\n-            def_class(e0a) => {\n+            def_class(e0a, e1a) => {\n                 match (*other) {\n-                    def_class(e0b) => e0a == e0b,\n+                    def_class(e0b, e1b) => e0a == e0b && e1a == e1b,\n                     _ => false\n                 }\n             }\n@@ -1462,6 +1462,8 @@ type struct_def = {\n     fields: ~[@struct_field], /* fields */\n     methods: ~[@method],    /* methods */\n     /* (not including ctor or dtor) */\n+    /* ctor is optional, and will soon go away */\n+    ctor: Option<class_ctor>,\n     /* dtor is optional */\n     dtor: Option<class_dtor>\n };\n@@ -1561,6 +1563,7 @@ enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),\n     ii_foreign(@foreign_item),\n+    ii_ctor(class_ctor, ident, ~[ty_param], def_id /* parent id */),\n     ii_dtor(class_dtor, ident, ~[ty_param], def_id /* parent id */)\n }\n "}, {"sha": "d05c6eadaf6a31fc23c26615b99ab43e9fcfdf15", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -71,6 +71,9 @@ enum ast_node {\n     // order they are introduced.\n     node_arg(arg, uint),\n     node_local(uint),\n+    // Constructor for a class\n+    // def_id is parent id\n+    node_ctor(ident, ~[ty_param], @class_ctor, def_id, @path),\n     // Destructor for a class\n     node_dtor(~[ty_param], @class_dtor, def_id, @path),\n     node_block(blk),\n@@ -129,7 +132,7 @@ fn map_decoded_item(diag: span_handler,\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now:\n     match ii {\n-      ii_item(*) | ii_dtor(*) => { /* fallthrough */ }\n+      ii_item(*) | ii_ctor(*) | ii_dtor(*) => { /* fallthrough */ }\n       ii_foreign(i) => {\n         cx.map.insert(i.id, node_foreign_item(i, foreign_abi_rust_intrinsic,\n                                              @path));\n@@ -152,6 +155,18 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n         cx.local_id += 1u;\n     }\n     match fk {\n+      visit::fk_ctor(nm, attrs, tps, self_id, parent_id) => {\n+          let ct = @{node: {id: id,\n+                            attrs: attrs,\n+                            self_id: self_id,\n+                            dec: /* FIXME (#2543) */ copy decl,\n+                            body: /* FIXME (#2543) */ copy body},\n+                    span: sp};\n+          cx.map.insert(id, node_ctor(/* FIXME (#2543) */ copy nm,\n+                                      /* FIXME (#2543) */ copy tps,\n+                                      ct, parent_id,\n+                                      @/* FIXME (#2543) */ copy cx.path));\n+      }\n       visit::fk_dtor(tps, attrs, self_id, parent_id) => {\n           let dt = @{node: {id: id, attrs: attrs, self_id: self_id,\n                      body: /* FIXME (#2543) */ copy body}, span: sp};\n@@ -367,6 +382,9 @@ fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n       Some(node_local(_)) => { // add more info here\n         fmt!(\"local (id=%?)\", id)\n       }\n+      Some(node_ctor(*)) => { // add more info here\n+        fmt!(\"node_ctor (id=%?)\", id)\n+      }\n       Some(node_dtor(*)) => { // add more info here\n         fmt!(\"node_dtor (id=%?)\", id)\n       }"}, {"sha": "47cbdb7ac6cbbc8b5e05fdadf65dce0ff98be078", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -57,7 +57,7 @@ pure fn def_id_of_def(d: def) -> def_id {\n       def_fn(id, _) | def_static_method(id, _) | def_mod(id) |\n       def_foreign_mod(id) | def_const(id) |\n       def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n-      def_use(id) | def_class(id) => {\n+      def_use(id) | def_class(id, _) => {\n         id\n       }\n       def_arg(id, _) | def_local(id, _) | def_self(id) |\n@@ -339,6 +339,7 @@ impl inlined_item: inlined_item_utils {\n           ii_item(i) => /* FIXME (#2543) */ copy i.ident,\n           ii_foreign(i) => /* FIXME (#2543) */ copy i.ident,\n           ii_method(_, m) => /* FIXME (#2543) */ copy m.ident,\n+          ii_ctor(_, nm, _, _) => /* FIXME (#2543) */ copy nm,\n           ii_dtor(_, nm, _, _) => /* FIXME (#2543) */ copy nm\n         }\n     }\n@@ -348,6 +349,7 @@ impl inlined_item: inlined_item_utils {\n           ii_item(i) => i.id,\n           ii_foreign(i) => i.id,\n           ii_method(_, m) => m.id,\n+          ii_ctor(ctor, _, _, _) => ctor.node.id,\n           ii_dtor(dtor, _, _, _) => dtor.node.id\n         }\n     }\n@@ -357,6 +359,9 @@ impl inlined_item: inlined_item_utils {\n           ii_item(i) => v.visit_item(i, e, v),\n           ii_foreign(i) => v.visit_foreign_item(i, e, v),\n           ii_method(_, m) => visit::visit_method_helper(m, e, v),\n+          ii_ctor(ctor, nm, tps, parent_id) => {\n+              visit::visit_class_ctor_helper(ctor, nm, tps, parent_id, e, v);\n+          }\n           ii_dtor(dtor, _, tps, parent_id) => {\n               visit::visit_class_dtor_helper(dtor, tps, parent_id, e, v);\n           }\n@@ -490,6 +495,12 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             vfn(id);\n \n             match fk {\n+                visit::fk_ctor(_, _, tps, self_id, parent_id) => {\n+                    for vec::each(tps) |tp| { vfn(tp.id); }\n+                    vfn(id);\n+                    vfn(self_id);\n+                    vfn(parent_id.node);\n+                }\n                 visit::fk_dtor(tps, _, self_id, parent_id) => {\n                     for vec::each(tps) |tp| { vfn(tp.id); }\n                     vfn(id);"}, {"sha": "088df01985ee981217dc7c740fdd62e1fa4d135c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -271,6 +271,23 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n \n fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n                 -> @ast::struct_def {\n+    let resulting_optional_constructor;\n+    match struct_def.ctor {\n+        None => {\n+            resulting_optional_constructor = None;\n+        }\n+        Some(constructor) => {\n+            resulting_optional_constructor = Some({\n+                node: {\n+                    body: fld.fold_block(constructor.node.body),\n+                    dec: fold_fn_decl(constructor.node.dec, fld),\n+                    id: fld.new_id(constructor.node.id),\n+                    .. constructor.node\n+                },\n+                .. constructor\n+            });\n+        }\n+    }\n     let dtor = do option::map(&struct_def.dtor) |dtor| {\n         let dtor_body = fld.fold_block(dtor.node.body);\n         let dtor_id   = fld.new_id(dtor.node.id);\n@@ -281,6 +298,7 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n         traits: vec::map(struct_def.traits, |p| fold_trait_ref(*p, fld)),\n         fields: vec::map(struct_def.fields, |f| fold_struct_field(*f, fld)),\n         methods: vec::map(struct_def.methods, |m| fld.fold_method(*m)),\n+        ctor: resulting_optional_constructor,\n         dtor: dtor\n     };\n }\n@@ -567,6 +585,7 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n                                  |f| fld.fold_struct_field(*f)),\n                 methods: vec::map(struct_def.methods,\n                                   |m| fld.fold_method(*m)),\n+                ctor: None,\n                 dtor: dtor\n             })\n         }"}, {"sha": "22c25186c91826d6280b5d9c7599d9c3f89b82fc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 56, "deletions": 9, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -115,7 +115,8 @@ enum class_member {\n   So that we can distinguish a class ctor or dtor\n   from other class members\n  */\n-enum class_contents { dtor_decl(blk, ~[attribute], codemap::span),\n+enum class_contents { ctor_decl(fn_decl, ~[attribute], blk, codemap::span),\n+                      dtor_decl(blk, ~[attribute], codemap::span),\n                       members(~[@class_member]) }\n \n type arg_or_capture_item = Either<arg, capture_item>;\n@@ -2682,13 +2683,30 @@ impl parser {\n \n         let mut fields: ~[@struct_field];\n         let mut methods: ~[@method] = ~[];\n+        let mut the_ctor: Option<(fn_decl, ~[attribute], blk, codemap::span)>\n+            = None;\n         let mut the_dtor: Option<(blk, ~[attribute], codemap::span)> = None;\n+        let ctor_id = self.get_id();\n \n         if self.eat(token::LBRACE) {\n             // It's a record-like struct.\n             fields = ~[];\n             while self.token != token::RBRACE {\n                 match self.parse_class_item() {\n+                  ctor_decl(a_fn_decl, attrs, blk, s) => {\n+                      match the_ctor {\n+                        Some((_, _, _, s_first)) => {\n+                          self.span_note(s, #fmt(\"Duplicate constructor \\\n+                                     declaration for class %s\",\n+                                     *self.interner.get(class_name)));\n+                           self.span_fatal(copy s_first, ~\"First constructor \\\n+                                                          declared here\");\n+                        }\n+                        None    => {\n+                          the_ctor = Some((a_fn_decl, attrs, blk, s));\n+                        }\n+                      }\n+                  }\n                   dtor_decl(blk, attrs, s) => {\n                       match the_dtor {\n                         Some((_, _, s_first)) => {\n@@ -2746,14 +2764,36 @@ impl parser {\n                     self_id: self.get_id(),\n                     body: d_body},\n              span: d_s}};\n-        (class_name,\n-         item_class(@{\n-             traits: traits,\n-             fields: move fields,\n-             methods: move methods,\n-             dtor: actual_dtor\n-         }, ty_params),\n-         None)\n+        match the_ctor {\n+          Some((ct_d, ct_attrs, ct_b, ct_s)) => {\n+            (class_name,\n+             item_class(@{\n+                traits: traits,\n+                fields: move fields,\n+                methods: move methods,\n+                ctor: Some({\n+                 node: {id: ctor_id,\n+                        attrs: ct_attrs,\n+                        self_id: self.get_id(),\n+                        dec: ct_d,\n+                        body: ct_b},\n+                 span: ct_s}),\n+                dtor: actual_dtor\n+             }, ty_params),\n+             None)\n+          }\n+          None => {\n+            (class_name,\n+             item_class(@{\n+                    traits: traits,\n+                    fields: move fields,\n+                    methods: move methods,\n+                    ctor: None,\n+                    dtor: actual_dtor\n+             }, ty_params),\n+             None)\n+          }\n+        }\n     }\n \n     fn token_is_pound_or_doc_comment(++tok: token::token) -> bool {\n@@ -3057,6 +3097,12 @@ impl parser {\n         let mut methods: ~[@method] = ~[];\n         while self.token != token::RBRACE {\n             match self.parse_class_item() {\n+                ctor_decl(*) => {\n+                    self.span_fatal(copy self.span,\n+                                    ~\"deprecated explicit \\\n+                                      constructors are not allowed \\\n+                                      here\");\n+                }\n                 dtor_decl(blk, attrs, s) => {\n                     match the_dtor {\n                         Some((_, _, s_first)) => {\n@@ -3097,6 +3143,7 @@ impl parser {\n             traits: ~[],\n             fields: move fields,\n             methods: move methods,\n+            ctor: None,\n             dtor: actual_dtor\n         };\n     }"}, {"sha": "bff356e5cb72751a8a28821c1dc00fa51d4e1cb9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -653,6 +653,18 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n     }\n     bopen(s);\n     hardbreak_if_not_bol(s);\n+    do struct_def.ctor.iter |ctor| {\n+      maybe_print_comment(s, ctor.span.lo);\n+      print_outer_attributes(s, ctor.node.attrs);\n+      // Doesn't call head because there shouldn't be a space after new.\n+      cbox(s, indent_unit);\n+      ibox(s, 4);\n+      word(s.s, ~\"new(\");\n+      print_fn_args(s, ctor.node.dec, ~[], None);\n+      word(s.s, ~\")\");\n+      space(s.s);\n+      print_block(s, ctor.node.body);\n+    }\n     do struct_def.dtor.iter |dtor| {\n       hardbreak_if_not_bol(s);\n       maybe_print_comment(s, dtor.span.lo);"}, {"sha": "e6fd65eb458a2c98d38d17aa96a3da5bc06b7ca6", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -17,28 +17,29 @@ enum fn_kind {\n     fk_method(ident, ~[ty_param], @method),\n     fk_anon(proto, capture_clause),  //< an anonymous function like fn@(...)\n     fk_fn_block(capture_clause),     //< a block {||...}\n+    fk_ctor(ident, ~[attribute], ~[ty_param], node_id /* self id */,\n+            def_id /* parent class id */), // class constructor\n     fk_dtor(~[ty_param], ~[attribute], node_id /* self id */,\n             def_id /* parent class id */) // class destructor\n \n }\n \n fn name_of_fn(fk: fn_kind) -> ident {\n     match fk {\n-      fk_item_fn(name, _, _) | fk_method(name, _, _) => {\n-          /* FIXME (#2543) */ copy name\n-      }\n+      fk_item_fn(name, _, _) | fk_method(name, _, _)\n+          | fk_ctor(name, _, _, _, _) =>  /* FIXME (#2543) */ copy name,\n       fk_anon(*) | fk_fn_block(*) => parse::token::special_idents::anon,\n       fk_dtor(*)                  => parse::token::special_idents::dtor\n     }\n }\n \n fn tps_of_fn(fk: fn_kind) -> ~[ty_param] {\n     match fk {\n-        fk_item_fn(_, tps, _) | fk_method(_, tps, _) |\n-        fk_dtor(tps, _, _, _) => {\n-            /* FIXME (#2543) */ copy tps\n-        }\n-        fk_anon(*) | fk_fn_block(*) => ~[]\n+      fk_item_fn(_, tps, _) | fk_method(_, tps, _)\n+          | fk_ctor(_, _, tps, _, _) | fk_dtor(tps, _, _, _) => {\n+          /* FIXME (#2543) */ copy tps\n+      }\n+      fk_anon(*) | fk_fn_block(*) => ~[]\n     }\n }\n \n@@ -290,6 +291,17 @@ fn visit_method_helper<E>(m: @method, e: E, v: vt<E>) {\n                m.decl, m.body, m.span, m.id, e, v);\n }\n \n+// Similar logic to the comment on visit_method_helper - Tim\n+fn visit_class_ctor_helper<E>(ctor: class_ctor, nm: ident, tps: ~[ty_param],\n+                              parent_id: def_id, e: E, v: vt<E>) {\n+    v.visit_fn(fk_ctor(/* FIXME (#2543) */ copy nm,\n+                       ctor.node.attrs,\n+                       /* FIXME (#2543) */ copy tps,\n+                       ctor.node.self_id, parent_id),\n+        ctor.node.dec, ctor.node.body, ctor.span, ctor.node.id, e, v)\n+\n+}\n+\n fn visit_class_dtor_helper<E>(dtor: class_dtor, tps: ~[ty_param],\n                               parent_id: def_id, e: E, v: vt<E>) {\n     v.visit_fn(fk_dtor(/* FIXME (#2543) */ copy tps, dtor.node.attrs,\n@@ -318,7 +330,7 @@ fn visit_trait_method<E>(m: trait_method, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_struct_def<E>(sd: @struct_def, _nm: ast::ident, tps: ~[ty_param],\n+fn visit_struct_def<E>(sd: @struct_def, nm: ast::ident, tps: ~[ty_param],\n                        id: node_id, e: E, v: vt<E>) {\n     for sd.fields.each |f| {\n         v.visit_struct_field(*f, e, v);\n@@ -329,6 +341,9 @@ fn visit_struct_def<E>(sd: @struct_def, _nm: ast::ident, tps: ~[ty_param],\n     for sd.traits.each |p| {\n         visit_path(p.path, e, v);\n     }\n+    do option::iter(&sd.ctor) |ctor| {\n+      visit_class_ctor_helper(*ctor, nm, tps, ast_util::local_def(id), e, v);\n+    };\n     do option::iter(&sd.dtor) |dtor| {\n       visit_class_dtor_helper(*dtor, tps, ast_util::local_def(id), e, v)\n     };"}, {"sha": "197e567ab2f88d490eb58de797160dc80803ec40", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -123,6 +123,7 @@ enum Family {\n     Variant,               // v\n     Impl,                  // i\n     Trait,                 // I\n+    Class,                 // C\n     Struct,                // S\n     PublicField,           // g\n     PrivateField,          // j\n@@ -155,6 +156,7 @@ fn item_family(item: ebml2::Doc) -> Family {\n       'v' => Variant,\n       'i' => Impl,\n       'I' => Trait,\n+      'C' => Class,\n       'S' => Struct,\n       'g' => PublicField,\n       'j' => PrivateField,\n@@ -298,7 +300,8 @@ fn item_to_def_like(item: ebml2::Doc, did: ast::def_id, cnum: ast::crate_num)\n     let fam = item_family(item);\n     match fam {\n       Const     => dl_def(ast::def_const(did)),\n-      Struct    => dl_def(ast::def_class(did)),\n+      Class     => dl_def(ast::def_class(did, true)),\n+      Struct    => dl_def(ast::def_class(did, false)),\n       UnsafeFn  => dl_def(ast::def_fn(did, ast::unsafe_fn)),\n       Fn        => dl_def(ast::def_fn(did, ast::impure_fn)),\n       PureFn    => dl_def(ast::def_fn(did, ast::pure_fn)),\n@@ -819,6 +822,7 @@ fn item_family_to_str(fam: Family) -> ~str {\n       Variant => ~\"variant\",\n       Impl => ~\"impl\",\n       Trait => ~\"trait\",\n+      Class => ~\"class\",\n       Struct => ~\"struct\",\n       PublicField => ~\"public field\",\n       PrivateField => ~\"private field\","}, {"sha": "95696a14156699058d947e210fedcce7442cffb6", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -635,7 +635,12 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n         /* Now, make an item for the class itself */\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'S');\n+\n+        match struct_def.ctor {\n+            None => encode_family(ebml_w, 'S'),\n+            Some(_) => encode_family(ebml_w, 'C')\n+        }\n+\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n@@ -694,6 +699,21 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n         let bkts = create_index(idx);\n         encode_index(ebml_w, bkts, write_int);\n         ebml_w.end_tag();\n+\n+        /* Encode the constructor */\n+        for struct_def.ctor.each |ctor| {\n+            debug!(\"encoding info for ctor %s %d\",\n+                   ecx.tcx.sess.str_of(item.ident), ctor.node.id);\n+            index.push({\n+                val: ctor.node.id,\n+                pos: ebml_w.writer.tell()\n+            });\n+            encode_info_for_ctor(ecx, ebml_w, ctor.node.id, item.ident,\n+                                 path, if tps.len() > 0u {\n+                                     Some(ii_ctor(*ctor, item.ident, tps,\n+                                                  local_def(item.id))) }\n+                                 else { None }, tps);\n+        }\n       }\n       item_impl(tps, opt_trait, _, methods) => {\n         add_to_index();"}, {"sha": "39ec58c079ed9e19378022a272ea316d3408874a", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -262,6 +262,13 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n       ast::ii_foreign(i) => {\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n+      ast::ii_ctor(ctor, nm, tps, parent_id) => {\n+        let ctor_body = fld.fold_block(ctor.node.body);\n+        let ctor_decl = fold::fold_fn_decl(ctor.node.dec, fld);\n+        ast::ii_ctor({node: {body: ctor_body, dec: ctor_decl,\n+                              .. ctor.node},\n+            .. ctor}, nm, tps, parent_id)\n+      }\n       ast::ii_dtor(dtor, nm, tps, parent_id) => {\n         let dtor_body = fld.fold_block(dtor.node.body);\n         ast::ii_dtor({node: {body: dtor_body,\n@@ -295,6 +302,18 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n       ast::ii_foreign(i) => {\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n+      ast::ii_ctor(ctor, nm, tps, parent_id) => {\n+        let ctor_body = fld.fold_block(ctor.node.body);\n+        let ctor_attrs = fld.fold_attributes(ctor.node.attrs);\n+        let ctor_decl = fold::fold_fn_decl(ctor.node.dec, fld);\n+        let new_params = fold::fold_ty_params(tps, fld);\n+        let ctor_id = fld.new_id(ctor.node.id);\n+        let new_parent = xcx.tr_def_id(parent_id);\n+        ast::ii_ctor({node: {body: ctor_body, attrs: ctor_attrs,\n+                dec: ctor_decl, id: ctor_id,\n+                              .. ctor.node},\n+            .. ctor}, nm, new_params, new_parent)\n+      }\n       ast::ii_dtor(dtor, nm, tps, parent_id) => {\n         let dtor_body = fld.fold_block(dtor.node.body);\n         let dtor_attrs = fld.fold_attributes(dtor.node.attrs);\n@@ -350,8 +369,8 @@ impl ast::def: tr {\n                            xcx.tr_id(nid2),\n                            xcx.tr_id(nid3))\n           }\n-          ast::def_class(did) => {\n-            ast::def_class(did.tr(xcx))\n+          ast::def_class(did, has_constructor) => {\n+            ast::def_class(did.tr(xcx), has_constructor)\n           }\n           ast::def_region(nid) => ast::def_region(xcx.tr_id(nid)),\n           ast::def_typaram_binder(nid) => {"}, {"sha": "cc8d89a8ace76873dd5cf2ae355580cf3c64c80b", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -17,6 +17,10 @@ enum check_loan_ctxt = @{\n \n     reported: HashMap<ast::node_id, ()>,\n \n+    // Keep track of whether we're inside a ctor, so as to\n+    // allow mutating immutable fields in the same class if\n+    // we are in a ctor, we track the self id\n+    mut in_ctor: bool,\n     mut declared_purity: ast::purity,\n     mut fn_args: @~[ast::node_id]\n };\n@@ -58,6 +62,7 @@ fn check_loans(bccx: borrowck_ctxt,\n     let clcx = check_loan_ctxt(@{bccx: bccx,\n                                  req_maps: req_maps,\n                                  reported: HashMap(),\n+                                 mut in_ctor: false,\n                                  mut declared_purity: ast::impure_fn,\n                                  mut fn_args: @~[]});\n     let vt = visit::mk_vt(@{visit_expr: check_loans_in_expr,\n@@ -315,7 +320,10 @@ impl check_loan_ctxt {\n         debug!(\"check_assignment(cmt=%s)\",\n                self.bccx.cmt_to_repr(cmt));\n \n-        if self.is_local_variable(cmt) && at.checked_by_liveness() {\n+        if self.in_ctor && self.is_self_field(cmt)\n+            && at.checked_by_liveness() {\n+            // assigning to self.foo in a ctor is always allowed.\n+        } else if self.is_local_variable(cmt) && at.checked_by_liveness() {\n             // liveness guarantees that immutable local variables\n             // are only assigned once\n         } else {\n@@ -534,28 +542,42 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                      visitor: visit::vt<check_loan_ctxt>) {\n \n     debug!(\"purity on entry=%?\", copy self.declared_purity);\n-    do save_and_restore(&mut(self.declared_purity)) {\n-        do save_and_restore(&mut(self.fn_args)) {\n-            let is_stack_closure = self.is_stack_closure(id);\n-            let fty = ty::node_id_to_type(self.tcx(), id);\n-            self.declared_purity = ty::determine_inherited_purity(\n-                copy self.declared_purity,\n-                ty::ty_fn_purity(fty),\n-                ty::ty_fn_proto(fty));\n-\n-            match fk {\n-                visit::fk_anon(*) |\n-                visit::fk_fn_block(*) if is_stack_closure => {\n+    do save_and_restore(&mut(self.in_ctor)) {\n+        do save_and_restore(&mut(self.declared_purity)) {\n+            do save_and_restore(&mut(self.fn_args)) {\n+                let is_stack_closure = self.is_stack_closure(id);\n+                let fty = ty::node_id_to_type(self.tcx(), id);\n+                self.declared_purity = ty::determine_inherited_purity(\n+                    copy self.declared_purity,\n+                    ty::ty_fn_purity(fty),\n+                    ty::ty_fn_proto(fty));\n+\n+                // In principle, we could consider fk_anon(*) or\n+                // fk_fn_block(*) to be in a ctor, I suppose, but the\n+                // purpose of the in_ctor flag is to allow modifications\n+                // of otherwise immutable fields and typestate wouldn't be\n+                // able to \"see\" into those functions anyway, so it\n+                // wouldn't be very helpful.\n+                match fk {\n+                  visit::fk_ctor(*) => {\n+                    self.in_ctor = true;\n+                    self.fn_args = @decl.inputs.map(|i| i.id );\n+                  }\n+                  visit::fk_anon(*) |\n+                  visit::fk_fn_block(*) if is_stack_closure => {\n+                    self.in_ctor = false;\n                     // inherits the fn_args from enclosing ctxt\n-                }\n-                visit::fk_anon(*) | visit::fk_fn_block(*) |\n-                visit::fk_method(*) | visit::fk_item_fn(*) |\n-                visit::fk_dtor(*) => {\n+                  }\n+                  visit::fk_anon(*) | visit::fk_fn_block(*) |\n+                  visit::fk_method(*) | visit::fk_item_fn(*) |\n+                  visit::fk_dtor(*) => {\n+                    self.in_ctor = false;\n                     self.fn_args = @decl.inputs.map(|i| i.id );\n+                  }\n                 }\n-            }\n \n-            visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n+                visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n+            }\n         }\n     }\n     debug!(\"purity on exit=%?\", copy self.declared_purity);"}, {"sha": "5dfde8c9af649c4844c240e6439b786226a2640d", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -71,11 +71,11 @@ fn req_loans_in_fn(fk: visit::fn_kind,\n     self.root_ub = body.node.id;\n \n     match fk {\n-        visit::fk_anon(*) | visit::fk_fn_block(*) => {}\n-        visit::fk_item_fn(*) | visit::fk_method(*) |\n-        visit::fk_dtor(*) => {\n-            self.item_ub = body.node.id;\n-        }\n+      visit::fk_anon(*) | visit::fk_fn_block(*) => {}\n+      visit::fk_item_fn(*) | visit::fk_method(*) |\n+      visit::fk_ctor(*) | visit::fk_dtor(*) => {\n+        self.item_ub = body.node.id;\n+      }\n     }\n \n     visit::visit_fn(fk, decl, body, sp, id, self, v);"}, {"sha": "e2b85441a8fda17657dbd5f01544369d27ccac8d", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -181,9 +181,9 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n         // variables.  This list is used below to avoid checking and reporting\n         // on a given variable twice.\n         let cap_clause = match fk {\n-            visit::fk_anon(_, cc) | visit::fk_fn_block(cc) => cc,\n-            visit::fk_item_fn(*) | visit::fk_method(*) |\n-            visit::fk_dtor(*) => @~[]\n+          visit::fk_anon(_, cc) | visit::fk_fn_block(cc) => cc,\n+          visit::fk_item_fn(*) | visit::fk_method(*) |\n+          visit::fk_ctor(*) | visit::fk_dtor(*) => @~[]\n         };\n         let captured_vars = do (*cap_clause).map |cap_item| {\n             let cap_def = cx.tcx.def_map.get(cap_item.id);"}, {"sha": "12d63cdacbf6729f4506d4e628014d076477dd15", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 173, "deletions": 29, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -35,6 +35,12 @@\n  * Any use of the variable where the variable is dead afterwards is a\n  * last use.\n  *\n+ * # Extension to handle constructors\n+ *\n+ * Each field is assigned an index just as with local variables.  A use of\n+ * `self` is considered a use of all fields.  A use of `self.f` is just a use\n+ * of `f`.\n+ *\n  * # Implementation details\n  *\n  * The actual implementation contains two (nested) walks over the AST.\n@@ -90,6 +96,8 @@\n  * - `no_ret_var`: a synthetic variable that is only 'read' from, the\n  *   fallthrough node.  This allows us to detect functions where we fail\n  *   to return explicitly.\n+ *\n+ * - `self_var`: a variable representing 'self'\n  */\n \n use dvec::DVec;\n@@ -222,7 +230,7 @@ impl LiveNode {\n \n fn invalid_node() -> LiveNode { LiveNode(uint::max_value) }\n \n-enum RelevantDef { RelevantVar(node_id) }\n+enum RelevantDef { RelevantVar(node_id), RelevantSelf }\n \n type CaptureInfo = {ln: LiveNode, is_move: bool, rv: RelevantDef};\n \n@@ -242,12 +250,15 @@ struct LocalInfo {\n enum VarKind {\n     Arg(node_id, ident, rmode),\n     Local(LocalInfo),\n+    Field(ident),\n     Self,\n     ImplicitRet\n }\n \n fn relevant_def(def: def) -> Option<RelevantDef> {\n     match def {\n+      def_self(_) => Some(RelevantSelf),\n+\n       def_binding(nid, _) |\n       def_arg(nid, _) |\n       def_local(nid, _) => Some(RelevantVar(nid)),\n@@ -265,6 +276,7 @@ struct IrMaps {\n     mut num_vars: uint,\n     live_node_map: HashMap<node_id, LiveNode>,\n     variable_map: HashMap<node_id, Variable>,\n+    field_map: HashMap<ident, Variable>,\n     capture_map: HashMap<node_id, @~[CaptureInfo]>,\n     mut var_kinds: ~[VarKind],\n     mut lnks: ~[LiveNodeKind],\n@@ -281,6 +293,7 @@ fn IrMaps(tcx: ty::ctxt, method_map: typeck::method_map,\n         live_node_map: HashMap(),\n         variable_map: HashMap(),\n         capture_map: HashMap(),\n+        field_map: HashMap(),\n         var_kinds: ~[],\n         lnks: ~[]\n     }\n@@ -310,12 +323,15 @@ impl IrMaps {\n         self.num_vars += 1u;\n \n         match vk {\n-            Local(LocalInfo {id:node_id, _}) |\n-            Arg(node_id, _, _) => {\n-                self.variable_map.insert(node_id, v);\n-            }\n-            Self | ImplicitRet => {\n-            }\n+          Local(LocalInfo {id:node_id, _}) |\n+          Arg(node_id, _, _) => {\n+            self.variable_map.insert(node_id, v);\n+          }\n+          Field(name) => {\n+            self.field_map.insert(name, v);\n+          }\n+          Self | ImplicitRet => {\n+          }\n         }\n \n         debug!(\"%s is %?\", v.to_str(), vk);\n@@ -335,10 +351,11 @@ impl IrMaps {\n \n     fn variable_name(var: Variable) -> ~str {\n         match copy self.var_kinds[*var] {\n-            Local(LocalInfo {ident: nm, _}) |\n-            Arg(_, nm, _) => self.tcx.sess.str_of(nm),\n-            Self => ~\"self\",\n-            ImplicitRet => ~\"<implicit-ret>\"\n+          Local(LocalInfo {ident: nm, _}) |\n+          Arg(_, nm, _) => self.tcx.sess.str_of(nm),\n+          Field(nm) => ~\"self.\" + self.tcx.sess.str_of(nm),\n+          Self => ~\"self\",\n+          ImplicitRet => ~\"<implicit-ret>\"\n         }\n     }\n \n@@ -382,7 +399,7 @@ impl IrMaps {\n             (*v).push(id);\n           }\n           Arg(_, _, by_ref) |\n-          Arg(_, _, by_val) | Self | ImplicitRet |\n+          Arg(_, _, by_val) | Self | Field(_) | ImplicitRet |\n           Local(LocalInfo {kind: FromMatch(bind_by_implicit_ref), _}) => {\n             debug!(\"--but it is not owned\");\n           }\n@@ -411,14 +428,22 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     // and so forth:\n     visit::visit_fn(fk, decl, body, sp, id, fn_maps, v);\n \n+    match fk {\n+      visit::fk_ctor(_, _, _, _, class_did) => {\n+        add_class_fields(fn_maps, class_did);\n+      }\n+      _ => {}\n+    }\n+\n     // Special nodes and variables:\n     // - exit_ln represents the end of the fn, either by return or fail\n     // - implicit_ret_var is a pseudo-variable that represents\n     //   an implicit return\n     let specials = {\n         exit_ln: (*fn_maps).add_live_node(ExitNode),\n         fallthrough_ln: (*fn_maps).add_live_node(ExitNode),\n-        no_ret_var: (*fn_maps).add_variable(ImplicitRet)\n+        no_ret_var: (*fn_maps).add_variable(ImplicitRet),\n+        self_var: (*fn_maps).add_variable(Self)\n     };\n \n     // compute liveness\n@@ -435,9 +460,18 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     });\n     check_vt.visit_block(body, lsets, check_vt);\n     lsets.check_ret(id, sp, fk, entry_ln);\n+    lsets.check_fields(sp, entry_ln);\n     lsets.warn_about_unused_args(sp, decl, entry_ln);\n }\n \n+fn add_class_fields(self: @IrMaps, did: def_id) {\n+    for ty::lookup_class_fields(self.tcx, did).each |field_ty| {\n+        assert field_ty.id.crate == local_crate;\n+        let var = self.add_variable(Field(field_ty.ident));\n+        self.field_map.insert(field_ty.ident, var);\n+    }\n+}\n+\n fn visit_local(local: @local, &&self: @IrMaps, vt: vt<@IrMaps>) {\n     let def_map = self.tcx.def_map;\n     do pat_util::pat_bindings(def_map, local.node.pat) |_bm, p_id, sp, path| {\n@@ -561,7 +595,8 @@ fn invalid_users() -> users {\n type Specials = {\n     exit_ln: LiveNode,\n     fallthrough_ln: LiveNode,\n-    no_ret_var: Variable\n+    no_ret_var: Variable,\n+    self_var: Variable\n };\n \n const ACC_READ: uint = 1u;\n@@ -614,6 +649,7 @@ impl Liveness {\n \n     fn variable_from_rdef(rv: RelevantDef, span: span) -> Variable {\n         match rv {\n+          RelevantSelf => self.s.self_var,\n           RelevantVar(nid) => self.variable(nid, span)\n         }\n     }\n@@ -898,6 +934,14 @@ impl Liveness {\n             }\n         }\n \n+        // as above, the \"self\" variable is a non-owned variable\n+        self.acc(self.s.exit_ln, self.s.self_var, ACC_READ);\n+\n+        // in a ctor, there is an implicit use of self.f for all fields f:\n+        for self.ir.field_map.each_value |var| {\n+            self.acc(self.s.exit_ln, var, ACC_READ|ACC_USE);\n+        }\n+\n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n         self.init_from_succ(self.s.fallthrough_ln, self.s.exit_ln);\n@@ -979,11 +1023,24 @@ impl Liveness {\n           // Interesting cases with control flow or which gen/kill\n \n           expr_path(_) => {\n-              self.access_path(expr, succ, ACC_READ | ACC_USE)\n+            self.access_path(expr, succ, ACC_READ | ACC_USE)\n           }\n \n-          expr_field(e, _, _) => {\n-              self.propagate_through_expr(e, succ)\n+          expr_field(e, nm, _) => {\n+            // If this is a reference to `self.f` inside of a ctor,\n+            // then we treat it as a read of that variable.\n+            // Otherwise, we ignore it and just propagate down to\n+            // process `e`.\n+            match self.as_self_field(e, nm) {\n+              Some((ln, var)) => {\n+                self.init_from_succ(ln, succ);\n+                self.acc(ln, var, ACC_READ | ACC_USE);\n+                ln\n+              }\n+              None => {\n+                self.propagate_through_expr(e, succ)\n+              }\n+            }\n           }\n \n           expr_fn(*) | expr_fn_block(*) => {\n@@ -1212,8 +1269,8 @@ impl Liveness {\n         // In general, the full flow graph structure for an\n         // assignment/move/etc can be handled in one of two ways,\n         // depending on whether what is being assigned is a \"tracked\n-        // value\" or not. A tracked value is basically a local\n-        // variable or argument.\n+        // value\" or not. A tracked value is basically a local variable\n+        // or argument, or a self-field (`self.f`) in a ctor.\n         //\n         // The two kinds of graphs are:\n         //\n@@ -1236,11 +1293,12 @@ impl Liveness {\n         //\n         // # Tracked lvalues\n         //\n-        // A tracked lvalue is a local variable/argument `x`.  In\n+        // A tracked lvalue is either a local variable/argument `x` or\n+        // else it is a self-field `self.f` in a constructor.  In\n         // these cases, the link_node where the write occurs is linked\n-        // to node id of `x`.  The `write_lvalue()` routine generates\n-        // the contents of this node.  There are no subcomponents to\n-        // consider.\n+        // to node id of `x` or `self`, respectively.  The\n+        // `write_lvalue()` routine generates the contents of this\n+        // node.  There are no subcomponents to consider.\n         //\n         // # Non-tracked lvalues\n         //\n@@ -1257,9 +1315,12 @@ impl Liveness {\n         // just ignore such cases and treat them as reads.\n \n         match expr.node {\n-            expr_path(_) => succ,\n-            expr_field(e, _, _) => self.propagate_through_expr(e, succ),\n-            _ => self.propagate_through_expr(expr, succ)\n+          expr_path(_) => succ,\n+          expr_field(e, nm, _) => match self.as_self_field(e, nm) {\n+            Some(_) => succ,\n+            None => self.propagate_through_expr(e, succ)\n+          },\n+          _ => self.propagate_through_expr(expr, succ)\n         }\n     }\n \n@@ -1269,6 +1330,14 @@ impl Liveness {\n                     acc: uint) -> LiveNode {\n         match expr.node {\n           expr_path(_) => self.access_path(expr, succ, acc),\n+          expr_field(e, nm, _) => match self.as_self_field(e, nm) {\n+            Some((ln, var)) => {\n+                self.init_from_succ(ln, succ);\n+                self.acc(ln, var, acc);\n+                ln\n+            }\n+            None => succ\n+          },\n \n           // We do not track other lvalues, so just propagate through\n           // to their subcomponents.  Also, it may happen that\n@@ -1281,6 +1350,26 @@ impl Liveness {\n     fn access_path(expr: @expr, succ: LiveNode, acc: uint) -> LiveNode {\n         let def = self.tcx.def_map.get(expr.id);\n         match relevant_def(def) {\n+          Some(RelevantSelf) => {\n+            // Accessing `self` is like accessing every field of\n+            // the current object. This allows something like\n+            // `self = ...;` (it will be considered a write to\n+            // every field, sensibly enough), though the borrowck\n+            // pass will reject it later on.\n+            //\n+            // Also, note that, within a ctor at least, an\n+            // expression like `self.f` is \"shortcircuiting\"\n+            // before it reaches this point by the code for\n+            // expr_field.\n+            let ln = self.live_node(expr.id, expr.span);\n+            if acc != 0u {\n+                self.init_from_succ(ln, succ);\n+                for self.ir.field_map.each_value |var| {\n+                    self.acc(ln, var, acc);\n+                }\n+            }\n+            ln\n+          }\n           Some(RelevantVar(nid)) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0u {\n@@ -1294,6 +1383,29 @@ impl Liveness {\n         }\n     }\n \n+    fn as_self_field(expr: @expr,\n+                     fld: ident) -> Option<(LiveNode,Variable)> {\n+        // If we checking a constructor, then we treat self.f as a\n+        // variable.  we use the live_node id that will be assigned to\n+        // the reference to self but the variable id for `f`.\n+        match expr.node {\n+          expr_path(_) => {\n+            let def = self.tcx.def_map.get(expr.id);\n+            match def {\n+              def_self(_) => {\n+                // Note: the field_map is empty unless we are in a ctor\n+                return self.ir.field_map.find(fld).map(|var| {\n+                    let ln = self.live_node(expr.id, expr.span);\n+                    (ln, *var)\n+                });\n+              }\n+              _ => return None\n+            }\n+          }\n+          _ => return None\n+        }\n+    }\n+\n     fn propagate_through_loop(expr: @expr,\n                               cond: Option<@expr>,\n                               body: blk,\n@@ -1501,7 +1613,24 @@ enum ReadKind {\n }\n \n impl @Liveness {\n-    fn check_ret(id: node_id, sp: span, _fk: visit::fn_kind,\n+    fn check_fields(sp: span, entry_ln: LiveNode) {\n+        for self.ir.field_map.each |nm, var| {\n+            match self.live_on_entry(entry_ln, var) {\n+              None => { /* ok */ }\n+              Some(ExitNode) => {\n+                self.tcx.sess.span_err(\n+                    sp, fmt!(\"field `self.%s` is never initialized\",\n+                             self.tcx.sess.str_of(nm)));\n+              }\n+              Some(lnk) => {\n+                self.report_illegal_read(\n+                    sp, lnk, var, PossiblyUninitializedField);\n+              }\n+            }\n+        }\n+    }\n+\n+    fn check_ret(id: node_id, sp: span, fk: visit::fn_kind,\n                  entry_ln: LiveNode) {\n         if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             // if no_ret_var is live, then we fall off the end of the\n@@ -1515,8 +1644,15 @@ impl @Liveness {\n                 self.tcx.sess.span_err(\n                     sp, ~\"some control paths may return\");\n             } else {\n-                self.tcx.sess.span_err(\n-                    sp, ~\"not all control paths return a value\");\n+                match fk {\n+                  visit::fk_ctor(*) => {\n+                    // ctors are written as though they are unit.\n+                  }\n+                  _ => {\n+                    self.tcx.sess.span_err(\n+                        sp, ~\"not all control paths return a value\");\n+                  }\n+                }\n             }\n         }\n     }\n@@ -1601,6 +1737,7 @@ impl @Liveness {\n                     let var = self.variable(nid, expr.span);\n                     self.warn_about_dead_assign(expr.span, ln, var);\n                   }\n+                  Some(RelevantSelf) => {}\n                   None => {}\n                 }\n               }\n@@ -1659,6 +1796,13 @@ impl @Liveness {\n                           copy or move mode\", self.tcx.sess.str_of(name)));\n                 return;\n               }\n+              Field(name) => {\n+                self.tcx.sess.span_err(\n+                    move_span,\n+                    fmt!(\"illegal move from field `%s`\",\n+                         self.tcx.sess.str_of(name)));\n+                return;\n+              }\n               Self => {\n                 self.tcx.sess.span_err(\n                     move_span,"}, {"sha": "ff708b7f4efa12b0e433317ed870088c32555b0a", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -305,16 +305,16 @@ fn resolve_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n               visitor: visit::vt<ctxt>) {\n \n     let fn_cx = match fk {\n-        visit::fk_item_fn(*) | visit::fk_method(*) |\n-        visit::fk_dtor(*) => {\n-            // Top-level functions are a root scope.\n-            ctxt {parent: Some(id),.. cx}\n-        }\n+      visit::fk_item_fn(*) | visit::fk_method(*) |\n+      visit::fk_ctor(*) | visit::fk_dtor(*) => {\n+        // Top-level functions are a root scope.\n+        ctxt {parent: Some(id),.. cx}\n+      }\n \n-        visit::fk_anon(*) | visit::fk_fn_block(*) => {\n-            // Closures continue with the inherited scope.\n-            cx\n-        }\n+      visit::fk_anon(*) | visit::fk_fn_block(*) => {\n+        // Closures continue with the inherited scope.\n+        cx\n+      }\n     };\n \n     debug!(\"visiting fn with body %d. cx.parent: %? \\\n@@ -641,7 +641,7 @@ fn determine_rp_in_ty(ty: @ast::ty,\n     match ty.node {\n       ast::ty_path(path, id) => {\n         match cx.def_map.get(id) {\n-          ast::def_ty(did) | ast::def_class(did) => {\n+          ast::def_ty(did) | ast::def_class(did, _) => {\n             if did.crate == ast::local_crate {\n                 if cx.opt_region_is_relevant(path.rp) {\n                     cx.add_dep(did.node);"}, {"sha": "5f30346a28e8f90fff6f4d1d84b9655cf5ed040e", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 64, "deletions": 15, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -757,7 +757,7 @@ struct Resolver {\n     unused_import_lint_level: level,\n \n     trait_info: HashMap<def_id,@HashMap<ident,()>>,\n-    structs: HashMap<def_id,()>,\n+    structs: HashMap<def_id,bool>,\n \n     // The number of imports that are currently unresolved.\n     mut unresolved_imports: uint,\n@@ -1069,15 +1069,36 @@ impl Resolver {\n             }\n \n             // These items live in both the type and value namespaces.\n-            item_class(*) => {\n-                let (name_bindings, new_parent) =\n-                    self.add_child(ident, parent, ~[TypeNS], sp);\n+            item_class(struct_definition, _) => {\n+                let new_parent =\n+                    match struct_definition.ctor {\n+                    None => {\n+                        let (name_bindings, new_parent) =\n+                            self.add_child(ident, parent, ~[TypeNS], sp);\n \n-                (*name_bindings).define_type\n-                    (privacy, def_ty(local_def(item.id)), sp);\n+                        (*name_bindings).define_type\n+                            (privacy, def_ty(local_def(item.id)), sp);\n+                        new_parent\n+                    }\n+                    Some(ctor) => {\n+                        let (name_bindings, new_parent) =\n+                            self.add_child(ident, parent, ~[ValueNS, TypeNS],\n+                                           sp);\n+\n+                        (*name_bindings).define_type\n+                            (privacy, def_ty(local_def(item.id)), sp);\n+\n+                        let purity = impure_fn;\n+                        let ctor_def = def_fn(local_def(ctor.node.id),\n+                                              purity);\n+                        (*name_bindings).define_value(privacy, ctor_def, sp);\n+                        new_parent\n+                    }\n+                };\n \n                 // Record the def ID of this struct.\n-                self.structs.insert(local_def(item.id), ());\n+                self.structs.insert(local_def(item.id),\n+                                    struct_definition.ctor.is_some());\n \n                 visit_item(item, new_parent, visitor);\n             }\n@@ -1162,7 +1183,7 @@ impl Resolver {\n                                      def_variant(item_id,\n                                                  local_def(variant.node.id)),\n                                      variant.span);\n-                self.structs.insert(local_def(variant.node.id), ());\n+                self.structs.insert(local_def(variant.node.id), false);\n             }\n             enum_variant_kind(enum_definition) => {\n                 (*child).define_type(privacy,\n@@ -1499,12 +1520,18 @@ impl Resolver {\n \n             child_name_bindings.define_type(Public, def, dummy_sp());\n           }\n-          def_class(def_id) => {\n+          def_class(def_id, has_constructor) => {\n             debug!(\"(building reduced graph for external \\\n-                    crate) building type %s\",\n-                   final_ident);\n+                    crate) building type %s (value? %d)\",\n+                   final_ident,\n+                   if has_constructor { 1 } else { 0 });\n             child_name_bindings.define_type(Public, def, dummy_sp());\n-            self.structs.insert(def_id, ());\n+\n+            if has_constructor {\n+                child_name_bindings.define_value(Public, def, dummy_sp());\n+            }\n+\n+            self.structs.insert(def_id, has_constructor);\n           }\n           def_self(*) | def_arg(*) | def_local(*) |\n           def_prim_ty(*) | def_ty_param(*) | def_binding(*) |\n@@ -3279,6 +3306,7 @@ impl Resolver {\n                                    struct_def.traits,\n                                    struct_def.fields,\n                                    struct_def.methods,\n+                                   struct_def.ctor,\n                                    struct_def.dtor,\n                                    visitor);\n             }\n@@ -3520,6 +3548,7 @@ impl Resolver {\n                      traits: ~[@trait_ref],\n                      fields: ~[@struct_field],\n                      methods: ~[@method],\n+                     optional_constructor: Option<class_ctor>,\n                      optional_destructor: Option<class_dtor>,\n                      visitor: ResolveVisitor) {\n \n@@ -3571,6 +3600,23 @@ impl Resolver {\n                 self.resolve_type(field.node.ty, visitor);\n             }\n \n+            // Resolve the constructor, if applicable.\n+            match optional_constructor {\n+                None => {\n+                    // Nothing to do.\n+                }\n+                Some(constructor) => {\n+                    self.resolve_function(NormalRibKind,\n+                                          Some(@constructor.node.dec),\n+                                          NoTypeParameters,\n+                                          constructor.node.body,\n+                                          HasSelfBinding(constructor.node.\n+                                                         self_id),\n+                                          NoCaptureClause,\n+                                          visitor);\n+                }\n+            }\n+\n             // Resolve the destructor, if applicable.\n             match optional_destructor {\n                 None => {\n@@ -4043,7 +4089,9 @@ impl Resolver {\n                     match self.resolve_path(path, TypeNS, false, visitor) {\n                         Some(def_ty(class_id))\n                                 if self.structs.contains_key(class_id) => {\n-                            let class_def = def_class(class_id);\n+                            let has_constructor = self.structs.get(class_id);\n+                            let class_def = def_class(class_id,\n+                                                      has_constructor);\n                             self.record_def(pattern.id, class_def);\n                         }\n                         Some(definition @ def_variant(_, variant_id))\n@@ -4511,9 +4559,10 @@ impl Resolver {\n                 //    let bar = Bar { ... } // no type parameters\n \n                 match self.resolve_path(path, TypeNS, false, visitor) {\n-                    Some(def_ty(class_id)) | Some(def_class(class_id))\n+                    Some(def_ty(class_id)) | Some(def_class(class_id, _))\n                             if self.structs.contains_key(class_id) => {\n-                        let class_def = def_class(class_id);\n+                        let has_constructor = self.structs.get(class_id);\n+                        let class_def = def_class(class_id, has_constructor);\n                         self.record_def(expr.id, class_def);\n                     }\n                     Some(definition @ def_variant(_, class_id))"}, {"sha": "95711f8da36a73112f04505ec39c744a55925d97", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 75, "deletions": 4, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -1596,14 +1596,18 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n     // translation calls that don't have a return value (trans_crate,\n     // trans_mod, trans_item, et cetera) and those that do\n     // (trans_block, trans_expr, et cetera).\n-    if body.node.expr.is_none() || ty::type_is_bot(block_ty) ||\n-        ty::type_is_nil(block_ty)\n-    {\n+\n+    if !ccx.class_ctors.contains_key(id) // hack --\n+       /* avoids the need for special cases to assign a type to\n+          the constructor body (since it has no explicit return) */\n+      &&\n+      (body.node.expr.is_none() ||\n+       ty::type_is_bot(block_ty) ||\n+       ty::type_is_nil(block_ty))  {\n         bcx = controlflow::trans_block(bcx, body, expr::Ignore);\n     } else {\n         bcx = controlflow::trans_block(bcx, body, expr::SaveIn(fcx.llretptr));\n     }\n-\n     finish(bcx);\n     cleanup_and_Br(bcx, bcx_top, fcx.llreturn);\n \n@@ -1694,6 +1698,60 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n     finish_fn(fcx, lltop);\n }\n \n+fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n+                    body: ast::blk, llctor_decl: ValueRef,\n+                    psubsts: param_substs, ctor_id: ast::node_id,\n+                    parent_id: ast::def_id, sp: span) {\n+    // Add ctor to the ctor map\n+    ccx.class_ctors.insert(ctor_id, parent_id);\n+\n+    // Translate the ctor\n+\n+    // Set up the type for the result of the ctor\n+    // kludgy -- this wouldn't be necessary if the typechecker\n+    // special-cased constructors, then we could just look up\n+    // the ctor's return type.\n+    let rslt_ty =  ty::mk_class(ccx.tcx, parent_id,\n+                                dummy_substs(psubsts.tys));\n+\n+    // Make the fn context\n+    let fcx = new_fn_ctxt_w_id(ccx, path, llctor_decl, ctor_id,\n+                               Some(psubsts), Some(sp));\n+    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, decl.inputs);\n+    let mut bcx_top = top_scope_block(fcx, body.info());\n+    let lltop = bcx_top.llbb;\n+    let arg_tys = ty::ty_fn_args(node_id_type(bcx_top, ctor_id));\n+    bcx_top = copy_args_to_allocas(fcx, bcx_top, decl.inputs,\n+                                   raw_llargs, arg_tys);\n+\n+    // Create a temporary for `self` that we will return at the end\n+    let selfdatum = datum::scratch_datum(bcx_top, rslt_ty, true);\n+\n+    // Initialize dtor flag (if any) to 1\n+    if ty::ty_dtor(bcx_top.tcx(), parent_id).is_some() {\n+        let flag = GEPi(bcx_top, selfdatum.val, [0, 1]);\n+        Store(bcx_top, C_u8(1), flag);\n+    }\n+\n+    // initialize fields to zero\n+    let mut bcx = bcx_top;\n+\n+    // note we don't want to take *or* drop self.\n+    fcx.llself = Some(ValSelfData {v: selfdatum.val,\n+                                   t: rslt_ty,\n+                                   is_owned: false});\n+\n+    // Translate the body of the ctor\n+    bcx = controlflow::trans_block(bcx, body, expr::Ignore);\n+\n+    // Generate the return expression\n+    bcx = selfdatum.move_to(bcx, datum::INIT, fcx.llretptr);\n+\n+    cleanup_and_leave(bcx, None, Some(fcx.llreturn));\n+    Unreachable(bcx);\n+    finish_fn(fcx, lltop);\n+}\n+\n fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n     body: ast::blk, dtor_id: ast::node_id,\n     psubsts: Option<param_substs>,\n@@ -1863,6 +1921,14 @@ fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n                     tps: ~[ast::ty_param], path: @ast_map::path,\n                     ident: ast::ident, id: ast::node_id) {\n     if tps.len() == 0u {\n+      let psubsts = {tys: ty::ty_params_to_tys(ccx.tcx, tps),\n+                     vtables: None,\n+                     bounds: @~[]};\n+      do option::iter(&struct_def.ctor) |ctor| {\n+        trans_class_ctor(ccx, *path, ctor.node.dec, ctor.node.body,\n+                         get_item_val(ccx, ctor.node.id), psubsts,\n+                         ctor.node.id, local_def(id), ctor.span);\n+      }\n       do option::iter(&struct_def.dtor) |dtor| {\n          trans_class_dtor(ccx, *path, dtor.node.body,\n            dtor.node.id, None, None, local_def(id));\n@@ -2118,6 +2184,10 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                 }\n             }\n           }\n+          ast_map::node_ctor(nm, _, ctor, _, pt) => {\n+            let my_path = vec::append(*pt, ~[path_name(nm)]);\n+            register_fn(ccx, ctor.span, my_path, ctor.node.id)\n+          }\n           ast_map::node_dtor(_, dt, parent_id, pt) => {\n             /*\n                 Don't just call register_fn, since we don't want to add\n@@ -2642,6 +2712,7 @@ fn trans_crate(sess: session::session,\n           crate_map: crate_map,\n           mut uses_gc: false,\n           dbg_cx: dbg_cx,\n+          class_ctors: HashMap(),\n           mut do_not_commit_warning_issued: false};\n \n "}, {"sha": "68e957bfe709974e05faf000a46e6ff29d18fd92", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -170,6 +170,11 @@ type crate_ctxt = {\n      // is not emitted by LLVM's GC pass when no functions use GC.\n      mut uses_gc: bool,\n      dbg_cx: Option<debuginfo::debug_ctxt>,\n+     // Mapping from class constructors to parent class --\n+     // used in base::trans_closure\n+     // parent_class must be a def_id because ctors can be\n+     // inlined, so the parent may be in a different crate\n+     class_ctors: HashMap<ast::node_id, ast::def_id>,\n      mut do_not_commit_warning_issued: bool};\n \n // Types used for llself."}, {"sha": "6cd4b49fa3b36fa006b148e4a7686ec1c37eed7c", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -732,6 +732,10 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n       ast_map::node_method(method, _, _) => {\n           (method.ident, method.decl.output, method.id)\n       }\n+      ast_map::node_ctor(nm, _, ctor, _, _) => {\n+        // FIXME: output type may be wrong (#2194)\n+        (nm, ctor.node.dec.output, ctor.node.id)\n+      }\n       ast_map::node_expr(expr) => {\n         match expr.node {\n           ast::expr_fn(_, decl, _, _) => {"}, {"sha": "76888471bf978c6cd03e67004082b0412c2dc96f", "filename": "src/rustc/middle/trans/inline.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -34,6 +34,10 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n             trans_item(ccx, *item);\n             local_def(item.id)\n           }\n+          csearch::found(ast::ii_ctor(ctor, _, _, _)) => {\n+            ccx.external.insert(fn_id, Some(ctor.node.id));\n+            local_def(ctor.node.id)\n+          }\n           csearch::found(ast::ii_foreign(item)) => {\n             ccx.external.insert(fn_id, Some(item.id));\n             local_def(item.id)"}, {"sha": "17eaf591c9f3469aca2c614e27260b07b50e784d", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -5,7 +5,7 @@ use syntax::ast_map::{path, path_mod, path_name};\n use base::{trans_item, get_item_val, no_self, self_arg, trans_fn,\n               impl_self, decl_internal_cdecl_fn,\n               set_inline_hint_if_appr, set_inline_hint,\n-              trans_enum_variant, trans_class_dtor,\n+              trans_enum_variant, trans_class_ctor, trans_class_dtor,\n               get_insn_ctxt};\n use syntax::parse::token::special_idents;\n use type_of::type_of_fn_from_ty;\n@@ -71,6 +71,7 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n         return {val: get_item_val(ccx, fn_id.node),\n                 must_cast: true};\n       }\n+      ast_map::node_ctor(nm, _, ct, _, pt) => (pt, nm, ct.span),\n       ast_map::node_dtor(_, dtor, _, pt) =>\n           (pt, special_idents::dtor, dtor.span),\n       ast_map::node_trait_method(*) => {\n@@ -161,6 +162,16 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n         meth::trans_method(ccx, pt, mth, psubsts, None, d);\n         d\n       }\n+      ast_map::node_ctor(_, tps, ctor, parent_id, _) => {\n+        // ctors don't have attrs, at least not right now\n+        let d = mk_lldecl();\n+        let tp_tys = ty::ty_params_to_tys(ccx.tcx, tps);\n+        trans_class_ctor(ccx, pt, ctor.node.dec, ctor.node.body, d,\n+               option::get_default(&psubsts,\n+                        {tys:tp_tys, vtables: None, bounds: @~[]}),\n+                         fn_id.node, parent_id, ctor.span);\n+        d\n+      }\n       ast_map::node_dtor(_, dtor, _, pt) => {\n         let parent_id = match ty::ty_to_def_id(ty::node_id_to_type(ccx.tcx,\n                                               dtor.node.self_id)) {"}, {"sha": "3c4439c918fbda9b0217074b72b805dff69112a0", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -59,6 +59,10 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n         cx.rmap.insert(item.id, ());\n       }\n       ast_map::node_variant(v, _, _) => { cx.rmap.insert(v.node.id, ()); }\n+      // If it's a ctor, consider the parent reachable\n+      ast_map::node_ctor(_, _, _, parent_id, _) => {\n+        traverse_def_id(cx, parent_id);\n+      }\n       _ => ()\n     }\n }\n@@ -100,6 +104,13 @@ fn traverse_public_item(cx: ctx, item: @item) {\n         }\n       }\n       item_class(struct_def, tps) => {\n+        do option::iter(&struct_def.ctor) |ctor| {\n+            cx.rmap.insert(ctor.node.id, ());\n+            if tps.len() > 0u || attr::find_inline_attr(ctor.node.attrs)\n+                     != attr::ia_none {\n+                traverse_inline_body(cx, ctor.node.body);\n+            }\n+        }\n         do option::iter(&struct_def.dtor) |dtor| {\n             cx.rmap.insert(dtor.node.id, ());\n             if tps.len() > 0u || attr::find_inline_attr(dtor.node.attrs)"}, {"sha": "ee247eb5db79f8c4a7f5338780633eac7f769a37", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -109,6 +109,9 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n             for uint::range(0u, n_tps) |n| { cx.uses[n] |= flags;}\n         }\n       }\n+      ast_map::node_ctor(_, _, ctor, _, _) => {\n+        handle_body(cx, ctor.node.body);\n+      }\n       ast_map::node_dtor(_, dtor, _, _) => {\n         handle_body(cx, dtor.node.body);\n       }"}, {"sha": "bbc3a06fb67523006e248ae7c296b66446bc7df4", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -3318,7 +3318,7 @@ fn note_and_explain_type_err(cx: ctxt, err: &type_err) {\n \n fn def_has_ty_params(def: ast::def) -> bool {\n     match def {\n-      ast::def_fn(_, _) | ast::def_variant(_, _) | ast::def_class(_)\n+      ast::def_fn(_, _) | ast::def_variant(_, _) | ast::def_class(_, _)\n         => true,\n       _ => false\n     }\n@@ -3492,6 +3492,9 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n                             ast_map::path_name(variant.node.name))\n           }\n \n+          ast_map::node_ctor(nm, _, _, _, path) => {\n+            vec::append_one(*path, ast_map::path_name(nm))\n+          }\n           ast_map::node_dtor(_, _, _, path) => {\n             vec::append_one(*path, ast_map::path_name(\n                 syntax::parse::token::special_idents::literally_dtor))"}, {"sha": "14797fcdd6bb1c38e8675f3cc09c82a3d0492959", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -323,7 +323,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n           Some(d) => d\n         };\n         match a_def {\n-          ast::def_ty(did) | ast::def_class(did) => {\n+          ast::def_ty(did) | ast::def_class(did, _) => {\n             ast_path_to_ty(self, rscope, did, path, id).ty\n           }\n           ast::def_prim_ty(nty) => {"}, {"sha": "7cc2c8b0ad767a9d898942cbe561b6e0cccea2df", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -451,6 +451,18 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n     let tcx = ccx.tcx;\n     let self_ty = ty::node_id_to_type(tcx, id);\n \n+    do option::iter(&struct_def.ctor) |ctor| {\n+        let class_t = {self_ty: self_ty,\n+                       self_id: ctor.node.self_id,\n+                       def_id: local_def(id),\n+                       explicit_self: {node: ast::sty_by_ref,\n+                                       span: ast_util::dummy_sp()}};\n+        // typecheck the ctor\n+        check_bare_fn(ccx, ctor.node.dec,\n+                      ctor.node.body, ctor.node.id,\n+                      Some(class_t));\n+    }\n+\n     do option::iter(&struct_def.dtor) |dtor| {\n         let class_t = {self_ty: self_ty,\n                        self_id: dtor.node.self_id,\n@@ -1913,7 +1925,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // Resolve the path.\n         let class_id;\n         match tcx.def_map.find(id) {\n-            Some(ast::def_class(type_def_id)) => {\n+            Some(ast::def_class(type_def_id, _)) => {\n                 class_id = type_def_id;\n             }\n             _ => {\n@@ -2400,7 +2412,7 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n \n       ast::def_fn(id, _) | ast::def_static_method(id, _) |\n       ast::def_const(id) | ast::def_variant(_, id) |\n-      ast::def_class(id) => {\n+      ast::def_class(id, _) => {\n         return ty::lookup_item_type(fcx.ccx.tcx, id);\n       }\n       ast::def_upvar(_, inner, _, _) => {"}, {"sha": "0b2e9c8ab3dda0287d15693f3209ed9c64d23b93", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -325,7 +325,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n \n         // Check to ensure that the struct is the one specified.\n         match tcx.def_map.get(pat.id) {\n-            ast::def_class(supplied_def_id)\n+            ast::def_class(supplied_def_id, _)\n                     if supplied_def_id == class_id => {\n                 // OK.\n             }"}, {"sha": "18e29981af30d054cec4afd9da6b32a5b65ea88c", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -497,6 +497,30 @@ fn convert_struct(ccx: @crate_ctxt,\n                   tpt: ty::ty_param_bounds_and_ty,\n                   id: ast::node_id) {\n     let tcx = ccx.tcx;\n+    do option::iter(&struct_def.ctor) |ctor| {\n+        // Write the ctor type\n+        let t_args = ctor.node.dec.inputs.map(\n+            |a| ty_of_arg(ccx, type_rscope(rp), *a, None) );\n+        let t_res = ty::mk_class(\n+            tcx, local_def(id),\n+            {self_r: rscope::bound_self_region(rp),\n+             self_ty: None,\n+             tps: ty::ty_params_to_tys(tcx, tps)});\n+        let proto = ty::proto_vstore(ty::vstore_slice(ty::re_static));\n+        let t_ctor = ty::mk_fn(tcx, FnTyBase {\n+            meta: FnMeta {purity: ast::impure_fn,\n+                          proto: proto,\n+                          bounds: @~[],\n+                          ret_style: ast::return_val},\n+            sig: FnSig {inputs: t_args,\n+                        output: t_res}\n+        });\n+        write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n+        tcx.tcache.insert(local_def(ctor.node.id),\n+                          {bounds: tpt.bounds,\n+                           region_param: rp,\n+                           ty: t_ctor});\n+    }\n \n     do option::iter(&struct_def.dtor) |dtor| {\n         // Write the dtor type"}, {"sha": "f4ccd901fb3aacf902e882eda82d4548eea3db44", "filename": "src/test/compile-fail/issue-2590.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -10,7 +10,7 @@ trait parse {\n \n impl parser: parse {\n     fn parse() -> ~[int] {\n-        dvec::unwrap(move self.tokens) //~ ERROR moving out of immutable field\n+        dvec::unwrap(move self.tokens) //~ ERROR illegal move from self\n     }\n }\n "}, {"sha": "223665381da1e3eb87d88cb936167dfd82a72acb", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=7bdab1e4a45bf734e4b25a2d58f4ee21ee5c9fdc", "patch": "@@ -19,7 +19,7 @@ mod argparse {\n         fn set_desc(self, s: &str) -> Flag {\n             Flag { //~ ERROR cannot infer an appropriate lifetime\n                 name: self.name,\n-                desc: s, //~ ERROR cannot infer an appropriate lifetime\n+                desc: s,\n                 max_count: self.max_count,\n                 value: self.value\n             }"}]}