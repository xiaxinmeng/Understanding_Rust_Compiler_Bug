{"sha": "9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhYTZjYzAyNWQzZWM2OGFhMzQ4OWQwYzRmOTI0MjFlMDJjZGJhY2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-13T02:26:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-13T02:26:20Z"}, "message": "Auto merge of #75476 - JohnTitor:rollup-ap1rqf1, r=JohnTitor\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #75189 (Fix wasi::fs::OpenOptions to imply write when append is on)\n - #75201 (Fix some Clippy warnings in librustc_serialize)\n - #75372 (Fix suggestion to use lifetime in type and in assoc const)\n - #75400 (Fix minor things in the `f32` primitive docs)\n - #75449 (add regression test for #74739 (mir const-prop bug))\n - #75451 (Clean up E0751 explanation)\n - #75455 (Use explicit path link in place for doc in time)\n - #75457 (Remove some dead variants in LLVM FFI)\n - #75466 (Move to intra doc links whenever possible within std/src/lib.rs)\n - #75469 (Switch to intra-doc links in `std/io/mod.rs`)\n - #75473 (Flip order of const & type)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "313884e17a60fd701e6fc9e585b3ce53302b998f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/313884e17a60fd701e6fc9e585b3ce53302b998f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "html_url": "https://github.com/rust-lang/rust/commit/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "847ba835ce411d47364a93ddf0b4a5c0f27928a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/847ba835ce411d47364a93ddf0b4a5c0f27928a9", "html_url": "https://github.com/rust-lang/rust/commit/847ba835ce411d47364a93ddf0b4a5c0f27928a9"}, {"sha": "76ac5d61e431c2ed347e4b9627e50cc7df9bc6e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/76ac5d61e431c2ed347e4b9627e50cc7df9bc6e3", "html_url": "https://github.com/rust-lang/rust/commit/76ac5d61e431c2ed347e4b9627e50cc7df9bc6e3"}], "stats": {"total": 681, "additions": 464, "deletions": 217}, "files": [{"sha": "e90ee5c285f2f5ca8d5af091914c8bcb1b3792fe", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -1212,7 +1212,7 @@ impl Initializer {\n ///\n /// [`write`]: Self::write\n /// [`flush`]: Self::flush\n-/// [`std::io`]: index.html\n+/// [`std::io`]: self\n ///\n /// # Examples\n ///\n@@ -1590,8 +1590,6 @@ pub trait Seek {\n     /// # Errors\n     ///\n     /// Seeking to a negative offset is considered an error.\n-    ///\n-    /// [`SeekFrom::Start`]: enum.SeekFrom.html#variant.Start\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn seek(&mut self, pos: SeekFrom) -> Result<u64>;\n \n@@ -1678,8 +1676,6 @@ pub trait Seek {\n /// Enumeration of possible methods to seek within an I/O object.\n ///\n /// It is used by the [`Seek`] trait.\n-///\n-/// [`Seek`]: trait.Seek.html\n #[derive(Copy, PartialEq, Eq, Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum SeekFrom {\n@@ -1759,11 +1755,9 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>) -> R\n /// For example, [`File`] implements [`Read`], but not `BufRead`.\n /// [`BufReader`] to the rescue!\n ///\n-/// [`BufReader`]: struct.BufReader.html\n /// [`File`]: crate::fs::File\n /// [`read_line`]: Self::read_line\n /// [`lines`]: Self::lines\n-/// [`Read`]: trait.Read.html\n ///\n /// ```no_run\n /// use std::io::{self, BufReader};\n@@ -1869,16 +1863,13 @@ pub trait BufRead: Read {\n     /// present in `buf` and its length will have been adjusted appropriately.\n     ///\n     /// [`fill_buf`]: Self::fill_buf\n-    /// [`ErrorKind::Interrupted`]: enum.ErrorKind.html#variant.Interrupted\n     ///\n     /// # Examples\n     ///\n     /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n     /// this example, we use [`Cursor`] to read all the bytes in a byte slice\n     /// in hyphen delimited segments:\n     ///\n-    /// [`Cursor`]: struct.Cursor.html\n-    ///\n     /// ```\n     /// use std::io::{self, BufRead};\n     ///\n@@ -1940,8 +1931,6 @@ pub trait BufRead: Read {\n     /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n     /// this example, we use [`Cursor`] to read all the lines in a byte slice:\n     ///\n-    /// [`Cursor`]: struct.Cursor.html\n-    ///\n     /// ```\n     /// use std::io::{self, BufRead};\n     ///\n@@ -1996,8 +1985,6 @@ pub trait BufRead: Read {\n     /// this example, we use [`Cursor`] to iterate over all hyphen delimited\n     /// segments in a byte slice\n     ///\n-    /// [`Cursor`]: struct.Cursor.html\n-    ///\n     /// ```\n     /// use std::io::{self, BufRead};\n     ///\n@@ -2046,8 +2033,6 @@ pub trait BufRead: Read {\n     /// # Errors\n     ///\n     /// Each line of the iterator has the same error semantics as [`BufRead::read_line`].\n-    ///\n-    /// [`BufRead::read_line`]: trait.BufRead.html#method.read_line\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines(self) -> Lines<Self>\n     where\n@@ -2062,7 +2047,7 @@ pub trait BufRead: Read {\n /// This struct is generally created by calling [`chain`] on a reader.\n /// Please see the documentation of [`chain`] for more details.\n ///\n-/// [`chain`]: trait.Read.html#method.chain\n+/// [`chain`]: Read::chain\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chain<T, U> {\n     first: T,\n@@ -2204,7 +2189,7 @@ impl<T: BufRead, U: BufRead> BufRead for Chain<T, U> {\n /// This struct is generally created by calling [`take`] on a reader.\n /// Please see the documentation of [`take`] for more details.\n ///\n-/// [`take`]: trait.Read.html#method.take\n+/// [`take`]: Read::take\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Take<T> {\n@@ -2403,7 +2388,7 @@ impl<T: BufRead> BufRead for Take<T> {\n /// This struct is generally created by calling [`bytes`] on a reader.\n /// Please see the documentation of [`bytes`] for more details.\n ///\n-/// [`bytes`]: trait.Read.html#method.bytes\n+/// [`bytes`]: Read::bytes\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Bytes<R> {\n@@ -2433,7 +2418,7 @@ impl<R: Read> Iterator for Bytes<R> {\n /// This struct is generally created by calling [`split`] on a `BufRead`.\n /// Please see the documentation of [`split`] for more details.\n ///\n-/// [`split`]: trait.BufRead.html#method.split\n+/// [`split`]: BufRead::split\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Split<B> {\n@@ -2465,7 +2450,7 @@ impl<B: BufRead> Iterator for Split<B> {\n /// This struct is generally created by calling [`lines`] on a `BufRead`.\n /// Please see the documentation of [`lines`] for more details.\n ///\n-/// [`lines`]: trait.BufRead.html#method.lines\n+/// [`lines`]: BufRead::lines\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Lines<B> {"}, {"sha": "1144a13b52c30b377a806a4e075891bd82711355", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 27, "deletions": 40, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -22,7 +22,7 @@\n //! * [`std::*` modules](#modules)\n //! * [Primitive types](#primitives)\n //! * [Standard macros](#macros)\n-//! * [The Rust Prelude](prelude/index.html)\n+//! * [The Rust Prelude]\n //!\n //! If this is your first time, the documentation for the standard library is\n //! written to be casually perused. Clicking on interesting things should\n@@ -63,8 +63,8 @@\n //! So for example there is a [page for the primitive type\n //! `i32`](primitive.i32.html) that lists all the methods that can be called on\n //! 32-bit integers (very useful), and there is a [page for the module\n-//! `std::i32`](i32/index.html) that documents the constant values [`MIN`] and\n-//! [`MAX`](i32/constant.MAX.html) (rarely useful).\n+//! `std::i32`] that documents the constant values [`MIN`] and [`MAX`] (rarely\n+//! useful).\n //!\n //! Note the documentation for the primitives [`str`] and [`[T]`][slice] (also\n //! called 'slice'). Many method calls on [`String`] and [`Vec<T>`] are actually\n@@ -152,48 +152,35 @@\n //! contains further primitive shared memory types, including [`atomic`] and\n //! [`mpsc`], which contains the channel types for message passing.\n //!\n-//! [I/O]: io/index.html\n-//! [`MIN`]: i32/constant.MIN.html\n-//! [TCP]: net/struct.TcpStream.html\n-//! [The Rust Prelude]: prelude/index.html\n-//! [UDP]: net/struct.UdpSocket.html\n-//! [`Arc`]: sync/struct.Arc.html\n-//! [owned slice]: boxed/index.html\n-//! [`Cell`]: cell/struct.Cell.html\n-//! [`FromStr`]: str/trait.FromStr.html\n-//! [`HashMap<K, V>`]: collections/struct.HashMap.html\n-//! [`Iterator`]: iter/trait.Iterator.html\n-//! [`Mutex`]: sync/struct.Mutex.html\n-//! [`Option<T>`]: option/enum.Option.html\n-//! [`Rc`]: rc/struct.Rc.html\n-//! [`RefCell`]: cell/struct.RefCell.html\n-//! [`Result<T, E>`]: result/enum.Result.html\n-//! [`String`]: string/struct.String.html\n-//! [`Vec<T>`]: vec/struct.Vec.html\n-//! [array]: primitive.array.html\n-//! [slice]: primitive.slice.html\n-//! [`atomic`]: sync/atomic/index.html\n-//! [`collections`]: collections/index.html\n+//! [I/O]: io\n+//! [`MIN`]: i32::MIN\n+//! [`MAX`]: i32::MAX\n+//! [page for the module `std::i32`]: crate::i32\n+//! [TCP]: net::TcpStream\n+//! [The Rust Prelude]: prelude\n+//! [UDP]: net::UdpSocket\n+//! [`Arc`]: sync::Arc\n+//! [owned slice]: boxed\n+//! [`Cell`]: cell::Cell\n+//! [`FromStr`]: str::FromStr\n+//! [`HashMap<K, V>`]: collections::HashMap\n+//! [`Mutex`]: sync::Mutex\n+//! [`Option<T>`]: option::Option\n+//! [`Rc`]: rc::Rc\n+//! [`RefCell`]: cell::RefCell\n+//! [`Result<T, E>`]: result::Result\n+//! [`Vec<T>`]: vec::Vec\n+//! [`atomic`]: sync::atomic\n //! [`for`]: ../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n-//! [`format!`]: macro.format.html\n-//! [`fs`]: fs/index.html\n-//! [`io`]: io/index.html\n-//! [`iter`]: iter/index.html\n-//! [`mpsc`]: sync/mpsc/index.html\n-//! [`net`]: net/index.html\n-//! [`option`]: option/index.html\n-//! [`result`]: result/index.html\n-//! [`std::cmp`]: cmp/index.html\n-//! [`std::slice`]: slice/index.html\n-//! [`str`]: primitive.str.html\n-//! [`sync`]: sync/index.html\n-//! [`thread`]: thread/index.html\n+//! [`mpsc`]: sync::mpsc\n+//! [`std::cmp`]: cmp\n+//! [`std::slice`]: slice\n //! [`use std::env`]: env/index.html\n //! [`use`]: ../book/ch07-02-defining-modules-to-control-scope-and-privacy.html\n //! [crates.io]: https://crates.io\n //! [deref-coercions]: ../book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods\n-//! [files]: fs/struct.File.html\n-//! [multithreading]: thread/index.html\n+//! [files]: fs::File\n+//! [multithreading]: thread\n //! [other]: #what-is-in-the-standard-library-documentation\n //! [primitive types]: ../book/ch03-02-data-types.html\n //! [rust-discord]: https://discord.gg/rust-lang"}, {"sha": "0d2aca6bbc3eb78505d8fe6ecb17568566a1c8b8", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -768,7 +768,8 @@ mod prim_tuple {}\n ///\n /// This type can represent a wide range of decimal numbers, like `3.5`, `27`,\n /// `-113.75`, `0.0078125`, `34359738368`, `0`, `-1`. So unlike integer types\n-/// (like `i32`), floating point types can represent non-integer numbers, too.\n+/// (such as `i32`), floating point types can represent non-integer numbers,\n+/// too.\n ///\n /// However, being able to represent this wide range of numbers comes at the\n /// cost of precision: floats can only represent some of the real numbers and\n@@ -779,15 +780,12 @@ mod prim_tuple {}\n /// often discard insignificant digits: `println!(\"{}\", 1.0f32 / 5.0f32)` will\n /// print `0.2`.\n ///\n-/// The precision is better for numbers near 0 and worse for large numbers. For\n-/// example, above 2<sup>24</sup>, not even all integers are representable.\n-///\n /// Additionally, `f32` can represent a couple of special values:\n ///\n /// - `-0`: this is just due to how floats are encoded. It is semantically\n ///   equivalent to `0` and `-0.0 == 0.0` results in `true`.\n /// - [\u221e](#associatedconstant.INFINITY) and\n-///   [-\u221e](#associatedconstant.NEG_INFINITY): these result from calculations\n+///   [\u2212\u221e](#associatedconstant.NEG_INFINITY): these result from calculations\n ///   like `1.0 / 0.0`.\n /// - [NaN (not a number)](#associatedconstant.NAN): this value results from\n ///   calculations like `(-1.0).sqrt()`. NaN has some potentially unexpected"}, {"sha": "8408756f1b3be1cca5bff0c8e8dc031d7163895e", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -46,6 +46,7 @@ pub struct DirEntry {\n pub struct OpenOptions {\n     read: bool,\n     write: bool,\n+    append: bool,\n     dirflags: wasi::Lookupflags,\n     fdflags: wasi::Fdflags,\n     oflags: wasi::Oflags,\n@@ -270,8 +271,9 @@ impl OpenOptions {\n         }\n     }\n \n-    pub fn append(&mut self, set: bool) {\n-        self.fdflag(wasi::FDFLAGS_APPEND, set);\n+    pub fn append(&mut self, append: bool) {\n+        self.append = append;\n+        self.fdflag(wasi::FDFLAGS_APPEND, append);\n     }\n \n     pub fn dsync(&mut self, set: bool) {\n@@ -321,7 +323,7 @@ impl OpenOptions {\n             base |= wasi::RIGHTS_FD_READ;\n             base |= wasi::RIGHTS_FD_READDIR;\n         }\n-        if self.write {\n+        if self.write || self.append {\n             base |= wasi::RIGHTS_FD_WRITE;\n             base |= wasi::RIGHTS_FD_DATASYNC;\n             base |= wasi::RIGHTS_FD_ALLOCATE;"}, {"sha": "02161ecb4c8d21adeb0ea2cb68c763fc21506fcc", "filename": "library/std/src/time.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/library%2Fstd%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/library%2Fstd%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -359,9 +359,7 @@ impl Add<Duration> for Instant {\n     /// # Panics\n     ///\n     /// This function may panic if the resulting point in time cannot be represented by the\n-    /// underlying data structure. See [`checked_add`] for a version without panic.\n-    ///\n-    /// [`checked_add`]: Instant::checked_add\n+    /// underlying data structure. See [`Instant::checked_add`] for a version without panic.\n     fn add(self, other: Duration) -> Instant {\n         self.checked_add(other).expect(\"overflow when adding duration to instant\")\n     }\n@@ -525,9 +523,7 @@ impl Add<Duration> for SystemTime {\n     /// # Panics\n     ///\n     /// This function may panic if the resulting point in time cannot be represented by the\n-    /// underlying data structure. See [`checked_add`] for a version without panic.\n-    ///\n-    /// [`checked_add`]: SystemTime::checked_add\n+    /// underlying data structure. See [`SystemTime::checked_add`] for a version without panic.\n     fn add(self, dur: Duration) -> SystemTime {\n         self.checked_add(dur).expect(\"overflow when adding duration to instant\")\n     }"}, {"sha": "3c2a063cf24814f6e66ec28976c01adcc86331f2", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -777,7 +777,7 @@ fn validate_generic_param_order<'a>(\n                 if sess.features_untracked().const_generics {\n                     \", then consts and types\"\n                 } else if sess.features_untracked().min_const_generics {\n-                    \", then consts, then types\"\n+                    \", then types, then consts\"\n                 } else {\n                     \", then types\"\n                 },"}, {"sha": "1a5794d1133660a574c083af83c211ea1ab46b14", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -975,7 +975,6 @@ pub unsafe fn with_llvm_pmb(\n         (llvm::CodeGenOptLevel::Default, ..) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 225);\n         }\n-        (llvm::CodeGenOptLevel::Other, ..) => bug!(\"CodeGenOptLevel::Other selected\"),\n     }\n \n     f(builder);"}, {"sha": "f094ad868947fa32242c0a699ca98d73f31b7231", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -337,17 +337,13 @@ impl AtomicOrdering {\n #[derive(Copy, Clone)]\n #[repr(C)]\n pub enum SynchronizationScope {\n-    // FIXME: figure out if this variant is needed at all.\n-    #[allow(dead_code)]\n-    Other,\n     SingleThread,\n     CrossThread,\n }\n \n impl SynchronizationScope {\n     pub fn from_generic(sc: rustc_codegen_ssa::common::SynchronizationScope) -> Self {\n         match sc {\n-            rustc_codegen_ssa::common::SynchronizationScope::Other => SynchronizationScope::Other,\n             rustc_codegen_ssa::common::SynchronizationScope::SingleThread => {\n                 SynchronizationScope::SingleThread\n             }\n@@ -362,9 +358,6 @@ impl SynchronizationScope {\n #[derive(Copy, Clone)]\n #[repr(C)]\n pub enum FileType {\n-    // FIXME: figure out if this variant is needed at all.\n-    #[allow(dead_code)]\n-    Other,\n     AssemblyFile,\n     ObjectFile,\n }\n@@ -391,9 +384,6 @@ pub enum MetadataType {\n #[derive(Copy, Clone)]\n #[repr(C)]\n pub enum AsmDialect {\n-    // FIXME: figure out if this variant is needed at all.\n-    #[allow(dead_code)]\n-    Other,\n     Att,\n     Intel,\n }\n@@ -411,9 +401,6 @@ impl AsmDialect {\n #[derive(Copy, Clone, PartialEq)]\n #[repr(C)]\n pub enum CodeGenOptLevel {\n-    // FIXME: figure out if this variant is needed at all.\n-    #[allow(dead_code)]\n-    Other,\n     None,\n     Less,\n     Default,\n@@ -513,9 +500,6 @@ pub enum DiagnosticLevel {\n #[derive(Copy, Clone)]\n #[repr(C)]\n pub enum ArchiveKind {\n-    // FIXME: figure out if this variant is needed at all.\n-    #[allow(dead_code)]\n-    Other,\n     K_GNU,\n     K_BSD,\n     K_DARWIN,"}, {"sha": "e04ed531bbff282912f14f7ad59116103d77be4c", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -72,9 +72,6 @@ pub enum AtomicOrdering {\n }\n \n pub enum SynchronizationScope {\n-    // FIXME: figure out if this variant is needed at all.\n-    #[allow(dead_code)]\n-    Other,\n     SingleThread,\n     CrossThread,\n }"}, {"sha": "8794f7868f30296ab022c341db3ed635dcd22e29", "filename": "src/librustc_error_codes/error_codes/E0751.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_error_codes%2Ferror_codes%2FE0751.md", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_error_codes%2Ferror_codes%2FE0751.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0751.md?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -5,8 +5,8 @@ Erroneous code example:\n ```compile_fail,E0751\n trait MyTrait {}\n impl MyTrait for i32 { }\n-impl !MyTrait for i32 { }\n+impl !MyTrait for i32 { } // error!\n ```\n \n-Negative implementations are a promise that the trait will never be\n-implemented for the given types.\n+Negative implementations are a promise that the trait will never be implemented\n+for the given types. Therefore, both cannot exists at the same time."}, {"sha": "a7d3697405751782b82f579613424af3a6ae6351", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 137, "deletions": 24, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -16,8 +16,8 @@ use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_session::config::nightly_options;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::{BytePos, Span, DUMMY_SP};\n \n use log::debug;\n \n@@ -33,6 +33,7 @@ enum AssocSuggestion {\n crate enum MissingLifetimeSpot<'tcx> {\n     Generics(&'tcx hir::Generics<'tcx>),\n     HigherRanked { span: Span, span_type: ForLifetimeSpanType },\n+    Static,\n }\n \n crate enum ForLifetimeSpanType {\n@@ -1195,6 +1196,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                             https://doc.rust-lang.org/nomicon/hrtb.html\",\n                     );\n                 }\n+                _ => {}\n             }\n         }\n         if nightly_options::is_nightly_build()\n@@ -1253,7 +1255,8 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         count: usize,\n-        lifetime_names: &FxHashSet<Ident>,\n+        lifetime_names: &FxHashSet<Symbol>,\n+        lifetime_spans: Vec<Span>,\n         params: &[ElisionFailureInfo],\n     ) {\n         let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok();\n@@ -1267,11 +1270,60 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n             ),\n         );\n \n-        let suggest_existing = |err: &mut DiagnosticBuilder<'_>, sugg| {\n+        let suggest_existing = |err: &mut DiagnosticBuilder<'_>,\n+                                name: &str,\n+                                formatter: &dyn Fn(&str) -> String| {\n+            if let Some(MissingLifetimeSpot::HigherRanked { span: for_span, span_type }) =\n+                self.missing_named_lifetime_spots.iter().rev().next()\n+            {\n+                // When we have `struct S<'a>(&'a dyn Fn(&X) -> &X);` we want to not only suggest\n+                // using `'a`, but also introduce the concept of HRLTs by suggesting\n+                // `struct S<'a>(&'a dyn for<'b> Fn(&X) -> &'b X);`. (#72404)\n+                let mut introduce_suggestion = vec![];\n+\n+                let a_to_z_repeat_n = |n| {\n+                    (b'a'..=b'z').map(move |c| {\n+                        let mut s = '\\''.to_string();\n+                        s.extend(std::iter::repeat(char::from(c)).take(n));\n+                        s\n+                    })\n+                };\n+\n+                // If all single char lifetime names are present, we wrap around and double the chars.\n+                let lt_name = (1..)\n+                    .flat_map(a_to_z_repeat_n)\n+                    .find(|lt| !lifetime_names.contains(&Symbol::intern(&lt)))\n+                    .unwrap();\n+                let msg = format!(\n+                    \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n+                    span_type.descr(),\n+                    lt_name,\n+                );\n+                err.note(\n+                    \"for more information on higher-ranked polymorphism, visit \\\n+                    https://doc.rust-lang.org/nomicon/hrtb.html\",\n+                );\n+                let for_sugg = span_type.suggestion(&lt_name);\n+                for param in params {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span) {\n+                        if snippet.starts_with('&') && !snippet.starts_with(\"&'\") {\n+                            introduce_suggestion\n+                                .push((param.span, format!(\"&{} {}\", lt_name, &snippet[1..])));\n+                        } else if snippet.starts_with(\"&'_ \") {\n+                            introduce_suggestion\n+                                .push((param.span, format!(\"&{} {}\", lt_name, &snippet[4..])));\n+                        }\n+                    }\n+                }\n+                introduce_suggestion.push((*for_span, for_sugg.to_string()));\n+                introduce_suggestion.push((span, formatter(&lt_name)));\n+                err.multipart_suggestion(&msg, introduce_suggestion, Applicability::MaybeIncorrect);\n+            }\n+\n             err.span_suggestion_verbose(\n                 span,\n                 &format!(\"consider using the `{}` lifetime\", lifetime_names.iter().next().unwrap()),\n-                sugg,\n+                formatter(name),\n                 Applicability::MaybeIncorrect,\n             );\n         };\n@@ -1282,6 +1334,15 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                 let should_break;\n                 introduce_suggestion.push(match missing {\n                     MissingLifetimeSpot::Generics(generics) => {\n+                        if generics.span == DUMMY_SP {\n+                            // Account for malformed generics in the HIR. This shouldn't happen,\n+                            // but if we make a mistake elsewhere, mainly by keeping something in\n+                            // `missing_named_lifetime_spots` that we shouldn't, like associated\n+                            // `const`s or making a mistake in the AST lowering we would provide\n+                            // non-sensical suggestions. Guard against that by skipping these.\n+                            // (#74264)\n+                            continue;\n+                        }\n                         msg = \"consider introducing a named lifetime parameter\".to_string();\n                         should_break = true;\n                         if let Some(param) = generics.params.iter().find(|p| match p.kind {\n@@ -1308,6 +1369,42 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                         );\n                         (*span, span_type.suggestion(\"'a\"))\n                     }\n+                    MissingLifetimeSpot::Static => {\n+                        let (span, sugg) = match snippet.as_deref() {\n+                            Some(\"&\") => (span.shrink_to_hi(), \"'static \".to_owned()),\n+                            Some(\"'_\") => (span, \"'static\".to_owned()),\n+                            Some(snippet) if !snippet.ends_with('>') => {\n+                                if snippet == \"\" {\n+                                    (\n+                                        span,\n+                                        std::iter::repeat(\"'static\")\n+                                            .take(count)\n+                                            .collect::<Vec<_>>()\n+                                            .join(\", \"),\n+                                    )\n+                                } else {\n+                                    (\n+                                        span.shrink_to_hi(),\n+                                        format!(\n+                                            \"<{}>\",\n+                                            std::iter::repeat(\"'static\")\n+                                                .take(count)\n+                                                .collect::<Vec<_>>()\n+                                                .join(\", \")\n+                                        ),\n+                                    )\n+                                }\n+                            }\n+                            _ => continue,\n+                        };\n+                        err.span_suggestion_verbose(\n+                            span,\n+                            \"consider using the `'static` lifetime\",\n+                            sugg.to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        continue;\n+                    }\n                 });\n                 for param in params {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span) {\n@@ -1328,41 +1425,57 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n             }\n         };\n \n-        match (lifetime_names.len(), lifetime_names.iter().next(), snippet.as_deref()) {\n-            (1, Some(name), Some(\"&\")) => {\n-                suggest_existing(err, format!(\"&{} \", name));\n+        let lifetime_names: Vec<_> = lifetime_names.into_iter().collect();\n+        match (&lifetime_names[..], snippet.as_deref()) {\n+            ([name], Some(\"&\")) => {\n+                suggest_existing(err, &name.as_str()[..], &|name| format!(\"&{} \", name));\n             }\n-            (1, Some(name), Some(\"'_\")) => {\n-                suggest_existing(err, name.to_string());\n+            ([name], Some(\"'_\")) => {\n+                suggest_existing(err, &name.as_str()[..], &|n| n.to_string());\n             }\n-            (1, Some(name), Some(\"\")) => {\n-                suggest_existing(err, format!(\"{}, \", name).repeat(count));\n+            ([name], Some(\"\")) => {\n+                suggest_existing(err, &name.as_str()[..], &|n| format!(\"{}, \", n).repeat(count));\n             }\n-            (1, Some(name), Some(snippet)) if !snippet.ends_with('>') => {\n-                suggest_existing(\n-                    err,\n+            ([name], Some(snippet)) if !snippet.ends_with('>') => {\n+                let f = |name: &str| {\n                     format!(\n                         \"{}<{}>\",\n                         snippet,\n                         std::iter::repeat(name.to_string())\n                             .take(count)\n                             .collect::<Vec<_>>()\n                             .join(\", \")\n-                    ),\n-                );\n+                    )\n+                };\n+                suggest_existing(err, &name.as_str()[..], &f);\n             }\n-            (0, _, Some(\"&\")) if count == 1 => {\n+            ([], Some(\"&\")) if count == 1 => {\n                 suggest_new(err, \"&'a \");\n             }\n-            (0, _, Some(\"'_\")) if count == 1 => {\n+            ([], Some(\"'_\")) if count == 1 => {\n                 suggest_new(err, \"'a\");\n             }\n-            (0, _, Some(snippet)) if !snippet.ends_with('>') && count == 1 => {\n-                suggest_new(err, &format!(\"{}<'a>\", snippet));\n+            ([], Some(snippet)) if !snippet.ends_with('>') => {\n+                if snippet == \"\" {\n+                    // This happens when we have `type Bar<'a> = Foo<T>` where we point at the space\n+                    // before `T`. We will suggest `type Bar<'a> = Foo<'a, T>`.\n+                    suggest_new(\n+                        err,\n+                        &std::iter::repeat(\"'a, \").take(count).collect::<Vec<_>>().join(\"\"),\n+                    );\n+                } else {\n+                    suggest_new(\n+                        err,\n+                        &format!(\n+                            \"{}<{}>\",\n+                            snippet,\n+                            std::iter::repeat(\"'a\").take(count).collect::<Vec<_>>().join(\", \")\n+                        ),\n+                    );\n+                }\n             }\n-            (n, ..) if n > 1 => {\n-                let spans: Vec<Span> = lifetime_names.iter().map(|lt| lt.span).collect();\n-                err.span_note(spans, \"these named lifetimes are available to use\");\n+            (lts, ..) if lts.len() > 1 => {\n+                err.span_note(lifetime_spans, \"these named lifetimes are available to use\");\n                 if Some(\"\") == snippet.as_deref() {\n                     // This happens when we have `Foo<T>` where we point at the space before `T`,\n                     // but this can be confusing so we give a suggestion with placeholders."}, {"sha": "2046419d984d0fd0be20c2e0fb0fe87f793cb2a2", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -711,18 +711,20 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         use self::hir::TraitItemKind::*;\n-        self.missing_named_lifetime_spots.push((&trait_item.generics).into());\n         match trait_item.kind {\n             Fn(ref sig, _) => {\n+                self.missing_named_lifetime_spots.push((&trait_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(trait_item.hir_id)),\n                     &sig.decl,\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n                 );\n+                self.missing_named_lifetime_spots.pop();\n             }\n             Type(bounds, ref ty) => {\n+                self.missing_named_lifetime_spots.push((&trait_item.generics).into());\n                 let generics = &trait_item.generics;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n@@ -757,31 +759,35 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         this.visit_ty(ty);\n                     }\n                 });\n+                self.missing_named_lifetime_spots.pop();\n             }\n             Const(_, _) => {\n                 // Only methods and types support generics.\n                 assert!(trait_item.generics.params.is_empty());\n+                self.missing_named_lifetime_spots.push(MissingLifetimeSpot::Static);\n                 intravisit::walk_trait_item(self, trait_item);\n+                self.missing_named_lifetime_spots.pop();\n             }\n         }\n-        self.missing_named_lifetime_spots.pop();\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         use self::hir::ImplItemKind::*;\n-        self.missing_named_lifetime_spots.push((&impl_item.generics).into());\n         match impl_item.kind {\n             Fn(ref sig, _) => {\n+                self.missing_named_lifetime_spots.push((&impl_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(impl_item.hir_id)),\n                     &sig.decl,\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n-                )\n+                );\n+                self.missing_named_lifetime_spots.pop();\n             }\n             TyAlias(ref ty) => {\n                 let generics = &impl_item.generics;\n+                self.missing_named_lifetime_spots.push(generics.into());\n                 let mut index = self.next_early_index();\n                 let mut non_lifetime_count = 0;\n                 debug!(\"visit_ty: index = {}\", index);\n@@ -810,14 +816,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     this.visit_generics(generics);\n                     this.visit_ty(ty);\n                 });\n+                self.missing_named_lifetime_spots.pop();\n             }\n             Const(_, _) => {\n                 // Only methods and types support generics.\n                 assert!(impl_item.generics.params.is_empty());\n+                self.missing_named_lifetime_spots.push(MissingLifetimeSpot::Static);\n                 intravisit::walk_impl_item(self, impl_item);\n+                self.missing_named_lifetime_spots.pop();\n             }\n         }\n-        self.missing_named_lifetime_spots.pop();\n     }\n \n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n@@ -2315,6 +2323,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n         let mut lifetime_names = FxHashSet::default();\n+        let mut lifetime_spans = vec![];\n         let error = loop {\n             match *scope {\n                 // Do not assign any resolution, it will be inferred.\n@@ -2326,7 +2335,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     // collect named lifetimes for suggestions\n                     for name in lifetimes.keys() {\n                         if let hir::ParamName::Plain(name) = name {\n-                            lifetime_names.insert(*name);\n+                            lifetime_names.insert(name.name);\n+                            lifetime_spans.push(name.span);\n                         }\n                     }\n                     late_depth += 1;\n@@ -2344,12 +2354,24 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         }\n                         Elide::Exact(l) => l.shifted(late_depth),\n                         Elide::Error(ref e) => {\n-                            if let Scope::Binder { ref lifetimes, .. } = s {\n-                                // collect named lifetimes for suggestions\n-                                for name in lifetimes.keys() {\n-                                    if let hir::ParamName::Plain(name) = name {\n-                                        lifetime_names.insert(*name);\n+                            let mut scope = s;\n+                            loop {\n+                                match scope {\n+                                    Scope::Binder { ref lifetimes, s, .. } => {\n+                                        // Collect named lifetimes for suggestions.\n+                                        for name in lifetimes.keys() {\n+                                            if let hir::ParamName::Plain(name) = name {\n+                                                lifetime_names.insert(name.name);\n+                                                lifetime_spans.push(name.span);\n+                                            }\n+                                        }\n+                                        scope = s;\n+                                    }\n+                                    Scope::ObjectLifetimeDefault { ref s, .. }\n+                                    | Scope::Elision { ref s, .. } => {\n+                                        scope = s;\n                                     }\n+                                    _ => break,\n                                 }\n                             }\n                             break Some(e);\n@@ -2373,14 +2395,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         if let Some(params) = error {\n             // If there's no lifetime available, suggest `'static`.\n             if self.report_elision_failure(&mut err, params) && lifetime_names.is_empty() {\n-                lifetime_names.insert(Ident::with_dummy_span(kw::StaticLifetime));\n+                lifetime_names.insert(kw::StaticLifetime);\n             }\n         }\n         self.add_missing_lifetime_specifiers_label(\n             &mut err,\n             span,\n             lifetime_refs.len(),\n             &lifetime_names,\n+            lifetime_spans,\n             error.map(|p| &p[..]).unwrap_or(&[]),\n         );\n         err.emit();"}, {"sha": "49b8094abd0eb5d64f7c491d1c292c0498a23cb1", "filename": "src/librustc_serialize/collection_impls.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_serialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_serialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Fcollection_impls.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -86,11 +86,9 @@ where\n {\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         e.emit_map(self.len(), |e| {\n-            let mut i = 0;\n-            for (key, val) in self {\n+            for (i, (key, val)) in self.iter().enumerate() {\n                 e.emit_map_elt_key(i, |e| key.encode(e))?;\n                 e.emit_map_elt_val(i, |e| val.encode(e))?;\n-                i += 1;\n             }\n             Ok(())\n         })\n@@ -121,10 +119,8 @@ where\n {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n-            let mut i = 0;\n-            for e in self {\n+            for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?;\n-                i += 1;\n             }\n             Ok(())\n         })\n@@ -154,11 +150,9 @@ where\n {\n     fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         e.emit_map(self.len(), |e| {\n-            let mut i = 0;\n-            for (key, val) in self {\n+            for (i, (key, val)) in self.iter().enumerate() {\n                 e.emit_map_elt_key(i, |e| key.encode(e))?;\n                 e.emit_map_elt_val(i, |e| val.encode(e))?;\n-                i += 1;\n             }\n             Ok(())\n         })\n@@ -192,10 +186,8 @@ where\n {\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n-            let mut i = 0;\n-            for e in self {\n+            for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?;\n-                i += 1;\n             }\n             Ok(())\n         })\n@@ -227,11 +219,9 @@ where\n {\n     fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         e.emit_map(self.len(), |e| {\n-            let mut i = 0;\n-            for (key, val) in self {\n+            for (i, (key, val)) in self.iter().enumerate() {\n                 e.emit_map_elt_key(i, |e| key.encode(e))?;\n                 e.emit_map_elt_val(i, |e| val.encode(e))?;\n-                i += 1;\n             }\n             Ok(())\n         })\n@@ -265,10 +255,8 @@ where\n {\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n-            let mut i = 0;\n-            for e in self {\n+            for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?;\n-                i += 1;\n             }\n             Ok(())\n         })"}, {"sha": "ab7f6975325bc0ccb403e5fd99483d2829bae210", "filename": "src/librustc_serialize/json.rs", "status": "modified", "additions": 34, "deletions": 54, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_serialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_serialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Fjson.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -78,19 +78,17 @@\n //!     data_vector: Vec<u8>,\n //! }\n //!\n-//! fn main() {\n-//!     let object = TestStruct {\n-//!         data_int: 1,\n-//!         data_str: \"homura\".to_string(),\n-//!         data_vector: vec![2,3,4,5],\n-//!     };\n+//! let object = TestStruct {\n+//!     data_int: 1,\n+//!     data_str: \"homura\".to_string(),\n+//!     data_vector: vec![2,3,4,5],\n+//! };\n //!\n-//!     // Serialize using `json::encode`\n-//!     let encoded = json::encode(&object).unwrap();\n+//! // Serialize using `json::encode`\n+//! let encoded = json::encode(&object).unwrap();\n //!\n-//!     // Deserialize using `json::decode`\n-//!     let decoded: TestStruct = json::decode(&encoded[..]).unwrap();\n-//! }\n+//! // Deserialize using `json::decode`\n+//! let decoded: TestStruct = json::decode(&encoded[..]).unwrap();\n //! ```\n //!\n //! ## Using the `ToJson` trait\n@@ -125,16 +123,14 @@\n //!     val: Json,\n //! }\n //!\n-//! fn main() {\n-//!     let num = ComplexNum { a: 0.0001, b: 12.539 };\n-//!     let data: String = json::encode(&ComplexNumRecord{\n-//!         uid: 1,\n-//!         dsc: \"test\".to_string(),\n-//!         val: num.to_json(),\n-//!     }).unwrap();\n-//!     println!(\"data: {}\", data);\n-//!     // data: {\"uid\":1,\"dsc\":\"test\",\"val\":\"0.0001+12.539i\"};\n-//! }\n+//! let num = ComplexNum { a: 0.0001, b: 12.539 };\n+//! let data: String = json::encode(&ComplexNumRecord{\n+//!     uid: 1,\n+//!     dsc: \"test\".to_string(),\n+//!     val: num.to_json(),\n+//! }).unwrap();\n+//! println!(\"data: {}\", data);\n+//! // data: {\"uid\":1,\"dsc\":\"test\",\"val\":\"0.0001+12.539i\"};\n //! ```\n //!\n //! ### Verbose example of `ToJson` usage\n@@ -164,19 +160,17 @@\n //!     }\n //! }\n //!\n-//! fn main() {\n-//!     // Serialize using `ToJson`\n-//!     let input_data = TestStruct {\n-//!         data_int: 1,\n-//!         data_str: \"madoka\".to_string(),\n-//!         data_vector: vec![2,3,4,5],\n-//!     };\n-//!     let json_obj: Json = input_data.to_json();\n-//!     let json_str: String = json_obj.to_string();\n+//! // Serialize using `ToJson`\n+//! let input_data = TestStruct {\n+//!     data_int: 1,\n+//!     data_str: \"madoka\".to_string(),\n+//!     data_vector: vec![2,3,4,5],\n+//! };\n+//! let json_obj: Json = input_data.to_json();\n+//! let json_str: String = json_obj.to_string();\n //!\n-//!     // Deserialize like before\n-//!     let decoded: TestStruct = json::decode(&json_str).unwrap();\n-//! }\n+//! // Deserialize like before\n+//! let decoded: TestStruct = json::decode(&json_str).unwrap();\n //! ```\n \n use self::DecoderError::*;\n@@ -1269,34 +1263,22 @@ impl Json {\n \n     /// Returns `true` if the Json value is a `Number`.\n     pub fn is_number(&self) -> bool {\n-        match *self {\n-            Json::I64(_) | Json::U64(_) | Json::F64(_) => true,\n-            _ => false,\n-        }\n+        matches!(*self, Json::I64(_) | Json::U64(_) | Json::F64(_))\n     }\n \n     /// Returns `true` if the Json value is a `i64`.\n     pub fn is_i64(&self) -> bool {\n-        match *self {\n-            Json::I64(_) => true,\n-            _ => false,\n-        }\n+        matches!(*self, Json::I64(_))\n     }\n \n     /// Returns `true` if the Json value is a `u64`.\n     pub fn is_u64(&self) -> bool {\n-        match *self {\n-            Json::U64(_) => true,\n-            _ => false,\n-        }\n+        matches!(*self, Json::U64(_))\n     }\n \n     /// Returns `true` if the Json value is a `f64`.\n     pub fn is_f64(&self) -> bool {\n-        match *self {\n-            Json::F64(_) => true,\n-            _ => false,\n-        }\n+        matches!(*self, Json::F64(_))\n     }\n \n     /// If the Json value is a number, returns or cast it to a `i64`;\n@@ -1416,6 +1398,7 @@ enum ParserState {\n /// structure of the JSON stream.\n ///\n /// An example is `foo.bar[3].x`.\n+#[derive(Default)]\n pub struct Stack {\n     stack: Vec<InternalStackElement>,\n     str_buffer: Vec<u8>,\n@@ -1442,7 +1425,7 @@ enum InternalStackElement {\n \n impl Stack {\n     pub fn new() -> Stack {\n-        Stack { stack: Vec::new(), str_buffer: Vec::new() }\n+        Self::default()\n     }\n \n     /// Returns The number of elements in the Stack.\n@@ -1547,10 +1530,7 @@ impl Stack {\n \n     // Used by Parser to test whether the top-most element is an index.\n     fn last_is_index(&self) -> bool {\n-        match self.stack.last() {\n-            Some(InternalIndex(_)) => true,\n-            _ => false,\n-        }\n+        matches!(self.stack.last(), Some(InternalIndex(_)))\n     }\n \n     // Used by Parser to increment the index of the top-most element."}, {"sha": "fa4423e261d1c98ccaf8e2494969cce8a300038e", "filename": "src/librustc_serialize/opaque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_serialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Flibrustc_serialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Fopaque.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -118,13 +118,13 @@ impl serialize::Encoder for Encoder {\n \n     #[inline]\n     fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        let as_u64: u64 = unsafe { ::std::mem::transmute(v) };\n+        let as_u64: u64 = v.to_bits();\n         self.emit_u64(as_u64)\n     }\n \n     #[inline]\n     fn emit_f32(&mut self, v: f32) -> EncodeResult {\n-        let as_u32: u32 = unsafe { ::std::mem::transmute(v) };\n+        let as_u32: u32 = v.to_bits();\n         self.emit_u32(as_u32)\n     }\n "}, {"sha": "9ce614fda575248063ae8d636921c102fd067754", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -35,7 +35,6 @@ struct RustArchiveIterator {\n };\n \n enum class LLVMRustArchiveKind {\n-  Other,\n   GNU,\n   BSD,\n   DARWIN,"}, {"sha": "76fe5e7f769f77066b59e23e47021b1937623531", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -311,7 +311,6 @@ static Optional<CodeModel::Model> fromRust(LLVMRustCodeModel Model) {\n }\n \n enum class LLVMRustCodeGenOptLevel {\n-  Other,\n   None,\n   Less,\n   Default,\n@@ -597,7 +596,6 @@ extern \"C\" void LLVMRustSetLLVMOptions(int Argc, char **Argv) {\n }\n \n enum class LLVMRustFileType {\n-  Other,\n   AssemblyFile,\n   ObjectFile,\n };"}, {"sha": "9d90b0dfe07024235a511e5fd77b0c47aa78e53e", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -366,7 +366,6 @@ LLVMRustBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef Target,\n }\n \n enum class LLVMRustSynchronizationScope {\n-  Other,\n   SingleThread,\n   CrossThread,\n };\n@@ -389,7 +388,6 @@ LLVMRustBuildAtomicFence(LLVMBuilderRef B, LLVMAtomicOrdering Order,\n }\n \n enum class LLVMRustAsmDialect {\n-  Other,\n   Att,\n   Intel,\n };"}, {"sha": "6c68cc7bc61aa94e25067b7431d84f80d7326f9e", "filename": "src/test/ui/associated-types/bound-lifetime-in-binding-only.elision.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -5,6 +5,11 @@ LL | fn elision<T: Fn() -> &i32>() {\n    |                       ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL | fn elision<T: for<'a> Fn() -> &'a i32>() {\n+   |               ^^^^^^^         ^^^\n help: consider using the `'static` lifetime\n    |\n LL | fn elision<T: Fn() -> &'static i32>() {"}, {"sha": "93d2f8e7911f08ceee48ca3eb3291a1b374722d8", "filename": "src/test/ui/associated-types/bound-lifetime-in-return-only.elision.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -5,6 +5,11 @@ LL | fn elision(_: fn() -> &i32) {\n    |                       ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the type lifetime-generic with a new `'a` lifetime\n+   |\n+LL | fn elision(_: for<'a> fn() -> &'a i32) {\n+   |               ^^^^^^^         ^^^\n help: consider using the `'static` lifetime\n    |\n LL | fn elision(_: fn() -> &'static i32) {"}, {"sha": "7058327fdce15ca12e2e7eb5f5be6c08f9405d13", "filename": "src/test/ui/const-generics/defaults/needs-feature.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fneeds-feature.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fneeds-feature.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fneeds-feature.min.stderr?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -2,7 +2,7 @@ error: type parameters must be declared prior to const parameters\n   --> $DIR/needs-feature.rs:10:26\n    |\n LL | struct A<const N: usize, T=u32>(T);\n-   |         -----------------^----- help: reorder the parameters: lifetimes, then consts, then types: `<T, const N: usize>`\n+   |         -----------------^----- help: reorder the parameters: lifetimes, then types, then consts: `<T, const N: usize>`\n \n error: aborting due to previous error\n "}, {"sha": "ac70e887626ab8348a1cdb7963064c1525c4cb99", "filename": "src/test/ui/error-codes/E0106.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Ferror-codes%2FE0106.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Ferror-codes%2FE0106.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0106.stderr?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -51,6 +51,15 @@ error[E0106]: missing lifetime specifiers\n    |\n LL |     buzz: Buzz,\n    |           ^^^^ expected 2 lifetime parameters\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | struct Quux<'a> {\n+LL |     baz: Baz,\n+LL |\n+LL |\n+LL |     buzz: Buzz<'a, 'a>,\n+   |\n \n error: aborting due to 5 previous errors\n "}, {"sha": "03622358ae1cd00ece3afc59383edccfed6fe0cb", "filename": "src/test/ui/issues/issue-74739.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fissues%2Fissue-74739.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fissues%2Fissue-74739.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-74739.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: -O\n+// run-pass\n+\n+struct Foo {\n+    x: i32,\n+}\n+\n+pub fn main() {\n+    let mut foo = Foo { x: 42 };\n+    let x = &mut foo.x;\n+    *x = 13;\n+    let y = foo;\n+    assert_eq!(y.x, 13); // used to print 42 due to mir-opt bug\n+}"}, {"sha": "d260addef481388ebfc3f314e3cfb80080790463", "filename": "src/test/ui/mismatched_types/issue-74918-missing-lifetime.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -6,8 +6,8 @@ LL |     type Item = IteratorChunk<T, S>;\n    |\n help: consider introducing a named lifetime parameter\n    |\n-LL |     type Item<'a> = IteratorChunk<<'a>T, S>;\n-   |              ^^^^                 ^^^^\n+LL |     type Item<'a> = IteratorChunk<'a, T, S>;\n+   |              ^^^^                 ^^^\n \n error: `impl` item signature doesn't match `trait` item signature\n   --> $DIR/issue-74918-missing-lifetime.rs:11:5"}, {"sha": "38332627f4c87a86a2a819151f6d0c40769bb9b7", "filename": "src/test/ui/suggestions/missing-lifetime-in-assoc-const-type.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-in-assoc-const-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-in-assoc-const-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-in-assoc-const-type.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -0,0 +1,16 @@\n+trait ZstAssert: Sized {\n+    const A: &str = \"\"; //~ ERROR missing lifetime specifier\n+    const B: S = S { s: &() }; //~ ERROR missing lifetime specifier\n+    const C: &'_ str = \"\"; //~ ERROR missing lifetime specifier\n+    const D: T = T { a: &(), b: &() }; //~ ERROR missing lifetime specifier\n+}\n+\n+struct S<'a> {\n+    s: &'a (),\n+}\n+struct T<'a, 'b> {\n+    a: &'a (),\n+    b: &'b (),\n+}\n+\n+fn main() {}"}, {"sha": "b20778ce208176346db23b7fc4c09d294c16bc48", "filename": "src/test/ui/suggestions/missing-lifetime-in-assoc-const-type.stderr", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-in-assoc-const-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-in-assoc-const-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-in-assoc-const-type.stderr?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -0,0 +1,73 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-in-assoc-const-type.rs:2:14\n+   |\n+LL |     const A: &str = \"\";\n+   |              ^ expected named lifetime parameter\n+   |\n+help: consider using the `'static` lifetime\n+   |\n+LL |     const A: &'static str = \"\";\n+   |               ^^^^^^^\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | trait ZstAssert<'a>: Sized {\n+LL |     const A: &'a str = \"\";\n+   |\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-in-assoc-const-type.rs:3:14\n+   |\n+LL |     const B: S = S { s: &() };\n+   |              ^ expected named lifetime parameter\n+   |\n+help: consider using the `'static` lifetime\n+   |\n+LL |     const B: S<'static> = S { s: &() };\n+   |               ^^^^^^^^^\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | trait ZstAssert<'a>: Sized {\n+LL |     const A: &str = \"\";\n+LL |     const B: S<'a> = S { s: &() };\n+   |\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-in-assoc-const-type.rs:4:15\n+   |\n+LL |     const C: &'_ str = \"\";\n+   |               ^^ expected named lifetime parameter\n+   |\n+help: consider using the `'static` lifetime\n+   |\n+LL |     const C: &'static str = \"\";\n+   |               ^^^^^^^\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | trait ZstAssert<'a>: Sized {\n+LL |     const A: &str = \"\";\n+LL |     const B: S = S { s: &() };\n+LL |     const C: &'a str = \"\";\n+   |\n+\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/missing-lifetime-in-assoc-const-type.rs:5:14\n+   |\n+LL |     const D: T = T { a: &(), b: &() };\n+   |              ^ expected 2 lifetime parameters\n+   |\n+help: consider using the `'static` lifetime\n+   |\n+LL |     const D: T<'static, 'static> = T { a: &(), b: &() };\n+   |               ^^^^^^^^^^^^^^^^^^\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | trait ZstAssert<'a>: Sized {\n+LL |     const A: &str = \"\";\n+LL |     const B: S = S { s: &() };\n+LL |     const C: &'_ str = \"\";\n+LL |     const D: T<'a, 'a> = T { a: &(), b: &() };\n+   |\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "a90a90122ad19f1cb3f79b8c881f544eaea1e84d", "filename": "src/test/ui/suggestions/missing-lt-for-hrtb.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.rs?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -0,0 +1,15 @@\n+struct X<'a>(&'a ());\n+struct S<'a>(&'a dyn Fn(&X) -> &X);\n+//~^ ERROR missing lifetime specifier\n+//~| ERROR missing lifetime specifier\n+struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n+//~^ ERROR missing lifetime specifier\n+//~| ERROR missing lifetime specifier\n+\n+fn main() {\n+    let x = S(&|x| {\n+        println!(\"hi\");\n+        x\n+    });\n+    x.0(&X(&()));\n+}"}, {"sha": "2cb63500e48b919e571026ce0a0c865a307da0cf", "filename": "src/test/ui/suggestions/missing-lt-for-hrtb.stderr", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr?ref=9aa6cc025d3ec68aa3489d0c4f92421e02cdbacd", "patch": "@@ -0,0 +1,63 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lt-for-hrtb.rs:2:32\n+   |\n+LL | struct S<'a>(&'a dyn Fn(&X) -> &X);\n+   |                         --     ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of argument 1's 2 lifetimes it is borrowed from\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'b` lifetime\n+   |\n+LL | struct S<'a>(&'a dyn for<'b> Fn(&'b X) -> &'b X);\n+   |                      ^^^^^^^    ^^^^^     ^^^\n+help: consider using the `'a` lifetime\n+   |\n+LL | struct S<'a>(&'a dyn Fn(&X) -> &'a X);\n+   |                                ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lt-for-hrtb.rs:2:33\n+   |\n+LL | struct S<'a>(&'a dyn Fn(&X) -> &X);\n+   |                         --      ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of argument 1's 2 lifetimes it is borrowed from\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'b` lifetime\n+   |\n+LL | struct S<'a>(&'a dyn for<'b> Fn(&'b X) -> &X<'b>);\n+   |                      ^^^^^^^    ^^^^^      ^^^^^\n+help: consider using the `'a` lifetime\n+   |\n+LL | struct S<'a>(&'a dyn Fn(&X) -> &X<'a>);\n+   |                                 ^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lt-for-hrtb.rs:5:40\n+   |\n+LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n+   |                                 --     ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of argument 1's 2 lifetimes it is borrowed from\n+note: these named lifetimes are available to use\n+  --> $DIR/missing-lt-for-hrtb.rs:5:10\n+   |\n+LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n+   |          ^^              ^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lt-for-hrtb.rs:5:41\n+   |\n+LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n+   |                                 --      ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of argument 1's 2 lifetimes it is borrowed from\n+note: these named lifetimes are available to use\n+  --> $DIR/missing-lt-for-hrtb.rs:5:10\n+   |\n+LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n+   |          ^^              ^^\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0106`."}]}