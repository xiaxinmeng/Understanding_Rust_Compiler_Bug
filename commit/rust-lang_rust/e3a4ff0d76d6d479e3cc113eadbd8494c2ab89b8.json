{"sha": "e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzYTRmZjBkNzZkNmQ0NzllM2NjMTEzZWFkYmQ4NDk0YzJhYjg5Yjg=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-08T16:48:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-08T16:48:28Z"}, "message": "Rollup merge of #71970 - thombles:ios-bitcode-improvements, r=alexcrichton\n\nImprove bitcode generation for Apple platforms\n\nSome improvements for iOS bitcode support suggested by Alex over at https://github.com/getditto/rust-bitcode/issues/9. r? @alexcrichton\n\nThis improves Rust's bitcode generation so that provided you have a compatible LLVM version, Rust targeting iOS should work out of the box when compiled into bitcode-enabled apps, and when submitted to the App Store. I've tested these changes using Xcode 11.4.1 and Apple's vendored LLVM, [tag `swift-5.2.3-RELEASE`](https://github.com/apple/llvm-project/releases/tag/swift-5.2.3-RELEASE).\n\n1. Force `aarch64-apple-ios` and `aarch64-apple-tvos` targets to always emit full bitcode sections, even when cargo is trying to optimise by invoking `rustc` with `-Cembed-bitcode=no`. Since Apple recommends bitcode on iOS and requires it on tvOS it is likely that this is what developers intend. Currently you need to override the codegen options with `RUSTFLAGS`, which is far from obvious.\n2. Provide an LLVM cmdline in the target spec. Apple's bitcode verification process looks for some arguments. For Rust modules to be accepted we must pretend they were produced similarly. A suitable default is provided in `TargetOptions` for iOS, copied directly from the a clang equivalent section.\n\nIn the context of Apple platforms, the predominant purpose of bitcode is App Store submissions, so simulator and 32-bit targets are not relevant. I'm hoping that the cmdline strings will not be a maintenance burden to keep up-to-date. If the event of any future incompatibilities, hopefully a custom target config would offer enough flexibility to work around it. It's impossible to say for sure.\n\nDue to unrelated build errors I haven't been able to build and test a full tvOS toolchain. I've stopped short of providing a similar `bitcode_llvm_cmdline` until I can actually test it.", "tree": {"sha": "a0b27b2adb1cee8e4ae7378df787d65eb03a8605", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0b27b2adb1cee8e4ae7378df787d65eb03a8605"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJetY1cCRBK7hj4Ov3rIwAAdHIIAHVkJazGyZYO9HaUiguREb88\nGKB94cDb4vxg8/LNF052X6urclfkWCe7T2jt1af1NVTZWEhpFQzv7bDtt+sIIfVx\ndv/NDx4MKAMGXwL9sba2mtjZLt6ZnaDIOZUuNdGxW2IVyPfE6yWZYQmza+RK7yum\nFMjVwGwjJCEWcmjzh/eB1jmrMfV/fqjZVBlK66ZSE9Ny7HgA1C7pKmCVOpoywqok\nBdesSlvEHY8MOat0h81mJX0JRwGWxODdWya0d1aFMiDEFDAUPF4uJLtrlTTZHdat\n8tSyzNgFz+RFmDxHituMxvok9a+i+Tn4B1a6u0ZvtFe929kyVQltXQfPXhkt1r4=\n=Az7v\n-----END PGP SIGNATURE-----\n", "payload": "tree a0b27b2adb1cee8e4ae7378df787d65eb03a8605\nparent a9eb01ae03770419ff61273cc8a5b8ec21483b9e\nparent 4fea9cdd2400f60439f96999f423f92a711b984d\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588956508 +0200\ncommitter GitHub <noreply@github.com> 1588956508 +0200\n\nRollup merge of #71970 - thombles:ios-bitcode-improvements, r=alexcrichton\n\nImprove bitcode generation for Apple platforms\n\nSome improvements for iOS bitcode support suggested by Alex over at https://github.com/getditto/rust-bitcode/issues/9. r? @alexcrichton\n\nThis improves Rust's bitcode generation so that provided you have a compatible LLVM version, Rust targeting iOS should work out of the box when compiled into bitcode-enabled apps, and when submitted to the App Store. I've tested these changes using Xcode 11.4.1 and Apple's vendored LLVM, [tag `swift-5.2.3-RELEASE`](https://github.com/apple/llvm-project/releases/tag/swift-5.2.3-RELEASE).\n\n1. Force `aarch64-apple-ios` and `aarch64-apple-tvos` targets to always emit full bitcode sections, even when cargo is trying to optimise by invoking `rustc` with `-Cembed-bitcode=no`. Since Apple recommends bitcode on iOS and requires it on tvOS it is likely that this is what developers intend. Currently you need to override the codegen options with `RUSTFLAGS`, which is far from obvious.\n2. Provide an LLVM cmdline in the target spec. Apple's bitcode verification process looks for some arguments. For Rust modules to be accepted we must pretend they were produced similarly. A suitable default is provided in `TargetOptions` for iOS, copied directly from the a clang equivalent section.\n\nIn the context of Apple platforms, the predominant purpose of bitcode is App Store submissions, so simulator and 32-bit targets are not relevant. I'm hoping that the cmdline strings will not be a maintenance burden to keep up-to-date. If the event of any future incompatibilities, hopefully a custom target config would offer enough flexibility to work around it. It's impossible to say for sure.\n\nDue to unrelated build errors I haven't been able to build and test a full tvOS toolchain. I've stopped short of providing a similar `bitcode_llvm_cmdline` until I can actually test it.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8", "html_url": "https://github.com/rust-lang/rust/commit/e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9eb01ae03770419ff61273cc8a5b8ec21483b9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9eb01ae03770419ff61273cc8a5b8ec21483b9e", "html_url": "https://github.com/rust-lang/rust/commit/a9eb01ae03770419ff61273cc8a5b8ec21483b9e"}, {"sha": "4fea9cdd2400f60439f96999f423f92a711b984d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fea9cdd2400f60439f96999f423f92a711b984d", "html_url": "https://github.com/rust-lang/rust/commit/4fea9cdd2400f60439f96999f423f92a711b984d"}], "stats": {"total": 65, "additions": 41, "deletions": 24}, "files": [{"sha": "e261ac654467954c11442f22cdf3b25ca380ae71", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8", "patch": "@@ -651,10 +651,8 @@ pub(crate) unsafe fn codegen(\n                     \"LLVM_module_codegen_embed_bitcode\",\n                     &module.name[..],\n                 );\n-                embed_bitcode(cgcx, llcx, llmod, Some(data));\n+                embed_bitcode(cgcx, llcx, llmod, &config.bc_cmdline, data);\n             }\n-        } else if config.emit_obj == EmitObj::ObjectCode(BitcodeSection::Marker) {\n-            embed_bitcode(cgcx, llcx, llmod, None);\n         }\n \n         if config.emit_ir {\n@@ -777,8 +775,8 @@ pub(crate) unsafe fn codegen(\n /// * __LLVM,__cmdline\n ///\n /// It appears *both* of these sections are necessary to get the linker to\n-/// recognize what's going on. For us though we just always throw in an empty\n-/// cmdline section.\n+/// recognize what's going on. A suitable cmdline value is taken from the\n+/// target spec.\n ///\n /// Furthermore debug/O1 builds don't actually embed bitcode but rather just\n /// embed an empty section.\n@@ -789,9 +787,10 @@ unsafe fn embed_bitcode(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     llcx: &llvm::Context,\n     llmod: &llvm::Module,\n-    bitcode: Option<&[u8]>,\n+    cmdline: &str,\n+    bitcode: &[u8],\n ) {\n-    let llconst = common::bytes_in_context(llcx, bitcode.unwrap_or(&[]));\n+    let llconst = common::bytes_in_context(llcx, bitcode);\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n         common::val_ty(llconst),\n@@ -800,14 +799,15 @@ unsafe fn embed_bitcode(\n     llvm::LLVMSetInitializer(llglobal, llconst);\n \n     let is_apple = cgcx.opts.target_triple.triple().contains(\"-ios\")\n-        || cgcx.opts.target_triple.triple().contains(\"-darwin\");\n+        || cgcx.opts.target_triple.triple().contains(\"-darwin\")\n+        || cgcx.opts.target_triple.triple().contains(\"-tvos\");\n \n     let section = if is_apple { \"__LLVM,__bitcode\\0\" } else { \".llvmbc\\0\" };\n     llvm::LLVMSetSection(llglobal, section.as_ptr().cast());\n     llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n     llvm::LLVMSetGlobalConstant(llglobal, llvm::True);\n \n-    let llconst = common::bytes_in_context(llcx, &[]);\n+    let llconst = common::bytes_in_context(llcx, cmdline.as_bytes());\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n         common::val_ty(llconst),"}, {"sha": "21eb56f12b97117b8d495b9c079016a3cd564855", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8", "patch": "@@ -68,10 +68,6 @@ pub enum BitcodeSection {\n     // No bitcode section.\n     None,\n \n-    // An empty bitcode section (to placate tools such as the iOS linker that\n-    // require this section even if they don't use it).\n-    Marker,\n-\n     // A full, uncompressed bitcode section.\n     Full,\n }\n@@ -101,6 +97,7 @@ pub struct ModuleConfig {\n     pub emit_ir: bool,\n     pub emit_asm: bool,\n     pub emit_obj: EmitObj,\n+    pub bc_cmdline: String,\n \n     // Miscellaneous flags.  These are mostly copied from command-line\n     // options.\n@@ -147,14 +144,8 @@ impl ModuleConfig {\n             || sess.opts.cg.linker_plugin_lto.enabled()\n         {\n             EmitObj::Bitcode\n-        } else if need_crate_bitcode_for_rlib(sess) {\n-            let force_full = need_crate_bitcode_for_rlib(sess);\n-            match sess.opts.optimize {\n-                config::OptLevel::No | config::OptLevel::Less if !force_full => {\n-                    EmitObj::ObjectCode(BitcodeSection::Marker)\n-                }\n-                _ => EmitObj::ObjectCode(BitcodeSection::Full),\n-            }\n+        } else if need_bitcode_in_object(sess) {\n+            EmitObj::ObjectCode(BitcodeSection::Full)\n         } else {\n             EmitObj::ObjectCode(BitcodeSection::None)\n         };\n@@ -211,6 +202,7 @@ impl ModuleConfig {\n                 false\n             ),\n             emit_obj,\n+            bc_cmdline: sess.target.target.options.bitcode_llvm_cmdline.clone(),\n \n             verify_llvm_ir: sess.verify_llvm_ir(),\n             no_prepopulate_passes: sess.opts.cg.no_prepopulate_passes,\n@@ -372,10 +364,12 @@ pub struct CompiledModules {\n     pub allocator_module: Option<CompiledModule>,\n }\n \n-fn need_crate_bitcode_for_rlib(sess: &Session) -> bool {\n-    sess.opts.cg.embed_bitcode\n+fn need_bitcode_in_object(sess: &Session) -> bool {\n+    let requested_for_rlib = sess.opts.cg.embed_bitcode\n         && sess.crate_types.borrow().contains(&CrateType::Rlib)\n-        && sess.opts.output_types.contains_key(&OutputType::Exe)\n+        && sess.opts.output_types.contains_key(&OutputType::Exe);\n+    let forced_by_target = sess.target.target.options.forces_embed_bitcode;\n+    requested_for_rlib || forced_by_target\n }\n \n fn need_pre_lto_bitcode_for_incr_comp(sess: &Session) -> bool {"}, {"sha": "eac2c3e6aa40c672c7dae945756ce667b434f53d", "filename": "src/librustc_target/spec/aarch64_apple_ios.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8/src%2Flibrustc_target%2Fspec%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8/src%2Flibrustc_target%2Fspec%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_apple_ios.rs?ref=e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8", "patch": "@@ -19,6 +19,18 @@ pub fn target() -> TargetResult {\n             eliminate_frame_pointer: false,\n             max_atomic_width: Some(128),\n             abi_blacklist: super::arm_base::abi_blacklist(),\n+            forces_embed_bitcode: true,\n+            // Taken from a clang build on Xcode 11.4.1.\n+            // These arguments are not actually invoked - they just have\n+            // to look right to pass App Store validation.\n+            bitcode_llvm_cmdline: \"-triple\\0\\\n+                arm64-apple-ios11.0.0\\0\\\n+                -emit-obj\\0\\\n+                -disable-llvm-passes\\0\\\n+                -target-abi\\0\\\n+                darwinpcs\\0\\\n+                -Os\\0\"\n+                .to_string(),\n             ..base\n         },\n     })"}, {"sha": "f1cd14ffd11a6a7ea89b8f726335636f06cd50a7", "filename": "src/librustc_target/spec/aarch64_apple_tvos.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8/src%2Flibrustc_target%2Fspec%2Faarch64_apple_tvos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8/src%2Flibrustc_target%2Fspec%2Faarch64_apple_tvos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_apple_tvos.rs?ref=e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> TargetResult {\n             eliminate_frame_pointer: false,\n             max_atomic_width: Some(128),\n             abi_blacklist: super::arm_base::abi_blacklist(),\n+            forces_embed_bitcode: true,\n             ..base\n         },\n     })"}, {"sha": "51dce9e144caa359f2c294b9aa0aa481473b4f04", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8", "patch": "@@ -783,6 +783,10 @@ pub struct TargetOptions {\n     // If we give emcc .o files that are actually .bc files it\n     // will 'just work'.\n     pub obj_is_bitcode: bool,\n+    /// Whether the target requires that emitted object code includes bitcode.\n+    pub forces_embed_bitcode: bool,\n+    /// Content of the LLVM cmdline section associated with embedded bitcode.\n+    pub bitcode_llvm_cmdline: String,\n \n     /// Don't use this field; instead use the `.min_atomic_width()` method.\n     pub min_atomic_width: Option<u64>,\n@@ -939,6 +943,8 @@ impl Default for TargetOptions {\n             allow_asm: true,\n             has_elf_tls: false,\n             obj_is_bitcode: false,\n+            forces_embed_bitcode: false,\n+            bitcode_llvm_cmdline: String::new(),\n             min_atomic_width: None,\n             max_atomic_width: None,\n             atomic_cas: true,\n@@ -1278,6 +1284,8 @@ impl Target {\n         key!(main_needs_argc_argv, bool);\n         key!(has_elf_tls, bool);\n         key!(obj_is_bitcode, bool);\n+        key!(forces_embed_bitcode, bool);\n+        key!(bitcode_llvm_cmdline);\n         key!(max_atomic_width, Option<u64>);\n         key!(min_atomic_width, Option<u64>);\n         key!(atomic_cas, bool);\n@@ -1505,6 +1513,8 @@ impl ToJson for Target {\n         target_option_val!(main_needs_argc_argv);\n         target_option_val!(has_elf_tls);\n         target_option_val!(obj_is_bitcode);\n+        target_option_val!(forces_embed_bitcode);\n+        target_option_val!(bitcode_llvm_cmdline);\n         target_option_val!(min_atomic_width);\n         target_option_val!(max_atomic_width);\n         target_option_val!(atomic_cas);"}]}