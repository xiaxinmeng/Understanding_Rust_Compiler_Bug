{"sha": "31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZTEwYWVjODNkNjhkZjBmNDVjZjY2NDNjY2E0ZTkwZTljMWZiNTU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-15T22:04:05Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-19T09:01:48Z"}, "message": "libsyntax: Remove `Mark` into `ExpnId`", "tree": {"sha": "deae30ca3e063c66ebf6f03857156939fec0be3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deae30ca3e063c66ebf6f03857156939fec0be3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "html_url": "https://github.com/rust-lang/rust/commit/31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9477a77c52af8d3dea361b3f4ac3e60653aa529", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9477a77c52af8d3dea361b3f4ac3e60653aa529", "html_url": "https://github.com/rust-lang/rust/commit/f9477a77c52af8d3dea361b3f4ac3e60653aa529"}], "stats": {"total": 365, "additions": 183, "deletions": 182}, "files": [{"sha": "c228bc2cf6b8c33d22bbba60258c93e0c84a5f4e", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -60,7 +60,7 @@ use syntax::attr;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::errors;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax::print::pprust;\n use syntax::source_map::{respan, ExpnInfo, ExpnKind, DesugaringKind, Spanned};\n use syntax::std_inject;\n@@ -437,7 +437,7 @@ impl<'a> LoweringContext<'a> {\n                                 owner,\n                                 id,\n                                 DefPathData::Misc,\n-                                Mark::root(),\n+                                ExpnId::root(),\n                                 tree.prefix.span,\n                             );\n                             self.lctx.allocate_hir_id_counter(id);\n@@ -875,7 +875,7 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     ) -> Span {\n-        span.fresh_expansion(Mark::root(), ExpnInfo {\n+        span.fresh_expansion(ExpnId::root(), ExpnInfo {\n             def_site: span,\n             allow_internal_unstable,\n             ..ExpnInfo::default(ExpnKind::Desugaring(reason), span, self.sess.edition())\n@@ -968,7 +968,7 @@ impl<'a> LoweringContext<'a> {\n             parent_index,\n             node_id,\n             DefPathData::LifetimeNs(str_name),\n-            Mark::root(),\n+            ExpnId::root(),\n             span,\n         );\n \n@@ -1462,7 +1462,7 @@ impl<'a> LoweringContext<'a> {\n                         parent_def_index,\n                         impl_trait_node_id,\n                         DefPathData::ImplTrait,\n-                        Mark::root(),\n+                        ExpnId::root(),\n                         DUMMY_SP\n                     );\n \n@@ -1921,7 +1921,7 @@ impl<'a> LoweringContext<'a> {\n                         self.parent,\n                         def_node_id,\n                         DefPathData::LifetimeNs(name.ident().as_interned_str()),\n-                        Mark::root(),\n+                        ExpnId::root(),\n                         lifetime.span);\n \n                     let (name, kind) = match name {"}, {"sha": "854b09c6dc914c2be06890e01096948416627929", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -2,7 +2,7 @@ use crate::hir::map::definitions::*;\n use crate::hir::def_id::DefIndex;\n \n use syntax::ast::*;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax::visit;\n use syntax::symbol::{kw, sym};\n use syntax::parse::token::{self, Token};\n@@ -12,11 +12,11 @@ use syntax_pos::Span;\n pub struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n     parent_def: DefIndex,\n-    expansion: Mark,\n+    expansion: ExpnId,\n }\n \n impl<'a> DefCollector<'a> {\n-    pub fn new(definitions: &'a mut Definitions, expansion: Mark) -> Self {\n+    pub fn new(definitions: &'a mut Definitions, expansion: ExpnId) -> Self {\n         let parent_def = definitions.invocation_parent(expansion);\n         DefCollector { definitions, parent_def, expansion }\n     }"}, {"sha": "bbaa731abc995eeb4b00d79c5a79c0fb9d3de1be", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -15,7 +15,7 @@ use std::borrow::Borrow;\n use std::fmt::Write;\n use std::hash::Hash;\n use syntax::ast;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax::symbol::{Symbol, sym, InternedString};\n use syntax_pos::{Span, DUMMY_SP};\n use crate::util::nodemap::NodeMap;\n@@ -93,16 +93,16 @@ pub struct Definitions {\n     node_to_def_index: NodeMap<DefIndex>,\n     def_index_to_node: Vec<ast::NodeId>,\n     pub(super) node_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n-    /// If `Mark` is an ID of some macro expansion,\n+    /// If `ExpnId` is an ID of some macro expansion,\n     /// then `DefId` is the normal module (`mod`) in which the expanded macro was defined.\n-    parent_modules_of_macro_defs: FxHashMap<Mark, DefId>,\n-    /// Item with a given `DefIndex` was defined during macro expansion with ID `Mark`.\n-    expansions_that_defined: FxHashMap<DefIndex, Mark>,\n+    parent_modules_of_macro_defs: FxHashMap<ExpnId, DefId>,\n+    /// Item with a given `DefIndex` was defined during macro expansion with ID `ExpnId`.\n+    expansions_that_defined: FxHashMap<DefIndex, ExpnId>,\n     next_disambiguator: FxHashMap<(DefIndex, DefPathData), u32>,\n     def_index_to_span: FxHashMap<DefIndex, Span>,\n-    /// When collecting definitions from an AST fragment produced by a macro invocation `Mark`\n+    /// When collecting definitions from an AST fragment produced by a macro invocation `ExpnId`\n     /// we know what parent node that fragment should be attached to thanks to this table.\n-    invocation_parents: FxHashMap<Mark, DefIndex>,\n+    invocation_parents: FxHashMap<ExpnId, DefIndex>,\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -437,7 +437,7 @@ impl Definitions {\n         assert!(self.def_index_to_node.is_empty());\n         self.def_index_to_node.push(ast::CRATE_NODE_ID);\n         self.node_to_def_index.insert(ast::CRATE_NODE_ID, root_index);\n-        self.set_invocation_parent(Mark::root(), root_index);\n+        self.set_invocation_parent(ExpnId::root(), root_index);\n \n         // Allocate some other DefIndices that always must exist.\n         GlobalMetaDataKind::allocate_def_indices(self);\n@@ -450,7 +450,7 @@ impl Definitions {\n                                   parent: DefIndex,\n                                   node_id: ast::NodeId,\n                                   data: DefPathData,\n-                                  expansion: Mark,\n+                                  expansion: ExpnId,\n                                   span: Span)\n                                   -> DefIndex {\n         debug!(\"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n@@ -498,7 +498,7 @@ impl Definitions {\n             self.node_to_def_index.insert(node_id, index);\n         }\n \n-        if expansion != Mark::root() {\n+        if expansion != ExpnId::root() {\n             self.expansions_that_defined.insert(index, expansion);\n         }\n \n@@ -519,23 +519,23 @@ impl Definitions {\n         self.node_to_hir_id = mapping;\n     }\n \n-    pub fn expansion_that_defined(&self, index: DefIndex) -> Mark {\n-        self.expansions_that_defined.get(&index).cloned().unwrap_or(Mark::root())\n+    pub fn expansion_that_defined(&self, index: DefIndex) -> ExpnId {\n+        self.expansions_that_defined.get(&index).cloned().unwrap_or(ExpnId::root())\n     }\n \n-    pub fn parent_module_of_macro_def(&self, mark: Mark) -> DefId {\n+    pub fn parent_module_of_macro_def(&self, mark: ExpnId) -> DefId {\n         self.parent_modules_of_macro_defs[&mark]\n     }\n \n-    pub fn add_parent_module_of_macro_def(&mut self, mark: Mark, module: DefId) {\n+    pub fn add_parent_module_of_macro_def(&mut self, mark: ExpnId, module: DefId) {\n         self.parent_modules_of_macro_defs.insert(mark, module);\n     }\n \n-    pub fn invocation_parent(&self, invoc_id: Mark) -> DefIndex {\n+    pub fn invocation_parent(&self, invoc_id: ExpnId) -> DefIndex {\n         self.invocation_parents[&invoc_id]\n     }\n \n-    pub fn set_invocation_parent(&mut self, invoc_id: Mark, parent: DefIndex) {\n+    pub fn set_invocation_parent(&mut self, invoc_id: ExpnId, parent: DefIndex) {\n         let old_parent = self.invocation_parents.insert(invoc_id, parent);\n         assert!(old_parent.is_none(), \"parent def-index is reset for an invocation\");\n     }\n@@ -624,7 +624,7 @@ macro_rules! define_global_metadata_kind {\n                         CRATE_DEF_INDEX,\n                         ast::DUMMY_NODE_ID,\n                         DefPathData::GlobalMetaData(instance.name().as_interned_str()),\n-                        Mark::root(),\n+                        ExpnId::root(),\n                         DUMMY_SP\n                     );\n "}, {"sha": "d85ef1f15677f9d43788e8d1965b7fe11a15c5f2", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -359,7 +359,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n             // times, we cache a stable hash of it and hash that instead of\n             // recursing every time.\n             thread_local! {\n-                static CACHE: RefCell<FxHashMap<hygiene::Mark, u64>> = Default::default();\n+                static CACHE: RefCell<FxHashMap<hygiene::ExpnId, u64>> = Default::default();\n             }\n \n             let sub_hash: u64 = CACHE.with(|cache| {"}, {"sha": "538afa6054ff9611ad635915e35bc1f3d8fb3598", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -44,7 +44,7 @@ use std::{mem, ptr};\n use std::ops::Range;\n use syntax::ast::{self, Name, Ident, NodeId};\n use syntax::attr;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax::symbol::{kw, sym, Symbol, LocalInternedString, InternedString};\n use syntax_pos::Span;\n \n@@ -3071,10 +3071,10 @@ impl<'tcx> TyCtxt<'tcx> {\n                                          self.expansion_that_defined(def_parent_def_id))\n     }\n \n-    fn expansion_that_defined(self, scope: DefId) -> Mark {\n+    fn expansion_that_defined(self, scope: DefId) -> ExpnId {\n         match scope.krate {\n             LOCAL_CRATE => self.hir().definitions().expansion_that_defined(scope.index),\n-            _ => Mark::root(),\n+            _ => ExpnId::root(),\n         }\n     }\n "}, {"sha": "333964514c1819dc4745b56e107cdb7dd58561b7", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -23,7 +23,7 @@ use std::mem;\n use syntax::ast::NodeId;\n use syntax::source_map::{SourceMap, StableSourceFileId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, SourceFile};\n-use syntax_pos::hygiene::{Mark, SyntaxContext, ExpnInfo};\n+use syntax_pos::hygiene::{ExpnId, SyntaxContext, ExpnInfo};\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n \n@@ -594,7 +594,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n         // as long as incremental compilation does not kick in before that.\n         let location = || Span::new(lo, hi, SyntaxContext::empty());\n         let recover_from_expn_info = |this: &Self, expn_info, pos| {\n-            let span = location().fresh_expansion(Mark::root(), expn_info);\n+            let span = location().fresh_expansion(ExpnId::root(), expn_info);\n             this.synthetic_expansion_infos.borrow_mut().insert(pos, span.ctxt());\n             span\n         };\n@@ -725,7 +725,7 @@ struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n     encoder: &'a mut E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n-    expn_info_shorthands: FxHashMap<Mark, AbsoluteBytePos>,\n+    expn_info_shorthands: FxHashMap<ExpnId, AbsoluteBytePos>,\n     interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n     interpret_allocs_inverse: Vec<interpret::AllocId>,\n     source_map: CachingSourceMapView<'tcx>,"}, {"sha": "87373364c4d9e3d26753f667c03ac52d86774f84", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -14,7 +14,7 @@ use syntax::{\n         base::{ExtCtxt, MacroKind, Resolver},\n         build::AstBuilder,\n         expand::ExpansionConfig,\n-        hygiene::Mark,\n+        hygiene::ExpnId,\n     },\n     mut_visit::{self, MutVisitor},\n     parse::ParseSess,\n@@ -85,7 +85,7 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n         self.found = true;\n \n         // Create a new expansion for the generated allocator code.\n-        let span = item.span.fresh_expansion(Mark::root(), ExpnInfo::allow_unstable(\n+        let span = item.span.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n             ExpnKind::Macro(MacroKind::Attr, sym::global_allocator), item.span, self.sess.edition,\n             [sym::rustc_attrs][..].into(),\n         ));"}, {"sha": "c9e4663fdbddfa2eb688e3b4c330a33d47db732d", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -26,7 +26,7 @@ use rustc_errors::{Handler, Level, DiagnosticBuilder, FatalError, DiagnosticId};\n use rustc_errors::emitter::{Emitter};\n use rustc_target::spec::MergeFunctions;\n use syntax::attr;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax_pos::MultiSpan;\n use syntax_pos::symbol::{Symbol, sym};\n use jobserver::{Client, Acquired};\n@@ -1775,7 +1775,7 @@ impl SharedEmitterMain {\n                     }\n                 }\n                 Ok(SharedEmitterMessage::InlineAsmError(cookie, msg)) => {\n-                    match Mark::from_u32(cookie).expn_info() {\n+                    match ExpnId::from_u32(cookie).expn_info() {\n                         Some(ei) => sess.span_err(ei.call_site, &msg),\n                         None     => sess.err(&msg),\n                     }"}, {"sha": "8e76dbb882e3bdce6cc5a3fabe1fc7ef7bf9851a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -31,7 +31,7 @@ use syntax::ast::{self, Ident};\n use syntax::source_map;\n use syntax::symbol::{Symbol, sym};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n use log::debug;\n \n@@ -458,7 +458,7 @@ crate fn proc_macro_def_path_table(crate_root: &CrateRoot<'_>,\n             crate_root,\n             ast::DUMMY_NODE_ID,\n             DefPathData::MacroNs(name.as_interned_str()),\n-            Mark::root(),\n+            ExpnId::root(),\n             DUMMY_SP);\n         debug!(\"definition for {:?} is {:?}\", name, def_index);\n         assert_eq!(def_index, DefIndex::from_proc_macro_index(index));"}, {"sha": "9ac6399689829a15395c7580a0756698d7ff567f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -30,7 +30,7 @@ use syntax::attr;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use syntax::ast::{MetaItemKind, StmtKind, TraitItem, TraitItemKind, Variant};\n use syntax::ext::base::SyntaxExtension;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n@@ -45,7 +45,7 @@ use log::debug;\n \n type Res = def::Res<NodeId>;\n \n-impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, Mark) {\n+impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, ExpnId) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Module(self.0),\n@@ -57,7 +57,7 @@ impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, Mark) {\n     }\n }\n \n-impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, Mark) {\n+impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, ExpnId) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Res(self.0, false),\n@@ -71,7 +71,7 @@ impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, Mark) {\n \n pub(crate) struct IsMacroExport;\n \n-impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, Mark, IsMacroExport) {\n+impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, ExpnId, IsMacroExport) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Res(self.0, true),\n@@ -397,7 +397,7 @@ impl<'a> Resolver<'a> {\n                 let imported_binding = self.import(binding, directive);\n                 if ptr::eq(self.current_module, self.graph_root) {\n                     if let Some(entry) = self.extern_prelude.get(&ident.modern()) {\n-                        if expansion != Mark::root() && orig_name.is_some() &&\n+                        if expansion != ExpnId::root() && orig_name.is_some() &&\n                            entry.extern_crate_item.is_none() {\n                             self.session.span_err(item.span, \"macro-expanded `extern crate` items \\\n                                                               cannot shadow names passed with \\\n@@ -571,7 +571,7 @@ impl<'a> Resolver<'a> {\n                                        variant: &Variant,\n                                        parent: Module<'a>,\n                                        vis: ty::Visibility,\n-                                       expansion: Mark) {\n+                                       expansion: ExpnId) {\n         let ident = variant.node.ident;\n \n         // Define a name in the type namespace.\n@@ -600,7 +600,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expansion: Mark) {\n+    fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expansion: ExpnId) {\n         let (res, ns) = match item.node {\n             ForeignItemKind::Fn(..) => {\n                 (Res::Def(DefKind::Fn, self.definitions.local_def_id(item.id)), ValueNS)\n@@ -618,7 +618,7 @@ impl<'a> Resolver<'a> {\n         self.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n     }\n \n-    fn build_reduced_graph_for_block(&mut self, block: &Block, expansion: Mark) {\n+    fn build_reduced_graph_for_block(&mut self, block: &Block, expansion: ExpnId) {\n         let parent = self.current_module;\n         if self.block_needs_anonymous_module(block) {\n             let module = self.new_module(parent,\n@@ -642,7 +642,7 @@ impl<'a> Resolver<'a> {\n         // but metadata cannot encode gensyms currently, so we create it here.\n         // This is only a guess, two equivalent idents may incorrectly get different gensyms here.\n         let ident = ident.gensym_if_underscore();\n-        let expansion = Mark::root(); // FIXME(jseyfried) intercrate hygiene\n+        let expansion = ExpnId::root(); // FIXME(jseyfried) intercrate hygiene\n         match res {\n             Res::Def(kind @ DefKind::Mod, def_id)\n             | Res::Def(kind @ DefKind::Enum, def_id) => {\n@@ -734,13 +734,14 @@ impl<'a> Resolver<'a> {\n         };\n \n         let kind = ModuleKind::Def(DefKind::Mod, def_id, name.as_symbol());\n-        let module =\n-            self.arenas.alloc_module(ModuleData::new(parent, kind, def_id, Mark::root(), DUMMY_SP));\n+        let module = self.arenas.alloc_module(ModuleData::new(\n+            parent, kind, def_id, ExpnId::root(), DUMMY_SP\n+        ));\n         self.extern_module_map.insert((def_id, macros_only), module);\n         module\n     }\n \n-    pub fn macro_def_scope(&mut self, expansion: Mark) -> Module<'a> {\n+    pub fn macro_def_scope(&mut self, expansion: ExpnId) -> Module<'a> {\n         let def_id = match self.macro_defs.get(&expansion) {\n             Some(def_id) => *def_id,\n             None => return self.graph_root,\n@@ -858,7 +859,7 @@ impl<'a> Resolver<'a> {\n             used: Cell::new(false),\n         });\n \n-        let allow_shadowing = parent_scope.expansion == Mark::root();\n+        let allow_shadowing = parent_scope.expansion == ExpnId::root();\n         if let Some(span) = import_all {\n             let directive = macro_use_directive(span);\n             self.potentially_unused_imports.push(directive);\n@@ -918,7 +919,7 @@ impl<'a> Resolver<'a> {\n pub struct BuildReducedGraphVisitor<'a, 'b> {\n     pub resolver: &'a mut Resolver<'b>,\n     pub current_legacy_scope: LegacyScope<'b>,\n-    pub expansion: Mark,\n+    pub expansion: ExpnId,\n }\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {"}, {"sha": "d088197b45d17eba7bbfbc43a13c7bb22bd0dcfb", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -39,7 +39,7 @@ use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n \n use syntax::source_map::SourceMap;\n-use syntax::ext::hygiene::{Mark, Transparency, SyntaxContext};\n+use syntax::ext::hygiene::{ExpnId, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::MacroKind;\n@@ -141,7 +141,7 @@ enum ScopeSet {\n #[derive(Clone, Debug)]\n pub struct ParentScope<'a> {\n     module: Module<'a>,\n-    expansion: Mark,\n+    expansion: ExpnId,\n     legacy: LegacyScope<'a>,\n     derives: Vec<ast::Path>,\n }\n@@ -1178,7 +1178,7 @@ pub struct ModuleData<'a> {\n     builtin_attrs: RefCell<Vec<(Ident, ParentScope<'a>)>>,\n \n     // Macro invocations that can expand into items in this module.\n-    unresolved_invocations: RefCell<FxHashSet<Mark>>,\n+    unresolved_invocations: RefCell<FxHashSet<ExpnId>>,\n \n     no_implicit_prelude: bool,\n \n@@ -1196,7 +1196,7 @@ pub struct ModuleData<'a> {\n     /// Span of the module itself. Used for error reporting.\n     span: Span,\n \n-    expansion: Mark,\n+    expansion: ExpnId,\n }\n \n type Module<'a> = &'a ModuleData<'a>;\n@@ -1205,7 +1205,7 @@ impl<'a> ModuleData<'a> {\n     fn new(parent: Option<Module<'a>>,\n            kind: ModuleKind,\n            normal_ancestor_id: DefId,\n-           expansion: Mark,\n+           expansion: ExpnId,\n            span: Span) -> Self {\n         ModuleData {\n             parent,\n@@ -1304,7 +1304,7 @@ impl<'a> fmt::Debug for ModuleData<'a> {\n pub struct NameBinding<'a> {\n     kind: NameBindingKind<'a>,\n     ambiguity: Option<(&'a NameBinding<'a>, AmbiguityKind)>,\n-    expansion: Mark,\n+    expansion: ExpnId,\n     span: Span,\n     vis: ty::Visibility,\n }\n@@ -1513,7 +1513,7 @@ impl<'a> NameBinding<'a> {\n     // in some later round and screw up our previously found resolution.\n     // See more detailed explanation in\n     // https://github.com/rust-lang/rust/pull/53778#issuecomment-419224049\n-    fn may_appear_after(&self, invoc_parent_expansion: Mark, binding: &NameBinding<'_>) -> bool {\n+    fn may_appear_after(&self, invoc_parent_expansion: ExpnId, binding: &NameBinding<'_>) -> bool {\n         // self > max(invoc, binding) => !(self <= invoc || self <= binding)\n         // Expansions are partially ordered, so \"may appear after\" is an inversion of\n         // \"certainly appears before or simultaneously\" and includes unordered cases.\n@@ -1686,13 +1686,13 @@ pub struct Resolver<'a> {\n     dummy_ext_bang: Lrc<SyntaxExtension>,\n     dummy_ext_derive: Lrc<SyntaxExtension>,\n     non_macro_attrs: [Lrc<SyntaxExtension>; 2],\n-    macro_defs: FxHashMap<Mark, DefId>,\n+    macro_defs: FxHashMap<ExpnId, DefId>,\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n     unused_macros: NodeMap<Span>,\n     proc_macro_stubs: NodeSet,\n \n-    /// Maps the `Mark` of an expansion to its containing module or block.\n-    invocations: FxHashMap<Mark, &'a InvocationData<'a>>,\n+    /// Maps the `ExpnId` of an expansion to its containing module or block.\n+    invocations: FxHashMap<ExpnId, &'a InvocationData<'a>>,\n \n     /// Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Name, Span>,\n@@ -1918,7 +1918,7 @@ impl<'a> Resolver<'a> {\n         );\n         let graph_root = arenas.alloc_module(ModuleData {\n             no_implicit_prelude: attr::contains_name(&krate.attrs, sym::no_implicit_prelude),\n-            ..ModuleData::new(None, root_module_kind, root_def_id, Mark::root(), krate.span)\n+            ..ModuleData::new(None, root_module_kind, root_def_id, ExpnId::root(), krate.span)\n         });\n         let mut module_map = FxHashMap::default();\n         module_map.insert(DefId::local(CRATE_DEF_INDEX), graph_root);\n@@ -1941,11 +1941,11 @@ impl<'a> Resolver<'a> {\n         }\n \n         let mut invocations = FxHashMap::default();\n-        invocations.insert(Mark::root(),\n+        invocations.insert(ExpnId::root(),\n                            arenas.alloc_invocation_data(InvocationData::root(graph_root)));\n \n         let mut macro_defs = FxHashMap::default();\n-        macro_defs.insert(Mark::root(), root_def_id);\n+        macro_defs.insert(ExpnId::root(), root_def_id);\n \n         let features = session.features_untracked();\n         let non_macro_attr =\n@@ -2014,7 +2014,7 @@ impl<'a> Resolver<'a> {\n             dummy_binding: arenas.alloc_name_binding(NameBinding {\n                 kind: NameBindingKind::Res(Res::Err, false),\n                 ambiguity: None,\n-                expansion: Mark::root(),\n+                expansion: ExpnId::root(),\n                 span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n             }),\n@@ -2095,7 +2095,7 @@ impl<'a> Resolver<'a> {\n         parent: Module<'a>,\n         kind: ModuleKind,\n         normal_ancestor_id: DefId,\n-        expansion: Mark,\n+        expansion: ExpnId,\n         span: Span,\n     ) -> Module<'a> {\n         let module = ModuleData::new(Some(parent), kind, normal_ancestor_id, expansion, span);\n@@ -2243,7 +2243,7 @@ impl<'a> Resolver<'a> {\n                 }\n                 Scope::CrateRoot => match ns {\n                     TypeNS => {\n-                        ident.span.adjust(Mark::root());\n+                        ident.span.adjust(ExpnId::root());\n                         Scope::ExternPrelude\n                     }\n                     ValueNS | MacroNS => break,\n@@ -2253,7 +2253,7 @@ impl<'a> Resolver<'a> {\n                     match self.hygienic_lexical_parent(module, &mut ident.span) {\n                         Some(parent_module) => Scope::Module(parent_module),\n                         None => {\n-                            ident.span.adjust(Mark::root());\n+                            ident.span.adjust(ExpnId::root());\n                             match ns {\n                                 TypeNS => Scope::ExternPrelude,\n                                 ValueNS => Scope::StdLibPrelude,\n@@ -2399,15 +2399,15 @@ impl<'a> Resolver<'a> {\n         }\n \n         if !module.no_implicit_prelude {\n-            ident.span.adjust(Mark::root());\n+            ident.span.adjust(ExpnId::root());\n             if ns == TypeNS {\n                 if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n                     return Some(LexicalScopeBinding::Item(binding));\n                 }\n             }\n             if ns == TypeNS && KNOWN_TOOLS.contains(&ident.name) {\n                 let binding = (Res::ToolMod, ty::Visibility::Public,\n-                               DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n+                               DUMMY_SP, ExpnId::root()).to_name_binding(self.arenas);\n                 return Some(LexicalScopeBinding::Item(binding));\n             }\n             if let Some(prelude) = self.prelude {\n@@ -2506,7 +2506,7 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             ModuleOrUniformRoot::ExternPrelude => {\n-                ident.span.modernize_and_adjust(Mark::root());\n+                ident.span.modernize_and_adjust(ExpnId::root());\n             }\n             ModuleOrUniformRoot::CrateRootAndExternPrelude |\n             ModuleOrUniformRoot::CurrentScope => {\n@@ -2552,7 +2552,7 @@ impl<'a> Resolver<'a> {\n             result\n         } else {\n             ctxt = ctxt.modern();\n-            ctxt.adjust(Mark::root())\n+            ctxt.adjust(ExpnId::root())\n         };\n         let module = match mark {\n             Some(def) => self.macro_def_scope(def),\n@@ -5063,7 +5063,7 @@ impl<'a> Resolver<'a> {\n                 };\n                 let crate_root = self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                 self.populate_module_if_necessary(&crate_root);\n-                Some((crate_root, ty::Visibility::Public, DUMMY_SP, Mark::root())\n+                Some((crate_root, ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n                     .to_name_binding(self.arenas))\n             }\n         })"}, {"sha": "6fa97df5e17da121cd70f99a76979b90085cb4c4", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -16,7 +16,7 @@ use syntax::attr::{self, StabilityLevel};\n use syntax::ext::base::{self, Indeterminate};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{self, Mark, ExpnInfo, ExpnKind};\n+use syntax::ext::hygiene::{self, ExpnId, ExpnInfo, ExpnKind};\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{emit_feature_err, is_builtin_attr_name};\n use syntax::feature_gate::GateIssue;\n@@ -135,8 +135,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.session.next_node_id()\n     }\n \n-    fn get_module_scope(&mut self, id: ast::NodeId) -> Mark {\n-        let span = DUMMY_SP.fresh_expansion(Mark::root(), ExpnInfo::default(\n+    fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId {\n+        let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::default(\n             ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, self.session.edition()\n         ));\n         let mark = span.ctxt().outer();\n@@ -160,8 +160,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n         });\n     }\n \n-    fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n-                                            derives: &[Mark]) {\n+    fn visit_ast_fragment_with_placeholders(&mut self, mark: ExpnId, fragment: &AstFragment,\n+                                            derives: &[ExpnId]) {\n         fragment.visit_with(&mut DefCollector::new(&mut self.definitions, mark));\n \n         let invocation = self.invocations[&mark];\n@@ -194,7 +194,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             ambiguity: None,\n             span: DUMMY_SP,\n             vis: ty::Visibility::Public,\n-            expansion: Mark::root(),\n+            expansion: ExpnId::root(),\n         });\n         if self.builtin_macros.insert(ident.name, binding).is_some() {\n             self.session.span_err(ident.span,\n@@ -206,7 +206,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         ImportResolver { resolver: self }.resolve_imports()\n     }\n \n-    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n+    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: ExpnId, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate> {\n         let (path, kind, derives_in_scope, after_derive) = match invoc.kind {\n             InvocationKind::Attr { ref attr, ref derives, after_derive, .. } =>\n@@ -250,10 +250,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n impl<'a> Resolver<'a> {\n     pub fn dummy_parent_scope(&self) -> ParentScope<'a> {\n-        self.invoc_parent_scope(Mark::root(), Vec::new())\n+        self.invoc_parent_scope(ExpnId::root(), Vec::new())\n     }\n \n-    fn invoc_parent_scope(&self, invoc_id: Mark, derives: Vec<ast::Path>) -> ParentScope<'a> {\n+    fn invoc_parent_scope(&self, invoc_id: ExpnId, derives: Vec<ast::Path>) -> ParentScope<'a> {\n         let invoc = self.invocations[&invoc_id];\n         ParentScope {\n             module: invoc.module.nearest_item_scope(),\n@@ -460,7 +460,7 @@ impl<'a> Resolver<'a> {\n                                                       &parent_scope, true, force) {\n                             Ok((Some(ext), _)) => if ext.helper_attrs.contains(&ident.name) {\n                                 let binding = (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                               ty::Visibility::Public, derive.span, Mark::root())\n+                                               ty::Visibility::Public, derive.span, ExpnId::root())\n                                                .to_name_binding(this.arenas);\n                                 result = Ok((binding, Flags::empty()));\n                                 break;\n@@ -541,7 +541,7 @@ impl<'a> Resolver<'a> {\n                 }\n                 Scope::BuiltinAttrs => if is_builtin_attr_name(ident.name) {\n                     let binding = (Res::NonMacroAttr(NonMacroAttrKind::Builtin),\n-                                   ty::Visibility::Public, DUMMY_SP, Mark::root())\n+                                   ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n                                    .to_name_binding(this.arenas);\n                     Ok((binding, Flags::PRELUDE))\n                 } else {\n@@ -550,7 +550,7 @@ impl<'a> Resolver<'a> {\n                 Scope::LegacyPluginHelpers => if this.session.plugin_attributes.borrow().iter()\n                                                      .any(|(name, _)| ident.name == *name) {\n                     let binding = (Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n-                                   ty::Visibility::Public, DUMMY_SP, Mark::root())\n+                                   ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n                                    .to_name_binding(this.arenas);\n                     Ok((binding, Flags::PRELUDE))\n                 } else {\n@@ -563,7 +563,7 @@ impl<'a> Resolver<'a> {\n                     )),\n                 }\n                 Scope::ToolPrelude => if KNOWN_TOOLS.contains(&ident.name) {\n-                    let binding = (Res::ToolMod, ty::Visibility::Public, DUMMY_SP, Mark::root())\n+                    let binding = (Res::ToolMod, ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n                                    .to_name_binding(this.arenas);\n                     Ok((binding, Flags::PRELUDE))\n                 } else {\n@@ -588,7 +588,7 @@ impl<'a> Resolver<'a> {\n                                                  .get(&ident.name).cloned() {\n                     Some(prim_ty) => {\n                         let binding = (Res::PrimTy(prim_ty), ty::Visibility::Public,\n-                                       DUMMY_SP, Mark::root()).to_name_binding(this.arenas);\n+                                       DUMMY_SP, ExpnId::root()).to_name_binding(this.arenas);\n                         Ok((binding, Flags::PRELUDE))\n                     }\n                     None => Err(Determinacy::Determined)\n@@ -688,7 +688,7 @@ impl<'a> Resolver<'a> {\n             // the last segment, so we are certainly working with a single-segment attribute here.)\n             assert!(ns == MacroNS);\n             let binding = (Res::NonMacroAttr(NonMacroAttrKind::Custom),\n-                           ty::Visibility::Public, orig_ident.span, Mark::root())\n+                           ty::Visibility::Public, orig_ident.span, ExpnId::root())\n                            .to_name_binding(self.arenas);\n             Ok(binding)\n         } else {\n@@ -846,7 +846,7 @@ impl<'a> Resolver<'a> {\n \n     pub fn define_macro(&mut self,\n                         item: &ast::Item,\n-                        expansion: Mark,\n+                        expansion: ExpnId,\n                         current_legacy_scope: &mut LegacyScope<'a>) {\n         let (ext, ident, span, is_legacy) = match &item.node {\n             ItemKind::MacroDef(def) => {"}, {"sha": "1960c06e86e4c7487f75543631da94ad4584b741", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -28,7 +28,7 @@ use rustc::util::nodemap::FxHashSet;\n use rustc::{bug, span_bug};\n \n use syntax::ast::{self, Ident, Name, NodeId, CRATE_NODE_ID};\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax::symbol::kw;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::{struct_span_err, unwrap_or};\n@@ -221,7 +221,7 @@ impl<'a> Resolver<'a> {\n                         ident.name == kw::DollarCrate {\n                         let module = self.resolve_crate_root(ident);\n                         let binding = (module, ty::Visibility::Public,\n-                                        module.span, Mark::root())\n+                                        module.span, ExpnId::root())\n                                         .to_name_binding(self.arenas);\n                         return Ok(binding);\n                     } else if ident.name == kw::Super ||\n@@ -246,7 +246,7 @@ impl<'a> Resolver<'a> {\n             .map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n \n         if let Some(binding) = resolution.binding {\n-            if !restricted_shadowing && binding.expansion != Mark::root() {\n+            if !restricted_shadowing && binding.expansion != ExpnId::root() {\n                 if let NameBindingKind::Res(_, true) = binding.kind {\n                     self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n                 }\n@@ -286,7 +286,7 @@ impl<'a> Resolver<'a> {\n                     if let Some(shadowed_glob) = resolution.shadowed_glob {\n                         // Forbid expanded shadowing to avoid time travel.\n                         if restricted_shadowing &&\n-                        binding.expansion != Mark::root() &&\n+                        binding.expansion != ExpnId::root() &&\n                         binding.res() != shadowed_glob.res() {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 kind: AmbiguityKind::GlobVsExpanded,\n@@ -525,7 +525,7 @@ impl<'a> Resolver<'a> {\n                             (binding, old_binding)\n                         };\n                         if glob_binding.res() != nonglob_binding.res() &&\n-                           ns == MacroNS && nonglob_binding.expansion != Mark::root() {\n+                           ns == MacroNS && nonglob_binding.expansion != ExpnId::root() {\n                             resolution.binding = Some(this.ambiguity(AmbiguityKind::GlobVsExpanded,\n                                                                     nonglob_binding, glob_binding));\n                         } else {\n@@ -1248,7 +1248,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         target: Ident,\n     ) {\n         // Skip if the import was produced by a macro.\n-        if directive.parent_scope.expansion != Mark::root() {\n+        if directive.parent_scope.expansion != ExpnId::root() {\n             return;\n         }\n "}, {"sha": "eb67fb94b7d614739253cfe6558ec6285c37b57b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -5,7 +5,7 @@ pub use UnsafeSource::*;\n pub use crate::symbol::{Ident, Symbol as Name};\n pub use crate::util::parser::ExprPrecedence;\n \n-use crate::ext::hygiene::{Mark, SyntaxContext};\n+use crate::ext::hygiene::{ExpnId, SyntaxContext};\n use crate::parse::token::{self, DelimToken};\n use crate::print::pprust;\n use crate::ptr::P;\n@@ -251,12 +251,12 @@ mod node_id_inner {\n pub use node_id_inner::NodeId;\n \n impl NodeId {\n-    pub fn placeholder_from_mark(mark: Mark) -> Self {\n+    pub fn placeholder_from_mark(mark: ExpnId) -> Self {\n         NodeId::from_u32(mark.as_u32())\n     }\n \n-    pub fn placeholder_to_mark(self) -> Mark {\n-        Mark::from_u32(self.as_u32())\n+    pub fn placeholder_to_mark(self) -> ExpnId {\n+        ExpnId::from_u32(self.as_u32())\n     }\n }\n "}, {"sha": "00b614d1584eef7273ac482dd8780d9e9b871501", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -3,7 +3,7 @@ use crate::attr::{HasAttrs, Stability, Deprecation};\n use crate::source_map::{SourceMap, Spanned, respan};\n use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n-use crate::ext::hygiene::{Mark, SyntaxContext, Transparency};\n+use crate::ext::hygiene::{ExpnId, SyntaxContext, Transparency};\n use crate::mut_visit::{self, MutVisitor};\n use crate::parse::{self, parser, DirectoryOwnership};\n use crate::parse::token;\n@@ -682,16 +682,16 @@ pub struct Indeterminate;\n pub trait Resolver {\n     fn next_node_id(&mut self) -> ast::NodeId;\n \n-    fn get_module_scope(&mut self, id: ast::NodeId) -> Mark;\n+    fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId;\n \n     fn resolve_dollar_crates(&mut self);\n-    fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n-                                            derives: &[Mark]);\n+    fn visit_ast_fragment_with_placeholders(&mut self, mark: ExpnId, fragment: &AstFragment,\n+                                            derives: &[ExpnId]);\n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>);\n \n     fn resolve_imports(&mut self);\n \n-    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n+    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: ExpnId, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate>;\n \n     fn check_unused_macros(&self);\n@@ -705,7 +705,7 @@ pub struct ModuleData {\n \n #[derive(Clone)]\n pub struct ExpansionData {\n-    pub mark: Mark,\n+    pub mark: ExpnId,\n     pub depth: usize,\n     pub module: Rc<ModuleData>,\n     pub directory_ownership: DirectoryOwnership,\n@@ -735,7 +735,7 @@ impl<'a> ExtCtxt<'a> {\n             root_path: PathBuf::new(),\n             resolver,\n             current_expansion: ExpansionData {\n-                mark: Mark::root(),\n+                mark: ExpnId::root(),\n                 depth: 0,\n                 module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n                 directory_ownership: DirectoryOwnership::Owned { relative: None },"}, {"sha": "8eb26ae8d33080abf529e7c9d85feb470f247318", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -5,7 +5,7 @@ use crate::source_map::{dummy_spanned, respan};\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n use crate::ext::derive::{add_derived_markers, collect_derives};\n-use crate::ext::hygiene::{Mark, SyntaxContext, ExpnInfo, ExpnKind};\n+use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnInfo, ExpnKind};\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n use crate::feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};\n use crate::mut_visit::*;\n@@ -304,7 +304,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         // Unresolved macros produce dummy outputs as a recovery measure.\n         invocations.reverse();\n         let mut expanded_fragments = Vec::new();\n-        let mut derives: FxHashMap<Mark, Vec<_>> = FxHashMap::default();\n+        let mut derives: FxHashMap<ExpnId, Vec<_>> = FxHashMap::default();\n         let mut undetermined_invocations = Vec::new();\n         let (mut progress, mut force) = (false, !self.monotonic);\n         loop {\n@@ -367,7 +367,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 derives.reserve(traits.len());\n                 invocations.reserve(traits.len());\n                 for path in traits {\n-                    let mark = Mark::fresh(self.cx.current_expansion.mark, None);\n+                    let mark = ExpnId::fresh(self.cx.current_expansion.mark, None);\n                     derives.push(mark);\n                     invocations.push(Invocation {\n                         kind: InvocationKind::Derive {\n@@ -423,7 +423,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     /// them with \"placeholders\" - dummy macro invocations with specially crafted `NodeId`s.\n     /// Then call into resolver that builds a skeleton (\"reduced graph\") of the fragment and\n     /// prepares data for resolving paths of macro invocations.\n-    fn collect_invocations(&mut self, mut fragment: AstFragment, derives: &[Mark])\n+    fn collect_invocations(&mut self, mut fragment: AstFragment, derives: &[ExpnId])\n                            -> (AstFragment, Vec<Invocation>) {\n         // Resolve `$crate`s in the fragment for pretty-printing.\n         self.cx.resolver.resolve_dollar_crates();\n@@ -822,7 +822,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             )),\n             _ => None,\n         };\n-        let mark = Mark::fresh(self.cx.current_expansion.mark, expn_info);\n+        let mark = ExpnId::fresh(self.cx.current_expansion.mark, expn_info);\n         self.invocations.push(Invocation {\n             kind,\n             fragment_kind,\n@@ -1402,7 +1402,7 @@ impl<'feat> ExpansionConfig<'feat> {\n \n // A Marker adds the given mark to the syntax context.\n #[derive(Debug)]\n-pub struct Marker(pub Mark);\n+pub struct Marker(pub ExpnId);\n \n impl MutVisitor for Marker {\n     fn visit_span(&mut self, span: &mut Span) {"}, {"sha": "872292bb600f8a58085d57869c2957fe11d2ef0b", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -2,7 +2,7 @@ use crate::ast::{self, NodeId};\n use crate::source_map::{DUMMY_SP, dummy_spanned};\n use crate::ext::base::ExtCtxt;\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n-use crate::ext::hygiene::Mark;\n+use crate::ext::hygiene::ExpnId;\n use crate::tokenstream::TokenStream;\n use crate::mut_visit::*;\n use crate::ptr::P;\n@@ -84,7 +84,7 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n         }\n     }\n \n-    pub fn add(&mut self, id: ast::NodeId, mut fragment: AstFragment, derives: Vec<Mark>) {\n+    pub fn add(&mut self, id: ast::NodeId, mut fragment: AstFragment, derives: Vec<ExpnId>) {\n         fragment.mut_visit_with(self);\n         if let AstFragment::Items(mut items) = fragment {\n             for derive in derives {"}, {"sha": "3fba81c0b691149f6d4a2726804236069e97b041", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -1,7 +1,7 @@\n use crate::ast;\n use crate::attr;\n use crate::edition::Edition;\n-use crate::ext::hygiene::{Mark, MacroKind};\n+use crate::ext::hygiene::{ExpnId, MacroKind};\n use crate::symbol::{Ident, Symbol, kw, sym};\n use crate::source_map::{ExpnInfo, ExpnKind, dummy_spanned, respan};\n use crate::ptr::P;\n@@ -75,7 +75,7 @@ pub fn maybe_inject_crates_ref(\n \n     INJECTED_CRATE_NAME.with(|opt_name| opt_name.set(Some(name)));\n \n-    let span = DUMMY_SP.fresh_expansion(Mark::root(), ExpnInfo::allow_unstable(\n+    let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::std_inject), DUMMY_SP, edition,\n         [sym::prelude_import][..].into(),\n     ));"}, {"sha": "72d62dbd46b2b1a36fc33e28f59bebd22e74a5dc", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -21,7 +21,7 @@ use crate::entry::{self, EntryPointType};\n use crate::ext::base::{ExtCtxt, Resolver};\n use crate::ext::build::AstBuilder;\n use crate::ext::expand::ExpansionConfig;\n-use crate::ext::hygiene::{self, Mark, SyntaxContext, MacroKind};\n+use crate::ext::hygiene::{self, ExpnId, SyntaxContext, MacroKind};\n use crate::mut_visit::{*, ExpectOne};\n use crate::feature_gate::Features;\n use crate::util::map_in_place::MapInPlace;\n@@ -303,7 +303,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     //            #![main]\n     //            test::test_main_static(&[..tests]);\n     //        }\n-    let sp = DUMMY_SP.fresh_expansion(Mark::root(), ExpnInfo::allow_unstable(\n+    let sp = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, cx.ext_cx.parse_sess.edition,\n         [sym::main, sym::test, sym::rustc_attrs][..].into(),\n     ));"}, {"sha": "1f05be3a51962e3d89faef66472d9b6d51636be6", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -19,7 +19,7 @@ use crate::parse::Directory;\n use crate::parse::token::{self, DelimToken, Token, TokenKind};\n use crate::print::pprust;\n \n-use syntax_pos::{BytePos, Mark, Span, DUMMY_SP};\n+use syntax_pos::{BytePos, ExpnId, Span, DUMMY_SP};\n #[cfg(target_arch = \"x86_64\")]\n use rustc_data_structures::static_assert_size;\n use rustc_data_structures::sync::Lrc;\n@@ -545,7 +545,7 @@ impl DelimSpan {\n         self.open.with_hi(self.close.hi())\n     }\n \n-    pub fn apply_mark(self, mark: Mark) -> Self {\n+    pub fn apply_mark(self, mark: ExpnId) -> Self {\n         DelimSpan {\n             open: self.open.apply_mark(mark),\n             close: self.close.apply_mark(mark),"}, {"sha": "08c40dde56c858283a5250054474ff9228927f00", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -8,7 +8,7 @@ use syntax::source_map::{ExpnInfo, ExpnKind, respan};\n use syntax::ext::base::{ExtCtxt, MacroKind};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::ExpnId;\n use syntax::mut_visit::MutVisitor;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n@@ -346,7 +346,7 @@ fn mk_decls(\n     custom_attrs: &[ProcMacroDef],\n     custom_macros: &[ProcMacroDef],\n ) -> P<ast::Item> {\n-    let span = DUMMY_SP.fresh_expansion(Mark::root(), ExpnInfo::allow_unstable(\n+    let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::proc_macro), DUMMY_SP, cx.parse_sess.edition,\n         [sym::rustc_attrs, sym::proc_macro_internals][..].into(),\n     ));"}, {"sha": "731a2d1c12144b156d39511745117b240b0add70", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -11,14 +11,14 @@\n // ensuring that multiple HygieneData accesses are combined into a single\n // `HygieneData::with`.\n //\n-// This explains why `HygieneData`, `SyntaxContext` and `Mark` have interfaces\n+// This explains why `HygieneData`, `SyntaxContext` and `ExpnId` have interfaces\n // with a certain amount of redundancy in them. For example,\n // `SyntaxContext::outer_expn_info` combines `SyntaxContext::outer` and\n-// `Mark::expn_info` so that two `HygieneData` accesses can be performed within\n+// `ExpnId::expn_info` so that two `HygieneData` accesses can be performed within\n // a single `HygieneData::with` call.\n //\n // It also explains why many functions appear in `HygieneData` and again in\n-// `SyntaxContext` or `Mark`. For example, `HygieneData::outer` and\n+// `SyntaxContext` or `ExpnId`. For example, `HygieneData::outer` and\n // `SyntaxContext::outer` do the same thing, but the former is for use within a\n // `HygieneData::with` call while the latter is for use outside such a call.\n // When modifying this file it is important to understand this distinction,\n@@ -41,7 +41,7 @@ pub struct SyntaxContext(u32);\n \n #[derive(Debug)]\n struct SyntaxContextData {\n-    outer_mark: Mark,\n+    outer_mark: ExpnId,\n     transparency: Transparency,\n     prev_ctxt: SyntaxContext,\n     /// This context, but with all transparent and semi-transparent marks filtered away.\n@@ -54,11 +54,11 @@ struct SyntaxContextData {\n \n /// A mark is a unique ID associated with a macro expansion.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub struct Mark(u32);\n+pub struct ExpnId(u32);\n \n #[derive(Debug)]\n struct MarkData {\n-    parent: Mark,\n+    parent: ExpnId,\n     /// Each mark should have an associated expansion info, but sometimes there's a delay between\n     /// creation of a mark and obtaining its info (e.g. macros are collected first and then\n     /// resolved later), so we use an `Option` here.\n@@ -84,15 +84,15 @@ pub enum Transparency {\n     Opaque,\n }\n \n-impl Mark {\n-    pub fn fresh(parent: Mark, expn_info: Option<ExpnInfo>) -> Self {\n+impl ExpnId {\n+    pub fn fresh(parent: ExpnId, expn_info: Option<ExpnInfo>) -> Self {\n         HygieneData::with(|data| data.fresh_mark(parent, expn_info))\n     }\n \n     /// The mark of the theoretical expansion that generates freshly parsed, unexpanded AST.\n     #[inline]\n     pub fn root() -> Self {\n-        Mark(0)\n+        ExpnId(0)\n     }\n \n     #[inline]\n@@ -101,12 +101,12 @@ impl Mark {\n     }\n \n     #[inline]\n-    pub fn from_u32(raw: u32) -> Mark {\n-        Mark(raw)\n+    pub fn from_u32(raw: u32) -> ExpnId {\n+        ExpnId(raw)\n     }\n \n     #[inline]\n-    pub fn parent(self) -> Mark {\n+    pub fn parent(self) -> ExpnId {\n         HygieneData::with(|data| data.marks[self.0 as usize].parent)\n     }\n \n@@ -124,7 +124,7 @@ impl Mark {\n         })\n     }\n \n-    pub fn is_descendant_of(self, ancestor: Mark) -> bool {\n+    pub fn is_descendant_of(self, ancestor: ExpnId) -> bool {\n         HygieneData::with(|data| data.is_descendant_of(self, ancestor))\n     }\n \n@@ -154,18 +154,18 @@ impl Mark {\n crate struct HygieneData {\n     marks: Vec<MarkData>,\n     syntax_contexts: Vec<SyntaxContextData>,\n-    markings: FxHashMap<(SyntaxContext, Mark, Transparency), SyntaxContext>,\n+    markings: FxHashMap<(SyntaxContext, ExpnId, Transparency), SyntaxContext>,\n }\n \n impl HygieneData {\n     crate fn new(edition: Edition) -> Self {\n         HygieneData {\n             marks: vec![MarkData {\n-                parent: Mark::root(),\n+                parent: ExpnId::root(),\n                 expn_info: Some(ExpnInfo::default(ExpnKind::Root, DUMMY_SP, edition)),\n             }],\n             syntax_contexts: vec![SyntaxContextData {\n-                outer_mark: Mark::root(),\n+                outer_mark: ExpnId::root(),\n                 transparency: Transparency::Opaque,\n                 prev_ctxt: SyntaxContext(0),\n                 opaque: SyntaxContext(0),\n@@ -180,13 +180,13 @@ impl HygieneData {\n         GLOBALS.with(|globals| f(&mut *globals.hygiene_data.borrow_mut()))\n     }\n \n-    fn fresh_mark(&mut self, parent: Mark, expn_info: Option<ExpnInfo>) -> Mark {\n+    fn fresh_mark(&mut self, parent: ExpnId, expn_info: Option<ExpnInfo>) -> ExpnId {\n         self.marks.push(MarkData { parent, expn_info });\n-        Mark(self.marks.len() as u32 - 1)\n+        ExpnId(self.marks.len() as u32 - 1)\n     }\n \n-    fn expn_info(&self, mark: Mark) -> Option<&ExpnInfo> {\n-        if mark != Mark::root() {\n+    fn expn_info(&self, mark: ExpnId) -> Option<&ExpnInfo> {\n+        if mark != ExpnId::root() {\n             Some(self.marks[mark.0 as usize].expn_info.as_ref()\n                      .expect(\"no expansion info for a mark\"))\n         } else {\n@@ -197,17 +197,17 @@ impl HygieneData {\n         }\n     }\n \n-    fn is_descendant_of(&self, mut mark: Mark, ancestor: Mark) -> bool {\n+    fn is_descendant_of(&self, mut mark: ExpnId, ancestor: ExpnId) -> bool {\n         while mark != ancestor {\n-            if mark == Mark::root() {\n+            if mark == ExpnId::root() {\n                 return false;\n             }\n             mark = self.marks[mark.0 as usize].parent;\n         }\n         true\n     }\n \n-    fn default_transparency(&self, mark: Mark) -> Transparency {\n+    fn default_transparency(&self, mark: ExpnId) -> Transparency {\n         self.expn_info(mark).map_or(\n             Transparency::SemiTransparent, |einfo| einfo.default_transparency\n         )\n@@ -221,7 +221,7 @@ impl HygieneData {\n         self.syntax_contexts[ctxt.0 as usize].opaque_and_semitransparent\n     }\n \n-    fn outer(&self, ctxt: SyntaxContext) -> Mark {\n+    fn outer(&self, ctxt: SyntaxContext) -> ExpnId {\n         self.syntax_contexts[ctxt.0 as usize].outer_mark\n     }\n \n@@ -233,13 +233,13 @@ impl HygieneData {\n         self.syntax_contexts[ctxt.0 as usize].prev_ctxt\n     }\n \n-    fn remove_mark(&self, ctxt: &mut SyntaxContext) -> Mark {\n+    fn remove_mark(&self, ctxt: &mut SyntaxContext) -> ExpnId {\n         let outer_mark = self.syntax_contexts[ctxt.0 as usize].outer_mark;\n         *ctxt = self.prev_ctxt(*ctxt);\n         outer_mark\n     }\n \n-    fn marks(&self, mut ctxt: SyntaxContext) -> Vec<(Mark, Transparency)> {\n+    fn marks(&self, mut ctxt: SyntaxContext) -> Vec<(ExpnId, Transparency)> {\n         let mut marks = Vec::new();\n         while ctxt != SyntaxContext::empty() {\n             let outer_mark = self.outer(ctxt);\n@@ -263,22 +263,22 @@ impl HygieneData {\n         span\n     }\n \n-    fn adjust(&self, ctxt: &mut SyntaxContext, expansion: Mark) -> Option<Mark> {\n+    fn adjust(&self, ctxt: &mut SyntaxContext, expansion: ExpnId) -> Option<ExpnId> {\n         let mut scope = None;\n         while !self.is_descendant_of(expansion, self.outer(*ctxt)) {\n             scope = Some(self.remove_mark(ctxt));\n         }\n         scope\n     }\n \n-    fn apply_mark(&mut self, ctxt: SyntaxContext, mark: Mark) -> SyntaxContext {\n-        assert_ne!(mark, Mark::root());\n+    fn apply_mark(&mut self, ctxt: SyntaxContext, mark: ExpnId) -> SyntaxContext {\n+        assert_ne!(mark, ExpnId::root());\n         self.apply_mark_with_transparency(ctxt, mark, self.default_transparency(mark))\n     }\n \n-    fn apply_mark_with_transparency(&mut self, ctxt: SyntaxContext, mark: Mark,\n+    fn apply_mark_with_transparency(&mut self, ctxt: SyntaxContext, mark: ExpnId,\n                                     transparency: Transparency) -> SyntaxContext {\n-        assert_ne!(mark, Mark::root());\n+        assert_ne!(mark, ExpnId::root());\n         if transparency == Transparency::Opaque {\n             return self.apply_mark_internal(ctxt, mark, transparency);\n         }\n@@ -310,7 +310,7 @@ impl HygieneData {\n         self.apply_mark_internal(call_site_ctxt, mark, transparency)\n     }\n \n-    fn apply_mark_internal(&mut self, ctxt: SyntaxContext, mark: Mark, transparency: Transparency)\n+    fn apply_mark_internal(&mut self, ctxt: SyntaxContext, mark: ExpnId, transparency: Transparency)\n                            -> SyntaxContext {\n         let syntax_contexts = &mut self.syntax_contexts;\n         let mut opaque = syntax_contexts[ctxt.0 as usize].opaque;\n@@ -410,12 +410,12 @@ impl SyntaxContext {\n     }\n \n     /// Extend a syntax context with a given mark and default transparency for that mark.\n-    pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n+    pub fn apply_mark(self, mark: ExpnId) -> SyntaxContext {\n         HygieneData::with(|data| data.apply_mark(self, mark))\n     }\n \n     /// Extend a syntax context with a given mark and transparency\n-    pub fn apply_mark_with_transparency(self, mark: Mark, transparency: Transparency)\n+    pub fn apply_mark_with_transparency(self, mark: ExpnId, transparency: Transparency)\n                                         -> SyntaxContext {\n         HygieneData::with(|data| data.apply_mark_with_transparency(self, mark, transparency))\n     }\n@@ -436,11 +436,11 @@ impl SyntaxContext {\n     /// of g (call it g1), calling remove_mark will result in the SyntaxContext for the\n     /// invocation of f that created g1.\n     /// Returns the mark that was removed.\n-    pub fn remove_mark(&mut self) -> Mark {\n+    pub fn remove_mark(&mut self) -> ExpnId {\n         HygieneData::with(|data| data.remove_mark(self))\n     }\n \n-    pub fn marks(self) -> Vec<(Mark, Transparency)> {\n+    pub fn marks(self) -> Vec<(ExpnId, Transparency)> {\n         HygieneData::with(|data| data.marks(self))\n     }\n \n@@ -452,13 +452,13 @@ impl SyntaxContext {\n     /// m!(f);\n     /// macro m($f:ident) {\n     ///     mod bar {\n-    ///         pub fn f() {} // `f`'s `SyntaxContext` has a single `Mark` from `m`.\n+    ///         pub fn f() {} // `f`'s `SyntaxContext` has a single `ExpnId` from `m`.\n     ///         pub fn $f() {} // `$f`'s `SyntaxContext` is empty.\n     ///     }\n-    ///     foo::f(); // `f`'s `SyntaxContext` has a single `Mark` from `m`\n+    ///     foo::f(); // `f`'s `SyntaxContext` has a single `ExpnId` from `m`\n     ///     //^ Since `mod foo` is outside this expansion, `adjust` removes the mark from `f`,\n     ///     //| and it resolves to `::foo::f`.\n-    ///     bar::f(); // `f`'s `SyntaxContext` has a single `Mark` from `m`\n+    ///     bar::f(); // `f`'s `SyntaxContext` has a single `ExpnId` from `m`\n     ///     //^ Since `mod bar` not outside this expansion, `adjust` does not change `f`,\n     ///     //| and it resolves to `::bar::f`.\n     ///     bar::$f(); // `f`'s `SyntaxContext` is empty.\n@@ -468,12 +468,12 @@ impl SyntaxContext {\n     /// ```\n     /// This returns the expansion whose definition scope we use to privacy check the resolution,\n     /// or `None` if we privacy check as usual (i.e., not w.r.t. a macro definition scope).\n-    pub fn adjust(&mut self, expansion: Mark) -> Option<Mark> {\n+    pub fn adjust(&mut self, expansion: ExpnId) -> Option<ExpnId> {\n         HygieneData::with(|data| data.adjust(self, expansion))\n     }\n \n     /// Like `SyntaxContext::adjust`, but also modernizes `self`.\n-    pub fn modernize_and_adjust(&mut self, expansion: Mark) -> Option<Mark> {\n+    pub fn modernize_and_adjust(&mut self, expansion: ExpnId) -> Option<ExpnId> {\n         HygieneData::with(|data| {\n             *self = data.modern(*self);\n             data.adjust(self, expansion)\n@@ -488,7 +488,7 @@ impl SyntaxContext {\n     /// m!(f);\n     /// macro m($i:ident) {\n     ///     mod foo {\n-    ///         pub fn f() {} // `f`'s `SyntaxContext` has a single `Mark` from `m`.\n+    ///         pub fn f() {} // `f`'s `SyntaxContext` has a single `ExpnId` from `m`.\n     ///         pub fn $i() {} // `$i`'s `SyntaxContext` is empty.\n     ///     }\n     ///     n(f);\n@@ -505,7 +505,7 @@ impl SyntaxContext {\n     /// ```\n     /// This returns `None` if the context cannot be glob-adjusted.\n     /// Otherwise, it returns the scope to use when privacy checking (see `adjust` for details).\n-    pub fn glob_adjust(&mut self, expansion: Mark, glob_span: Span) -> Option<Option<Mark>> {\n+    pub fn glob_adjust(&mut self, expansion: ExpnId, glob_span: Span) -> Option<Option<ExpnId>> {\n         HygieneData::with(|data| {\n             let mut scope = None;\n             let mut glob_ctxt = data.modern(glob_span.ctxt());\n@@ -529,8 +529,8 @@ impl SyntaxContext {\n     ///     assert!(self.glob_adjust(expansion, glob_ctxt) == Some(privacy_checking_scope));\n     /// }\n     /// ```\n-    pub fn reverse_glob_adjust(&mut self, expansion: Mark, glob_span: Span)\n-                               -> Option<Option<Mark>> {\n+    pub fn reverse_glob_adjust(&mut self, expansion: ExpnId, glob_span: Span)\n+                               -> Option<Option<ExpnId>> {\n         HygieneData::with(|data| {\n             if data.adjust(self, expansion).is_some() {\n                 return None;\n@@ -550,7 +550,7 @@ impl SyntaxContext {\n         })\n     }\n \n-    pub fn hygienic_eq(self, other: SyntaxContext, mark: Mark) -> bool {\n+    pub fn hygienic_eq(self, other: SyntaxContext, mark: ExpnId) -> bool {\n         HygieneData::with(|data| {\n             let mut self_modern = data.modern(self);\n             data.adjust(&mut self_modern, mark);\n@@ -569,7 +569,7 @@ impl SyntaxContext {\n     }\n \n     #[inline]\n-    pub fn outer(self) -> Mark {\n+    pub fn outer(self) -> ExpnId {\n         HygieneData::with(|data| data.outer(self))\n     }\n \n@@ -583,7 +583,7 @@ impl SyntaxContext {\n     /// `ctxt.outer_and_expn_info()` is equivalent to but faster than\n     /// `{ let outer = ctxt.outer(); (outer, outer.expn_info()) }`.\n     #[inline]\n-    pub fn outer_and_expn_info(self) -> (Mark, Option<ExpnInfo>) {\n+    pub fn outer_and_expn_info(self) -> (ExpnId, Option<ExpnInfo>) {\n         HygieneData::with(|data| {\n             let outer = data.outer(self);\n             (outer, data.expn_info(outer).cloned())\n@@ -607,7 +607,7 @@ impl Span {\n     /// other compiler-generated code to set per-span properties like allowed unstable features.\n     /// The returned span belongs to the created expansion and has the new properties,\n     /// but its location is inherited from the current span.\n-    pub fn fresh_expansion(self, parent: Mark, expn_info: ExpnInfo) -> Span {\n+    pub fn fresh_expansion(self, parent: ExpnId, expn_info: ExpnInfo) -> Span {\n         HygieneData::with(|data| {\n             let mark = data.fresh_mark(parent, Some(expn_info));\n             self.with_ctxt(data.apply_mark(SyntaxContext::empty(), mark))\n@@ -681,7 +681,7 @@ impl ExpnInfo {\n /// Expansion kind.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum ExpnKind {\n-    /// No expansion, aka root expansion. Only `Mark::root()` has this kind.\n+    /// No expansion, aka root expansion. Only `ExpnId::root()` has this kind.\n     Root,\n     /// Expansion produced by a macro.\n     /// FIXME: Some code injected by the compiler before HIR lowering also gets this kind."}, {"sha": "a4c7c4bf28752866bbd7ccbf15fce95fbc1ace0f", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e10aec83d68df0f45cf6643cca4e90e9c1fb55/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=31e10aec83d68df0f45cf6643cca4e90e9c1fb55", "patch": "@@ -27,7 +27,7 @@ extern crate serialize as rustc_serialize; // used by deriving\n pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n-pub use hygiene::{Mark, SyntaxContext, ExpnInfo, ExpnKind, MacroKind, DesugaringKind};\n+pub use hygiene::{ExpnId, SyntaxContext, ExpnInfo, ExpnKind, MacroKind, DesugaringKind};\n \n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n@@ -516,46 +516,46 @@ impl Span {\n     }\n \n     #[inline]\n-    pub fn apply_mark(self, mark: Mark) -> Span {\n+    pub fn apply_mark(self, mark: ExpnId) -> Span {\n         let span = self.data();\n         span.with_ctxt(span.ctxt.apply_mark(mark))\n     }\n \n     #[inline]\n-    pub fn remove_mark(&mut self) -> Mark {\n+    pub fn remove_mark(&mut self) -> ExpnId {\n         let mut span = self.data();\n         let mark = span.ctxt.remove_mark();\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }\n \n     #[inline]\n-    pub fn adjust(&mut self, expansion: Mark) -> Option<Mark> {\n+    pub fn adjust(&mut self, expansion: ExpnId) -> Option<ExpnId> {\n         let mut span = self.data();\n         let mark = span.ctxt.adjust(expansion);\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }\n \n     #[inline]\n-    pub fn modernize_and_adjust(&mut self, expansion: Mark) -> Option<Mark> {\n+    pub fn modernize_and_adjust(&mut self, expansion: ExpnId) -> Option<ExpnId> {\n         let mut span = self.data();\n         let mark = span.ctxt.modernize_and_adjust(expansion);\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }\n \n     #[inline]\n-    pub fn glob_adjust(&mut self, expansion: Mark, glob_span: Span) -> Option<Option<Mark>> {\n+    pub fn glob_adjust(&mut self, expansion: ExpnId, glob_span: Span) -> Option<Option<ExpnId>> {\n         let mut span = self.data();\n         let mark = span.ctxt.glob_adjust(expansion, glob_span);\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }\n \n     #[inline]\n-    pub fn reverse_glob_adjust(&mut self, expansion: Mark, glob_span: Span)\n-                               -> Option<Option<Mark>> {\n+    pub fn reverse_glob_adjust(&mut self, expansion: ExpnId, glob_span: Span)\n+                               -> Option<Option<ExpnId>> {\n         let mut span = self.data();\n         let mark = span.ctxt.reverse_glob_adjust(expansion, glob_span);\n         *self = Span::new(span.lo, span.hi, span.ctxt);"}]}