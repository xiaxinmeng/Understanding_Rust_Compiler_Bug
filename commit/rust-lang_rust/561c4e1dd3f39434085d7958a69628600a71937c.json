{"sha": "561c4e1dd3f39434085d7958a69628600a71937c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MWM0ZTFkZDNmMzk0MzQwODVkNzk1OGE2OTYyODYwMGE3MTkzN2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-10T04:00:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-10T04:00:21Z"}, "message": "Auto merge of #35079 - nikomatsakis:incr-comp-ich-32753, r=mw\n\nVarious improvements to the SVH\n\nThis fixes a few points for the SVH:\n\n- incorporate resolve results into the SVH;\n- don't include nested items.\n\nr? @michaelwoerister\n\ncc #32753 (not fully fixed I don't think)", "tree": {"sha": "9815cdad3f04d378c61e3af2932c40cfe2735589", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9815cdad3f04d378c61e3af2932c40cfe2735589"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/561c4e1dd3f39434085d7958a69628600a71937c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/561c4e1dd3f39434085d7958a69628600a71937c", "html_url": "https://github.com/rust-lang/rust/commit/561c4e1dd3f39434085d7958a69628600a71937c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/561c4e1dd3f39434085d7958a69628600a71937c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "576f7665942414cb95239f8cbec4b654f231f4aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/576f7665942414cb95239f8cbec4b654f231f4aa", "html_url": "https://github.com/rust-lang/rust/commit/576f7665942414cb95239f8cbec4b654f231f4aa"}, {"sha": "83068ebafd125e16dfd8821716030d8012fca0c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/83068ebafd125e16dfd8821716030d8012fca0c6", "html_url": "https://github.com/rust-lang/rust/commit/83068ebafd125e16dfd8821716030d8012fca0c6"}], "stats": {"total": 1298, "additions": 815, "deletions": 483}, "files": [{"sha": "40fd3dede3d08b5399312d8fc2fa82719c188d42", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=561c4e1dd3f39434085d7958a69628600a71937c", "patch": "@@ -150,6 +150,7 @@ impl<D: Clone + Debug> DepNode<D> {\n         check! {\n             CollectItem,\n             BorrowCheck,\n+            Hir,\n             TransCrateItem,\n             TypeckItemType,\n             TypeckItemBody,"}, {"sha": "a816d26edadf36678d254f83b15f8932e5b4bdc9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=561c4e1dd3f39434085d7958a69628600a71937c", "patch": "@@ -14,6 +14,7 @@ use dep_graph::{DepGraph, DepTrackingMap};\n use session::Session;\n use middle;\n use middle::cstore::LOCAL_CRATE;\n+use hir::TraitMap;\n use hir::def::DefMap;\n use hir::def_id::{DefId, DefIndex};\n use hir::map as ast_map;\n@@ -299,8 +300,16 @@ pub struct GlobalCtxt<'tcx> {\n     pub types: CommonTypes<'tcx>,\n \n     pub sess: &'tcx Session,\n+\n+    /// Map from path id to the results from resolve; generated\n+    /// initially by resolve and updated during typeck in some cases\n+    /// (e.g., UFCS paths)\n     pub def_map: RefCell<DefMap>,\n \n+    /// Map indicating what traits are in scope for places where this\n+    /// is relevant; generated by resolve.\n+    pub trait_map: TraitMap,\n+\n     pub named_region_map: resolve_lifetime::NamedRegionMap,\n \n     pub region_maps: RegionMaps,\n@@ -666,6 +675,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n                                   arenas: &'tcx CtxtArenas<'tcx>,\n                                   def_map: DefMap,\n+                                  trait_map: TraitMap,\n                                   named_region_map: resolve_lifetime::NamedRegionMap,\n                                   map: ast_map::Map<'tcx>,\n                                   freevars: FreevarMap,\n@@ -694,6 +704,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             variance_computed: Cell::new(false),\n             sess: s,\n             def_map: RefCell::new(def_map),\n+            trait_map: trait_map,\n             tables: RefCell::new(Tables::empty()),\n             impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),"}, {"sha": "7f50522b2032b0e10f51d9cdb38f20efe7a9a182", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=561c4e1dd3f39434085d7958a69628600a71937c", "patch": "@@ -846,10 +846,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let index = stability::Index::new(&hir_map);\n \n-    let trait_map = resolutions.trait_map;\n     TyCtxt::create_and_enter(sess,\n                              arenas,\n                              resolutions.def_map,\n+                             resolutions.trait_map,\n                              named_region_map,\n                              hir_map,\n                              resolutions.freevars,\n@@ -864,7 +864,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              || rustc_incremental::load_dep_graph(tcx));\n \n         // passes are timed inside typeck\n-        try_with_f!(typeck::check_crate(tcx, trait_map), (tcx, None, analysis));\n+        try_with_f!(typeck::check_crate(tcx), (tcx, None, analysis));\n \n         time(time_passes,\n              \"const checking\","}, {"sha": "2b0bd14d83fa0bb35ff36d65a6dace4442b3c223", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=561c4e1dd3f39434085d7958a69628600a71937c", "patch": "@@ -131,6 +131,7 @@ fn test_env<F>(source_string: &str,\n     TyCtxt::create_and_enter(&sess,\n                              &arenas,\n                              resolutions.def_map,\n+                             resolutions.trait_map,\n                              named_region_map.unwrap(),\n                              ast_map,\n                              resolutions.freevars,"}, {"sha": "4b2d42ca8895ce59417ece0865e521cac8e906dd", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "removed", "additions": 0, "deletions": 454, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -1,454 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Calculation of a Strict Version Hash for crates.  For a length\n-//! comment explaining the general idea, see `librustc/middle/svh.rs`.\n-\n-use syntax::attr::AttributeMethods;\n-use std::hash::{Hash, SipHasher, Hasher};\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::hir::map::{NodeItem, NodeForeignItem};\n-use rustc::hir::svh::Svh;\n-use rustc::ty::TyCtxt;\n-use rustc::hir::intravisit::{self, Visitor};\n-\n-use self::svh_visitor::StrictVersionHashVisitor;\n-\n-pub trait SvhCalculate {\n-    /// Calculate the SVH for an entire krate.\n-    fn calculate_krate_hash(self) -> Svh;\n-\n-    /// Calculate the SVH for a particular item.\n-    fn calculate_item_hash(self, def_id: DefId) -> u64;\n-}\n-\n-impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n-    fn calculate_krate_hash(self) -> Svh {\n-        // FIXME (#14132): This is better than it used to be, but it still not\n-        // ideal. We now attempt to hash only the relevant portions of the\n-        // Crate AST as well as the top-level crate attributes. (However,\n-        // the hashing of the crate attributes should be double-checked\n-        // to ensure it is not incorporating implementation artifacts into\n-        // the hash that are not otherwise visible.)\n-\n-        let crate_disambiguator = self.sess.local_crate_disambiguator();\n-        let krate = self.map.krate();\n-\n-        // FIXME: this should use SHA1, not SipHash. SipHash is not built to\n-        //        avoid collisions.\n-        let mut state = SipHasher::new();\n-        debug!(\"state: {:?}\", state);\n-\n-        // FIXME(#32753) -- at (*) we `to_le` for endianness, but is\n-        // this enough, and does it matter anyway?\n-        \"crate_disambiguator\".hash(&mut state);\n-        crate_disambiguator.len().to_le().hash(&mut state); // (*)\n-        crate_disambiguator.hash(&mut state);\n-\n-        debug!(\"crate_disambiguator: {:?}\", crate_disambiguator);\n-        debug!(\"state: {:?}\", state);\n-\n-        {\n-            let mut visit = StrictVersionHashVisitor::new(&mut state, self);\n-            krate.visit_all_items(&mut visit);\n-        }\n-\n-        // FIXME (#14132): This hash is still sensitive to e.g. the\n-        // spans of the crate Attributes and their underlying\n-        // MetaItems; we should make ContentHashable impl for those\n-        // types and then use hash_content.  But, since all crate\n-        // attributes should appear near beginning of the file, it is\n-        // not such a big deal to be sensitive to their spans for now.\n-        //\n-        // We hash only the MetaItems instead of the entire Attribute\n-        // to avoid hashing the AttrId\n-        for attr in &krate.attrs {\n-            debug!(\"krate attr {:?}\", attr);\n-            attr.meta().hash(&mut state);\n-        }\n-\n-        Svh::new(state.finish())\n-    }\n-\n-    fn calculate_item_hash(self, def_id: DefId) -> u64 {\n-        assert!(def_id.is_local());\n-\n-        debug!(\"calculate_item_hash(def_id={:?})\", def_id);\n-\n-        let mut state = SipHasher::new();\n-\n-        {\n-            let mut visit = StrictVersionHashVisitor::new(&mut state, self);\n-            if def_id.index == CRATE_DEF_INDEX {\n-                // the crate root itself is not registered in the map\n-                // as an item, so we have to fetch it this way\n-                let krate = self.map.krate();\n-                intravisit::walk_crate(&mut visit, krate);\n-            } else {\n-                let node_id = self.map.as_local_node_id(def_id).unwrap();\n-                match self.map.find(node_id) {\n-                    Some(NodeItem(item)) => visit.visit_item(item),\n-                    Some(NodeForeignItem(item)) => visit.visit_foreign_item(item),\n-                    r => bug!(\"calculate_item_hash: expected an item for node {} not {:?}\",\n-                              node_id, r),\n-                }\n-            }\n-        }\n-\n-        let hash = state.finish();\n-\n-        debug!(\"calculate_item_hash: def_id={:?} hash={:?}\", def_id, hash);\n-\n-        hash\n-    }\n-}\n-\n-// FIXME (#14132): Even this SVH computation still has implementation\n-// artifacts: namely, the order of item declaration will affect the\n-// hash computation, but for many kinds of items the order of\n-// declaration should be irrelevant to the ABI.\n-\n-mod svh_visitor {\n-    pub use self::SawExprComponent::*;\n-    pub use self::SawStmtComponent::*;\n-    use self::SawAbiComponent::*;\n-    use syntax::ast::{self, Name, NodeId};\n-    use syntax::parse::token;\n-    use syntax_pos::Span;\n-    use rustc::ty::TyCtxt;\n-    use rustc::hir;\n-    use rustc::hir::*;\n-    use rustc::hir::map::DefPath;\n-    use rustc::hir::intravisit as visit;\n-    use rustc::hir::intravisit::{Visitor, FnKind};\n-\n-    use std::hash::{Hash, SipHasher};\n-\n-    pub struct StrictVersionHashVisitor<'a, 'tcx: 'a> {\n-        pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        pub st: &'a mut SipHasher,\n-    }\n-\n-    impl<'a, 'tcx> StrictVersionHashVisitor<'a, 'tcx> {\n-        pub fn new(st: &'a mut SipHasher,\n-                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                   -> Self {\n-            StrictVersionHashVisitor { st: st, tcx: tcx }\n-        }\n-\n-        fn hash_def_path(&mut self, path: &DefPath) {\n-            path.deterministic_hash_to(self.tcx, self.st);\n-        }\n-    }\n-\n-    // To off-load the bulk of the hash-computation on #[derive(Hash)],\n-    // we define a set of enums corresponding to the content that our\n-    // crate visitor will encounter as it traverses the ast.\n-    //\n-    // The important invariant is that all of the Saw*Component enums\n-    // do not carry any Spans, Names, or Idents.\n-    //\n-    // Not carrying any Names/Idents is the important fix for problem\n-    // noted on PR #13948: using the ident.name as the basis for a\n-    // hash leads to unstable SVH, because ident.name is just an index\n-    // into intern table (i.e. essentially a random address), not\n-    // computed from the name content.\n-    //\n-    // With the below enums, the SVH computation is not sensitive to\n-    // artifacts of how rustc was invoked nor of how the source code\n-    // was laid out.  (Or at least it is *less* sensitive.)\n-\n-    // This enum represents the different potential bits of code the\n-    // visitor could encounter that could affect the ABI for the crate,\n-    // and assigns each a distinct tag to feed into the hash computation.\n-    #[derive(Hash)]\n-    enum SawAbiComponent<'a> {\n-\n-        // FIXME (#14132): should we include (some function of)\n-        // ident.ctxt as well?\n-        SawIdent(token::InternedString),\n-        SawStructDef(token::InternedString),\n-\n-        SawLifetime(token::InternedString),\n-        SawLifetimeDef(token::InternedString),\n-\n-        SawMod,\n-        SawForeignItem,\n-        SawItem,\n-        SawDecl,\n-        SawTy,\n-        SawGenerics,\n-        SawFn,\n-        SawTraitItem,\n-        SawImplItem,\n-        SawStructField,\n-        SawVariant,\n-        SawPath,\n-        SawBlock,\n-        SawPat,\n-        SawLocal,\n-        SawArm,\n-        SawExpr(SawExprComponent<'a>),\n-        SawStmt(SawStmtComponent),\n-    }\n-\n-    /// SawExprComponent carries all of the information that we want\n-    /// to include in the hash that *won't* be covered by the\n-    /// subsequent recursive traversal of the expression's\n-    /// substructure by the visitor.\n-    ///\n-    /// We know every Expr_ variant is covered by a variant because\n-    /// `fn saw_expr` maps each to some case below.  Ensuring that\n-    /// each variant carries an appropriate payload has to be verified\n-    /// by hand.\n-    ///\n-    /// (However, getting that *exactly* right is not so important\n-    /// because the SVH is just a developer convenience; there is no\n-    /// guarantee of collision-freedom, hash collisions are just\n-    /// (hopefully) unlikely.)\n-    #[derive(Hash)]\n-    pub enum SawExprComponent<'a> {\n-\n-        SawExprLoop(Option<token::InternedString>),\n-        SawExprField(token::InternedString),\n-        SawExprTupField(usize),\n-        SawExprBreak(Option<token::InternedString>),\n-        SawExprAgain(Option<token::InternedString>),\n-\n-        SawExprBox,\n-        SawExprVec,\n-        SawExprCall,\n-        SawExprMethodCall,\n-        SawExprTup,\n-        SawExprBinary(hir::BinOp_),\n-        SawExprUnary(hir::UnOp),\n-        SawExprLit(ast::LitKind),\n-        SawExprCast,\n-        SawExprType,\n-        SawExprIf,\n-        SawExprWhile,\n-        SawExprMatch,\n-        SawExprClosure,\n-        SawExprBlock,\n-        SawExprAssign,\n-        SawExprAssignOp(hir::BinOp_),\n-        SawExprIndex,\n-        SawExprPath(Option<usize>),\n-        SawExprAddrOf(hir::Mutability),\n-        SawExprRet,\n-        SawExprInlineAsm(&'a hir::InlineAsm),\n-        SawExprStruct,\n-        SawExprRepeat,\n-    }\n-\n-    fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n-        match *node {\n-            ExprBox(..)              => SawExprBox,\n-            ExprVec(..)              => SawExprVec,\n-            ExprCall(..)             => SawExprCall,\n-            ExprMethodCall(..)       => SawExprMethodCall,\n-            ExprTup(..)              => SawExprTup,\n-            ExprBinary(op, _, _)     => SawExprBinary(op.node),\n-            ExprUnary(op, _)         => SawExprUnary(op),\n-            ExprLit(ref lit)         => SawExprLit(lit.node.clone()),\n-            ExprCast(..)             => SawExprCast,\n-            ExprType(..)             => SawExprType,\n-            ExprIf(..)               => SawExprIf,\n-            ExprWhile(..)            => SawExprWhile,\n-            ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.node.as_str())),\n-            ExprMatch(..)            => SawExprMatch,\n-            ExprClosure(..)          => SawExprClosure,\n-            ExprBlock(..)            => SawExprBlock,\n-            ExprAssign(..)           => SawExprAssign,\n-            ExprAssignOp(op, _, _)   => SawExprAssignOp(op.node),\n-            ExprField(_, name)       => SawExprField(name.node.as_str()),\n-            ExprTupField(_, id)      => SawExprTupField(id.node),\n-            ExprIndex(..)            => SawExprIndex,\n-            ExprPath(ref qself, _)   => SawExprPath(qself.as_ref().map(|q| q.position)),\n-            ExprAddrOf(m, _)         => SawExprAddrOf(m),\n-            ExprBreak(id)            => SawExprBreak(id.map(|id| id.node.as_str())),\n-            ExprAgain(id)            => SawExprAgain(id.map(|id| id.node.as_str())),\n-            ExprRet(..)              => SawExprRet,\n-            ExprInlineAsm(ref a,_,_) => SawExprInlineAsm(a),\n-            ExprStruct(..)           => SawExprStruct,\n-            ExprRepeat(..)           => SawExprRepeat,\n-        }\n-    }\n-\n-    /// SawStmtComponent is analogous to SawExprComponent, but for statements.\n-    #[derive(Hash)]\n-    pub enum SawStmtComponent {\n-        SawStmtDecl,\n-        SawStmtExpr,\n-        SawStmtSemi,\n-    }\n-\n-    fn saw_stmt(node: &Stmt_) -> SawStmtComponent {\n-        match *node {\n-            StmtDecl(..) => SawStmtDecl,\n-            StmtExpr(..) => SawStmtExpr,\n-            StmtSemi(..) => SawStmtSemi,\n-        }\n-    }\n-\n-    impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n-        fn visit_nested_item(&mut self, item: ItemId) {\n-            let def_path = self.tcx.map.def_path_from_id(item.id).unwrap();\n-            debug!(\"visit_nested_item: def_path={:?} st={:?}\", def_path, self.st);\n-            self.hash_def_path(&def_path);\n-        }\n-\n-        fn visit_variant_data(&mut self, s: &'a VariantData, name: Name,\n-                              g: &'a Generics, _: NodeId, _: Span) {\n-            debug!(\"visit_variant_data: st={:?}\", self.st);\n-            SawStructDef(name.as_str()).hash(self.st);\n-            visit::walk_generics(self, g);\n-            visit::walk_struct_def(self, s)\n-        }\n-\n-        fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n-            debug!(\"visit_variant: st={:?}\", self.st);\n-            SawVariant.hash(self.st);\n-            // walk_variant does not call walk_generics, so do it here.\n-            visit::walk_generics(self, g);\n-            visit::walk_variant(self, v, g, item_id)\n-        }\n-\n-        // All of the remaining methods just record (in the hash\n-        // SipHasher) that the visitor saw that particular variant\n-        // (with its payload), and continue walking as the default\n-        // visitor would.\n-        //\n-        // Some of the implementations have some notes as to how one\n-        // might try to make their SVH computation less discerning\n-        // (e.g. by incorporating reachability analysis).  But\n-        // currently all of their implementations are uniform and\n-        // uninteresting.\n-        //\n-        // (If you edit a method such that it deviates from the\n-        // pattern, please move that method up above this comment.)\n-\n-        fn visit_name(&mut self, _: Span, name: Name) {\n-            debug!(\"visit_name: st={:?}\", self.st);\n-            SawIdent(name.as_str()).hash(self.st);\n-        }\n-\n-        fn visit_lifetime(&mut self, l: &'a Lifetime) {\n-            debug!(\"visit_lifetime: st={:?}\", self.st);\n-            SawLifetime(l.name.as_str()).hash(self.st);\n-        }\n-\n-        fn visit_lifetime_def(&mut self, l: &'a LifetimeDef) {\n-            debug!(\"visit_lifetime_def: st={:?}\", self.st);\n-            SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n-        }\n-\n-        // We do recursively walk the bodies of functions/methods\n-        // (rather than omitting their bodies from the hash) since\n-        // monomorphization and cross-crate inlining generally implies\n-        // that a change to a crate body will require downstream\n-        // crates to be recompiled.\n-        fn visit_expr(&mut self, ex: &'a Expr) {\n-            debug!(\"visit_expr: st={:?}\", self.st);\n-            SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n-        }\n-\n-        fn visit_stmt(&mut self, s: &'a Stmt) {\n-            debug!(\"visit_stmt: st={:?}\", self.st);\n-            SawStmt(saw_stmt(&s.node)).hash(self.st); visit::walk_stmt(self, s)\n-        }\n-\n-        fn visit_foreign_item(&mut self, i: &'a ForeignItem) {\n-            debug!(\"visit_foreign_item: st={:?}\", self.st);\n-\n-            // FIXME (#14132) ideally we would incorporate privacy (or\n-            // perhaps reachability) somewhere here, so foreign items\n-            // that do not leak into downstream crates would not be\n-            // part of the ABI.\n-            SawForeignItem.hash(self.st); visit::walk_foreign_item(self, i)\n-        }\n-\n-        fn visit_item(&mut self, i: &'a Item) {\n-            debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n-\n-            // FIXME (#14132) ideally would incorporate reachability\n-            // analysis somewhere here, so items that never leak into\n-            // downstream crates (e.g. via monomorphisation or\n-            // inlining) would not be part of the ABI.\n-            SawItem.hash(self.st); visit::walk_item(self, i)\n-        }\n-\n-        fn visit_mod(&mut self, m: &'a Mod, _s: Span, n: NodeId) {\n-            debug!(\"visit_mod: st={:?}\", self.st);\n-            SawMod.hash(self.st); visit::walk_mod(self, m, n)\n-        }\n-\n-        fn visit_decl(&mut self, d: &'a Decl) {\n-            debug!(\"visit_decl: st={:?}\", self.st);\n-            SawDecl.hash(self.st); visit::walk_decl(self, d)\n-        }\n-\n-        fn visit_ty(&mut self, t: &'a Ty) {\n-            debug!(\"visit_ty: st={:?}\", self.st);\n-            SawTy.hash(self.st); visit::walk_ty(self, t)\n-        }\n-\n-        fn visit_generics(&mut self, g: &'a Generics) {\n-            debug!(\"visit_generics: st={:?}\", self.st);\n-            SawGenerics.hash(self.st); visit::walk_generics(self, g)\n-        }\n-\n-        fn visit_fn(&mut self, fk: FnKind<'a>, fd: &'a FnDecl,\n-                    b: &'a Block, s: Span, n: NodeId) {\n-            debug!(\"visit_fn: st={:?}\", self.st);\n-            SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s, n)\n-        }\n-\n-        fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n-            debug!(\"visit_trait_item: st={:?}\", self.st);\n-            SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n-        }\n-\n-        fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n-            debug!(\"visit_impl_item: st={:?}\", self.st);\n-            SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n-        }\n-\n-        fn visit_struct_field(&mut self, s: &'a StructField) {\n-            debug!(\"visit_struct_field: st={:?}\", self.st);\n-            SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n-        }\n-\n-        fn visit_path(&mut self, path: &'a Path, _: ast::NodeId) {\n-            debug!(\"visit_path: st={:?}\", self.st);\n-            SawPath.hash(self.st); visit::walk_path(self, path)\n-        }\n-\n-        fn visit_block(&mut self, b: &'a Block) {\n-            debug!(\"visit_block: st={:?}\", self.st);\n-            SawBlock.hash(self.st); visit::walk_block(self, b)\n-        }\n-\n-        fn visit_pat(&mut self, p: &'a Pat) {\n-            debug!(\"visit_pat: st={:?}\", self.st);\n-            SawPat.hash(self.st); visit::walk_pat(self, p)\n-        }\n-\n-        fn visit_local(&mut self, l: &'a Local) {\n-            debug!(\"visit_local: st={:?}\", self.st);\n-            SawLocal.hash(self.st); visit::walk_local(self, l)\n-        }\n-\n-        fn visit_arm(&mut self, a: &'a Arm) {\n-            debug!(\"visit_arm: st={:?}\", self.st);\n-            SawArm.hash(self.st); visit::walk_arm(self, a)\n-        }\n-    }\n-}"}, {"sha": "d7caf8c882f0b36d52f575f98125ab368e81b3ad", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=561c4e1dd3f39434085d7958a69628600a71937c", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Calculation of a Strict Version Hash for crates.  For a length\n+//! comment explaining the general idea, see `librustc/middle/svh.rs`.\n+\n+use syntax::attr::AttributeMethods;\n+use std::hash::{Hash, SipHasher, Hasher};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::map::{NodeItem, NodeForeignItem};\n+use rustc::hir::svh::Svh;\n+use rustc::ty::TyCtxt;\n+use rustc::hir::intravisit::{self, Visitor};\n+\n+use self::svh_visitor::StrictVersionHashVisitor;\n+\n+mod svh_visitor;\n+\n+pub trait SvhCalculate {\n+    /// Calculate the SVH for an entire krate.\n+    fn calculate_krate_hash(self) -> Svh;\n+\n+    /// Calculate the SVH for a particular item.\n+    fn calculate_item_hash(self, def_id: DefId) -> u64;\n+}\n+\n+impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n+    fn calculate_krate_hash(self) -> Svh {\n+        // FIXME (#14132): This is better than it used to be, but it still not\n+        // ideal. We now attempt to hash only the relevant portions of the\n+        // Crate AST as well as the top-level crate attributes. (However,\n+        // the hashing of the crate attributes should be double-checked\n+        // to ensure it is not incorporating implementation artifacts into\n+        // the hash that are not otherwise visible.)\n+\n+        let crate_disambiguator = self.sess.local_crate_disambiguator();\n+        let krate = self.map.krate();\n+\n+        // FIXME: this should use SHA1, not SipHash. SipHash is not built to\n+        //        avoid collisions.\n+        let mut state = SipHasher::new();\n+        debug!(\"state: {:?}\", state);\n+\n+        // FIXME(#32753) -- at (*) we `to_le` for endianness, but is\n+        // this enough, and does it matter anyway?\n+        \"crate_disambiguator\".hash(&mut state);\n+        crate_disambiguator.len().to_le().hash(&mut state); // (*)\n+        crate_disambiguator.hash(&mut state);\n+\n+        debug!(\"crate_disambiguator: {:?}\", crate_disambiguator);\n+        debug!(\"state: {:?}\", state);\n+\n+        {\n+            let mut visit = StrictVersionHashVisitor::new(&mut state, self);\n+            krate.visit_all_items(&mut visit);\n+        }\n+\n+        // FIXME (#14132): This hash is still sensitive to e.g. the\n+        // spans of the crate Attributes and their underlying\n+        // MetaItems; we should make ContentHashable impl for those\n+        // types and then use hash_content.  But, since all crate\n+        // attributes should appear near beginning of the file, it is\n+        // not such a big deal to be sensitive to their spans for now.\n+        //\n+        // We hash only the MetaItems instead of the entire Attribute\n+        // to avoid hashing the AttrId\n+        for attr in &krate.attrs {\n+            debug!(\"krate attr {:?}\", attr);\n+            attr.meta().hash(&mut state);\n+        }\n+\n+        Svh::new(state.finish())\n+    }\n+\n+    fn calculate_item_hash(self, def_id: DefId) -> u64 {\n+        assert!(def_id.is_local());\n+\n+        debug!(\"calculate_item_hash(def_id={:?})\", def_id);\n+\n+        let mut state = SipHasher::new();\n+\n+        {\n+            let mut visit = StrictVersionHashVisitor::new(&mut state, self);\n+            if def_id.index == CRATE_DEF_INDEX {\n+                // the crate root itself is not registered in the map\n+                // as an item, so we have to fetch it this way\n+                let krate = self.map.krate();\n+                intravisit::walk_crate(&mut visit, krate);\n+            } else {\n+                let node_id = self.map.as_local_node_id(def_id).unwrap();\n+                match self.map.find(node_id) {\n+                    Some(NodeItem(item)) => visit.visit_item(item),\n+                    Some(NodeForeignItem(item)) => visit.visit_foreign_item(item),\n+                    r => bug!(\"calculate_item_hash: expected an item for node {} not {:?}\",\n+                              node_id, r),\n+                }\n+            }\n+        }\n+\n+        let hash = state.finish();\n+\n+        debug!(\"calculate_item_hash: def_id={:?} hash={:?}\", def_id, hash);\n+\n+        hash\n+    }\n+}"}, {"sha": "42e7abeeaca8f250d809c0760fc142570c0a5622", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "added", "additions": 439, "deletions": 0, "changes": 439, "blob_url": "https://github.com/rust-lang/rust/blob/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=561c4e1dd3f39434085d7958a69628600a71937c", "patch": "@@ -0,0 +1,439 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// FIXME (#14132): Even this SVH computation still has implementation\n+// artifacts: namely, the order of item declaration will affect the\n+// hash computation, but for many kinds of items the order of\n+// declaration should be irrelevant to the ABI.\n+\n+pub use self::SawExprComponent::*;\n+pub use self::SawStmtComponent::*;\n+use self::SawAbiComponent::*;\n+use syntax::ast::{self, Name, NodeId};\n+use syntax::parse::token;\n+use syntax_pos::Span;\n+use rustc::hir;\n+use rustc::hir::*;\n+use rustc::hir::def::{Def, PathResolution};\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::intravisit as visit;\n+use rustc::hir::intravisit::{Visitor, FnKind};\n+use rustc::hir::map::DefPath;\n+use rustc::ty::TyCtxt;\n+\n+use std::hash::{Hash, SipHasher};\n+\n+pub struct StrictVersionHashVisitor<'a, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub st: &'a mut SipHasher,\n+}\n+\n+impl<'a, 'tcx> StrictVersionHashVisitor<'a, 'tcx> {\n+    pub fn new(st: &'a mut SipHasher,\n+               tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+               -> Self {\n+        StrictVersionHashVisitor { st: st, tcx: tcx }\n+    }\n+\n+    fn hash_def_path(&mut self, path: &DefPath) {\n+        path.deterministic_hash_to(self.tcx, self.st);\n+    }\n+}\n+\n+// To off-load the bulk of the hash-computation on #[derive(Hash)],\n+// we define a set of enums corresponding to the content that our\n+// crate visitor will encounter as it traverses the ast.\n+//\n+// The important invariant is that all of the Saw*Component enums\n+// do not carry any Spans, Names, or Idents.\n+//\n+// Not carrying any Names/Idents is the important fix for problem\n+// noted on PR #13948: using the ident.name as the basis for a\n+// hash leads to unstable SVH, because ident.name is just an index\n+// into intern table (i.e. essentially a random address), not\n+// computed from the name content.\n+//\n+// With the below enums, the SVH computation is not sensitive to\n+// artifacts of how rustc was invoked nor of how the source code\n+// was laid out.  (Or at least it is *less* sensitive.)\n+\n+// This enum represents the different potential bits of code the\n+// visitor could encounter that could affect the ABI for the crate,\n+// and assigns each a distinct tag to feed into the hash computation.\n+#[derive(Hash)]\n+enum SawAbiComponent<'a> {\n+\n+    // FIXME (#14132): should we include (some function of)\n+    // ident.ctxt as well?\n+    SawIdent(token::InternedString),\n+    SawStructDef(token::InternedString),\n+\n+    SawLifetime(token::InternedString),\n+    SawLifetimeDef(token::InternedString),\n+\n+    SawMod,\n+    SawForeignItem,\n+    SawItem,\n+    SawTy,\n+    SawGenerics,\n+    SawFn,\n+    SawTraitItem,\n+    SawImplItem,\n+    SawStructField,\n+    SawVariant,\n+    SawPath,\n+    SawBlock,\n+    SawPat,\n+    SawLocal,\n+    SawArm,\n+    SawExpr(SawExprComponent<'a>),\n+    SawStmt(SawStmtComponent),\n+}\n+\n+/// SawExprComponent carries all of the information that we want\n+/// to include in the hash that *won't* be covered by the\n+/// subsequent recursive traversal of the expression's\n+/// substructure by the visitor.\n+///\n+/// We know every Expr_ variant is covered by a variant because\n+/// `fn saw_expr` maps each to some case below.  Ensuring that\n+/// each variant carries an appropriate payload has to be verified\n+/// by hand.\n+///\n+/// (However, getting that *exactly* right is not so important\n+/// because the SVH is just a developer convenience; there is no\n+/// guarantee of collision-freedom, hash collisions are just\n+/// (hopefully) unlikely.)\n+#[derive(Hash)]\n+pub enum SawExprComponent<'a> {\n+\n+    SawExprLoop(Option<token::InternedString>),\n+    SawExprField(token::InternedString),\n+    SawExprTupField(usize),\n+    SawExprBreak(Option<token::InternedString>),\n+    SawExprAgain(Option<token::InternedString>),\n+\n+    SawExprBox,\n+    SawExprVec,\n+    SawExprCall,\n+    SawExprMethodCall,\n+    SawExprTup,\n+    SawExprBinary(hir::BinOp_),\n+    SawExprUnary(hir::UnOp),\n+    SawExprLit(ast::LitKind),\n+    SawExprCast,\n+    SawExprType,\n+    SawExprIf,\n+    SawExprWhile,\n+    SawExprMatch,\n+    SawExprClosure,\n+    SawExprBlock,\n+    SawExprAssign,\n+    SawExprAssignOp(hir::BinOp_),\n+    SawExprIndex,\n+    SawExprPath(Option<usize>),\n+    SawExprAddrOf(hir::Mutability),\n+    SawExprRet,\n+    SawExprInlineAsm(&'a hir::InlineAsm),\n+    SawExprStruct,\n+    SawExprRepeat,\n+}\n+\n+fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n+    match *node {\n+        ExprBox(..)              => SawExprBox,\n+        ExprVec(..)              => SawExprVec,\n+        ExprCall(..)             => SawExprCall,\n+        ExprMethodCall(..)       => SawExprMethodCall,\n+        ExprTup(..)              => SawExprTup,\n+        ExprBinary(op, _, _)     => SawExprBinary(op.node),\n+        ExprUnary(op, _)         => SawExprUnary(op),\n+        ExprLit(ref lit)         => SawExprLit(lit.node.clone()),\n+        ExprCast(..)             => SawExprCast,\n+        ExprType(..)             => SawExprType,\n+        ExprIf(..)               => SawExprIf,\n+        ExprWhile(..)            => SawExprWhile,\n+        ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.node.as_str())),\n+        ExprMatch(..)            => SawExprMatch,\n+        ExprClosure(..)          => SawExprClosure,\n+        ExprBlock(..)            => SawExprBlock,\n+        ExprAssign(..)           => SawExprAssign,\n+        ExprAssignOp(op, _, _)   => SawExprAssignOp(op.node),\n+        ExprField(_, name)       => SawExprField(name.node.as_str()),\n+        ExprTupField(_, id)      => SawExprTupField(id.node),\n+        ExprIndex(..)            => SawExprIndex,\n+        ExprPath(ref qself, _)   => SawExprPath(qself.as_ref().map(|q| q.position)),\n+        ExprAddrOf(m, _)         => SawExprAddrOf(m),\n+        ExprBreak(id)            => SawExprBreak(id.map(|id| id.node.as_str())),\n+        ExprAgain(id)            => SawExprAgain(id.map(|id| id.node.as_str())),\n+        ExprRet(..)              => SawExprRet,\n+        ExprInlineAsm(ref a,_,_) => SawExprInlineAsm(a),\n+        ExprStruct(..)           => SawExprStruct,\n+        ExprRepeat(..)           => SawExprRepeat,\n+    }\n+}\n+\n+/// SawStmtComponent is analogous to SawExprComponent, but for statements.\n+#[derive(Hash)]\n+pub enum SawStmtComponent {\n+    SawStmtExpr,\n+    SawStmtSemi,\n+}\n+\n+impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n+    fn visit_nested_item(&mut self, _: ItemId) {\n+        // Each item is hashed independently; ignore nested items.\n+    }\n+\n+    fn visit_variant_data(&mut self, s: &'a VariantData, name: Name,\n+                          g: &'a Generics, _: NodeId, _: Span) {\n+        debug!(\"visit_variant_data: st={:?}\", self.st);\n+        SawStructDef(name.as_str()).hash(self.st);\n+        visit::walk_generics(self, g);\n+        visit::walk_struct_def(self, s)\n+    }\n+\n+    fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n+        debug!(\"visit_variant: st={:?}\", self.st);\n+        SawVariant.hash(self.st);\n+        // walk_variant does not call walk_generics, so do it here.\n+        visit::walk_generics(self, g);\n+        visit::walk_variant(self, v, g, item_id)\n+    }\n+\n+    // All of the remaining methods just record (in the hash\n+    // SipHasher) that the visitor saw that particular variant\n+    // (with its payload), and continue walking as the default\n+    // visitor would.\n+    //\n+    // Some of the implementations have some notes as to how one\n+    // might try to make their SVH computation less discerning\n+    // (e.g. by incorporating reachability analysis).  But\n+    // currently all of their implementations are uniform and\n+    // uninteresting.\n+    //\n+    // (If you edit a method such that it deviates from the\n+    // pattern, please move that method up above this comment.)\n+\n+    fn visit_name(&mut self, _: Span, name: Name) {\n+        debug!(\"visit_name: st={:?}\", self.st);\n+        SawIdent(name.as_str()).hash(self.st);\n+    }\n+\n+    fn visit_lifetime(&mut self, l: &'a Lifetime) {\n+        debug!(\"visit_lifetime: st={:?}\", self.st);\n+        SawLifetime(l.name.as_str()).hash(self.st);\n+    }\n+\n+    fn visit_lifetime_def(&mut self, l: &'a LifetimeDef) {\n+        debug!(\"visit_lifetime_def: st={:?}\", self.st);\n+        SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n+    }\n+\n+    // We do recursively walk the bodies of functions/methods\n+    // (rather than omitting their bodies from the hash) since\n+    // monomorphization and cross-crate inlining generally implies\n+    // that a change to a crate body will require downstream\n+    // crates to be recompiled.\n+    fn visit_expr(&mut self, ex: &'a Expr) {\n+        debug!(\"visit_expr: st={:?}\", self.st);\n+        SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n+    }\n+\n+    fn visit_stmt(&mut self, s: &'a Stmt) {\n+        debug!(\"visit_stmt: st={:?}\", self.st);\n+\n+        // We don't want to modify the hash for decls, because\n+        // they might be item decls (if they are local decls,\n+        // we'll hash that fact in visit_local); but we do want to\n+        // remember if this was a StmtExpr or StmtSemi (the later\n+        // had an explicit semi-colon; this affects the typing\n+        // rules).\n+        match s.node {\n+            StmtDecl(..) => (),\n+            StmtExpr(..) => SawStmt(SawStmtExpr).hash(self.st),\n+            StmtSemi(..) => SawStmt(SawStmtSemi).hash(self.st),\n+        }\n+\n+        visit::walk_stmt(self, s)\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &'a ForeignItem) {\n+        debug!(\"visit_foreign_item: st={:?}\", self.st);\n+\n+        // FIXME (#14132) ideally we would incorporate privacy (or\n+        // perhaps reachability) somewhere here, so foreign items\n+        // that do not leak into downstream crates would not be\n+        // part of the ABI.\n+        SawForeignItem.hash(self.st); visit::walk_foreign_item(self, i)\n+    }\n+\n+    fn visit_item(&mut self, i: &'a Item) {\n+        debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n+\n+        // FIXME (#14132) ideally would incorporate reachability\n+        // analysis somewhere here, so items that never leak into\n+        // downstream crates (e.g. via monomorphisation or\n+        // inlining) would not be part of the ABI.\n+        SawItem.hash(self.st); visit::walk_item(self, i)\n+    }\n+\n+    fn visit_mod(&mut self, m: &'a Mod, _s: Span, n: NodeId) {\n+        debug!(\"visit_mod: st={:?}\", self.st);\n+        SawMod.hash(self.st); visit::walk_mod(self, m, n)\n+    }\n+\n+    fn visit_ty(&mut self, t: &'a Ty) {\n+        debug!(\"visit_ty: st={:?}\", self.st);\n+        SawTy.hash(self.st); visit::walk_ty(self, t)\n+    }\n+\n+    fn visit_generics(&mut self, g: &'a Generics) {\n+        debug!(\"visit_generics: st={:?}\", self.st);\n+        SawGenerics.hash(self.st); visit::walk_generics(self, g)\n+    }\n+\n+    fn visit_fn(&mut self, fk: FnKind<'a>, fd: &'a FnDecl,\n+                b: &'a Block, s: Span, n: NodeId) {\n+        debug!(\"visit_fn: st={:?}\", self.st);\n+        SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s, n)\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n+        debug!(\"visit_trait_item: st={:?}\", self.st);\n+        SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n+        debug!(\"visit_impl_item: st={:?}\", self.st);\n+        SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'a StructField) {\n+        debug!(\"visit_struct_field: st={:?}\", self.st);\n+        SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n+    }\n+\n+    fn visit_path(&mut self, path: &'a Path, _: ast::NodeId) {\n+        debug!(\"visit_path: st={:?}\", self.st);\n+        SawPath.hash(self.st); visit::walk_path(self, path)\n+    }\n+\n+    fn visit_block(&mut self, b: &'a Block) {\n+        debug!(\"visit_block: st={:?}\", self.st);\n+        SawBlock.hash(self.st); visit::walk_block(self, b)\n+    }\n+\n+    fn visit_pat(&mut self, p: &'a Pat) {\n+        debug!(\"visit_pat: st={:?}\", self.st);\n+        SawPat.hash(self.st); visit::walk_pat(self, p)\n+    }\n+\n+    fn visit_local(&mut self, l: &'a Local) {\n+        debug!(\"visit_local: st={:?}\", self.st);\n+        SawLocal.hash(self.st); visit::walk_local(self, l)\n+    }\n+\n+    fn visit_arm(&mut self, a: &'a Arm) {\n+        debug!(\"visit_arm: st={:?}\", self.st);\n+        SawArm.hash(self.st); visit::walk_arm(self, a)\n+    }\n+\n+    fn visit_id(&mut self, id: NodeId) {\n+        debug!(\"visit_id: id={} st={:?}\", id, self.st);\n+        self.hash_resolve(id);\n+    }\n+}\n+\n+#[derive(Hash)]\n+pub enum DefHash {\n+    SawDefId,\n+    SawLabel,\n+    SawPrimTy,\n+    SawSelfTy,\n+    SawErr,\n+}\n+\n+impl<'a, 'tcx> StrictVersionHashVisitor<'a, 'tcx> {\n+    fn hash_resolve(&mut self, id: ast::NodeId) {\n+        // Because whether or not a given id has an entry is dependent\n+        // solely on expr variant etc, we don't need to hash whether\n+        // or not an entry was present (we are already hashing what\n+        // variant it is above when we visit the HIR).\n+\n+        if let Some(def) = self.tcx.def_map.borrow().get(&id) {\n+            self.hash_partial_def(def);\n+        }\n+\n+        if let Some(traits) = self.tcx.trait_map.get(&id) {\n+            traits.len().hash(self.st);\n+            for candidate in traits {\n+                self.hash_def_id(candidate.def_id);\n+            }\n+        }\n+    }\n+\n+    fn hash_def_id(&mut self, def_id: DefId) {\n+        let def_path = self.tcx.def_path(def_id);\n+        self.hash_def_path(&def_path);\n+    }\n+\n+    fn hash_partial_def(&mut self, def: &PathResolution) {\n+        self.hash_def(def.base_def);\n+        def.depth.hash(self.st);\n+    }\n+\n+    fn hash_def(&mut self, def: Def) {\n+        match def {\n+            // Crucial point: for all of these variants, the variant +\n+            // add'l data that is added is always the same if the\n+            // def-id is the same, so it suffices to hash the def-id\n+            Def::Fn(..) |\n+            Def::Mod(..) |\n+            Def::ForeignMod(..) |\n+            Def::Static(..) |\n+            Def::Variant(..) |\n+            Def::Enum(..) |\n+            Def::TyAlias(..) |\n+            Def::AssociatedTy(..) |\n+            Def::TyParam(..) |\n+            Def::Struct(..) |\n+            Def::Trait(..) |\n+            Def::Method(..) |\n+            Def::Const(..) |\n+            Def::AssociatedConst(..) |\n+            Def::Local(..) |\n+            Def::Upvar(..) => {\n+                DefHash::SawDefId.hash(self.st);\n+                self.hash_def_id(def.def_id());\n+            }\n+\n+            Def::Label(..) => {\n+                DefHash::SawLabel.hash(self.st);\n+                // we don't encode the `id` because it always refers to something\n+                // within this item, so if it changed, there would have to be other\n+                // changes too\n+            }\n+            Def::PrimTy(ref prim_ty) => {\n+                DefHash::SawPrimTy.hash(self.st);\n+                prim_ty.hash(self.st);\n+            }\n+            Def::SelfTy(..) => {\n+                DefHash::SawSelfTy.hash(self.st);\n+                // the meaning of Self is always the same within a\n+                // given context, so we don't need to hash the other\n+                // fields\n+            }\n+            Def::Err => {\n+                DefHash::SawErr.hash(self.st);\n+            }\n+        }\n+    }\n+}"}, {"sha": "3c77cc07d3d89283b37a1feda18444e8309618c7", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 67, "deletions": 14, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=561c4e1dd3f39434085d7958a69628600a71937c", "patch": "@@ -24,10 +24,13 @@\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n \n+use super::directory::RetracedDefIdDirectory;\n+use super::load::DirtyNodes;\n use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::Visitor;\n+use rustc_data_structures::fnv::FnvHashSet;\n use syntax::ast::{self, Attribute, MetaItem};\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::InternedString;\n@@ -38,19 +41,33 @@ const CLEAN: &'static str = \"rustc_clean\";\n const LABEL: &'static str = \"label\";\n const CFG: &'static str = \"cfg\";\n \n-pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               dirty_inputs: &DirtyNodes,\n+                                               retraced: &RetracedDefIdDirectory) {\n+    // can't add `#[rustc_dirty]` etc without opting in to this feature\n+    if !tcx.sess.features.borrow().rustc_attrs {\n+        return;\n+    }\n+\n     let _ignore = tcx.dep_graph.in_ignore();\n+    let dirty_inputs: FnvHashSet<DepNode<DefId>> =\n+        dirty_inputs.iter()\n+                   .filter_map(|d| retraced.map(d))\n+                   .collect();\n     let query = tcx.dep_graph.query();\n+    debug!(\"query-nodes: {:?}\", query.nodes());\n     let krate = tcx.map.krate();\n     krate.visit_all_items(&mut DirtyCleanVisitor {\n         tcx: tcx,\n         query: &query,\n+        dirty_inputs: dirty_inputs,\n     });\n }\n \n pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     query: &'a DepGraphQuery<DefId>,\n+    dirty_inputs: FnvHashSet<DepNode<DefId>>,\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n@@ -81,10 +98,13 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                         return true;\n                     }\n                 }\n+                return false;\n             }\n         }\n-        debug!(\"check_config: no match found\");\n-        return false;\n+\n+        self.tcx.sess.span_fatal(\n+            attr.span,\n+            &format!(\"no cfg attribute\"));\n     }\n \n     fn dep_node(&self, attr: &Attribute, def_id: DefId) -> DepNode<DefId> {\n@@ -105,29 +125,62 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n         self.tcx.sess.span_fatal(attr.span, \"no `label` found\");\n     }\n \n-    fn dep_node_str(&self, dep_node: DepNode<DefId>) -> DepNode<String> {\n+    fn dep_node_str(&self, dep_node: &DepNode<DefId>) -> DepNode<String> {\n         dep_node.map_def(|&def_id| Some(self.tcx.item_path_str(def_id))).unwrap()\n     }\n \n     fn assert_dirty(&self, item: &hir::Item, dep_node: DepNode<DefId>) {\n         debug!(\"assert_dirty({:?})\", dep_node);\n \n-        if self.query.contains_node(&dep_node) {\n-            let dep_node_str = self.dep_node_str(dep_node);\n-            self.tcx.sess.span_err(\n-                item.span,\n-                &format!(\"`{:?}` found in dep graph, but should be dirty\", dep_node_str));\n+        match dep_node {\n+            DepNode::Hir(_) => {\n+                // HIR nodes are inputs, so if we are asserting that the HIR node is\n+                // dirty, we check the dirty input set.\n+                if !self.dirty_inputs.contains(&dep_node) {\n+                    let dep_node_str = self.dep_node_str(&dep_node);\n+                    self.tcx.sess.span_err(\n+                        item.span,\n+                        &format!(\"`{:?}` not found in dirty set, but should be dirty\",\n+                                 dep_node_str));\n+                }\n+            }\n+            _ => {\n+                // Other kinds of nodes would be targets, so check if\n+                // the dep-graph contains the node.\n+                if self.query.contains_node(&dep_node) {\n+                    let dep_node_str = self.dep_node_str(&dep_node);\n+                    self.tcx.sess.span_err(\n+                        item.span,\n+                        &format!(\"`{:?}` found in dep graph, but should be dirty\", dep_node_str));\n+                }\n+            }\n         }\n     }\n \n     fn assert_clean(&self, item: &hir::Item, dep_node: DepNode<DefId>) {\n         debug!(\"assert_clean({:?})\", dep_node);\n \n-        if !self.query.contains_node(&dep_node) {\n-            let dep_node_str = self.dep_node_str(dep_node);\n-            self.tcx.sess.span_err(\n-                item.span,\n-                &format!(\"`{:?}` not found in dep graph, but should be clean\", dep_node_str));\n+        match dep_node {\n+            DepNode::Hir(_) => {\n+                // For HIR nodes, check the inputs.\n+                if self.dirty_inputs.contains(&dep_node) {\n+                    let dep_node_str = self.dep_node_str(&dep_node);\n+                    self.tcx.sess.span_err(\n+                        item.span,\n+                        &format!(\"`{:?}` found in dirty-node set, but should be clean\",\n+                                 dep_node_str));\n+                }\n+            }\n+            _ => {\n+                // Otherwise, check if the dep-node exists.\n+                if !self.query.contains_node(&dep_node) {\n+                    let dep_node_str = self.dep_node_str(&dep_node);\n+                    self.tcx.sess.span_err(\n+                        item.span,\n+                        &format!(\"`{:?}` not found in dep graph, but should be clean\",\n+                                 dep_node_str));\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "79b90b63dc608d8b238eea13d3b84ac3f890c9d8", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=561c4e1dd3f39434085d7958a69628600a71937c", "patch": "@@ -28,7 +28,7 @@ use super::dirty_clean;\n use super::hash::*;\n use super::util::*;\n \n-type DirtyNodes = FnvHashSet<DepNode<DefPathIndex>>;\n+pub type DirtyNodes = FnvHashSet<DepNode<DefPathIndex>>;\n \n type CleanEdges = Vec<(DepNode<DefId>, DepNode<DefId>)>;\n \n@@ -45,7 +45,6 @@ pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     let _ignore = tcx.dep_graph.in_ignore();\n     load_dep_graph_if_exists(tcx);\n-    dirty_clean::check_dirty_clean_annotations(tcx);\n }\n \n fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -62,7 +61,7 @@ fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     };\n \n     match decode_dep_graph(tcx, &dep_graph_data, &work_products_data) {\n-        Ok(()) => return,\n+        Ok(dirty_nodes) => dirty_nodes,\n         Err(err) => {\n             tcx.sess.warn(\n                 &format!(\"decoding error in dep-graph from `{}` and `{}`: {}\",\n@@ -184,6 +183,8 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let work_products = try!(<Vec<SerializedWorkProduct>>::decode(&mut work_product_decoder));\n     reconcile_work_products(tcx, work_products, &dirty_target_nodes);\n \n+    dirty_clean::check_dirty_clean_annotations(tcx, &dirty_raw_source_nodes, &retraced);\n+\n     Ok(())\n }\n "}, {"sha": "860e569ba7e5e3dc6ed477f30d53d607cd902931", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=561c4e1dd3f39434085d7958a69628600a71937c", "patch": "@@ -1005,7 +1005,7 @@ pub struct Resolver<'a> {\n     //\n     // There will be an anonymous module created around `g` with the ID of the\n     // entry block for `f`.\n-    pub module_map: NodeMap<Module<'a>>,\n+    module_map: NodeMap<Module<'a>>,\n \n     // Whether or not to print error messages. Can be set to true\n     // when getting additional info for error message suggestions,"}, {"sha": "648d1f42fb5208322843c8a3d41791ae357ef2aa", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=561c4e1dd3f39434085d7958a69628600a71937c", "patch": "@@ -580,7 +580,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                                          -> Result<(), MethodError<'tcx>>\n     {\n         let mut duplicates = HashSet::new();\n-        let opt_applicable_traits = self.ccx.trait_map.get(&expr_id);\n+        let opt_applicable_traits = self.tcx.trait_map.get(&expr_id);\n         if let Some(applicable_traits) = opt_applicable_traits {\n             for trait_candidate in applicable_traits {\n                 let trait_did = trait_candidate.def_id;"}, {"sha": "eac26487ea3afd7a19bbc7a036249f9a0f3c38c6", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561c4e1dd3f39434085d7958a69628600a71937c/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=561c4e1dd3f39434085d7958a69628600a71937c", "patch": "@@ -139,9 +139,6 @@ pub struct TypeAndSubsts<'tcx> {\n pub struct CrateCtxt<'a, 'tcx: 'a> {\n     ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n \n-    /// A mapping from method call sites to traits that have that method.\n-    pub trait_map: hir::TraitMap,\n-\n     /// A vector of every trait accessible in the whole crate\n     /// (i.e. including those from subcrates). This is used only for\n     /// error reporting, and so is lazily initialised and generally\n@@ -321,13 +318,11 @@ fn check_for_entry_fn(ccx: &CrateCtxt) {\n     }\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             trait_map: hir::TraitMap)\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                              -> CompileResult {\n     let time_passes = tcx.sess.time_passes();\n     let ccx = CrateCtxt {\n         ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n-        trait_map: trait_map,\n         all_traits: RefCell::new(None),\n         stack: RefCell::new(Vec::new()),\n         tcx: tcx"}, {"sha": "f28ecf74dd47d38a53b60d8f5b43b13841ef44ec", "filename": "src/test/incremental/ich_method_call_trait_scope.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/561c4e1dd3f39434085d7958a69628600a71937c/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561c4e1dd3f39434085d7958a69628600a71937c/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs?ref=561c4e1dd3f39434085d7958a69628600a71937c", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the hash for a method call is sensitive to the traits in\n+// scope.\n+\n+// revisions: rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+\n+fn test<T>() { }\n+\n+trait Trait1 {\n+    fn method(&self) { }\n+}\n+\n+impl Trait1 for () { }\n+\n+trait Trait2 {\n+    fn method(&self) { }\n+}\n+\n+impl Trait2 for () { }\n+\n+#[cfg(rpass1)]\n+mod mod3 {\n+    use Trait1;\n+\n+    fn bar() {\n+        ().method();\n+    }\n+\n+    fn baz() {\n+        22; // no method call, traits in scope don't matter\n+    }\n+}\n+\n+#[cfg(rpass2)]\n+mod mod3 {\n+    use Trait2;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"rpass2\")]\n+    fn bar() {\n+        ().method();\n+    }\n+\n+    #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+    fn baz() {\n+        22; // no method call, traits in scope don't matter\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "4466cfb1317d961d6b24919a9a21d1e02a92c37b", "filename": "src/test/incremental/ich_nested_items.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/561c4e1dd3f39434085d7958a69628600a71937c/src%2Ftest%2Fincremental%2Fich_nested_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561c4e1dd3f39434085d7958a69628600a71937c/src%2Ftest%2Fincremental%2Fich_nested_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fich_nested_items.rs?ref=561c4e1dd3f39434085d7958a69628600a71937c", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the hash of `foo` doesn't change just because we ordered\n+// the nested items (or even added new ones).\n+\n+// revisions: rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+\n+#[cfg(rpass1)]\n+fn foo() {\n+    fn bar() { }\n+    fn baz() { }\n+}\n+\n+#[cfg(rpass2)]\n+#[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+fn foo() {\n+    #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+    fn baz() { } // order is different...\n+\n+    #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+    fn bar() { } // but that doesn't matter.\n+\n+    fn bap() { } // neither does adding a new item\n+}\n+\n+fn main() { }"}, {"sha": "680a91da09f92cdada3c8d74ddc1818157c3c28d", "filename": "src/test/incremental/ich_resolve_results.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/561c4e1dd3f39434085d7958a69628600a71937c/src%2Ftest%2Fincremental%2Fich_resolve_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561c4e1dd3f39434085d7958a69628600a71937c/src%2Ftest%2Fincremental%2Fich_resolve_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fich_resolve_results.rs?ref=561c4e1dd3f39434085d7958a69628600a71937c", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the hash for `mod3::bar` changes when we change the\n+// `use` to something different.\n+\n+// revisions: rpass1 rpass2 rpass3\n+\n+#![feature(rustc_attrs)]\n+\n+fn test<T>() { }\n+\n+mod mod1 {\n+    pub struct Foo(pub u32);\n+}\n+\n+mod mod2 {\n+    pub struct Foo(pub i64);\n+}\n+\n+#[cfg(rpass1)]\n+mod mod3 {\n+    use test;\n+    use mod1::Foo;\n+\n+    fn in_expr() {\n+        Foo(0);\n+    }\n+\n+    fn in_type() {\n+        test::<Foo>();\n+    }\n+}\n+\n+#[cfg(rpass2)]\n+mod mod3 {\n+    use mod1::Foo; // <-- Nothing changed, but reordered!\n+    use test;\n+\n+    #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+    fn in_expr() {\n+        Foo(0);\n+    }\n+\n+    #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+    fn in_type() {\n+        test::<Foo>();\n+    }\n+}\n+\n+#[cfg(rpass3)]\n+mod mod3 {\n+    use test;\n+    use mod2::Foo; // <-- This changed!\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"rpass3\")]\n+    fn in_expr() {\n+        Foo(0);\n+    }\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"rpass3\")]\n+    fn in_type() {\n+        test::<Foo>();\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "72072248ec05f2990c2bfe1e026e882319b32b6c", "filename": "src/test/incremental/string_constant.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/561c4e1dd3f39434085d7958a69628600a71937c/src%2Ftest%2Fincremental%2Fstring_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561c4e1dd3f39434085d7958a69628600a71937c/src%2Ftest%2Fincremental%2Fstring_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstring_constant.rs?ref=561c4e1dd3f39434085d7958a69628600a71937c", "patch": "@@ -41,8 +41,10 @@ mod x {\n mod y {\n     use x;\n \n-    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n-    #[rustc_clean(label=\"TransCrateItem\", cfg=\"rpass2\")]\n+    // FIXME(#35078) -- when body of `x` changes, we treat it as\n+    // though signature changed.\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_dirty(label=\"TransCrateItem\", cfg=\"rpass2\")]\n     pub fn y() {\n         x::x();\n     }"}]}