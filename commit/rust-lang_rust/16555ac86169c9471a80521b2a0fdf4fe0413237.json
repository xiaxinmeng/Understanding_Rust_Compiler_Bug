{"sha": "16555ac86169c9471a80521b2a0fdf4fe0413237", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NTU1YWM4NjE2OWM5NDcxYTgwNTIxYjJhMGZkZjRmZTA0MTMyMzc=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-02-05T12:14:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-05T12:14:28Z"}, "message": "Rollup merge of #68809 - ecstatic-morse:const-int-functions, r=oli-obk\n\nMake more arithmetic functions unstably const\n\nThis is a smaller version of #66884 (thanks @9999years) that constifies many of the arithmetic functions on integer primitives from #53718 that were blocked on #49146.\n\nThis makes the following things unstably const.\n\n- `feature = const_int_unchecked_arith`\n  - `intrinsics::unchecked_add`\n  - `intrinsics::unchecked_sub`\n  - `intrinsics::unchecked_mul`\n  - `intrinsics::unchecked_div`\n  - `intrinsics::unchecked_rem`\n\n- `feature = const_checked_int_methods`\n  - `checked_add`\n  - `checked_sub`\n  - `checked_mul`\n  - `checked_div` (Uses `intrinsics::unchecked_div` internally)\n  - `checked_rem` (Uses `intrinsics::unchecked_rem` internally)\n  - `checked_neg`\n  - `checked_shl`\n  - `checked_shr`\n  - `checked_abs`\n\n- `feature = const_saturating_int_methods`\n  - `saturating_mul`\n  - `saturating_neg`  (Uses `intrinsics::unchecked_sub` internally)\n  - `saturating_abs` (Uses `intrinsics::unchecked_sub` internally)\n\n- `feature = const_wrapping_int_methods`\n  - `wrapping_div`\n  - `wrapping_rem`\n\n- `feature = const_overflowing_int_methods`\n  - `overflowing_div`\n  - `overflowing_rem`\n\n- `feature = const_euclidean_int_methods`\n  - `checked_div_euclid`\n  - `checked_rem_euclid`\n  - `wrapping_div_euclid`\n  - `wrapping_rem_euclid`\n  - `overflowing_div_euclid`\n  - `overflowing_rem_euclid`\n\nExponentiation and operations on the `NonZero` types are left to a later PR.\n\nr? @oli-obk\ncc @rust-lang/wg-const-eval @rust-lang/libs", "tree": {"sha": "6cae779e1680f97f980138b21dd39e6eb2fde635", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cae779e1680f97f980138b21dd39e6eb2fde635"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16555ac86169c9471a80521b2a0fdf4fe0413237", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeOrGkCRBK7hj4Ov3rIwAAdHIIAAHsM9PPQXF24SepDteX6b8h\nBhpafTIi5dTGmRlwr3SvwDFm6ln4DbGe8imF70FcKyiP+CE0idZI4hwzWVxwG47+\nZRlZwzbsxUF60ZVr6rQGyKQ/MQtc49/7JayI9fQyfOaE4YMOHY6Y+Q8iV7F3iTVy\nbUuIsIcB2Bt8CBEyKQYwvlE/gY4JBZDRHPAIL/c95iAE/AGN3X8CXz42hqrwsQsF\ntx50NLWRTBVPSBHcCikMVXGjJEP9p//7T/JcSwgGTixbF2HKOi4yAgRZ36SSw/mj\nSd+aqL3sqYkK/2Px9wN/zFKABnHdAwqptuzfa81c5bTqz+kfgqfmsjmQwUYMjMA=\n=uXw1\n-----END PGP SIGNATURE-----\n", "payload": "tree 6cae779e1680f97f980138b21dd39e6eb2fde635\nparent c1779412fa97a1d5ecded57dd43c5f802e21de89\nparent 78f8ad36409754319011514ca6febc8599abd429\nauthor Dylan DPC <dylan.dpc@gmail.com> 1580904868 +0100\ncommitter GitHub <noreply@github.com> 1580904868 +0100\n\nRollup merge of #68809 - ecstatic-morse:const-int-functions, r=oli-obk\n\nMake more arithmetic functions unstably const\n\nThis is a smaller version of #66884 (thanks @9999years) that constifies many of the arithmetic functions on integer primitives from #53718 that were blocked on #49146.\n\nThis makes the following things unstably const.\n\n- `feature = const_int_unchecked_arith`\n  - `intrinsics::unchecked_add`\n  - `intrinsics::unchecked_sub`\n  - `intrinsics::unchecked_mul`\n  - `intrinsics::unchecked_div`\n  - `intrinsics::unchecked_rem`\n\n- `feature = const_checked_int_methods`\n  - `checked_add`\n  - `checked_sub`\n  - `checked_mul`\n  - `checked_div` (Uses `intrinsics::unchecked_div` internally)\n  - `checked_rem` (Uses `intrinsics::unchecked_rem` internally)\n  - `checked_neg`\n  - `checked_shl`\n  - `checked_shr`\n  - `checked_abs`\n\n- `feature = const_saturating_int_methods`\n  - `saturating_mul`\n  - `saturating_neg`  (Uses `intrinsics::unchecked_sub` internally)\n  - `saturating_abs` (Uses `intrinsics::unchecked_sub` internally)\n\n- `feature = const_wrapping_int_methods`\n  - `wrapping_div`\n  - `wrapping_rem`\n\n- `feature = const_overflowing_int_methods`\n  - `overflowing_div`\n  - `overflowing_rem`\n\n- `feature = const_euclidean_int_methods`\n  - `checked_div_euclid`\n  - `checked_rem_euclid`\n  - `wrapping_div_euclid`\n  - `wrapping_rem_euclid`\n  - `overflowing_div_euclid`\n  - `overflowing_rem_euclid`\n\nExponentiation and operations on the `NonZero` types are left to a later PR.\n\nr? @oli-obk\ncc @rust-lang/wg-const-eval @rust-lang/libs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16555ac86169c9471a80521b2a0fdf4fe0413237", "html_url": "https://github.com/rust-lang/rust/commit/16555ac86169c9471a80521b2a0fdf4fe0413237", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16555ac86169c9471a80521b2a0fdf4fe0413237/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1779412fa97a1d5ecded57dd43c5f802e21de89", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1779412fa97a1d5ecded57dd43c5f802e21de89", "html_url": "https://github.com/rust-lang/rust/commit/c1779412fa97a1d5ecded57dd43c5f802e21de89"}, {"sha": "78f8ad36409754319011514ca6febc8599abd429", "url": "https://api.github.com/repos/rust-lang/rust/commits/78f8ad36409754319011514ca6febc8599abd429", "html_url": "https://github.com/rust-lang/rust/commit/78f8ad36409754319011514ca6febc8599abd429"}], "stats": {"total": 311, "additions": 260, "deletions": 51}, "files": [{"sha": "2cee23a5c752c9d3ef93193870a01b7992b730aa", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16555ac86169c9471a80521b2a0fdf4fe0413237/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16555ac86169c9471a80521b2a0fdf4fe0413237/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=16555ac86169c9471a80521b2a0fdf4fe0413237", "patch": "@@ -1305,9 +1305,11 @@ extern \"rust-intrinsic\" {\n \n     /// Performs an unchecked division, resulting in undefined behavior\n     /// where y = 0 or x = `T::min_value()` and y = -1\n+    #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_div<T>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n     /// undefined behavior where y = 0 or x = `T::min_value()` and y = -1\n+    #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_rem<T>(x: T, y: T) -> T;\n \n     /// Performs an unchecked left shift, resulting in undefined behavior when\n@@ -1321,14 +1323,17 @@ extern \"rust-intrinsic\" {\n \n     /// Returns the result of an unchecked addition, resulting in\n     /// undefined behavior when `x + y > T::max_value()` or `x + y < T::min_value()`.\n+    #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_add<T>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked subtraction, resulting in\n     /// undefined behavior when `x - y > T::max_value()` or `x - y < T::min_value()`.\n+    #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_sub<T>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked multiplication, resulting in\n     /// undefined behavior when `x * y > T::max_value()` or `x * y < T::min_value()`.\n+    #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_mul<T>(x: T, y: T) -> T;\n \n     /// Performs rotate left."}, {"sha": "1fd70e1a1b049aeadef92fe39f5922e2a0131f5f", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16555ac86169c9471a80521b2a0fdf4fe0413237/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16555ac86169c9471a80521b2a0fdf4fe0413237/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=16555ac86169c9471a80521b2a0fdf4fe0413237", "patch": "@@ -72,6 +72,11 @@\n #![feature(concat_idents)]\n #![feature(const_alloc_layout)]\n #![feature(const_if_match)]\n+#![feature(const_checked_int_methods)]\n+#![feature(const_euclidean_int_methods)]\n+#![feature(const_overflowing_int_methods)]\n+#![feature(const_saturating_int_methods)]\n+#![feature(const_int_unchecked_arith)]\n #![feature(const_panic)]\n #![feature(const_fn_union)]\n #![feature(const_generics)]"}, {"sha": "ed37b48b3e8556fbb45733f3376d23531a2889f7", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 98, "deletions": 49, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/16555ac86169c9471a80521b2a0fdf4fe0413237/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16555ac86169c9471a80521b2a0fdf4fe0413237/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=16555ac86169c9471a80521b2a0fdf4fe0413237", "patch": "@@ -701,10 +701,11 @@ assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_add(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_add(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -725,10 +726,11 @@ assert_eq!((\", stringify!($SelfT), \"::min_value() + 2).checked_sub(3), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_sub(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -749,10 +751,11 @@ assert_eq!(\", stringify!($SelfT), \"::max_value().checked_mul(2), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_mul(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -774,10 +777,11 @@ assert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_div(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                     None\n                 } else {\n@@ -802,10 +806,11 @@ assert_eq!(\", stringify!($SelfT), \"::min_value().checked_div_euclid(-1), None);\n assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                     None\n                 } else {\n@@ -831,10 +836,11 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                     None\n                 } else {\n@@ -860,10 +866,11 @@ assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                     None\n                 } else {\n@@ -887,8 +894,9 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.checked_neg(), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[inline]\n-            pub fn checked_neg(self) -> Option<Self> {\n+            pub const fn checked_neg(self) -> Option<Self> {\n                 let (a, b) = self.overflowing_neg();\n                 if b {None} else {Some(a)}\n             }\n@@ -908,10 +916,11 @@ assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(129), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n+            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shl(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -931,10 +940,11 @@ assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(128), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n+            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shr(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -956,8 +966,9 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.checked_abs(), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[inline]\n-            pub fn checked_abs(self) -> Option<Self> {\n+            pub const fn checked_abs(self) -> Option<Self> {\n                 if self.is_negative() {\n                     self.checked_neg()\n                 } else {\n@@ -1080,8 +1091,9 @@ $EndFeature, \"\n ```\"),\n \n             #[unstable(feature = \"saturating_neg\", issue = \"59983\")]\n+            #[rustc_const_unstable(feature = \"const_saturating_int_methods\", issue = \"53718\")]\n             #[inline]\n-            pub fn saturating_neg(self) -> Self {\n+            pub const fn saturating_neg(self) -> Self {\n                 intrinsics::saturating_sub(0, self)\n             }\n         }\n@@ -1106,8 +1118,9 @@ $EndFeature, \"\n ```\"),\n \n             #[unstable(feature = \"saturating_neg\", issue = \"59983\")]\n+            #[rustc_const_unstable(feature = \"const_saturating_int_methods\", issue = \"53718\")]\n             #[inline]\n-            pub fn saturating_abs(self) -> Self {\n+            pub const fn saturating_abs(self) -> Self {\n                 if self.is_negative() {\n                     self.saturating_neg()\n                 } else {\n@@ -1133,17 +1146,19 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_mul(10), \", stringify!($Self\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_saturating_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn saturating_mul(self, rhs: Self) -> Self {\n-                self.checked_mul(rhs).unwrap_or_else(|| {\n-                    if (self < 0) == (rhs < 0) {\n+            pub const fn saturating_mul(self, rhs: Self) -> Self {\n+                match self.checked_mul(rhs) {\n+                    Some(x) => x,\n+                    None => if (self < 0) == (rhs < 0) {\n                         Self::max_value()\n                     } else {\n                         Self::min_value()\n                     }\n-                })\n+                }\n             }\n         }\n \n@@ -1269,10 +1284,11 @@ assert_eq!((-128i8).wrapping_div(-1), -128);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_unstable(feature = \"const_wrapping_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_div(self, rhs: Self) -> Self {\n+            pub const fn wrapping_div(self, rhs: Self) -> Self {\n                 self.overflowing_div(rhs).0\n             }\n         }\n@@ -1298,10 +1314,11 @@ assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n assert_eq!((-128i8).wrapping_div_euclid(-1), -128);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_div_euclid(self, rhs: Self) -> Self {\n+            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n                 self.overflowing_div_euclid(rhs).0\n             }\n         }\n@@ -1328,10 +1345,11 @@ assert_eq!((-128i8).wrapping_rem(-1), 0);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_unstable(feature = \"const_wrapping_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_rem(self, rhs: Self) -> Self {\n+            pub const fn wrapping_rem(self, rhs: Self) -> Self {\n                 self.overflowing_rem(rhs).0\n             }\n         }\n@@ -1356,10 +1374,11 @@ assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n assert_eq!((-128i8).wrapping_rem_euclid(-1), 0);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n+            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n                 self.overflowing_rem_euclid(rhs).0\n             }\n         }\n@@ -1635,9 +1654,10 @@ $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_overflowing_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n-            pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n+            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (self, true)\n                 } else {\n@@ -1669,9 +1689,10 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringi\n ```\"),\n             #[inline]\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n-            pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n+            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (self, true)\n                 } else {\n@@ -1703,9 +1724,10 @@ $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_overflowing_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n-            pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n+            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (0, true)\n                 } else {\n@@ -1736,10 +1758,11 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n+            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (0, true)\n                 } else {\n@@ -1981,11 +2004,12 @@ assert_eq!((-a).div_euclid(b), -2); // -7 >= 4 * -2\n assert_eq!((-a).div_euclid(-b), 2); // -7 >= -4 * 2\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn div_euclid(self, rhs: Self) -> Self {\n+            pub const fn div_euclid(self, rhs: Self) -> Self {\n                 let q = self / rhs;\n                 if self % rhs < 0 {\n                     return if rhs > 0 { q - 1 } else { q + 1 }\n@@ -2020,11 +2044,12 @@ assert_eq!(a.rem_euclid(-b), 3);\n assert_eq!((-a).rem_euclid(-b), 1);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn rem_euclid(self, rhs: Self) -> Self {\n+            pub const fn rem_euclid(self, rhs: Self) -> Self {\n                 let r = self % rhs;\n                 if r < 0 {\n                     if rhs < 0 {\n@@ -2847,10 +2872,11 @@ Basic usage:\n assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_add(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_add(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -2869,10 +2895,11 @@ Basic usage:\n assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_sub(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -2891,10 +2918,11 @@ Basic usage:\n assert_eq!(\", stringify!($SelfT), \"::max_value().checked_mul(2), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_mul(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -2913,10 +2941,11 @@ Basic usage:\n assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_div(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n                 match rhs {\n                     0 => None,\n                     // SAFETY: div by zero has been checked above and unsigned types have no other\n@@ -2939,10 +2968,11 @@ assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\n assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 {\n                     None\n                 } else {\n@@ -2965,10 +2995,11 @@ Basic usage:\n assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 {\n                     None\n                 } else {\n@@ -2992,10 +3023,11 @@ assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\n assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 {\n                     None\n                 } else {\n@@ -3019,8 +3051,9 @@ Basic usage:\n assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[inline]\n-            pub fn checked_neg(self) -> Option<Self> {\n+            pub const fn checked_neg(self) -> Option<Self> {\n                 let (a, b) = self.overflowing_neg();\n                 if b {None} else {Some(a)}\n             }\n@@ -3039,10 +3072,11 @@ Basic usage:\n assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n+            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shl(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -3061,10 +3095,11 @@ Basic usage:\n assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n+            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shr(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -3170,11 +3205,15 @@ assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($Se\n \"::MAX);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_saturating_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn saturating_mul(self, rhs: Self) -> Self {\n-                self.checked_mul(rhs).unwrap_or(Self::max_value())\n+            pub const fn saturating_mul(self, rhs: Self) -> Self {\n+                match self.checked_mul(rhs) {\n+                    Some(x) => x,\n+                    None => Self::max_value(),\n+                }\n             }\n         }\n \n@@ -3289,10 +3328,11 @@ Basic usage:\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_unstable(feature = \"const_wrapping_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_div(self, rhs: Self) -> Self {\n+            pub const fn wrapping_div(self, rhs: Self) -> Self {\n                 self / rhs\n             }\n         }\n@@ -3315,10 +3355,11 @@ Basic usage:\n assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_div_euclid(self, rhs: Self) -> Self {\n+            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n                 self / rhs\n             }\n         }\n@@ -3339,10 +3380,11 @@ Basic usage:\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_unstable(feature = \"const_wrapping_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_rem(self, rhs: Self) -> Self {\n+            pub const fn wrapping_rem(self, rhs: Self) -> Self {\n                 self % rhs\n             }\n         }\n@@ -3366,10 +3408,11 @@ Basic usage:\n assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n+            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n                 self % rhs\n             }\n         }\n@@ -3614,9 +3657,10 @@ Basic usage\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_overflowing_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n-            pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n+            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n                 (self / rhs, false)\n             }\n         }\n@@ -3645,9 +3689,10 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\n ```\"),\n             #[inline]\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n-            pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n+            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n                 (self / rhs, false)\n             }\n         }\n@@ -3673,9 +3718,10 @@ Basic usage\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_overflowing_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n-            pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n+            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n                 (self % rhs, false)\n             }\n         }\n@@ -3704,9 +3750,10 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n ```\"),\n             #[inline]\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n-            pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n+            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n                 (self % rhs, false)\n             }\n         }\n@@ -3897,11 +3944,12 @@ Basic usage:\n assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn div_euclid(self, rhs: Self) -> Self {\n+            pub const fn div_euclid(self, rhs: Self) -> Self {\n                 self / rhs\n             }\n         }\n@@ -3926,11 +3974,12 @@ Basic usage:\n assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn rem_euclid(self, rhs: Self) -> Self {\n+            pub const fn rem_euclid(self, rhs: Self) -> Self {\n                 self % rhs\n             }\n         }"}, {"sha": "f85da760ada6d03c5af4262172a761ec422ea0ba", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/16555ac86169c9471a80521b2a0fdf4fe0413237/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16555ac86169c9471a80521b2a0fdf4fe0413237/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=16555ac86169c9471a80521b2a0fdf4fe0413237", "patch": "@@ -218,19 +218,34 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 self.write_scalar(val, dest)?;\n             }\n-            sym::unchecked_shl | sym::unchecked_shr => {\n+            sym::unchecked_shl\n+            | sym::unchecked_shr\n+            | sym::unchecked_add\n+            | sym::unchecked_sub\n+            | sym::unchecked_mul\n+            | sym::unchecked_div\n+            | sym::unchecked_rem => {\n                 let l = self.read_immediate(args[0])?;\n                 let r = self.read_immediate(args[1])?;\n                 let bin_op = match intrinsic_name {\n                     sym::unchecked_shl => BinOp::Shl,\n                     sym::unchecked_shr => BinOp::Shr,\n+                    sym::unchecked_add => BinOp::Add,\n+                    sym::unchecked_sub => BinOp::Sub,\n+                    sym::unchecked_mul => BinOp::Mul,\n+                    sym::unchecked_div => BinOp::Div,\n+                    sym::unchecked_rem => BinOp::Rem,\n                     _ => bug!(\"Already checked for int ops\"),\n                 };\n                 let (val, overflowed, _ty) = self.overflowing_binary_op(bin_op, l, r)?;\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val = self.force_bits(r.to_scalar()?, layout.size)?;\n-                    throw_ub_format!(\"Overflowing shift by {} in `{}`\", r_val, intrinsic_name);\n+                    if let sym::unchecked_shl | sym::unchecked_shr = intrinsic_name {\n+                        throw_ub_format!(\"Overflowing shift by {} in `{}`\", r_val, intrinsic_name);\n+                    } else {\n+                        throw_ub_format!(\"Overflow executing `{}`\", intrinsic_name);\n+                    }\n                 }\n                 self.write_scalar(val, dest)?;\n             }"}, {"sha": "c060e8948e3ed45fd770a518044c5d67d7ddc4c4", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16555ac86169c9471a80521b2a0fdf4fe0413237/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16555ac86169c9471a80521b2a0fdf4fe0413237/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=16555ac86169c9471a80521b2a0fdf4fe0413237", "patch": "@@ -755,8 +755,13 @@ symbols! {\n         u64,\n         u8,\n         unboxed_closures,\n+        unchecked_add,\n+        unchecked_div,\n+        unchecked_mul,\n+        unchecked_rem,\n         unchecked_shl,\n         unchecked_shr,\n+        unchecked_sub,\n         underscore_const_names,\n         underscore_imports,\n         underscore_lifetimes,"}, {"sha": "cfa2873c68bad1ac1dda2fb10fbf22e74711da70", "filename": "src/test/ui/consts/const-int-arithmetic.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/16555ac86169c9471a80521b2a0fdf4fe0413237/src%2Ftest%2Fui%2Fconsts%2Fconst-int-arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16555ac86169c9471a80521b2a0fdf4fe0413237/src%2Ftest%2Fui%2Fconsts%2Fconst-int-arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-arithmetic.rs?ref=16555ac86169c9471a80521b2a0fdf4fe0413237", "patch": "@@ -0,0 +1,130 @@\n+// run-pass\n+\n+#![feature(saturating_neg)]\n+#![feature(const_checked_int_methods)]\n+#![feature(const_euclidean_int_methods)]\n+#![feature(const_overflowing_int_methods)]\n+#![feature(const_saturating_int_methods)]\n+#![feature(const_wrapping_int_methods)]\n+\n+use std::i8;\n+\n+macro_rules! suite {\n+    ($(\n+        $fn:ident -> $ty:ty { $( $label:ident : $expr:expr, $result:expr; )* }\n+    )*) => { $(\n+        fn $fn() {\n+            $(\n+                const $label: $ty = $expr;\n+                assert_eq!($label, $result);\n+            )*\n+        }\n+    )* }\n+}\n+\n+suite!(\n+    checked -> Option<i8> {\n+        // `const_checked_int_methods`\n+        C1: 5i8.checked_add(2), Some(7);\n+        C2: 127i8.checked_add(2), None;\n+\n+        C3: 5i8.checked_sub(2), Some(3);\n+        C4: (-127i8).checked_sub(2), None;\n+\n+        C5: 1i8.checked_mul(3), Some(3);\n+        C6: 5i8.checked_mul(122), None;\n+        C7: (-127i8).checked_mul(-99), None;\n+\n+        C8: (i8::min_value() + 1).checked_div(-1), Some(127);\n+        C9: i8::min_value().checked_div(-1), None;\n+        C10: 1i8.checked_div(0), None;\n+\n+        C11: 5i8.checked_rem(2), Some(1);\n+        C12: 5i8.checked_rem(0), None;\n+        C13: i8::MIN.checked_rem(-1), None;\n+\n+        C14: 5i8.checked_neg(), Some(-5);\n+        C15: i8::MIN.checked_neg(), None;\n+\n+        C16: 0x1i8.checked_shl(4), Some(0x10);\n+        C17: 0x1i8.checked_shl(129), None;\n+\n+        C18: 0x10i8.checked_shr(4), Some(0x1);\n+        C19: 0x10i8.checked_shr(128), None;\n+\n+\n+        C20: (-5i8).checked_abs(), Some(5);\n+        C21: i8::MIN.checked_abs(), None;\n+\n+        // `const_euclidean_int_methods`\n+        C22: (i8::min_value() + 1).checked_div_euclid(-1), Some(127);\n+        C23: i8::min_value().checked_div_euclid(-1), None;\n+        C24: (1i8).checked_div_euclid(0), None;\n+\n+        C25: 5i8.checked_rem_euclid(2), Some(1);\n+        C26: 5i8.checked_rem_euclid(0), None;\n+        C27: i8::MIN.checked_rem_euclid(-1), None;\n+    }\n+\n+    saturating_and_wrapping -> i8 {\n+        // `const_saturating_int_methods`\n+        C28: 100i8.saturating_add(1), 101;\n+        C29: i8::max_value().saturating_add(100), i8::max_value();\n+        C30: i8::min_value().saturating_add(-1), i8::min_value();\n+\n+        C31: 100i8.saturating_sub(127), -27;\n+        C32: i8::min_value().saturating_sub(100), i8::min_value();\n+        C33: i8::max_value().saturating_sub(-1), i8::max_value();\n+\n+        C34: 10i8.saturating_mul(12), 120;\n+        C35: i8::MAX.saturating_mul(10), i8::MAX;\n+        C36: i8::MIN.saturating_mul(10), i8::MIN;\n+\n+        C37: 100i8.saturating_neg(), -100;\n+        C38: (-100i8).saturating_neg(), 100;\n+        C39: i8::min_value().saturating_neg(), i8::max_value();\n+        C40: i8::max_value().saturating_neg(), i8::min_value() + 1;\n+\n+        C57: 100i8.saturating_abs(), 100;\n+        C58: (-100i8).saturating_abs(), 100;\n+        C59: i8::min_value().saturating_abs(), i8::max_value();\n+        C60: (i8::min_value() + 1).saturating_abs(), i8::max_value();\n+\n+        // `const_wrapping_int_methods`\n+        C41: 100i8.wrapping_div(10), 10;\n+        C42: (-128i8).wrapping_div(-1), -128;\n+\n+        C43: 100i8.wrapping_rem(10), 0;\n+        C44: (-128i8).wrapping_rem(-1), 0;\n+\n+        // `const_euclidean_int_methods`\n+        C45: 100i8.wrapping_div_euclid(10), 10;\n+        C46: (-128i8).wrapping_div_euclid(-1), -128;\n+\n+        C47: 100i8.wrapping_rem_euclid(10), 0;\n+        C48: (-128i8).wrapping_rem_euclid(-1), 0;\n+    }\n+\n+    overflowing -> (i8, bool) {\n+        // `const_overflowing_int_methods`\n+        C49: 5i8.overflowing_div(2), (2, false);\n+        C50: i8::MIN.overflowing_div(-1), (i8::MIN, true);\n+\n+        C51: 5i8.overflowing_rem(2), (1, false);\n+        C52: i8::MIN.overflowing_rem(-1), (0, true);\n+\n+        // `const_euclidean_int_methods`\n+        C53: 5i8.overflowing_div_euclid(2), (2, false);\n+        C54: i8::MIN.overflowing_div_euclid(-1), (i8::MIN, true);\n+\n+        C55: 5i8.overflowing_rem_euclid(2), (1, false);\n+        C56: i8::MIN.overflowing_rem_euclid(-1), (0, true);\n+\n+    }\n+);\n+\n+fn main() {\n+   checked();\n+   saturating_and_wrapping();\n+   overflowing();\n+}"}]}