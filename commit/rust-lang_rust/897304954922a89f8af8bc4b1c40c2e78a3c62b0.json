{"sha": "897304954922a89f8af8bc4b1c40c2e78a3c62b0", "node_id": "C_kwDOAAsO6NoAKDg5NzMwNDk1NDkyMmE4OWY4YWY4YmM0YjFjNDBjMmU3OGEzYzYyYjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-20T16:19:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-20T16:19:06Z"}, "message": "Auto merge of #108268 - matthiaskrgr:rollup-4tdvnx6, r=matthiaskrgr\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #108124 (Document that CStr::as_ptr returns a type alias)\n - #108171 (Improve building compiler artifacts output)\n - #108200 (Use restricted Damerau-Levenshtein distance for diagnostics)\n - #108259 (remove FIXME that doesn't require fixing)\n - #108265 (\"`const` generic\" -> \"const parameter\")\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "87918ed6485ab750b6c488610827adeb8af44dd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87918ed6485ab750b6c488610827adeb8af44dd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/897304954922a89f8af8bc4b1c40c2e78a3c62b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/897304954922a89f8af8bc4b1c40c2e78a3c62b0", "html_url": "https://github.com/rust-lang/rust/commit/897304954922a89f8af8bc4b1c40c2e78a3c62b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/897304954922a89f8af8bc4b1c40c2e78a3c62b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "267cd1d2c5abf5f0d825822a4179ba807b69ffb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/267cd1d2c5abf5f0d825822a4179ba807b69ffb4", "html_url": "https://github.com/rust-lang/rust/commit/267cd1d2c5abf5f0d825822a4179ba807b69ffb4"}, {"sha": "e4dadd6416baad14b8cfa559d8872dd8dd9ed4d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4dadd6416baad14b8cfa559d8872dd8dd9ed4d4", "html_url": "https://github.com/rust-lang/rust/commit/e4dadd6416baad14b8cfa559d8872dd8dd9ed4d4"}], "stats": {"total": 831, "additions": 506, "deletions": 325}, "files": [{"sha": "4a0e005b8b90220c1befaeda82a973fa76218d06", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::PredicateOrigin;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::ty::{DefIdTree, ResolverAstLowering, TyCtxt};\n-use rustc_span::lev_distance::find_best_match_for_name;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{Span, Symbol};"}, {"sha": "a68e0e0ac5bd058afaa9b4c4fc2e0529659502db", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::traits::FulfillmentError;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::parse::feature_err;\n-use rustc_span::lev_distance::find_best_match_for_name;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, Symbol, DUMMY_SP};\n "}, {"sha": "630becc09d26e482b976c15f90427cec30294a72", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -6,7 +6,7 @@ use crate::astconv::{\n use crate::errors::AssocTypeBindingNotAllowed;\n use crate::structured_errors::{GenericArgsInfo, StructuredDiagnostic, WrongNumberOfGenericArgs};\n use rustc_ast::ast::ParamKindOrd;\n-use rustc_errors::{struct_span_err, Applicability, Diagnostic, MultiSpan};\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -26,7 +26,7 @@ fn generic_arg_mismatch_err(\n     param: &GenericParamDef,\n     possible_ordering_error: bool,\n     help: Option<&str>,\n-) {\n+) -> ErrorGuaranteed {\n     let sess = tcx.sess;\n     let mut err = struct_span_err!(\n         sess,\n@@ -70,9 +70,9 @@ fn generic_arg_mismatch_err(\n         ) => match path.res {\n             Res::Err => {\n                 add_braces_suggestion(arg, &mut err);\n-                err.set_primary_message(\"unresolved item provided when a constant was expected\")\n+                return err\n+                    .set_primary_message(\"unresolved item provided when a constant was expected\")\n                     .emit();\n-                return;\n             }\n             Res::Def(DefKind::TyParam, src_def_id) => {\n                 if let Some(param_local_id) = param.def_id.as_local() {\n@@ -81,7 +81,7 @@ fn generic_arg_mismatch_err(\n                     if param_type.is_suggestable(tcx, false) {\n                         err.span_suggestion(\n                             tcx.def_span(src_def_id),\n-                            \"consider changing this type parameter to be a `const` generic\",\n+                            \"consider changing this type parameter to a const parameter\",\n                             format!(\"const {}: {}\", param_name, param_type),\n                             Applicability::MaybeIncorrect,\n                         );\n@@ -137,7 +137,7 @@ fn generic_arg_mismatch_err(\n         }\n     }\n \n-    err.emit();\n+    err.emit()\n }\n \n /// Creates the relevant generic argument substitutions"}, {"sha": "c0cd54cc916e09ae4b397409d934ececb4cb3e87", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -37,8 +37,8 @@ use rustc_middle::ty::DynKind;\n use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{self, Const, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeVisitable};\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECTS};\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{sym, Span, DUMMY_SP};\n use rustc_target::spec::abi;"}, {"sha": "08cbfffdd171b581cf21cf47d75b9ea598c7f647", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -45,8 +45,8 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtKind, Ty, TypeVisitable};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_session::parse::feature_err;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_target::spec::abi::Abi::RustIntrinsic;"}, {"sha": "88af554483b8e71b31bb814f38c72287d77088f5", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -24,8 +24,8 @@ use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_session::lint;\n use rustc_span::def_id::DefId;\n use rustc_span::def_id::LocalDefId;\n-use rustc_span::lev_distance::{\n-    find_best_match_for_name_with_substrings, lev_distance_with_substrings,\n+use rustc_span::edit_distance::{\n+    edit_distance_with_substrings, find_best_match_for_name_with_substrings,\n };\n use rustc_span::symbol::sym;\n use rustc_span::{symbol::Ident, Span, Symbol, DUMMY_SP};\n@@ -69,7 +69,7 @@ struct ProbeContext<'a, 'tcx> {\n     impl_dups: FxHashSet<DefId>,\n \n     /// When probing for names, include names that are close to the\n-    /// requested name (by Levenshtein distance)\n+    /// requested name (by edit distance)\n     allow_similar_names: bool,\n \n     /// Some(candidate) if there is a private candidate\n@@ -1793,7 +1793,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n     /// Similarly to `probe_for_return_type`, this method attempts to find the best matching\n     /// candidate method where the method name may have been misspelled. Similarly to other\n-    /// Levenshtein based suggestions, we provide at most one such suggestion.\n+    /// edit distance based suggestions, we provide at most one such suggestion.\n     fn probe_for_similar_candidate(&mut self) -> Result<Option<ty::AssocItem>, MethodError<'tcx>> {\n         debug!(\"probing for method names similar to {:?}\", self.method_name);\n \n@@ -2024,8 +2024,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         if self.matches_by_doc_alias(x.def_id) {\n                             return true;\n                         }\n-                        match lev_distance_with_substrings(name.as_str(), x.name.as_str(), max_dist)\n-                        {\n+                        match edit_distance_with_substrings(\n+                            name.as_str(),\n+                            x.name.as_str(),\n+                            max_dist,\n+                        ) {\n                             Some(d) => d > 0,\n                             None => false,\n                         }"}, {"sha": "4f3dbe03c052aac1c9c961441e1ec81c61e2d344", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -31,7 +31,7 @@ use rustc_middle::ty::{self, DefIdTree, GenericArgKind, Ty, TyCtxt, TypeVisitabl\n use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n-use rustc_span::{lev_distance, source_map, ExpnKind, FileName, MacroKind, Span};\n+use rustc_span::{edit_distance, source_map, ExpnKind, FileName, MacroKind, Span};\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::OnUnimplementedNote;\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -1014,7 +1014,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // that had unsatisfied trait bounds\n         if unsatisfied_predicates.is_empty() && rcvr_ty.is_enum() {\n             let adt_def = rcvr_ty.ty_adt_def().expect(\"enum is not an ADT\");\n-            if let Some(suggestion) = lev_distance::find_best_match_for_name(\n+            if let Some(suggestion) = edit_distance::find_best_match_for_name(\n                 &adt_def.variants().iter().map(|s| s.name).collect::<Vec<_>>(),\n                 item_name.name,\n                 None,"}, {"sha": "ab6e76ef8aa35932c416a2f82820ab1c244953f5", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -14,8 +14,8 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::{self, Adt, BindingMode, Ty, TypeVisitable};\n use rustc_session::lint::builtin::NON_EXHAUSTIVE_OMITTED_PATTERNS;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{BytePos, DUMMY_SP};"}, {"sha": "475d3601b52ab65263b5fc92e767c71ac7d40049", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -14,8 +14,8 @@ use rustc_session::filesearch::sysroot_candidates;\n use rustc_session::lint::{self, BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::parse::CrateConfig;\n use rustc_session::{early_error, filesearch, output, Session};\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::FileLoader;\n use rustc_span::symbol::{sym, Symbol};\n use session::CompilerIO;"}, {"sha": "aace4974cc935cad3de3cb4957f8a0a6cdcde790", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -39,7 +39,7 @@ use rustc_middle::ty::{self, print::Printer, subst::GenericArg, RegisteredTools,\n use rustc_session::lint::{BuiltinLintDiagnostics, LintExpectationId};\n use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId};\n use rustc_session::Session;\n-use rustc_span::lev_distance::find_best_match_for_name;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{BytePos, Span};\n use rustc_target::abi;"}, {"sha": "f164bb330f3daee79ee8ff506ca26398cc713b46", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -19,8 +19,8 @@ use rustc_errors::{\n     struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, PResult,\n     StashKey,\n };\n+use rustc_span::edit_distance::edit_distance;\n use rustc_span::edition::Edition;\n-use rustc_span::lev_distance::lev_distance;\n use rustc_span::source_map::{self, Span};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n@@ -459,7 +459,8 @@ impl<'a> Parser<'a> {\n                 // Maybe the user misspelled `macro_rules` (issue #91227)\n                 if self.token.is_ident()\n                     && path.segments.len() == 1\n-                    && lev_distance(\"macro_rules\", &path.segments[0].ident.to_string(), 3).is_some()\n+                    && edit_distance(\"macro_rules\", &path.segments[0].ident.to_string(), 2)\n+                        .is_some()\n                 {\n                     err.span_suggestion(\n                         path.span,"}, {"sha": "cd26dbd61901d7819686426200e3b594504696f4", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -21,9 +21,9 @@ use rustc_session::lint::builtin::ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE;\n use rustc_session::lint::builtin::MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::Session;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Span, SyntaxContext};"}, {"sha": "48188b4ba355ec1ea52566e5e0c45274fc5fb071", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -21,8 +21,8 @@ use rustc_middle::span_bug;\n use rustc_middle::ty;\n use rustc_session::lint::builtin::{PUB_USE_OF_PRIVATE_EXTERN_CRATE, UNUSED_IMPORTS};\n use rustc_session::lint::BuiltinLintDiagnostics;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::hygiene::LocalExpnId;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n "}, {"sha": "f8bd289d72f6af1a35bc7e0fb1738bc899d57f08", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -4135,9 +4135,9 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n     fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &'ast Expr) {\n         match expr.kind {\n             ExprKind::Field(_, ident) => {\n-                // FIXME(#6890): Even though you can't treat a method like a\n-                // field, we need to add any trait methods we find that match\n-                // the field name so that we can do some nice error reporting\n+                // #6890: Even though you can't treat a method like a field,\n+                // we need to add any trait methods we find that match the\n+                // field name so that we can do some nice error reporting\n                 // later on in typeck.\n                 let traits = self.traits_in_scope(ident, ValueNS);\n                 self.r.trait_map.insert(expr.id, traits);"}, {"sha": "174a543fe466df57a2371c6be199dac97d999784", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -25,9 +25,9 @@ use rustc_middle::ty::DefIdTree;\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Span};\n \n@@ -542,7 +542,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             }\n         }\n \n-        // Try Levenshtein algorithm.\n+        // Try finding a suitable replacement.\n         let typo_sugg =\n             self.lookup_typo_candidate(path, source.namespace(), is_expected).to_opt_suggestion();\n         if path.len() == 1 && self.self_type_is_available() {\n@@ -770,7 +770,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 _ => {}\n             }\n \n-            // If the trait has a single item (which wasn't matched by Levenshtein), suggest it\n+            // If the trait has a single item (which wasn't matched by the algorithm), suggest it\n             let suggestion = self.get_single_associated_item(&path, &source, is_expected);\n             if !self.r.add_typo_suggestion(err, suggestion, ident_span) {\n                 fallback = !self.let_binding_suggestion(err, ident_span);"}, {"sha": "89f0386e3e97fe934abdfb4d73ee8a0f1b3b34e5", "filename": "compiler/rustc_span/src/edit_distance.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_span%2Fsrc%2Fedit_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_span%2Fsrc%2Fedit_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fedit_distance.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -0,0 +1,229 @@\n+//! Edit distances.\n+//!\n+//! The [edit distance] is a metric for measuring the difference between two strings.\n+//!\n+//! [edit distance]: https://en.wikipedia.org/wiki/Edit_distance\n+\n+// The current implementation is the restricted Damerau-Levenshtein algorithm. It is restricted\n+// because it does not permit modifying characters that have already been transposed. The specific\n+// algorithm should not matter to the caller of the methods, which is why it is not noted in the\n+// documentation.\n+\n+use crate::symbol::Symbol;\n+use std::{cmp, mem};\n+\n+#[cfg(test)]\n+mod tests;\n+\n+/// Finds the [edit distance] between two strings.\n+///\n+/// Returns `None` if the distance exceeds the limit.\n+///\n+/// [edit distance]: https://en.wikipedia.org/wiki/Edit_distance\n+pub fn edit_distance(a: &str, b: &str, limit: usize) -> Option<usize> {\n+    let mut a = &a.chars().collect::<Vec<_>>()[..];\n+    let mut b = &b.chars().collect::<Vec<_>>()[..];\n+\n+    // Ensure that `b` is the shorter string, minimizing memory use.\n+    if a.len() < b.len() {\n+        mem::swap(&mut a, &mut b);\n+    }\n+\n+    let min_dist = a.len() - b.len();\n+    // If we know the limit will be exceeded, we can return early.\n+    if min_dist > limit {\n+        return None;\n+    }\n+\n+    // Strip common prefix.\n+    while let Some(((b_char, b_rest), (a_char, a_rest))) = b.split_first().zip(a.split_first())\n+        && a_char == b_char\n+    {\n+        a = a_rest;\n+        b = b_rest;\n+    }\n+    // Strip common suffix.\n+    while let Some(((b_char, b_rest), (a_char, a_rest))) = b.split_last().zip(a.split_last())\n+        && a_char == b_char\n+    {\n+        a = a_rest;\n+        b = b_rest;\n+    }\n+\n+    // If either string is empty, the distance is the length of the other.\n+    // We know that `b` is the shorter string, so we don't need to check `a`.\n+    if b.len() == 0 {\n+        return Some(min_dist);\n+    }\n+\n+    let mut prev_prev = vec![usize::MAX; b.len() + 1];\n+    let mut prev = (0..=b.len()).collect::<Vec<_>>();\n+    let mut current = vec![0; b.len() + 1];\n+\n+    // row by row\n+    for i in 1..=a.len() {\n+        current[0] = i;\n+        let a_idx = i - 1;\n+\n+        // column by column\n+        for j in 1..=b.len() {\n+            let b_idx = j - 1;\n+\n+            // There is no cost to substitute a character with itself.\n+            let substitution_cost = if a[a_idx] == b[b_idx] { 0 } else { 1 };\n+\n+            current[j] = cmp::min(\n+                // deletion\n+                prev[j] + 1,\n+                cmp::min(\n+                    // insertion\n+                    current[j - 1] + 1,\n+                    // substitution\n+                    prev[j - 1] + substitution_cost,\n+                ),\n+            );\n+\n+            if (i > 1) && (j > 1) && (a[a_idx] == b[b_idx - 1]) && (a[a_idx - 1] == b[b_idx]) {\n+                // transposition\n+                current[j] = cmp::min(current[j], prev_prev[j - 2] + 1);\n+            }\n+        }\n+\n+        // Rotate the buffers, reusing the memory.\n+        [prev_prev, prev, current] = [prev, current, prev_prev];\n+    }\n+\n+    // `prev` because we already rotated the buffers.\n+    let distance = prev[b.len()];\n+    (distance <= limit).then_some(distance)\n+}\n+\n+/// Provides a word similarity score between two words that accounts for substrings being more\n+/// meaningful than a typical edit distance. The lower the score, the closer the match. 0 is an\n+/// identical match.\n+///\n+/// Uses the edit distance between the two strings and removes the cost of the length difference.\n+/// If this is 0 then it is either a substring match or a full word match, in the substring match\n+/// case we detect this and return `1`. To prevent finding meaningless substrings, eg. \"in\" in\n+/// \"shrink\", we only perform this subtraction of length difference if one of the words is not\n+/// greater than twice the length of the other. For cases where the words are close in size but not\n+/// an exact substring then the cost of the length difference is discounted by half.\n+///\n+/// Returns `None` if the distance exceeds the limit.\n+pub fn edit_distance_with_substrings(a: &str, b: &str, limit: usize) -> Option<usize> {\n+    let n = a.chars().count();\n+    let m = b.chars().count();\n+\n+    // Check one isn't less than half the length of the other. If this is true then there is a\n+    // big difference in length.\n+    let big_len_diff = (n * 2) < m || (m * 2) < n;\n+    let len_diff = if n < m { m - n } else { n - m };\n+    let distance = edit_distance(a, b, limit + len_diff)?;\n+\n+    // This is the crux, subtracting length difference means exact substring matches will now be 0\n+    let score = distance - len_diff;\n+\n+    // If the score is 0 but the words have different lengths then it's a substring match not a full\n+    // word match\n+    let score = if score == 0 && len_diff > 0 && !big_len_diff {\n+        1 // Exact substring match, but not a total word match so return non-zero\n+    } else if !big_len_diff {\n+        // Not a big difference in length, discount cost of length difference\n+        score + (len_diff + 1) / 2\n+    } else {\n+        // A big difference in length, add back the difference in length to the score\n+        score + len_diff\n+    };\n+\n+    (score <= limit).then_some(score)\n+}\n+\n+/// Finds the best match for given word in the given iterator where substrings are meaningful.\n+///\n+/// A version of [`find_best_match_for_name`] that uses [`edit_distance_with_substrings`] as the\n+/// score for word similarity. This takes an optional distance limit which defaults to one-third of\n+/// the given word.\n+///\n+/// We use case insensitive comparison to improve accuracy on an edge case with a lower(upper)case\n+/// letters mismatch.\n+pub fn find_best_match_for_name_with_substrings(\n+    candidates: &[Symbol],\n+    lookup: Symbol,\n+    dist: Option<usize>,\n+) -> Option<Symbol> {\n+    find_best_match_for_name_impl(true, candidates, lookup, dist)\n+}\n+\n+/// Finds the best match for a given word in the given iterator.\n+///\n+/// As a loose rule to avoid the obviously incorrect suggestions, it takes\n+/// an optional limit for the maximum allowable edit distance, which defaults\n+/// to one-third of the given word.\n+///\n+/// We use case insensitive comparison to improve accuracy on an edge case with a lower(upper)case\n+/// letters mismatch.\n+pub fn find_best_match_for_name(\n+    candidates: &[Symbol],\n+    lookup: Symbol,\n+    dist: Option<usize>,\n+) -> Option<Symbol> {\n+    find_best_match_for_name_impl(false, candidates, lookup, dist)\n+}\n+\n+#[cold]\n+fn find_best_match_for_name_impl(\n+    use_substring_score: bool,\n+    candidates: &[Symbol],\n+    lookup: Symbol,\n+    dist: Option<usize>,\n+) -> Option<Symbol> {\n+    let lookup = lookup.as_str();\n+    let lookup_uppercase = lookup.to_uppercase();\n+\n+    // Priority of matches:\n+    // 1. Exact case insensitive match\n+    // 2. Edit distance match\n+    // 3. Sorted word match\n+    if let Some(c) = candidates.iter().find(|c| c.as_str().to_uppercase() == lookup_uppercase) {\n+        return Some(*c);\n+    }\n+\n+    let mut dist = dist.unwrap_or_else(|| cmp::max(lookup.len(), 3) / 3);\n+    let mut best = None;\n+    for c in candidates {\n+        match if use_substring_score {\n+            edit_distance_with_substrings(lookup, c.as_str(), dist)\n+        } else {\n+            edit_distance(lookup, c.as_str(), dist)\n+        } {\n+            Some(0) => return Some(*c),\n+            Some(d) => {\n+                dist = d - 1;\n+                best = Some(*c);\n+            }\n+            None => {}\n+        }\n+    }\n+    if best.is_some() {\n+        return best;\n+    }\n+\n+    find_match_by_sorted_words(candidates, lookup)\n+}\n+\n+fn find_match_by_sorted_words(iter_names: &[Symbol], lookup: &str) -> Option<Symbol> {\n+    iter_names.iter().fold(None, |result, candidate| {\n+        if sort_by_words(candidate.as_str()) == sort_by_words(lookup) {\n+            Some(*candidate)\n+        } else {\n+            result\n+        }\n+    })\n+}\n+\n+fn sort_by_words(name: &str) -> String {\n+    let mut split_words: Vec<&str> = name.split('_').collect();\n+    // We are sorting primitive &strs and can use unstable sort here.\n+    split_words.sort_unstable();\n+    split_words.join(\"_\")\n+}"}, {"sha": "c9c7a1f1bf2f687f9a0290cdc6471ddf659ea969", "filename": "compiler/rustc_span/src/edit_distance/tests.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_span%2Fsrc%2Fedit_distance%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_span%2Fsrc%2Fedit_distance%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fedit_distance%2Ftests.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -0,0 +1,80 @@\n+use super::*;\n+\n+#[test]\n+fn test_edit_distance() {\n+    // Test bytelength agnosticity\n+    for c in (0..char::MAX as u32).filter_map(char::from_u32).map(|i| i.to_string()) {\n+        assert_eq!(edit_distance(&c[..], &c[..], usize::MAX), Some(0));\n+    }\n+\n+    let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    let b = \"\\nMary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    let c = \"Mary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    assert_eq!(edit_distance(a, b, usize::MAX), Some(1));\n+    assert_eq!(edit_distance(b, a, usize::MAX), Some(1));\n+    assert_eq!(edit_distance(a, c, usize::MAX), Some(2));\n+    assert_eq!(edit_distance(c, a, usize::MAX), Some(2));\n+    assert_eq!(edit_distance(b, c, usize::MAX), Some(1));\n+    assert_eq!(edit_distance(c, b, usize::MAX), Some(1));\n+}\n+\n+#[test]\n+fn test_edit_distance_limit() {\n+    assert_eq!(edit_distance(\"abc\", \"abcd\", 1), Some(1));\n+    assert_eq!(edit_distance(\"abc\", \"abcd\", 0), None);\n+    assert_eq!(edit_distance(\"abc\", \"xyz\", 3), Some(3));\n+    assert_eq!(edit_distance(\"abc\", \"xyz\", 2), None);\n+}\n+\n+#[test]\n+fn test_method_name_similarity_score() {\n+    assert_eq!(edit_distance_with_substrings(\"empty\", \"is_empty\", 1), Some(1));\n+    assert_eq!(edit_distance_with_substrings(\"shrunk\", \"rchunks\", 2), None);\n+    assert_eq!(edit_distance_with_substrings(\"abc\", \"abcd\", 1), Some(1));\n+    assert_eq!(edit_distance_with_substrings(\"a\", \"abcd\", 1), None);\n+    assert_eq!(edit_distance_with_substrings(\"edf\", \"eq\", 1), None);\n+    assert_eq!(edit_distance_with_substrings(\"abc\", \"xyz\", 3), Some(3));\n+    assert_eq!(edit_distance_with_substrings(\"abcdef\", \"abcdef\", 2), Some(0));\n+}\n+\n+#[test]\n+fn test_find_best_match_for_name() {\n+    use crate::create_default_session_globals_then;\n+    create_default_session_globals_then(|| {\n+        let input = vec![Symbol::intern(\"aaab\"), Symbol::intern(\"aaabc\")];\n+        assert_eq!(\n+            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), None),\n+            Some(Symbol::intern(\"aaab\"))\n+        );\n+\n+        assert_eq!(find_best_match_for_name(&input, Symbol::intern(\"1111111111\"), None), None);\n+\n+        let input = vec![Symbol::intern(\"AAAA\")];\n+        assert_eq!(\n+            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), None),\n+            Some(Symbol::intern(\"AAAA\"))\n+        );\n+\n+        let input = vec![Symbol::intern(\"AAAA\")];\n+        assert_eq!(\n+            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), Some(4)),\n+            Some(Symbol::intern(\"AAAA\"))\n+        );\n+\n+        let input = vec![Symbol::intern(\"a_longer_variable_name\")];\n+        assert_eq!(\n+            find_best_match_for_name(&input, Symbol::intern(\"a_variable_longer_name\"), None),\n+            Some(Symbol::intern(\"a_longer_variable_name\"))\n+        );\n+    })\n+}\n+\n+#[test]\n+fn test_precise_algorithm() {\n+    // Not Levenshtein distance.\n+    assert_ne!(edit_distance(\"ab\", \"ba\", usize::MAX), Some(2));\n+    // Not unrestricted Damerau-Levenshtein distance.\n+    assert_ne!(edit_distance(\"abde\", \"bcaed\", usize::MAX), Some(3));\n+    // The current implementation is a restricted Damerau-Levenshtein distance.\n+    assert_eq!(edit_distance(\"abde\", \"bcaed\", usize::MAX), Some(4));\n+}"}, {"sha": "61e4b98a8d28bbda31d873b007217a5a2fc5e350", "filename": "compiler/rustc_span/src/lev_distance.rs", "status": "removed", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/267cd1d2c5abf5f0d825822a4179ba807b69ffb4/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267cd1d2c5abf5f0d825822a4179ba807b69ffb4/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs?ref=267cd1d2c5abf5f0d825822a4179ba807b69ffb4", "patch": "@@ -1,177 +0,0 @@\n-//! Levenshtein distances.\n-//!\n-//! The [Levenshtein distance] is a metric for measuring the difference between two strings.\n-//!\n-//! [Levenshtein distance]: https://en.wikipedia.org/wiki/Levenshtein_distance\n-\n-use crate::symbol::Symbol;\n-use std::cmp;\n-\n-#[cfg(test)]\n-mod tests;\n-\n-/// Finds the Levenshtein distance between two strings.\n-///\n-/// Returns None if the distance exceeds the limit.\n-pub fn lev_distance(a: &str, b: &str, limit: usize) -> Option<usize> {\n-    let n = a.chars().count();\n-    let m = b.chars().count();\n-    let min_dist = if n < m { m - n } else { n - m };\n-\n-    if min_dist > limit {\n-        return None;\n-    }\n-    if n == 0 || m == 0 {\n-        return (min_dist <= limit).then_some(min_dist);\n-    }\n-\n-    let mut dcol: Vec<_> = (0..=m).collect();\n-\n-    for (i, sc) in a.chars().enumerate() {\n-        let mut current = i;\n-        dcol[0] = current + 1;\n-\n-        for (j, tc) in b.chars().enumerate() {\n-            let next = dcol[j + 1];\n-            if sc == tc {\n-                dcol[j + 1] = current;\n-            } else {\n-                dcol[j + 1] = cmp::min(current, next);\n-                dcol[j + 1] = cmp::min(dcol[j + 1], dcol[j]) + 1;\n-            }\n-            current = next;\n-        }\n-    }\n-\n-    (dcol[m] <= limit).then_some(dcol[m])\n-}\n-\n-/// Provides a word similarity score between two words that accounts for substrings being more\n-/// meaningful than a typical Levenshtein distance. The lower the score, the closer the match.\n-/// 0 is an identical match.\n-///\n-/// Uses the Levenshtein distance between the two strings and removes the cost of the length\n-/// difference. If this is 0 then it is either a substring match or a full word match, in the\n-/// substring match case we detect this and return `1`. To prevent finding meaningless substrings,\n-/// eg. \"in\" in \"shrink\", we only perform this subtraction of length difference if one of the words\n-/// is not greater than twice the length of the other. For cases where the words are close in size\n-/// but not an exact substring then the cost of the length difference is discounted by half.\n-///\n-/// Returns `None` if the distance exceeds the limit.\n-pub fn lev_distance_with_substrings(a: &str, b: &str, limit: usize) -> Option<usize> {\n-    let n = a.chars().count();\n-    let m = b.chars().count();\n-\n-    // Check one isn't less than half the length of the other. If this is true then there is a\n-    // big difference in length.\n-    let big_len_diff = (n * 2) < m || (m * 2) < n;\n-    let len_diff = if n < m { m - n } else { n - m };\n-    let lev = lev_distance(a, b, limit + len_diff)?;\n-\n-    // This is the crux, subtracting length difference means exact substring matches will now be 0\n-    let score = lev - len_diff;\n-\n-    // If the score is 0 but the words have different lengths then it's a substring match not a full\n-    // word match\n-    let score = if score == 0 && len_diff > 0 && !big_len_diff {\n-        1 // Exact substring match, but not a total word match so return non-zero\n-    } else if !big_len_diff {\n-        // Not a big difference in length, discount cost of length difference\n-        score + (len_diff + 1) / 2\n-    } else {\n-        // A big difference in length, add back the difference in length to the score\n-        score + len_diff\n-    };\n-\n-    (score <= limit).then_some(score)\n-}\n-\n-/// Finds the best match for given word in the given iterator where substrings are meaningful.\n-///\n-/// A version of [`find_best_match_for_name`] that uses [`lev_distance_with_substrings`] as the score\n-/// for word similarity. This takes an optional distance limit which defaults to one-third of the\n-/// given word.\n-///\n-/// Besides the modified Levenshtein, we use case insensitive comparison to improve accuracy\n-/// on an edge case with a lower(upper)case letters mismatch.\n-pub fn find_best_match_for_name_with_substrings(\n-    candidates: &[Symbol],\n-    lookup: Symbol,\n-    dist: Option<usize>,\n-) -> Option<Symbol> {\n-    find_best_match_for_name_impl(true, candidates, lookup, dist)\n-}\n-\n-/// Finds the best match for a given word in the given iterator.\n-///\n-/// As a loose rule to avoid the obviously incorrect suggestions, it takes\n-/// an optional limit for the maximum allowable edit distance, which defaults\n-/// to one-third of the given word.\n-///\n-/// Besides Levenshtein, we use case insensitive comparison to improve accuracy\n-/// on an edge case with a lower(upper)case letters mismatch.\n-pub fn find_best_match_for_name(\n-    candidates: &[Symbol],\n-    lookup: Symbol,\n-    dist: Option<usize>,\n-) -> Option<Symbol> {\n-    find_best_match_for_name_impl(false, candidates, lookup, dist)\n-}\n-\n-#[cold]\n-fn find_best_match_for_name_impl(\n-    use_substring_score: bool,\n-    candidates: &[Symbol],\n-    lookup: Symbol,\n-    dist: Option<usize>,\n-) -> Option<Symbol> {\n-    let lookup = lookup.as_str();\n-    let lookup_uppercase = lookup.to_uppercase();\n-\n-    // Priority of matches:\n-    // 1. Exact case insensitive match\n-    // 2. Levenshtein distance match\n-    // 3. Sorted word match\n-    if let Some(c) = candidates.iter().find(|c| c.as_str().to_uppercase() == lookup_uppercase) {\n-        return Some(*c);\n-    }\n-\n-    let mut dist = dist.unwrap_or_else(|| cmp::max(lookup.len(), 3) / 3);\n-    let mut best = None;\n-    for c in candidates {\n-        match if use_substring_score {\n-            lev_distance_with_substrings(lookup, c.as_str(), dist)\n-        } else {\n-            lev_distance(lookup, c.as_str(), dist)\n-        } {\n-            Some(0) => return Some(*c),\n-            Some(d) => {\n-                dist = d - 1;\n-                best = Some(*c);\n-            }\n-            None => {}\n-        }\n-    }\n-    if best.is_some() {\n-        return best;\n-    }\n-\n-    find_match_by_sorted_words(candidates, lookup)\n-}\n-\n-fn find_match_by_sorted_words(iter_names: &[Symbol], lookup: &str) -> Option<Symbol> {\n-    iter_names.iter().fold(None, |result, candidate| {\n-        if sort_by_words(candidate.as_str()) == sort_by_words(lookup) {\n-            Some(*candidate)\n-        } else {\n-            result\n-        }\n-    })\n-}\n-\n-fn sort_by_words(name: &str) -> String {\n-    let mut split_words: Vec<&str> = name.split('_').collect();\n-    // We are sorting primitive &strs and can use unstable sort here.\n-    split_words.sort_unstable();\n-    split_words.join(\"_\")\n-}"}, {"sha": "ed03b22c61fd6a2eb20675ee7de0f799322e53b5", "filename": "compiler/rustc_span/src/lev_distance/tests.rs", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/267cd1d2c5abf5f0d825822a4179ba807b69ffb4/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267cd1d2c5abf5f0d825822a4179ba807b69ffb4/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs?ref=267cd1d2c5abf5f0d825822a4179ba807b69ffb4", "patch": "@@ -1,70 +0,0 @@\n-use super::*;\n-\n-#[test]\n-fn test_lev_distance() {\n-    // Test bytelength agnosticity\n-    for c in (0..char::MAX as u32).filter_map(char::from_u32).map(|i| i.to_string()) {\n-        assert_eq!(lev_distance(&c[..], &c[..], usize::MAX), Some(0));\n-    }\n-\n-    let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-    let b = \"\\nMary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-    let c = \"Mary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-    assert_eq!(lev_distance(a, b, usize::MAX), Some(1));\n-    assert_eq!(lev_distance(b, a, usize::MAX), Some(1));\n-    assert_eq!(lev_distance(a, c, usize::MAX), Some(2));\n-    assert_eq!(lev_distance(c, a, usize::MAX), Some(2));\n-    assert_eq!(lev_distance(b, c, usize::MAX), Some(1));\n-    assert_eq!(lev_distance(c, b, usize::MAX), Some(1));\n-}\n-\n-#[test]\n-fn test_lev_distance_limit() {\n-    assert_eq!(lev_distance(\"abc\", \"abcd\", 1), Some(1));\n-    assert_eq!(lev_distance(\"abc\", \"abcd\", 0), None);\n-    assert_eq!(lev_distance(\"abc\", \"xyz\", 3), Some(3));\n-    assert_eq!(lev_distance(\"abc\", \"xyz\", 2), None);\n-}\n-\n-#[test]\n-fn test_method_name_similarity_score() {\n-    assert_eq!(lev_distance_with_substrings(\"empty\", \"is_empty\", 1), Some(1));\n-    assert_eq!(lev_distance_with_substrings(\"shrunk\", \"rchunks\", 2), None);\n-    assert_eq!(lev_distance_with_substrings(\"abc\", \"abcd\", 1), Some(1));\n-    assert_eq!(lev_distance_with_substrings(\"a\", \"abcd\", 1), None);\n-    assert_eq!(lev_distance_with_substrings(\"edf\", \"eq\", 1), None);\n-    assert_eq!(lev_distance_with_substrings(\"abc\", \"xyz\", 3), Some(3));\n-    assert_eq!(lev_distance_with_substrings(\"abcdef\", \"abcdef\", 2), Some(0));\n-}\n-\n-#[test]\n-fn test_find_best_match_for_name() {\n-    use crate::create_default_session_globals_then;\n-    create_default_session_globals_then(|| {\n-        let input = vec![Symbol::intern(\"aaab\"), Symbol::intern(\"aaabc\")];\n-        assert_eq!(\n-            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), None),\n-            Some(Symbol::intern(\"aaab\"))\n-        );\n-\n-        assert_eq!(find_best_match_for_name(&input, Symbol::intern(\"1111111111\"), None), None);\n-\n-        let input = vec![Symbol::intern(\"AAAA\")];\n-        assert_eq!(\n-            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), None),\n-            Some(Symbol::intern(\"AAAA\"))\n-        );\n-\n-        let input = vec![Symbol::intern(\"AAAA\")];\n-        assert_eq!(\n-            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), Some(4)),\n-            Some(Symbol::intern(\"AAAA\"))\n-        );\n-\n-        let input = vec![Symbol::intern(\"a_longer_variable_name\")];\n-        assert_eq!(\n-            find_best_match_for_name(&input, Symbol::intern(\"a_variable_longer_name\"), None),\n-            Some(Symbol::intern(\"a_longer_variable_name\"))\n-        );\n-    })\n-}"}, {"sha": "e112100aa5fcdb05fcb8e48f7a0c8a17c3f08ef2", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -19,6 +19,7 @@\n #![feature(negative_impls)]\n #![feature(min_specialization)]\n #![feature(rustc_attrs)]\n+#![feature(let_chains)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n@@ -46,7 +47,7 @@ pub use hygiene::{ExpnData, ExpnHash, ExpnId, LocalExpnId, SyntaxContext};\n use rustc_data_structures::stable_hasher::HashingControls;\n pub mod def_id;\n use def_id::{CrateNum, DefId, DefPathHash, LocalDefId, LOCAL_CRATE};\n-pub mod lev_distance;\n+pub mod edit_distance;\n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n "}, {"sha": "87f077325f8bef527102c17c1bcdbb810cc98bc9", "filename": "library/core/src/ffi/c_str.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -457,6 +457,10 @@ impl CStr {\n     /// to a contiguous region of memory terminated with a 0 byte to represent\n     /// the end of the string.\n     ///\n+    /// The type of the returned pointer is\n+    /// [`*const c_char`][crate::ffi::c_char], and whether it's\n+    /// an alias for `*const i8` or `*const u8` is platform-specific.\n+    ///\n     /// **WARNING**\n     ///\n     /// The returned pointer is read-only; writing to it (including passing it\n@@ -470,6 +474,7 @@ impl CStr {\n     /// # #![allow(unused_must_use)] #![allow(temporary_cstring_as_ptr)]\n     /// use std::ffi::CString;\n     ///\n+    /// // Do not do this:\n     /// let ptr = CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr();\n     /// unsafe {\n     ///     // `ptr` is dangling"}, {"sha": "f0fcdf0d5a0cd7a59deffae657c8d286025810cd", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 78, "deletions": 33, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -111,10 +111,18 @@ impl Step for Std {\n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         if compiler_to_use != compiler {\n             builder.ensure(Std::new(compiler_to_use, target));\n-            builder.info(&format!(\n-                \"Uplifting stage1 library ({} -> {})\",\n-                compiler_to_use.host, target\n-            ));\n+            let msg = if compiler_to_use.host == target {\n+                format!(\n+                    \"Uplifting library (stage{} -> stage{})\",\n+                    compiler_to_use.stage, compiler.stage\n+                )\n+            } else {\n+                format!(\n+                    \"Uplifting library (stage{}:{} -> stage{}:{})\",\n+                    compiler_to_use.stage, compiler_to_use.host, compiler.stage, target\n+                )\n+            };\n+            builder.info(&msg);\n \n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the third party objects needed by various targets.\n@@ -134,13 +142,23 @@ impl Step for Std {\n             cargo.arg(\"-p\").arg(krate);\n         }\n \n-        builder.info(&format!(\n-            \"Building{} stage{} library artifacts ({} -> {})\",\n-            crate_description(&self.crates),\n-            compiler.stage,\n-            &compiler.host,\n-            target,\n-        ));\n+        let msg = if compiler.host == target {\n+            format!(\n+                \"Building{} stage{} library artifacts ({}) \",\n+                crate_description(&self.crates),\n+                compiler.stage,\n+                compiler.host\n+            )\n+        } else {\n+            format!(\n+                \"Building{} stage{} library artifacts ({} -> {})\",\n+                crate_description(&self.crates),\n+                compiler.stage,\n+                compiler.host,\n+                target,\n+            )\n+        };\n+        builder.info(&msg);\n         run_cargo(\n             builder,\n             cargo,\n@@ -438,10 +456,6 @@ impl Step for StdLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        builder.info(&format!(\n-            \"Copying stage{} library from stage{} ({} -> {} / {})\",\n-            target_compiler.stage, compiler.stage, &compiler.host, target_compiler.host, target\n-        ));\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n         let hostdir = builder.sysroot_libdir(target_compiler, compiler.host);\n         add_to_sysroot(builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n@@ -715,8 +729,22 @@ impl Step for Rustc {\n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         if compiler_to_use != compiler {\n             builder.ensure(Rustc::new(compiler_to_use, target));\n-            builder\n-                .info(&format!(\"Uplifting stage1 rustc ({} -> {})\", builder.config.build, target));\n+            let msg = if compiler_to_use.host == target {\n+                format!(\n+                    \"Uplifting rustc (stage{} -> stage{})\",\n+                    compiler_to_use.stage,\n+                    compiler.stage + 1\n+                )\n+            } else {\n+                format!(\n+                    \"Uplifting rustc (stage{}:{} -> stage{}:{})\",\n+                    compiler_to_use.stage,\n+                    compiler_to_use.host,\n+                    compiler.stage + 1,\n+                    target\n+                )\n+            };\n+            builder.info(&msg);\n             builder.ensure(RustcLink::from_rustc(self, compiler_to_use));\n             return;\n         }\n@@ -810,13 +838,24 @@ impl Step for Rustc {\n             cargo.arg(\"-p\").arg(krate);\n         }\n \n-        builder.info(&format!(\n-            \"Building{} stage{} compiler artifacts ({} -> {})\",\n-            crate_description(&self.crates),\n-            compiler.stage,\n-            &compiler.host,\n-            target,\n-        ));\n+        let msg = if compiler.host == target {\n+            format!(\n+                \"Building{} compiler artifacts (stage{} -> stage{})\",\n+                crate_description(&self.crates),\n+                compiler.stage,\n+                compiler.stage + 1\n+            )\n+        } else {\n+            format!(\n+                \"Building{} compiler artifacts (stage{}:{} -> stage{}:{})\",\n+                crate_description(&self.crates),\n+                compiler.stage,\n+                compiler.host,\n+                compiler.stage + 1,\n+                target,\n+            )\n+        };\n+        builder.info(&msg);\n         run_cargo(\n             builder,\n             cargo,\n@@ -1000,10 +1039,6 @@ impl Step for RustcLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        builder.info(&format!(\n-            \"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n-            target_compiler.stage, compiler.stage, &compiler.host, target_compiler.host, target\n-        ));\n         add_to_sysroot(\n             builder,\n             &builder.sysroot_libdir(target_compiler, target),\n@@ -1077,10 +1112,15 @@ impl Step for CodegenBackend {\n \n         let tmp_stamp = out_dir.join(\".tmp.stamp\");\n \n-        builder.info(&format!(\n-            \"Building stage{} codegen backend {} ({} -> {})\",\n-            compiler.stage, backend, &compiler.host, target\n-        ));\n+        let msg = if compiler.host == target {\n+            format!(\"Building stage{} codegen backend {}\", compiler.stage, backend)\n+        } else {\n+            format!(\n+                \"Building stage{} codegen backend {} ({} -> {})\",\n+                compiler.stage, backend, compiler.host, target\n+            )\n+        };\n+        builder.info(&msg);\n         let files = run_cargo(builder, cargo, vec![], &tmp_stamp, vec![], false, false);\n         if builder.config.dry_run() {\n             return;\n@@ -1386,7 +1426,12 @@ impl Step for Assemble {\n \n         let stage = target_compiler.stage;\n         let host = target_compiler.host;\n-        builder.info(&format!(\"Assembling stage{} compiler ({})\", stage, host));\n+        let msg = if build_compiler.host == host {\n+            format!(\"Assembling stage{} compiler\", stage)\n+        } else {\n+            format!(\"Assembling stage{} compiler ({})\", stage, host)\n+        };\n+        builder.info(&msg);\n \n         // Link in all dylibs to the libdir\n         let stamp = librustc_stamp(builder, build_compiler, target_compiler.host);"}, {"sha": "d30532ef3c658756ad5f83cfc3040d008b112ea8", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -33,6 +33,44 @@ struct ToolBuild {\n     allow_features: &'static str,\n }\n \n+fn tooling_output(\n+    mode: Mode,\n+    tool: &str,\n+    build_stage: u32,\n+    host: &TargetSelection,\n+    target: &TargetSelection,\n+) -> String {\n+    match mode {\n+        // depends on compiler stage, different to host compiler\n+        Mode::ToolRustc => {\n+            if host == target {\n+                format!(\"Building tool {} (stage{} -> stage{})\", tool, build_stage, build_stage + 1)\n+            } else {\n+                format!(\n+                    \"Building tool {} (stage{}:{} -> stage{}:{})\",\n+                    tool,\n+                    build_stage,\n+                    host,\n+                    build_stage + 1,\n+                    target\n+                )\n+            }\n+        }\n+        // doesn't depend on compiler, same as host compiler\n+        Mode::ToolStd => {\n+            if host == target {\n+                format!(\"Building tool {} (stage{})\", tool, build_stage)\n+            } else {\n+                format!(\n+                    \"Building tool {} (stage{}:{} -> stage{}:{})\",\n+                    tool, build_stage, host, build_stage, target\n+                )\n+            }\n+        }\n+        _ => format!(\"Building tool {} (stage{})\", tool, build_stage),\n+    }\n+}\n+\n impl Step for ToolBuild {\n     type Output = Option<PathBuf>;\n \n@@ -74,8 +112,14 @@ impl Step for ToolBuild {\n         if !self.allow_features.is_empty() {\n             cargo.allow_features(self.allow_features);\n         }\n-\n-        builder.info(&format!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target));\n+        let msg = tooling_output(\n+            self.mode,\n+            self.tool,\n+            self.compiler.stage,\n+            &self.compiler.host,\n+            &self.target,\n+        );\n+        builder.info(&msg);\n         let mut duplicates = Vec::new();\n         let is_expected = compile::stream_cargo(builder, cargo, vec![], &mut |msg| {\n             // Only care about big things like the RLS/Cargo for now\n@@ -562,10 +606,14 @@ impl Step for Rustdoc {\n             features.as_slice(),\n         );\n \n-        builder.info(&format!(\n-            \"Building rustdoc for stage{} ({})\",\n-            target_compiler.stage, target_compiler.host\n-        ));\n+        let msg = tooling_output(\n+            Mode::ToolRustc,\n+            \"rustdoc\",\n+            build_compiler.stage,\n+            &self.compiler.host,\n+            &target,\n+        );\n+        builder.info(&msg);\n         builder.run(&mut cargo.into());\n \n         // Cargo adds a number of paths to the dylib search path on windows, which results in"}, {"sha": "83383ea61a4ab20a20ccd66be9220d394e384589", "filename": "tests/ui/check-cfg/invalid-cfg-value.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/tests%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/tests%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -2,7 +2,9 @@ warning: unexpected `cfg` condition value\n   --> $DIR/invalid-cfg-value.rs:7:7\n    |\n LL | #[cfg(feature = \"sedre\")]\n-   |       ^^^^^^^^^^^^^^^^^\n+   |       ^^^^^^^^^^-------\n+   |                 |\n+   |                 help: did you mean: `\"serde\"`\n    |\n    = note: expected values for `feature` are: full, serde\n    = note: `#[warn(unexpected_cfgs)]` on by default"}, {"sha": "cee34e3b7159372c46c44e06a75c29b9c0dfe8d5", "filename": "tests/ui/const-generics/early/invalid-const-arguments.stderr", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/tests%2Fui%2Fconst-generics%2Fearly%2Finvalid-const-arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/tests%2Fui%2Fconst-generics%2Fearly%2Finvalid-const-arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fearly%2Finvalid-const-arguments.stderr?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -49,12 +49,9 @@ error[E0747]: type provided when a constant was expected\n   --> $DIR/invalid-const-arguments.rs:10:19\n    |\n LL | impl<N> Foo for B<N> {}\n-   |                   ^\n-   |\n-help: consider changing this type parameter to be a `const` generic\n-   |\n-LL | impl<const N: u8> Foo for B<N> {}\n-   |      ~~~~~~~~~~~\n+   |      -            ^\n+   |      |\n+   |      help: consider changing this type parameter to a const parameter: `const N: u8`\n \n error[E0747]: unresolved item provided when a constant was expected\n   --> $DIR/invalid-const-arguments.rs:14:32"}, {"sha": "685b5e1f284035c1ded45649ea69dd22bf1c7c21", "filename": "tests/ui/did_you_mean/println-typo.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.rs?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -0,0 +1,6 @@\n+// https://internals.rust-lang.org/t/18227\n+\n+fn main() {\n+    prinltn!(); //~ ERROR cannot find macro `prinltn` in this scope\n+    //^ a macro with a similar name exists: `println`\n+}"}, {"sha": "43b7b1894e2ae31e718403f5e34466c69da38ba0", "filename": "tests/ui/did_you_mean/println-typo.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/897304954922a89f8af8bc4b1c40c2e78a3c62b0/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/897304954922a89f8af8bc4b1c40c2e78a3c62b0/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.stderr?ref=897304954922a89f8af8bc4b1c40c2e78a3c62b0", "patch": "@@ -0,0 +1,11 @@\n+error: cannot find macro `prinltn` in this scope\n+  --> $DIR/println-typo.rs:4:5\n+   |\n+LL |     prinltn!();\n+   |     ^^^^^^^ help: a macro with a similar name exists: `println`\n+  --> $SRC_DIR/std/src/macros.rs:LL:COL\n+   |\n+   = note: similarly named macro `println` defined here\n+\n+error: aborting due to previous error\n+"}]}