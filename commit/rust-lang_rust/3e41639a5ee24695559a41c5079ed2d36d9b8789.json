{"sha": "3e41639a5ee24695559a41c5079ed2d36d9b8789", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNDE2MzlhNWVlMjQ2OTU1NTlhNDFjNTA3OWVkMmQzNmQ5Yjg3ODk=", "commit": {"author": {"name": "Olivier Saut", "email": "osaut@airpost.net", "date": "2013-05-17T21:11:49Z"}, "committer": {"name": "Olivier Saut", "email": "osaut@airpost.net", "date": "2013-05-17T21:11:49Z"}, "message": "Add a small section on futures to the tutorial", "tree": {"sha": "286674b55ec4f68ec5e8c52bfa07582336f4c75e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/286674b55ec4f68ec5e8c52bfa07582336f4c75e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e41639a5ee24695559a41c5079ed2d36d9b8789", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e41639a5ee24695559a41c5079ed2d36d9b8789", "html_url": "https://github.com/rust-lang/rust/commit/3e41639a5ee24695559a41c5079ed2d36d9b8789", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e41639a5ee24695559a41c5079ed2d36d9b8789/comments", "author": null, "committer": null, "parents": [{"sha": "7dc466f91f3f6bf44d72430bf760277cd4eebf3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dc466f91f3f6bf44d72430bf760277cd4eebf3a", "html_url": "https://github.com/rust-lang/rust/commit/7dc466f91f3f6bf44d72430bf760277cd4eebf3a"}], "stats": {"total": 73, "additions": 60, "deletions": 13}, "files": [{"sha": "c9e0377dd132ca9d55f5aa13693924b50d827465", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 60, "deletions": 13, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3e41639a5ee24695559a41c5079ed2d36d9b8789/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/3e41639a5ee24695559a41c5079ed2d36d9b8789/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=3e41639a5ee24695559a41c5079ed2d36d9b8789", "patch": "@@ -43,22 +43,24 @@ in the core and standard libraries, which are still under development\n and do not always present a consistent or complete interface.\n \n For your reference, these are the standard modules involved in Rust\n-concurrency at this writing.\n+concurrency at this writing:\n \n-* [`core::task`] - All code relating to tasks and task scheduling\n-* [`core::comm`] - The message passing interface\n-* [`core::pipes`] - The underlying messaging infrastructure\n-* [`std::comm`] - Additional messaging types based on `core::pipes`\n-* [`std::sync`] - More exotic synchronization tools, including locks\n+* [`core::task`] - All code relating to tasks and task scheduling,\n+* [`core::comm`] - The message passing interface,\n+* [`core::pipes`] - The underlying messaging infrastructure,\n+* [`std::comm`] - Additional messaging types based on `core::pipes`,\n+* [`std::sync`] - More exotic synchronization tools, including locks,\n * [`std::arc`] - The ARC (atomically reference counted) type,\n-  for safely sharing immutable data\n+  for safely sharing immutable data,\n+* [`std::future`] - A type representing values that may be computed concurrently and retrieved at a later time.\n \n [`core::task`]: core/task.html\n [`core::comm`]: core/comm.html\n [`core::pipes`]: core/pipes.html\n [`std::comm`]: std/comm.html\n [`std::sync`]: std/sync.html\n [`std::arc`]: std/arc.html\n+[`std::future`]: std/future.html\n \n # Basics\n \n@@ -70,7 +72,7 @@ closure in the new task.\n \n ~~~~\n # use core::io::println;\n-use core::task::spawn;\n+# use core::task::spawn;\n \n // Print something profound in a different task using a named function\n fn print_message() { println(\"I am running in a different task!\"); }\n@@ -145,8 +147,8 @@ endpoint. Consider the following example of calculating two results\n concurrently:\n \n ~~~~\n-use core::task::spawn;\n-use core::comm::{stream, Port, Chan};\n+# use core::task::spawn;\n+# use core::comm::{stream, Port, Chan};\n \n let (port, chan): (Port<int>, Chan<int>) = stream();\n \n@@ -233,7 +235,7 @@ Instead we can use a `SharedChan`, a type that allows a single\n \n ~~~\n # use core::task::spawn;\n-use core::comm::{stream, SharedChan};\n+# use core::comm::{stream, SharedChan};\n \n let (port, chan) = stream();\n let chan = SharedChan::new(chan);\n@@ -282,6 +284,51 @@ let result = ports.foldl(0, |accum, port| *accum + port.recv() );\n # fn some_expensive_computation(_i: uint) -> int { 42 }\n ~~~\n \n+## Futures\n+With `std::future`, rust has a mechanism for requesting a computation and getting the result\n+later.\n+\n+The basic example below illustrates this.\n+~~~\n+# fn make_a_sandwich() {};\n+fn fib(n: uint) -> uint {\n+    // lengthy computation returning an uint\n+    12586269025\n+}\n+\n+let mut delayed_fib = std::future::spawn (|| fib(50) );\n+make_a_sandwich();\n+println(fmt!(\"fib(50) = %?\", delayed_fib.get()))\n+~~~\n+\n+The call to `future::spawn` returns immediately a `future` object regardless of how long it\n+takes to run `fib(50)`. You can then make yourself a sandwich while the computation of `fib` is\n+running. The result of the execution of the method is obtained by calling `get` on the future.\n+This call will block until the value is available (*i.e.* the computation is complete). Note that\n+the future needs to be mutable so that it can save the result for next time `get` is called.\n+\n+Here is another example showing how futures allow you to background computations. The workload will\n+be distributed on the available cores.\n+~~~\n+fn partial_sum(start: uint) -> f64 {\n+    let mut local_sum = 0f64;\n+    for uint::range(start*100000, (start+1)*100000) |num| {\n+        local_sum += (num as f64 + 1.0).pow(-2.0);\n+    }\n+    local_sum\n+}\n+\n+fn main() {\n+    let mut futures = vec::from_fn(1000, |ind| do std::future::spawn { partial_sum(ind) });\n+\n+    let mut final_res = 0f64;\n+    for futures.each_mut |ft|  {\n+        final_res += ft.get();\n+    }\n+    println(fmt!(\"\u03c0^2/6 is not far from : %?\", final_res));\n+}\n+~~~\n+\n # Handling task failure\n \n Rust has a built-in mechanism for raising exceptions. The `fail!()` macro\n@@ -363,8 +410,8 @@ either task fails, it kills the other one.\n ~~~\n # fn sleep_forever() { loop { task::yield() } }\n # do task::try {\n-do task::spawn {\n-    do task::spawn {\n+do spawn {\n+    do spawn {\n         fail!();  // All three tasks will fail.\n     }\n     sleep_forever();  // Will get woken up by force, then fail"}]}