{"sha": "cf81e1aba86bebb4830f91d4097492dd21d8ebf6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmODFlMWFiYTg2YmViYjQ4MzBmOTFkNDA5NzQ5MmRkMjFkOGViZjY=", "commit": {"author": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2015-12-10T16:34:54Z"}, "committer": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2015-12-10T16:34:54Z"}, "message": "Improve `htmldocck.py` error messages", "tree": {"sha": "62cb0b10bbb82e7717f3ee9c25c4f1ac628e4b46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62cb0b10bbb82e7717f3ee9c25c4f1ac628e4b46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf81e1aba86bebb4830f91d4097492dd21d8ebf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf81e1aba86bebb4830f91d4097492dd21d8ebf6", "html_url": "https://github.com/rust-lang/rust/commit/cf81e1aba86bebb4830f91d4097492dd21d8ebf6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf81e1aba86bebb4830f91d4097492dd21d8ebf6/comments", "author": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8eee0efd1f3f43e379abf7dfcb190bd60700eeca", "url": "https://api.github.com/repos/rust-lang/rust/commits/8eee0efd1f3f43e379abf7dfcb190bd60700eeca", "html_url": "https://github.com/rust-lang/rust/commit/8eee0efd1f3f43e379abf7dfcb190bd60700eeca"}], "stats": {"total": 140, "additions": 86, "deletions": 54}, "files": [{"sha": "8362c239b655d0b975eda8ab7bc008a14bcb66cf", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 86, "deletions": 54, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/cf81e1aba86bebb4830f91d4097492dd21d8ebf6/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/cf81e1aba86bebb4830f91d4097492dd21d8ebf6/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=cf81e1aba86bebb4830f91d4097492dd21d8ebf6", "patch": "@@ -104,6 +104,7 @@\n \n \"\"\"\n \n+from __future__ import print_function\n import sys\n import os.path\n import re\n@@ -160,8 +161,13 @@ def close(self):\n         HTMLParser.close(self)\n         return self.__builder.close()\n \n-Command = namedtuple('Command', 'negated cmd args lineno')\n+Command = namedtuple('Command', 'negated cmd args lineno context')\n \n+class FailedCheck(Exception):\n+    pass\n+\n+class InvalidCheck(Exception):\n+    pass\n \n def concat_multi_lines(f):\n     \"\"\"returns a generator out of the file object, which\n@@ -196,7 +202,7 @@ def concat_multi_lines(f):\n             catenated = ''\n \n     if lastline is not None:\n-        raise RuntimeError('Trailing backslash in the end of file')\n+        print_err(lineno, line, 'Trailing backslash at the end of the file')\n \n LINE_PATTERN = re.compile(r'''\n     (?<=(?<!\\S)@)(?P<negated>!?)\n@@ -216,9 +222,10 @@ def get_commands(template):\n             cmd = m.group('cmd')\n             args = m.group('args')\n             if args and not args[:1].isspace():\n-                raise RuntimeError('Invalid template syntax at line {}'.format(lineno+1))\n+                print_err(lineno, line, 'Invalid template syntax')\n+                continue\n             args = shlex.split(args)\n-            yield Command(negated=negated, cmd=cmd, args=args, lineno=lineno+1)\n+            yield Command(negated=negated, cmd=cmd, args=args, lineno=lineno+1, context=line)\n \n \n def _flatten(node, acc):\n@@ -242,8 +249,7 @@ def normalize_xpath(path):\n     elif path.startswith('.//'):\n         return path\n     else:\n-        raise RuntimeError('Non-absolute XPath is not supported due to \\\n-                            the implementation issue.')\n+        raise InvalidCheck('Non-absolute XPath is not supported due to implementation issues')\n \n \n class CachedFiles(object):\n@@ -259,41 +265,40 @@ def resolve_path(self, path):\n             self.last_path = path\n             return path\n         elif self.last_path is None:\n-            raise RuntimeError('Tried to use the previous path in the first command')\n+            raise InvalidCheck('Tried to use the previous path in the first command')\n         else:\n             return self.last_path\n \n     def get_file(self, path):\n         path = self.resolve_path(path)\n-        try:\n+        if path in self.files:\n             return self.files[path]\n-        except KeyError:\n-            try:\n-                with open(os.path.join(self.root, path)) as f:\n-                    data = f.read()\n-            except Exception as e:\n-                raise RuntimeError('Cannot open file {!r}: {}'.format(path, e))\n-            else:\n-                self.files[path] = data\n-                return data\n+\n+        abspath = os.path.join(self.root, path)\n+        if not(os.path.exists(abspath) and os.path.isfile(abspath)):\n+            raise FailedCheck('File does not exist {!r}'.format(path))\n+\n+        with open(abspath) as f:\n+            data = f.read()\n+            self.files[path] = data\n+            return data\n \n     def get_tree(self, path):\n         path = self.resolve_path(path)\n-        try:\n+        if path in self.trees:\n             return self.trees[path]\n-        except KeyError:\n-            try:\n-                f = open(os.path.join(self.root, path))\n-            except Exception as e:\n-                raise RuntimeError('Cannot open file {!r}: {}'.format(path, e))\n+\n+        abspath = os.path.join(self.root, path)\n+        if not(os.path.exists(abspath) and os.path.isfile(abspath)):\n+            raise FailedCheck('File does not exist {!r}'.format(path))\n+\n+        with open(abspath) as f:\n             try:\n-                with f:\n-                    tree = ET.parse(f, CustomHTMLParser())\n+                tree = ET.parse(f, CustomHTMLParser())\n             except Exception as e:\n                 raise RuntimeError('Cannot parse an HTML file {!r}: {}'.format(path, e))\n-            else:\n-                self.trees[path] = tree\n-                return self.trees[path]\n+            self.trees[path] = tree\n+            return self.trees[path]\n \n \n def check_string(data, pat, regexp):\n@@ -311,14 +316,14 @@ def check_tree_attr(tree, path, attr, pat, regexp):\n     path = normalize_xpath(path)\n     ret = False\n     for e in tree.findall(path):\n-        try:\n+        if attr in e.attrib:\n             value = e.attrib[attr]\n-        except KeyError:\n-            continue\n         else:\n-            ret = check_string(value, pat, regexp)\n-            if ret:\n-                break\n+            continue\n+\n+        ret = check_string(value, pat, regexp)\n+        if ret:\n+            break\n     return ret\n \n \n@@ -341,57 +346,84 @@ def check_tree_count(tree, path, count):\n     path = normalize_xpath(path)\n     return len(tree.findall(path)) == count\n \n+def stderr(*args):\n+    print(*args, file=sys.stderr)\n \n-def check(target, commands):\n-    cache = CachedFiles(target)\n-    for c in commands:\n+def print_err(lineno, context, err, message=None):\n+    global ERR_COUNT\n+    ERR_COUNT += 1\n+    stderr(\"{}: {}\".format(lineno, message or err))\n+    if message and err:\n+        stderr(\"\\t{}\".format(err))\n+\n+    if context:\n+        stderr(\"\\t{}\".format(context))\n+\n+ERR_COUNT = 0\n+\n+def check_command(c, cache):\n+    try:\n+        cerr = \"\"\n         if c.cmd == 'has' or c.cmd == 'matches': # string test\n             regexp = (c.cmd == 'matches')\n             if len(c.args) == 1 and not regexp: # @has <path> = file existence\n                 try:\n                     cache.get_file(c.args[0])\n                     ret = True\n-                except RuntimeError:\n+                except FailedCheck as err:\n+                    cerr = err.message\n                     ret = False\n             elif len(c.args) == 2: # @has/matches <path> <pat> = string test\n+                cerr = \"`PATTERN` did not match\"\n                 ret = check_string(cache.get_file(c.args[0]), c.args[1], regexp)\n             elif len(c.args) == 3: # @has/matches <path> <pat> <match> = XML tree test\n+                cerr = \"`XPATH PATTERN` did not match\"\n                 tree = cache.get_tree(c.args[0])\n                 pat, sep, attr = c.args[1].partition('/@')\n                 if sep: # attribute\n-                    ret = check_tree_attr(cache.get_tree(c.args[0]), pat, attr, c.args[2], regexp)\n+                    tree = cache.get_tree(c.args[0])\n+                    ret = check_tree_attr(tree, pat, attr, c.args[2], regexp)\n                 else: # normalized text\n                     pat = c.args[1]\n                     if pat.endswith('/text()'):\n                         pat = pat[:-7]\n                     ret = check_tree_text(cache.get_tree(c.args[0]), pat, c.args[2], regexp)\n             else:\n-                raise RuntimeError('Invalid number of @{} arguments \\\n-                                    at line {}'.format(c.cmd, c.lineno))\n+                raise InvalidCheck('Invalid number of @{} arguments'.format(c.cmd))\n \n         elif c.cmd == 'count': # count test\n             if len(c.args) == 3: # @count <path> <pat> <count> = count test\n                 ret = check_tree_count(cache.get_tree(c.args[0]), c.args[1], int(c.args[2]))\n             else:\n-                raise RuntimeError('Invalid number of @{} arguments \\\n-                                    at line {}'.format(c.cmd, c.lineno))\n-\n+                raise InvalidCheck('Invalid number of @{} arguments'.format(c.cmd))\n         elif c.cmd == 'valid-html':\n-            raise RuntimeError('Unimplemented @valid-html at line {}'.format(c.lineno))\n+            raise InvalidCheck('Unimplemented @valid-html')\n \n         elif c.cmd == 'valid-links':\n-            raise RuntimeError('Unimplemented @valid-links at line {}'.format(c.lineno))\n-\n+            raise InvalidCheck('Unimplemented @valid-links')\n         else:\n-            raise RuntimeError('Unrecognized @{} at line {}'.format(c.cmd, c.lineno))\n+            raise InvalidCheck('Unrecognized @{}'.format(c.cmd))\n \n         if ret == c.negated:\n-            raise RuntimeError('@{}{} check failed at line {}'.format('!' if c.negated else '',\n-                                                                      c.cmd, c.lineno))\n+            raise FailedCheck(cerr)\n+\n+    except FailedCheck as err:\n+        message = '@{}{} check failed'.format('!' if c.negated else '', c.cmd)\n+        print_err(c.lineno, c.context, err.message, message)\n+    except InvalidCheck as err:\n+        print_err(c.lineno, c.context, err.message)\n+\n+def check(target, commands):\n+    cache = CachedFiles(target)\n+    for c in commands:\n+        check_command(c, cache)\n \n if __name__ == '__main__':\n-    if len(sys.argv) < 3:\n-        print >>sys.stderr, 'Usage: {} <doc dir> <template>'.format(sys.argv[0])\n+    if len(sys.argv) != 3:\n+        stderr('Usage: {} <doc dir> <template>'.format(sys.argv[0]))\n+        raise SystemExit(1)\n+\n+    check(sys.argv[1], get_commands(sys.argv[2]))\n+    if ERR_COUNT:\n+        stderr(\"\\nEncountered {} errors\".format(ERR_COUNT))\n         raise SystemExit(1)\n-    else:\n-        check(sys.argv[1], get_commands(sys.argv[2]))"}]}