{"sha": "3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2", "node_id": "C_kwDOAAsO6NoAKDNkMDliOTkwZDdlM2Q4NTM5YTNiOTY1NTg5NGU3ZTA1ZGNjOWViZjI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-26T03:47:27Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-26T14:42:52Z"}, "message": "Wait until type_of to remap HIR opaques back to their defn params", "tree": {"sha": "dfa6749ec2e57eb37209bcda7db1a849247534d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfa6749ec2e57eb37209bcda7db1a849247534d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2", "html_url": "https://github.com/rust-lang/rust/commit/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a810b584cf7bf6f3d0eb02cef441b510475514f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a810b584cf7bf6f3d0eb02cef441b510475514f9", "html_url": "https://github.com/rust-lang/rust/commit/a810b584cf7bf6f3d0eb02cef441b510475514f9"}], "stats": {"total": 147, "additions": 92, "deletions": 55}, "files": [{"sha": "b759a848bf56fb7258c398fe23e3ed1346099fe1", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2", "patch": "@@ -188,9 +188,6 @@ pub(crate) fn type_check<'mir, 'tcx>(\n \n     // FIXME(-Ztrait-solver=next): A bit dubious that we're only registering\n     // predefined opaques in the typeck root.\n-    // FIXME(-Ztrait-solver=next): This is also totally wrong for TAITs, since\n-    // the HIR typeck map defining usages back to their definition params,\n-    // they won't actually match up with the usages in this body...\n     if infcx.tcx.trait_solver_next() && !infcx.tcx.is_typeck_child(body.source.def_id()) {\n         checker.register_predefined_opaques_in_new_solver();\n     }\n@@ -1042,10 +1039,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             .typeck(self.body.source.def_id().expect_local())\n             .concrete_opaque_types\n             .iter()\n-            .map(|(&def_id, &hidden_ty)| {\n-                let substs = ty::InternalSubsts::identity_for_item(self.infcx.tcx, def_id);\n-                (ty::OpaqueTypeKey { def_id, substs }, hidden_ty)\n-            })\n+            .map(|(k, v)| (*k, *v))\n             .collect();\n \n         let renumbered_opaques = self.infcx.tcx.fold_regions(opaques, |_, _| {"}, {"sha": "da82ce1d523d0ed64c6fa4111130561ffc8ab463", "filename": "compiler/rustc_hir_analysis/src/collect/type_of/opaque.rs", "status": "modified", "additions": 66, "deletions": 28, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs?ref=3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2", "patch": "@@ -59,7 +59,20 @@ pub(super) fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: Local\n         }\n     }\n \n-    let Some(hidden) = locator.found else {\n+    if let Some(hidden) = locator.found {\n+        // Only check against typeck if we didn't already error\n+        if !hidden.ty.references_error() {\n+            for concrete_type in locator.typeck_types {\n+                if concrete_type.ty != tcx.erase_regions(hidden.ty)\n+                    && !(concrete_type, hidden).references_error()\n+                {\n+                    hidden.report_mismatch(&concrete_type, def_id, tcx).emit();\n+                }\n+            }\n+        }\n+\n+        hidden.ty\n+    } else {\n         let reported = tcx.sess.emit_err(UnconstrainedOpaqueType {\n             span: tcx.def_span(def_id),\n             name: tcx.item_name(tcx.local_parent(def_id).to_def_id()),\n@@ -70,21 +83,8 @@ pub(super) fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: Local\n                 _ => \"item\",\n             },\n         });\n-        return tcx.ty_error(reported);\n-    };\n-\n-    // Only check against typeck if we didn't already error\n-    if !hidden.ty.references_error() {\n-        for concrete_type in locator.typeck_types {\n-            if concrete_type.ty != tcx.erase_regions(hidden.ty)\n-                && !(concrete_type, hidden).references_error()\n-            {\n-                hidden.report_mismatch(&concrete_type, def_id, tcx).emit();\n-            }\n-        }\n+        tcx.ty_error(reported)\n     }\n-\n-    hidden.ty\n }\n \n struct TaitConstraintLocator<'tcx> {\n@@ -130,13 +130,28 @@ impl TaitConstraintLocator<'_> {\n             self.found = Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error(guar) });\n             return;\n         }\n-        let Some(&typeck_hidden_ty) = tables.concrete_opaque_types.get(&self.def_id) else {\n+\n+        let mut constrained = false;\n+        for (&opaque_type_key, &hidden_type) in &tables.concrete_opaque_types {\n+            if opaque_type_key.def_id != self.def_id {\n+                continue;\n+            }\n+            constrained = true;\n+            let concrete_type =\n+                self.tcx.erase_regions(hidden_type.remap_generic_params_to_declaration_params(\n+                    opaque_type_key,\n+                    self.tcx,\n+                    true,\n+                ));\n+            if self.typeck_types.iter().all(|prev| prev.ty != concrete_type.ty) {\n+                self.typeck_types.push(concrete_type);\n+            }\n+        }\n+\n+        if !constrained {\n             debug!(\"no constraints in typeck results\");\n             return;\n         };\n-        if self.typeck_types.iter().all(|prev| prev.ty != typeck_hidden_ty.ty) {\n-            self.typeck_types.push(typeck_hidden_ty);\n-        }\n \n         // Use borrowck to get the type with unerased regions.\n         let concrete_opaque_types = &self.tcx.mir_borrowck(item_def_id).concrete_opaque_types;\n@@ -190,8 +205,8 @@ impl<'tcx> intravisit::Visitor<'tcx> for TaitConstraintLocator<'tcx> {\n     }\n }\n \n-pub(super) fn find_opaque_ty_constraints_for_rpit(\n-    tcx: TyCtxt<'_>,\n+pub(super) fn find_opaque_ty_constraints_for_rpit<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,\n     owner_def_id: LocalDefId,\n ) -> Ty<'_> {\n@@ -208,27 +223,50 @@ pub(super) fn find_opaque_ty_constraints_for_rpit(\n             Node::TraitItem(it) => intravisit::walk_trait_item(&mut locator, it),\n             other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n         }\n-    }\n \n-    concrete.map(|concrete| concrete.ty).unwrap_or_else(|| {\n-        let table = tcx.typeck(owner_def_id);\n-        if let Some(guar) = table.tainted_by_errors {\n+        concrete.ty\n+    } else {\n+        let tables = tcx.typeck(owner_def_id);\n+        if let Some(guar) = tables.tainted_by_errors {\n             // Some error in the\n             // owner fn prevented us from populating\n             // the `concrete_opaque_types` table.\n             tcx.ty_error(guar)\n         } else {\n-            table.concrete_opaque_types.get(&def_id).map(|ty| ty.ty).unwrap_or_else(|| {\n+            // Fall back to the RPIT we inferred during HIR typeck\n+            let mut opaque_ty: Option<ty::OpaqueHiddenType<'tcx>> = None;\n+            for (&opaque_type_key, &hidden_type) in &tables.concrete_opaque_types {\n+                if opaque_type_key.def_id != def_id {\n+                    continue;\n+                }\n+                let concrete_type =\n+                    tcx.erase_regions(hidden_type.remap_generic_params_to_declaration_params(\n+                        opaque_type_key,\n+                        tcx,\n+                        true,\n+                    ));\n+                if let Some(prev) = &mut opaque_ty {\n+                    if concrete_type.ty != prev.ty && !(concrete_type, prev.ty).references_error() {\n+                        prev.report_mismatch(&concrete_type, def_id, tcx).emit();\n+                    }\n+                } else {\n+                    opaque_ty = Some(concrete_type);\n+                }\n+            }\n+\n+            if let Some(opaque_ty) = opaque_ty {\n+                opaque_ty.ty\n+            } else {\n                 // We failed to resolve the opaque type or it\n                 // resolves to itself. We interpret this as the\n                 // no values of the hidden type ever being constructed,\n                 // so we can just make the hidden type be `!`.\n                 // For backwards compatibility reasons, we fall back to\n                 // `()` until we the diverging default is changed.\n                 tcx.mk_diverging_default()\n-            })\n+            }\n         }\n-    })\n+    }\n }\n \n struct RpitConstraintChecker<'tcx> {"}, {"sha": "964acc4eb77ef803a6741f4fce489302da8cd8c9", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2", "patch": "@@ -583,19 +583,15 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 continue;\n             }\n \n-            let hidden_type =\n-                self.tcx().erase_regions(hidden_type.remap_generic_params_to_declaration_params(\n-                    opaque_type_key,\n-                    self.tcx(),\n-                    true,\n-                ));\n-\n+            // Here we only detect impl trait definition conflicts when they\n+            // are equal modulo regions.\n             if let Some(last_opaque_ty) = self\n                 .typeck_results\n                 .concrete_opaque_types\n-                .insert(opaque_type_key.def_id, hidden_type)\n+                .insert(opaque_type_key, hidden_type)\n                 && last_opaque_ty.ty != hidden_type.ty\n             {\n+                assert!(!self.tcx().trait_solver_next());\n                 hidden_type\n                     .report_mismatch(&last_opaque_ty, opaque_type_key.def_id, self.tcx())\n                     .stash("}, {"sha": "68bae5828c51ad329ca1f30581294d7d1663f7c2", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2", "patch": "@@ -159,7 +159,7 @@ pub struct TypeckResults<'tcx> {\n     /// These types are mapped back to the opaque's identity substitutions\n     /// (with erased regions), which is why we don't associated substs with any\n     /// of these usages.\n-    pub concrete_opaque_types: FxIndexMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n+    pub concrete_opaque_types: FxIndexMap<ty::OpaqueTypeKey<'tcx>, ty::OpaqueHiddenType<'tcx>>,\n \n     /// Tracks the minimum captures required for a closure;\n     /// see `MinCaptureInformationMap` for more details."}, {"sha": "028222f4e6dba451272373f4ed485bdce95aaf57", "filename": "tests/ui/traits/new-solver/dont-remap-tait-substs.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2/tests%2Fui%2Ftraits%2Fnew-solver%2Fdont-remap-tait-substs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2/tests%2Fui%2Ftraits%2Fnew-solver%2Fdont-remap-tait-substs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fdont-remap-tait-substs.rs?ref=3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+// Makes sure we don't prepopulate the MIR typeck of `define`\n+// with `Foo<T, U> = T`, but instead, `Foo<B, A> = B`, so that\n+// the param-env predicates actually apply.\n+\n+#![feature(type_alias_impl_trait)]\n+\n+type Foo<T: Send, U> = impl NeedsSend<T>;\n+\n+trait NeedsSend<T> {}\n+impl<T: Send> NeedsSend<T> for T {}\n+\n+fn define<A, B: Send>(a: A, b: B) {\n+    let y: Option<Foo<B, A>> = Some(b);\n+}\n+\n+fn main() {}"}, {"sha": "da845e86147b7ffb620f880936aae59069a2095f", "filename": "tests/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs?ref=3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2", "patch": "@@ -8,7 +8,6 @@ type X<A, B> = impl Into<&'static A>;\n \n fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) {\n     //~^ ERROR the trait bound `&'static B: From<&A>` is not satisfied\n-    //~| ERROR concrete type differs from previous defining opaque type use\n     (a, a)\n }\n "}, {"sha": "66a6b0bbf743148407ae5faa5a4d9d00815da3aa", "filename": "tests/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn.stderr", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr?ref=3d09b990d7e3d8539a3b9655894e7e05dcc9ebf2", "patch": "@@ -10,15 +10,6 @@ help: consider introducing a `where` clause, but there might be an alternative b\n LL | fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) where &'static B: From<&A> {\n    |                                                                ++++++++++++++++++++++++++\n \n-error: concrete type differs from previous defining opaque type use\n-  --> $DIR/multiple-def-uses-in-one-fn.rs:9:45\n-   |\n-LL | fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) {\n-   |                                             ^^^^^^^^^^^^^^^^^^\n-   |                                             |\n-   |                                             expected `&B`, got `&A`\n-   |                                             this expression supplies two conflicting concrete types for the same opaque type\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0277`."}]}