{"sha": "2c52cb424a3fdad4888dd7b73eb2c19dbd75fc2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNTJjYjQyNGEzZmRhZDQ4ODhkZDdiNzNlYjJjMTlkYmQ3NWZjMmQ=", "commit": {"author": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2015-11-28T10:41:52Z"}, "committer": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2016-01-02T18:46:31Z"}, "message": "Limit displaying relevant trait impls to 4", "tree": {"sha": "afc3d895eb0b5db9464f62f285396a269fb7d9ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afc3d895eb0b5db9464f62f285396a269fb7d9ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c52cb424a3fdad4888dd7b73eb2c19dbd75fc2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c52cb424a3fdad4888dd7b73eb2c19dbd75fc2d", "html_url": "https://github.com/rust-lang/rust/commit/2c52cb424a3fdad4888dd7b73eb2c19dbd75fc2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c52cb424a3fdad4888dd7b73eb2c19dbd75fc2d/comments", "author": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "335298e7b606c80cd7218de64856c10acf3855d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/335298e7b606c80cd7218de64856c10acf3855d5", "html_url": "https://github.com/rust-lang/rust/commit/335298e7b606c80cd7218de64856c10acf3855d5"}], "stats": {"total": 56, "additions": 34, "deletions": 22}, "files": [{"sha": "ef8982219563b6432010d1fd6c1cc5e1ae2bfe94", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2c52cb424a3fdad4888dd7b73eb2c19dbd75fc2d/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c52cb424a3fdad4888dd7b73eb2c19dbd75fc2d/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=2c52cb424a3fdad4888dd7b73eb2c19dbd75fc2d", "patch": "@@ -30,6 +30,7 @@ use middle::ty::{self, ToPredicate, HasTypeFlags, ToPolyTraitRef, TraitRef, Ty};\n use middle::ty::fold::TypeFoldable;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n+use std::cmp;\n use std::fmt;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::codemap::Span;\n@@ -225,38 +226,49 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                 \"the trait `{}` is not implemented for the type `{}`\",\n                                 trait_ref, trait_ref.self_ty());\n \n-                            let mut counter = 1;\n-                            infcx.tcx.sess.fileline_help(\n-                                obligation.cause.span,\n-                                \"the following implementations were found:\");\n-                            infcx.tcx.lookup_trait_def(trait_ref.def_id()).for_each_relevant_impl(\n-                                infcx.tcx,\n-                                trait_ref.self_ty(),\n-                                |impl_def_id| {\n-                                    match infcx.tcx.impl_trait_ref(impl_def_id) {\n-                                        Some(ref imp) => {\n-                                            infcx.tcx.sess.fileline_help(\n-                                                obligation.cause.span,\n-                                                &format!(\"implementation {}: `{}`\", counter, imp));\n-                                            counter += 1;\n-                                        },\n-                                        None => (),\n-                                    }\n-                                }\n-                            );\n-\n                             // Check if it has a custom \"#[rustc_on_unimplemented]\"\n                             // error message, report with that message if it does\n                             let custom_note = report_on_unimplemented(infcx, &trait_ref.0,\n                                                                       obligation.cause.span);\n                             if let Some(s) = custom_note {\n                                 err.fileline_note(obligation.cause.span, &s);\n+                            } else {\n+                                let mut impl_candidates = Vec::new();\n+                                infcx.tcx.lookup_trait_def(trait_ref.def_id())\n+                                         .for_each_relevant_impl(\n+                                    infcx.tcx,\n+                                    trait_ref.self_ty(),\n+                                    |impl_def_id| {\n+                                        match infcx.tcx.impl_trait_ref(impl_def_id) {\n+                                            Some(ref imp) => {\n+                                                impl_candidates.push(format!(\"  {}\", imp));\n+                                            },\n+                                            None => (),\n+                                        }\n+                                    }\n+                                );\n+\n+                                if impl_candidates.len() > 0 {\n+                                    err.fileline_help(\n+                                        obligation.cause.span,\n+                                        &format!(\"the following implementations were found:\"));\n+\n+                                    let end = cmp::min(4, impl_candidates.len());\n+                                    for candidate in &impl_candidates[0..end] {\n+                                        err.fileline_help(obligation.cause.span,\n+                                                                     candidate);\n+                                    }\n+                                    if impl_candidates.len() > 4 {\n+                                        err.fileline_help(obligation.cause.span,\n+                                                          &format!(\"and {} others\",\n+                                                                   impl_candidates.len()-4));\n+                                    }\n+                                }\n                             }\n                             note_obligation_cause(infcx, &mut err, obligation);\n                             err.emit();\n                         }\n-                    }\n-\n+                    },\n                     ty::Predicate::Equate(ref predicate) => {\n                         let predicate = infcx.resolve_type_vars_if_possible(predicate);\n                         let err = infcx.equality_predicate(obligation.cause.span,"}]}