{"sha": "2f37c5a358464bbf2f6ed15ec10766ee54543055", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMzdjNWEzNTg0NjRiYmYyZjZlZDE1ZWMxMDc2NmVlNTQ1NDMwNTU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-03T02:36:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-03T02:36:09Z"}, "message": "Rollup merge of #55448 - Mokosha:SortAtIndex, r=bluss\n\nAdd 'partition_at_index/_by/_by_key' for slices.\n\nThis is an analog to C++'s std::nth_element (a.k.a. quickselect).\n\nCorresponds to tracking bug #55300.", "tree": {"sha": "1d5bd2daae0dbaf5938ed2a8191abbc9c69dd1b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d5bd2daae0dbaf5938ed2a8191abbc9c69dd1b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f37c5a358464bbf2f6ed15ec10766ee54543055", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcpBwaCRBK7hj4Ov3rIwAAdHIIAFooLm7hgGnGfER3mDDfOGf7\nXsVerqsSCx8sME/yAZs9gkCGb7ZyHpQU5Sje3S6LFzS/Vg49S5VdLRZeHU8QOqE6\n7FFvHOy2XF3cA7cldJO9ImowML719ci/DBynL5UO+8yDAM+NuFqBIaK8Rzg10rV2\nnK+3mx1KH6N9vnmJWiXlt4wpN2eeQDIwx4By1v6N9CQnszt/UtfAXluPI5bp2PvD\nP7fV9+ws7xKTUiyebm8utKZJUPTCVbrhPM7AncnF1+n6EjJVd/UnFuMyC4XtGiOg\nG8Bx2jM8WaqragKiBVbbYAD2vZzYpenb+s+JxXgBYuM+UDc0r8GkVH6MZn54oeA=\n=ZFF3\n-----END PGP SIGNATURE-----\n", "payload": "tree 1d5bd2daae0dbaf5938ed2a8191abbc9c69dd1b2\nparent 7641873f591dca86e2b31f60fc76b39553892631\nparent 3f306db3dbe390f43c7dfa8e17630747723e39e3\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1554258969 +0200\ncommitter GitHub <noreply@github.com> 1554258969 +0200\n\nRollup merge of #55448 - Mokosha:SortAtIndex, r=bluss\n\nAdd 'partition_at_index/_by/_by_key' for slices.\n\nThis is an analog to C++'s std::nth_element (a.k.a. quickselect).\n\nCorresponds to tracking bug #55300.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f37c5a358464bbf2f6ed15ec10766ee54543055", "html_url": "https://github.com/rust-lang/rust/commit/2f37c5a358464bbf2f6ed15ec10766ee54543055", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f37c5a358464bbf2f6ed15ec10766ee54543055/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7641873f591dca86e2b31f60fc76b39553892631", "url": "https://api.github.com/repos/rust-lang/rust/commits/7641873f591dca86e2b31f60fc76b39553892631", "html_url": "https://github.com/rust-lang/rust/commit/7641873f591dca86e2b31f60fc76b39553892631"}, {"sha": "3f306db3dbe390f43c7dfa8e17630747723e39e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f306db3dbe390f43c7dfa8e17630747723e39e3", "html_url": "https://github.com/rust-lang/rust/commit/3f306db3dbe390f43c7dfa8e17630747723e39e3"}], "stats": {"total": 355, "additions": 355, "deletions": 0}, "files": [{"sha": "122ef9c79c2764f258423526497621ecd0f473d3", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/2f37c5a358464bbf2f6ed15ec10766ee54543055/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f37c5a358464bbf2f6ed15ec10766ee54543055/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=2f37c5a358464bbf2f6ed15ec10766ee54543055", "patch": "@@ -1585,6 +1585,153 @@ impl<T> [T] {\n         sort::quicksort(self, |a, b| f(a).lt(&f(b)));\n     }\n \n+    /// Reorder the slice such that the element at `index` is at its final sorted position.\n+    ///\n+    /// This reordering has the additional property that any value at position `i < index` will be\n+    /// less than or equal to any value at a position `j > index`. Additionally, this reordering is\n+    /// unstable (i.e. any number of equal elements may end up at position `index`), in-place\n+    /// (i.e. does not allocate), and `O(n)` worst-case. This function is also/ known as \"kth\n+    /// element\" in other libraries. It returns a triplet of the following values: all elements less\n+    /// than the one at the given index, the value at the given index, and all elements greater than\n+    /// the one at the given index.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n+    /// used for [`sort_unstable`].\n+    ///\n+    /// [`sort_unstable`]: #method.sort_unstable\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics when `index >= len()`, meaning it always panics on empty slices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_at_index)]\n+    ///\n+    /// let mut v = [-5i32, 4, 1, -3, 2];\n+    ///\n+    /// // Find the median\n+    /// v.partition_at_index(2);\n+    ///\n+    /// // We are only guaranteed the slice will be one of the following, based on the way we sort\n+    /// // about the specified index.\n+    /// assert!(v == [-3, -5, 1, 2, 4] ||\n+    ///         v == [-5, -3, 1, 2, 4] ||\n+    ///         v == [-3, -5, 1, 4, 2] ||\n+    ///         v == [-5, -3, 1, 4, 2]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_at_index\", issue = \"55300\")]\n+    #[inline]\n+    pub fn partition_at_index(&mut self, index: usize) -> (&mut [T], &mut T, &mut [T])\n+        where T: Ord\n+    {\n+        let mut f = |a: &T, b: &T| a.lt(b);\n+        sort::partition_at_index(self, index, &mut f)\n+    }\n+\n+    /// Reorder the slice with a comparator function such that the element at `index` is at its\n+    /// final sorted position.\n+    ///\n+    /// This reordering has the additional property that any value at position `i < index` will be\n+    /// less than or equal to any value at a position `j > index` using the comparator function.\n+    /// Additionally, this reordering is unstable (i.e. any number of equal elements may end up at\n+    /// position `index`), in-place (i.e. does not allocate), and `O(n)` worst-case. This function\n+    /// is also known as \"kth element\" in other libraries. It returns a triplet of the following\n+    /// values: all elements less than the one at the given index, the value at the given index,\n+    /// and all elements greater than the one at the given index, using the provided comparator\n+    /// function.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n+    /// used for [`sort_unstable`].\n+    ///\n+    /// [`sort_unstable`]: #method.sort_unstable\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics when `index >= len()`, meaning it always panics on empty slices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_at_index)]\n+    ///\n+    /// let mut v = [-5i32, 4, 1, -3, 2];\n+    ///\n+    /// // Find the median as if the slice were sorted in descending order.\n+    /// v.partition_at_index_by(2, |a, b| b.cmp(a));\n+    ///\n+    /// // We are only guaranteed the slice will be one of the following, based on the way we sort\n+    /// // about the specified index.\n+    /// assert!(v == [2, 4, 1, -5, -3] ||\n+    ///         v == [2, 4, 1, -3, -5] ||\n+    ///         v == [4, 2, 1, -5, -3] ||\n+    ///         v == [4, 2, 1, -3, -5]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_at_index\", issue = \"55300\")]\n+    #[inline]\n+    pub fn partition_at_index_by<F>(&mut self, index: usize, mut compare: F)\n+                                    -> (&mut [T], &mut T, &mut [T])\n+        where F: FnMut(&T, &T) -> Ordering\n+    {\n+        let mut f = |a: &T, b: &T| compare(a, b) == Less;\n+        sort::partition_at_index(self, index, &mut f)\n+    }\n+\n+    /// Reorder the slice with a key extraction function such that the element at `index` is at its\n+    /// final sorted position.\n+    ///\n+    /// This reordering has the additional property that any value at position `i < index` will be\n+    /// less than or equal to any value at a position `j > index` using the key extraction function.\n+    /// Additionally, this reordering is unstable (i.e. any number of equal elements may end up at\n+    /// position `index`), in-place (i.e. does not allocate), and `O(n)` worst-case. This function\n+    /// is also known as \"kth element\" in other libraries. It returns a triplet of the following\n+    /// values: all elements less than the one at the given index, the value at the given index, and\n+    /// all elements greater than the one at the given index, using the provided key extraction\n+    /// function.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n+    /// used for [`sort_unstable`].\n+    ///\n+    /// [`sort_unstable`]: #method.sort_unstable\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics when `index >= len()`, meaning it always panics on empty slices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_at_index)]\n+    ///\n+    /// let mut v = [-5i32, 4, 1, -3, 2];\n+    ///\n+    /// // Return the median as if the array were sorted according to absolute value.\n+    /// v.partition_at_index_by_key(2, |a| a.abs());\n+    ///\n+    /// // We are only guaranteed the slice will be one of the following, based on the way we sort\n+    /// // about the specified index.\n+    /// assert!(v == [1, 2, -3, 4, -5] ||\n+    ///         v == [1, 2, -3, -5, 4] ||\n+    ///         v == [2, 1, -3, 4, -5] ||\n+    ///         v == [2, 1, -3, -5, 4]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_at_index\", issue = \"55300\")]\n+    #[inline]\n+    pub fn partition_at_index_by_key<K, F>(&mut self, index: usize, mut f: F)\n+                                           -> (&mut [T], &mut T, &mut [T])\n+        where F: FnMut(&T) -> K, K: Ord\n+    {\n+        let mut g = |a: &T, b: &T| f(a).lt(&f(b));\n+        sort::partition_at_index(self, index, &mut g)\n+    }\n+\n     /// Moves all consecutive repeated elements to the end of the slice according to the\n     /// [`PartialEq`] trait implementation.\n     ///"}, {"sha": "68f1fb4b526adf902069592e1b57dab09730d612", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/2f37c5a358464bbf2f6ed15ec10766ee54543055/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f37c5a358464bbf2f6ed15ec10766ee54543055/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=2f37c5a358464bbf2f6ed15ec10766ee54543055", "patch": "@@ -691,3 +691,92 @@ pub fn quicksort<T, F>(v: &mut [T], mut is_less: F)\n \n     recurse(v, &mut is_less, None, limit);\n }\n+\n+fn partition_at_index_loop<'a, T, F>( mut v: &'a mut [T], mut index: usize, is_less: &mut F\n+                                    , mut pred: Option<&'a T>) where F: FnMut(&T, &T) -> bool\n+{\n+    loop {\n+        // For slices of up to this length it's probably faster to simply sort them.\n+        const MAX_INSERTION: usize = 10;\n+        if v.len() <= MAX_INSERTION {\n+            insertion_sort(v, is_less);\n+            return;\n+        }\n+\n+        // Choose a pivot\n+        let (pivot, _) = choose_pivot(v, is_less);\n+\n+        // If the chosen pivot is equal to the predecessor, then it's the smallest element in the\n+        // slice. Partition the slice into elements equal to and elements greater than the pivot.\n+        // This case is usually hit when the slice contains many duplicate elements.\n+        if let Some(p) = pred {\n+            if !is_less(p, &v[pivot]) {\n+                let mid = partition_equal(v, pivot, is_less);\n+\n+                // If we've passed our index, then we're good.\n+                if mid > index {\n+                    return;\n+                }\n+\n+                // Otherwise, continue sorting elements greater than the pivot.\n+                v = &mut v[mid..];\n+                index = index - mid;\n+                pred = None;\n+                continue;\n+            }\n+        }\n+\n+        let (mid, _) = partition(v, pivot, is_less);\n+\n+        // Split the slice into `left`, `pivot`, and `right`.\n+        let (left, right) = {v}.split_at_mut(mid);\n+        let (pivot, right) = right.split_at_mut(1);\n+        let pivot = &pivot[0];\n+\n+        if mid < index {\n+            v = right;\n+            index = index - mid - 1;\n+            pred = Some(pivot);\n+        } else if mid > index {\n+            v = left;\n+        } else {\n+            // If mid == index, then we're done, since partition() guaranteed that all elements\n+            // after mid are greater than or equal to mid.\n+            return;\n+        }\n+    }\n+}\n+\n+pub fn partition_at_index<T, F>(v: &mut [T], index: usize, mut is_less: F)\n+                                -> (&mut [T], &mut T, &mut [T]) where F: FnMut(&T, &T) -> bool\n+{\n+    use cmp::Ordering::Less;\n+    use cmp::Ordering::Greater;\n+\n+    if index >= v.len() {\n+        panic!(\"partition_at_index index {} greater than length of slice {}\", index, v.len());\n+    }\n+\n+    if mem::size_of::<T>() == 0 {\n+        // Sorting has no meaningful behavior on zero-sized types. Do nothing.\n+    } else if index == v.len() - 1 {\n+        // Find max element and place it in the last position of the array. We're free to use\n+        // `unwrap()` here because we know v must not be empty.\n+        let (max_index, _) = v.iter().enumerate().max_by(\n+            |&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater }).unwrap();\n+        v.swap(max_index, index);\n+    } else if index == 0 {\n+        // Find min element and place it in the first position of the array. We're free to use\n+        // `unwrap()` here because we know v must not be empty.\n+        let (min_index, _) = v.iter().enumerate().min_by(\n+            |&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater }).unwrap();\n+        v.swap(min_index, index);\n+    } else {\n+        partition_at_index_loop(v, index, &mut is_less, None);\n+    }\n+\n+    let (left, right) = v.split_at_mut(index);\n+    let (pivot, right) = right.split_at_mut(1);\n+    let pivot = &mut pivot[0];\n+    (left, pivot, right)\n+}"}, {"sha": "392a0ffabe3d62b5cf74ac6f2e0bf3efe0ec5074", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f37c5a358464bbf2f6ed15ec10766ee54543055/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f37c5a358464bbf2f6ed15ec10766ee54543055/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=2f37c5a358464bbf2f6ed15ec10766ee54543055", "patch": "@@ -18,6 +18,7 @@\n #![feature(raw)]\n #![feature(slice_patterns)]\n #![feature(sort_internals)]\n+#![feature(slice_partition_at_index)]\n #![feature(specialization)]\n #![feature(step_trait)]\n #![feature(str_internals)]"}, {"sha": "007283b5f69c874201ce6bf3bd10626c4f3663e2", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/2f37c5a358464bbf2f6ed15ec10766ee54543055/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f37c5a358464bbf2f6ed15ec10766ee54543055/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=2f37c5a358464bbf2f6ed15ec10766ee54543055", "patch": "@@ -1093,6 +1093,124 @@ fn sort_unstable() {\n     assert!(v == [0xDEADBEEF]);\n }\n \n+#[test]\n+#[cfg(not(target_arch = \"wasm32\"))]\n+#[cfg(not(miri))] // Miri does not support entropy\n+fn partition_at_index() {\n+    use core::cmp::Ordering::{Equal, Greater, Less};\n+    use rand::rngs::SmallRng;\n+    use rand::seq::SliceRandom;\n+    use rand::{FromEntropy, Rng};\n+\n+    let mut rng = SmallRng::from_entropy();\n+\n+    for len in (2..21).chain(500..501) {\n+        let mut orig = vec![0; len];\n+\n+        for &modulus in &[5, 10, 1000] {\n+            for _ in 0..10 {\n+                for i in 0..len {\n+                    orig[i] = rng.gen::<i32>() % modulus;\n+                }\n+\n+                let v_sorted = {\n+                    let mut v = orig.clone();\n+                    v.sort();\n+                    v\n+                };\n+\n+                // Sort in default order.\n+                for pivot in 0..len {\n+                    let mut v = orig.clone();\n+                    v.partition_at_index(pivot);\n+\n+                    assert_eq!(v_sorted[pivot], v[pivot]);\n+                    for i in 0..pivot {\n+                        for j in pivot..len {\n+                            assert!(v[i] <= v[j]);\n+                        }\n+                    }\n+                }\n+\n+                // Sort in ascending order.\n+                for pivot in 0..len {\n+                    let mut v = orig.clone();\n+                    let (left, pivot, right) = v.partition_at_index_by(pivot, |a, b| a.cmp(b));\n+\n+                    assert_eq!(left.len() + right.len(), len - 1);\n+\n+                    for l in left {\n+                        assert!(l <= pivot);\n+                        for r in right.iter_mut() {\n+                            assert!(l <= r);\n+                            assert!(pivot <= r);\n+                        }\n+                    }\n+                }\n+\n+                // Sort in descending order.\n+                let sort_descending_comparator = |a: &i32, b: &i32| b.cmp(a);\n+                let v_sorted_descending = {\n+                    let mut v = orig.clone();\n+                    v.sort_by(sort_descending_comparator);\n+                    v\n+                };\n+\n+                for pivot in 0..len {\n+                    let mut v = orig.clone();\n+                    v.partition_at_index_by(pivot, sort_descending_comparator);\n+\n+                    assert_eq!(v_sorted_descending[pivot], v[pivot]);\n+                    for i in 0..pivot {\n+                        for j in pivot..len {\n+                            assert!(v[j] <= v[i]);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Sort at index using a completely random comparison function.\n+    // This will reorder the elements *somehow*, but won't panic.\n+    let mut v = [0; 500];\n+    for i in 0..v.len() {\n+        v[i] = i as i32;\n+    }\n+\n+    for pivot in 0..v.len() {\n+        v.partition_at_index_by(pivot, |_, _| *[Less, Equal, Greater].choose(&mut rng).unwrap());\n+        v.sort();\n+        for i in 0..v.len() {\n+            assert_eq!(v[i], i as i32);\n+        }\n+    }\n+\n+    // Should not panic.\n+    [(); 10].partition_at_index(0);\n+    [(); 10].partition_at_index(5);\n+    [(); 10].partition_at_index(9);\n+    [(); 100].partition_at_index(0);\n+    [(); 100].partition_at_index(50);\n+    [(); 100].partition_at_index(99);\n+\n+    let mut v = [0xDEADBEEFu64];\n+    v.partition_at_index(0);\n+    assert!(v == [0xDEADBEEF]);\n+}\n+\n+#[test]\n+#[should_panic(expected = \"index 0 greater than length of slice\")]\n+fn partition_at_index_zero_length() {\n+    [0i32; 0].partition_at_index(0);\n+}\n+\n+#[test]\n+#[should_panic(expected = \"index 20 greater than length of slice\")]\n+fn partition_at_index_past_length() {\n+    [0i32; 10].partition_at_index(20);\n+}\n+\n pub mod memchr {\n     use core::slice::memchr::{memchr, memrchr};\n "}]}