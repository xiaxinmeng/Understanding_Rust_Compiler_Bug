{"sha": "07f5ab10096718a296825b3b628081559d738810", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ZjVhYjEwMDk2NzE4YTI5NjgyNWIzYjYyODA4MTU1OWQ3Mzg4MTA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-06-15T01:27:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-06-15T02:12:37Z"}, "message": "Implement a deriving(Zero) attribute", "tree": {"sha": "77423ce7bc24607a0f85de6af86fdc487fc15c4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77423ce7bc24607a0f85de6af86fdc487fc15c4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07f5ab10096718a296825b3b628081559d738810", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07f5ab10096718a296825b3b628081559d738810", "html_url": "https://github.com/rust-lang/rust/commit/07f5ab10096718a296825b3b628081559d738810", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07f5ab10096718a296825b3b628081559d738810/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eadd83da8b9abc821b141195503836b2094a9ea3", "url": "https://api.github.com/repos/rust-lang/rust/commits/eadd83da8b9abc821b141195503836b2094a9ea3", "html_url": "https://github.com/rust-lang/rust/commit/eadd83da8b9abc821b141195503836b2094a9ea3"}], "stats": {"total": 138, "additions": 138, "deletions": 0}, "files": [{"sha": "690690268011aef72874f3be00b2889f564b9792", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07f5ab10096718a296825b3b628081559d738810/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f5ab10096718a296825b3b628081559d738810/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=07f5ab10096718a296825b3b628081559d738810", "patch": "@@ -32,6 +32,7 @@ pub mod encodable;\n pub mod decodable;\n pub mod rand;\n pub mod to_str;\n+pub mod zero;\n \n #[path=\"cmp/eq.rs\"]\n pub mod eq;\n@@ -99,6 +100,7 @@ pub fn expand_meta_deriving(cx: @ExtCtxt,\n                             \"Rand\" => expand!(rand::expand_deriving_rand),\n \n                             \"ToStr\" => expand!(to_str::expand_deriving_to_str),\n+                            \"Zero\" => expand!(zero::expand_deriving_zero),\n \n                             ref tname => {\n                                 cx.span_err(titem.span, fmt!(\"unknown \\"}, {"sha": "121d8351ee477f6f941aadd0abe71feeef214444", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/07f5ab10096718a296825b3b628081559d738810/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f5ab10096718a296825b3b628081559d738810/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=07f5ab10096718a296825b3b628081559d738810", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use ast::{meta_item, item, expr};\n+use codemap::span;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use ext::deriving::generic::*;\n+\n+use core::vec;\n+\n+pub fn expand_deriving_zero(cx: @ExtCtxt,\n+                            span: span,\n+                            mitem: @meta_item,\n+                            in_items: ~[@item])\n+    -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: Path::new(~[\"std\", \"num\", \"Zero\"]),\n+        additional_bounds: ~[],\n+        generics: LifetimeBounds::empty(),\n+        methods: ~[\n+            MethodDef {\n+                name: \"zero\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: None,\n+                args: ~[],\n+                ret_ty: Self,\n+                const_nonmatching: false,\n+                combine_substructure: zero_substructure\n+            },\n+            MethodDef {\n+                name: \"is_zero\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: borrowed_explicit_self(),\n+                args: ~[],\n+                ret_ty: Literal(Path::new(~[\"bool\"])),\n+                const_nonmatching: false,\n+                combine_substructure: |cx, span, substr| {\n+                    cs_and(|cx, span, _, _| cx.span_bug(span,\n+                                                        \"Non-matching enum \\\n+                                                         variant in \\\n+                                                         deriving(Zero)\"),\n+                           cx, span, substr)\n+                }\n+            }\n+        ]\n+    };\n+    trait_def.expand(cx, span, mitem, in_items)\n+}\n+\n+fn zero_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n+    let zero_ident = ~[\n+        cx.ident_of(\"std\"),\n+        cx.ident_of(\"num\"),\n+        cx.ident_of(\"Zero\"),\n+        cx.ident_of(\"zero\")\n+    ];\n+    let zero_call = || {\n+        cx.expr_call_global(span, copy zero_ident, ~[])\n+    };\n+\n+    return match *substr.fields {\n+        StaticStruct(_, ref summary) => {\n+            match *summary {\n+                Left(count) => {\n+                    if count == 0 {\n+                        cx.expr_ident(span, substr.type_ident)\n+                    } else {\n+                        let exprs = vec::from_fn(count, |_| zero_call());\n+                        cx.expr_call_ident(span, substr.type_ident, exprs)\n+                    }\n+                }\n+                Right(ref fields) => {\n+                    let zero_fields = do fields.map |ident| {\n+                        cx.field_imm(span, *ident, zero_call())\n+                    };\n+                    cx.expr_struct_ident(span, substr.type_ident, zero_fields)\n+                }\n+            }\n+        }\n+        StaticEnum(*) => {\n+            cx.span_fatal(span, \"`Zero` cannot be derived for enums, \\\n+                                 only structs\")\n+        }\n+        _ => cx.bug(\"Non-static method in `deriving(Zero)`\")\n+    };\n+}"}, {"sha": "2ee57624112fae4ecf4b0aa62c69fb3aaab0063b", "filename": "src/test/run-pass/deriving-zero.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/07f5ab10096718a296825b3b628081559d738810/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f5ab10096718a296825b3b628081559d738810/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-zero.rs?ref=07f5ab10096718a296825b3b628081559d738810", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::util;\n+use std::num::Zero;\n+\n+#[deriving(Zero)]\n+struct A;\n+#[deriving(Zero)]\n+struct B(int);\n+#[deriving(Zero)]\n+struct C(int, int);\n+#[deriving(Zero)]\n+struct D { a: int }\n+#[deriving(Zero)]\n+struct E { a: int, b: int }\n+\n+#[deriving(Zero)]\n+struct Lots {\n+    a: ~str,\n+    b: @str,\n+    c: Option<util::NonCopyable>,\n+    d: u8,\n+    e: char,\n+    f: float,\n+    g: (f32, char),\n+    h: ~[util::NonCopyable],\n+    i: @mut (int, int),\n+}\n+\n+fn main() {\n+    assert!(Zero::zero::<Lots>().is_zero());\n+}"}]}