{"sha": "65ecc481fac7ceced57d973a580d0a7ccbdcb192", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ZWNjNDgxZmFjN2NlY2VkNTdkOTczYTU4MGQwYTdjY2JkY2IxOTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-26T16:31:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-26T16:31:12Z"}, "message": "Auto merge of #77467 - jyn514:query-docs, r=oli-obk\n\nNormalize `<X as Y>::T` for rustdoc\n\n- Only run for `QPath::Resolved` with `Some` self parameter (`<X as Y>::T`)\n- Fall back to the previous behavior if the path can't be resolved\n\nThe first commit is a pure refactor and should probably be reviewed by `@GuillaumeGomez.` I recommend reviewing the second commit on its own.\n\nFixes https://github.com/rust-lang/rust/issues/77459.\n\nr? `@eddyb`\ncc `@danielhenrymantilla` , `@lcnr`", "tree": {"sha": "aacd240feea9dd3a35c7c5cc3dfee2bceab76dbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aacd240feea9dd3a35c7c5cc3dfee2bceab76dbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65ecc481fac7ceced57d973a580d0a7ccbdcb192", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65ecc481fac7ceced57d973a580d0a7ccbdcb192", "html_url": "https://github.com/rust-lang/rust/commit/65ecc481fac7ceced57d973a580d0a7ccbdcb192", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65ecc481fac7ceced57d973a580d0a7ccbdcb192/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0beba9333754ead8febc5101fc5c35f7dcdfaadf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0beba9333754ead8febc5101fc5c35f7dcdfaadf", "html_url": "https://github.com/rust-lang/rust/commit/0beba9333754ead8febc5101fc5c35f7dcdfaadf"}, {"sha": "277bdbc0ed0f1f87e8d340233d7f485fbbe8cc66", "url": "https://api.github.com/repos/rust-lang/rust/commits/277bdbc0ed0f1f87e8d340233d7f485fbbe8cc66", "html_url": "https://github.com/rust-lang/rust/commit/277bdbc0ed0f1f87e8d340233d7f485fbbe8cc66"}], "stats": {"total": 719, "additions": 435, "deletions": 284}, "files": [{"sha": "ea34085823f6e8142c9ebb16b89e76353dff42fd", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 341, "deletions": 282, "changes": 623, "blob_url": "https://github.com/rust-lang/rust/blob/65ecc481fac7ceced57d973a580d0a7ccbdcb192/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ecc481fac7ceced57d973a580d0a7ccbdcb192/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=65ecc481fac7ceced57d973a580d0a7ccbdcb192", "patch": "@@ -1067,63 +1067,68 @@ impl Clean<TypeKind> for hir::def::DefKind {\n impl Clean<Item> for hir::TraitItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let local_did = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n-        let inner = match self.kind {\n-            hir::TraitItemKind::Const(ref ty, default) => {\n-                AssocConstItem(ty.clean(cx), default.map(|e| print_const_expr(cx, e)))\n-            }\n-            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                let mut m = (sig, &self.generics, body).clean(cx);\n-                if m.header.constness == hir::Constness::Const\n-                    && is_unstable_const_fn(cx.tcx, local_did).is_some()\n-                {\n-                    m.header.constness = hir::Constness::NotConst;\n+        cx.with_param_env(local_did, || {\n+            let inner = match self.kind {\n+                hir::TraitItemKind::Const(ref ty, default) => {\n+                    AssocConstItem(ty.clean(cx), default.map(|e| print_const_expr(cx, e)))\n                 }\n-                MethodItem(m, None)\n-            }\n-            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(ref names)) => {\n-                let (generics, decl) = enter_impl_trait(cx, || {\n-                    (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n-                });\n-                let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n-                let mut t = Function { header: sig.header, decl, generics, all_types, ret_types };\n-                if t.header.constness == hir::Constness::Const\n-                    && is_unstable_const_fn(cx.tcx, local_did).is_some()\n-                {\n-                    t.header.constness = hir::Constness::NotConst;\n+                hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n+                    let mut m = (sig, &self.generics, body).clean(cx);\n+                    if m.header.constness == hir::Constness::Const\n+                        && is_unstable_const_fn(cx.tcx, local_did).is_some()\n+                    {\n+                        m.header.constness = hir::Constness::NotConst;\n+                    }\n+                    MethodItem(m, None)\n                 }\n-                TyMethodItem(t)\n-            }\n-            hir::TraitItemKind::Type(ref bounds, ref default) => {\n-                AssocTypeItem(bounds.clean(cx), default.clean(cx))\n-            }\n-        };\n-        Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx)\n+                hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(ref names)) => {\n+                    let (generics, decl) = enter_impl_trait(cx, || {\n+                        (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n+                    });\n+                    let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n+                    let mut t =\n+                        Function { header: sig.header, decl, generics, all_types, ret_types };\n+                    if t.header.constness == hir::Constness::Const\n+                        && is_unstable_const_fn(cx.tcx, local_did).is_some()\n+                    {\n+                        t.header.constness = hir::Constness::NotConst;\n+                    }\n+                    TyMethodItem(t)\n+                }\n+                hir::TraitItemKind::Type(ref bounds, ref default) => {\n+                    AssocTypeItem(bounds.clean(cx), default.clean(cx))\n+                }\n+            };\n+            Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx)\n+        })\n     }\n }\n \n impl Clean<Item> for hir::ImplItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let local_did = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n-        let inner = match self.kind {\n-            hir::ImplItemKind::Const(ref ty, expr) => {\n-                AssocConstItem(ty.clean(cx), Some(print_const_expr(cx, expr)))\n-            }\n-            hir::ImplItemKind::Fn(ref sig, body) => {\n-                let mut m = (sig, &self.generics, body).clean(cx);\n-                if m.header.constness == hir::Constness::Const\n-                    && is_unstable_const_fn(cx.tcx, local_did).is_some()\n-                {\n-                    m.header.constness = hir::Constness::NotConst;\n+        cx.with_param_env(local_did, || {\n+            let inner = match self.kind {\n+                hir::ImplItemKind::Const(ref ty, expr) => {\n+                    AssocConstItem(ty.clean(cx), Some(print_const_expr(cx, expr)))\n                 }\n-                MethodItem(m, Some(self.defaultness))\n-            }\n-            hir::ImplItemKind::TyAlias(ref ty) => {\n-                let type_ = ty.clean(cx);\n-                let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n-                TypedefItem(Typedef { type_, generics: Generics::default(), item_type }, true)\n-            }\n-        };\n-        Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx)\n+                hir::ImplItemKind::Fn(ref sig, body) => {\n+                    let mut m = (sig, &self.generics, body).clean(cx);\n+                    if m.header.constness == hir::Constness::Const\n+                        && is_unstable_const_fn(cx.tcx, local_did).is_some()\n+                    {\n+                        m.header.constness = hir::Constness::NotConst;\n+                    }\n+                    MethodItem(m, Some(self.defaultness))\n+                }\n+                hir::ImplItemKind::TyAlias(ref ty) => {\n+                    let type_ = ty.clean(cx);\n+                    let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n+                    TypedefItem(Typedef { type_, generics: Generics::default(), item_type }, true)\n+                }\n+            };\n+            Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx)\n+        })\n     }\n }\n \n@@ -1283,6 +1288,157 @@ impl Clean<Item> for ty::AssocItem {\n     }\n }\n \n+fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &DocContext<'_>) -> Type {\n+    use rustc_hir::GenericParamCount;\n+    let hir::Ty { hir_id, span, ref kind } = *hir_ty;\n+    let qpath = match kind {\n+        hir::TyKind::Path(qpath) => qpath,\n+        _ => unreachable!(),\n+    };\n+\n+    match qpath {\n+        hir::QPath::Resolved(None, ref path) => {\n+            if let Res::Def(DefKind::TyParam, did) = path.res {\n+                if let Some(new_ty) = cx.ty_substs.borrow().get(&did).cloned() {\n+                    return new_ty;\n+                }\n+                if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&did.into()) {\n+                    return ImplTrait(bounds);\n+                }\n+            }\n+\n+            let mut alias = None;\n+            if let Res::Def(DefKind::TyAlias, def_id) = path.res {\n+                // Substitute private type aliases\n+                if let Some(def_id) = def_id.as_local() {\n+                    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n+                    if !cx.renderinfo.borrow().access_levels.is_exported(def_id.to_def_id()) {\n+                        alias = Some(&cx.tcx.hir().expect_item(hir_id).kind);\n+                    }\n+                }\n+            };\n+\n+            if let Some(&hir::ItemKind::TyAlias(ref ty, ref generics)) = alias {\n+                let provided_params = &path.segments.last().expect(\"segments were empty\");\n+                let mut ty_substs = FxHashMap::default();\n+                let mut lt_substs = FxHashMap::default();\n+                let mut ct_substs = FxHashMap::default();\n+                let generic_args = provided_params.generic_args();\n+                {\n+                    let mut indices: GenericParamCount = Default::default();\n+                    for param in generics.params.iter() {\n+                        match param.kind {\n+                            hir::GenericParamKind::Lifetime { .. } => {\n+                                let mut j = 0;\n+                                let lifetime = generic_args.args.iter().find_map(|arg| match arg {\n+                                    hir::GenericArg::Lifetime(lt) => {\n+                                        if indices.lifetimes == j {\n+                                            return Some(lt);\n+                                        }\n+                                        j += 1;\n+                                        None\n+                                    }\n+                                    _ => None,\n+                                });\n+                                if let Some(lt) = lifetime.cloned() {\n+                                    let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                                    let cleaned = if !lt.is_elided() {\n+                                        lt.clean(cx)\n+                                    } else {\n+                                        self::types::Lifetime::elided()\n+                                    };\n+                                    lt_substs.insert(lt_def_id.to_def_id(), cleaned);\n+                                }\n+                                indices.lifetimes += 1;\n+                            }\n+                            hir::GenericParamKind::Type { ref default, .. } => {\n+                                let ty_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                                let mut j = 0;\n+                                let type_ = generic_args.args.iter().find_map(|arg| match arg {\n+                                    hir::GenericArg::Type(ty) => {\n+                                        if indices.types == j {\n+                                            return Some(ty);\n+                                        }\n+                                        j += 1;\n+                                        None\n+                                    }\n+                                    _ => None,\n+                                });\n+                                if let Some(ty) = type_ {\n+                                    ty_substs.insert(ty_param_def_id.to_def_id(), ty.clean(cx));\n+                                } else if let Some(default) = *default {\n+                                    ty_substs\n+                                        .insert(ty_param_def_id.to_def_id(), default.clean(cx));\n+                                }\n+                                indices.types += 1;\n+                            }\n+                            hir::GenericParamKind::Const { .. } => {\n+                                let const_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                                let mut j = 0;\n+                                let const_ = generic_args.args.iter().find_map(|arg| match arg {\n+                                    hir::GenericArg::Const(ct) => {\n+                                        if indices.consts == j {\n+                                            return Some(ct);\n+                                        }\n+                                        j += 1;\n+                                        None\n+                                    }\n+                                    _ => None,\n+                                });\n+                                if let Some(ct) = const_ {\n+                                    ct_substs.insert(const_param_def_id.to_def_id(), ct.clean(cx));\n+                                }\n+                                // FIXME(const_generics:defaults)\n+                                indices.consts += 1;\n+                            }\n+                        }\n+                    }\n+                }\n+                return cx.enter_alias(ty_substs, lt_substs, ct_substs, || ty.clean(cx));\n+            }\n+            resolve_type(cx, path.clean(cx), hir_id)\n+        }\n+        hir::QPath::Resolved(Some(ref qself), ref p) => {\n+            // Try to normalize `<X as Y>::T` to a type\n+            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+            if let Some(normalized_value) = normalize(cx, ty) {\n+                return normalized_value.clean(cx);\n+            }\n+\n+            let segments = if p.is_global() { &p.segments[1..] } else { &p.segments };\n+            let trait_segments = &segments[..segments.len() - 1];\n+            let trait_path = self::Path {\n+                global: p.is_global(),\n+                res: Res::Def(\n+                    DefKind::Trait,\n+                    cx.tcx.associated_item(p.res.def_id()).container.id(),\n+                ),\n+                segments: trait_segments.clean(cx),\n+            };\n+            Type::QPath {\n+                name: p.segments.last().expect(\"segments were empty\").ident.name.clean(cx),\n+                self_type: box qself.clean(cx),\n+                trait_: box resolve_type(cx, trait_path, hir_id),\n+            }\n+        }\n+        hir::QPath::TypeRelative(ref qself, ref segment) => {\n+            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+            let res = if let ty::Projection(proj) = ty.kind() {\n+                Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id)\n+            } else {\n+                Res::Err\n+            };\n+            let trait_path = hir::Path { span, res, segments: &[] };\n+            Type::QPath {\n+                name: segment.ident.name.clean(cx),\n+                self_type: box qself.clean(cx),\n+                trait_: box resolve_type(cx, trait_path.clean(cx), hir_id),\n+            }\n+        }\n+        hir::QPath::LangItem(..) => bug!(\"clean: requiring documentation of lang item\"),\n+    }\n+}\n+\n impl Clean<Type> for hir::Ty<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Type {\n         use rustc_hir::*;\n@@ -1318,145 +1474,7 @@ impl Clean<Type> for hir::Ty<'_> {\n                     unreachable!()\n                 }\n             }\n-            TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n-                if let Res::Def(DefKind::TyParam, did) = path.res {\n-                    if let Some(new_ty) = cx.ty_substs.borrow().get(&did).cloned() {\n-                        return new_ty;\n-                    }\n-                    if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&did.into()) {\n-                        return ImplTrait(bounds);\n-                    }\n-                }\n-\n-                let mut alias = None;\n-                if let Res::Def(DefKind::TyAlias, def_id) = path.res {\n-                    // Substitute private type aliases\n-                    if let Some(def_id) = def_id.as_local() {\n-                        let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n-                        if !cx.renderinfo.borrow().access_levels.is_exported(def_id.to_def_id()) {\n-                            alias = Some(&cx.tcx.hir().expect_item(hir_id).kind);\n-                        }\n-                    }\n-                };\n-\n-                if let Some(&hir::ItemKind::TyAlias(ref ty, ref generics)) = alias {\n-                    let provided_params = &path.segments.last().expect(\"segments were empty\");\n-                    let mut ty_substs = FxHashMap::default();\n-                    let mut lt_substs = FxHashMap::default();\n-                    let mut ct_substs = FxHashMap::default();\n-                    let generic_args = provided_params.generic_args();\n-                    {\n-                        let mut indices: GenericParamCount = Default::default();\n-                        for param in generics.params.iter() {\n-                            match param.kind {\n-                                hir::GenericParamKind::Lifetime { .. } => {\n-                                    let mut j = 0;\n-                                    let lifetime =\n-                                        generic_args.args.iter().find_map(|arg| match arg {\n-                                            hir::GenericArg::Lifetime(lt) => {\n-                                                if indices.lifetimes == j {\n-                                                    return Some(lt);\n-                                                }\n-                                                j += 1;\n-                                                None\n-                                            }\n-                                            _ => None,\n-                                        });\n-                                    if let Some(lt) = lifetime.cloned() {\n-                                        let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                                        let cleaned = if !lt.is_elided() {\n-                                            lt.clean(cx)\n-                                        } else {\n-                                            self::types::Lifetime::elided()\n-                                        };\n-                                        lt_substs.insert(lt_def_id.to_def_id(), cleaned);\n-                                    }\n-                                    indices.lifetimes += 1;\n-                                }\n-                                hir::GenericParamKind::Type { ref default, .. } => {\n-                                    let ty_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                                    let mut j = 0;\n-                                    let type_ =\n-                                        generic_args.args.iter().find_map(|arg| match arg {\n-                                            hir::GenericArg::Type(ty) => {\n-                                                if indices.types == j {\n-                                                    return Some(ty);\n-                                                }\n-                                                j += 1;\n-                                                None\n-                                            }\n-                                            _ => None,\n-                                        });\n-                                    if let Some(ty) = type_ {\n-                                        ty_substs.insert(ty_param_def_id.to_def_id(), ty.clean(cx));\n-                                    } else if let Some(default) = *default {\n-                                        ty_substs\n-                                            .insert(ty_param_def_id.to_def_id(), default.clean(cx));\n-                                    }\n-                                    indices.types += 1;\n-                                }\n-                                hir::GenericParamKind::Const { .. } => {\n-                                    let const_param_def_id =\n-                                        cx.tcx.hir().local_def_id(param.hir_id);\n-                                    let mut j = 0;\n-                                    let const_ =\n-                                        generic_args.args.iter().find_map(|arg| match arg {\n-                                            hir::GenericArg::Const(ct) => {\n-                                                if indices.consts == j {\n-                                                    return Some(ct);\n-                                                }\n-                                                j += 1;\n-                                                None\n-                                            }\n-                                            _ => None,\n-                                        });\n-                                    if let Some(ct) = const_ {\n-                                        ct_substs\n-                                            .insert(const_param_def_id.to_def_id(), ct.clean(cx));\n-                                    }\n-                                    // FIXME(const_generics:defaults)\n-                                    indices.consts += 1;\n-                                }\n-                            }\n-                        }\n-                    }\n-                    return cx.enter_alias(ty_substs, lt_substs, ct_substs, || ty.clean(cx));\n-                }\n-                resolve_type(cx, path.clean(cx), self.hir_id)\n-            }\n-            TyKind::Path(hir::QPath::Resolved(Some(ref qself), ref p)) => {\n-                let segments = if p.is_global() { &p.segments[1..] } else { &p.segments };\n-                let trait_segments = &segments[..segments.len() - 1];\n-                let trait_path = self::Path {\n-                    global: p.is_global(),\n-                    res: Res::Def(\n-                        DefKind::Trait,\n-                        cx.tcx.associated_item(p.res.def_id()).container.id(),\n-                    ),\n-                    segments: trait_segments.clean(cx),\n-                };\n-                Type::QPath {\n-                    name: p.segments.last().expect(\"segments were empty\").ident.name.clean(cx),\n-                    self_type: box qself.clean(cx),\n-                    trait_: box resolve_type(cx, trait_path, self.hir_id),\n-                }\n-            }\n-            TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n-                let mut res = Res::Err;\n-                let ty = hir_ty_to_ty(cx.tcx, self);\n-                if let ty::Projection(proj) = ty.kind() {\n-                    res = Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id);\n-                }\n-                let trait_path = hir::Path { span: self.span, res, segments: &[] };\n-                Type::QPath {\n-                    name: segment.ident.name.clean(cx),\n-                    self_type: box qself.clean(cx),\n-                    trait_: box resolve_type(cx, trait_path.clean(cx), self.hir_id),\n-                }\n-            }\n-            TyKind::Path(hir::QPath::LangItem(..)) => {\n-                bug!(\"clean: requiring documentation of lang item\")\n-            }\n+            TyKind::Path(_) => clean_qpath(&self, cx),\n             TyKind::TraitObject(ref bounds, ref lifetime) => {\n                 match bounds[0].clean(cx).trait_ {\n                     ResolvedPath { path, param_names: None, did, is_generic } => {\n@@ -1484,10 +1502,37 @@ impl Clean<Type> for hir::Ty<'_> {\n     }\n }\n \n+/// Returns `None` if the type could not be normalized\n+fn normalize(cx: &DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n+    use crate::rustc_trait_selection::infer::TyCtxtInferExt;\n+    use crate::rustc_trait_selection::traits::query::normalize::AtExt;\n+    use rustc_middle::traits::ObligationCause;\n+\n+    // Try to normalize `<X as Y>::T` to a type\n+    let lifted = ty.lift_to_tcx(cx.tcx).unwrap();\n+    let normalized = cx.tcx.infer_ctxt().enter(|infcx| {\n+        infcx\n+            .at(&ObligationCause::dummy(), cx.param_env.get())\n+            .normalize(lifted)\n+            .map(|resolved| infcx.resolve_vars_if_possible(resolved.value))\n+    });\n+    match normalized {\n+        Ok(normalized_value) => {\n+            debug!(\"normalized {:?} to {:?}\", ty, normalized_value);\n+            Some(normalized_value)\n+        }\n+        Err(err) => {\n+            debug!(\"failed to normalize {:?}: {:?}\", ty, err);\n+            None\n+        }\n+    }\n+}\n+\n impl<'tcx> Clean<Type> for Ty<'tcx> {\n     fn clean(&self, cx: &DocContext<'_>) -> Type {\n         debug!(\"cleaning type: {:?}\", self);\n-        match *self.kind() {\n+        let ty = normalize(cx, self).unwrap_or(self);\n+        match *ty.kind() {\n             ty::Never => Never,\n             ty::Bool => Primitive(PrimitiveType::Bool),\n             ty::Char => Primitive(PrimitiveType::Char),\n@@ -1939,77 +1984,81 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Ident>) {\n             Some(ident) => ident.name,\n             None => cx.tcx.hir().name(item.hir_id),\n         };\n-        let kind = match item.kind {\n-            ItemKind::Static(ty, mutability, body_id) => StaticItem(Static {\n-                type_: ty.clean(cx),\n-                mutability,\n-                expr: print_const_expr(cx, body_id),\n-            }),\n-            ItemKind::Const(ty, body_id) => ConstantItem(Constant {\n-                type_: ty.clean(cx),\n-                expr: print_const_expr(cx, body_id),\n-                value: print_evaluated_const(cx, def_id),\n-                is_literal: is_literal_expr(cx, body_id.hir_id),\n-            }),\n-            ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n-                bounds: ty.bounds.clean(cx),\n-                generics: ty.generics.clean(cx),\n-            }),\n-            ItemKind::TyAlias(ty, ref generics) => {\n-                let rustdoc_ty = ty.clean(cx);\n-                let item_type = rustdoc_ty.def_id().and_then(|did| inline::build_ty(cx, did));\n-                TypedefItem(\n-                    Typedef { type_: rustdoc_ty, generics: generics.clean(cx), item_type },\n-                    false,\n-                )\n-            }\n-            ItemKind::Enum(ref def, ref generics) => EnumItem(Enum {\n-                variants: def.variants.iter().map(|v| v.clean(cx)).collect(),\n-                generics: generics.clean(cx),\n-                variants_stripped: false,\n-            }),\n-            ItemKind::TraitAlias(ref generics, bounds) => TraitAliasItem(TraitAlias {\n-                generics: generics.clean(cx),\n-                bounds: bounds.clean(cx),\n-            }),\n-            ItemKind::Union(ref variant_data, ref generics) => UnionItem(Union {\n-                struct_type: doctree::struct_type_from_def(&variant_data),\n-                generics: generics.clean(cx),\n-                fields: variant_data.fields().clean(cx),\n-                fields_stripped: false,\n-            }),\n-            ItemKind::Struct(ref variant_data, ref generics) => StructItem(Struct {\n-                struct_type: doctree::struct_type_from_def(&variant_data),\n-                generics: generics.clean(cx),\n-                fields: variant_data.fields().clean(cx),\n-                fields_stripped: false,\n-            }),\n-            ItemKind::Impl { .. } => return clean_impl(item, cx),\n-            // proc macros can have a name set by attributes\n-            ItemKind::Fn(ref sig, ref generics, body_id) => {\n-                clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n-            }\n-            hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n-                let items =\n-                    item_ids.iter().map(|ti| cx.tcx.hir().trait_item(ti.id).clean(cx)).collect();\n-                let attrs = item.attrs.clean(cx);\n-                let is_spotlight = attrs.has_doc_flag(sym::spotlight);\n-                TraitItem(Trait {\n-                    unsafety,\n-                    items,\n+        cx.with_param_env(def_id, || {\n+            let kind = match item.kind {\n+                ItemKind::Static(ty, mutability, body_id) => StaticItem(Static {\n+                    type_: ty.clean(cx),\n+                    mutability,\n+                    expr: print_const_expr(cx, body_id),\n+                }),\n+                ItemKind::Const(ty, body_id) => ConstantItem(Constant {\n+                    type_: ty.clean(cx),\n+                    expr: print_const_expr(cx, body_id),\n+                    value: print_evaluated_const(cx, def_id),\n+                    is_literal: is_literal_expr(cx, body_id.hir_id),\n+                }),\n+                ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n+                    bounds: ty.bounds.clean(cx),\n+                    generics: ty.generics.clean(cx),\n+                }),\n+                ItemKind::TyAlias(ty, ref generics) => {\n+                    let rustdoc_ty = ty.clean(cx);\n+                    let item_type = rustdoc_ty.def_id().and_then(|did| inline::build_ty(cx, did));\n+                    TypedefItem(\n+                        Typedef { type_: rustdoc_ty, generics: generics.clean(cx), item_type },\n+                        false,\n+                    )\n+                }\n+                ItemKind::Enum(ref def, ref generics) => EnumItem(Enum {\n+                    variants: def.variants.iter().map(|v| v.clean(cx)).collect(),\n+                    generics: generics.clean(cx),\n+                    variants_stripped: false,\n+                }),\n+                ItemKind::TraitAlias(ref generics, bounds) => TraitAliasItem(TraitAlias {\n                     generics: generics.clean(cx),\n                     bounds: bounds.clean(cx),\n-                    is_spotlight,\n-                    is_auto: is_auto.clean(cx),\n-                })\n-            }\n-            ItemKind::ExternCrate(orig_name) => {\n-                return clean_extern_crate(item, name, orig_name, cx);\n-            }\n-            _ => unreachable!(\"not yet converted\"),\n-        };\n+                }),\n+                ItemKind::Union(ref variant_data, ref generics) => UnionItem(Union {\n+                    struct_type: doctree::struct_type_from_def(&variant_data),\n+                    generics: generics.clean(cx),\n+                    fields: variant_data.fields().clean(cx),\n+                    fields_stripped: false,\n+                }),\n+                ItemKind::Struct(ref variant_data, ref generics) => StructItem(Struct {\n+                    struct_type: doctree::struct_type_from_def(&variant_data),\n+                    generics: generics.clean(cx),\n+                    fields: variant_data.fields().clean(cx),\n+                    fields_stripped: false,\n+                }),\n+                ItemKind::Impl { .. } => return clean_impl(item, cx),\n+                // proc macros can have a name set by attributes\n+                ItemKind::Fn(ref sig, ref generics, body_id) => {\n+                    clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n+                }\n+                hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n+                    let items = item_ids\n+                        .iter()\n+                        .map(|ti| cx.tcx.hir().trait_item(ti.id).clean(cx))\n+                        .collect();\n+                    let attrs = item.attrs.clean(cx);\n+                    let is_spotlight = attrs.has_doc_flag(sym::spotlight);\n+                    TraitItem(Trait {\n+                        unsafety,\n+                        items,\n+                        generics: generics.clean(cx),\n+                        bounds: bounds.clean(cx),\n+                        is_spotlight,\n+                        is_auto: is_auto.clean(cx),\n+                    })\n+                }\n+                ItemKind::ExternCrate(orig_name) => {\n+                    return clean_extern_crate(item, name, orig_name, cx);\n+                }\n+                _ => unreachable!(\"not yet converted\"),\n+            };\n \n-        vec![Item::from_def_id_and_parts(def_id, Some(name), kind, cx)]\n+            vec![Item::from_def_id_and_parts(def_id, Some(name), kind, cx)]\n+        })\n     }\n }\n \n@@ -2227,32 +2276,42 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Ident>) {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let (item, renamed) = self;\n-        let kind = match item.kind {\n-            hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n-                let abi = cx.tcx.hir().get_foreign_abi(item.hir_id);\n-                let (generics, decl) =\n-                    enter_impl_trait(cx, || (generics.clean(cx), (&**decl, &names[..]).clean(cx)));\n-                let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n-                ForeignFunctionItem(Function {\n-                    decl,\n-                    generics,\n-                    header: hir::FnHeader {\n-                        unsafety: hir::Unsafety::Unsafe,\n-                        abi,\n-                        constness: hir::Constness::NotConst,\n-                        asyncness: hir::IsAsync::NotAsync,\n-                    },\n-                    all_types,\n-                    ret_types,\n-                })\n-            }\n-            hir::ForeignItemKind::Static(ref ty, mutability) => {\n-                ForeignStaticItem(Static { type_: ty.clean(cx), mutability, expr: String::new() })\n-            }\n-            hir::ForeignItemKind::Type => ForeignTypeItem,\n-        };\n-\n-        Item::from_hir_id_and_parts(item.hir_id, Some(renamed.unwrap_or(item.ident).name), kind, cx)\n+        cx.with_param_env(cx.tcx.hir().local_def_id(item.hir_id).to_def_id(), || {\n+            let kind = match item.kind {\n+                hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n+                    let abi = cx.tcx.hir().get_foreign_abi(item.hir_id);\n+                    let (generics, decl) = enter_impl_trait(cx, || {\n+                        (generics.clean(cx), (&**decl, &names[..]).clean(cx))\n+                    });\n+                    let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n+                    ForeignFunctionItem(Function {\n+                        decl,\n+                        generics,\n+                        header: hir::FnHeader {\n+                            unsafety: hir::Unsafety::Unsafe,\n+                            abi,\n+                            constness: hir::Constness::NotConst,\n+                            asyncness: hir::IsAsync::NotAsync,\n+                        },\n+                        all_types,\n+                        ret_types,\n+                    })\n+                }\n+                hir::ForeignItemKind::Static(ref ty, mutability) => ForeignStaticItem(Static {\n+                    type_: ty.clean(cx),\n+                    mutability,\n+                    expr: String::new(),\n+                }),\n+                hir::ForeignItemKind::Type => ForeignTypeItem,\n+            };\n+\n+            Item::from_hir_id_and_parts(\n+                item.hir_id,\n+                Some(renamed.unwrap_or(item.ident).name),\n+                kind,\n+                cx,\n+            )\n+        })\n     }\n }\n "}, {"sha": "b63acdc114e89cec6299b8bcb35c1f1ba56ae958", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/65ecc481fac7ceced57d973a580d0a7ccbdcb192/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ecc481fac7ceced57d973a580d0a7ccbdcb192/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=65ecc481fac7ceced57d973a580d0a7ccbdcb192", "patch": "@@ -15,7 +15,7 @@ use rustc_interface::interface;\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::cstore::CrateStore;\n use rustc_middle::middle::privacy::AccessLevels;\n-use rustc_middle::ty::{Ty, TyCtxt};\n+use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n use rustc_resolve as resolve;\n use rustc_session::config::{self, CrateType, ErrorOutputType};\n use rustc_session::lint;\n@@ -25,7 +25,7 @@ use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n \n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n use std::mem;\n use std::rc::Rc;\n \n@@ -42,6 +42,10 @@ crate type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n crate struct DocContext<'tcx> {\n     crate tcx: TyCtxt<'tcx>,\n     crate resolver: Rc<RefCell<interface::BoxedResolver>>,\n+    /// Used for normalization.\n+    ///\n+    /// Most of this logic is copied from rustc_lint::late.\n+    crate param_env: Cell<ParamEnv<'tcx>>,\n     /// Later on moved into `CACHE_KEY`\n     crate renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `CACHE_KEY`\n@@ -79,6 +83,13 @@ impl<'tcx> DocContext<'tcx> {\n         &self.tcx.sess\n     }\n \n+    crate fn with_param_env<T, F: FnOnce() -> T>(&self, def_id: DefId, f: F) -> T {\n+        let old_param_env = self.param_env.replace(self.tcx.param_env(def_id));\n+        let ret = f();\n+        self.param_env.set(old_param_env);\n+        ret\n+    }\n+\n     crate fn enter_resolver<F, R>(&self, f: F) -> R\n     where\n         F: FnOnce(&mut resolve::Resolver<'_>) -> R,\n@@ -524,6 +535,7 @@ fn run_global_ctxt(\n     let mut ctxt = DocContext {\n         tcx,\n         resolver,\n+        param_env: Cell::new(ParamEnv::empty()),\n         external_traits: Default::default(),\n         active_extern_traits: Default::default(),\n         renderinfo: RefCell::new(renderinfo),"}, {"sha": "fbd111c3035662e7894695b022c135bab7c30a50", "filename": "src/test/rustdoc/auxiliary/normalize-assoc-item.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/65ecc481fac7ceced57d973a580d0a7ccbdcb192/src%2Ftest%2Frustdoc%2Fauxiliary%2Fnormalize-assoc-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ecc481fac7ceced57d973a580d0a7ccbdcb192/src%2Ftest%2Frustdoc%2Fauxiliary%2Fnormalize-assoc-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fnormalize-assoc-item.rs?ref=65ecc481fac7ceced57d973a580d0a7ccbdcb192", "patch": "@@ -0,0 +1,12 @@\n+#![crate_name = \"inner\"]\n+pub trait MyTrait {\n+    type Y;\n+}\n+\n+impl MyTrait for u32 {\n+    type Y = i32;\n+}\n+\n+pub fn foo() -> <u32 as MyTrait>::Y {\n+    0\n+}"}, {"sha": "137fd354a8743a61dceec4ab94702644e036e30e", "filename": "src/test/rustdoc/normalize-assoc-item.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/65ecc481fac7ceced57d973a580d0a7ccbdcb192/src%2Ftest%2Frustdoc%2Fnormalize-assoc-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ecc481fac7ceced57d973a580d0a7ccbdcb192/src%2Ftest%2Frustdoc%2Fnormalize-assoc-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fnormalize-assoc-item.rs?ref=65ecc481fac7ceced57d973a580d0a7ccbdcb192", "patch": "@@ -0,0 +1,68 @@\n+// ignore-tidy-linelength\n+// aux-build:normalize-assoc-item.rs\n+// build-aux-docs\n+\n+pub trait Trait {\n+    type X;\n+}\n+\n+impl Trait for usize {\n+    type X = isize;\n+}\n+\n+// @has 'normalize_assoc_item/fn.f.html' '//pre[@class=\"rust fn\"]' 'pub fn f() -> isize'\n+pub fn f() -> <usize as Trait>::X {\n+    0\n+}\n+\n+pub struct S {\n+    // @has 'normalize_assoc_item/struct.S.html' '//span[@id=\"structfield.box_me_up\"]' 'box_me_up: Box<S, Global>'\n+    pub box_me_up: <S as Trait>::X,\n+    // @has 'normalize_assoc_item/struct.S.html' '//span[@id=\"structfield.generic\"]' 'generic: (usize, isize)'\n+    pub generic: <Generic<usize> as Trait>::X,\n+}\n+\n+impl Trait for S {\n+    type X = Box<S>;\n+}\n+\n+pub struct Generic<Inner>(Inner);\n+\n+impl<Inner: Trait> Trait for Generic<Inner> {\n+    type X = (Inner, Inner::X);\n+}\n+\n+// These can't be normalized because they depend on a generic parameter.\n+// However the user can choose whether the text should be displayed as `Inner::X` or `<Inner as Trait>::X`.\n+\n+// @has 'normalize_assoc_item/struct.Unknown.html' '//pre[@class=\"rust struct\"]' 'pub struct Unknown<Inner: Trait>(pub <Inner as Trait>::X);'\n+pub struct Unknown<Inner: Trait>(pub <Inner as Trait>::X);\n+\n+// @has 'normalize_assoc_item/struct.Unknown2.html' '//pre[@class=\"rust struct\"]' 'pub struct Unknown2<Inner: Trait>(pub Inner::X);'\n+pub struct Unknown2<Inner: Trait>(pub Inner::X);\n+\n+trait Lifetimes<'a> {\n+    type Y;\n+}\n+\n+impl<'a> Lifetimes<'a> for usize {\n+    type Y = &'a isize;\n+}\n+\n+// @has 'normalize_assoc_item/fn.g.html' '//pre[@class=\"rust fn\"]' \"pub fn g() -> &isize\"\n+pub fn g() -> <usize as Lifetimes<'static>>::Y {\n+    &0\n+}\n+\n+// @has 'normalize_assoc_item/constant.A.html' '//pre[@class=\"rust const\"]' \"pub const A: &isize\"\n+pub const A: <usize as Lifetimes<'static>>::Y = &0;\n+\n+// test cross-crate re-exports\n+extern crate inner;\n+// @has 'normalize_assoc_item/fn.foo.html' '//pre[@class=\"rust fn\"]' \"pub fn foo() -> i32\"\n+pub use inner::foo;\n+\n+// @has 'normalize_assoc_item/fn.h.html' '//pre[@class=\"rust fn\"]' \"pub fn h<T>() -> IntoIter<T, Global>\"\n+pub fn h<T>() -> <Vec<T> as IntoIterator>::IntoIter {\n+    vec![].into_iter()\n+}"}]}