{"sha": "91fe3fcbef43c68943b57b0cfaf637c84d39926c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZmUzZmNiZWY0M2M2ODk0M2I1N2IwY2ZhZjYzN2M4NGQzOTkyNmM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-25T02:11:48Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-25T02:11:48Z"}, "message": "tutorial: Expand borrowed ptr discussion. Misc", "tree": {"sha": "11a2a10e658ec141226740b99be836004ef9aae0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11a2a10e658ec141226740b99be836004ef9aae0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91fe3fcbef43c68943b57b0cfaf637c84d39926c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91fe3fcbef43c68943b57b0cfaf637c84d39926c", "html_url": "https://github.com/rust-lang/rust/commit/91fe3fcbef43c68943b57b0cfaf637c84d39926c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91fe3fcbef43c68943b57b0cfaf637c84d39926c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3c72713def77769107488d91f600f805bd68419", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3c72713def77769107488d91f600f805bd68419", "html_url": "https://github.com/rust-lang/rust/commit/b3c72713def77769107488d91f600f805bd68419"}], "stats": {"total": 139, "additions": 94, "deletions": 45}, "files": [{"sha": "b15383181b13f2c5c2b4d12b64aacc9b8e803059", "filename": "doc/tutorial.md", "status": "modified", "additions": 94, "deletions": 45, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/91fe3fcbef43c68943b57b0cfaf637c84d39926c/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/91fe3fcbef43c68943b57b0cfaf637c84d39926c/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=91fe3fcbef43c68943b57b0cfaf637c84d39926c", "patch": "@@ -896,6 +896,8 @@ Rust types with the `impl` keyword. As an example, lets define a draw\n method on our `Shape` enum.\n \n ~~~\n+# fn draw_circle(p: Point, f: float) { }\n+# fn draw_rectangle(p: Point, p: Point) { }\n struct Point {\n     x: float,\n     y: float\n@@ -915,17 +917,18 @@ impl Shape {\n     }\n }\n \n-let s = Circle(Point { x: 1f, y: 2f }, 3f };\n+let s = Circle(Point { x: 1f, y: 2f }, 3f);\n s.draw();\n ~~~\n \n This defines an _implementation_ for `Shape` containing a single\n-method, `draw`. If we wanted we could add additional methods to the\n-same impl.  In most most respects the `draw` method is defined like\n-any other function, with the exception of the name `self`. `self` is a\n-special value that is automatically defined in each method, referring\n-to the value being operated on. We'll discuss methods more in the\n-context of [traits and generics](#generics).\n+method, `draw`. In most most respects the `draw` method is defined\n+like any other function, with the exception of the name `self`. `self`\n+is a special value that is automatically defined in each method,\n+referring to the value being operated on. If we wanted we could add\n+additional methods to the same impl, or multiple impls for the same\n+type. We'll discuss methods more in the context of [traits and\n+generics](#generics).\n \n > ***Note:*** The method definition syntax will change to require\n > declaring the self type explicitly, as the first argument.\n@@ -1042,9 +1045,11 @@ during assignment, only copies a pointer, never the contents of the\n box.\n \n ~~~~\n-let x: @int = @10; // New box, refcount of 1\n-let y = x; // Copy the pointer, increase refcount\n-// When x and y go out of scope, refcount goes to 0, box is freed\n+let x: @int = @10; // New box\n+let y = x; // Copy of a pointer to the same box\n+\n+// x and y both refer to the same allocation. When both go out of scope\n+// then the allocation will be freed.\n ~~~~\n \n Managed boxes never cross task boundaries.\n@@ -1059,7 +1064,7 @@ In contrast to maneged boxes, owned boxes have a single owning memory\n slot and thus two owned boxes may not refer to the same memory. All\n owned boxes across all tasks are allocated on a single _exchange\n heap_, where their uniquely owned nature allows them to be passed\n-between tasks.\n+between tasks efficiently.\n \n Because owned boxes are uniquely owned, copying them involves allocating\n a new owned box and duplicating the contents. Copying owned boxes\n@@ -1089,16 +1094,16 @@ let x = ~10;\n let y = move x;\n ~~~~\n \n-> ***Note:*** this discussion of copying vs moving does not account\n-> for the \"last use\" rules that automatically promote copy operations\n-> to moves. This is an evolving area of the language that will\n-> continue to change.\n-\n Owned boxes, when they do not contain any managed boxes, can be sent\n to other tasks. The sending task will give up ownership of the box,\n and won't be able to access it afterwards. The receiving task will\n become the sole owner of the box.\n \n+> ***Note:*** this discussion of copying vs moving does not account\n+> for the \"last use\" rules that automatically promote copy operations\n+> to moves. Last use is expected to be removed from the language in\n+> favor of explicit moves.\n+\n ## Borrowed pointers\n \n Rust borrowed pointers are a general purpose reference/pointer type,\n@@ -1108,41 +1113,85 @@ pointer is the owner of the pointed-to memory, borrowed pointers never\n imply ownership. Pointers may be borrowed from any type, in which case\n the pointer is guaranteed not to outlive the value it points to.\n \n-~~~~\n-# fn work_with_foo_by_pointer(f: &~str) { }\n-let foo = ~\"foo\";\n-work_with_foo_by_pointer(&foo);\n-~~~~\n-\n-The following shows an example of what is _not_ possible with borrowed\n-pointers. If you were able to write this then the pointer to `foo`\n-would outlive `foo` itself.\n+As an example, consider a simple struct type, `Point`:\n \n-~~~~ {.ignore}\n-let foo_ptr;\n-{\n-    let foo = ~\"foo\";\n-    foo_ptr = &foo;\n+~~~\n+struct Point {\n+    x: float, y: float\n }\n ~~~~\n \n-> ***Note:*** borrowed pointers are a new addition to the language.\n-> They are not used extensively yet but are expected to become the\n-> pointer type used in many common situations, in particular for\n-> by-reference argument passing. Rust's current solution for passing\n-> arguments by reference is [argument modes](#argument-passing).\n+We can use this simple definition to allocate points in many ways. For\n+example, in this code, each of these three local variables contains a\n+point, but allocated in a different place:\n \n-## Mutability\n+~~~\n+# struct Point { x: float, y: float }\n+let on_the_stack : Point  =  Point {x: 3.0, y: 4.0};\n+let shared_box   : @Point = @Point {x: 5.0, y: 1.0};\n+let unique_box   : ~Point = ~Point {x: 7.0, y: 9.0};\n+~~~\n \n-All pointer types have a mutable variant, written `@mut T` or `~mut\n-T`. Given such a pointer, you can write to its contents by combining\n-the dereference operator with a mutating action.\n+Suppose we wanted to write a procedure that computed the distance\n+between any two points, no matter where they were stored. For example,\n+we might like to compute the distance between `on_the_stack` and\n+`shared_box`, or between `shared_box` and `unique_box`. One option is\n+to define a function that takes two arguments of type point\u2014that is,\n+it takes the points by value. But this will cause the points to be\n+copied when we call the function. For points, this is probably not so\n+bad, but often copies are expensive or, worse, if there are mutable\n+fields, they can change the semantics of your program. So we\u2019d like to\n+define a function that takes the points by pointer. We can use\n+borrowed pointers to do this:\n \n-~~~~\n-fn increase_contents(pt: @mut int) {\n-    *pt += 1;\n+~~~\n+# struct Point { x: float, y: float }\n+# fn sqrt(f: float) -> float { 0f }\n+fn compute_distance(p1: &Point, p2: &Point) -> float {\n+    let x_d = p1.x - p2.x;\n+    let y_d = p1.y - p2.y;\n+    sqrt(x_d * x_d + y_d * y_d)\n }\n-~~~~\n+~~~\n+\n+Now we can call `compute_distance()` in various ways:\n+\n+~~~\n+# struct Point{ x: float, y: float };\n+# let on_the_stack : Point  =  Point {x: 3.0, y: 4.0};\n+# let shared_box   : @Point = @Point {x: 5.0, y: 1.0};\n+# let unique_box   : ~Point = ~Point {x: 7.0, y: 9.0};\n+# fn compute_distance(p1: &Point, p2: &Point) -> float { 0f }\n+compute_distance(&on_the_stack, shared_box);\n+compute_distance(shared_box, unique_box);\n+~~~\n+\n+Here the `&` operator is used to take the address of the variable\n+`on_the_stack`; this is because `on_the_stack` has the type `point`\n+(that is, a record value) and we have to take its address to get a\n+value. We also call this _borrowing_ the local variable\n+`on_the_stack`, because we are created an alias: that is, another\n+route to the same data.\n+\n+In the case of the boxes `shared_box` and `unique_box`, however, no\n+explicit action is necessary. The compiler will automatically convert\n+a box like `@point` or `~point` to a borrowed pointer like\n+`&point`. This is another form of borrowing; in this case, the\n+contents of the shared/unique box is being lent out.\n+\n+Whenever a value is borrowed, there are some limitations on what you\n+can do with the original. For example, if the contents of a variable\n+have been lent out, you cannot send that variable to another task, nor\n+will you be permitted to take actions that might cause the borrowed\n+value to be freed or to change its type. This rule should make\n+intuitive sense: you must wait for a borrowed value to be returned\n+(that is, for the borrowed pointer to go out of scope) before you can\n+make full use of it again.\n+\n+For a more in-depth explanation of borrowed pointers, read the\n+[borrowed pointer tutorial][borrowtut].\n+\n+[borrowtut]: tutorial-borrowed-ptr.html\n \n # Vectors and strings\n \n@@ -1719,8 +1768,8 @@ impl ~str: Printable {\n # (~\"foo\").print();\n ~~~~\n \n-Given these, we may call `1.to_str()` to print `\"1\"`, or\n-`(~\"foo\").to_str()` to print `\"foo\"` again. This is basically a form of\n+Given these, we may call `1.print()` to print `\"1\"`, or\n+`(~\"foo\").print()` to print `\"foo\"` again, as with . This is basically a form of\n static overloading\u2014when the Rust compiler sees the `print` method\n call, it looks for an implementation that matches the type with a\n method that matches the name, and simply calls that."}]}