{"sha": "263401bf751c66fadd4e9a46cce29dd724cc0985", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MzQwMWJmNzUxYzY2ZmFkZDRlOWE0NmNjZTI5ZGQ3MjRjYzA5ODU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-15T16:44:12Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-15T16:44:12Z"}, "message": "Rename", "tree": {"sha": "54bc5468488a3901ecf1521e1ed2ad3941c872ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54bc5468488a3901ecf1521e1ed2ad3941c872ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/263401bf751c66fadd4e9a46cce29dd724cc0985", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/263401bf751c66fadd4e9a46cce29dd724cc0985", "html_url": "https://github.com/rust-lang/rust/commit/263401bf751c66fadd4e9a46cce29dd724cc0985", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/263401bf751c66fadd4e9a46cce29dd724cc0985/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0661ce7444223b0fff1f5d54adb41022ab788cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0661ce7444223b0fff1f5d54adb41022ab788cb", "html_url": "https://github.com/rust-lang/rust/commit/c0661ce7444223b0fff1f5d54adb41022ab788cb"}], "stats": {"total": 31, "additions": 14, "deletions": 17}, "files": [{"sha": "8cc2fb160d374541865cae898e99464800b77fe2", "filename": "crates/ra_hir_def/src/find_path.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/263401bf751c66fadd4e9a46cce29dd724cc0985/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263401bf751c66fadd4e9a46cce29dd724cc0985/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs?ref=263401bf751c66fadd4e9a46cce29dd724cc0985", "patch": "@@ -35,7 +35,7 @@ fn find_path_inner(\n     let def_map = db.crate_def_map(from.krate);\n     let from_scope: &crate::item_scope::ItemScope = &def_map.modules[from.local_id].scope;\n     if let Some((name, _)) = from_scope.name_of(item) {\n-        return Some(ModPath::from_simple_segments(PathKind::Plain, vec![name.clone()]));\n+        return Some(ModPath::from_segments(PathKind::Plain, vec![name.clone()]));\n     }\n \n     // - if the item is the crate root, return `crate`\n@@ -45,12 +45,12 @@ fn find_path_inner(\n             local_id: def_map.root,\n         }))\n     {\n-        return Some(ModPath::from_simple_segments(PathKind::Crate, Vec::new()));\n+        return Some(ModPath::from_segments(PathKind::Crate, Vec::new()));\n     }\n \n     // - if the item is the module we're in, use `self`\n     if item == ItemInNs::Types(from.into()) {\n-        return Some(ModPath::from_simple_segments(PathKind::Super(0), Vec::new()));\n+        return Some(ModPath::from_segments(PathKind::Super(0), Vec::new()));\n     }\n \n     // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n@@ -61,14 +61,14 @@ fn find_path_inner(\n                 local_id: parent_id,\n             }))\n         {\n-            return Some(ModPath::from_simple_segments(PathKind::Super(1), Vec::new()));\n+            return Some(ModPath::from_segments(PathKind::Super(1), Vec::new()));\n         }\n     }\n \n     // - if the item is the crate root of a dependency crate, return the name from the extern prelude\n     for (name, def_id) in &def_map.extern_prelude {\n         if item == ItemInNs::Types(*def_id) {\n-            return Some(ModPath::from_simple_segments(PathKind::Plain, vec![name.clone()]));\n+            return Some(ModPath::from_segments(PathKind::Plain, vec![name.clone()]));\n         }\n     }\n \n@@ -79,7 +79,7 @@ fn find_path_inner(\n             &prelude_def_map.modules[prelude_module.local_id].scope;\n         if let Some((name, vis)) = prelude_scope.name_of(item) {\n             if vis.is_visible_from(db, from) {\n-                return Some(ModPath::from_simple_segments(PathKind::Plain, vec![name.clone()]));\n+                return Some(ModPath::from_segments(PathKind::Plain, vec![name.clone()]));\n             }\n         }\n     }"}, {"sha": "ab290e2c98a8486f3f3ad4c5e76262f5423d01af", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/263401bf751c66fadd4e9a46cce29dd724cc0985/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263401bf751c66fadd4e9a46cce29dd724cc0985/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=263401bf751c66fadd4e9a46cce29dd724cc0985", "patch": "@@ -39,10 +39,7 @@ impl ModPath {\n         lower::lower_path(path, hygiene).map(|it| it.mod_path)\n     }\n \n-    pub fn from_simple_segments(\n-        kind: PathKind,\n-        segments: impl IntoIterator<Item = Name>,\n-    ) -> ModPath {\n+    pub fn from_segments(kind: PathKind, segments: impl IntoIterator<Item = Name>) -> ModPath {\n         let segments = segments.into_iter().collect::<Vec<_>>();\n         ModPath { kind, segments }\n     }\n@@ -240,15 +237,15 @@ impl From<Name> for Path {\n     fn from(name: Name) -> Path {\n         Path {\n             type_anchor: None,\n-            mod_path: ModPath::from_simple_segments(PathKind::Plain, iter::once(name)),\n+            mod_path: ModPath::from_segments(PathKind::Plain, iter::once(name)),\n             generic_args: vec![None],\n         }\n     }\n }\n \n impl From<Name> for ModPath {\n     fn from(name: Name) -> ModPath {\n-        ModPath::from_simple_segments(PathKind::Plain, iter::once(name))\n+        ModPath::from_segments(PathKind::Plain, iter::once(name))\n     }\n }\n \n@@ -311,7 +308,7 @@ macro_rules! __known_path {\n macro_rules! __path {\n     ($start:ident $(:: $seg:ident)*) => ({\n         $crate::__known_path!($start $(:: $seg)*);\n-        $crate::path::ModPath::from_simple_segments($crate::path::PathKind::Abs, vec![\n+        $crate::path::ModPath::from_segments($crate::path::PathKind::Abs, vec![\n             $crate::path::__name![$start], $($crate::path::__name![$seg],)*\n         ])\n     });"}, {"sha": "531878174edc2b4adda94f6537a1bdf79bd659ec", "filename": "crates/ra_hir_def/src/path/lower/lower_use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/263401bf751c66fadd4e9a46cce29dd724cc0985/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263401bf751c66fadd4e9a46cce29dd724cc0985/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=263401bf751c66fadd4e9a46cce29dd724cc0985", "patch": "@@ -84,7 +84,7 @@ fn convert_path(prefix: Option<ModPath>, path: ast::Path, hygiene: &Hygiene) ->\n                     res\n                 }\n                 Either::Right(crate_id) => {\n-                    return Some(ModPath::from_simple_segments(\n+                    return Some(ModPath::from_segments(\n                         PathKind::DollarCrate(crate_id),\n                         iter::empty(),\n                     ))\n@@ -95,19 +95,19 @@ fn convert_path(prefix: Option<ModPath>, path: ast::Path, hygiene: &Hygiene) ->\n             if prefix.is_some() {\n                 return None;\n             }\n-            ModPath::from_simple_segments(PathKind::Crate, iter::empty())\n+            ModPath::from_segments(PathKind::Crate, iter::empty())\n         }\n         ast::PathSegmentKind::SelfKw => {\n             if prefix.is_some() {\n                 return None;\n             }\n-            ModPath::from_simple_segments(PathKind::Super(0), iter::empty())\n+            ModPath::from_segments(PathKind::Super(0), iter::empty())\n         }\n         ast::PathSegmentKind::SuperKw => {\n             if prefix.is_some() {\n                 return None;\n             }\n-            ModPath::from_simple_segments(PathKind::Super(1), iter::empty())\n+            ModPath::from_segments(PathKind::Super(1), iter::empty())\n         }\n         ast::PathSegmentKind::Type { .. } => {\n             // not allowed in imports"}]}