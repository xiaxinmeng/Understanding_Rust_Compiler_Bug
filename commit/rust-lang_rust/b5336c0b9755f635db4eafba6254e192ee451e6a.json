{"sha": "b5336c0b9755f635db4eafba6254e192ee451e6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MzM2YzBiOTc1NWY2MzVkYjRlYWZiYTYyNTRlMTkyZWU0NTFlNmE=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-10-17T22:11:11Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-10-22T21:20:52Z"}, "message": "Add a cheap mode for `compute_missing_ctors`.\n\n`compute_missing_ctors` is called a lot. It produces a vector, which can\nbe reasonably large (e.g. 100+ elements), but the vector is almost\nalways only checked for emptiness.\n\nThis commit changes `compute_missing_ctors` so it can be called in a\ncheap way that just indicates if the vector would be empty. If\nnecessary, the function can subsequently be called in an expensive way\nto compute the full vector.\n\nThis change reduces instruction counts for several benchmarks up to 2%.", "tree": {"sha": "3048b8d7f13a010afde7abe53be1328275b42954", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3048b8d7f13a010afde7abe53be1328275b42954"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5336c0b9755f635db4eafba6254e192ee451e6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5336c0b9755f635db4eafba6254e192ee451e6a", "html_url": "https://github.com/rust-lang/rust/commit/b5336c0b9755f635db4eafba6254e192ee451e6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5336c0b9755f635db4eafba6254e192ee451e6a/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a7048b72b7e9499dfae3f946baa92fc9e62a6b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a7048b72b7e9499dfae3f946baa92fc9e62a6b8", "html_url": "https://github.com/rust-lang/rust/commit/8a7048b72b7e9499dfae3f946baa92fc9e62a6b8"}], "stats": {"total": 85, "additions": 66, "deletions": 19}, "files": [{"sha": "7f46e2f3845511c545c9011ddeb3aa4399eb094f", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 66, "deletions": 19, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b5336c0b9755f635db4eafba6254e192ee451e6a/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5336c0b9755f635db4eafba6254e192ee451e6a/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=b5336c0b9755f635db4eafba6254e192ee451e6a", "patch": "@@ -931,12 +931,37 @@ impl<'tcx> IntRange<'tcx> {\n     }\n }\n \n-// Return a set of constructors equivalent to `all_ctors \\ used_ctors`.\n+// A request for missing constructor data in terms of either:\n+// - whether or not there any missing constructors; or\n+// - the actual set of missing constructors.\n+#[derive(PartialEq)]\n+enum MissingCtorsInfo {\n+    Emptiness,\n+    Ctors,\n+}\n+\n+// Used by `compute_missing_ctors`.\n+#[derive(Debug, PartialEq)]\n+enum MissingCtors<'tcx> {\n+    Empty,\n+    NonEmpty,\n+\n+    // Note that the Vec can be empty.\n+    Ctors(Vec<Constructor<'tcx>>),\n+}\n+\n+// When `info` is `MissingCtorsInfo::Ctors`, compute a set of constructors\n+// equivalent to `all_ctors \\ used_ctors`. When `info` is\n+// `MissingCtorsInfo::Emptiness`, just determines if that set is empty or not.\n+// (The split logic gives a performance win, because we always need to know if\n+// the set is empty, but we rarely need the full set, and it can be expensive\n+// to compute the full set.)\n fn compute_missing_ctors<'a, 'tcx: 'a>(\n+    info: MissingCtorsInfo,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     all_ctors: &Vec<Constructor<'tcx>>,\n     used_ctors: &Vec<Constructor<'tcx>>,\n-) -> Vec<Constructor<'tcx>> {\n+) -> MissingCtors<'tcx> {\n     let mut missing_ctors = vec![];\n \n     for req_ctor in all_ctors {\n@@ -965,10 +990,22 @@ fn compute_missing_ctors<'a, 'tcx: 'a>(\n         // We add `refined_ctors` instead of `req_ctor`, because then we can\n         // provide more detailed error information about precisely which\n         // ranges have been omitted.\n-        missing_ctors.extend(refined_ctors);\n+        if info == MissingCtorsInfo::Emptiness {\n+            if !refined_ctors.is_empty() {\n+                // The set is non-empty; return early.\n+                return MissingCtors::NonEmpty;\n+            }\n+        } else {\n+            missing_ctors.extend(refined_ctors);\n+        }\n     }\n \n-    missing_ctors\n+    if info == MissingCtorsInfo::Emptiness {\n+        // If we reached here, the set is empty.\n+        MissingCtors::Empty\n+    } else {\n+        MissingCtors::Ctors(missing_ctors)\n+    }\n }\n \n /// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n@@ -1081,20 +1118,23 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         // feature flag is not present, so this is only\n         // needed for that case.\n \n-        // Find those constructors that are not matched by any non-wildcard patterns in the\n-        // current column.\n-        let missing_ctors = compute_missing_ctors(cx.tcx, &all_ctors, &used_ctors);\n+        // Missing constructors are those that are not matched by any\n+        // non-wildcard patterns in the current column. We always determine if\n+        // the set is empty, but we only fully construct them on-demand,\n+        // because they're rarely used and can be big.\n+        let cheap_missing_ctors =\n+            compute_missing_ctors(MissingCtorsInfo::Emptiness, cx.tcx, &all_ctors, &used_ctors);\n \n         let is_privately_empty = all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n         let is_declared_nonexhaustive = cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n-        debug!(\"missing_ctors={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n-               missing_ctors, is_privately_empty, is_declared_nonexhaustive);\n+        debug!(\"cheap_missing_ctors={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n+               cheap_missing_ctors, is_privately_empty, is_declared_nonexhaustive);\n \n         // For privately empty and non-exhaustive enums, we work as if there were an \"extra\"\n         // `_` constructor for the type, so we can never match over all constructors.\n         let is_non_exhaustive = is_privately_empty || is_declared_nonexhaustive;\n \n-        if missing_ctors.is_empty() && !is_non_exhaustive {\n+        if cheap_missing_ctors == MissingCtors::Empty && !is_non_exhaustive {\n             split_grouped_constructors(cx.tcx, all_ctors, matrix, pcx.ty).into_iter().map(|c| {\n                 is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n             }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n@@ -1165,15 +1205,22 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                             witness\n                         }).collect()\n                     } else {\n-                        pats.into_iter().flat_map(|witness| {\n-                            missing_ctors.iter().map(move |ctor| {\n-                                // Extends the witness with a \"wild\" version of this\n-                                // constructor, that matches everything that can be built with\n-                                // it. For example, if `ctor` is a `Constructor::Variant` for\n-                                // `Option::Some`, this pushes the witness for `Some(_)`.\n-                                witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n-                            })\n-                        }).collect()\n+                        let expensive_missing_ctors =\n+                            compute_missing_ctors(MissingCtorsInfo::Ctors, cx.tcx, &all_ctors,\n+                                                  &used_ctors);\n+                        if let MissingCtors::Ctors(missing_ctors) = expensive_missing_ctors {\n+                            pats.into_iter().flat_map(|witness| {\n+                                missing_ctors.iter().map(move |ctor| {\n+                                    // Extends the witness with a \"wild\" version of this\n+                                    // constructor, that matches everything that can be built with\n+                                    // it. For example, if `ctor` is a `Constructor::Variant` for\n+                                    // `Option::Some`, this pushes the witness for `Some(_)`.\n+                                    witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n+                                })\n+                            }).collect()\n+                        } else {\n+                            bug!(\"cheap missing ctors\")\n+                        }\n                     };\n                     UsefulWithWitness(new_witnesses)\n                 }"}]}