{"sha": "b258060a94e629d3281697cedfa6620f5e75b0c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNTgwNjBhOTRlNjI5ZDMyODE2OTdjZWRmYTY2MjBmNWU3NWIwYzM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-25T16:49:08Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-25T16:49:08Z"}, "message": "Avoid type_store hashtable access for a variety of cases, probably only ty_var matters.", "tree": {"sha": "8fa87be229281b262bd4e3c6d625216d2a731597", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fa87be229281b262bd4e3c6d625216d2a731597"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b258060a94e629d3281697cedfa6620f5e75b0c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b258060a94e629d3281697cedfa6620f5e75b0c3", "html_url": "https://github.com/rust-lang/rust/commit/b258060a94e629d3281697cedfa6620f5e75b0c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b258060a94e629d3281697cedfa6620f5e75b0c3/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "485399a8d5de8a8bb759feacd9e4915055e51cb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/485399a8d5de8a8bb759feacd9e4915055e51cb5", "html_url": "https://github.com/rust-lang/rust/commit/485399a8d5de8a8bb759feacd9e4915055e51cb5"}], "stats": {"total": 213, "additions": 168, "deletions": 45}, "files": [{"sha": "2381751f8994b5710d1c0b8ee5d0732d44ea23df", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 128, "deletions": 19, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/b258060a94e629d3281697cedfa6620f5e75b0c3/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b258060a94e629d3281697cedfa6620f5e75b0c3/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=b258060a94e629d3281697cedfa6620f5e75b0c3", "patch": "@@ -15,6 +15,20 @@ import front.ast.mutability;\n import front.creader;\n import middle.metadata;\n import util.common;\n+\n+import util.common.ty_u8;\n+import util.common.ty_u16;\n+import util.common.ty_u32;\n+import util.common.ty_u64;\n+\n+import util.common.ty_i8;\n+import util.common.ty_i16;\n+import util.common.ty_i32;\n+import util.common.ty_i64;\n+\n+import util.common.ty_f32;\n+import util.common.ty_f64;\n+\n import util.common.new_def_hash;\n import util.common.span;\n import util.typestate_ann.ts_ann;\n@@ -102,13 +116,74 @@ tag type_err {\n type ty_param_count_and_ty = tup(uint, t);\n type type_cache = hashmap[ast.def_id,ty_param_count_and_ty];\n \n+type type_store = rec(vec[ty.t] empty_vec_ty,\n+                      vec[mutable ty.t] empty_vec_mutable_ty,\n+                      ty.t t_nil,\n+                      ty.t t_bool,\n+                      ty.t t_int,\n+                      ty.t t_float,\n+                      ty.t t_uint,\n+\n+                      ty.t t_i8,\n+                      ty.t t_i16,\n+                      ty.t t_i32,\n+                      ty.t t_i64,\n+\n+                      ty.t t_u8,\n+                      ty.t t_u16,\n+                      ty.t t_u32,\n+                      ty.t t_u64,\n+\n+                      ty.t t_f32,\n+                      ty.t t_f64,\n+\n+                      ty.t t_char,\n+                      ty.t t_str,\n \n-type type_store = hashmap[t,t];\n+                      ty.t t_native,\n+                      ty.t t_type,\n+\n+                      mutable vec[ty.t] t_params,\n+                      mutable vec[ty.t] t_bound_params,\n+                      mutable vec[ty.t] t_vars,\n+                      hashmap[t,t] others);\n \n fn mk_type_store() -> @type_store {\n     auto hasher = hash_ty;\n     auto eqer = eq_ty_full;\n-    ret @map.mk_hashmap[t,t](hasher, eqer);\n+\n+    ret @rec(empty_vec_ty = _vec.empty[ty.t](),\n+             empty_vec_mutable_ty = _vec.empty_mut[ty.t](),\n+             t_nil = mk_ty_full(ty_nil, none[str]),\n+             t_bool = mk_ty_full(ty_bool, none[str]),\n+             t_int = mk_ty_full(ty_int, none[str]),\n+             t_float = mk_ty_full(ty_float, none[str]),\n+             t_uint = mk_ty_full(ty_uint, none[str]),\n+             \n+             t_i8 = mk_ty_full(ty_machine(ty_i8), none[str]),\n+             t_i16 = mk_ty_full(ty_machine(ty_i16), none[str]),\n+             t_i32 = mk_ty_full(ty_machine(ty_i32), none[str]),\n+             t_i64 = mk_ty_full(ty_machine(ty_i64), none[str]),\n+\n+             t_u8 = mk_ty_full(ty_machine(ty_u8), none[str]),\n+             t_u16 = mk_ty_full(ty_machine(ty_u16), none[str]),\n+             t_u32 = mk_ty_full(ty_machine(ty_u32), none[str]),\n+             t_u64 = mk_ty_full(ty_machine(ty_u64), none[str]),\n+\n+             t_f32 = mk_ty_full(ty_machine(ty_f32), none[str]),\n+             t_f64 = mk_ty_full(ty_machine(ty_f64), none[str]),\n+\n+             t_char = mk_ty_full(ty_char, none[str]),\n+             t_str = mk_ty_full(ty_str, none[str]),\n+\n+             t_native = mk_ty_full(ty_native, none[str]),\n+             t_type = mk_ty_full(ty_type, none[str]),\n+\n+             mutable t_params = _vec.empty[ty.t](),\n+             mutable t_bound_params = _vec.empty[ty.t](),\n+             mutable t_vars = _vec.empty[ty.t](),\n+\n+             others=map.mk_hashmap[t,t](hasher, eqer));\n }\n \n // Type constructors\n@@ -119,36 +194,53 @@ fn gen_ty(@type_store tystore, &sty st) -> t {\n     ret gen_ty_full(tystore, st, none[str]);\n }\n \n-fn gen_ty_full(@type_store tystore, &sty st, option.t[str] cname) -> t {\n+fn mk_ty_full(&sty st, option.t[str] cname) -> t {\n     auto h = hash_type_info(st, cname);\n     auto magic = mk_magic(st);\n-    auto new_type = @rec(struct=st, cname=cname, magic=magic, hash=h);\n+    ret @rec(struct=st, cname=cname, magic=magic, hash=h);\n+}\n \n+fn gen_ty_full(@type_store tystore, &sty st, option.t[str] cname) -> t {\n+    auto new_type = mk_ty_full(st, cname);\n     // Is it interned?\n-    alt (tystore.find(new_type)) {\n+    alt (tystore.others.find(new_type)) {\n         case (some[t](?typ)) {\n             ret typ;\n         }\n         case (none[t]) {\n             // Nope. Insert it and return.\n-            tystore.insert(new_type, new_type);\n+            tystore.others.insert(new_type, new_type);\n             ret new_type;\n         }\n     }\n }\n \n-fn mk_nil(@type_store ts) -> t          { ret gen_ty(ts, ty_nil); }\n-fn mk_bool(@type_store ts) -> t         { ret gen_ty(ts, ty_bool); }\n-fn mk_int(@type_store ts) -> t          { ret gen_ty(ts, ty_int); }\n-fn mk_float(@type_store ts) -> t        { ret gen_ty(ts, ty_float); }\n-fn mk_uint(@type_store ts) -> t         { ret gen_ty(ts, ty_uint); }\n+fn mk_nil(@type_store ts) -> t          { ret ts.t_nil; }\n+fn mk_bool(@type_store ts) -> t         { ret ts.t_bool; }\n+fn mk_int(@type_store ts) -> t          { ret ts.t_int; }\n+fn mk_float(@type_store ts) -> t        { ret ts.t_float; }\n+fn mk_uint(@type_store ts) -> t         { ret ts.t_uint; }\n \n fn mk_mach(@type_store ts, util.common.ty_mach tm) -> t {\n-    ret gen_ty(ts, ty_machine(tm));\n+    alt (tm) {\n+        case (ty_u8) { ret ts.t_u8; }\n+        case (ty_u16) { ret ts.t_u16; }\n+        case (ty_u32) { ret ts.t_u32; }\n+        case (ty_u64) { ret ts.t_u64; }\n+\n+        case (ty_i8) { ret ts.t_i8; }\n+        case (ty_i16) { ret ts.t_i16; }\n+        case (ty_i32) { ret ts.t_i32; }\n+        case (ty_i64) { ret ts.t_i64; }\n+\n+        case (ty_f32) { ret ts.t_f32; }\n+        case (ty_f64) { ret ts.t_f64; }\n+    }\n+    fail;\n }\n \n-fn mk_char(@type_store ts) -> t         { ret gen_ty(ts, ty_char); }\n-fn mk_str(@type_store ts) -> t          { ret gen_ty(ts, ty_str); }\n+fn mk_char(@type_store ts) -> t         { ret ts.t_char; }\n+fn mk_str(@type_store ts) -> t          { ret ts.t_str; }\n \n fn mk_tag(@type_store ts, ast.def_id did, vec[t] tys) -> t {\n     ret gen_ty(ts, ty_tag(did, tys));\n@@ -197,22 +289,39 @@ fn mk_obj(@type_store ts, vec[method] meths) -> t {\n     ret gen_ty(ts, ty_obj(meths));\n }\n \n-fn mk_var(@type_store ts, int v) -> t    { ret gen_ty(ts, ty_var(v)); }\n+fn mk_var(@type_store ts, int v) -> t    {\n+    let int i = _vec.len[t](ts.t_vars) as int;\n+    while (i <= v) {\n+        ts.t_vars += vec(mk_ty_full(ty_var(i), none[str]));\n+        i += 1;\n+    }\n+    ret ts.t_vars.(v);\n+}\n \n fn mk_local(@type_store ts, ast.def_id did) -> t {\n     ret gen_ty(ts, ty_local(did));\n }\n \n fn mk_param(@type_store ts, uint n) -> t {\n-    ret gen_ty(ts, ty_param(n));\n+    let uint i = _vec.len[t](ts.t_params);\n+    while (i <= n) {\n+        ts.t_params += vec(mk_ty_full(ty_param(i), none[str]));\n+        i += 1u;\n+    }\n+    ret ts.t_params.(n);\n }\n \n fn mk_bound_param(@type_store ts, uint n) -> t {\n-    ret gen_ty(ts, ty_bound_param(n));\n+    let uint i = _vec.len[t](ts.t_bound_params);\n+    while (i <= n) {\n+        ts.t_bound_params += vec(mk_ty_full(ty_bound_param(i), none[str]));\n+        i += 1u;\n+    }\n+    ret ts.t_bound_params.(n);\n }\n \n-fn mk_type(@type_store ts) -> t          { ret gen_ty(ts, ty_type); }\n-fn mk_native(@type_store ts) -> t        { ret gen_ty(ts, ty_native); }\n+fn mk_type(@type_store ts) -> t          { ret ts.t_type; }\n+fn mk_native(@type_store ts) -> t        { ret ts.t_native; }\n \n \n // Returns the one-level-deep type structure of the given type."}, {"sha": "9aef66aaf680277773bba4a6350657b35ef2797b", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b258060a94e629d3281697cedfa6620f5e75b0c3/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b258060a94e629d3281697cedfa6620f5e75b0c3/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=b258060a94e629d3281697cedfa6620f5e75b0c3", "patch": "@@ -106,7 +106,7 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n         -> ty_param_count_and_ty {\n     alt (defn) {\n         case (ast.def_arg(?id)) {\n-            check (fcx.locals.contains_key(id));\n+            // check (fcx.locals.contains_key(id));\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast.def_local(?id)) {\n@@ -118,7 +118,7 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n             ret tup(0u, t);\n         }\n         case (ast.def_obj_field(?id)) {\n-            check (fcx.locals.contains_key(id));\n+            // check (fcx.locals.contains_key(id));\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast.def_fn(?id)) {\n@@ -138,7 +138,7 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n                                     fcx.ccx.type_cache, vid);\n         }\n         case (ast.def_binding(?id)) {\n-            check (fcx.locals.contains_key(id));\n+            // check (fcx.locals.contains_key(id));\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast.def_obj(?id)) {\n@@ -406,7 +406,7 @@ mod Collect {\n             ret creader.get_type(cx.sess, cx.tystore, id);\n         }\n \n-        check (cx.id_to_ty_item.contains_key(id));\n+        // check (cx.id_to_ty_item.contains_key(id));\n \n         auto it = cx.id_to_ty_item.get(id);\n         auto tpt;\n@@ -493,15 +493,17 @@ mod Collect {\n                 ret cx.type_cache.get(odid.ty);\n             }\n \n-            case (ast.item_ty(?ident, ?ty, ?tps, ?def_id, _)) {\n-                if (cx.type_cache.contains_key(def_id)) {\n-                    // Avoid repeating work.\n-                    ret cx.type_cache.get(def_id);\n+            case (ast.item_ty(?ident, ?t, ?tps, ?def_id, _)) {\n+                alt (cx.type_cache.find(def_id)) {\n+                    case (some[ty.ty_param_count_and_ty](?tpt)) {\n+                        ret tpt;\n+                    }\n+                    case (none[ty.ty_param_count_and_ty]) {}\n                 }\n \n                 // Tell ast_ty_to_ty() that we want to perform a recursive\n                 // call to resolve any named types.\n-                auto typ = convert(ty);\n+                auto typ = convert(t);\n                 auto ty_param_count = _vec.len[ast.ty_param](tps);\n                 auto tpt = tup(ty_param_count, typ);\n                 cx.type_cache.insert(def_id, tpt);\n@@ -543,9 +545,11 @@ mod Collect {\n                                          def_id);\n             }\n             case (ast.native_item_ty(_, ?def_id)) {\n-                if (cx.type_cache.contains_key(def_id)) {\n-                    // Avoid repeating work.\n-                    ret cx.type_cache.get(def_id);\n+                alt (cx.type_cache.find(def_id)) {\n+                    case (some[ty.ty_param_count_and_ty](?tpt)) {\n+                        ret tpt;\n+                    }\n+                    case (none[ty.ty_param_count_and_ty]) {}\n                 }\n \n                 auto t = ty.mk_native(cx.tystore);\n@@ -661,7 +665,7 @@ mod Collect {\n     fn fold_item_const(&@env e, &span sp, ast.ident i,\n                        @ast.ty t, @ast.expr ex,\n                        ast.def_id id, ast.ann a) -> @ast.item {\n-        check (e.cx.type_cache.contains_key(id));\n+        // check (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_const(i, t, ex, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n@@ -670,7 +674,7 @@ mod Collect {\n     fn fold_item_fn(&@env e, &span sp, ast.ident i,\n                     &ast._fn f, vec[ast.ty_param] ty_params,\n                     ast.def_id id, ast.ann a) -> @ast.item {\n-        check (e.cx.type_cache.contains_key(id));\n+        // check (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_fn(i, f, ty_params, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n@@ -679,7 +683,7 @@ mod Collect {\n     fn fold_native_item_fn(&@env e, &span sp, ast.ident i, option.t[str] ln,\n                            &ast.fn_decl d, vec[ast.ty_param] ty_params,\n                            ast.def_id id, ast.ann a) -> @ast.native_item {\n-        check (e.cx.type_cache.contains_key(id));\n+        // check (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.native_item_fn(i, ln, d, ty_params, id,\n                                        triv_ann(typ));\n@@ -710,7 +714,7 @@ mod Collect {\n     fn fold_item_obj(&@env e, &span sp, ast.ident i,\n                     &ast._obj ob, vec[ast.ty_param] ty_params,\n                     ast.obj_def_ids odid, ast.ann a) -> @ast.item {\n-        check (e.cx.type_cache.contains_key(odid.ctor));\n+        // check (e.cx.type_cache.contains_key(odid.ctor));\n         auto t = e.cx.type_cache.get(odid.ctor)._1;\n         let vec[method] meth_tys = get_ctor_obj_methods(e, t);\n         let vec[@ast.method] methods = vec();\n@@ -766,7 +770,7 @@ mod Collect {\n     fn fold_item_ty(&@env e, &span sp, ast.ident i,\n                     @ast.ty t, vec[ast.ty_param] ty_params,\n                     ast.def_id id, ast.ann a) -> @ast.item {\n-        check (e.cx.type_cache.contains_key(id));\n+        // check (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_ty(i, t, ty_params, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n@@ -841,13 +845,16 @@ mod Unify {\n     fn with_params(@fn_ctxt fcx, ty.t expected, ty.t actual,\n                    vec[mutable ty.t] param_substs) -> ty.Unify.result {\n         auto cache_key = tup(expected, actual, param_substs);\n-        if (fcx.ccx.unify_cache.contains_key(cache_key)) {\n-            fcx.ccx.cache_hits += 1u;\n-            ret fcx.ccx.unify_cache.get(cache_key);\n+        alt (fcx.ccx.unify_cache.find(cache_key)) {\n+            case (some[ty.Unify.result](?r)) {\n+                fcx.ccx.cache_hits += 1u;\n+                ret r;\n+            }\n+            case (none[ty.Unify.result]) {\n+                fcx.ccx.cache_misses += 1u;\n+            }\n         }\n \n-        fcx.ccx.cache_misses += 1u;\n-\n         obj unify_handler(@fn_ctxt fcx, vec[mutable ty.t] param_substs) {\n             fn resolve_local(ast.def_id id) -> option.t[ty.t] {\n                 alt (fcx.locals.find(id)) {\n@@ -1502,11 +1509,18 @@ fn writeback_local(&option.t[@fn_ctxt] env, &span sp, @ast.local local)\n         -> @ast.decl {\n     auto fcx = option.get[@fn_ctxt](env);\n \n-    if (!fcx.locals.contains_key(local.id)) {\n-        fcx.ccx.sess.span_err(sp, \"unable to determine type of local: \"\n-                              + local.ident);\n+    auto local_ty;\n+    alt (fcx.locals.find(local.id)) {\n+        case (none[ty.t]) {\n+            fcx.ccx.sess.span_err(sp, \"unable to determine type of local: \"\n+                                  + local.ident);\n+            fail;\n+        }\n+        case (some[ty.t](?lt)) {\n+            local_ty = lt;\n+        }\n     }\n-    auto local_ty = fcx.locals.get(local.id);\n+\n     auto local_wb = @rec(ann=triv_ann(local_ty)\n         with *local\n     );"}]}