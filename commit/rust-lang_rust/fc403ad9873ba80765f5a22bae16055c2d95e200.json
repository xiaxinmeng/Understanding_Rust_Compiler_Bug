{"sha": "fc403ad9873ba80765f5a22bae16055c2d95e200", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNDAzYWQ5ODczYmE4MDc2NWY1YTIyYmFlMTYwNTVjMmQ5NWUyMDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-30T19:41:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-30T19:41:07Z"}, "message": "Auto merge of #53255 - orium:fix-bug-overflow-send, r=arielb1\n\nAdd a per-tree error cache to the obligation forest\n\nThis implements part of what @nikomatsakis mentioned in  https://github.com/rust-lang/rust/pull/30533#issuecomment-170705871:\n\n> 1. If you find that a new obligation is a duplicate of one already in the tree, the proper processing is:\n>      * if that other location is your parent, you should abort with a cycle error (or accept it, if coinductive)\n>      * if that other location is not an ancestor, you can safely ignore the new obligation\n\nIn particular it implements the \"if that other location is your parent accept it, if coinductive\" part.  This fixes #40827.\n\nI have to say that I'm not 100% confident that this is rock solid.  This is my first pull request :tada:, and I didn't know anything about the trait resolver before this.  In particular I'm not totally sure that comparing predicates is enough (for instance, do we need to compare `param_env` as well?).  Also, I'm not sure what @nikomatsakis mentions [here](https://github.com/rust-lang/rust/issues/30977#issue-127091096), but it might be something that affects this PR:\n\n> In particular, I am wary of getting things wrong around inference variables! We can always add things to the set in their current state, and if unifications occur then the obligation is just kind of out-of-date, but I want to be sure we don't accidentally fail to notice that something is our ancestor. I decided this was subtle enough to merit its own PR.\n\nAnyway, go ahead and review :slightly_smiling_face:.\n\nRef #30977.\n\n# Performance\n\nWe are now copying vectors around, so I decided to do some benchmarking.  A simple benchmark shows that this does not seem to affect performance in a measurable way:\n\nI ran `cargo clean && cargo build` 20 times on actix-web (84b27db) and these are the results:\n\n```text\nrustc master:\n\n            Mean        Std.Dev.    Min         Median      Max\nreal        66.637      2.996       57.220      67.714      69.314\nuser        307.293     14.741      258.093     312.209     320.702\nsys         12.524      0.653       10.499      12.726      13.193\n\nrustc fix-bug-overflow-send:\n\n            Mean        Std.Dev.    Min         Median      Max\nreal        66.297      4.310       53.532      67.516      70.348\nuser        306.812     22.371      236.917     314.748     326.229\nsys         12.757      0.952       9.671       13.125      13.544\n```\n\nI will do a more comprehensive benchmark (compiling rustc stage1) and post the results.\n\nr? @nikomatsakis, @nnethercote\n\nPS: It is better to review this commit-by-commit.", "tree": {"sha": "4bc7b4570c97d1b0bcacc5eb117173531bcecd6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bc7b4570c97d1b0bcacc5eb117173531bcecd6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc403ad9873ba80765f5a22bae16055c2d95e200", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc403ad9873ba80765f5a22bae16055c2d95e200", "html_url": "https://github.com/rust-lang/rust/commit/fc403ad9873ba80765f5a22bae16055c2d95e200", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc403ad9873ba80765f5a22bae16055c2d95e200/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "390540909e545ffbec79d706d98c868a0f2ef297", "url": "https://api.github.com/repos/rust-lang/rust/commits/390540909e545ffbec79d706d98c868a0f2ef297", "html_url": "https://github.com/rust-lang/rust/commit/390540909e545ffbec79d706d98c868a0f2ef297"}, {"sha": "6bfa6aa87255cf8291333139ad2d383950b5a0f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bfa6aa87255cf8291333139ad2d383950b5a0f7", "html_url": "https://github.com/rust-lang/rust/commit/6bfa6aa87255cf8291333139ad2d383950b5a0f7"}], "stats": {"total": 232, "additions": 183, "deletions": 49}, "files": [{"sha": "1e5ce15914d6a6026dd6cfdf829637ce99b21f4f", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=fc403ad9873ba80765f5a22bae16055c2d95e200", "patch": "@@ -73,16 +73,16 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     /// ```\n     /// struct Foo<T> { data: Box<T> }\n     /// ```\n-\n+    ///\n     /// then this might return that Foo<T>: Send if T: Send (encoded in the AutoTraitResult type).\n     /// The analysis attempts to account for custom impls as well as other complex cases. This\n     /// result is intended for use by rustdoc and other such consumers.\n-\n+    ///\n     /// (Note that due to the coinductive nature of Send, the full and correct result is actually\n     /// quite simple to generate. That is, when a type has no custom impl, it is Send iff its field\n     /// types are all Send. So, in our example, we might have that Foo<T>: Send if Box<T>: Send.\n     /// But this is often not the best way to present to the user.)\n-\n+    ///\n     /// Warning: The API should be considered highly unstable, and it may be refactored or removed\n     /// in the future.\n     pub fn find_auto_trait_generics<A>(\n@@ -288,7 +288,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     // hold.\n     //\n     // One additional consideration is supertrait bounds. Normally, a ParamEnv is only ever\n-    // consutrcted once for a given type. As part of the construction process, the ParamEnv will\n+    // constructed once for a given type. As part of the construction process, the ParamEnv will\n     // have any supertrait bounds normalized - e.g. if we have a type 'struct Foo<T: Copy>', the\n     // ParamEnv will contain 'T: Copy' and 'T: Clone', since 'Copy: Clone'. When we construct our\n     // own ParamEnv, we need to do this ourselves, through traits::elaborate_predicates, or else"}, {"sha": "0f330504334a6a38e4bf0e443af53b028c2a48b4", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=fc403ad9873ba80765f5a22bae16055c2d95e200", "patch": "@@ -45,7 +45,6 @@ impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n /// along. Once all type inference constraints have been generated, the\n /// method `select_all_or_error` can be used to report any remaining\n /// ambiguous cases as errors.\n-\n pub struct FulfillmentContext<'tcx> {\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n@@ -89,7 +88,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n     /// Attempts to select obligations using `selcx`.\n     fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n-              -> Result<(),Vec<FulfillmentError<'tcx>>> {\n+              -> Result<(), Vec<FulfillmentError<'tcx>>> {\n         debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n \n         let mut errors = Vec::new();"}, {"sha": "75c6d805fad74577ad5c8edf79e65179aa7de10f", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=fc403ad9873ba80765f5a22bae16055c2d95e200", "patch": "@@ -644,7 +644,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // have the errors get reported at a defined place (e.g.,\n     // during typeck). Instead I have all parameter\n     // environments, in effect, going through this function\n-    // and hence potentially reporting errors. This ensurse of\n+    // and hence potentially reporting errors. This ensures of\n     // course that we never forget to normalize (the\n     // alternative seemed like it would involve a lot of\n     // manual invocations of this fn -- and then we'd have to"}, {"sha": "268b8e0161b6dd54fbcd00535895f9ae6c6dd192", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=fc403ad9873ba80765f5a22bae16055c2d95e200", "patch": "@@ -582,7 +582,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         match self.confirm_candidate(obligation, candidate) {\n             Err(SelectionError::Overflow) => {\n                 assert!(self.query_mode == TraitQueryMode::Canonical);\n-                return Err(SelectionError::Overflow);\n+                Err(SelectionError::Overflow)\n             },\n             Err(e) => Err(e),\n             Ok(candidate) => Ok(Some(candidate))\n@@ -879,7 +879,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // must be met of course). One obvious case this comes up is\n         // marker traits like `Send`. Think of a linked list:\n         //\n-        //    struct List<T> { data: T, next: Option<Box<List<T>>> {\n+        //    struct List<T> { data: T, next: Option<Box<List<T>>> }\n         //\n         // `Box<List<T>>` will be `Send` if `T` is `Send` and\n         // `Option<Box<List<T>>>` is `Send`, and in turn\n@@ -1407,7 +1407,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                stack: &TraitObligationStack<'o, 'tcx>)\n                                -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>>\n     {\n-        let TraitObligationStack { obligation, .. } = *stack;\n+        let obligation = stack.obligation;\n         let ref obligation = Obligation {\n             param_env: obligation.param_env,\n             cause: obligation.cause.clone(),\n@@ -1788,9 +1788,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn assemble_candidates_from_auto_impls(&mut self,\n-                                              obligation: &TraitObligation<'tcx>,\n-                                              candidates: &mut SelectionCandidateSet<'tcx>)\n-                                              -> Result<(), SelectionError<'tcx>>\n+                                           obligation: &TraitObligation<'tcx>,\n+                                           candidates: &mut SelectionCandidateSet<'tcx>)\n+                                           -> Result<(), SelectionError<'tcx>>\n     {\n         // OK to skip binder here because the tests we do below do not involve bound regions\n         let self_ty = *obligation.self_ty().skip_binder();\n@@ -2433,7 +2433,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn confirm_candidate(&mut self,\n                          obligation: &TraitObligation<'tcx>,\n                          candidate: SelectionCandidate<'tcx>)\n-                         -> Result<Selection<'tcx>,SelectionError<'tcx>>\n+                         -> Result<Selection<'tcx>, SelectionError<'tcx>>\n     {\n         debug!(\"confirm_candidate({:?}, {:?})\",\n                obligation,\n@@ -2612,11 +2612,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let mut obligations = self.collect_predicates_for_types(\n             obligation.param_env,\n             cause,\n-            obligation.recursion_depth+1,\n+            obligation.recursion_depth + 1,\n             trait_def_id,\n             nested);\n \n-        let trait_obligations = self.in_snapshot(|this, snapshot| {\n+        let trait_obligations: Vec<PredicateObligation<'_>> = self.in_snapshot(|this, snapshot| {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n             let (trait_ref, skol_map) =\n                 this.infcx().skolemize_late_bound_regions(&poly_trait_ref);\n@@ -2630,6 +2630,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                            snapshot)\n         });\n \n+        // Adds the predicates from the trait.  Note that this contains a `Self: Trait`\n+        // predicate as usual.  It won't have any effect since auto traits are coinductive.\n         obligations.extend(trait_obligations);\n \n         debug!(\"vtable_auto_impl: obligations={:?}\", obligations);"}, {"sha": "f159857e7446711e1d391327990c07618712e08d", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 73, "deletions": 20, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=fc403ad9873ba80765f5a22bae16055c2d95e200", "patch": "@@ -65,6 +65,12 @@ pub enum ProcessResult<O, E> {\n     Error(E),\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+struct ObligationTreeId(usize);\n+\n+type ObligationTreeIdGenerator =\n+    ::std::iter::Map<::std::ops::RangeFrom<usize>, fn(usize) -> ObligationTreeId>;\n+\n pub struct ObligationForest<O: ForestObligation> {\n     /// The list of obligations. In between calls to\n     /// `process_obligations`, this list only contains nodes in the\n@@ -79,11 +85,25 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// at a higher index than its parent. This is needed by the\n     /// backtrace iterator (which uses `split_at`).\n     nodes: Vec<Node<O>>,\n+\n     /// A cache of predicates that have been successfully completed.\n     done_cache: FxHashSet<O::Predicate>,\n+\n     /// An cache of the nodes in `nodes`, indexed by predicate.\n     waiting_cache: FxHashMap<O::Predicate, NodeIndex>,\n+\n     scratch: Option<Vec<usize>>,\n+\n+    obligation_tree_id_generator: ObligationTreeIdGenerator,\n+\n+    /// Per tree error cache.  This is used to deduplicate errors,\n+    /// which is necessary to avoid trait resolution overflow in\n+    /// some cases.\n+    ///\n+    /// See [this][details] for details.\n+    ///\n+    /// [details]: https://github.com/rust-lang/rust/pull/53255#issuecomment-421184780\n+    error_cache: FxHashMap<ObligationTreeId, FxHashSet<O::Predicate>>,\n }\n \n #[derive(Debug)]\n@@ -99,6 +119,9 @@ struct Node<O> {\n     /// Obligations that depend on this obligation for their\n     /// completion. They must all be in a non-pending state.\n     dependents: Vec<NodeIndex>,\n+\n+    /// Identifier of the obligation tree to which this node belongs.\n+    obligation_tree_id: ObligationTreeId,\n }\n \n /// The state of one node in some tree within the forest. This\n@@ -165,6 +188,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n             done_cache: FxHashSet(),\n             waiting_cache: FxHashMap(),\n             scratch: Some(vec![]),\n+            obligation_tree_id_generator: (0..).map(|i| ObligationTreeId(i)),\n+            error_cache: FxHashMap(),\n         }\n     }\n \n@@ -187,7 +212,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                               -> Result<(), ()>\n     {\n         if self.done_cache.contains(obligation.as_predicate()) {\n-            return Ok(())\n+            return Ok(());\n         }\n \n         match self.waiting_cache.entry(obligation.as_predicate().clone()) {\n@@ -214,9 +239,29 @@ impl<O: ForestObligation> ObligationForest<O> {\n             Entry::Vacant(v) => {\n                 debug!(\"register_obligation_at({:?}, {:?}) - ok, new index is {}\",\n                        obligation, parent, self.nodes.len());\n-                v.insert(NodeIndex::new(self.nodes.len()));\n-                self.nodes.push(Node::new(parent, obligation));\n-                Ok(())\n+\n+                let obligation_tree_id = match parent {\n+                    Some(p) => {\n+                        let parent_node = &self.nodes[p.get()];\n+                        parent_node.obligation_tree_id\n+                    }\n+                    None => self.obligation_tree_id_generator.next().unwrap()\n+                };\n+\n+                let already_failed =\n+                    parent.is_some()\n+                        && self.error_cache\n+                            .get(&obligation_tree_id)\n+                            .map(|errors| errors.contains(obligation.as_predicate()))\n+                            .unwrap_or(false);\n+\n+                if already_failed {\n+                    Err(())\n+                } else {\n+                    v.insert(NodeIndex::new(self.nodes.len()));\n+                    self.nodes.push(Node::new(parent, obligation, obligation_tree_id));\n+                    Ok(())\n+                }\n             }\n         }\n     }\n@@ -251,6 +296,15 @@ impl<O: ForestObligation> ObligationForest<O> {\n             .collect()\n     }\n \n+    fn insert_into_error_cache(&mut self, node_index: usize) {\n+        let node = &self.nodes[node_index];\n+\n+        self.error_cache\n+            .entry(node.obligation_tree_id)\n+            .or_insert_with(|| FxHashSet())\n+            .insert(node.obligation.as_predicate().clone());\n+    }\n+\n     /// Perform a pass through the obligation list. This must\n     /// be called in a loop until `outcome.stalled` is false.\n     ///\n@@ -264,22 +318,15 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let mut stalled = true;\n \n         for index in 0..self.nodes.len() {\n-            debug!(\"process_obligations: node {} == {:?}\",\n-                   index,\n-                   self.nodes[index]);\n+            debug!(\"process_obligations: node {} == {:?}\", index, self.nodes[index]);\n \n             let result = match self.nodes[index] {\n-                Node { state: ref _state, ref mut obligation, .. }\n-                    if _state.get() == NodeState::Pending =>\n-                {\n-                    processor.process_obligation(obligation)\n-                }\n+                Node { ref state, ref mut obligation, .. } if state.get() == NodeState::Pending =>\n+                    processor.process_obligation(obligation),\n                 _ => continue\n             };\n \n-            debug!(\"process_obligations: node {} got result {:?}\",\n-                   index,\n-                   result);\n+            debug!(\"process_obligations: node {} got result {:?}\", index, result);\n \n             match result {\n                 ProcessResult::Unchanged => {\n@@ -420,13 +467,13 @@ impl<O: ForestObligation> ObligationForest<O> {\n         }\n \n         while let Some(i) = error_stack.pop() {\n-            let node = &self.nodes[i];\n-\n-            match node.state.get() {\n+            match self.nodes[i].state.get() {\n                 NodeState::Error => continue,\n-                _ => node.state.set(NodeState::Error)\n+                _ => self.nodes[i].state.set(NodeState::Error),\n             }\n \n+            let node = &self.nodes[i];\n+\n             error_stack.extend(\n                 node.parent.iter().chain(node.dependents.iter()).map(|x| x.get())\n             );\n@@ -514,6 +561,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     self.waiting_cache.remove(self.nodes[i].obligation.as_predicate());\n                     node_rewrites[i] = nodes_len;\n                     dead_nodes += 1;\n+                    self.insert_into_error_cache(i);\n                 }\n                 NodeState::OnDfsStack | NodeState::Success => unreachable!()\n             }\n@@ -587,12 +635,17 @@ impl<O: ForestObligation> ObligationForest<O> {\n }\n \n impl<O> Node<O> {\n-    fn new(parent: Option<NodeIndex>, obligation: O) -> Node<O> {\n+    fn new(\n+        parent: Option<NodeIndex>,\n+        obligation: O,\n+        obligation_tree_id: ObligationTreeId\n+    ) -> Node<O> {\n         Node {\n             obligation,\n             state: Cell::new(NodeState::Pending),\n             parent,\n             dependents: vec![],\n+            obligation_tree_id,\n         }\n     }\n }"}, {"sha": "c27a65e34310ff19e774a6d0029366d5ffeaa8f2", "filename": "src/librustc_data_structures/obligation_forest/test.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs?ref=fc403ad9873ba80765f5a22bae16055c2d95e200", "patch": "@@ -59,8 +59,9 @@ impl<OF, BF, O, E> ObligationProcessor for ClosureObligationProcessor<OF, BF, O,\n \n     fn process_backedge<'c, I>(&mut self, _cycle: I,\n                                _marker: PhantomData<&'c Self::Obligation>)\n-        where I: Clone + Iterator<Item=&'c Self::Obligation> {\n-        }\n+        where I: Clone + Iterator<Item=&'c Self::Obligation>\n+    {\n+    }\n }\n \n \n@@ -350,11 +351,8 @@ fn done_dependency() {\n         }, |_|{}));\n     assert_eq!(ok, vec![\"(A,B,C): Sized\"]);\n     assert_eq!(err.len(), 0);\n-\n-\n }\n \n-\n #[test]\n fn orphan() {\n     // check that orphaned nodes are handled correctly"}, {"sha": "4b079ace3ca328258fc5e13cd77c033cfa871a13", "filename": "src/test/ui/issue-40827.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Ftest%2Fui%2Fissue-40827.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Ftest%2Fui%2Fissue-40827.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-40827.rs?ref=fc403ad9873ba80765f5a22bae16055c2d95e200", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+struct Foo(Arc<Bar>);\n+\n+enum Bar {\n+    A(Rc<Foo>),\n+    B(Option<Foo>),\n+}\n+\n+fn f<T: Send>(_: T) {}\n+\n+fn main() {\n+    f(Foo(Arc::new(Bar::B(None))));\n+    //~^ ERROR E0277\n+    //~| ERROR E0277\n+}"}, {"sha": "dd0ebf96d19e4cfd5b23e5fb67de87b8345c7161", "filename": "src/test/ui/issue-40827.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Ftest%2Fui%2Fissue-40827.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Ftest%2Fui%2Fissue-40827.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-40827.stderr?ref=fc403ad9873ba80765f5a22bae16055c2d95e200", "patch": "@@ -0,0 +1,35 @@\n+error[E0277]: `std::rc::Rc<Foo>` cannot be sent between threads safely\n+  --> $DIR/issue-40827.rs:24:5\n+   |\n+LL |     f(Foo(Arc::new(Bar::B(None))));\n+   |     ^ `std::rc::Rc<Foo>` cannot be sent between threads safely\n+   |\n+   = help: within `Bar`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<Foo>`\n+   = note: required because it appears within the type `Bar`\n+   = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc<Bar>`\n+   = note: required because it appears within the type `Foo`\n+note: required by `f`\n+  --> $DIR/issue-40827.rs:21:1\n+   |\n+LL | fn f<T: Send>(_: T) {}\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `std::rc::Rc<Foo>` cannot be shared between threads safely\n+  --> $DIR/issue-40827.rs:24:5\n+   |\n+LL |     f(Foo(Arc::new(Bar::B(None))));\n+   |     ^ `std::rc::Rc<Foo>` cannot be shared between threads safely\n+   |\n+   = help: within `Bar`, the trait `std::marker::Sync` is not implemented for `std::rc::Rc<Foo>`\n+   = note: required because it appears within the type `Bar`\n+   = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc<Bar>`\n+   = note: required because it appears within the type `Foo`\n+note: required by `f`\n+  --> $DIR/issue-40827.rs:21:1\n+   |\n+LL | fn f<T: Send>(_: T) {}\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "dd6d2f6a2256a0e1512dee2d23d79c5e57164bcf", "filename": "src/test/ui/recursion/recursive-requirements.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Ftest%2Fui%2Frecursion%2Frecursive-requirements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Ftest%2Fui%2Frecursion%2Frecursive-requirements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-requirements.rs?ref=fc403ad9873ba80765f5a22bae16055c2d95e200", "patch": "@@ -23,5 +23,7 @@ pub struct Bar {\n }\n \n fn main() {\n-    let _: AssertSync<Foo> = unimplemented!(); //~ ERROR E0275\n+    let _: AssertSync<Foo> = unimplemented!();\n+    //~^ ERROR E0277\n+    //~| ERROR E0277\n }"}, {"sha": "8fe282505e9078d1652fd4cb8e864b4d05675121", "filename": "src/test/ui/recursion/recursive-requirements.stderr", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Ftest%2Fui%2Frecursion%2Frecursive-requirements.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc403ad9873ba80765f5a22bae16055c2d95e200/src%2Ftest%2Fui%2Frecursion%2Frecursive-requirements.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-requirements.stderr?ref=fc403ad9873ba80765f5a22bae16055c2d95e200", "patch": "@@ -1,15 +1,33 @@\n-error[E0275]: overflow evaluating the requirement `Foo: std::marker::Sync`\n+error[E0277]: `*const Bar` cannot be shared between threads safely\n   --> $DIR/recursive-requirements.rs:26:12\n    |\n-LL |     let _: AssertSync<Foo> = unimplemented!(); //~ ERROR E0275\n-   |            ^^^^^^^^^^^^^^^\n+LL |     let _: AssertSync<Foo> = unimplemented!();\n+   |            ^^^^^^^^^^^^^^^ `*const Bar` cannot be shared between threads safely\n    |\n-   = help: consider adding a `#![recursion_limit=\"128\"]` attribute to your crate\n-   = note: required because it appears within the type `std::marker::PhantomData<Foo>`\n+   = help: within `Foo`, the trait `std::marker::Sync` is not implemented for `*const Bar`\n+   = note: required because it appears within the type `Foo`\n+note: required by `AssertSync`\n+  --> $DIR/recursive-requirements.rs:13:1\n+   |\n+LL | struct AssertSync<T: Sync>(PhantomData<T>);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `*const Foo` cannot be shared between threads safely\n+  --> $DIR/recursive-requirements.rs:26:12\n+   |\n+LL |     let _: AssertSync<Foo> = unimplemented!();\n+   |            ^^^^^^^^^^^^^^^ `*const Foo` cannot be shared between threads safely\n+   |\n+   = help: within `Foo`, the trait `std::marker::Sync` is not implemented for `*const Foo`\n    = note: required because it appears within the type `Bar`\n    = note: required because it appears within the type `std::marker::PhantomData<Bar>`\n    = note: required because it appears within the type `Foo`\n+note: required by `AssertSync`\n+  --> $DIR/recursive-requirements.rs:13:1\n+   |\n+LL | struct AssertSync<T: Sync>(PhantomData<T>);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0275`.\n+For more information about this error, try `rustc --explain E0277`."}]}