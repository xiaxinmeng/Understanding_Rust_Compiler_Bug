{"sha": "2c1777a2e264e58fccd5ace94b238c8a497ddbda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMTc3N2EyZTI2NGU1OGZjY2Q1YWNlOTRiMjM4YzhhNDk3ZGRiZGE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-01-12T14:51:02Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-01-12T14:51:02Z"}, "message": "Ensure uniqueness of file ids in reference search via hashmap", "tree": {"sha": "e7d47c95c6bcdeecd5f321f4ca969d04ca90dff7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7d47c95c6bcdeecd5f321f4ca969d04ca90dff7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c1777a2e264e58fccd5ace94b238c8a497ddbda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c1777a2e264e58fccd5ace94b238c8a497ddbda", "html_url": "https://github.com/rust-lang/rust/commit/2c1777a2e264e58fccd5ace94b238c8a497ddbda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c1777a2e264e58fccd5ace94b238c8a497ddbda/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbdb32adfc49e0d69b7fd8e44135bea59382d2cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb", "html_url": "https://github.com/rust-lang/rust/commit/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb"}], "stats": {"total": 243, "additions": 122, "deletions": 121}, "files": [{"sha": "e3ef04932f93fbb04c3d8e1a83cf75fe7199fcfe", "filename": "crates/assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=2c1777a2e264e58fccd5ace94b238c8a497ddbda", "patch": "@@ -8,7 +8,7 @@ use ide_db::{\n         insert_use::{insert_use, ImportScope},\n         mod_path_to_ast,\n     },\n-    search::{FileReference, FileReferences},\n+    search::FileReference,\n     RootDatabase,\n };\n use rustc_hash::FxHashSet;\n@@ -63,10 +63,10 @@ pub(crate) fn extract_struct_from_enum_variant(\n             let current_module = enum_hir.module(ctx.db());\n             visited_modules_set.insert(current_module);\n             let mut def_rewriter = None;\n-            for FileReferences { file_id, references: refs } in usages {\n+            for (file_id, references) in usages {\n                 let mut rewriter = SyntaxRewriter::default();\n                 let source_file = ctx.sema.parse(file_id);\n-                for reference in refs {\n+                for reference in references {\n                     update_reference(\n                         ctx,\n                         &mut rewriter,"}, {"sha": "dc798daaade681cbd3bded4c7ed7d8f087970a78", "filename": "crates/assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=2c1777a2e264e58fccd5ace94b238c8a497ddbda", "patch": "@@ -47,8 +47,8 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n \n     let def = ctx.sema.to_def(&bind_pat)?;\n     let def = Definition::Local(def);\n-    let refs = def.usages(&ctx.sema).all();\n-    if refs.is_empty() {\n+    let usages = def.usages(&ctx.sema).all();\n+    if usages.is_empty() {\n         mark::hit!(test_not_applicable_if_variable_unused);\n         return None;\n     };\n@@ -66,9 +66,10 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n         let_stmt.syntax().text_range()\n     };\n \n-    let wrap_in_parens = refs\n-        .iter()\n-        .flat_map(|refs| &refs.references)\n+    let wrap_in_parens = usages\n+        .references\n+        .values()\n+        .flatten()\n         .map(|&FileReference { range, .. }| {\n             let usage_node =\n                 ctx.covering_node_for_range(range).ancestors().find_map(ast::PathExpr::cast)?;\n@@ -115,8 +116,7 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n         target,\n         move |builder| {\n             builder.delete(delete_range);\n-            for (reference, should_wrap) in\n-                refs.iter().flat_map(|refs| &refs.references).zip(wrap_in_parens)\n+            for (reference, should_wrap) in usages.references.values().flatten().zip(wrap_in_parens)\n             {\n                 let replacement =\n                     if should_wrap { init_in_paren.clone() } else { init_str.clone() };"}, {"sha": "c961680e22a02bcbb05b805a49634f51d96518e6", "filename": "crates/assists/src/handlers/remove_unused_param.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs?ref=2c1777a2e264e58fccd5ace94b238c8a497ddbda", "patch": "@@ -1,7 +1,4 @@\n-use ide_db::{\n-    defs::Definition,\n-    search::{FileReference, FileReferences},\n-};\n+use ide_db::{base_db::FileId, defs::Definition, search::FileReference};\n use syntax::{\n     algo::find_node_at_range,\n     ast::{self, ArgListOwner},\n@@ -61,8 +58,8 @@ pub(crate) fn remove_unused_param(acc: &mut Assists, ctx: &AssistContext) -> Opt\n         param.syntax().text_range(),\n         |builder| {\n             builder.delete(range_to_remove(param.syntax()));\n-            for usages in fn_def.usages(&ctx.sema).all() {\n-                process_usages(ctx, builder, usages, param_position);\n+            for (file_id, references) in fn_def.usages(&ctx.sema).all() {\n+                process_usages(ctx, builder, file_id, references, param_position);\n             }\n         },\n     )\n@@ -71,12 +68,13 @@ pub(crate) fn remove_unused_param(acc: &mut Assists, ctx: &AssistContext) -> Opt\n fn process_usages(\n     ctx: &AssistContext,\n     builder: &mut AssistBuilder,\n-    usages: FileReferences,\n+    file_id: FileId,\n+    references: Vec<FileReference>,\n     arg_to_remove: usize,\n ) {\n-    let source_file = ctx.sema.parse(usages.file_id);\n-    builder.edit_file(usages.file_id);\n-    for usage in usages.references {\n+    let source_file = ctx.sema.parse(file_id);\n+    builder.edit_file(file_id);\n+    for usage in references {\n         if let Some(text_range) = process_usage(&source_file, usage, arg_to_remove) {\n             builder.delete(text_range);\n         }"}, {"sha": "e8999a7f39c8c90f9b6e23e4386d373728f0f08c", "filename": "crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=2c1777a2e264e58fccd5ace94b238c8a497ddbda", "patch": "@@ -3,8 +3,8 @@\n use indexmap::IndexMap;\n \n use hir::Semantics;\n+use ide_db::call_info::FnCallNode;\n use ide_db::RootDatabase;\n-use ide_db::{call_info::FnCallNode, search::FileReferences};\n use syntax::{ast, AstNode, TextRange};\n \n use crate::{\n@@ -47,7 +47,7 @@ pub(crate) fn incoming_calls(db: &RootDatabase, position: FilePosition) -> Optio\n \n     let mut calls = CallLocations::default();\n \n-    for &FileReferences { file_id, ref references } in refs.info.references() {\n+    for (&file_id, references) in refs.info.references().iter() {\n         let file = sema.parse(file_id);\n         let file = file.syntax();\n         for reference in references {"}, {"sha": "c7943dc95ef87212e842d498f58644fa1ffcab1c", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=2c1777a2e264e58fccd5ace94b238c8a497ddbda", "patch": "@@ -13,6 +13,7 @@ pub(crate) mod rename;\n \n use hir::Semantics;\n use ide_db::{\n+    base_db::FileId,\n     defs::{Definition, NameClass, NameRefClass},\n     search::{FileReference, FileReferences, ReferenceAccess, ReferenceKind, SearchScope},\n     RootDatabase,\n@@ -28,7 +29,7 @@ use crate::{display::TryToNav, FilePosition, FileRange, NavigationTarget, RangeI\n #[derive(Debug, Clone)]\n pub struct ReferenceSearchResult {\n     declaration: Declaration,\n-    references: Vec<FileReferences>,\n+    references: FileReferences,\n }\n \n #[derive(Debug, Clone)]\n@@ -47,10 +48,21 @@ impl ReferenceSearchResult {\n         &self.declaration.nav\n     }\n \n-    pub fn references(&self) -> &[FileReferences] {\n+    pub fn references(&self) -> &FileReferences {\n         &self.references\n     }\n \n+    pub fn references_with_declaration(mut self) -> FileReferences {\n+        let decl_ref = FileReference {\n+            range: self.declaration.nav.focus_or_full_range(),\n+            kind: self.declaration.kind,\n+            access: self.declaration.access,\n+        };\n+        let file_id = self.declaration.nav.file_id;\n+        self.references.references.entry(file_id).or_default().push(decl_ref);\n+        self.references\n+    }\n+\n     /// Total number of references\n     /// At least 1 since all valid references should\n     /// Have a declaration\n@@ -62,23 +74,11 @@ impl ReferenceSearchResult {\n // allow turning ReferenceSearchResult into an iterator\n // over References\n impl IntoIterator for ReferenceSearchResult {\n-    type Item = FileReferences;\n-    type IntoIter = std::vec::IntoIter<FileReferences>;\n+    type Item = (FileId, Vec<FileReference>);\n+    type IntoIter = std::collections::hash_map::IntoIter<FileId, Vec<FileReference>>;\n \n-    fn into_iter(mut self) -> Self::IntoIter {\n-        let mut v = Vec::with_capacity(self.len());\n-        v.append(&mut self.references);\n-        let decl_ref = FileReference {\n-            range: self.declaration.nav.focus_or_full_range(),\n-            kind: self.declaration.kind,\n-            access: self.declaration.access,\n-        };\n-        let file_id = self.declaration.nav.file_id;\n-        match v.iter_mut().find(|it| it.file_id == file_id) {\n-            Some(file_refs) => file_refs.references.push(decl_ref),\n-            None => v.push(FileReferences { file_id, references: vec![decl_ref] }),\n-        }\n-        v.into_iter()\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.references_with_declaration().into_iter()\n     }\n }\n \n@@ -110,11 +110,12 @@ pub(crate) fn find_all_refs(\n \n     let RangeInfo { range, info: def } = find_name(&sema, &syntax, position, opt_name)?;\n \n-    let mut references = def.usages(sema).set_scope(search_scope).all();\n-    references.iter_mut().for_each(|it| {\n-        it.references.retain(|r| search_kind == ReferenceKind::Other || search_kind == r.kind)\n-    });\n-    references.retain(|r| !r.references.is_empty());\n+    let mut usages = def.usages(sema).set_scope(search_scope).all();\n+    usages\n+        .references\n+        .values_mut()\n+        .for_each(|it| it.retain(|r| search_kind == ReferenceKind::Other || search_kind == r.kind));\n+    usages.references.retain(|_, it| !it.is_empty());\n \n     let nav = def.try_to_nav(sema.db)?;\n     let decl_range = nav.focus_or_full_range();\n@@ -138,7 +139,7 @@ pub(crate) fn find_all_refs(\n \n     let declaration = Declaration { nav, kind, access: decl_access(&def, &syntax, decl_range) };\n \n-    Some(RangeInfo::new(range, ReferenceSearchResult { declaration, references }))\n+    Some(RangeInfo::new(range, ReferenceSearchResult { declaration, references: usages }))\n }\n \n fn find_name(\n@@ -292,32 +293,30 @@ fn try_find_self_references(\n             ReferenceAccess::Read\n         }),\n     };\n-    let references = function\n+    let refs = function\n         .body()\n         .map(|body| {\n-            FileReferences {\n-                file_id,\n-                references: body\n-                    .syntax()\n-                    .descendants()\n-                    .filter_map(ast::PathExpr::cast)\n-                    .filter_map(|expr| {\n-                        let path = expr.path()?;\n-                        if path.qualifier().is_none() {\n-                            path.segment()?.self_token()\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                    .map(|token| FileReference {\n-                        range: token.text_range(),\n-                        kind: ReferenceKind::SelfKw,\n-                        access: declaration.access, // FIXME: properly check access kind here instead of copying it from the declaration\n-                    })\n-                    .collect(),\n-            }\n+            body.syntax()\n+                .descendants()\n+                .filter_map(ast::PathExpr::cast)\n+                .filter_map(|expr| {\n+                    let path = expr.path()?;\n+                    if path.qualifier().is_none() {\n+                        path.segment()?.self_token()\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .map(|token| FileReference {\n+                    range: token.text_range(),\n+                    kind: ReferenceKind::SelfKw,\n+                    access: declaration.access, // FIXME: properly check access kind here instead of copying it from the declaration\n+                })\n+                .collect()\n         })\n-        .map_or_else(Vec::default, |it| vec![it]);\n+        .unwrap_or_default();\n+    let mut references = FileReferences::default();\n+    references.references.insert(file_id, refs);\n \n     Some(RangeInfo::new(\n         param_self_token.text_range(),\n@@ -328,7 +327,7 @@ fn try_find_self_references(\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n-    use ide_db::{base_db::FileId, search::FileReferences};\n+    use ide_db::base_db::FileId;\n     use stdx::format_to;\n \n     use crate::{fixture, SearchScope};\n@@ -1022,7 +1021,7 @@ impl Foo {\n             actual += \"\\n\\n\";\n         }\n \n-        for FileReferences { file_id, references } in refs.references {\n+        for (file_id, references) in refs.references {\n             for r in references {\n                 format_to!(actual, \"{:?} {:?} {:?}\", file_id, r.range, r.kind);\n                 if let Some(access) = r.access {"}, {"sha": "5207388b5219e63d555a28beb3880d20c64d03ed", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=2c1777a2e264e58fccd5ace94b238c8a497ddbda", "patch": "@@ -9,7 +9,7 @@ use hir::{Module, ModuleDef, ModuleSource, Semantics};\n use ide_db::{\n     base_db::{AnchoredPathBuf, FileId, FileRange, SourceDatabaseExt},\n     defs::{Definition, NameClass, NameRefClass},\n-    search::FileReferences,\n+    search::FileReference,\n     RootDatabase,\n };\n use syntax::{\n@@ -176,7 +176,8 @@ fn find_all_refs(\n \n fn source_edit_from_references(\n     sema: &Semantics<RootDatabase>,\n-    &FileReferences { file_id, ref references }: &FileReferences,\n+    file_id: FileId,\n+    references: &[FileReference],\n     new_name: &str,\n ) -> SourceFileEdit {\n     let mut edit = TextEdit::builder();\n@@ -283,10 +284,9 @@ fn rename_mod(\n     }\n \n     let RangeInfo { range, info: refs } = find_all_refs(sema, position)?;\n-    let ref_edits = refs\n-        .references()\n-        .iter()\n-        .map(|reference| source_edit_from_references(sema, reference, new_name));\n+    let ref_edits = refs.references().iter().map(|(&file_id, references)| {\n+        source_edit_from_references(sema, file_id, references, new_name)\n+    });\n     source_file_edits.extend(ref_edits);\n \n     Ok(RangeInfo::new(range, SourceChange::from_edits(source_file_edits, file_system_edits)))\n@@ -341,7 +341,9 @@ fn rename_to_self(\n     let mut edits = refs\n         .references()\n         .iter()\n-        .map(|reference| source_edit_from_references(sema, reference, \"self\"))\n+        .map(|(&file_id, references)| {\n+            source_edit_from_references(sema, file_id, references, \"self\")\n+        })\n         .collect::<Vec<_>>();\n \n     edits.push(SourceFileEdit {\n@@ -467,7 +469,9 @@ fn rename_reference(\n \n     let edit = refs\n         .into_iter()\n-        .map(|reference| source_edit_from_references(sema, &reference, new_name))\n+        .map(|(file_id, references)| {\n+            source_edit_from_references(sema, file_id, &references, new_name)\n+        })\n         .collect::<Vec<_>>();\n \n     Ok(RangeInfo::new(range, SourceChange::from(edit)))"}, {"sha": "89a313e9b5b6e275880c63c00ed517c27ef4374b", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=2c1777a2e264e58fccd5ace94b238c8a497ddbda", "patch": "@@ -8,7 +8,6 @@ use std::{convert::TryInto, mem};\n \n use base_db::{FileId, FileRange, SourceDatabaseExt};\n use hir::{DefWithBody, HasSource, Module, ModuleSource, Semantics, Visibility};\n-use itertools::Itertools;\n use once_cell::unsync::Lazy;\n use rustc_hash::FxHashMap;\n use syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n@@ -19,17 +18,37 @@ use crate::{\n     RootDatabase,\n };\n \n-#[derive(Debug, Clone)]\n+#[derive(Debug, Default, Clone)]\n pub struct FileReferences {\n-    pub file_id: FileId,\n-    pub references: Vec<FileReference>,\n+    pub references: FxHashMap<FileId, Vec<FileReference>>,\n }\n \n impl FileReferences {\n+    pub fn is_empty(&self) -> bool {\n+        self.references.is_empty()\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        self.references.len()\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = (&FileId, &Vec<FileReference>)> + '_ {\n+        self.references.iter()\n+    }\n+\n     pub fn file_ranges(&self) -> impl Iterator<Item = FileRange> + '_ {\n-        self.references\n-            .iter()\n-            .map(move |&FileReference { range, .. }| FileRange { file_id: self.file_id, range })\n+        self.references.iter().flat_map(|(&file_id, refs)| {\n+            refs.iter().map(move |&FileReference { range, .. }| FileRange { file_id, range })\n+        })\n+    }\n+}\n+\n+impl IntoIterator for FileReferences {\n+    type Item = (FileId, Vec<FileReference>);\n+    type IntoIter = <FxHashMap<FileId, Vec<FileReference>> as IntoIterator>::IntoIter;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.references.into_iter()\n     }\n }\n \n@@ -275,21 +294,12 @@ impl<'a> FindUsages<'a> {\n     }\n \n     /// The [`FileReferences`] returned always have unique [`FileId`]s.\n-    pub fn all(self) -> Vec<FileReferences> {\n-        let mut res = <Vec<FileReferences>>::new();\n+    pub fn all(self) -> FileReferences {\n+        let mut res = FileReferences::default();\n         self.search(&mut |file_id, reference| {\n-            match res.iter_mut().find(|it| it.file_id == file_id) {\n-                Some(file_refs) => file_refs.references.push(reference),\n-                _ => res.push(FileReferences { file_id, references: vec![reference] }),\n-            }\n+            res.references.entry(file_id).or_default().push(reference);\n             false\n         });\n-        assert!(res\n-            .iter()\n-            .map(|refs| refs.file_id)\n-            .sorted_unstable()\n-            .tuple_windows::<(_, _)>()\n-            .all(|(a, b)| a < b));\n         res\n     }\n "}, {"sha": "2cc57f0224287cb57ec950d0180646cda725fdef", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=2c1777a2e264e58fccd5ace94b238c8a497ddbda", "patch": "@@ -12,7 +12,6 @@ use ide::{\n     FileId, FilePosition, FileRange, HoverAction, HoverGotoTypeData, LineIndex, NavigationTarget,\n     Query, RangeInfo, Runnable, RunnableKind, SearchScope, SourceChange, SymbolKind, TextEdit,\n };\n-use ide_db::search::FileReferences;\n use itertools::Itertools;\n use lsp_server::ErrorCode;\n use lsp_types::{\n@@ -813,18 +812,14 @@ pub(crate) fn handle_references(\n     };\n \n     let locations = if params.context.include_declaration {\n-        let mut locations = Vec::default();\n-        refs.into_iter().for_each(|it| {\n-            locations.extend(\n-                it.file_ranges().filter_map(|frange| to_proto::location(&snap, frange).ok()),\n-            )\n-        });\n-        locations\n+        refs.references_with_declaration()\n+            .file_ranges()\n+            .filter_map(|frange| to_proto::location(&snap, frange).ok())\n+            .collect()\n     } else {\n         // Only iterate over the references if include_declaration was false\n         refs.references()\n-            .iter()\n-            .flat_map(FileReferences::file_ranges)\n+            .file_ranges()\n             .filter_map(|frange| to_proto::location(&snap, frange).ok())\n             .collect()\n     };\n@@ -1181,8 +1176,7 @@ pub(crate) fn handle_code_lens_resolve(\n                 .unwrap_or(None)\n                 .map(|r| {\n                     r.references()\n-                        .iter()\n-                        .flat_map(FileReferences::file_ranges)\n+                        .file_ranges()\n                         .filter_map(|frange| to_proto::location(&snap, frange).ok())\n                         .collect_vec()\n                 })\n@@ -1227,11 +1221,11 @@ pub(crate) fn handle_document_highlight(\n     };\n \n     let res = refs\n-        .into_iter()\n-        .find(|refs| refs.file_id == position.file_id)\n+        .references_with_declaration()\n+        .references\n+        .get(&position.file_id)\n         .map(|file_refs| {\n             file_refs\n-                .references\n                 .into_iter()\n                 .map(|r| DocumentHighlight {\n                     range: to_proto::range(&line_index, r.range),"}, {"sha": "a3eb2e800d24a5719dab51f5b262d59ee4f39321", "filename": "crates/ssr/src/search.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Fssr%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1777a2e264e58fccd5ace94b238c8a497ddbda/crates%2Fssr%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Fsearch.rs?ref=2c1777a2e264e58fccd5ace94b238c8a497ddbda", "patch": "@@ -20,7 +20,7 @@ use test_utils::mark;\n /// them more than once.\n #[derive(Default)]\n pub(crate) struct UsageCache {\n-    usages: Vec<(Definition, Vec<FileReferences>)>,\n+    usages: Vec<(Definition, FileReferences)>,\n }\n \n impl<'db> MatchFinder<'db> {\n@@ -58,11 +58,7 @@ impl<'db> MatchFinder<'db> {\n     ) {\n         if let Some(resolved_path) = pick_path_for_usages(pattern) {\n             let definition: Definition = resolved_path.resolution.clone().into();\n-            for file_range in self\n-                .find_usages(usage_cache, definition)\n-                .iter()\n-                .flat_map(FileReferences::file_ranges)\n-            {\n+            for file_range in self.find_usages(usage_cache, definition).file_ranges() {\n                 if let Some(node_to_match) = self.find_node_to_match(resolved_path, file_range) {\n                     if !is_search_permitted_ancestors(&node_to_match) {\n                         mark::hit!(use_declaration_with_braces);\n@@ -112,7 +108,7 @@ impl<'db> MatchFinder<'db> {\n         &self,\n         usage_cache: &'a mut UsageCache,\n         definition: Definition,\n-    ) -> &'a [FileReferences] {\n+    ) -> &'a FileReferences {\n         // Logically if a lookup succeeds we should just return it. Unfortunately returning it would\n         // extend the lifetime of the borrow, then we wouldn't be able to do the insertion on a\n         // cache miss. This is a limitation of NLL and is fixed with Polonius. For now we do two\n@@ -254,7 +250,7 @@ fn is_search_permitted(node: &SyntaxNode) -> bool {\n }\n \n impl UsageCache {\n-    fn find(&mut self, definition: &Definition) -> Option<&[FileReferences]> {\n+    fn find(&mut self, definition: &Definition) -> Option<&FileReferences> {\n         // We expect a very small number of cache entries (generally 1), so a linear scan should be\n         // fast enough and avoids the need to implement Hash for Definition.\n         for (d, refs) in &self.usages {"}]}