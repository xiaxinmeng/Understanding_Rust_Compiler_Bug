{"sha": "2c3250adfa4676467f9ab31201a26187a66cbe0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMzI1MGFkZmE0Njc2NDY3ZjlhYjMxMjAxYTI2MTg3YTY2Y2JlMGI=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-08-17T21:38:30Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-08-17T21:41:56Z"}, "message": "Nice graphs", "tree": {"sha": "31191982f7225758d3f85e99b92780cab3d1f003", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31191982f7225758d3f85e99b92780cab3d1f003"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c3250adfa4676467f9ab31201a26187a66cbe0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c3250adfa4676467f9ab31201a26187a66cbe0b", "html_url": "https://github.com/rust-lang/rust/commit/2c3250adfa4676467f9ab31201a26187a66cbe0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c3250adfa4676467f9ab31201a26187a66cbe0b/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d366428cc50d1f20c139ffc854a603de1c1470c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d366428cc50d1f20c139ffc854a603de1c1470c", "html_url": "https://github.com/rust-lang/rust/commit/2d366428cc50d1f20c139ffc854a603de1c1470c"}], "stats": {"total": 60, "additions": 48, "deletions": 12}, "files": [{"sha": "dc1d63a29111874dd4bae64946524727e8896e8c", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2c3250adfa4676467f9ab31201a26187a66cbe0b/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c3250adfa4676467f9ab31201a26187a66cbe0b/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=2c3250adfa4676467f9ab31201a26187a66cbe0b", "patch": "@@ -459,16 +459,52 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         for scope in self.scopes.iter_mut().rev() {\n             let this_scope = scope.extent == extent;\n-            // We must invalidate all the caches leading up to the scope we\u2019re looking for, because\n-            // the cached blocks will branch into build of scope not containing the new drop. If we\n-            // add stuff to the currently inspected scope, then in some cases the non-unwind caches\n-            // may become invalid, therefore we should invalidate these as well. The unwind caches\n-            // will stay correct, because the already generated unwind blocks cannot be influenced\n-            // by just added drop.\n+            // When building drops, we try to cache chains of drops in such a way so these drops\n+            // could be reused by the drops which would branch into the cached (already built)\n+            // blocks.  This, however, means that whenever we add a drop into a scope which already\n+            // had some blocks built (and thus, cached) for it, we must invalidate all caches which\n+            // might branch into the scope which had a drop just added to it. This is necessary,\n+            // because otherwise some other code might use the cache to branch into already built\n+            // chain of drops, essentially ignoring the newly added drop.\n             //\n-            // If we\u2019re scheduling cleanup for non-droppable type (i.e. DropKind::Storage), then we\n-            // do not need to invalidate unwind branch, because DropKind::Storage does not end up\n-            // built in the unwind branch currently.\n+            // For example consider there\u2019s two scopes with a drop in each. These are built and\n+            // thus the caches are filled:\n+            //\n+            // +--------------------------------------------------------+\n+            // | +---------------------------------+                    |\n+            // | | +--------+     +-------------+  |  +---------------+ |\n+            // | | | return | <-+ | drop(outer) | <-+ |  drop(middle) | |\n+            // | | +--------+     +-------------+  |  +---------------+ |\n+            // | +------------|outer_scope cache|--+                    |\n+            // +------------------------------|middle_scope cache|------+\n+            //\n+            // Now, a new, inner-most scope is added along with a new drop into both inner-most and\n+            // outer-most scopes:\n+            //\n+            // +------------------------------------------------------------+\n+            // | +----------------------------------+                       |\n+            // | | +--------+      +-------------+  |   +---------------+   | +-------------+\n+            // | | | return | <+   | drop(new)   | <-+  |  drop(middle) | <--+| drop(inner) |\n+            // | | +--------+  |   | drop(outer) |  |   +---------------+   | +-------------+\n+            // | |             +-+ +-------------+  |                       |\n+            // | +---|invalid outer_scope cache|----+                       |\n+            // +----=----------------|invalid middle_scope cache|-----------+\n+            //\n+            // If, when adding `drop(new)` we do not invalidate the cached blocks for both\n+            // outer_scope and middle_scope, then, when building drops for the inner (right-most)\n+            // scope, the old, cached blocks, without `drop(new)` will get used, producing the\n+            // wrong results.\n+            //\n+            // The cache and its invalidation for unwind branch is somewhat special. The cache is\n+            // per-drop, rather than per scope, which has a several different implications. Adding\n+            // a new drop into a scope will not invalidate cached blocks of the prior drops in the\n+            // scope. That is true, because none of the already existing drops will have an edge\n+            // into a block with the newly added drop.\n+            //\n+            // Note that this code iterates scopes from the inner-most to the outer-most,\n+            // invalidating caches of each scope visited. This way bare minimum of the\n+            // caches gets invalidated. i.e. if a new drop is added into the middle scope, the\n+            // cache of outer scpoe stays intact.\n             let invalidate_unwind = needs_drop && !this_scope;\n             scope.invalidate_cache(invalidate_unwind);\n             if this_scope {\n@@ -497,9 +533,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                              value: &Lvalue<'tcx>,\n                              item_ty: Ty<'tcx>) {\n         for scope in self.scopes.iter_mut().rev() {\n-            // We must invalidate all the caches leading up to and including the scope we\u2019re\n-            // looking for, because otherwise some of the blocks in the chain will become\n-            // incorrect and must be rebuilt.\n+            // See the comment in schedule_drop above. The primary difference is that we invalidate\n+            // the unwind blocks unconditionally. That\u2019s because the box free may be considered\n+            // outer-most cleanup within the scope.\n             scope.invalidate_cache(true);\n             if scope.extent == extent {\n                 assert!(scope.free.is_none(), \"scope already has a scheduled free!\");"}]}