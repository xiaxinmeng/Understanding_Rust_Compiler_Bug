{"sha": "8003b043233213c6f984837d7618f92a6181a875", "node_id": "C_kwDOAAsO6NoAKDgwMDNiMDQzMjMzMjEzYzZmOTg0ODM3ZDc2MThmOTJhNjE4MWE4NzU", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-12-01T23:02:03Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-12-01T23:45:01Z"}, "message": "impl Op<&'_ RHS> for &'_ LHS", "tree": {"sha": "44c54874366877e578dfd9d6af27246272bcb8d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44c54874366877e578dfd9d6af27246272bcb8d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8003b043233213c6f984837d7618f92a6181a875", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8003b043233213c6f984837d7618f92a6181a875", "html_url": "https://github.com/rust-lang/rust/commit/8003b043233213c6f984837d7618f92a6181a875", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8003b043233213c6f984837d7618f92a6181a875/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "257fa7aa6d03157476f0d6acd9a0b4c28a3877ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/257fa7aa6d03157476f0d6acd9a0b4c28a3877ec", "html_url": "https://github.com/rust-lang/rust/commit/257fa7aa6d03157476f0d6acd9a0b4c28a3877ec"}], "stats": {"total": 136, "additions": 106, "deletions": 30}, "files": [{"sha": "9883a74c92d678cfff70473623468168772d6112", "filename": "crates/core_simd/src/ops/deref.rs", "status": "modified", "additions": 84, "deletions": 30, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/8003b043233213c6f984837d7618f92a6181a875/crates%2Fcore_simd%2Fsrc%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8003b043233213c6f984837d7618f92a6181a875/crates%2Fcore_simd%2Fsrc%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops%2Fderef.rs?ref=8003b043233213c6f984837d7618f92a6181a875", "patch": "@@ -1,70 +1,124 @@\n //! This module hacks in \"implicit deref\" for Simd's operators.\n //! Ideally, Rust would take care of this itself,\n //! and method calls usually handle the LHS implicitly.\n-//! So, we'll manually deref the RHS.\n+//! But this is not the case with arithmetic ops.\n use super::*;\n \n-macro_rules! deref_ops {\n-    ($(impl<T, const LANES: usize> $trait:ident<&Self> for Simd<T, LANES> {\n-            fn $call:ident(rhs: &Self)\n-        })*) => {\n-        $(impl<T, const LANES: usize> $trait<&Self> for Simd<T, LANES>\n+macro_rules! deref_lhs {\n+    (impl<T, const LANES: usize> $trait:ident for $simd:ty {\n+            fn $call:ident\n+        }) => {\n+        impl<T, const LANES: usize> $trait<$simd> for &$simd\n+        where\n+            T: SimdElement,\n+            $simd: $trait<$simd, Output = $simd>,\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Output = Simd<T, LANES>;\n+\n+            #[inline]\n+            #[must_use = \"operator returns a new vector without mutating the inputs\"]\n+            fn $call(self, rhs: $simd) -> Self::Output {\n+                (*self).$call(rhs)\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! deref_rhs {\n+    (impl<T, const LANES: usize> $trait:ident for $simd:ty {\n+            fn $call:ident\n+        }) => {\n+        impl<T, const LANES: usize> $trait<&$simd> for $simd\n         where\n-            Self: $trait<Self, Output = Self>,\n             T: SimdElement,\n+            $simd: $trait<$simd, Output = $simd>,\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n-            type Output = Self;\n+            type Output = Simd<T, LANES>;\n \n             #[inline]\n             #[must_use = \"operator returns a new vector without mutating the inputs\"]\n-            fn $call(self, rhs: &Self) -> Self::Output {\n+            fn $call(self, rhs: &$simd) -> Self::Output {\n                 self.$call(*rhs)\n             }\n-        })*\n+        }\n+    };\n+}\n+\n+macro_rules! deref_ops {\n+    ($(impl<T, const LANES: usize> $trait:ident for $simd:ty {\n+            fn $call:ident\n+        })*) => {\n+        $(\n+            deref_rhs! {\n+                impl<T, const LANES: usize> $trait for $simd {\n+                    fn $call\n+                }\n+            }\n+            deref_lhs! {\n+                impl<T, const LANES: usize> $trait for $simd {\n+                    fn $call\n+                }\n+            }\n+            impl<'lhs, 'rhs, T, const LANES: usize> $trait<&'rhs $simd> for &'lhs $simd\n+            where\n+                T: SimdElement,\n+                $simd: $trait<$simd, Output = $simd>,\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                type Output = $simd;\n+\n+                #[inline]\n+                #[must_use = \"operator returns a new vector without mutating the inputs\"]\n+                fn $call(self, rhs: &$simd) -> Self::Output {\n+                    (*self).$call(*rhs)\n+                }\n+            }\n+        )*\n     }\n }\n \n deref_ops! {\n     // Arithmetic\n-    impl<T, const LANES: usize> Add<&Self> for Simd<T, LANES> {\n-        fn add(rhs: &Self)\n+    impl<T, const LANES: usize> Add for Simd<T, LANES> {\n+        fn add\n     }\n \n-    impl<T, const LANES: usize> Mul<&Self> for Simd<T, LANES> {\n-        fn mul(rhs: &Self)\n+    impl<T, const LANES: usize> Mul for Simd<T, LANES> {\n+        fn mul\n     }\n \n-    impl<T, const LANES: usize> Sub<&Self> for Simd<T, LANES> {\n-        fn sub(rhs: &Self)\n+    impl<T, const LANES: usize> Sub for Simd<T, LANES> {\n+        fn sub\n     }\n \n-    impl<T, const LANES: usize> Div<&Self> for Simd<T, LANES> {\n-        fn div(rhs: &Self)\n+    impl<T, const LANES: usize> Div for Simd<T, LANES> {\n+        fn div\n     }\n \n-    impl<T, const LANES: usize> Rem<&Self> for Simd<T, LANES> {\n-        fn rem(rhs: &Self)\n+    impl<T, const LANES: usize> Rem for Simd<T, LANES> {\n+        fn rem\n     }\n \n     // Bitops\n-    impl<T, const LANES: usize> BitAnd<&Self> for Simd<T, LANES> {\n-        fn bitand(rhs: &Self)\n+    impl<T, const LANES: usize> BitAnd for Simd<T, LANES> {\n+        fn bitand\n     }\n \n-    impl<T, const LANES: usize> BitOr<&Self> for Simd<T, LANES> {\n-        fn bitor(rhs: &Self)\n+    impl<T, const LANES: usize> BitOr for Simd<T, LANES> {\n+        fn bitor\n     }\n \n-    impl<T, const LANES: usize> BitXor<&Self> for Simd<T, LANES> {\n-        fn bitxor(rhs: &Self)\n+    impl<T, const LANES: usize> BitXor for Simd<T, LANES> {\n+        fn bitxor\n     }\n \n-    impl<T, const LANES: usize> Shl<&Self> for Simd<T, LANES> {\n-        fn shl(rhs: &Self)\n+    impl<T, const LANES: usize> Shl for Simd<T, LANES> {\n+        fn shl\n     }\n \n-    impl<T, const LANES: usize> Shr<&Self> for Simd<T, LANES> {\n-        fn shr(rhs: &Self)\n+    impl<T, const LANES: usize> Shr for Simd<T, LANES> {\n+        fn shr\n     }\n }"}, {"sha": "9359da16ee5c7c1a647666598d093697daceeb1f", "filename": "crates/core_simd/tests/autoderef.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8003b043233213c6f984837d7618f92a6181a875/crates%2Fcore_simd%2Ftests%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8003b043233213c6f984837d7618f92a6181a875/crates%2Fcore_simd%2Ftests%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fautoderef.rs?ref=8003b043233213c6f984837d7618f92a6181a875", "patch": "@@ -0,0 +1,22 @@\n+// Test that we handle all our \"auto-deref\" cases correctly.\n+#![feature(portable_simd)]\n+use core_simd::f32x4;\n+\n+#[cfg(target_arch = \"wasm32\")]\n+use wasm_bindgen_test::*;\n+\n+#[cfg(target_arch = \"wasm32\")]\n+wasm_bindgen_test_configure!(run_in_browser);\n+\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn deref() {\n+    let x = f32x4::splat(1.0);\n+    let y = f32x4::splat(2.0);\n+    let a = &x;\n+    let b = &y;\n+    assert_eq!(f32x4::splat(3.0), x + y);\n+    assert_eq!(f32x4::splat(3.0), x + b);\n+    assert_eq!(f32x4::splat(3.0), a + y);\n+    assert_eq!(f32x4::splat(3.0), a + b);\n+}"}]}