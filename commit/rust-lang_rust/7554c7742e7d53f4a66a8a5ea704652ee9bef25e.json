{"sha": "7554c7742e7d53f4a66a8a5ea704652ee9bef25e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1NTRjNzc0MmU3ZDUzZjRhNjZhOGE1ZWE3MDQ2NTJlZTliZWYyNWU=", "commit": {"author": {"name": "wcampbell", "email": "wcampbell1995@gmail.com", "date": "2021-02-09T03:02:35Z"}, "committer": {"name": "wcampbell", "email": "wcampbell1995@gmail.com", "date": "2021-02-09T03:02:35Z"}, "message": "Remove unnecessary refs in pattern matching\n\nSigned-off-by: wcampbell <wcampbell1995@gmail.com>", "tree": {"sha": "c9959b67866fcc150b3ef3d6d07e6763ede6eb01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9959b67866fcc150b3ef3d6d07e6763ede6eb01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7554c7742e7d53f4a66a8a5ea704652ee9bef25e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEoLMBW/Y1Vj+lcFnQoED02vxo/+gFAmAh/GsACgkQoED02vxo\n/+hX3A/+LwRMoXb/+lU099SXYmhyS9SHLlqpvEcXnQrhG6GD/s3+viBwTSVpEM8X\n68z9jWIAKvuRvNGN4//u/bMT3Jvvk0BezUiL8BTHVUXIQdHKQ3d93aqsWLJNssjV\nUdh2/inrTHGMWyY6p4yXpQwj7qk5dD4rpVLOCLZ1L3OJi35/f9HJYJIcD7cDxYd4\nZ85YwrvDdrZrB4x4jci9ze4GOJYcSXmWkN0HtYwA4XEZjQjdNMC0Rs0mGZ0zgT9/\nGMHp22TMEQZ44eDWJL7WuV5uMCY4vUb4P3GMBkJ9pQ995TYKS9+qD7AUmCWzEAul\n73UWi8c7p7oE/PXiF783zpSqfzmAFWgpAMSf6cx86ptuM8PFJRRuKNSY3A0ugFRB\n0rpR3sYr7YXYvtHWzoKIlprSw67jHWRTaC7BI0ZIkz3H5V0zAR3QlQl8c8TRO3yn\nvlpxJSC5+/rBq+8qLj+JeGnOB5fF56FNP2ld3Vbik4Tc5SwoQJy2KIzluMal2eEK\nZEKmzh3K1iZSzE2Upl+d2ySTF2EQOh4/VV6KgiIfC0lOWZIgQIHqRzvpb6z3cf7S\nVwOH6JYn4MDitWVfw5Q979v9MTJ2Hn6Dc2RRAtHwK5OCLeFtaHZcGllQqP/IWM5j\nMBPOxG3vVKOMQwbFfTLhivuzHwfdquQKypHfc1D2kSnYvwYERWo=\n=a27y\n-----END PGP SIGNATURE-----", "payload": "tree c9959b67866fcc150b3ef3d6d07e6763ede6eb01\nparent a2704448c1f4e25d4979f21869dd3235d29b1429\nauthor wcampbell <wcampbell1995@gmail.com> 1612839755 -0500\ncommitter wcampbell <wcampbell1995@gmail.com> 1612839755 -0500\n\nRemove unnecessary refs in pattern matching\n\nSigned-off-by: wcampbell <wcampbell1995@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7554c7742e7d53f4a66a8a5ea704652ee9bef25e", "html_url": "https://github.com/rust-lang/rust/commit/7554c7742e7d53f4a66a8a5ea704652ee9bef25e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7554c7742e7d53f4a66a8a5ea704652ee9bef25e/comments", "author": {"login": "wcampbell0x2a", "id": 15236002, "node_id": "MDQ6VXNlcjE1MjM2MDAy", "avatar_url": "https://avatars.githubusercontent.com/u/15236002?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wcampbell0x2a", "html_url": "https://github.com/wcampbell0x2a", "followers_url": "https://api.github.com/users/wcampbell0x2a/followers", "following_url": "https://api.github.com/users/wcampbell0x2a/following{/other_user}", "gists_url": "https://api.github.com/users/wcampbell0x2a/gists{/gist_id}", "starred_url": "https://api.github.com/users/wcampbell0x2a/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wcampbell0x2a/subscriptions", "organizations_url": "https://api.github.com/users/wcampbell0x2a/orgs", "repos_url": "https://api.github.com/users/wcampbell0x2a/repos", "events_url": "https://api.github.com/users/wcampbell0x2a/events{/privacy}", "received_events_url": "https://api.github.com/users/wcampbell0x2a/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wcampbell0x2a", "id": 15236002, "node_id": "MDQ6VXNlcjE1MjM2MDAy", "avatar_url": "https://avatars.githubusercontent.com/u/15236002?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wcampbell0x2a", "html_url": "https://github.com/wcampbell0x2a", "followers_url": "https://api.github.com/users/wcampbell0x2a/followers", "following_url": "https://api.github.com/users/wcampbell0x2a/following{/other_user}", "gists_url": "https://api.github.com/users/wcampbell0x2a/gists{/gist_id}", "starred_url": "https://api.github.com/users/wcampbell0x2a/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wcampbell0x2a/subscriptions", "organizations_url": "https://api.github.com/users/wcampbell0x2a/orgs", "repos_url": "https://api.github.com/users/wcampbell0x2a/repos", "events_url": "https://api.github.com/users/wcampbell0x2a/events{/privacy}", "received_events_url": "https://api.github.com/users/wcampbell0x2a/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2704448c1f4e25d4979f21869dd3235d29b1429", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2704448c1f4e25d4979f21869dd3235d29b1429", "html_url": "https://github.com/rust-lang/rust/commit/a2704448c1f4e25d4979f21869dd3235d29b1429"}], "stats": {"total": 70, "additions": 34, "deletions": 36}, "files": [{"sha": "44813313fa37cb63975136b1eccb1bc7b8a67530", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7554c7742e7d53f4a66a8a5ea704652ee9bef25e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7554c7742e7d53f4a66a8a5ea704652ee9bef25e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=7554c7742e7d53f4a66a8a5ea704652ee9bef25e", "patch": "@@ -168,7 +168,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // without the final expr (e.g. `try { return; }`). We don't want to generate an\n         // unreachable_code lint for it since warnings for autogenerated code are confusing.\n         let is_try_block_generated_unit_expr = match expr.kind {\n-            ExprKind::Call(_, ref args) if expr.span.is_desugaring(DesugaringKind::TryBlock) => {\n+            ExprKind::Call(_, args) if expr.span.is_desugaring(DesugaringKind::TryBlock) => {\n                 args.len() == 1 && args[0].span.is_desugaring(DesugaringKind::TryBlock)\n             }\n \n@@ -193,9 +193,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // diverging expression (e.g. it arose from desugaring of `try { return }`),\n             // we skip issuing a warning because it is autogenerated code.\n             ExprKind::Call(..) if expr.span.is_desugaring(DesugaringKind::TryBlock) => {}\n-            ExprKind::Call(ref callee, _) => {\n-                self.warn_if_unreachable(expr.hir_id, callee.span, \"call\")\n-            }\n+            ExprKind::Call(callee, _) => self.warn_if_unreachable(expr.hir_id, callee.span, \"call\"),\n             ExprKind::MethodCall(_, ref span, _, _) => {\n                 self.warn_if_unreachable(expr.hir_id, *span, \"call\")\n             }\n@@ -231,23 +229,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let tcx = self.tcx;\n         match expr.kind {\n-            ExprKind::Box(ref subexpr) => self.check_expr_box(subexpr, expected),\n+            ExprKind::Box(subexpr) => self.check_expr_box(subexpr, expected),\n             ExprKind::Lit(ref lit) => self.check_lit(&lit, expected),\n-            ExprKind::Binary(op, ref lhs, ref rhs) => self.check_binop(expr, op, lhs, rhs),\n-            ExprKind::Assign(ref lhs, ref rhs, ref span) => {\n+            ExprKind::Binary(op, lhs, rhs) => self.check_binop(expr, op, lhs, rhs),\n+            ExprKind::Assign(lhs, rhs, ref span) => {\n                 self.check_expr_assign(expr, expected, lhs, rhs, span)\n             }\n-            ExprKind::AssignOp(op, ref lhs, ref rhs) => self.check_binop_assign(expr, op, lhs, rhs),\n-            ExprKind::Unary(unop, ref oprnd) => self.check_expr_unary(unop, oprnd, expected, expr),\n-            ExprKind::AddrOf(kind, mutbl, ref oprnd) => {\n+            ExprKind::AssignOp(op, lhs, rhs) => self.check_binop_assign(expr, op, lhs, rhs),\n+            ExprKind::Unary(unop, oprnd) => self.check_expr_unary(unop, oprnd, expected, expr),\n+            ExprKind::AddrOf(kind, mutbl, oprnd) => {\n                 self.check_expr_addr_of(kind, mutbl, oprnd, expected, expr)\n             }\n             ExprKind::Path(QPath::LangItem(lang_item, _)) => {\n                 self.check_lang_item_path(lang_item, expr)\n             }\n             ExprKind::Path(ref qpath) => self.check_expr_path(qpath, expr),\n             ExprKind::InlineAsm(asm) => self.check_expr_asm(asm),\n-            ExprKind::LlvmInlineAsm(ref asm) => {\n+            ExprKind::LlvmInlineAsm(asm) => {\n                 for expr in asm.outputs_exprs.iter().chain(asm.inputs_exprs.iter()) {\n                     self.check_expr(expr);\n                 }\n@@ -265,42 +263,42 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             ExprKind::Ret(ref expr_opt) => self.check_expr_return(expr_opt.as_deref(), expr),\n-            ExprKind::Loop(ref body, _, source, _) => {\n+            ExprKind::Loop(body, _, source, _) => {\n                 self.check_expr_loop(body, source, expected, expr)\n             }\n-            ExprKind::Match(ref discrim, ref arms, match_src) => {\n+            ExprKind::Match(discrim, arms, match_src) => {\n                 self.check_match(expr, &discrim, arms, expected, match_src)\n             }\n-            ExprKind::Closure(capture, ref decl, body_id, _, gen) => {\n+            ExprKind::Closure(capture, decl, body_id, _, gen) => {\n                 self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n             }\n-            ExprKind::Block(ref body, _) => self.check_block_with_expected(&body, expected),\n-            ExprKind::Call(ref callee, ref args) => self.check_call(expr, &callee, args, expected),\n-            ExprKind::MethodCall(ref segment, span, ref args, _) => {\n+            ExprKind::Block(body, _) => self.check_block_with_expected(&body, expected),\n+            ExprKind::Call(callee, args) => self.check_call(expr, &callee, args, expected),\n+            ExprKind::MethodCall(segment, span, args, _) => {\n                 self.check_method_call(expr, segment, span, args, expected)\n             }\n-            ExprKind::Cast(ref e, ref t) => self.check_expr_cast(e, t, expr),\n-            ExprKind::Type(ref e, ref t) => {\n+            ExprKind::Cast(e, t) => self.check_expr_cast(e, t, expr),\n+            ExprKind::Type(e, t) => {\n                 let ty = self.to_ty_saving_user_provided_ty(&t);\n                 self.check_expr_eq_type(&e, ty);\n                 ty\n             }\n             ExprKind::If(cond, then_expr, opt_else_expr) => {\n                 self.check_then_else(cond, then_expr, opt_else_expr, expr.span, expected)\n             }\n-            ExprKind::DropTemps(ref e) => self.check_expr_with_expectation(e, expected),\n-            ExprKind::Array(ref args) => self.check_expr_array(args, expected, expr),\n+            ExprKind::DropTemps(e) => self.check_expr_with_expectation(e, expected),\n+            ExprKind::Array(args) => self.check_expr_array(args, expected, expr),\n             ExprKind::ConstBlock(ref anon_const) => self.to_const(anon_const).ty,\n-            ExprKind::Repeat(ref element, ref count) => {\n+            ExprKind::Repeat(element, ref count) => {\n                 self.check_expr_repeat(element, count, expected, expr)\n             }\n-            ExprKind::Tup(ref elts) => self.check_expr_tuple(elts, expected, expr),\n-            ExprKind::Struct(ref qpath, fields, ref base_expr) => {\n+            ExprKind::Tup(elts) => self.check_expr_tuple(elts, expected, expr),\n+            ExprKind::Struct(qpath, fields, ref base_expr) => {\n                 self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n             }\n-            ExprKind::Field(ref base, field) => self.check_field(expr, &base, field),\n-            ExprKind::Index(ref base, ref idx) => self.check_expr_index(base, idx, expr),\n-            ExprKind::Yield(ref value, ref src) => self.check_expr_yield(value, expr, src),\n+            ExprKind::Field(base, field) => self.check_field(expr, &base, field),\n+            ExprKind::Index(base, idx) => self.check_expr_index(base, idx, expr),\n+            ExprKind::Yield(value, ref src) => self.check_expr_yield(value, expr, src),\n             hir::ExprKind::Err => tcx.ty_error(),\n         }\n     }\n@@ -541,7 +539,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         if let Ok(target_id) = destination.target_id {\n             let (e_ty, cause);\n-            if let Some(ref e) = expr_opt {\n+            if let Some(e) = expr_opt {\n                 // If this is a break with a value, we need to type-check\n                 // the expression. Get an expected type from the loop context.\n                 let opt_coerce_to = {\n@@ -650,12 +648,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // We still need to assign a type to the inner expression to\n             // prevent the ICE in #43162.\n-            if let Some(ref e) = expr_opt {\n+            if let Some(e) = expr_opt {\n                 self.check_expr_with_hint(e, err);\n \n                 // ... except when we try to 'break rust;'.\n                 // ICE this expression in particular (see #43162).\n-                if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.kind {\n+                if let ExprKind::Path(QPath::Resolved(_, path)) = e.kind {\n                     if path.segments.len() == 1 && path.segments[0].ident.name == sym::rust {\n                         fatally_break_rust(self.tcx.sess);\n                     }\n@@ -674,7 +672,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         if self.ret_coercion.is_none() {\n             self.tcx.sess.emit_err(ReturnStmtOutsideOfFnBody { span: expr.span });\n-        } else if let Some(ref e) = expr_opt {\n+        } else if let Some(e) = expr_opt {\n             if self.ret_coercion_span.get().is_none() {\n                 self.ret_coercion_span.set(Some(e.span));\n             }\n@@ -1133,13 +1131,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let flds = expected.only_has_type(self).and_then(|ty| {\n             let ty = self.resolve_vars_with_obligations(ty);\n             match ty.kind() {\n-                ty::Tuple(ref flds) => Some(&flds[..]),\n+                ty::Tuple(flds) => Some(&flds[..]),\n                 _ => None,\n             }\n         });\n \n         let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| match flds {\n-            Some(ref fs) if i < fs.len() => {\n+            Some(fs) if i < fs.len() => {\n                 let ety = fs[i].expect_ty();\n                 self.check_expr_coercable_to_type(&e, ety, None);\n                 ety\n@@ -1328,7 +1326,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         for field in fields {\n             self.check_expr(&field.expr);\n         }\n-        if let Some(ref base) = *base_expr {\n+        if let Some(base) = *base_expr {\n             self.check_expr(&base);\n         }\n     }\n@@ -1488,7 +1486,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n             _ => {\n                 // prevent all specified fields from being suggested\n-                let skip_fields = skip_fields.iter().map(|ref x| x.ident.name);\n+                let skip_fields = skip_fields.iter().map(|x| x.ident.name);\n                 if let Some(field_name) =\n                     Self::suggest_field_name(variant, field.ident.name, skip_fields.collect())\n                 {\n@@ -1617,7 +1615,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         private_candidate = Some((base_def.did, field_ty));\n                     }\n                 }\n-                ty::Tuple(ref tys) => {\n+                ty::Tuple(tys) => {\n                     let fstr = field.as_str();\n                     if let Ok(index) = fstr.parse::<usize>() {\n                         if fstr == index.to_string() {"}]}