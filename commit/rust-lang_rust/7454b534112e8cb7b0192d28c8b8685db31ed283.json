{"sha": "7454b534112e8cb7b0192d28c8b8685db31ed283", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NTRiNTM0MTEyZThjYjdiMDE5MmQyOGM4Yjg2ODVkYjMxZWQyODM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-11T00:49:00Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-11T00:49:00Z"}, "message": "rustc: Build up a list of upvars inside foreach bodies", "tree": {"sha": "395f984b76c86319fbfca0e20726d74063e5897c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/395f984b76c86319fbfca0e20726d74063e5897c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7454b534112e8cb7b0192d28c8b8685db31ed283", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7454b534112e8cb7b0192d28c8b8685db31ed283", "html_url": "https://github.com/rust-lang/rust/commit/7454b534112e8cb7b0192d28c8b8685db31ed283", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7454b534112e8cb7b0192d28c8b8685db31ed283/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60f86354ad95802da4c861fb8df54abf95f1917b", "url": "https://api.github.com/repos/rust-lang/rust/commits/60f86354ad95802da4c861fb8df54abf95f1917b", "html_url": "https://github.com/rust-lang/rust/commit/60f86354ad95802da4c861fb8df54abf95f1917b"}], "stats": {"total": 79, "additions": 74, "deletions": 5}, "files": [{"sha": "584586f66ce16e7972783db5608ba2300feb9d25", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7454b534112e8cb7b0192d28c8b8685db31ed283/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7454b534112e8cb7b0192d28c8b8685db31ed283/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=7454b534112e8cb7b0192d28c8b8685db31ed283", "patch": "@@ -32,6 +32,7 @@ tag def {\n     def_const(def_id);\n     def_arg(def_id);\n     def_local(def_id);\n+    def_upvar(def_id);\n     def_variant(def_id /* tag */, def_id /* variant */);\n     def_ty(def_id);\n     def_ty_arg(def_id);"}, {"sha": "32a12c2372d08335a95e7911c53d1f5900eb1fe7", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 73, "deletions": 5, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7454b534112e8cb7b0192d28c8b8685db31ed283/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7454b534112e8cb7b0192d28c8b8685db31ed283/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7454b534112e8cb7b0192d28c8b8685db31ed283", "patch": "@@ -98,6 +98,7 @@ state type fn_ctxt = rec(ValueRef llfn,\n                          hashmap[ast.def_id, ValueRef] llargs,\n                          hashmap[ast.def_id, ValueRef] llobjfields,\n                          hashmap[ast.def_id, ValueRef] lllocals,\n+                         hashmap[ast.def_id, ValueRef] llupvars,\n                          hashmap[ast.def_id, ValueRef] lltydescs,\n                          @crate_ctxt ccx);\n \n@@ -2897,6 +2898,62 @@ fn trans_for(@block_ctxt cx,\n                       bind inner(_, local, _, _, body));\n }\n \n+\n+// Iterator translation\n+\n+// Searches through a block for all references to locals or upvars in this\n+// frame and returns the list of definition IDs thus found.\n+fn collect_upvars(@block_ctxt cx, &ast.block bloc, &ast.def_id initial_decl)\n+        -> vec[ast.def_id] {\n+    type env = @rec(\n+        mutable vec[ast.def_id] refs,\n+        hashmap[ast.def_id,()] decls\n+    );\n+\n+    fn fold_expr_path(&env e, &common.span sp, &ast.path p,\n+                      &option.t[ast.def] d, ast.ann a) -> @ast.expr {\n+        alt (option.get[ast.def](d)) {\n+            case (ast.def_arg(?did))    { e.refs += vec(did);   }\n+            case (ast.def_local(?did))  { e.refs += vec(did);   }\n+            case (ast.def_upvar(?did))  { e.refs += vec(did);   }\n+            case (_)                    { /* ignore */          }\n+        }\n+\n+        ret @fold.respan[ast.expr_](sp, ast.expr_path(p, d, a));\n+    }\n+\n+    fn fold_decl_local(&env e, &common.span sp, @ast.local local)\n+            -> @ast.decl {\n+        e.decls.insert(local.id, ());\n+        ret @fold.respan[ast.decl_](sp, ast.decl_local(local));\n+    }\n+\n+    auto fep = fold_expr_path;\n+    auto fdl = fold_decl_local;\n+    auto fld = @rec(\n+        fold_expr_path=fep,\n+        fold_decl_local=fdl\n+        with *fold.new_identity_fold[env]()\n+    );\n+\n+    let vec[ast.def_id] refs = vec();\n+    let hashmap[ast.def_id,()] decls = new_def_hash[()]();\n+    decls.insert(initial_decl, ());\n+    let env e = @rec(mutable refs=refs, decls=decls);\n+\n+    fold.fold_block[env](e, fld, bloc);\n+\n+    // Calculate (refs - decls). This is the set of captured upvars.\n+    let vec[ast.def_id] result = vec();\n+    for (ast.def_id ref_id in e.refs) {\n+        if (!decls.contains_key(ref_id)) {\n+            result += vec(ref_id);\n+        }\n+    }\n+\n+    ret result;\n+}\n+\n fn trans_for_each(@block_ctxt cx,\n                   @ast.decl decl,\n                   @ast.expr seq,\n@@ -2928,19 +2985,26 @@ fn trans_for_each(@block_ctxt cx,\n     // escape. This could be determined upstream, and probably ought\n     // to be so, eventualy. For first cut, skip this. Null env.\n \n-    auto env_ty = T_opaque_closure_ptr(cx.fcx.ccx.tn);\n-\n-\n-    // Step 2: Declare foreach body function.\n-\n     // FIXME: possibly support alias-mode here?\n     auto decl_ty = plain_ty(ty.ty_nil);\n+    auto decl_id;\n     alt (decl.node) {\n         case (ast.decl_local(?local)) {\n             decl_ty = node_ann_type(cx.fcx.ccx, local.ann);\n+            decl_id = local.id;\n         }\n     }\n \n+    auto upvars = collect_upvars(cx, body, decl_id);\n+    if (_vec.len[ast.def_id](upvars) > 0u) {\n+        cx.fcx.ccx.sess.unimpl(\"upvars in for each\");\n+        fail;\n+    }\n+\n+    auto env_ty = T_opaque_closure_ptr(cx.fcx.ccx.tn);\n+\n+    // Step 2: Declare foreach body function.\n+\n     let str s =\n         cx.fcx.ccx.names.next(\"_rust_foreach\")\n         + sep() + cx.fcx.ccx.path;\n@@ -4624,6 +4688,7 @@ fn new_fn_ctxt(@crate_ctxt cx,\n     let hashmap[ast.def_id, ValueRef] llargs = new_def_hash[ValueRef]();\n     let hashmap[ast.def_id, ValueRef] llobjfields = new_def_hash[ValueRef]();\n     let hashmap[ast.def_id, ValueRef] lllocals = new_def_hash[ValueRef]();\n+    let hashmap[ast.def_id, ValueRef] llupvars = new_def_hash[ValueRef]();\n     let hashmap[ast.def_id, ValueRef] lltydescs = new_def_hash[ValueRef]();\n \n     ret @rec(llfn=llfndecl,\n@@ -4635,6 +4700,7 @@ fn new_fn_ctxt(@crate_ctxt cx,\n              llargs=llargs,\n              llobjfields=llobjfields,\n              lllocals=lllocals,\n+             llupvars=llupvars,\n              lltydescs=lltydescs,\n              ccx=cx);\n }\n@@ -5486,6 +5552,7 @@ fn trans_exit_task_glue(@crate_ctxt cx) {\n                     llargs=new_def_hash[ValueRef](),\n                     llobjfields=new_def_hash[ValueRef](),\n                     lllocals=new_def_hash[ValueRef](),\n+                    llupvars=new_def_hash[ValueRef](),\n                     lltydescs=new_def_hash[ValueRef](),\n                     ccx=cx);\n \n@@ -5819,6 +5886,7 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n                     llargs=new_def_hash[ValueRef](),\n                     llobjfields=new_def_hash[ValueRef](),\n                     lllocals=new_def_hash[ValueRef](),\n+                    llupvars=new_def_hash[ValueRef](),\n                     lltydescs=new_def_hash[ValueRef](),\n                     ccx=cx);\n "}]}