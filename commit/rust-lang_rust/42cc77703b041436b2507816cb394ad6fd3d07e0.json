{"sha": "42cc77703b041436b2507816cb394ad6fd3d07e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyY2M3NzcwM2IwNDE0MzZiMjUwNzgxNmNiMzk0YWQ2ZmQzZDA3ZTA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-01T21:30:00Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-01T21:30:00Z"}, "message": "move more stuff to ids", "tree": {"sha": "69fbd4722cea2a5a5d322d890bef14f11da60b36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69fbd4722cea2a5a5d322d890bef14f11da60b36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42cc77703b041436b2507816cb394ad6fd3d07e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42cc77703b041436b2507816cb394ad6fd3d07e0", "html_url": "https://github.com/rust-lang/rust/commit/42cc77703b041436b2507816cb394ad6fd3d07e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42cc77703b041436b2507816cb394ad6fd3d07e0/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "html_url": "https://github.com/rust-lang/rust/commit/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1"}], "stats": {"total": 368, "additions": 183, "deletions": 185}, "files": [{"sha": "c6463235c4e7272b7cb02ae1dea4c60ac848415e", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42cc77703b041436b2507816cb394ad6fd3d07e0/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42cc77703b041436b2507816cb394ad6fd3d07e0/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=42cc77703b041436b2507816cb394ad6fd3d07e0", "patch": "@@ -1,9 +1,10 @@\n use std::sync::Arc;\n \n+use ra_db::Cancelable;\n use ra_syntax::ast::{self, NameOwner, StructFlavor};\n \n use crate::{\n-    DefId, Cancelable, Name, AsName,\n+    DefId, Name, AsName,\n     db::HirDatabase,\n     type_ref::TypeRef,\n };"}, {"sha": "cd32033f38b79a43f8901fc5e193a533bbd837f8", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 173, "deletions": 2, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/42cc77703b041436b2507816cb394ad6fd3d07e0/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42cc77703b041436b2507816cb394ad6fd3d07e0/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=42cc77703b041436b2507816cb394ad6fd3d07e0", "patch": "@@ -1,6 +1,10 @@\n-use crate::{FileId, MacroCallId, HirDatabase};\n+use ra_db::{SourceRootId, LocationIntener, Cancelable, FileId};\n+use ra_syntax::{SourceFileNode, SyntaxKind, SyntaxNode, SyntaxNodeRef, SourceFile, AstNode, ast};\n \n-use ra_syntax::SourceFileNode;\n+use crate::{\n+    MacroCallId, HirDatabase, PerNs, ModuleId, Module, Def, Function, Struct, Enum,\n+    arena::{Arena, Id},\n+};\n \n /// hir makes a heavy use of ids: integer (u32) handlers to various things. You\n /// can think of id as a pointer (but without a lifetime) or a file descriptor\n@@ -72,3 +76,170 @@ impl From<MacroCallId> for HirFileId {\n         HirFileId(HirFileIdRepr::Macro(macro_call_id))\n     }\n }\n+\n+/// Def's are a core concept of hir. A `Def` is an Item (function, module, etc)\n+/// in a specific module.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct DefId(u32);\n+ra_db::impl_numeric_id!(DefId);\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct DefLoc {\n+    pub(crate) kind: DefKind,\n+    pub(crate) source_root_id: SourceRootId,\n+    pub(crate) module_id: ModuleId,\n+    pub(crate) source_item_id: SourceItemId,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub(crate) enum DefKind {\n+    Module,\n+    Function,\n+    Struct,\n+    Enum,\n+    Item,\n+\n+    StructCtor,\n+}\n+\n+impl DefId {\n+    pub(crate) fn loc(self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefLoc {\n+        db.as_ref().id2loc(self)\n+    }\n+\n+    pub fn resolve(self, db: &impl HirDatabase) -> Cancelable<Def> {\n+        let loc = self.loc(db);\n+        let res = match loc.kind {\n+            DefKind::Module => {\n+                let module = Module::new(db, loc.source_root_id, loc.module_id)?;\n+                Def::Module(module)\n+            }\n+            DefKind::Function => {\n+                let function = Function::new(self);\n+                Def::Function(function)\n+            }\n+            DefKind::Struct => {\n+                let struct_def = Struct::new(self);\n+                Def::Struct(struct_def)\n+            }\n+            DefKind::Enum => {\n+                let enum_def = Enum::new(self);\n+                Def::Enum(enum_def)\n+            }\n+            DefKind::StructCtor => Def::Item,\n+            DefKind::Item => Def::Item,\n+        };\n+        Ok(res)\n+    }\n+\n+    /// For a module, returns that module; for any other def, returns the containing module.\n+    pub fn module(self, db: &impl HirDatabase) -> Cancelable<Module> {\n+        let loc = self.loc(db);\n+        Module::new(db, loc.source_root_id, loc.module_id)\n+    }\n+}\n+\n+impl DefLoc {\n+    pub(crate) fn id(&self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefId {\n+        db.as_ref().loc2id(&self)\n+    }\n+}\n+\n+impl DefKind {\n+    pub(crate) fn for_syntax_kind(kind: SyntaxKind) -> PerNs<DefKind> {\n+        match kind {\n+            SyntaxKind::FN_DEF => PerNs::values(DefKind::Function),\n+            SyntaxKind::MODULE => PerNs::types(DefKind::Module),\n+            SyntaxKind::STRUCT_DEF => PerNs::both(DefKind::Struct, DefKind::StructCtor),\n+            SyntaxKind::ENUM_DEF => PerNs::types(DefKind::Enum),\n+            // These define items, but don't have their own DefKinds yet:\n+            SyntaxKind::TRAIT_DEF => PerNs::types(DefKind::Item),\n+            SyntaxKind::TYPE_DEF => PerNs::types(DefKind::Item),\n+            SyntaxKind::CONST_DEF => PerNs::values(DefKind::Item),\n+            SyntaxKind::STATIC_DEF => PerNs::values(DefKind::Item),\n+            _ => PerNs::none(),\n+        }\n+    }\n+}\n+\n+/// Identifier of item within a specific file. This is stable over reparses, so\n+/// it's OK to use it as a salsa key/value.\n+pub(crate) type SourceFileItemId = Id<SyntaxNode>;\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct SourceItemId {\n+    pub(crate) file_id: HirFileId,\n+    /// None for the whole file.\n+    pub(crate) item_id: Option<SourceFileItemId>,\n+}\n+\n+/// Maps item's `SyntaxNode`s to `SourceFileItemId` and back.\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct SourceFileItems {\n+    file_id: HirFileId,\n+    arena: Arena<SyntaxNode>,\n+}\n+\n+impl SourceFileItems {\n+    pub(crate) fn new(file_id: HirFileId, source_file: SourceFile) -> SourceFileItems {\n+        let mut res = SourceFileItems {\n+            file_id,\n+            arena: Arena::default(),\n+        };\n+        res.init(source_file);\n+        res\n+    }\n+\n+    fn init(&mut self, source_file: SourceFile) {\n+        source_file.syntax().descendants().for_each(|it| {\n+            if let Some(module_item) = ast::ModuleItem::cast(it) {\n+                self.alloc(module_item.syntax().owned());\n+            } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n+                self.alloc(macro_call.syntax().owned());\n+            }\n+        });\n+    }\n+\n+    fn alloc(&mut self, item: SyntaxNode) -> SourceFileItemId {\n+        self.arena.alloc(item)\n+    }\n+    pub(crate) fn id_of(&self, file_id: HirFileId, item: SyntaxNodeRef) -> SourceFileItemId {\n+        assert_eq!(\n+            self.file_id, file_id,\n+            \"SourceFileItems: wrong file, expected {:?}, got {:?}\",\n+            self.file_id, file_id\n+        );\n+        self.id_of_unchecked(item)\n+    }\n+    pub(crate) fn id_of_unchecked(&self, item: SyntaxNodeRef) -> SourceFileItemId {\n+        if let Some((id, _)) = self.arena.iter().find(|(_id, i)| i.borrowed() == item) {\n+            return id;\n+        }\n+        // This should not happen. Let's try to give a sensible diagnostics.\n+        if let Some((id, i)) = self.arena.iter().find(|(_id, i)| i.range() == item.range()) {\n+            // FIXME(#288): whyyy are we getting here?\n+            log::error!(\n+                \"unequal syntax nodes with the same range:\\n{:?}\\n{:?}\",\n+                item,\n+                i\n+            );\n+            return id;\n+        }\n+        panic!(\n+            \"Can't find {:?} in SourceFileItems:\\n{:?}\",\n+            item,\n+            self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n+        );\n+    }\n+    pub fn id_of_source_file(&self) -> SourceFileItemId {\n+        let (id, _syntax) = self.arena.iter().next().unwrap();\n+        id\n+    }\n+}\n+\n+impl std::ops::Index<SourceFileItemId> for SourceFileItems {\n+    type Output = SyntaxNode;\n+    fn index(&self, idx: SourceFileItemId) -> &SyntaxNode {\n+        &self.arena[idx]\n+    }\n+}"}, {"sha": "a0821d15dd2d551ae4080bce8aed0750b054a414", "filename": "crates/ra_hir/src/krate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42cc77703b041436b2507816cb394ad6fd3d07e0/crates%2Fra_hir%2Fsrc%2Fkrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42cc77703b041436b2507816cb394ad6fd3d07e0/crates%2Fra_hir%2Fsrc%2Fkrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fkrate.rs?ref=42cc77703b041436b2507816cb394ad6fd3d07e0", "patch": "@@ -1,6 +1,6 @@\n-pub use ra_db::CrateId;\n+pub use ra_db::{CrateId, Cancelable};\n \n-use crate::{HirDatabase, Module, Cancelable, Name, AsName, HirFileId};\n+use crate::{HirDatabase, Module, Name, AsName, HirFileId};\n \n /// hir::Crate describes a single crate. It's the main inteface with which\n /// crate's dependencies interact. Mostly, it should be just a proxy for the"}, {"sha": "5e939b79e1402e6e84799c1b88c35c0a461f2462", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 176, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/42cc77703b041436b2507816cb394ad6fd3d07e0/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42cc77703b041436b2507816cb394ad6fd3d07e0/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=42cc77703b041436b2507816cb394ad6fd3d07e0", "patch": "@@ -32,22 +32,17 @@ mod adt;\n mod type_ref;\n mod ty;\n \n-use std::ops::Index;\n-\n-use ra_syntax::{SyntaxNodeRef, SyntaxNode, SyntaxKind, SourceFile, AstNode, ast};\n-use ra_db::{LocationIntener, SourceRootId, FileId, Cancelable};\n-\n use crate::{\n     db::HirDatabase,\n-    arena::{Arena, Id},\n     name::{AsName, KnownName},\n+    ids::{DefKind, SourceItemId, SourceFileItemId, SourceFileItems},\n };\n \n pub use self::{\n     path::{Path, PathKind},\n     name::Name,\n     krate::Crate,\n-    ids::HirFileId,\n+    ids::{HirFileId, DefId, DefLoc},\n     macros::{MacroDef, MacroInput, MacroExpansion, MacroCallId, MacroCallLoc},\n     module::{Module, ModuleId, Problem, nameres::{ItemMap, PerNs, Namespace}, ModuleScope, Resolution},\n     function::{Function, FnScopes},\n@@ -57,179 +52,10 @@ pub use self::{\n \n pub use self::function::FnSignatureInfo;\n \n-/// Def's are a core concept of hir. A `Def` is an Item (function, module, etc)\n-/// in a specific module.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct DefId(u32);\n-ra_db::impl_numeric_id!(DefId);\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub(crate) enum DefKind {\n-    Module,\n-    Function,\n-    Struct,\n-    Enum,\n-    Item,\n-\n-    StructCtor,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct DefLoc {\n-    pub(crate) kind: DefKind,\n-    source_root_id: SourceRootId,\n-    module_id: ModuleId,\n-    source_item_id: SourceItemId,\n-}\n-\n-impl DefKind {\n-    pub(crate) fn for_syntax_kind(kind: SyntaxKind) -> PerNs<DefKind> {\n-        match kind {\n-            SyntaxKind::FN_DEF => PerNs::values(DefKind::Function),\n-            SyntaxKind::MODULE => PerNs::types(DefKind::Module),\n-            SyntaxKind::STRUCT_DEF => PerNs::both(DefKind::Struct, DefKind::StructCtor),\n-            SyntaxKind::ENUM_DEF => PerNs::types(DefKind::Enum),\n-            // These define items, but don't have their own DefKinds yet:\n-            SyntaxKind::TRAIT_DEF => PerNs::types(DefKind::Item),\n-            SyntaxKind::TYPE_DEF => PerNs::types(DefKind::Item),\n-            SyntaxKind::CONST_DEF => PerNs::values(DefKind::Item),\n-            SyntaxKind::STATIC_DEF => PerNs::values(DefKind::Item),\n-            _ => PerNs::none(),\n-        }\n-    }\n-}\n-\n-impl DefId {\n-    pub(crate) fn loc(self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefLoc {\n-        db.as_ref().id2loc(self)\n-    }\n-}\n-\n-impl DefLoc {\n-    pub(crate) fn id(&self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefId {\n-        db.as_ref().loc2id(&self)\n-    }\n-}\n-\n pub enum Def {\n     Module(Module),\n     Function(Function),\n     Struct(Struct),\n     Enum(Enum),\n     Item,\n }\n-\n-impl DefId {\n-    pub fn resolve(self, db: &impl HirDatabase) -> Cancelable<Def> {\n-        let loc = self.loc(db);\n-        let res = match loc.kind {\n-            DefKind::Module => {\n-                let module = Module::new(db, loc.source_root_id, loc.module_id)?;\n-                Def::Module(module)\n-            }\n-            DefKind::Function => {\n-                let function = Function::new(self);\n-                Def::Function(function)\n-            }\n-            DefKind::Struct => {\n-                let struct_def = Struct::new(self);\n-                Def::Struct(struct_def)\n-            }\n-            DefKind::Enum => {\n-                let enum_def = Enum::new(self);\n-                Def::Enum(enum_def)\n-            }\n-            DefKind::StructCtor => Def::Item,\n-            DefKind::Item => Def::Item,\n-        };\n-        Ok(res)\n-    }\n-\n-    /// For a module, returns that module; for any other def, returns the containing module.\n-    pub fn module(self, db: &impl HirDatabase) -> Cancelable<Module> {\n-        let loc = self.loc(db);\n-        Module::new(db, loc.source_root_id, loc.module_id)\n-    }\n-}\n-\n-/// Identifier of item within a specific file. This is stable over reparses, so\n-/// it's OK to use it as a salsa key/value.\n-pub(crate) type SourceFileItemId = Id<SyntaxNode>;\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct SourceItemId {\n-    file_id: HirFileId,\n-    /// None for the whole file.\n-    item_id: Option<SourceFileItemId>,\n-}\n-\n-/// Maps item's `SyntaxNode`s to `SourceFileItemId` and back.\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct SourceFileItems {\n-    file_id: HirFileId,\n-    arena: Arena<SyntaxNode>,\n-}\n-\n-impl SourceFileItems {\n-    fn new(file_id: HirFileId, source_file: SourceFile) -> SourceFileItems {\n-        let mut res = SourceFileItems {\n-            file_id,\n-            arena: Arena::default(),\n-        };\n-        res.init(source_file);\n-        res\n-    }\n-\n-    fn init(&mut self, source_file: SourceFile) {\n-        source_file.syntax().descendants().for_each(|it| {\n-            if let Some(module_item) = ast::ModuleItem::cast(it) {\n-                self.alloc(module_item.syntax().owned());\n-            } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n-                self.alloc(macro_call.syntax().owned());\n-            }\n-        });\n-    }\n-\n-    fn alloc(&mut self, item: SyntaxNode) -> SourceFileItemId {\n-        self.arena.alloc(item)\n-    }\n-    pub fn id_of(&self, file_id: HirFileId, item: SyntaxNodeRef) -> SourceFileItemId {\n-        assert_eq!(\n-            self.file_id, file_id,\n-            \"SourceFileItems: wrong file, expected {:?}, got {:?}\",\n-            self.file_id, file_id\n-        );\n-        self.id_of_unchecked(item)\n-    }\n-    fn id_of_unchecked(&self, item: SyntaxNodeRef) -> SourceFileItemId {\n-        if let Some((id, _)) = self.arena.iter().find(|(_id, i)| i.borrowed() == item) {\n-            return id;\n-        }\n-        // This should not happen. Let's try to give a sensible diagnostics.\n-        if let Some((id, i)) = self.arena.iter().find(|(_id, i)| i.range() == item.range()) {\n-            // FIXME(#288): whyyy are we getting here?\n-            log::error!(\n-                \"unequal syntax nodes with the same range:\\n{:?}\\n{:?}\",\n-                item,\n-                i\n-            );\n-            return id;\n-        }\n-        panic!(\n-            \"Can't find {:?} in SourceFileItems:\\n{:?}\",\n-            item,\n-            self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n-        );\n-    }\n-    pub fn id_of_source_file(&self) -> SourceFileItemId {\n-        let (id, _syntax) = self.arena.iter().next().unwrap();\n-        id\n-    }\n-}\n-\n-impl Index<SourceFileItemId> for SourceFileItems {\n-    type Output = SyntaxNode;\n-    fn index(&self, idx: SourceFileItemId) -> &SyntaxNode {\n-        &self.arena[idx]\n-    }\n-}"}, {"sha": "288fbe3c630fb2084bb6e5a30ffa12df9d838483", "filename": "crates/ra_hir/src/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42cc77703b041436b2507816cb394ad6fd3d07e0/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42cc77703b041436b2507816cb394ad6fd3d07e0/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmacros.rs?ref=42cc77703b041436b2507816cb394ad6fd3d07e0", "patch": "@@ -1,12 +1,12 @@\n use std::sync::Arc;\n \n-use ra_db::{LocalSyntaxPtr, LocationIntener};\n+use ra_db::{SourceRootId, LocalSyntaxPtr, LocationIntener};\n use ra_syntax::{\n     TextRange, TextUnit, SourceFileNode, AstNode, SyntaxNode,\n     ast::{self, NameOwner},\n };\n \n-use crate::{SourceRootId, module::ModuleId, SourceItemId, HirDatabase};\n+use crate::{module::ModuleId, SourceItemId, HirDatabase};\n \n /// Def's are a core concept of hir. A `Def` is an Item (function, module, etc)\n /// in a specific module."}, {"sha": "40aa33ffa7c939603855e6d06bde335f2826348f", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42cc77703b041436b2507816cb394ad6fd3d07e0/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42cc77703b041436b2507816cb394ad6fd3d07e0/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=42cc77703b041436b2507816cb394ad6fd3d07e0", "patch": "@@ -22,10 +22,10 @@ use ra_syntax::{\n     SyntaxKind::{self, *},\n     ast::{self, AstNode}\n };\n-use ra_db::SourceRootId;\n+use ra_db::{SourceRootId, Cancelable, FileId};\n \n use crate::{\n-    Cancelable, HirFileId, FileId,\n+    HirFileId,\n     DefId, DefLoc, DefKind,\n     SourceItemId, SourceFileItemId, SourceFileItems,\n     Path, PathKind,"}]}