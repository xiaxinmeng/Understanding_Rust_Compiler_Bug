{"sha": "803d374f9b937fcaacc9fef643a270ecaf66b878", "node_id": "C_kwDOAAsO6NoAKDgwM2QzNzRmOWI5MzdmY2FhY2M5ZmVmNjQzYTI3MGVjYWY2NmI4Nzg", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-07-28T08:49:39Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-07-28T08:49:39Z"}, "message": "Pass PatCtxt instead of passing MatchCtxt + Ty separately", "tree": {"sha": "08ab65469b379df5983022914617718d478383af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08ab65469b379df5983022914617718d478383af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/803d374f9b937fcaacc9fef643a270ecaf66b878", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/803d374f9b937fcaacc9fef643a270ecaf66b878", "html_url": "https://github.com/rust-lang/rust/commit/803d374f9b937fcaacc9fef643a270ecaf66b878", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/803d374f9b937fcaacc9fef643a270ecaf66b878/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "544de44a6b8e17c378c14137bc1d6814d88e9321", "url": "https://api.github.com/repos/rust-lang/rust/commits/544de44a6b8e17c378c14137bc1d6814d88e9321", "html_url": "https://github.com/rust-lang/rust/commit/544de44a6b8e17c378c14137bc1d6814d88e9321"}], "stats": {"total": 47, "additions": 22, "deletions": 25}, "files": [{"sha": "98eb6e170ab76f237462798b95959548851b6392", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/803d374f9b937fcaacc9fef643a270ecaf66b878/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803d374f9b937fcaacc9fef643a270ecaf66b878/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=803d374f9b937fcaacc9fef643a270ecaf66b878", "patch": "@@ -1202,35 +1202,32 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n \n     /// Creates a new list of wildcard fields for a given constructor. The result must have a\n     /// length of `constructor.arity()`.\n-    pub(super) fn wildcards(\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n-        ty: Ty<'tcx>,\n-        constructor: &Constructor<'tcx>,\n-    ) -> Self {\n+    #[instrument(level = \"trace\")]\n+    pub(super) fn wildcards(pcx: &PatCtxt<'_, 'p, 'tcx>, constructor: &Constructor<'tcx>) -> Self {\n         let ret = match constructor {\n-            Single | Variant(_) => match ty.kind() {\n-                ty::Tuple(fs) => Fields::wildcards_from_tys(cx, fs.iter()),\n-                ty::Ref(_, rty, _) => Fields::wildcards_from_tys(cx, once(*rty)),\n+            Single | Variant(_) => match pcx.ty.kind() {\n+                ty::Tuple(fs) => Fields::wildcards_from_tys(pcx.cx, fs.iter()),\n+                ty::Ref(_, rty, _) => Fields::wildcards_from_tys(pcx.cx, once(*rty)),\n                 ty::Adt(adt, substs) => {\n                     if adt.is_box() {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n                         // patterns. If we're here we can assume this is a box pattern.\n-                        Fields::wildcards_from_tys(cx, once(substs.type_at(0)))\n+                        Fields::wildcards_from_tys(pcx.cx, once(substs.type_at(0)))\n                     } else {\n                         let variant = &adt.variant(constructor.variant_index_for_adt(*adt));\n-                        let tys = Fields::list_variant_nonhidden_fields(cx, ty, variant)\n+                        let tys = Fields::list_variant_nonhidden_fields(pcx.cx, pcx.ty, variant)\n                             .map(|(_, ty)| ty);\n-                        Fields::wildcards_from_tys(cx, tys)\n+                        Fields::wildcards_from_tys(pcx.cx, tys)\n                     }\n                 }\n-                _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", ty),\n+                _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", pcx),\n             },\n-            Slice(slice) => match *ty.kind() {\n+            Slice(slice) => match *pcx.ty.kind() {\n                 ty::Slice(ty) | ty::Array(ty, _) => {\n                     let arity = slice.arity();\n-                    Fields::wildcards_from_tys(cx, (0..arity).map(|_| ty))\n+                    Fields::wildcards_from_tys(pcx.cx, (0..arity).map(|_| ty))\n                 }\n-                _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n+                _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, pcx),\n             },\n             Str(..)\n             | FloatRange(..)\n@@ -1243,7 +1240,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 bug!(\"called `Fields::wildcards` on an `Or` ctor\")\n             }\n         };\n-        debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n+        debug!(?ret);\n         ret\n     }\n \n@@ -1286,7 +1283,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n     /// For example, if `ctor` is a `Constructor::Variant` for `Option::Some`, we get the pattern\n     /// `Some(_)`.\n     pub(super) fn wild_from_ctor(pcx: &PatCtxt<'_, 'p, 'tcx>, ctor: Constructor<'tcx>) -> Self {\n-        let fields = Fields::wildcards(pcx.cx, pcx.ty, &ctor);\n+        let fields = Fields::wildcards(pcx, &ctor);\n         DeconstructedPat::new(ctor, fields, pcx.ty, DUMMY_SP)\n     }\n \n@@ -1553,13 +1550,13 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n     /// `other_ctor` can be different from `self.ctor`, but must be covered by it.\n     pub(super) fn specialize<'a>(\n         &'a self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: &PatCtxt<'_, 'p, 'tcx>,\n         other_ctor: &Constructor<'tcx>,\n     ) -> SmallVec<[&'p DeconstructedPat<'p, 'tcx>; 2]> {\n         match (&self.ctor, other_ctor) {\n             (Wildcard, _) => {\n                 // We return a wildcard for each field of `other_ctor`.\n-                Fields::wildcards(cx, self.ty, other_ctor).iter_patterns().collect()\n+                Fields::wildcards(pcx, other_ctor).iter_patterns().collect()\n             }\n             (Slice(self_slice), Slice(other_slice))\n                 if self_slice.arity() != other_slice.arity() =>\n@@ -1578,7 +1575,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                         let prefix = &self.fields.fields[..prefix];\n                         let suffix = &self.fields.fields[self_slice.arity() - suffix..];\n                         let wildcard: &_ =\n-                            cx.pattern_arena.alloc(DeconstructedPat::wildcard(inner_ty));\n+                            pcx.cx.pattern_arena.alloc(DeconstructedPat::wildcard(inner_ty));\n                         let extra_wildcards = other_slice.arity() - self_slice.arity();\n                         let extra_wildcards = (0..extra_wildcards).map(|_| wildcard);\n                         prefix.iter().chain(extra_wildcards).chain(suffix).collect()"}, {"sha": "0a660ef30c88ee333bfc4cf6fc58bc77bc0b711a", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/803d374f9b937fcaacc9fef643a270ecaf66b878/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803d374f9b937fcaacc9fef643a270ecaf66b878/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=803d374f9b937fcaacc9fef643a270ecaf66b878", "patch": "@@ -411,12 +411,12 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     /// This is roughly the inverse of `Constructor::apply`.\n     fn pop_head_constructor(\n         &self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: &PatCtxt<'_, 'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n     ) -> PatStack<'p, 'tcx> {\n         // We pop the head pattern and push the new fields extracted from the arguments of\n         // `self.head()`.\n-        let mut new_fields: SmallVec<[_; 2]> = self.head().specialize(cx, ctor);\n+        let mut new_fields: SmallVec<[_; 2]> = self.head().specialize(pcx, ctor);\n         new_fields.extend_from_slice(&self.pats[1..]);\n         PatStack::from_vec(new_fields)\n     }\n@@ -475,7 +475,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         let mut matrix = Matrix::empty();\n         for row in &self.patterns {\n             if ctor.is_covered_by(pcx, row.head().ctor()) {\n-                let new_row = row.pop_head_constructor(pcx.cx, ctor);\n+                let new_row = row.pop_head_constructor(pcx, ctor);\n                 matrix.push(new_row);\n             }\n         }\n@@ -786,7 +786,7 @@ fn is_useful<'p, 'tcx>(\n     is_under_guard: bool,\n     is_top_level: bool,\n ) -> Usefulness<'p, 'tcx> {\n-    debug!(\"matrix,v={:?}{:?}\", matrix, v);\n+    debug!(?matrix, ?v);\n     let Matrix { patterns: rows, .. } = matrix;\n \n     // The base case. We are pattern-matching on () and the return value is\n@@ -853,7 +853,7 @@ fn is_useful<'p, 'tcx>(\n             debug!(\"specialize({:?})\", ctor);\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n             let spec_matrix = start_matrix.specialize_constructor(pcx, &ctor);\n-            let v = v.pop_head_constructor(cx, &ctor);\n+            let v = v.pop_head_constructor(pcx, &ctor);\n             let usefulness = ensure_sufficient_stack(|| {\n                 is_useful(cx, &spec_matrix, &v, witness_preference, hir_id, is_under_guard, false)\n             });"}]}