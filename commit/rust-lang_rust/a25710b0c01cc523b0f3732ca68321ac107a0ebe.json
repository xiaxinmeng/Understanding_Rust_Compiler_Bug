{"sha": "a25710b0c01cc523b0f3732ca68321ac107a0ebe", "node_id": "C_kwDOAAsO6NoAKGEyNTcxMGIwYzAxY2M1MjNiMGYzNzMyY2E2ODMyMWFjMTA3YTBlYmU", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-02-21T19:00:38Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-06T17:39:08Z"}, "message": "Add `need-mut` and `unused-mut` diagnostics", "tree": {"sha": "4cded04a434bd6710d509597dcbabb9401f2d1d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cded04a434bd6710d509597dcbabb9401f2d1d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a25710b0c01cc523b0f3732ca68321ac107a0ebe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a25710b0c01cc523b0f3732ca68321ac107a0ebe", "html_url": "https://github.com/rust-lang/rust/commit/a25710b0c01cc523b0f3732ca68321ac107a0ebe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a25710b0c01cc523b0f3732ca68321ac107a0ebe/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0a0664d120609fa37aa950a11d5e6c0df176770", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0a0664d120609fa37aa950a11d5e6c0df176770", "html_url": "https://github.com/rust-lang/rust/commit/c0a0664d120609fa37aa950a11d5e6c0df176770"}], "stats": {"total": 1366, "additions": 1089, "deletions": 277}, "files": [{"sha": "c6c18490033c16792b2ad645d1c7fd938e086ce9", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=a25710b0c01cc523b0f3732ca68321ac107a0ebe", "patch": "@@ -422,6 +422,13 @@ impl Body {\n         }\n     }\n \n+    pub fn walk_child_bindings(&self, pat: PatId, f: &mut impl FnMut(BindingId)) {\n+        if let Pat::Bind { id, .. } = self[pat] {\n+            f(id)\n+        }\n+        self[pat].walk_child_pats(|p| self.walk_child_bindings(p, f));\n+    }\n+\n     pub fn pretty_print(&self, db: &dyn DefDatabase, owner: DefWithBodyId) -> String {\n         pretty::print_body_hir(db, self, owner)\n     }"}, {"sha": "0f0e68a5601088847228bde52b24cb1348969830", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=a25710b0c01cc523b0f3732ca68321ac107a0ebe", "patch": "@@ -103,6 +103,22 @@ fn references() {\n     \"#,\n         5,\n     );\n+    check_number(\n+        r#\"\n+    struct Foo(i32);\n+    impl Foo {\n+        fn method(&mut self, x: i32) {\n+            self.0 = 2 * self.0 + x;\n+        }\n+    }\n+    const GOAL: i32 = {\n+        let mut x = Foo(3);\n+        x.method(5);\n+        x.0\n+    };\n+    \"#,\n+        11,\n+    );\n }\n \n #[test]\n@@ -358,15 +374,15 @@ fn ifs() {\n         if a < b { b } else { a }\n     }\n \n-    const GOAL: u8 = max(max(1, max(10, 3)), 0-122);\n+    const GOAL: i32 = max(max(1, max(10, 3)), 0-122);\n         \"#,\n         10,\n     );\n \n     check_number(\n         r#\"\n     const fn max(a: &i32, b: &i32) -> &i32 {\n-        if a < b { b } else { a }\n+        if *a < *b { b } else { a }\n     }\n \n     const GOAL: i32 = *max(max(&1, max(&10, &3)), &5);\n@@ -464,6 +480,16 @@ fn tuples() {\n         \"#,\n         20,\n     );\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let mut a = (10, 20, 3, 15);\n+        a.1 = 2;\n+        a.0 + a.1 + a.2 + a.3\n+    };\n+        \"#,\n+        30,\n+    );\n     check_number(\n         r#\"\n     struct TupleLike(i32, u8, i64, u16);\n@@ -539,7 +565,7 @@ fn let_else() {\n         let Some(x) = x else { return 10 };\n         2 * x\n     }\n-    const GOAL: u8 = f(Some(1000)) + f(None);\n+    const GOAL: i32 = f(Some(1000)) + f(None);\n         \"#,\n         2010,\n     );\n@@ -615,7 +641,7 @@ fn options() {\n             0\n         }\n     }\n-    const GOAL: u8 = f(Some(Some(10))) + f(Some(None)) + f(None);\n+    const GOAL: i32 = f(Some(Some(10))) + f(Some(None)) + f(None);\n         \"#,\n         11,\n     );\n@@ -746,24 +772,24 @@ fn enums() {\n         r#\"\n     enum E {\n         F1 = 1,\n-        F2 = 2 * E::F1 as u8,\n-        F3 = 3 * E::F2 as u8,\n+        F2 = 2 * E::F1 as isize, // Rustc expects an isize here\n+        F3 = 3 * E::F2 as isize,\n     }\n-    const GOAL: i32 = E::F3 as u8;\n+    const GOAL: u8 = E::F3 as u8;\n     \"#,\n         6,\n     );\n     check_number(\n         r#\"\n     enum E { F1 = 1, F2, }\n-    const GOAL: i32 = E::F2 as u8;\n+    const GOAL: u8 = E::F2 as u8;\n     \"#,\n         2,\n     );\n     check_number(\n         r#\"\n     enum E { F1, }\n-    const GOAL: i32 = E::F1 as u8;\n+    const GOAL: u8 = E::F1 as u8;\n     \"#,\n         0,\n     );\n@@ -894,8 +920,22 @@ fn exec_limits() {\n         }\n         sum\n     }\n-    const GOAL: usize = f(10000);\n+    const GOAL: i32 = f(10000);\n     \"#,\n         10000 * 10000,\n     );\n }\n+\n+#[test]\n+fn type_error() {\n+    let e = eval_goal(\n+        r#\"\n+    const GOAL: u8 = {\n+        let x: u16 = 2;\n+        let y: (u8, u8) = x;\n+        y.0\n+    };\n+    \"#,\n+    );\n+    assert!(matches!(e, Err(ConstEvalError::MirLowerError(MirLowerError::TypeMismatch(_)))));\n+}"}, {"sha": "5d8a81a3ee3d6f977b352007b287ac6a5c33d461", "filename": "crates/hir-ty/src/mir.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir.rs?ref=a25710b0c01cc523b0f3732ca68321ac107a0ebe", "patch": "@@ -7,17 +7,19 @@ use crate::{\n };\n use chalk_ir::Mutability;\n use hir_def::{\n-    expr::{Expr, Ordering},\n+    expr::{BindingId, Expr, ExprId, Ordering, PatId},\n     DefWithBodyId, FieldId, UnionId, VariantId,\n };\n-use la_arena::{Arena, Idx, RawIdx};\n+use la_arena::{Arena, ArenaMap, Idx, RawIdx};\n \n mod eval;\n mod lower;\n+pub mod borrowck;\n \n pub use eval::{interpret_mir, pad16, Evaluator, MirEvalError};\n pub use lower::{lower_to_mir, mir_body_query, mir_body_recover, MirLowerError};\n use smallvec::{smallvec, SmallVec};\n+use stdx::impl_from;\n \n use super::consteval::{intern_const_scalar, try_const_usize};\n \n@@ -181,6 +183,11 @@ impl SwitchTargets {\n         iter::zip(&self.values, &self.targets).map(|(x, y)| (*x, *y))\n     }\n \n+    /// Returns a slice with all possible jump targets (including the fallback target).\n+    pub fn all_targets(&self) -> &[BasicBlockId] {\n+        &self.targets\n+    }\n+\n     /// Finds the `BasicBlock` to which this `SwitchInt` will branch given the\n     /// specific value. This cannot fail, as it'll return the `otherwise`\n     /// branch if there's not a specific match for the value.\n@@ -758,7 +765,7 @@ pub enum Rvalue {\n }\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n-pub enum Statement {\n+pub enum StatementKind {\n     Assign(Place, Rvalue),\n     //FakeRead(Box<(FakeReadCause, Place)>),\n     //SetDiscriminant {\n@@ -773,6 +780,17 @@ pub enum Statement {\n     //Intrinsic(Box<NonDivergingIntrinsic>),\n     Nop,\n }\n+impl StatementKind {\n+    fn with_span(self, span: MirSpan) -> Statement {\n+        Statement { kind: self, span }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub struct Statement {\n+    pub kind: StatementKind,\n+    pub span: MirSpan,\n+}\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct BasicBlock {\n@@ -803,10 +821,20 @@ pub struct MirBody {\n     pub start_block: BasicBlockId,\n     pub owner: DefWithBodyId,\n     pub arg_count: usize,\n+    pub binding_locals: ArenaMap<BindingId, LocalId>,\n }\n \n impl MirBody {}\n \n fn const_as_usize(c: &Const) -> usize {\n     try_const_usize(c).unwrap() as usize\n }\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+pub enum MirSpan {\n+    ExprId(ExprId),\n+    PatId(PatId),\n+    Unknown,\n+}\n+\n+impl_from!(ExprId, PatId for MirSpan);"}, {"sha": "fcf9a67fe83420d6d1ffd08ff3b1453fcb89dab2", "filename": "crates/hir-ty/src/mir/borrowck.rs", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs?ref=a25710b0c01cc523b0f3732ca68321ac107a0ebe", "patch": "@@ -0,0 +1,201 @@\n+//! MIR borrow checker, which is used in diagnostics like `unused_mut`\n+\n+// Currently it is an ad-hoc implementation, only useful for mutability analysis. Feel free to remove all of these\n+// and implement a proper borrow checker.\n+\n+use la_arena::ArenaMap;\n+use stdx::never;\n+\n+use super::{\n+    BasicBlockId, BorrowKind, LocalId, MirBody, MirSpan, Place, ProjectionElem, Rvalue,\n+    StatementKind, Terminator,\n+};\n+\n+#[derive(Debug)]\n+pub enum Mutability {\n+    Mut { span: MirSpan },\n+    Not,\n+}\n+\n+fn is_place_direct(lvalue: &Place) -> bool {\n+    !lvalue.projection.iter().any(|x| *x == ProjectionElem::Deref)\n+}\n+\n+enum ProjectionCase {\n+    /// Projection is a local\n+    Direct,\n+    /// Projection is some field or slice of a local\n+    DirectPart,\n+    /// Projection is deref of something\n+    Indirect,\n+}\n+\n+fn place_case(lvalue: &Place) -> ProjectionCase {\n+    let mut is_part_of = false;\n+    for proj in lvalue.projection.iter().rev() {\n+        match proj {\n+            ProjectionElem::Deref => return ProjectionCase::Indirect, // It's indirect\n+            ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::Subslice { .. }\n+            | ProjectionElem::Field(_)\n+            | ProjectionElem::TupleField(_)\n+            | ProjectionElem::Index(_) => {\n+                is_part_of = true;\n+            }\n+            ProjectionElem::OpaqueCast(_) => (),\n+        }\n+    }\n+    if is_part_of {\n+        ProjectionCase::DirectPart\n+    } else {\n+        ProjectionCase::Direct\n+    }\n+}\n+\n+/// Returns a map from basic blocks to the set of locals that might be ever initialized before\n+/// the start of the block. Only `StorageDead` can remove something from this map, and we ignore\n+/// `Uninit` and `drop` and similars after initialization.\n+fn ever_initialized_map(body: &MirBody) -> ArenaMap<BasicBlockId, ArenaMap<LocalId, bool>> {\n+    let mut result: ArenaMap<BasicBlockId, ArenaMap<LocalId, bool>> =\n+        body.basic_blocks.iter().map(|x| (x.0, ArenaMap::default())).collect();\n+    fn dfs(\n+        body: &MirBody,\n+        b: BasicBlockId,\n+        l: LocalId,\n+        result: &mut ArenaMap<BasicBlockId, ArenaMap<LocalId, bool>>,\n+    ) {\n+        let mut is_ever_initialized = result[b][l]; // It must be filled, as we use it as mark for dfs\n+        let block = &body.basic_blocks[b];\n+        for statement in &block.statements {\n+            match &statement.kind {\n+                StatementKind::Assign(p, _) => {\n+                    if p.projection.len() == 0 && p.local == l {\n+                        is_ever_initialized = true;\n+                    }\n+                }\n+                StatementKind::StorageDead(p) => {\n+                    if *p == l {\n+                        is_ever_initialized = false;\n+                    }\n+                }\n+                StatementKind::Deinit(_) | StatementKind::Nop | StatementKind::StorageLive(_) => (),\n+            }\n+        }\n+        let Some(terminator) = &block.terminator else {\n+            never!(\"Terminator should be none only in construction\");\n+            return;\n+        };\n+        let targets = match terminator {\n+            Terminator::Goto { target } => vec![*target],\n+            Terminator::SwitchInt { targets, .. } => targets.all_targets().to_vec(),\n+            Terminator::Resume\n+            | Terminator::Abort\n+            | Terminator::Return\n+            | Terminator::Unreachable => vec![],\n+            Terminator::Call { target, cleanup, destination, .. } => {\n+                if destination.projection.len() == 0 && destination.local == l {\n+                    is_ever_initialized = true;\n+                }\n+                target.into_iter().chain(cleanup.into_iter()).copied().collect()\n+            }\n+            Terminator::Drop { .. }\n+            | Terminator::DropAndReplace { .. }\n+            | Terminator::Assert { .. }\n+            | Terminator::Yield { .. }\n+            | Terminator::GeneratorDrop\n+            | Terminator::FalseEdge { .. }\n+            | Terminator::FalseUnwind { .. } => {\n+                never!(\"We don't emit these MIR terminators yet\");\n+                vec![]\n+            }\n+        };\n+        for target in targets {\n+            if !result[target].contains_idx(l) || !result[target][l] && is_ever_initialized {\n+                result[target].insert(l, is_ever_initialized);\n+                dfs(body, target, l, result);\n+            }\n+        }\n+    }\n+    for (b, block) in body.basic_blocks.iter() {\n+        for statement in &block.statements {\n+            if let StatementKind::Assign(p, _) = &statement.kind {\n+                if p.projection.len() == 0 {\n+                    let l = p.local;\n+                    if !result[b].contains_idx(l) {\n+                        result[b].insert(l, false);\n+                        dfs(body, b, l, &mut result);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    result\n+}\n+\n+pub fn mutability_of_locals(body: &MirBody) -> ArenaMap<LocalId, Mutability> {\n+    let mut result: ArenaMap<LocalId, Mutability> =\n+        body.locals.iter().map(|x| (x.0, Mutability::Not)).collect();\n+    let ever_init_maps = ever_initialized_map(body);\n+    for (block_id, ever_init_map) in ever_init_maps.iter() {\n+        let mut ever_init_map = ever_init_map.clone();\n+        let block = &body.basic_blocks[block_id];\n+        for statement in &block.statements {\n+            match &statement.kind {\n+                StatementKind::Assign(place, value) => {\n+                    match place_case(place) {\n+                        ProjectionCase::Direct => {\n+                            if ever_init_map.get(place.local).copied().unwrap_or_default() {\n+                                result[place.local] = Mutability::Mut { span: statement.span };\n+                            } else {\n+                                ever_init_map.insert(place.local, true);\n+                            }\n+                        }\n+                        ProjectionCase::DirectPart => {\n+                            // Partial initialization is not supported, so it is definitely `mut`\n+                            result[place.local] = Mutability::Mut { span: statement.span };\n+                        }\n+                        ProjectionCase::Indirect => (),\n+                    }\n+                    if let Rvalue::Ref(BorrowKind::Mut { .. }, p) = value {\n+                        if is_place_direct(p) {\n+                            result[p.local] = Mutability::Mut { span: statement.span };\n+                        }\n+                    }\n+                }\n+                StatementKind::StorageDead(p) => {\n+                    ever_init_map.insert(*p, false);\n+                }\n+                StatementKind::Deinit(_) | StatementKind::StorageLive(_) | StatementKind::Nop => (),\n+            }\n+        }\n+        let Some(terminator) = &block.terminator else {\n+            never!(\"Terminator should be none only in construction\");\n+            continue;\n+        };\n+        match terminator {\n+            Terminator::Goto { .. }\n+            | Terminator::Resume\n+            | Terminator::Abort\n+            | Terminator::Return\n+            | Terminator::Unreachable\n+            | Terminator::FalseEdge { .. }\n+            | Terminator::FalseUnwind { .. }\n+            | Terminator::GeneratorDrop\n+            | Terminator::SwitchInt { .. }\n+            | Terminator::Drop { .. }\n+            | Terminator::DropAndReplace { .. }\n+            | Terminator::Assert { .. }\n+            | Terminator::Yield { .. } => (),\n+            Terminator::Call { destination, .. } => {\n+                if destination.projection.len() == 0 {\n+                    if ever_init_map.get(destination.local).copied().unwrap_or_default() {\n+                        result[destination.local] = Mutability::Mut { span: MirSpan::Unknown };\n+                    } else {\n+                        ever_init_map.insert(destination.local, true);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    result\n+}"}, {"sha": "245cfdb4ddef2cbfc33172ed1cd5e40298c47403", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=a25710b0c01cc523b0f3732ca68321ac107a0ebe", "patch": "@@ -29,7 +29,7 @@ use crate::{\n \n use super::{\n     const_as_usize, return_slot, AggregateKind, BinOp, CastKind, LocalId, MirBody, MirLowerError,\n-    Operand, Place, ProjectionElem, Rvalue, Statement, Terminator, UnOp,\n+    Operand, Place, ProjectionElem, Rvalue, StatementKind, Terminator, UnOp,\n };\n \n pub struct Evaluator<'a> {\n@@ -395,7 +395,8 @@ impl Evaluator<'_> {\n                 .locals\n                 .iter()\n                 .map(|(id, x)| {\n-                    let size = self.size_of_sized(&x.ty, &locals, \"no unsized local\")?;\n+                    let size =\n+                        self.size_of_sized(&x.ty, &locals, \"no unsized local in extending stack\")?;\n                     let my_ptr = stack_ptr;\n                     stack_ptr += size;\n                     Ok((id, Stack(my_ptr)))\n@@ -425,16 +426,16 @@ impl Evaluator<'_> {\n                 return Err(MirEvalError::ExecutionLimitExceeded);\n             }\n             for statement in &current_block.statements {\n-                match statement {\n-                    Statement::Assign(l, r) => {\n+                match &statement.kind {\n+                    StatementKind::Assign(l, r) => {\n                         let addr = self.place_addr(l, &locals)?;\n                         let result = self.eval_rvalue(r, &locals)?.to_vec(&self)?;\n                         self.write_memory(addr, &result)?;\n                     }\n-                    Statement::Deinit(_) => not_supported!(\"de-init statement\"),\n-                    Statement::StorageLive(_) => not_supported!(\"storage-live statement\"),\n-                    Statement::StorageDead(_) => not_supported!(\"storage-dead statement\"),\n-                    Statement::Nop => (),\n+                    StatementKind::Deinit(_) => not_supported!(\"de-init statement\"),\n+                    StatementKind::StorageLive(_)\n+                    | StatementKind::StorageDead(_)\n+                    | StatementKind::Nop => (),\n                 }\n             }\n             let Some(terminator) = current_block.terminator.as_ref() else {"}, {"sha": "73ae5eaeeffe0b145c7934649ada278c1dcfcebe", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 430, "deletions": 248, "changes": 678, "blob_url": "https://github.com/rust-lang/rust/blob/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=a25710b0c01cc523b0f3732ca68321ac107a0ebe", "patch": "@@ -16,22 +16,23 @@ use hir_def::{\n use la_arena::ArenaMap;\n \n use crate::{\n-    consteval::ConstEvalError, db::HirDatabase, layout::layout_of_ty, mapping::ToChalk,\n-    utils::generics, Adjust, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n+    consteval::ConstEvalError, db::HirDatabase, infer::TypeMismatch,\n+    inhabitedness::is_ty_uninhabited_from, layout::layout_of_ty, mapping::ToChalk, utils::generics,\n+    Adjust, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n };\n \n use super::*;\n \n #[derive(Debug, Clone, Copy)]\n struct LoopBlocks {\n     begin: BasicBlockId,\n-    end: BasicBlockId,\n+    /// `None` for loops that are not terminating\n+    end: Option<BasicBlockId>,\n }\n \n struct MirLowerCtx<'a> {\n     result: MirBody,\n     owner: DefWithBodyId,\n-    binding_locals: ArenaMap<BindingId, LocalId>,\n     current_loop_blocks: Option<LoopBlocks>,\n     discr_temp: Option<Place>,\n     db: &'a dyn HirDatabase,\n@@ -48,11 +49,15 @@ pub enum MirLowerError {\n     UnresolvedMethod,\n     UnresolvedField,\n     MissingFunctionDefinition,\n+    TypeMismatch(TypeMismatch),\n+    /// This should be never happen. Type mismatch should catch everything.\n     TypeError(&'static str),\n     NotSupported(String),\n     ContinueWithoutLoop,\n     BreakWithoutLoop,\n     Loop,\n+    /// Something that should never happen and is definitely a bug, but we don't want to panic if it happened\n+    ImplementationError(&'static str),\n }\n \n macro_rules! not_supported {\n@@ -113,7 +118,9 @@ impl MirLowerCtx<'_> {\n                     ResolveValueResult::Partial(..) => return None,\n                 };\n                 match pr {\n-                    ValueNs::LocalBinding(pat_id) => Some(self.binding_locals[pat_id].into()),\n+                    ValueNs::LocalBinding(pat_id) => {\n+                        Some(self.result.binding_locals[pat_id].into())\n+                    }\n                     _ => None,\n                 }\n             }\n@@ -125,6 +132,11 @@ impl MirLowerCtx<'_> {\n                 }\n                 _ => None,\n             },\n+            Expr::Field { expr, .. } => {\n+                let mut r = self.lower_expr_as_place(*expr)?;\n+                self.push_field_projection(&mut r, expr_id).ok()?;\n+                Some(r)\n+            }\n             _ => None,\n         }\n     }\n@@ -133,12 +145,12 @@ impl MirLowerCtx<'_> {\n         &mut self,\n         expr_id: ExprId,\n         current: BasicBlockId,\n-    ) -> Result<(Operand, BasicBlockId)> {\n+    ) -> Result<(Operand, Option<BasicBlockId>)> {\n         if !self.has_adjustments(expr_id) {\n             match &self.body.exprs[expr_id] {\n                 Expr::Literal(l) => {\n                     let ty = self.expr_ty(expr_id);\n-                    return Ok((self.lower_literal_to_operand(ty, l)?, current));\n+                    return Ok((self.lower_literal_to_operand(ty, l)?, Some(current)));\n                 }\n                 _ => (),\n             }\n@@ -151,27 +163,44 @@ impl MirLowerCtx<'_> {\n         &mut self,\n         expr_id: ExprId,\n         prev_block: BasicBlockId,\n-    ) -> Result<(Place, BasicBlockId)> {\n+    ) -> Result<(Place, Option<BasicBlockId>)> {\n         if let Some(p) = self.lower_expr_as_place(expr_id) {\n-            return Ok((p, prev_block));\n+            return Ok((p, Some(prev_block)));\n         }\n         let ty = self.expr_ty_after_adjustments(expr_id);\n         let place = self.temp(ty)?;\n         Ok((place.into(), self.lower_expr_to_place(expr_id, place.into(), prev_block)?))\n     }\n \n+    fn lower_expr_to_some_place_without_adjust(\n+        &mut self,\n+        expr_id: ExprId,\n+        prev_block: BasicBlockId,\n+    ) -> Result<(Place, Option<BasicBlockId>)> {\n+        if let Some(p) = self.lower_expr_as_place_without_adjust(expr_id) {\n+            return Ok((p, Some(prev_block)));\n+        }\n+        let ty = self.expr_ty(expr_id);\n+        let place = self.temp(ty)?;\n+        Ok((\n+            place.into(),\n+            self.lower_expr_to_place_without_adjust(expr_id, place.into(), prev_block)?,\n+        ))\n+    }\n+\n     fn lower_expr_to_place(\n         &mut self,\n         expr_id: ExprId,\n         place: Place,\n         prev_block: BasicBlockId,\n-    ) -> Result<BasicBlockId> {\n+    ) -> Result<Option<BasicBlockId>> {\n         if let Some(x) = self.infer.expr_adjustments.get(&expr_id) {\n             if x.len() > 0 {\n-                let tmp = self.temp(self.expr_ty(expr_id))?;\n-                let current =\n-                    self.lower_expr_to_place_without_adjust(expr_id, tmp.into(), prev_block)?;\n-                let mut r = Place::from(tmp);\n+                let (mut r, Some(current)) =\n+                    self.lower_expr_to_some_place_without_adjust(expr_id, prev_block)?\n+                else {\n+                    return Ok(None);\n+                };\n                 for adjustment in x {\n                     match &adjustment.kind {\n                         Adjust::NeverToAny => (),\n@@ -185,6 +214,7 @@ impl MirLowerCtx<'_> {\n                                 current,\n                                 tmp.into(),\n                                 Rvalue::Ref(BorrowKind::from_chalk(*m), r),\n+                                expr_id.into(),\n                             );\n                             r = tmp.into();\n                         }\n@@ -199,13 +229,14 @@ impl MirLowerCtx<'_> {\n                                     Operand::Copy(r).into(),\n                                     target.clone(),\n                                 ),\n+                                expr_id.into(),\n                             );\n                             r = tmp.into();\n                         }\n                     }\n                 }\n-                self.push_assignment(current, place, Operand::Copy(r).into());\n-                return Ok(current);\n+                self.push_assignment(current, place, Operand::Copy(r).into(), expr_id.into());\n+                return Ok(Some(current));\n             }\n         }\n         self.lower_expr_to_place_without_adjust(expr_id, place, prev_block)\n@@ -216,7 +247,7 @@ impl MirLowerCtx<'_> {\n         expr_id: ExprId,\n         place: Place,\n         mut current: BasicBlockId,\n-    ) -> Result<BasicBlockId> {\n+    ) -> Result<Option<BasicBlockId>> {\n         match &self.body.exprs[expr_id] {\n             Expr::Missing => Err(MirLowerError::IncompleteExpr),\n             Expr::Path(p) => {\n@@ -235,7 +266,10 @@ impl MirLowerCtx<'_> {\n                             .0\n                             //.ok_or(ConstEvalError::SemanticError(\"unresolved assoc item\"))?\n                         {\n-                            hir_def::AssocItemId::ConstId(c) => self.lower_const(c, current, place),\n+                            hir_def::AssocItemId::ConstId(c) => {\n+                                self.lower_const(c, current, place, expr_id.into())?;\n+                                Ok(Some(current))\n+                            },\n                             _ => return Err(unresolved_name()),\n                         };\n                     }\n@@ -245,14 +279,26 @@ impl MirLowerCtx<'_> {\n                         self.push_assignment(\n                             current,\n                             place,\n-                            Operand::Copy(self.binding_locals[pat_id].into()).into(),\n+                            Operand::Copy(self.result.binding_locals[pat_id].into()).into(),\n+                            expr_id.into(),\n                         );\n-                        Ok(current)\n+                        Ok(Some(current))\n+                    }\n+                    ValueNs::ConstId(const_id) => {\n+                        self.lower_const(const_id, current, place, expr_id.into())?;\n+                        Ok(Some(current))\n                     }\n-                    ValueNs::ConstId(const_id) => self.lower_const(const_id, current, place),\n                     ValueNs::EnumVariantId(variant_id) => {\n                         let ty = self.infer.type_of_expr[expr_id].clone();\n-                        self.lower_enum_variant(variant_id, current, place, ty, vec![])\n+                        let current = self.lower_enum_variant(\n+                            variant_id,\n+                            current,\n+                            place,\n+                            ty,\n+                            vec![],\n+                            expr_id.into(),\n+                        )?;\n+                        Ok(Some(current))\n                     }\n                     ValueNs::GenericParam(p) => {\n                         let Some(def) = self.owner.as_generic_def_id() else {\n@@ -276,44 +322,46 @@ impl MirLowerCtx<'_> {\n                                 .intern(Interner),\n                             )\n                             .into(),\n+                            expr_id.into(),\n                         );\n-                        Ok(current)\n+                        Ok(Some(current))\n                     }\n                     ValueNs::StructId(_) => {\n                         // It's probably a unit struct or a zero sized function, so no action is needed.\n-                        Ok(current)\n+                        Ok(Some(current))\n                     }\n                     x => {\n                         not_supported!(\"unknown name {x:?} in value name space\");\n                     }\n                 }\n             }\n             Expr::If { condition, then_branch, else_branch } => {\n-                let (discr, current) = self.lower_expr_to_some_operand(*condition, current)?;\n+                let (discr, Some(current)) = self.lower_expr_to_some_operand(*condition, current)? else {\n+                    return Ok(None);\n+                };\n                 let start_of_then = self.new_basic_block();\n-                let end = self.new_basic_block();\n                 let end_of_then =\n                     self.lower_expr_to_place(*then_branch, place.clone(), start_of_then)?;\n-                self.set_goto(end_of_then, end);\n-                let mut start_of_else = end;\n-                if let Some(else_branch) = else_branch {\n-                    start_of_else = self.new_basic_block();\n-                    let end_of_else =\n-                        self.lower_expr_to_place(*else_branch, place, start_of_else)?;\n-                    self.set_goto(end_of_else, end);\n-                }\n+                let start_of_else = self.new_basic_block();\n+                let end_of_else = if let Some(else_branch) = else_branch {\n+                    self.lower_expr_to_place(*else_branch, place, start_of_else)?\n+                } else {\n+                    Some(start_of_else)\n+                };\n                 self.set_terminator(\n                     current,\n                     Terminator::SwitchInt {\n                         discr,\n                         targets: SwitchTargets::static_if(1, start_of_then, start_of_else),\n                     },\n                 );\n-                Ok(end)\n+                Ok(self.merge_blocks(end_of_then, end_of_else))\n             }\n             Expr::Let { pat, expr } => {\n-                let (cond_place, current) = self.lower_expr_to_some_place(*expr, current)?;\n-                let result = self.new_basic_block();\n+                self.push_storage_live(*pat, current)?;\n+                let (cond_place, Some(current)) = self.lower_expr_to_some_place(*expr, current)? else {\n+                    return Ok(None);\n+                };\n                 let (then_target, else_target) = self.pattern_match(\n                     current,\n                     None,\n@@ -322,13 +370,23 @@ impl MirLowerCtx<'_> {\n                     *pat,\n                     BindingAnnotation::Unannotated,\n                 )?;\n-                self.write_bytes_to_place(then_target, place.clone(), vec![1], TyBuilder::bool())?;\n-                self.set_goto(then_target, result);\n+                self.write_bytes_to_place(\n+                    then_target,\n+                    place.clone(),\n+                    vec![1],\n+                    TyBuilder::bool(),\n+                    MirSpan::Unknown,\n+                )?;\n                 if let Some(else_target) = else_target {\n-                    self.write_bytes_to_place(else_target, place, vec![0], TyBuilder::bool())?;\n-                    self.set_goto(else_target, result);\n+                    self.write_bytes_to_place(\n+                        else_target,\n+                        place,\n+                        vec![0],\n+                        TyBuilder::bool(),\n+                        MirSpan::Unknown,\n+                    )?;\n                 }\n-                Ok(result)\n+                Ok(self.merge_blocks(Some(then_target), else_target))\n             }\n             Expr::Unsafe { id: _, statements, tail } => {\n                 self.lower_block_to_place(None, statements, current, *tail, place)\n@@ -344,52 +402,63 @@ impl MirLowerCtx<'_> {\n                             initializer,\n                             else_branch,\n                             type_ref: _,\n-                        } => match initializer {\n-                            Some(expr_id) => {\n-                                let else_block;\n-                                let init_place;\n-                                (init_place, current) =\n-                                    self.lower_expr_to_some_place(*expr_id, current)?;\n-                                (current, else_block) = self.pattern_match(\n-                                    current,\n-                                    None,\n-                                    init_place,\n-                                    self.expr_ty_after_adjustments(*expr_id),\n-                                    *pat,\n-                                    BindingAnnotation::Unannotated,\n-                                )?;\n-                                match (else_block, else_branch) {\n-                                    (None, _) => (),\n-                                    (Some(else_block), None) => {\n-                                        self.set_terminator(else_block, Terminator::Unreachable);\n-                                    }\n-                                    (Some(else_block), Some(else_branch)) => {\n-                                        let (_, b) = self\n-                                            .lower_expr_to_some_place(*else_branch, else_block)?;\n+                        } => {\n+                            self.push_storage_live(*pat, current)?;\n+                            if let Some(expr_id) = initializer {\n+                            let else_block;\n+                            let (init_place, Some(c)) =\n+                                self.lower_expr_to_some_place(*expr_id, current)?\n+                            else {\n+                                return Ok(None);\n+                            };\n+                            current = c;\n+                            (current, else_block) = self.pattern_match(\n+                                current,\n+                                None,\n+                                init_place,\n+                                self.expr_ty_after_adjustments(*expr_id),\n+                                *pat,\n+                                BindingAnnotation::Unannotated,\n+                            )?;\n+                            match (else_block, else_branch) {\n+                                (None, _) => (),\n+                                (Some(else_block), None) => {\n+                                    self.set_terminator(else_block, Terminator::Unreachable);\n+                                }\n+                                (Some(else_block), Some(else_branch)) => {\n+                                    let (_, b) = self\n+                                        .lower_expr_to_some_place(*else_branch, else_block)?;\n+                                    if let Some(b) = b {\n                                         self.set_terminator(b, Terminator::Unreachable);\n                                     }\n                                 }\n                             }\n-                            None => continue,\n-                        },\n+                        } },\n                         hir_def::expr::Statement::Expr { expr, has_semi: _ } => {\n-                            (_, current) = self.lower_expr_to_some_place(*expr, current)?;\n+                            let (_, Some(c)) = self.lower_expr_to_some_place(*expr, current)? else {\n+                                return Ok(None);\n+                            };\n+                            current = c;\n                         }\n                     }\n                 }\n                 match tail {\n                     Some(tail) => self.lower_expr_to_place(*tail, place, current),\n-                    None => Ok(current),\n+                    None => Ok(Some(current)),\n                 }\n             }\n-            Expr::Loop { body, label } => self.lower_loop(current, *label, |this, begin, _| {\n-                let (_, block) = this.lower_expr_to_some_place(*body, begin)?;\n-                this.set_goto(block, begin);\n+            Expr::Loop { body, label } => self.lower_loop(current, *label, |this, begin| {\n+                if let (_, Some(block)) = this.lower_expr_to_some_place(*body, begin)? {\n+                    this.set_goto(block, begin);\n+                }\n                 Ok(())\n             }),\n             Expr::While { condition, body, label } => {\n-                self.lower_loop(current, *label, |this, begin, end| {\n-                    let (discr, to_switch) = this.lower_expr_to_some_operand(*condition, begin)?;\n+                self.lower_loop(current, *label, |this, begin| {\n+                    let (discr, Some(to_switch)) = this.lower_expr_to_some_operand(*condition, begin)? else {\n+                        return Ok(());\n+                    };\n+                    let end = this.current_loop_end()?;\n                     let after_cond = this.new_basic_block();\n                     this.set_terminator(\n                         to_switch,\n@@ -398,8 +467,9 @@ impl MirLowerCtx<'_> {\n                             targets: SwitchTargets::static_if(1, after_cond, end),\n                         },\n                     );\n-                    let (_, block) = this.lower_expr_to_some_place(*body, after_cond)?;\n-                    this.set_goto(block, begin);\n+                    if let (_, Some(block)) = this.lower_expr_to_some_place(*body, after_cond)? {\n+                        this.set_goto(block, begin);\n+                    }\n                     Ok(())\n                 })\n             }\n@@ -409,7 +479,7 @@ impl MirLowerCtx<'_> {\n                 match &callee_ty.data(Interner).kind {\n                     chalk_ir::TyKind::FnDef(..) => {\n                         let func = Operand::from_bytes(vec![], callee_ty.clone());\n-                        self.lower_call(func, args.iter().copied(), place, current)\n+                        self.lower_call(func, args.iter().copied(), place, current, self.is_uninhabited(expr_id))\n                     }\n                     TyKind::Scalar(_)\n                     | TyKind::Tuple(_, _)\n@@ -451,16 +521,21 @@ impl MirLowerCtx<'_> {\n                     iter::once(*receiver).chain(args.iter().copied()),\n                     place,\n                     current,\n+                    self.is_uninhabited(expr_id),\n                 )\n             }\n             Expr::Match { expr, arms } => {\n-                let (cond_place, mut current) = self.lower_expr_to_some_place(*expr, current)?;\n+                let (cond_place, Some(mut current)) = self.lower_expr_to_some_place(*expr, current)?\n+                else {\n+                    return Ok(None);\n+                };\n                 let cond_ty = self.expr_ty_after_adjustments(*expr);\n-                let end = self.new_basic_block();\n+                let mut end = None;\n                 for MatchArm { pat, guard, expr } in arms.iter() {\n                     if guard.is_some() {\n                         not_supported!(\"pattern matching with guard\");\n                     }\n+                    self.push_storage_live(*pat, current)?;\n                     let (then, otherwise) = self.pattern_match(\n                         current,\n                         None,\n@@ -469,8 +544,10 @@ impl MirLowerCtx<'_> {\n                         *pat,\n                         BindingAnnotation::Unannotated,\n                     )?;\n-                    let block = self.lower_expr_to_place(*expr, place.clone(), then)?;\n-                    self.set_goto(block, end);\n+                    if let Some(block) = self.lower_expr_to_place(*expr, place.clone(), then)? {\n+                        let r = end.get_or_insert_with(|| self.new_basic_block());\n+                        self.set_goto(block, *r);\n+                    }\n                     match otherwise {\n                         Some(o) => current = o,\n                         None => {\n@@ -491,8 +568,7 @@ impl MirLowerCtx<'_> {\n                     let loop_data =\n                         self.current_loop_blocks.ok_or(MirLowerError::ContinueWithoutLoop)?;\n                     self.set_goto(current, loop_data.begin);\n-                    let otherwise = self.new_basic_block();\n-                    Ok(otherwise)\n+                    Ok(None)\n                 }\n             },\n             Expr::Break { expr, label } => {\n@@ -502,19 +578,23 @@ impl MirLowerCtx<'_> {\n                 match label {\n                     Some(_) => not_supported!(\"break with label\"),\n                     None => {\n-                        let loop_data =\n-                            self.current_loop_blocks.ok_or(MirLowerError::BreakWithoutLoop)?;\n-                        self.set_goto(current, loop_data.end);\n-                        Ok(self.new_basic_block())\n+                        let end =\n+                            self.current_loop_end()?;\n+                        self.set_goto(current, end);\n+                        Ok(None)\n                     }\n                 }\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n-                    current = self.lower_expr_to_place(*expr, return_slot().into(), current)?;\n+                    if let Some(c) = self.lower_expr_to_place(*expr, return_slot().into(), current)? {\n+                        current = c;\n+                    } else {\n+                        return Ok(None);\n+                    }\n                 }\n                 self.set_terminator(current, Terminator::Return);\n-                Ok(self.new_basic_block())\n+                Ok(None)\n             }\n             Expr::Yield { .. } => not_supported!(\"yield\"),\n             Expr::RecordLit { fields, .. } => {\n@@ -533,8 +613,10 @@ impl MirLowerCtx<'_> {\n                         for RecordLitField { name, expr } in fields.iter() {\n                             let field_id =\n                                 variant_data.field(name).ok_or(MirLowerError::UnresolvedField)?;\n-                            let op;\n-                            (op, current) = self.lower_expr_to_some_operand(*expr, current)?;\n+                            let (op, Some(c)) = self.lower_expr_to_some_operand(*expr, current)? else {\n+                                return Ok(None);\n+                            };\n+                            current = c;\n                             operands[u32::from(field_id.into_raw()) as usize] = Some(op);\n                         }\n                         self.push_assignment(\n@@ -546,8 +628,9 @@ impl MirLowerCtx<'_> {\n                                     MirLowerError::TypeError(\"missing field in record literal\"),\n                                 )?,\n                             ),\n+                            expr_id.into(),\n                         );\n-                        Ok(current)\n+                        Ok(Some(current))\n                     }\n                     VariantId::UnionId(union_id) => {\n                         let [RecordLitField { name, expr }] = fields.as_ref() else {\n@@ -563,22 +646,18 @@ impl MirLowerCtx<'_> {\n                     }\n                 }\n             }\n-            Expr::Field { expr, name } => {\n-                let (mut current_place, current) = self.lower_expr_to_some_place(*expr, current)?;\n-                if let TyKind::Tuple(..) = self.expr_ty_after_adjustments(*expr).kind(Interner) {\n-                    let index = name\n-                        .as_tuple_index()\n-                        .ok_or(MirLowerError::TypeError(\"named field on tuple\"))?;\n-                    current_place.projection.push(ProjectionElem::TupleField(index))\n-                } else {\n-                    let field = self\n-                        .infer\n-                        .field_resolution(expr_id)\n-                        .ok_or(MirLowerError::UnresolvedField)?;\n-                    current_place.projection.push(ProjectionElem::Field(field));\n-                }\n-                self.push_assignment(current, place, Operand::Copy(current_place).into());\n-                Ok(current)\n+            Expr::Field { expr, .. } => {\n+                let (mut current_place, Some(current)) = self.lower_expr_to_some_place(*expr, current)? else {\n+                    return Ok(None);\n+                };\n+                self.push_field_projection(&mut current_place, expr_id)?;\n+                self.push_assignment(\n+                    current,\n+                    place,\n+                    Operand::Copy(current_place).into(),\n+                    expr_id.into(),\n+                );\n+                Ok(Some(current))\n             }\n             Expr::Await { .. } => not_supported!(\"await\"),\n             Expr::Try { .. } => not_supported!(\"? operator\"),\n@@ -587,40 +666,53 @@ impl MirLowerCtx<'_> {\n             Expr::Async { .. } => not_supported!(\"async block\"),\n             Expr::Const { .. } => not_supported!(\"anonymous const block\"),\n             Expr::Cast { expr, type_ref: _ } => {\n-                let (x, current) = self.lower_expr_to_some_operand(*expr, current)?;\n+                let (x, Some(current)) = self.lower_expr_to_some_operand(*expr, current)? else {\n+                    return Ok(None);\n+                };\n                 let source_ty = self.infer[*expr].clone();\n                 let target_ty = self.infer[expr_id].clone();\n                 self.push_assignment(\n                     current,\n                     place,\n                     Rvalue::Cast(cast_kind(&source_ty, &target_ty)?, x, target_ty),\n+                    expr_id.into(),\n                 );\n-                Ok(current)\n+                Ok(Some(current))\n             }\n             Expr::Ref { expr, rawness: _, mutability } => {\n-                let p;\n-                (p, current) = self.lower_expr_to_some_place(*expr, current)?;\n+                let (p, Some(current)) = self.lower_expr_to_some_place(*expr, current)? else {\n+                    return Ok(None);\n+                };\n                 let bk = BorrowKind::from_hir(*mutability);\n-                self.push_assignment(current, place, Rvalue::Ref(bk, p));\n-                Ok(current)\n+                self.push_assignment(current, place, Rvalue::Ref(bk, p), expr_id.into());\n+                Ok(Some(current))\n             }\n             Expr::Box { .. } => not_supported!(\"box expression\"),\n             Expr::UnaryOp { expr, op } => match op {\n                 hir_def::expr::UnaryOp::Deref => {\n-                    let (mut tmp, current) = self.lower_expr_to_some_place(*expr, current)?;\n+                    let (mut tmp, Some(current)) = self.lower_expr_to_some_place(*expr, current)? else {\n+                        return Ok(None);\n+                    };\n                     tmp.projection.push(ProjectionElem::Deref);\n-                    self.push_assignment(current, place, Operand::Copy(tmp).into());\n-                    Ok(current)\n-                }\n-                hir_def::expr::UnaryOp::Not => {\n-                    let (op, current) = self.lower_expr_to_some_operand(*expr, current)?;\n-                    self.push_assignment(current, place, Rvalue::UnaryOp(UnOp::Not, op));\n-                    Ok(current)\n+                    self.push_assignment(current, place, Operand::Copy(tmp).into(), expr_id.into());\n+                    Ok(Some(current))\n                 }\n-                hir_def::expr::UnaryOp::Neg => {\n-                    let (op, current) = self.lower_expr_to_some_operand(*expr, current)?;\n-                    self.push_assignment(current, place, Rvalue::UnaryOp(UnOp::Neg, op));\n-                    Ok(current)\n+                hir_def::expr::UnaryOp::Not | hir_def::expr::UnaryOp::Neg => {\n+                    let (operand, Some(current)) = self.lower_expr_to_some_operand(*expr, current)? else {\n+                        return Ok(None);\n+                    };\n+                    let operation = match op {\n+                        hir_def::expr::UnaryOp::Not => UnOp::Not,\n+                        hir_def::expr::UnaryOp::Neg => UnOp::Neg,\n+                        _ => unreachable!(),\n+                    };\n+                    self.push_assignment(\n+                        current,\n+                        place,\n+                        Rvalue::UnaryOp(operation, operand),\n+                        expr_id.into(),\n+                    );\n+                    Ok(Some(current))\n                 }\n             },\n             Expr::BinaryOp { lhs, rhs, op } => {\n@@ -632,15 +724,18 @@ impl MirLowerCtx<'_> {\n                     let Some(lhs_place) = self.lower_expr_as_place(*lhs) else {\n                         not_supported!(\"assignment to complex place\");\n                     };\n-                    let rhs_op;\n-                    (rhs_op, current) = self.lower_expr_to_some_operand(*rhs, current)?;\n-                    self.push_assignment(current, lhs_place, rhs_op.into());\n-                    return Ok(current);\n+                    let (rhs_op, Some(current)) = self.lower_expr_to_some_operand(*rhs, current)? else {\n+                        return Ok(None);\n+                    };\n+                    self.push_assignment(current, lhs_place, rhs_op.into(), expr_id.into());\n+                    return Ok(Some(current));\n                 }\n-                let lhs_op;\n-                (lhs_op, current) = self.lower_expr_to_some_operand(*lhs, current)?;\n-                let rhs_op;\n-                (rhs_op, current) = self.lower_expr_to_some_operand(*rhs, current)?;\n+                let (lhs_op, Some(current)) = self.lower_expr_to_some_operand(*lhs, current)? else {\n+                    return Ok(None);\n+                };\n+                let (rhs_op, Some(current)) = self.lower_expr_to_some_operand(*rhs, current)? else {\n+                    return Ok(None);\n+                };\n                 self.push_assignment(\n                     current,\n                     place,\n@@ -657,34 +752,44 @@ impl MirLowerCtx<'_> {\n                         lhs_op,\n                         rhs_op,\n                     ),\n+                    expr_id.into(),\n                 );\n-                Ok(current)\n+                Ok(Some(current))\n             }\n             Expr::Range { .. } => not_supported!(\"range\"),\n             Expr::Index { base, index } => {\n-                let mut p_base;\n-                (p_base, current) = self.lower_expr_to_some_place(*base, current)?;\n+                let (mut p_base, Some(current)) = self.lower_expr_to_some_place(*base, current)?  else {\n+                    return Ok(None);\n+                };\n                 let l_index = self.temp(self.expr_ty_after_adjustments(*index))?;\n-                current = self.lower_expr_to_place(*index, l_index.into(), current)?;\n+                let Some(current) = self.lower_expr_to_place(*index, l_index.into(), current)? else {\n+                    return Ok(None);\n+                };\n                 p_base.projection.push(ProjectionElem::Index(l_index));\n-                self.push_assignment(current, place, Operand::Copy(p_base).into());\n-                Ok(current)\n+                self.push_assignment(current, place, Operand::Copy(p_base).into(), expr_id.into());\n+                Ok(Some(current))\n             }\n             Expr::Closure { .. } => not_supported!(\"closure\"),\n             Expr::Tuple { exprs, is_assignee_expr: _ } => {\n-                let r = Rvalue::Aggregate(\n-                    AggregateKind::Tuple(self.expr_ty(expr_id)),\n-                    exprs\n+                let Some(values) = exprs\n                         .iter()\n                         .map(|x| {\n-                            let o;\n-                            (o, current) = self.lower_expr_to_some_operand(*x, current)?;\n-                            Ok(o)\n+                            let (o, Some(c)) = self.lower_expr_to_some_operand(*x, current)? else {\n+                                return Ok(None);\n+                            };\n+                            current = c;\n+                            Ok(Some(o))\n                         })\n-                        .collect::<Result<_>>()?,\n+                        .collect::<Result<Option<_>>>()?\n+                else {\n+                    return Ok(None);\n+                };\n+                let r = Rvalue::Aggregate(\n+                    AggregateKind::Tuple(self.expr_ty(expr_id)),\n+                    values,\n                 );\n-                self.push_assignment(current, place, r);\n-                Ok(current)\n+                self.push_assignment(current, place, r, expr_id.into());\n+                Ok(Some(current))\n             }\n             Expr::Array(l) => match l {\n                 Array::ElementList { elements, .. } => {\n@@ -696,86 +801,54 @@ impl MirLowerCtx<'_> {\n                             ))\n                         }\n                     };\n-                    let r = Rvalue::Aggregate(\n-                        AggregateKind::Array(elem_ty),\n-                        elements\n+                    let Some(values) = elements\n                             .iter()\n                             .map(|x| {\n-                                let o;\n-                                (o, current) = self.lower_expr_to_some_operand(*x, current)?;\n-                                Ok(o)\n+                                let (o, Some(c)) = self.lower_expr_to_some_operand(*x, current)? else {\n+                                    return Ok(None);\n+                                };\n+                                current = c;\n+                                Ok(Some(o))\n                             })\n-                            .collect::<Result<_>>()?,\n+                            .collect::<Result<Option<_>>>()?\n+                    else {\n+                        return Ok(None);\n+                    };\n+                    let r = Rvalue::Aggregate(\n+                        AggregateKind::Array(elem_ty),\n+                        values,\n                     );\n-                    self.push_assignment(current, place, r);\n-                    Ok(current)\n+                    self.push_assignment(current, place, r, expr_id.into());\n+                    Ok(Some(current))\n                 }\n                 Array::Repeat { .. } => not_supported!(\"array repeat\"),\n             },\n             Expr::Literal(l) => {\n                 let ty = self.expr_ty(expr_id);\n                 let op = self.lower_literal_to_operand(ty, l)?;\n-                self.push_assignment(current, place, op.into());\n-                Ok(current)\n+                self.push_assignment(current, place, op.into(), expr_id.into());\n+                Ok(Some(current))\n             }\n             Expr::Underscore => not_supported!(\"underscore\"),\n         }\n     }\n \n-    fn lower_block_to_place(\n-        &mut self,\n-        label: Option<LabelId>,\n-        statements: &[hir_def::expr::Statement],\n-        mut current: BasicBlockId,\n-        tail: Option<ExprId>,\n-        place: Place,\n-    ) -> Result<BasicBlockId> {\n-        if label.is_some() {\n-            not_supported!(\"block with label\");\n-        }\n-        for statement in statements.iter() {\n-            match statement {\n-                hir_def::expr::Statement::Let { pat, initializer, else_branch, type_ref: _ } => {\n-                    match initializer {\n-                        Some(expr_id) => {\n-                            let else_block;\n-                            let init_place;\n-                            (init_place, current) =\n-                                self.lower_expr_to_some_place(*expr_id, current)?;\n-                            (current, else_block) = self.pattern_match(\n-                                current,\n-                                None,\n-                                init_place,\n-                                self.expr_ty(*expr_id),\n-                                *pat,\n-                                BindingAnnotation::Unannotated,\n-                            )?;\n-                            match (else_block, else_branch) {\n-                                (None, _) => (),\n-                                (Some(else_block), None) => {\n-                                    self.set_terminator(else_block, Terminator::Unreachable);\n-                                }\n-                                (Some(else_block), Some(else_branch)) => {\n-                                    let (_, b) =\n-                                        self.lower_expr_to_some_place(*else_branch, else_block)?;\n-                                    self.set_terminator(b, Terminator::Unreachable);\n-                                }\n-                            }\n-                        }\n-                        None => continue,\n-                    }\n-                }\n-                hir_def::expr::Statement::Expr { expr, has_semi: _ } => {\n-                    let ty = self.expr_ty(*expr);\n-                    let temp = self.temp(ty)?;\n-                    current = self.lower_expr_to_place(*expr, temp.into(), current)?;\n-                }\n+    fn push_field_projection(&self, place: &mut Place, expr_id: ExprId) -> Result<()> {\n+        if let Expr::Field { expr, name } = &self.body[expr_id] {\n+            if let TyKind::Tuple(..) = self.expr_ty_after_adjustments(*expr).kind(Interner) {\n+                let index = name\n+                    .as_tuple_index()\n+                    .ok_or(MirLowerError::TypeError(\"named field on tuple\"))?;\n+                place.projection.push(ProjectionElem::TupleField(index))\n+            } else {\n+                let field =\n+                    self.infer.field_resolution(expr_id).ok_or(MirLowerError::UnresolvedField)?;\n+                place.projection.push(ProjectionElem::Field(field));\n             }\n+        } else {\n+            not_supported!(\"\")\n         }\n-        match tail {\n-            Some(tail) => self.lower_expr_to_place(tail, place, current),\n-            None => Ok(current),\n-        }\n+        Ok(())\n     }\n \n     fn lower_literal_to_operand(&mut self, ty: Ty, l: &Literal) -> Result<Operand> {\n@@ -824,19 +897,21 @@ impl MirLowerCtx<'_> {\n         const_id: hir_def::ConstId,\n         prev_block: BasicBlockId,\n         place: Place,\n-    ) -> Result<BasicBlockId> {\n+        span: MirSpan,\n+    ) -> Result<()> {\n         let c = self.db.const_eval(const_id)?;\n-        self.write_const_to_place(c, prev_block, place)\n+        self.write_const_to_place(c, prev_block, place, span)\n     }\n \n     fn write_const_to_place(\n         &mut self,\n         c: Const,\n         prev_block: BasicBlockId,\n         place: Place,\n-    ) -> Result<BasicBlockId> {\n-        self.push_assignment(prev_block, place, Operand::Constant(c).into());\n-        Ok(prev_block)\n+        span: MirSpan,\n+    ) -> Result<()> {\n+        self.push_assignment(prev_block, place, Operand::Constant(c).into(), span);\n+        Ok(())\n     }\n \n     fn write_bytes_to_place(\n@@ -845,9 +920,10 @@ impl MirLowerCtx<'_> {\n         place: Place,\n         cv: Vec<u8>,\n         ty: Ty,\n-    ) -> Result<BasicBlockId> {\n-        self.push_assignment(prev_block, place, Operand::from_bytes(cv, ty).into());\n-        Ok(prev_block)\n+        span: MirSpan,\n+    ) -> Result<()> {\n+        self.push_assignment(prev_block, place, Operand::from_bytes(cv, ty).into(), span);\n+        Ok(())\n     }\n \n     fn lower_enum_variant(\n@@ -857,6 +933,7 @@ impl MirLowerCtx<'_> {\n         place: Place,\n         ty: Ty,\n         fields: Vec<Operand>,\n+        span: MirSpan,\n     ) -> Result<BasicBlockId> {\n         let subst = match ty.kind(Interner) {\n             TyKind::Adt(_, subst) => subst.clone(),\n@@ -866,6 +943,7 @@ impl MirLowerCtx<'_> {\n             prev_block,\n             place,\n             Rvalue::Aggregate(AggregateKind::Adt(variant_id.into(), subst), fields),\n+            span,\n         );\n         Ok(prev_block)\n     }\n@@ -876,26 +954,29 @@ impl MirLowerCtx<'_> {\n         args: impl Iterator<Item = ExprId>,\n         place: Place,\n         mut current: BasicBlockId,\n-    ) -> Result<BasicBlockId> {\n-        let args = args\n+        is_uninhabited: bool,\n+    ) -> Result<Option<BasicBlockId>> {\n+        let Some(args) = args\n             .map(|arg| {\n-                let temp;\n-                (temp, current) = self.lower_expr_to_some_operand(arg, current)?;\n-                Ok(temp)\n+                if let (temp, Some(c)) = self.lower_expr_to_some_operand(arg, current)? {\n+                    current = c;\n+                    Ok(Some(temp))\n+                } else {\n+                    Ok(None)\n+                }\n             })\n-            .collect::<Result<Vec<_>>>()?;\n-        let b = self.result.basic_blocks.alloc(BasicBlock {\n-            statements: vec![],\n-            terminator: None,\n-            is_cleanup: false,\n-        });\n+            .collect::<Result<Option<Vec<_>>>>()?\n+        else {\n+            return Ok(None);\n+        };\n+        let b = if is_uninhabited { None } else { Some(self.new_basic_block()) };\n         self.set_terminator(\n             current,\n             Terminator::Call {\n                 func,\n                 args,\n                 destination: place,\n-                target: Some(b),\n+                target: b,\n                 cleanup: None,\n                 from_hir_call: true,\n             },\n@@ -929,8 +1010,18 @@ impl MirLowerCtx<'_> {\n         ty.unwrap_or_else(|| self.expr_ty(e))\n     }\n \n-    fn push_assignment(&mut self, block: BasicBlockId, place: Place, rvalue: Rvalue) {\n-        self.result.basic_blocks[block].statements.push(Statement::Assign(place, rvalue));\n+    fn push_statement(&mut self, block: BasicBlockId, statement: Statement) {\n+        self.result.basic_blocks[block].statements.push(statement);\n+    }\n+\n+    fn push_assignment(\n+        &mut self,\n+        block: BasicBlockId,\n+        place: Place,\n+        rvalue: Rvalue,\n+        span: MirSpan,\n+    ) {\n+        self.push_statement(block, StatementKind::Assign(place, rvalue).with_span(span));\n     }\n \n     /// It gets a `current` unterminated block, appends some statements and possibly a terminator to it to check if\n@@ -983,8 +1074,14 @@ impl MirLowerCtx<'_> {\n                 let then_target = self.new_basic_block();\n                 let mut finished = false;\n                 for pat in &**pats {\n-                    let (next, next_else) =\n-                        self.pattern_match(current, None, cond_place.clone(), cond_ty.clone(), *pat, binding_mode)?;\n+                    let (next, next_else) = self.pattern_match(\n+                        current,\n+                        None,\n+                        cond_place.clone(),\n+                        cond_ty.clone(),\n+                        *pat,\n+                        binding_mode,\n+                    )?;\n                     self.set_goto(next, then_target);\n                     match next_else {\n                         Some(t) => {\n@@ -1036,7 +1133,7 @@ impl MirLowerCtx<'_> {\n                 (then_target, Some(else_target))\n             }\n             Pat::Bind { id, subpat } => {\n-                let target_place = self.binding_locals[*id];\n+                let target_place = self.result.binding_locals[*id];\n                 let mode = self.body.bindings[*id].mode;\n                 if let Some(subpat) = subpat {\n                     (current, current_else) = self.pattern_match(\n@@ -1064,6 +1161,7 @@ impl MirLowerCtx<'_> {\n                             cond_place,\n                         ),\n                     },\n+                    pattern.into(),\n                 );\n                 (current, current_else)\n             }\n@@ -1090,6 +1188,7 @@ impl MirLowerCtx<'_> {\n                             current,\n                             tmp.clone(),\n                             Rvalue::Discriminant(cond_place.clone()),\n+                            pattern.into(),\n                         );\n                         let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n                         self.set_terminator(\n@@ -1183,23 +1282,94 @@ impl MirLowerCtx<'_> {\n         &mut self,\n         prev_block: BasicBlockId,\n         label: Option<LabelId>,\n-        f: impl FnOnce(&mut MirLowerCtx<'_>, BasicBlockId, BasicBlockId) -> Result<()>,\n-    ) -> Result<BasicBlockId> {\n+        f: impl FnOnce(&mut MirLowerCtx<'_>, BasicBlockId) -> Result<()>,\n+    ) -> Result<Option<BasicBlockId>> {\n         if label.is_some() {\n             not_supported!(\"loop with label\");\n         }\n         let begin = self.new_basic_block();\n-        let end = self.new_basic_block();\n-        let prev = mem::replace(&mut self.current_loop_blocks, Some(LoopBlocks { begin, end }));\n+        let prev =\n+            mem::replace(&mut self.current_loop_blocks, Some(LoopBlocks { begin, end: None }));\n         self.set_goto(prev_block, begin);\n-        f(self, begin, end)?;\n-        self.current_loop_blocks = prev;\n-        Ok(end)\n+        f(self, begin)?;\n+        let my = mem::replace(&mut self.current_loop_blocks, prev)\n+            .ok_or(MirLowerError::ImplementationError(\"current_loop_blocks is corrupt\"))?;\n+        Ok(my.end)\n     }\n \n     fn has_adjustments(&self, expr_id: ExprId) -> bool {\n         !self.infer.expr_adjustments.get(&expr_id).map(|x| x.is_empty()).unwrap_or(true)\n     }\n+\n+    fn merge_blocks(\n+        &mut self,\n+        b1: Option<BasicBlockId>,\n+        b2: Option<BasicBlockId>,\n+    ) -> Option<BasicBlockId> {\n+        match (b1, b2) {\n+            (None, None) => None,\n+            (None, Some(b)) | (Some(b), None) => Some(b),\n+            (Some(b1), Some(b2)) => {\n+                let bm = self.new_basic_block();\n+                self.set_goto(b1, bm);\n+                self.set_goto(b2, bm);\n+                Some(bm)\n+            }\n+        }\n+    }\n+\n+    fn current_loop_end(&mut self) -> Result<BasicBlockId> {\n+        let r = match self\n+            .current_loop_blocks\n+            .as_mut()\n+            .ok_or(MirLowerError::ImplementationError(\"Current loop access out of loop\"))?\n+            .end\n+        {\n+            Some(x) => x,\n+            None => {\n+                let s = self.new_basic_block();\n+                self.current_loop_blocks\n+                    .as_mut()\n+                    .ok_or(MirLowerError::ImplementationError(\"Current loop access out of loop\"))?\n+                    .end = Some(s);\n+                s\n+            }\n+        };\n+        Ok(r)\n+    }\n+\n+    fn is_uninhabited(&self, expr_id: ExprId) -> bool {\n+        is_ty_uninhabited_from(&self.infer[expr_id], self.owner.module(self.db.upcast()), self.db)\n+    }\n+\n+    /// This function push `StorageLive` statements for each binding in the pattern.\n+    fn push_storage_live(&mut self, pat: PatId, current: BasicBlockId) -> Result<()> {\n+        // Current implementation is wrong. It adds no `StorageDead` at the end of scope, and before each break\n+        // and continue. It just add a `StorageDead` before the `StorageLive`, which is not wrong, but unneeeded in\n+        // the proper implementation. Due this limitation, implementing a borrow checker on top of this mir will falsely\n+        // allow this:\n+        //\n+        // ```\n+        // let x;\n+        // loop {\n+        //     let y = 2;\n+        //     x = &y;\n+        //     if some_condition {\n+        //         break; // we need to add a StorageDead(y) above this to kill the x borrow\n+        //     }\n+        // }\n+        // use(x)\n+        // ```\n+        // But I think this approach work for mutability analysis, as user can't write code which mutates a binding\n+        // after StorageDead, except loops, which are handled by this hack.\n+        let span = pat.into();\n+        self.body.walk_child_bindings(pat, &mut |b| {\n+            let l = self.result.binding_locals[b];\n+            self.push_statement(current, StatementKind::StorageDead(l).with_span(span));\n+            self.push_statement(current, StatementKind::StorageLive(l).with_span(span));\n+        });\n+        Ok(())\n+    }\n }\n \n fn pattern_matching_dereference(\n@@ -1257,6 +1427,11 @@ pub fn lower_to_mir(\n     // need to take this input explicitly.\n     root_expr: ExprId,\n ) -> Result<MirBody> {\n+    if let (Some((_, x)), _) | (_, Some((_, x))) =\n+        (infer.expr_type_mismatches().next(), infer.pat_type_mismatches().next())\n+    {\n+        return Err(MirLowerError::TypeMismatch(x.clone()));\n+    }\n     let mut basic_blocks = Arena::new();\n     let start_block =\n         basic_blocks.alloc(BasicBlock { statements: vec![], terminator: None, is_cleanup: false });\n@@ -1299,21 +1474,27 @@ pub fn lower_to_mir(\n             );\n         }\n     }\n-    let mir = MirBody { basic_blocks, locals, start_block, owner, arg_count: body.params.len() };\n+    let mir = MirBody {\n+        basic_blocks,\n+        locals,\n+        start_block,\n+        binding_locals,\n+        owner,\n+        arg_count: body.params.len(),\n+    };\n     let mut ctx = MirLowerCtx {\n         result: mir,\n         db,\n         infer,\n         body,\n-        binding_locals,\n         owner,\n         current_loop_blocks: None,\n         discr_temp: None,\n     };\n     let mut current = start_block;\n     for &param in &body.params {\n         if let Pat::Bind { id, .. } = body[param] {\n-            if param_locals[param] == ctx.binding_locals[id] {\n+            if param_locals[param] == ctx.result.binding_locals[id] {\n                 continue;\n             }\n         }\n@@ -1330,7 +1511,8 @@ pub fn lower_to_mir(\n         }\n         current = r.0;\n     }\n-    let b = ctx.lower_expr_to_place(root_expr, return_slot().into(), current)?;\n-    ctx.result.basic_blocks[b].terminator = Some(Terminator::Return);\n+    if let Some(b) = ctx.lower_expr_to_place(root_expr, return_slot().into(), current)? {\n+        ctx.result.basic_blocks[b].terminator = Some(Terminator::Return);\n+    }\n     Ok(ctx.result)\n }"}, {"sha": "c257ee2ae3a414d569a84580565ef4e707298552", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=a25710b0c01cc523b0f3732ca68321ac107a0ebe", "patch": "@@ -10,7 +10,7 @@ use hir_def::path::ModPath;\n use hir_expand::{name::Name, HirFileId, InFile};\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n-use crate::{AssocItem, Field, MacroKind, Type};\n+use crate::{AssocItem, Field, Local, MacroKind, Type};\n \n macro_rules! diagnostics {\n     ($($diag:ident,)*) => {\n@@ -41,6 +41,7 @@ diagnostics![\n     MissingFields,\n     MissingMatchArms,\n     MissingUnsafe,\n+    NeedMut,\n     NoSuchField,\n     PrivateAssocItem,\n     PrivateField,\n@@ -54,6 +55,7 @@ diagnostics![\n     UnresolvedMethodCall,\n     UnresolvedModule,\n     UnresolvedProcMacro,\n+    UnusedMut,\n ];\n \n #[derive(Debug)]\n@@ -209,4 +211,15 @@ pub struct TypeMismatch {\n     pub actual: Type,\n }\n \n+#[derive(Debug)]\n+pub struct NeedMut {\n+    pub local: Local,\n+    pub span: InFile<SyntaxNodePtr>,\n+}\n+\n+#[derive(Debug)]\n+pub struct UnusedMut {\n+    pub local: Local,\n+}\n+\n pub use hir_ty::diagnostics::IncorrectCase;"}, {"sha": "4b65a93cac1b7a1d7d096c4620a981414d19776b", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=a25710b0c01cc523b0f3732ca68321ac107a0ebe", "patch": "@@ -63,7 +63,7 @@ use hir_ty::{\n     display::HexifiedConst,\n     layout::layout_of_ty,\n     method_resolution::{self, TyFingerprint},\n-    mir::interpret_mir,\n+    mir::{self, interpret_mir},\n     primitive::UintTy,\n     traits::FnTrait,\n     AliasTy, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast, ClosureId,\n@@ -85,12 +85,12 @@ use crate::db::{DefDatabase, HirDatabase};\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncorrectCase,\n-        InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n-        MissingMatchArms, MissingUnsafe, NoSuchField, PrivateAssocItem, PrivateField,\n+        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, InvalidDeriveTarget,\n+        MacroError, MalformedDerive, MismatchedArgCount, MissingFields, MissingMatchArms,\n+        MissingUnsafe, NeedMut, NoSuchField, PrivateAssocItem, PrivateField,\n         ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n-        UnresolvedExternCrate, UnresolvedField, UnresolvedImport, UnresolvedMacroCall,\n-        UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro,\n+        UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall, UnresolvedModule,\n+        UnresolvedProcMacro, UnusedMut,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -1500,6 +1500,38 @@ impl DefWithBody {\n             }\n         }\n \n+        let hir_body = db.body(self.into());\n+\n+        if let Ok(mir_body) = db.mir_body(self.into()) {\n+            let mol = mir::borrowck::mutability_of_locals(&mir_body);\n+            for (binding_id, _) in hir_body.bindings.iter() {\n+                let need_mut = &mol[mir_body.binding_locals[binding_id]];\n+                let local = Local { parent: self.into(), binding_id };\n+                match (need_mut, local.is_mut(db)) {\n+                    (mir::borrowck::Mutability::Mut { .. }, true)\n+                    | (mir::borrowck::Mutability::Not, false) => (),\n+                    (mir::borrowck::Mutability::Mut { span }, false) => {\n+                        let span: InFile<SyntaxNodePtr> = match span {\n+                            mir::MirSpan::ExprId(e) => match source_map.expr_syntax(*e) {\n+                                Ok(s) => s.map(|x| x.into()),\n+                                Err(_) => continue,\n+                            },\n+                            mir::MirSpan::PatId(p) => match source_map.pat_syntax(*p) {\n+                                Ok(s) => s.map(|x| match x {\n+                                    Either::Left(e) => e.into(),\n+                                    Either::Right(e) => e.into(),\n+                                }),\n+                                Err(_) => continue,\n+                            },\n+                            mir::MirSpan::Unknown => continue,\n+                        };\n+                        acc.push(NeedMut { local, span }.into());\n+                    }\n+                    (mir::borrowck::Mutability::Not, true) => acc.push(UnusedMut { local }.into()),\n+                }\n+            }\n+        }\n+\n         for diagnostic in BodyValidationDiagnostic::collect(db, self.into()) {\n             match diagnostic {\n                 BodyValidationDiagnostic::RecordMissingFields {\n@@ -2490,6 +2522,10 @@ impl LocalSource {\n     pub fn syntax(&self) -> &SyntaxNode {\n         self.source.value.syntax()\n     }\n+\n+    pub fn syntax_ptr(self) -> InFile<SyntaxNodePtr> {\n+        self.source.map(|x| SyntaxNodePtr::new(x.syntax()))\n+    }\n }\n \n impl Local {"}, {"sha": "a78b58fdc8027e9ebfa5d872b99fb78ad0fda354", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=a25710b0c01cc523b0f3732ca68321ac107a0ebe", "patch": "@@ -0,0 +1,302 @@\n+use crate::{Diagnostic, DiagnosticsContext, Severity};\n+\n+// Diagnostic: need-mut\n+//\n+// This diagnostic is triggered on mutating an immutable variable.\n+pub(crate) fn need_mut(ctx: &DiagnosticsContext<'_>, d: &hir::NeedMut) -> Diagnostic {\n+    Diagnostic::new(\n+        \"need-mut\",\n+        format!(\"cannot mutate immutable variable `{}`\", d.local.name(ctx.sema.db)),\n+        ctx.sema.diagnostics_display_range(d.span.clone()).range,\n+    )\n+}\n+\n+// Diagnostic: unused-mut\n+//\n+// This diagnostic is triggered when a mutable variable isn't actually mutated.\n+pub(crate) fn unused_mut(ctx: &DiagnosticsContext<'_>, d: &hir::UnusedMut) -> Diagnostic {\n+    Diagnostic::new(\n+        \"unused-mut\",\n+        \"remove this `mut`\",\n+        ctx.sema.diagnostics_display_range(d.local.primary_source(ctx.sema.db).syntax_ptr()).range,\n+    )\n+    .severity(Severity::WeakWarning)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn unused_mut_simple() {\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x = 2;\n+      //^^^^^ weak: remove this `mut`\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_false_positive_simple() {\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x = 2;\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x = 2;\n+    x = 5;\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn field_mutate() {\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x = (2, 7);\n+      //^^^^^ weak: remove this `mut`\n+    f(x.1);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x = (2, 7);\n+    x.0 = 5;\n+    f(x.1);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x = (2, 7);\n+    x.0 = 5;\n+  //^^^^^^^ error: cannot mutate immutable variable `x`\n+    f(x.1);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn mutable_reference() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let mut x = &mut 2;\n+      //^^^^^ weak: remove this `mut`\n+    *x = 5;\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let x = 2;\n+    &mut x;\n+  //^^^^^^ error: cannot mutate immutable variable `x`\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let x_own = 2;\n+    let ref mut x_ref = x_own;\n+      //^^^^^^^^^^^^^ error: cannot mutate immutable variable `x_own`\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn method(&mut self, x: i32) {}\n+}\n+fn main() {\n+    let x = Foo;\n+    x.method(2);\n+  //^ error: cannot mutate immutable variable `x`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn match_bindings() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (2, 3) {\n+        (x, mut y) => {\n+          //^^^^^ weak: remove this `mut`\n+            x = 7;\n+          //^^^^^ error: cannot mutate immutable variable `x`\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn mutation_in_dead_code() {\n+        // This one is interesting. Dead code is not represented at all in the MIR, so\n+        // there would be no mutablility error for locals in dead code. Rustc tries to\n+        // not emit `unused_mut` in this case, but since it works without `mut`, and\n+        // special casing it is not trivial, we emit it.\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    return;\n+    let mut x = 2;\n+      //^^^^^ weak: remove this `mut`\n+    &mut x;\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    loop {}\n+    let mut x = 2;\n+      //^^^^^ weak: remove this `mut`\n+    &mut x;\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+enum X {}\n+fn g() -> X {\n+    loop {}\n+}\n+fn f() -> ! {\n+    loop {}\n+}\n+fn main(b: bool) {\n+    if b {\n+        f();\n+    } else {\n+        g();\n+    }\n+    let mut x = 2;\n+      //^^^^^ weak: remove this `mut`\n+    &mut x;\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn main(b: bool) {\n+    if b {\n+        loop {}\n+    } else {\n+        return;\n+    }\n+    let mut x = 2;\n+      //^^^^^ weak: remove this `mut`\n+    &mut x;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn initialization_is_not_mutation() {\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x;\n+      //^^^^^ weak: remove this `mut`\n+    x = 5;\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main(b: bool) {\n+    let mut x;\n+      //^^^^^ weak: remove this `mut`\n+    if b {\n+        x = 1;\n+    } else {\n+        x = 3;\n+    }\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main(b: bool) {\n+    let x;\n+    if b {\n+        x = 1;\n+    }\n+    x = 3;\n+  //^^^^^ error: cannot mutate immutable variable `x`\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x;\n+    loop {\n+        x = 1;\n+      //^^^^^ error: cannot mutate immutable variable `x`\n+        f(x);\n+    }\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    loop {\n+        let mut x = 1;\n+          //^^^^^ weak: remove this `mut`\n+        f(x);\n+        if let mut y = 2 {\n+             //^^^^^ weak: remove this `mut`\n+            f(y);\n+        }\n+        match 3 {\n+            mut z => f(z),\n+          //^^^^^ weak: remove this `mut`\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "f6c9b79c30c3cf31f101cda55a4b80046eb84149", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25710b0c01cc523b0f3732ca68321ac107a0ebe/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=a25710b0c01cc523b0f3732ca68321ac107a0ebe", "patch": "@@ -37,6 +37,7 @@ mod handlers {\n     pub(crate) mod missing_fields;\n     pub(crate) mod missing_match_arms;\n     pub(crate) mod missing_unsafe;\n+    pub(crate) mod mutability_errors;\n     pub(crate) mod no_such_field;\n     pub(crate) mod private_assoc_item;\n     pub(crate) mod private_field;\n@@ -273,7 +274,8 @@ pub fn diagnostics(\n             AnyDiagnostic::InvalidDeriveTarget(d) => handlers::invalid_derive_target::invalid_derive_target(&ctx, &d),\n             AnyDiagnostic::UnresolvedField(d) => handlers::unresolved_field::unresolved_field(&ctx, &d),\n             AnyDiagnostic::UnresolvedMethodCall(d) => handlers::unresolved_method::unresolved_method(&ctx, &d),\n-\n+            AnyDiagnostic::NeedMut(d) => handlers::mutability_errors::need_mut(&ctx, &d),\n+            AnyDiagnostic::UnusedMut(d) => handlers::mutability_errors::unused_mut(&ctx, &d),\n             AnyDiagnostic::InactiveCode(d) => match handlers::inactive_code::inactive_code(&ctx, &d) {\n                 Some(it) => it,\n                 None => continue,"}]}