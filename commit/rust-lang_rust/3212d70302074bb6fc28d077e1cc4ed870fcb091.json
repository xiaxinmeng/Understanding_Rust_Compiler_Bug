{"sha": "3212d70302074bb6fc28d077e1cc4ed870fcb091", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMTJkNzAzMDIwNzRiYjZmYzI4ZDA3N2UxY2M0ZWQ4NzBmY2IwOTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-16T04:56:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-16T04:56:01Z"}, "message": "auto merge of #17280 : thestinger/rust/heap, r=pcwalton", "tree": {"sha": "8178edf24aa3f7310c40fb5523abe571f0d68537", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8178edf24aa3f7310c40fb5523abe571f0d68537"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3212d70302074bb6fc28d077e1cc4ed870fcb091", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3212d70302074bb6fc28d077e1cc4ed870fcb091", "html_url": "https://github.com/rust-lang/rust/commit/3212d70302074bb6fc28d077e1cc4ed870fcb091", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3212d70302074bb6fc28d077e1cc4ed870fcb091/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8426e2e21f1baa0cbb9775eeef1061773103a28", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8426e2e21f1baa0cbb9775eeef1061773103a28", "html_url": "https://github.com/rust-lang/rust/commit/f8426e2e21f1baa0cbb9775eeef1061773103a28"}, {"sha": "d206f05132566a4ae1974e7a3d892ab5788616cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d206f05132566a4ae1974e7a3d892ab5788616cd", "html_url": "https://github.com/rust-lang/rust/commit/d206f05132566a4ae1974e7a3d892ab5788616cd"}], "stats": {"total": 80, "additions": 25, "deletions": 55}, "files": [{"sha": "f1780b07271ec93d563c7eeca601229fffcf2b70", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 7, "deletions": 24, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3212d70302074bb6fc28d077e1cc4ed870fcb091/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3212d70302074bb6fc28d077e1cc4ed870fcb091/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=3212d70302074bb6fc28d077e1cc4ed870fcb091", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME: #13994: port to the sized deallocation API when available\n // FIXME: #13996: mark the `allocate` and `reallocate` return value as `noalias`\n-//                and `nonnull`\n \n-#[cfg(not(test))] use core::raw;\n+#[cfg(stage0, not(test))] use core::raw;\n #[cfg(stage0, not(test))] use util;\n \n /// Returns a pointer to `size` bytes of memory.\n@@ -88,18 +86,19 @@ pub fn stats_print() {\n     imp::stats_print();\n }\n \n-// The compiler never calls `exchange_free` on Box<ZeroSizeType>, so zero-size\n-// allocations can point to this `static`. It would be incorrect to use a null\n-// pointer, due to enums assuming types like unique pointers are never null.\n-pub static mut EMPTY: uint = 12345;\n+/// An arbitrary non-null address to represent zero-size allocations.\n+///\n+/// This preserves the non-null invariant for types like `Box<T>`. The address may overlap with\n+/// non-zero-size memory allocations.\n+pub static EMPTY: *mut () = 0x1 as *mut ();\n \n /// The allocator for unique pointers.\n #[cfg(not(test))]\n #[lang=\"exchange_malloc\"]\n #[inline]\n unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n     if size == 0 {\n-        &EMPTY as *const uint as *mut u8\n+        EMPTY as *mut u8\n     } else {\n         allocate(size, align)\n     }\n@@ -112,7 +111,6 @@ unsafe fn exchange_free(ptr: *mut u8, size: uint, align: uint) {\n     deallocate(ptr, size, align);\n }\n \n-// FIXME: #7496\n #[cfg(stage0, not(test))]\n #[lang=\"closure_exchange_malloc\"]\n #[inline]\n@@ -128,21 +126,6 @@ unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint,\n     alloc as *mut u8\n }\n \n-// FIXME: #7496\n-#[cfg(not(stage0), not(test))]\n-#[lang=\"closure_exchange_malloc\"]\n-#[inline]\n-#[allow(deprecated)]\n-unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint,\n-                                  align: uint) -> *mut u8 {\n-    let p = allocate(size, align);\n-\n-    let alloc = p as *mut raw::Box<()>;\n-    (*alloc).drop_glue = drop_glue;\n-\n-    alloc as *mut u8\n-}\n-\n // The minimum alignment guaranteed by the architecture. This value is used to\n // add fast paths for low alignment values. In practice, the alignment is a\n // constant at the call site and the branch will be optimized out."}, {"sha": "c933690b58fd8aa19831a988a471b0d468ab4a2b", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3212d70302074bb6fc28d077e1cc4ed870fcb091/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3212d70302074bb6fc28d077e1cc4ed870fcb091/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=3212d70302074bb6fc28d077e1cc4ed870fcb091", "patch": "@@ -14,7 +14,7 @@\n \n use core::prelude::*;\n \n-use alloc::heap::{allocate, reallocate, deallocate};\n+use alloc::heap::{EMPTY, allocate, reallocate, deallocate};\n use core::cmp::max;\n use core::default::Default;\n use core::fmt;\n@@ -28,10 +28,6 @@ use {Mutable, MutableSeq};\n use slice::{MutableOrdSlice, MutableSliceAllocating, CloneableVector};\n use slice::{Items, MutItems};\n \n-\n-#[doc(hidden)]\n-pub static PTR_MARKER: u8 = 0;\n-\n /// An owned, growable vector.\n ///\n /// # Examples\n@@ -124,7 +120,7 @@ impl<T> Vec<T> {\n         // non-null value which is fine since we never call deallocate on the ptr\n         // if cap is 0. The reason for this is because the pointer of a slice\n         // being NULL would break the null pointer optimization for enums.\n-        Vec { len: 0, cap: 0, ptr: &PTR_MARKER as *const _ as *mut T }\n+        Vec { len: 0, cap: 0, ptr: EMPTY as *mut T }\n     }\n \n     /// Constructs a new, empty `Vec` with the specified capacity.\n@@ -157,7 +153,7 @@ impl<T> Vec<T> {\n     #[inline]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n-            Vec { len: 0, cap: uint::MAX, ptr: &PTR_MARKER as *const _ as *mut T }\n+            Vec { len: 0, cap: uint::MAX, ptr: EMPTY as *mut T }\n         } else if capacity == 0 {\n             Vec::new()\n         } else {"}, {"sha": "507ba3e9d5bf6132f1014718b3d47b8750c309d3", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3212d70302074bb6fc28d077e1cc4ed870fcb091/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3212d70302074bb6fc28d077e1cc4ed870fcb091/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=3212d70302074bb6fc28d077e1cc4ed870fcb091", "patch": "@@ -265,7 +265,6 @@ lets_do_this! {\n     BeginUnwindLangItem,             \"begin_unwind\",            begin_unwind;\n \n     ExchangeMallocFnLangItem,        \"exchange_malloc\",         exchange_malloc_fn;\n-    ClosureExchangeMallocFnLangItem, \"closure_exchange_malloc\", closure_exchange_malloc_fn;\n     ExchangeFreeFnLangItem,          \"exchange_free\",           exchange_free_fn;\n     MallocFnLangItem,                \"malloc\",                  malloc_fn;\n     FreeFnLangItem,                  \"free\",                    free_fn;"}, {"sha": "5187ecb8b3bc8ca47d0d8f8f137e295a9a2701ff", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3212d70302074bb6fc28d077e1cc4ed870fcb091/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3212d70302074bb6fc28d077e1cc4ed870fcb091/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3212d70302074bb6fc28d077e1cc4ed870fcb091", "patch": "@@ -383,14 +383,10 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n \n-pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                       t: ty::t, alloc_fn: LangItem)\n-                                       -> Result<'blk, 'tcx> {\n+pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: ty::t) -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"malloc_raw_dyn_proc\");\n     let ccx = bcx.ccx();\n \n-    let langcall = require_alloc_fn(bcx, t, alloc_fn);\n-\n     // Grab the TypeRef type of ptr_ty.\n     let ptr_ty = ty::mk_uniq(bcx.tcx(), t);\n     let ptr_llty = type_of(ccx, ptr_ty);\n@@ -399,18 +395,15 @@ pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let size = llsize_of(bcx.ccx(), llty);\n     let llalign = C_uint(ccx, llalign_of_min(bcx.ccx(), llty) as uint);\n \n-    // Allocate space:\n-    let drop_glue = glue::get_drop_glue(ccx, ty::mk_uniq(bcx.tcx(), t));\n-    let r = callee::trans_lang_call(\n-        bcx,\n-        langcall,\n-        [\n-            PointerCast(bcx, drop_glue, Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to()),\n-            size,\n-            llalign\n-        ],\n-        None);\n-    Result::new(r.bcx, PointerCast(r.bcx, r.val, ptr_llty))\n+    // Allocate space and store the destructor pointer:\n+    let Result {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, ptr_llty, t, size, llalign);\n+    let dtor_ptr = GEPi(bcx, llbox, [0u, abi::box_field_drop_glue]);\n+    let drop_glue_field_ty = type_of(ccx, ty::mk_nil_ptr(bcx.tcx()));\n+    let drop_glue = PointerCast(bcx, glue::get_drop_glue(ccx, ty::mk_uniq(bcx.tcx(), t)),\n+                                drop_glue_field_ty);\n+    Store(bcx, drop_glue, dtor_ptr);\n+\n+    Result::new(bcx, llbox)\n }\n \n "}, {"sha": "2fac6e80ba085b83b8649b72ec7b4d77a4ec9501", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3212d70302074bb6fc28d077e1cc4ed870fcb091/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3212d70302074bb6fc28d077e1cc4ed870fcb091/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=3212d70302074bb6fc28d077e1cc4ed870fcb091", "patch": "@@ -15,7 +15,6 @@ use driver::config::FullDebugInfo;\n use llvm::ValueRef;\n use middle::def;\n use middle::freevars;\n-use middle::lang_items::ClosureExchangeMallocFnLangItem;\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -146,7 +145,7 @@ fn allocate_cbox<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n     match store {\n         ty::UniqTraitStore => {\n-            malloc_raw_dyn_proc(bcx, cbox_ty, ClosureExchangeMallocFnLangItem)\n+            malloc_raw_dyn_proc(bcx, cbox_ty)\n         }\n         ty::RegionTraitStore(..) => {\n             let llbox = alloc_ty(bcx, cbox_ty, \"__closure\");"}, {"sha": "fa2b192615d878990dfdf1c40ca54ec1085668df", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3212d70302074bb6fc28d077e1cc4ed870fcb091/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3212d70302074bb6fc28d077e1cc4ed870fcb091/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=3212d70302074bb6fc28d077e1cc4ed870fcb091", "patch": "@@ -519,7 +519,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: ty::t)\n             let env_ptr_ty = Type::at_box(bcx.ccx(), Type::i8(bcx.ccx())).ptr_to();\n             let env = PointerCast(bcx, env, env_ptr_ty);\n             with_cond(bcx, IsNotNull(bcx, env), |bcx| {\n-                let dtor_ptr = GEPi(bcx, env, [0u, abi::box_field_tydesc]);\n+                let dtor_ptr = GEPi(bcx, env, [0u, abi::box_field_drop_glue]);\n                 let dtor = Load(bcx, dtor_ptr);\n                 Call(bcx, dtor, [PointerCast(bcx, box_cell_v, Type::i8p(bcx.ccx()))], None);\n                 bcx"}, {"sha": "72acba542460cc94280db8c246f5ddcf3ac75c69", "filename": "src/librustc_back/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3212d70302074bb6fc28d077e1cc4ed870fcb091/src%2Flibrustc_back%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3212d70302074bb6fc28d077e1cc4ed870fcb091/src%2Flibrustc_back%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fabi.rs?ref=3212d70302074bb6fc28d077e1cc4ed870fcb091", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub static box_field_refcnt: uint = 0u;\n-pub static box_field_tydesc: uint = 1u;\n+pub static box_field_drop_glue: uint = 1u;\n pub static box_field_body: uint = 4u;\n \n pub static tydesc_field_visit_glue: uint = 3u;"}, {"sha": "33482ec0eb35952e58be0c4669963b689e3aabb3", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3212d70302074bb6fc28d077e1cc4ed870fcb091/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3212d70302074bb6fc28d077e1cc4ed870fcb091/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=3212d70302074bb6fc28d077e1cc4ed870fcb091", "patch": "@@ -12,6 +12,7 @@ use std::fmt;\n use std::default::Default;\n use std::hash;\n use std::{mem, raw, ptr, slice, vec};\n+use std::rt::heap::EMPTY;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// A non-growable owned slice. This would preferably become `~[T]`\n@@ -81,10 +82,9 @@ impl<T> OwnedSlice<T> {\n     }\n \n     pub fn as_slice<'a>(&'a self) -> &'a [T] {\n-        static PTR_MARKER: u8 = 0;\n         let ptr = if self.data.is_null() {\n             // length zero, i.e. this will never be read as a T.\n-            &PTR_MARKER as *const u8 as *const T\n+            EMPTY as *const T\n         } else {\n             self.data as *const T\n         };"}]}