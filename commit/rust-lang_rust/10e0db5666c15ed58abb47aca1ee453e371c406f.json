{"sha": "10e0db5666c15ed58abb47aca1ee453e371c406f", "node_id": "C_kwDOAAsO6NoAKDEwZTBkYjU2NjZjMTVlZDU4YWJiNDdhY2ExZWU0NTNlMzcxYzQwNmY", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-16T17:42:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-16T17:42:07Z"}, "message": "Rollup merge of #96118 - GuillaumeGomez:cleanup-def-id-item-id, r=notriddle\n\nrustdoc: Rename `def_id` into `item_id` when the type is `ItemId` for readability\n\nAs `@notriddle` mentioned in https://github.com/rust-lang/rust/pull/96091, the field name is inaccurate. This PR fixes it by renaming it accordingly to its real type.\n\nr? `@notriddle`", "tree": {"sha": "f42addbbdb1c482fd6556716a785dc46f10b7ab1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f42addbbdb1c482fd6556716a785dc46f10b7ab1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10e0db5666c15ed58abb47aca1ee453e371c406f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiWv/vCRBK7hj4Ov3rIwAAw9UIAIaWxP+lAOvY8x2CSFaD5L9p\nlnuoeEUDHSIdRrsWRvVoHZeXceDY2r0aectqaOrl6BDajIGasjezZl7ydxeeHW7y\nZurU4KhUm1ZJAZmgIPAu8BTC54PE9cWtWjeoCVT57PqwyX6QsN7KHubSAYimisge\nojJ22DGqlYSKvhu/0A8k8E1rxCYrlJre6R4/q3QVrwdGGY1jEpYJF/4Zbjhcb2m3\nMfZ6eujmoUgLsLkb8qF9MxOYw4JWTpFySlqSDpJE8oAeICf8H6ng29gx3dmCgHsV\n0wf7Ql2A4vpi7N+j6Bd5jIWJs4IMUgt7yOVIfCVBJezgbYGT5p/tR4pl9QhNY0g=\n=06Co\n-----END PGP SIGNATURE-----\n", "payload": "tree f42addbbdb1c482fd6556716a785dc46f10b7ab1\nparent 5d98ce6f83dfa0369d5239969c0a494d4471405d\nparent b1e6211c5ccb606a8a470a3e6c4290843542e3cb\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1650130927 +0200\ncommitter GitHub <noreply@github.com> 1650130927 +0200\n\nRollup merge of #96118 - GuillaumeGomez:cleanup-def-id-item-id, r=notriddle\n\nrustdoc: Rename `def_id` into `item_id` when the type is `ItemId` for readability\n\nAs `@notriddle` mentioned in https://github.com/rust-lang/rust/pull/96091, the field name is inaccurate. This PR fixes it by renaming it accordingly to its real type.\n\nr? `@notriddle`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10e0db5666c15ed58abb47aca1ee453e371c406f", "html_url": "https://github.com/rust-lang/rust/commit/10e0db5666c15ed58abb47aca1ee453e371c406f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10e0db5666c15ed58abb47aca1ee453e371c406f/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d98ce6f83dfa0369d5239969c0a494d4471405d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d98ce6f83dfa0369d5239969c0a494d4471405d", "html_url": "https://github.com/rust-lang/rust/commit/5d98ce6f83dfa0369d5239969c0a494d4471405d"}, {"sha": "b1e6211c5ccb606a8a470a3e6c4290843542e3cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1e6211c5ccb606a8a470a3e6c4290843542e3cb", "html_url": "https://github.com/rust-lang/rust/commit/b1e6211c5ccb606a8a470a3e6c4290843542e3cb"}], "stats": {"total": 241, "additions": 121, "deletions": 120}, "files": [{"sha": "fffd94992093b22d9cb1a20555bc90efb98ee13d", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -116,7 +116,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             name: None,\n             attrs: Default::default(),\n             visibility: Inherited,\n-            def_id: ItemId::Auto { trait_: trait_def_id, for_: item_def_id },\n+            item_id: ItemId::Auto { trait_: trait_def_id, for_: item_def_id },\n             kind: box ImplItem(Impl {\n                 unsafety: hir::Unsafety::Normal,\n                 generics: new_generics,"}, {"sha": "f0d87f7ce4cd582908f9a7211ea4b520f5fff928", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                         name: None,\n                         attrs: Default::default(),\n                         visibility: Inherited,\n-                        def_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n+                        item_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n                         kind: box ImplItem(Impl {\n                             unsafety: hir::Unsafety::Normal,\n                             generics: clean_ty_generics("}, {"sha": "261eb39bf723d3aaf22da9a1c3238fe3dab8dbdf", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -534,7 +534,7 @@ fn build_module(\n                 items.push(clean::Item {\n                     name: None,\n                     attrs: box clean::Attributes::default(),\n-                    def_id: ItemId::Primitive(prim_ty, did.krate),\n+                    item_id: ItemId::Primitive(prim_ty, did.krate),\n                     visibility: clean::Public,\n                     kind: box clean::ImportItem(clean::Import::new_simple(\n                         item.ident.name,"}, {"sha": "21016afbf5f99369e253d179dede250e40882a7d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -2009,7 +2009,7 @@ fn clean_extern_crate(\n     vec![Item {\n         name: Some(name),\n         attrs: box attrs.clean(cx),\n-        def_id: crate_def_id.into(),\n+        item_id: crate_def_id.into(),\n         visibility: ty_vis.clean(cx),\n         kind: box ExternCrateItem { src: orig_name },\n         cfg: attrs.cfg(cx.tcx, &cx.cache.hidden_cfg),"}, {"sha": "4b473df155f588c925defb7a20d5062ef77d00d4", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -366,7 +366,7 @@ crate struct Item {\n     /// Information about this item that is specific to what kind of item it is.\n     /// E.g., struct vs enum vs function.\n     crate kind: Box<ItemKind>,\n-    crate def_id: ItemId,\n+    crate item_id: ItemId,\n \n     crate cfg: Option<Arc<Cfg>>,\n }\n@@ -380,7 +380,7 @@ impl fmt::Debug for Item {\n         let mut fmt = f.debug_struct(\"Item\");\n         fmt.field(\"name\", &self.name)\n             .field(\"visibility\", &self.visibility)\n-            .field(\"def_id\", &self.def_id);\n+            .field(\"item_id\", &self.item_id);\n         // allow printing the full item if someone really wants to\n         if alternate {\n             fmt.field(\"attrs\", &self.attrs).field(\"kind\", &self.kind).field(\"cfg\", &self.cfg);\n@@ -408,19 +408,19 @@ crate fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n \n impl Item {\n     crate fn stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<Stability> {\n-        self.def_id.as_def_id().and_then(|did| tcx.lookup_stability(did))\n+        self.item_id.as_def_id().and_then(|did| tcx.lookup_stability(did))\n     }\n \n     crate fn const_stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<ConstStability> {\n-        self.def_id.as_def_id().and_then(|did| tcx.lookup_const_stability(did))\n+        self.item_id.as_def_id().and_then(|did| tcx.lookup_const_stability(did))\n     }\n \n     crate fn deprecation(&self, tcx: TyCtxt<'_>) -> Option<Deprecation> {\n-        self.def_id.as_def_id().and_then(|did| tcx.lookup_deprecation(did))\n+        self.item_id.as_def_id().and_then(|did| tcx.lookup_deprecation(did))\n     }\n \n     crate fn inner_docs(&self, tcx: TyCtxt<'_>) -> bool {\n-        self.def_id.as_def_id().map(|did| tcx.get_attrs(did).inner_docs()).unwrap_or(false)\n+        self.item_id.as_def_id().map(|did| tcx.get_attrs(did).inner_docs()).unwrap_or(false)\n     }\n \n     crate fn span(&self, tcx: TyCtxt<'_>) -> Span {\n@@ -432,14 +432,14 @@ impl Item {\n             ItemKind::ModuleItem(Module { span, .. }) => *span,\n             ItemKind::ImplItem(Impl { kind: ImplKind::Auto, .. }) => Span::dummy(),\n             ItemKind::ImplItem(Impl { kind: ImplKind::Blanket(_), .. }) => {\n-                if let ItemId::Blanket { impl_id, .. } = self.def_id {\n+                if let ItemId::Blanket { impl_id, .. } = self.item_id {\n                     rustc_span(impl_id, tcx)\n                 } else {\n                     panic!(\"blanket impl item has non-blanket ID\")\n                 }\n             }\n             _ => {\n-                self.def_id.as_def_id().map(|did| rustc_span(did, tcx)).unwrap_or_else(Span::dummy)\n+                self.item_id.as_def_id().map(|did| rustc_span(did, tcx)).unwrap_or_else(Span::dummy)\n             }\n         }\n     }\n@@ -503,7 +503,7 @@ impl Item {\n             cx.tcx.visibility(def_id).clean(cx)\n         };\n \n-        Item { def_id: def_id.into(), kind: box kind, name, attrs, visibility, cfg }\n+        Item { item_id: def_id.into(), kind: box kind, name, attrs, visibility, cfg }\n     }\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n@@ -517,7 +517,7 @@ impl Item {\n \n         cx.cache()\n             .intra_doc_links\n-            .get(&self.def_id)\n+            .get(&self.item_id)\n             .map_or(&[][..], |v| v.as_slice())\n             .iter()\n             .filter_map(|ItemLink { link: s, link_text, did, ref fragment }| {\n@@ -547,7 +547,7 @@ impl Item {\n     crate fn link_names(&self, cache: &Cache) -> Vec<RenderedLink> {\n         cache\n             .intra_doc_links\n-            .get(&self.def_id)\n+            .get(&self.item_id)\n             .map_or(&[][..], |v| v.as_slice())\n             .iter()\n             .map(|ItemLink { link: s, link_text, .. }| RenderedLink {\n@@ -559,7 +559,7 @@ impl Item {\n     }\n \n     crate fn is_crate(&self) -> bool {\n-        self.is_mod() && self.def_id.as_def_id().map_or(false, |did| did.index == CRATE_DEF_INDEX)\n+        self.is_mod() && self.item_id.as_def_id().map_or(false, |did| did.index == CRATE_DEF_INDEX)\n     }\n     crate fn is_mod(&self) -> bool {\n         self.type_() == ItemType::Module\n@@ -695,7 +695,7 @@ impl Item {\n         }\n         let header = match *self.kind {\n             ItemKind::ForeignFunctionItem(_) => {\n-                let abi = tcx.fn_sig(self.def_id.as_def_id().unwrap()).abi();\n+                let abi = tcx.fn_sig(self.item_id.as_def_id().unwrap()).abi();\n                 hir::FnHeader {\n                     unsafety: if abi == Abi::RustIntrinsic {\n                         intrinsic_operation_unsafety(self.name.unwrap())\n@@ -708,11 +708,11 @@ impl Item {\n                 }\n             }\n             ItemKind::FunctionItem(_) | ItemKind::MethodItem(_, _) => {\n-                let def_id = self.def_id.as_def_id().unwrap();\n+                let def_id = self.item_id.as_def_id().unwrap();\n                 build_fn_header(def_id, tcx, tcx.asyncness(def_id))\n             }\n             ItemKind::TyMethodItem(_) => {\n-                build_fn_header(self.def_id.as_def_id().unwrap(), tcx, hir::IsAsync::NotAsync)\n+                build_fn_header(self.item_id.as_def_id().unwrap(), tcx, hir::IsAsync::NotAsync)\n             }\n             _ => return None,\n         };"}, {"sha": "abfc5b80a3ef0f8bda47c6216c36db0557fcd67c", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -44,9 +44,9 @@ crate fn krate(cx: &mut DocContext<'_>) -> Crate {\n                 // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n                 if it.is_extern_crate()\n                     && (it.attrs.has_doc_flag(sym::masked)\n-                        || cx.tcx.is_compiler_builtins(it.def_id.krate()))\n+                        || cx.tcx.is_compiler_builtins(it.item_id.krate()))\n                 {\n-                    cx.cache.masked_crates.insert(it.def_id.krate());\n+                    cx.cache.masked_crates.insert(it.item_id.krate());\n                 }\n             }\n         }"}, {"sha": "b9e20c41b681fbcde73f99685551116dff064070", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -113,8 +113,8 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Like `hir().local_def_id_to_hir_id()`, but skips calling it on fake DefIds.\n     /// (This avoids a slice-index-out-of-bounds panic.)\n-    crate fn as_local_hir_id(tcx: TyCtxt<'_>, def_id: ItemId) -> Option<HirId> {\n-        match def_id {\n+    crate fn as_local_hir_id(tcx: TyCtxt<'_>, item_id: ItemId) -> Option<HirId> {\n+        match item_id {\n             ItemId::DefId(real_id) => {\n                 real_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n             }\n@@ -390,7 +390,7 @@ crate fn run_global_ctxt(\n         );\n         tcx.struct_lint_node(\n             crate::lint::MISSING_CRATE_LEVEL_DOCS,\n-            DocContext::as_local_hir_id(tcx, krate.module.def_id).unwrap(),\n+            DocContext::as_local_hir_id(tcx, krate.module.item_id).unwrap(),\n             |lint| {\n                 let mut diag =\n                     lint.build(\"no documentation found for this crate's top-level module\");"}, {"sha": "e138e434c4e04f72116b0bb1e9114fb9723cc6c5", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -186,8 +186,8 @@ impl Cache {\n \n impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        if item.def_id.is_local() {\n-            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n+        if item.item_id.is_local() {\n+            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.item_id);\n         }\n \n         // If this is a stripped module,\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         // If the impl is from a masked crate or references something from a\n         // masked crate then remove it completely.\n         if let clean::ImplItem(ref i) = *item.kind {\n-            if self.cache.masked_crates.contains(&item.def_id.krate())\n+            if self.cache.masked_crates.contains(&item.item_id.krate())\n                 || i.trait_\n                     .as_ref()\n                     .map_or(false, |t| self.cache.masked_crates.contains(&t.def_id().krate))\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         // Propagate a trait method's documentation to all implementors of the\n         // trait.\n         if let clean::TraitItem(ref t) = *item.kind {\n-            self.cache.traits.entry(item.def_id.expect_def_id()).or_insert_with(|| {\n+            self.cache.traits.entry(item.item_id.expect_def_id()).or_insert_with(|| {\n                 clean::TraitWithExtraInfo {\n                     trait_: t.clone(),\n                     is_notable: item.attrs.has_doc_flag(sym::notable_trait),\n@@ -293,7 +293,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     // A crate has a module at its root, containing all items,\n                     // which should not be indexed. The crate-item itself is\n                     // inserted later on when serializing the search-index.\n-                    if item.def_id.index().map_or(false, |idx| idx != CRATE_DEF_INDEX) {\n+                    if item.item_id.index().map_or(false, |idx| idx != CRATE_DEF_INDEX) {\n                         let desc = item.doc_value().map_or_else(String::new, |x| {\n                             short_markdown_summary(x.as_str(), &item.link_names(self.cache))\n                         });\n@@ -351,11 +351,11 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     // `public_items` map, so we can skip inserting into the\n                     // paths map if there was already an entry present and we're\n                     // not a public item.\n-                    if !self.cache.paths.contains_key(&item.def_id.expect_def_id())\n-                        || self.cache.access_levels.is_public(item.def_id.expect_def_id())\n+                    if !self.cache.paths.contains_key(&item.item_id.expect_def_id())\n+                        || self.cache.access_levels.is_public(item.item_id.expect_def_id())\n                     {\n                         self.cache.paths.insert(\n-                            item.def_id.expect_def_id(),\n+                            item.item_id.expect_def_id(),\n                             (self.cache.stack.clone(), item.type_()),\n                         );\n                     }\n@@ -364,7 +364,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             clean::PrimitiveItem(..) => {\n                 self.cache\n                     .paths\n-                    .insert(item.def_id.expect_def_id(), (self.cache.stack.clone(), item.type_()));\n+                    .insert(item.item_id.expect_def_id(), (self.cache.stack.clone(), item.type_()));\n             }\n \n             clean::ExternCrateItem { .. }\n@@ -396,7 +396,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             | clean::StructItem(..)\n             | clean::UnionItem(..)\n             | clean::VariantItem(..) => {\n-                self.cache.parent_stack.push(item.def_id.expect_def_id());\n+                self.cache.parent_stack.push(item.item_id.expect_def_id());\n                 self.cache.parent_is_trait_impl = false;\n                 true\n             }"}, {"sha": "8e643107353ddadc1de5887ab3eeee002445157d", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -222,7 +222,7 @@ impl<'tcx> Context<'tcx> {\n                 &self.shared.style_files,\n             )\n         } else {\n-            if let Some(&(ref names, ty)) = self.cache().paths.get(&it.def_id.expect_def_id()) {\n+            if let Some(&(ref names, ty)) = self.cache().paths.get(&it.item_id.expect_def_id()) {\n                 if self.current.len() + 1 != names.len()\n                     || self.current.iter().zip(names.iter()).any(|(a, b)| a != b)\n                 {"}, {"sha": "7a4289b8e60e9eebd0caa60683b1039887c35882", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -830,7 +830,7 @@ fn assoc_const(\n         w,\n         \"{extra}{vis}const <a{href} class=\\\"constant\\\">{name}</a>: {ty}\",\n         extra = extra,\n-        vis = it.visibility.print_with_space(it.def_id, cx),\n+        vis = it.visibility.print_with_space(it.item_id, cx),\n         href = assoc_href_attr(it, link, cx),\n         name = it.name.as_ref().unwrap(),\n         ty = ty.print(cx),\n@@ -884,7 +884,7 @@ fn assoc_method(\n ) {\n     let header = meth.fn_header(cx.tcx()).expect(\"Trying to get header from a non-function item\");\n     let name = meth.name.as_ref().unwrap();\n-    let vis = meth.visibility.print_with_space(meth.def_id, cx).to_string();\n+    let vis = meth.visibility.print_with_space(meth.item_id, cx).to_string();\n     // FIXME: Once https://github.com/rust-lang/rust/issues/67792 is implemented, we can remove\n     // this condition.\n     let constness = match render_mode {\n@@ -2060,7 +2060,7 @@ fn small_url_encode(s: String) -> String {\n }\n \n fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n-    let did = it.def_id.expect_def_id();\n+    let did = it.item_id.expect_def_id();\n     let cache = cx.cache();\n \n     if let Some(v) = cache.impls.get(&did) {\n@@ -2412,7 +2412,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n     );\n \n     let cache = cx.cache();\n-    if let Some(implementors) = cache.implementors.get(&it.def_id.expect_def_id()) {\n+    if let Some(implementors) = cache.implementors.get(&it.item_id.expect_def_id()) {\n         let mut res = implementors\n             .iter()\n             .filter(|i| {\n@@ -2761,7 +2761,7 @@ const NUM_VISIBLE_LINES: usize = 10;\n /// Generates the HTML for example call locations generated via the --scrape-examples flag.\n fn render_call_locations(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item) {\n     let tcx = cx.tcx();\n-    let def_id = item.def_id.expect_def_id();\n+    let def_id = item.item_id.expect_def_id();\n     let key = tcx.def_path_hash(def_id);\n     let Some(call_locations) = cx.shared.call_locations.get(&key) else { return };\n "}, {"sha": "f1915920b6d05dd79832656d491f2ffb06e3198d", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -264,7 +264,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n     // (which is the position in the vector).\n     indices.dedup_by_key(|i| {\n         (\n-            items[*i].def_id,\n+            items[*i].item_id,\n             if items[*i].name.is_some() { Some(full_path(cx, &items[*i])) } else { None },\n             items[*i].type_(),\n             if items[*i].is_import() { *i } else { 0 },\n@@ -306,15 +306,15 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                     Some(src) => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {} as {};\",\n-                        myitem.visibility.print_with_space(myitem.def_id, cx),\n-                        anchor(myitem.def_id.expect_def_id(), src, cx),\n+                        myitem.visibility.print_with_space(myitem.item_id, cx),\n+                        anchor(myitem.item_id.expect_def_id(), src, cx),\n                         myitem.name.unwrap(),\n                     ),\n                     None => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {};\",\n-                        myitem.visibility.print_with_space(myitem.def_id, cx),\n-                        anchor(myitem.def_id.expect_def_id(), myitem.name.unwrap(), cx),\n+                        myitem.visibility.print_with_space(myitem.item_id, cx),\n+                        anchor(myitem.item_id.expect_def_id(), myitem.name.unwrap(), cx),\n                     ),\n                 }\n                 w.write_str(\"</code></div>\");\n@@ -328,7 +328,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n \n                     // Just need an item with the correct def_id and attrs\n                     let import_item = clean::Item {\n-                        def_id: import_def_id.into(),\n+                        item_id: import_def_id.into(),\n                         attrs: import_attrs,\n                         cfg: ast_attrs.cfg(cx.tcx(), &cx.cache().hidden_cfg),\n                         ..myitem.clone()\n@@ -352,7 +352,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                      <div class=\\\"item-right docblock-short\\\">{stab_tags}</div>\",\n                     stab = stab.unwrap_or_default(),\n                     add = add,\n-                    vis = myitem.visibility.print_with_space(myitem.def_id, cx),\n+                    vis = myitem.visibility.print_with_space(myitem.item_id, cx),\n                     imp = import.print(cx),\n                     stab_tags = stab_tags.unwrap_or_default(),\n                 );\n@@ -468,7 +468,7 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n     let unsafety = header.unsafety.print_with_space();\n     let abi = print_abi_with_space(header.abi).to_string();\n     let asyncness = header.asyncness.print_with_space();\n-    let visibility = it.visibility.print_with_space(it.def_id, cx).to_string();\n+    let visibility = it.visibility.print_with_space(it.item_id, cx).to_string();\n     let name = it.name.unwrap();\n \n     let generics_len = format!(\"{:#}\", f.generics.print(cx)).len();\n@@ -524,7 +524,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n             write!(\n                 w,\n                 \"{}{}{}trait {}{}{}\",\n-                it.visibility.print_with_space(it.def_id, cx),\n+                it.visibility.print_with_space(it.item_id, cx),\n                 t.unsafety.print_with_space(),\n                 if t.is_auto { \"auto \" } else { \"\" },\n                 it.name.unwrap(),\n@@ -787,10 +787,10 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All);\n+    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All);\n \n     let cache = cx.cache();\n-    if let Some(implementors) = cache.implementors.get(&it.def_id.expect_def_id()) {\n+    if let Some(implementors) = cache.implementors.get(&it.item_id.expect_def_id()) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();\n@@ -827,7 +827,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n             for implementor in foreign {\n                 let provided_methods = implementor.inner_impl().provided_trait_methods(cx.tcx());\n                 let assoc_link =\n-                    AssocItemLink::GotoSource(implementor.impl_item.def_id, &provided_methods);\n+                    AssocItemLink::GotoSource(implementor.impl_item.item_id, &provided_methods);\n                 render_impl(\n                     w,\n                     cx,\n@@ -902,10 +902,10 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         .take(cx.current.len())\n         .chain(std::iter::once(\"implementors\"))\n         .collect();\n-    if it.def_id.is_local() {\n+    if it.item_id.is_local() {\n         js_src_path.extend(cx.current.iter().copied());\n     } else {\n-        let (ref path, _) = cache.external_paths[&it.def_id.expect_def_id()];\n+        let (ref path, _) = cache.external_paths[&it.item_id.expect_def_id()];\n         js_src_path.extend(path[..path.len() - 1].iter().copied());\n     }\n     js_src_path.push_fmt(format_args!(\"{}.{}.js\", it.type_(), it.name.unwrap()));\n@@ -937,7 +937,7 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clea\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n@@ -961,14 +961,14 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean:\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n     fn write_content(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n         wrap_item(w, \"typedef\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n-            write!(w, \"{}\", it.visibility.print_with_space(it.def_id, cx));\n+            write!(w, \"{}\", it.visibility.print_with_space(it.item_id, cx));\n             write!(\n                 w,\n                 \"type {}{}{where_clause} = {type_};\",\n@@ -984,7 +984,7 @@ fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::T\n \n     document(w, cx, it, None, HeadingOffset::H2);\n \n-    let def_id = it.def_id.expect_def_id();\n+    let def_id = it.item_id.expect_def_id();\n     // Render any items associated directly to this alias, as otherwise they\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n@@ -1037,7 +1037,7 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n             document(w, cx, field, Some(it), HeadingOffset::H3);\n         }\n     }\n-    let def_id = it.def_id.expect_def_id();\n+    let def_id = it.item_id.expect_def_id();\n     render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n     document_type_layout(w, cx, def_id);\n }\n@@ -1062,7 +1062,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             write!(\n                 w,\n                 \"{}enum {}{}{}\",\n-                it.visibility.print_with_space(it.def_id, cx),\n+                it.visibility.print_with_space(it.item_id, cx),\n                 it.name.unwrap(),\n                 e.generics.print(cx),\n                 print_where_clause(&e.generics, cx, 0, true),\n@@ -1197,7 +1197,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             document(w, cx, variant, Some(it), HeadingOffset::H4);\n         }\n     }\n-    let def_id = it.def_id.expect_def_id();\n+    let def_id = it.item_id.expect_def_id();\n     render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n     document_type_layout(w, cx, def_id);\n }\n@@ -1253,7 +1253,7 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean\n \n fn item_primitive(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n     document(w, cx, it, None, HeadingOffset::H2);\n-    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::Constant) {\n@@ -1264,7 +1264,7 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n             write!(\n                 w,\n                 \"{vis}const {name}: {typ}\",\n-                vis = it.visibility.print_with_space(it.def_id, cx),\n+                vis = it.visibility.print_with_space(it.item_id, cx),\n                 name = it.name.unwrap(),\n                 typ = c.type_.print(cx),\n             );\n@@ -1344,7 +1344,7 @@ fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n             }\n         }\n     }\n-    let def_id = it.def_id.expect_def_id();\n+    let def_id = it.item_id.expect_def_id();\n     render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n     document_type_layout(w, cx, def_id);\n }\n@@ -1356,7 +1356,7 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n             write!(\n                 w,\n                 \"{vis}static {mutability}{name}: {typ}\",\n-                vis = it.visibility.print_with_space(it.def_id, cx),\n+                vis = it.visibility.print_with_space(it.item_id, cx),\n                 mutability = s.mutability.print_with_space(),\n                 name = it.name.unwrap(),\n                 typ = s.type_.print(cx)\n@@ -1374,15 +1374,15 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n             write!(\n                 w,\n                 \"    {}type {};\\n}}\",\n-                it.visibility.print_with_space(it.def_id, cx),\n+                it.visibility.print_with_space(it.item_id, cx),\n                 it.name.unwrap(),\n             );\n         });\n     });\n \n     document(w, cx, it, None, HeadingOffset::H2);\n \n-    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_keyword(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n@@ -1543,7 +1543,7 @@ fn render_union(\n     tab: &str,\n     cx: &Context<'_>,\n ) {\n-    write!(w, \"{}union {}\", it.visibility.print_with_space(it.def_id, cx), it.name.unwrap());\n+    write!(w, \"{}union {}\", it.visibility.print_with_space(it.item_id, cx), it.name.unwrap());\n     if let Some(g) = g {\n         write!(w, \"{}\", g.print(cx));\n         write!(w, \"{}\", print_where_clause(g, cx, 0, true));\n@@ -1562,7 +1562,7 @@ fn render_union(\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n-                field.visibility.print_with_space(field.def_id, cx),\n+                field.visibility.print_with_space(field.item_id, cx),\n                 field.name.unwrap(),\n                 ty.print(cx),\n                 tab\n@@ -1592,7 +1592,7 @@ fn render_struct(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(it.def_id, cx),\n+        it.visibility.print_with_space(it.item_id, cx),\n         if structhead { \"struct \" } else { \"\" },\n         it.name.unwrap()\n     );\n@@ -1618,7 +1618,7 @@ fn render_struct(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n                         tab,\n-                        field.visibility.print_with_space(field.def_id, cx),\n+                        field.visibility.print_with_space(field.item_id, cx),\n                         field.name.unwrap(),\n                         ty.print(cx),\n                     );\n@@ -1650,7 +1650,7 @@ fn render_struct(\n                         write!(\n                             w,\n                             \"{}{}\",\n-                            field.visibility.print_with_space(field.def_id, cx),\n+                            field.visibility.print_with_space(field.item_id, cx),\n                             ty.print(cx),\n                         )\n                     }"}, {"sha": "371d0e84087544d4223a3427721fd102570702a6", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -535,7 +535,7 @@ pub(super) fn write_shared(\n                 //\n                 // If the implementation is from another crate then that crate\n                 // should add it.\n-                if imp.impl_item.def_id.krate() == did.krate || !imp.impl_item.def_id.is_local() {\n+                if imp.impl_item.item_id.krate() == did.krate || !imp.impl_item.item_id.is_local() {\n                     None\n                 } else {\n                     Some(Implementor {"}, {"sha": "0b5fb480595797a3fbc96264fd079961371e0f45", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -27,7 +27,7 @@ impl JsonRenderer<'_> {\n         let links = self\n             .cache\n             .intra_doc_links\n-            .get(&item.def_id)\n+            .get(&item.item_id)\n             .into_iter()\n             .flatten()\n             .map(|clean::ItemLink { link, did, .. }| (link.clone(), from_item_id((*did).into())))\n@@ -40,14 +40,14 @@ impl JsonRenderer<'_> {\n             .map(rustc_ast_pretty::pprust::attribute_to_string)\n             .collect();\n         let span = item.span(self.tcx);\n-        let clean::Item { name, attrs: _, kind: _, visibility, def_id, cfg: _ } = item;\n+        let clean::Item { name, attrs: _, kind: _, visibility, item_id, cfg: _ } = item;\n         let inner = match *item.kind {\n             clean::StrippedItem(_) => return None,\n             _ => from_clean_item(item, self.tcx),\n         };\n         Some(Item {\n-            id: from_item_id(def_id),\n-            crate_id: def_id.krate().as_u32(),\n+            id: from_item_id(item_id),\n+            crate_id: item_id.krate().as_u32(),\n             name: name.map(|sym| sym.to_string()),\n             span: self.convert_span(span),\n             visibility: self.convert_visibility(visibility),\n@@ -174,7 +174,7 @@ impl FromWithTcx<clean::TypeBindingKind> for TypeBindingKind {\n     }\n }\n \n-crate fn from_item_id(did: ItemId) -> Id {\n+crate fn from_item_id(item_id: ItemId) -> Id {\n     struct DisplayDefId(DefId);\n \n     impl fmt::Display for DisplayDefId {\n@@ -183,7 +183,7 @@ crate fn from_item_id(did: ItemId) -> Id {\n         }\n     }\n \n-    match did {\n+    match item_id {\n         ItemId::DefId(did) => Id(format!(\"{}\", DisplayDefId(did))),\n         ItemId::Blanket { for_, impl_id } => {\n             Id(format!(\"b:{}-{}\", DisplayDefId(impl_id), DisplayDefId(for_)))\n@@ -732,5 +732,5 @@ impl FromWithTcx<ItemType> for ItemKind {\n }\n \n fn ids(items: impl IntoIterator<Item = clean::Item>) -> Vec<Id> {\n-    items.into_iter().filter(|x| !x.is_stripped()).map(|i| from_item_id(i.def_id)).collect()\n+    items.into_iter().filter(|x| !x.is_stripped()).map(|i| from_item_id(i.item_id)).collect()\n }"}, {"sha": "e6e5bba7f006745d94d8cba6ef31d283f76192bc", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> JsonRenderer<'tcx> {\n                     .map(|i| {\n                         let item = &i.impl_item;\n                         self.item(item.clone()).unwrap();\n-                        from_item_id(item.def_id)\n+                        from_item_id(item.item_id)\n                     })\n                     .collect()\n             })\n@@ -84,9 +84,9 @@ impl<'tcx> JsonRenderer<'tcx> {\n                             }\n                         }\n \n-                        if item.def_id.is_local() || is_primitive_impl {\n+                        if item.item_id.is_local() || is_primitive_impl {\n                             self.item(item.clone()).unwrap();\n-                            Some(from_item_id(item.def_id))\n+                            Some(from_item_id(item.item_id))\n                         } else {\n                             None\n                         }\n@@ -176,18 +176,18 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         // Flatten items that recursively store other items\n         item.kind.inner_items().for_each(|i| self.item(i.clone()).unwrap());\n \n-        let id = item.def_id;\n+        let item_id = item.item_id;\n         if let Some(mut new_item) = self.convert_item(item) {\n             if let types::ItemEnum::Trait(ref mut t) = new_item.inner {\n-                t.implementations = self.get_trait_implementors(id.expect_def_id())\n+                t.implementations = self.get_trait_implementors(item_id.expect_def_id())\n             } else if let types::ItemEnum::Struct(ref mut s) = new_item.inner {\n-                s.impls = self.get_impls(id.expect_def_id())\n+                s.impls = self.get_impls(item_id.expect_def_id())\n             } else if let types::ItemEnum::Enum(ref mut e) = new_item.inner {\n-                e.impls = self.get_impls(id.expect_def_id())\n+                e.impls = self.get_impls(item_id.expect_def_id())\n             } else if let types::ItemEnum::Union(ref mut u) = new_item.inner {\n-                u.impls = self.get_impls(id.expect_def_id())\n+                u.impls = self.get_impls(item_id.expect_def_id())\n             }\n-            let removed = self.index.borrow_mut().insert(from_item_id(id), new_item.clone());\n+            let removed = self.index.borrow_mut().insert(from_item_id(item_id), new_item.clone());\n \n             // FIXME(adotinthevoid): Currently, the index is duplicated. This is a sanity check\n             // to make sure the items are unique. The main place this happens is when an item, is"}, {"sha": "1839a35a8b14bb38f24ef318a4a0ffd4ab38c14e", "filename": "src/librustdoc/passes/bare_urls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -61,7 +61,7 @@ crate fn check_bare_urls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n \n impl<'a, 'tcx> DocVisitor for BareUrlsLinter<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n-        let Some(hir_id) = DocContext::as_local_hir_id(self.cx.tcx, item.def_id)\n+        let Some(hir_id) = DocContext::as_local_hir_id(self.cx.tcx, item.item_id)\n         else {\n             // If non-local, no need to check anything.\n             return;"}, {"sha": "33d83aa339d95313441d9f47a2e6cab5285b5ac9", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -185,7 +185,7 @@ impl<'a, 'b> CoverageCalculator<'a, 'b> {\n \n impl<'a, 'b> DocVisitor for CoverageCalculator<'a, 'b> {\n     fn visit_item(&mut self, i: &clean::Item) {\n-        if !i.def_id.is_local() {\n+        if !i.item_id.is_local() {\n             // non-local items are skipped because they can be out of the users control,\n             // especially in the case of trait impls, which rustdoc eagerly inlines\n             return;\n@@ -223,7 +223,7 @@ impl<'a, 'b> DocVisitor for CoverageCalculator<'a, 'b> {\n                     .ctx\n                     .tcx\n                     .hir()\n-                    .local_def_id_to_hir_id(i.def_id.expect_def_id().expect_local());\n+                    .local_def_id_to_hir_id(i.item_id.expect_def_id().expect_local());\n                 let (level, source) = self.ctx.tcx.lint_level_at_node(MISSING_DOCS, hir_id);\n \n                 // In case we have:\n@@ -237,7 +237,7 @@ impl<'a, 'b> DocVisitor for CoverageCalculator<'a, 'b> {\n                 // there is no need to require documentation on the fields of tuple variants and\n                 // tuple structs.\n                 let should_be_ignored = i\n-                    .def_id\n+                    .item_id\n                     .as_def_id()\n                     .and_then(|def_id| self.ctx.tcx.parent(def_id))\n                     .and_then(|def_id| self.ctx.tcx.hir().get_if_local(def_id))"}, {"sha": "23d947c4d7227e74c869b64bef89eda9261588ea", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n             return;\n         }\n \n-        let Some(local_id) = item.def_id.as_def_id().and_then(|x| x.as_local())\n+        let Some(local_id) = item.item_id.as_def_id().and_then(|x| x.as_local())\n         else {\n             // We don't need to check the syntax for other crates so returning\n             // without doing anything should not be a problem.\n@@ -153,7 +153,7 @@ impl<'a, 'tcx> DocVisitor for SyntaxChecker<'a, 'tcx> {\n             let sp = item.attr_span(self.cx.tcx);\n             let extra = crate::html::markdown::ExtraInfo::new_did(\n                 self.cx.tcx,\n-                item.def_id.expect_def_id(),\n+                item.item_id.expect_def_id(),\n                 sp,\n             );\n             for code_block in markdown::rust_code_blocks(dox, &extra) {"}, {"sha": "80a2683fde7f4f87fd2cae41e2f7bfc2766c17d7", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -56,7 +56,7 @@ impl crate::doctest::Tester for Tests {\n }\n \n crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n-    if !cx.cache.access_levels.is_public(item.def_id.expect_def_id())\n+    if !cx.cache.access_levels.is_public(item.item_id.expect_def_id())\n         || matches!(\n             *item.kind,\n             clean::StructFieldItem(_)\n@@ -79,7 +79,7 @@ crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> boo\n \n     // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n     // would presumably panic if a fake `DefIndex` were passed.\n-    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(item.def_id.expect_def_id().expect_local());\n+    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(item.item_id.expect_def_id().expect_local());\n \n     // check if parent is trait impl\n     if let Some(parent_hir_id) = cx.tcx.hir().find_parent_node(hir_id) {\n@@ -107,7 +107,7 @@ crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> boo\n }\n \n crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n-    let Some(hir_id) = DocContext::as_local_hir_id(cx.tcx, item.def_id)\n+    let Some(hir_id) = DocContext::as_local_hir_id(cx.tcx, item.item_id)\n     else {\n         // If non-local, no need to check anything.\n         return;\n@@ -131,7 +131,7 @@ crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n             );\n         }\n     } else if tests.found_tests > 0\n-        && !cx.cache.access_levels.is_exported(item.def_id.expect_def_id())\n+        && !cx.cache.access_levels.is_exported(item.item_id.expect_def_id())\n     {\n         cx.tcx.struct_span_lint_hir(\n             crate::lint::PRIVATE_DOC_TESTS,"}, {"sha": "c48f8bd0c7cc5a0cced4aa8341630a5157369718", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -1025,15 +1025,15 @@ fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_\n impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         let parent_node =\n-            item.def_id.as_def_id().and_then(|did| find_nearest_parent_module(self.cx.tcx, did));\n+            item.item_id.as_def_id().and_then(|did| find_nearest_parent_module(self.cx.tcx, did));\n         if parent_node.is_some() {\n-            trace!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n+            trace!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.item_id);\n         }\n \n         let inner_docs = item.inner_docs(self.cx.tcx);\n \n         if item.is_mod() && inner_docs {\n-            self.mod_ids.push(item.def_id.expect_def_id());\n+            self.mod_ids.push(item.item_id.expect_def_id());\n         }\n \n         // We want to resolve in the lexical scope of the documentation.\n@@ -1048,14 +1048,14 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n             for md_link in markdown_links(&doc) {\n                 let link = self.resolve_link(&item, &doc, parent_node, md_link);\n                 if let Some(link) = link {\n-                    self.cx.cache.intra_doc_links.entry(item.def_id).or_default().push(link);\n+                    self.cx.cache.intra_doc_links.entry(item.item_id).or_default().push(link);\n                 }\n             }\n         }\n \n         if item.is_mod() {\n             if !inner_docs {\n-                self.mod_ids.push(item.def_id.expect_def_id());\n+                self.mod_ids.push(item.item_id.expect_def_id());\n             }\n \n             self.visit_item_recur(item);\n@@ -1246,7 +1246,7 @@ impl LinkCollector<'_, '_> {\n \n         let (mut res, fragment) = self.resolve_with_disambiguator_cached(\n             ResolutionInfo {\n-                item_id: item.def_id,\n+                item_id: item.item_id,\n                 module_id,\n                 dis: disambiguator,\n                 path_str: path_str.to_owned(),\n@@ -1302,7 +1302,7 @@ impl LinkCollector<'_, '_> {\n                     // FIXME: it would be nice to check that the feature gate was enabled in the original crate, not just ignore it altogether.\n                     // However I'm not sure how to check that across crates.\n                     if prim == PrimitiveType::RawPointer\n-                        && item.def_id.is_local()\n+                        && item.item_id.is_local()\n                         && !self.cx.tcx.features().intra_doc_pointers\n                     {\n                         self.report_rawptr_assoc_feature_gate(dox, &ori_link, item);\n@@ -1386,7 +1386,7 @@ impl LinkCollector<'_, '_> {\n             // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n             // would presumably panic if a fake `DefIndex` were passed.\n             .and_then(|dst_id| {\n-                item.def_id.expect_def_id().as_local().map(|src_id| (src_id, dst_id))\n+                item.item_id.expect_def_id().as_local().map(|src_id| (src_id, dst_id))\n             })\n         {\n             if self.cx.tcx.privacy_access_levels(()).is_exported(src_id)\n@@ -1864,7 +1864,7 @@ fn report_diagnostic(\n     DiagnosticInfo { item, ori_link: _, dox, link_range }: &DiagnosticInfo<'_>,\n     decorate: impl FnOnce(&mut Diagnostic, Option<rustc_span::Span>),\n ) {\n-    let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.def_id)\n+    let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.item_id)\n     else {\n         // If non-local, no need to check anything.\n         info!(\"ignoring warning from parent crate: {}\", msg);"}, {"sha": "65459913eeaa80d09415c56d2e78ba28f2890358", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -52,7 +52,7 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n                 // FIXME(eddyb) is this `doc(hidden)` check needed?\n                 if !cx.tcx.is_doc_hidden(def_id) {\n                     let impls = get_auto_trait_and_blanket_impls(cx, def_id);\n-                    new_items.extend(impls.filter(|i| cx.inlined.insert(i.def_id)));\n+                    new_items.extend(impls.filter(|i| cx.inlined.insert(i.item_id)));\n                 }\n             }\n         }\n@@ -176,9 +176,9 @@ impl<'a, 'tcx> DocVisitor for SyntheticImplCollector<'a, 'tcx> {\n     fn visit_item(&mut self, i: &Item) {\n         if i.is_struct() || i.is_enum() || i.is_union() {\n             // FIXME(eddyb) is this `doc(hidden)` check needed?\n-            if !self.cx.tcx.is_doc_hidden(i.def_id.expect_def_id()) {\n+            if !self.cx.tcx.is_doc_hidden(i.item_id.expect_def_id()) {\n                 self.impls\n-                    .extend(get_auto_trait_and_blanket_impls(self.cx, i.def_id.expect_def_id()));\n+                    .extend(get_auto_trait_and_blanket_impls(self.cx, i.item_id.expect_def_id()));\n             }\n         }\n \n@@ -199,7 +199,7 @@ impl ItemCollector {\n \n impl DocVisitor for ItemCollector {\n     fn visit_item(&mut self, i: &Item) {\n-        self.items.insert(i.def_id);\n+        self.items.insert(i.item_id);\n \n         self.visit_item_recur(i)\n     }\n@@ -225,7 +225,7 @@ impl<'a> BadImplStripper<'a> {\n         }\n     }\n \n-    fn keep_impl_with_def_id(&self, did: ItemId) -> bool {\n-        self.items.contains(&did)\n+    fn keep_impl_with_def_id(&self, item_id: ItemId) -> bool {\n+        self.items.contains(&item_id)\n     }\n }"}, {"sha": "044f224e7885c24727e4907977331b2faef474df", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -197,7 +197,7 @@ fn extract_tags(\n impl<'a, 'tcx> DocVisitor for InvalidHtmlTagsLinter<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         let tcx = self.cx.tcx;\n-        let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.def_id)\n+        let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.item_id)\n         // If non-local, no need to check anything.\n         else { return };\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_default();"}, {"sha": "6b052185bbdb84b7c7c2a0fcd6b8a881c5143159", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -53,7 +53,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             }\n         } else {\n             if self.update_retained {\n-                self.retained.insert(i.def_id);\n+                self.retained.insert(i.item_id);\n             }\n         }\n         Some(self.fold_item_recur(i))"}, {"sha": "6a522bdacf997849e1fc4bd4bfbdcf3106069d5e", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e0db5666c15ed58abb47aca1ee453e371c406f/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=10e0db5666c15ed58abb47aca1ee453e371c406f", "patch": "@@ -45,7 +45,8 @@ impl<'a> DocFolder for Stripper<'a> {\n             | clean::TraitAliasItem(..)\n             | clean::MacroItem(..)\n             | clean::ForeignTypeItem => {\n-                if i.def_id.is_local() && !self.access_levels.is_exported(i.def_id.expect_def_id())\n+                if i.item_id.is_local()\n+                    && !self.access_levels.is_exported(i.item_id.expect_def_id())\n                 {\n                     debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n                     return None;\n@@ -59,7 +60,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             }\n \n             clean::ModuleItem(..) => {\n-                if i.def_id.is_local() && !i.visibility.is_public() {\n+                if i.item_id.is_local() && !i.visibility.is_public() {\n                     debug!(\"Stripper: stripping module {:?}\", i.name);\n                     let old = mem::replace(&mut self.update_retained, false);\n                     let ret = strip_item(self.fold_item_recur(i));\n@@ -100,15 +101,15 @@ impl<'a> DocFolder for Stripper<'a> {\n \n         let i = if fastreturn {\n             if self.update_retained {\n-                self.retained.insert(i.def_id);\n+                self.retained.insert(i.item_id);\n             }\n             return Some(i);\n         } else {\n             self.fold_item_recur(i)\n         };\n \n         if self.update_retained {\n-            self.retained.insert(i.def_id);\n+            self.retained.insert(i.item_id);\n         }\n         Some(i)\n     }"}]}