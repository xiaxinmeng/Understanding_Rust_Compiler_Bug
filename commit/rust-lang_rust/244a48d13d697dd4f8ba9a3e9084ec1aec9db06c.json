{"sha": "244a48d13d697dd4f8ba9a3e9084ec1aec9db06c", "node_id": "C_kwDOAAsO6NoAKDI0NGE0OGQxM2Q2OTdkZDRmOGJhOWEzZTkwODRlYzFhZWM5ZGIwNmM", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-02-13T10:25:45Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-02-13T10:25:45Z"}, "message": "Cleanup signature help a bit", "tree": {"sha": "75b5989ddaab7a83f233e5895340423b4377e7a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75b5989ddaab7a83f233e5895340423b4377e7a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/244a48d13d697dd4f8ba9a3e9084ec1aec9db06c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/244a48d13d697dd4f8ba9a3e9084ec1aec9db06c", "html_url": "https://github.com/rust-lang/rust/commit/244a48d13d697dd4f8ba9a3e9084ec1aec9db06c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/244a48d13d697dd4f8ba9a3e9084ec1aec9db06c/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9738f97f8c7542d84f1996e1f857ecd77adda160", "url": "https://api.github.com/repos/rust-lang/rust/commits/9738f97f8c7542d84f1996e1f857ecd77adda160", "html_url": "https://github.com/rust-lang/rust/commit/9738f97f8c7542d84f1996e1f857ecd77adda160"}], "stats": {"total": 144, "additions": 79, "deletions": 65}, "files": [{"sha": "2b6b60547b355e9bb41f6f381f479f8101ddbbc4", "filename": "crates/ide-db/src/active_parameter.rs", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/244a48d13d697dd4f8ba9a3e9084ec1aec9db06c/crates%2Fide-db%2Fsrc%2Factive_parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244a48d13d697dd4f8ba9a3e9084ec1aec9db06c/crates%2Fide-db%2Fsrc%2Factive_parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Factive_parameter.rs?ref=244a48d13d697dd4f8ba9a3e9084ec1aec9db06c", "patch": "@@ -5,7 +5,7 @@ use hir::{Semantics, Type};\n use parser::T;\n use syntax::{\n     ast::{self, HasArgList, HasName},\n-    AstNode, NodeOrToken, SyntaxToken,\n+    match_ast, AstNode, NodeOrToken, SyntaxToken,\n };\n \n use crate::RootDatabase;\n@@ -81,3 +81,64 @@ pub fn callable_for_node(\n     };\n     Some((callable, active_param))\n }\n+\n+pub fn generic_def_for_node(\n+    sema: &Semantics<'_, RootDatabase>,\n+    generic_arg_list: &ast::GenericArgList,\n+    token: &SyntaxToken,\n+) -> Option<(hir::GenericDef, usize, bool)> {\n+    let parent = generic_arg_list.syntax().parent()?;\n+    let def = match_ast! {\n+        match parent {\n+            ast::PathSegment(ps) => {\n+                let res = sema.resolve_path(&ps.parent_path())?;\n+                let generic_def: hir::GenericDef = match res {\n+                    hir::PathResolution::Def(hir::ModuleDef::Adt(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::Function(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::Trait(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::TypeAlias(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::Variant(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::BuiltinType(_))\n+                    | hir::PathResolution::Def(hir::ModuleDef::Const(_))\n+                    | hir::PathResolution::Def(hir::ModuleDef::Macro(_))\n+                    | hir::PathResolution::Def(hir::ModuleDef::Module(_))\n+                    | hir::PathResolution::Def(hir::ModuleDef::Static(_)) => return None,\n+                    hir::PathResolution::BuiltinAttr(_)\n+                    | hir::PathResolution::ToolModule(_)\n+                    | hir::PathResolution::Local(_)\n+                    | hir::PathResolution::TypeParam(_)\n+                    | hir::PathResolution::ConstParam(_)\n+                    | hir::PathResolution::SelfType(_)\n+                    | hir::PathResolution::DeriveHelper(_) => return None,\n+                };\n+\n+                generic_def\n+            },\n+            ast::AssocTypeArg(_) => {\n+                // FIXME: We don't record the resolutions for this anywhere atm\n+                return None;\n+            },\n+            ast::MethodCallExpr(mcall) => {\n+                // recv.method::<$0>()\n+                let method = sema.resolve_method_call(&mcall)?;\n+                method.into()\n+            },\n+            _ => return None,\n+        }\n+    };\n+\n+    let active_param = generic_arg_list\n+        .syntax()\n+        .children_with_tokens()\n+        .filter_map(NodeOrToken::into_token)\n+        .filter(|t| t.kind() == T![,])\n+        .take_while(|t| t.text_range().start() <= token.text_range().start())\n+        .count();\n+\n+    let first_arg_is_non_lifetime = generic_arg_list\n+        .generic_args()\n+        .next()\n+        .map_or(false, |arg| !matches!(arg, ast::GenericArg::LifetimeArg(_)));\n+\n+    Some((def, active_param, first_arg_is_non_lifetime))\n+}"}, {"sha": "f70ca55a508d2b8045e841aa668b2a422342560b", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 17, "deletions": 64, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/244a48d13d697dd4f8ba9a3e9084ec1aec9db06c/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244a48d13d697dd4f8ba9a3e9084ec1aec9db06c/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=244a48d13d697dd4f8ba9a3e9084ec1aec9db06c", "patch": "@@ -7,7 +7,11 @@ use either::Either;\n use hir::{\n     AssocItem, GenericParam, HasAttrs, HirDisplay, ModuleDef, PathResolution, Semantics, Trait,\n };\n-use ide_db::{active_parameter::callable_for_node, base_db::FilePosition, FxIndexMap};\n+use ide_db::{\n+    active_parameter::{callable_for_node, generic_def_for_node},\n+    base_db::FilePosition,\n+    FxIndexMap,\n+};\n use stdx::format_to;\n use syntax::{\n     algo,\n@@ -214,59 +218,11 @@ fn signature_help_for_call(\n \n fn signature_help_for_generics(\n     sema: &Semantics<'_, RootDatabase>,\n-    garg_list: ast::GenericArgList,\n+    arg_list: ast::GenericArgList,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n-    let arg_list = garg_list\n-        .syntax()\n-        .ancestors()\n-        .filter_map(ast::GenericArgList::cast)\n-        .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n-\n-    let mut active_parameter = arg_list\n-        .generic_args()\n-        .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n-        .count();\n-\n-    let first_arg_is_non_lifetime = arg_list\n-        .generic_args()\n-        .next()\n-        .map_or(false, |arg| !matches!(arg, ast::GenericArg::LifetimeArg(_)));\n-\n-    let mut generics_def = if let Some(path) =\n-        arg_list.syntax().ancestors().find_map(ast::Path::cast)\n-    {\n-        let res = sema.resolve_path(&path)?;\n-        let generic_def: hir::GenericDef = match res {\n-            hir::PathResolution::Def(hir::ModuleDef::Adt(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Function(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Trait(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::TypeAlias(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Variant(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::BuiltinType(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Const(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Macro(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Module(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Static(_)) => return None,\n-            hir::PathResolution::BuiltinAttr(_)\n-            | hir::PathResolution::ToolModule(_)\n-            | hir::PathResolution::Local(_)\n-            | hir::PathResolution::TypeParam(_)\n-            | hir::PathResolution::ConstParam(_)\n-            | hir::PathResolution::SelfType(_)\n-            | hir::PathResolution::DeriveHelper(_) => return None,\n-        };\n-\n-        generic_def\n-    } else if let Some(method_call) = arg_list.syntax().parent().and_then(ast::MethodCallExpr::cast)\n-    {\n-        // recv.method::<$0>()\n-        let method = sema.resolve_method_call(&method_call)?;\n-        method.into()\n-    } else {\n-        return None;\n-    };\n-\n+    let (mut generics_def, mut active_parameter, first_arg_is_non_lifetime) =\n+        generic_def_for_node(sema, &arg_list, &token)?;\n     let mut res = SignatureHelp {\n         doc: None,\n         signature: String::new(),\n@@ -305,9 +261,9 @@ fn signature_help_for_generics(\n             // eg. `None::<u8>`\n             // We'll use the signature of the enum, but include the docs of the variant.\n             res.doc = it.docs(db).map(|it| it.into());\n-            let it = it.parent_enum(db);\n-            format_to!(res.signature, \"enum {}\", it.name(db));\n-            generics_def = it.into();\n+            let enum_ = it.parent_enum(db);\n+            format_to!(res.signature, \"enum {}\", enum_.name(db));\n+            generics_def = enum_.into();\n         }\n         // These don't have generic args that can be specified\n         hir::GenericDef::Impl(_) | hir::GenericDef::Const(_) => return None,\n@@ -386,16 +342,13 @@ fn signature_help_for_record_lit(\n     record: ast::RecordExpr,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n-    let arg_list = record\n-        .syntax()\n-        .ancestors()\n-        .filter_map(ast::RecordExpr::cast)\n-        .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n-\n-    let active_parameter = arg_list\n+    let active_parameter = record\n         .record_expr_field_list()?\n-        .fields()\n-        .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n+        .syntax()\n+        .children_with_tokens()\n+        .filter_map(syntax::NodeOrToken::into_token)\n+        .filter(|t| t.kind() == syntax::T![,])\n+        .take_while(|t| t.text_range().start() <= token.text_range().start())\n         .count();\n \n     let mut res = SignatureHelp {"}]}