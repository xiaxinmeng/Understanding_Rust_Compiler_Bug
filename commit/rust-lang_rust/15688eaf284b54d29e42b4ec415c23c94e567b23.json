{"sha": "15688eaf284b54d29e42b4ec415c23c94e567b23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1Njg4ZWFmMjg0YjU0ZDI5ZTQyYjRlYzQxNWMyM2M5NGU1NjdiMjM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-25T20:15:03Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-27T04:29:35Z"}, "message": "librustc: Require explicit lifetime binders", "tree": {"sha": "e171e163bbeab4085101612136e74bb443b0c740", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e171e163bbeab4085101612136e74bb443b0c740"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15688eaf284b54d29e42b4ec415c23c94e567b23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15688eaf284b54d29e42b4ec415c23c94e567b23", "html_url": "https://github.com/rust-lang/rust/commit/15688eaf284b54d29e42b4ec415c23c94e567b23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15688eaf284b54d29e42b4ec415c23c94e567b23/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b2fcf9f5991effa96c0102adc155bad0b5a4feb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b2fcf9f5991effa96c0102adc155bad0b5a4feb", "html_url": "https://github.com/rust-lang/rust/commit/3b2fcf9f5991effa96c0102adc155bad0b5a4feb"}], "stats": {"total": 385, "additions": 322, "deletions": 63}, "files": [{"sha": "dad660e8c7053ddb669a05f1ec103d2689b48281", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/15688eaf284b54d29e42b4ec415c23c94e567b23/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15688eaf284b54d29e42b4ec415c23c94e567b23/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=15688eaf284b54d29e42b4ec415c23c94e567b23", "patch": "@@ -58,13 +58,15 @@ use middle::const_eval;\n use middle::ty::{arg, field, substs};\n use middle::ty::{ty_param_substs_and_ty};\n use middle::ty;\n-use middle::typeck::rscope::{in_binding_rscope};\n+use middle::typeck::rscope::{in_binding_rscope, in_binding_rscope_ext};\n use middle::typeck::rscope::{region_scope, type_rscope, RegionError};\n+use middle::typeck::rscope::{RegionParamNames};\n \n use core::result;\n use core::vec;\n use syntax::{ast, ast_util};\n use syntax::codemap::span;\n+use syntax::opt_vec::OptVec;\n use syntax::print::pprust::{lifetime_to_str, path_to_str};\n use syntax::parse::token::special_idents;\n use util::common::indenter;\n@@ -348,9 +350,15 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n                                             bf.abi, &bf.decl))\n       }\n       ast::ty_closure(ref f) => {\n-          let fn_decl = ty_of_closure(self, rscope, f.sigil,\n-                                      f.purity, f.onceness,\n-                                      f.region, &f.decl, None,\n+          let fn_decl = ty_of_closure(self,\n+                                      rscope,\n+                                      f.sigil,\n+                                      f.purity,\n+                                      f.onceness,\n+                                      f.region,\n+                                      &f.decl,\n+                                      None,\n+                                      &f.lifetimes,\n                                       ast_ty.span);\n           ty::mk_closure(tcx, fn_decl)\n       }\n@@ -507,7 +515,7 @@ pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Copy + Durable>(\n         abi: ast::Abi,\n         decl: &ast::fn_decl)\n      -> ty::BareFnTy {\n-    debug!(\"ty_of_fn_decl\");\n+    debug!(\"ty_of_bare_fn\");\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n@@ -526,6 +534,33 @@ pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Copy + Durable>(\n     }\n }\n \n+pub fn ty_of_bare_fn_ext<AC:AstConv,RS:region_scope + Copy + Durable>(\n+        self: &AC,\n+        rscope: &RS,\n+        purity: ast::purity,\n+        abi: ast::Abi,\n+        decl: &ast::fn_decl,\n+        +region_param_names: RegionParamNames)\n+     -> ty::BareFnTy {\n+    debug!(\"ty_of_bare_fn_ext\");\n+\n+    // new region names that appear inside of the fn decl are bound to\n+    // that function type\n+    let rb = in_binding_rscope_ext(rscope, region_param_names);\n+\n+    let input_tys = decl.inputs.map(|a| ty_of_arg(self, &rb, *a, None));\n+    let output_ty = match decl.output.node {\n+        ast::ty_infer => self.ty_infer(decl.output.span),\n+        _ => ast_ty_to_ty(self, &rb, decl.output)\n+    };\n+\n+    ty::BareFnTy {\n+        purity: purity,\n+        abi: abi,\n+        sig: ty::FnSig {inputs: input_tys, output: output_ty}\n+    }\n+}\n+\n pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + Durable>(\n         self: &AC,\n         rscope: &RS,\n@@ -535,6 +570,7 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + Durable>(\n         opt_lifetime: Option<@ast::Lifetime>,\n         decl: &ast::fn_decl,\n         expected_tys: Option<ty::FnSig>,\n+        lifetimes: &OptVec<ast::Lifetime>,\n         span: span)\n      -> ty::ClosureTy {\n     debug!(\"ty_of_fn_decl\");\n@@ -563,7 +599,8 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + Durable>(\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n-    let rb = in_binding_rscope(rscope);\n+    let region_param_names = RegionParamNames::from_lifetimes(lifetimes);\n+    let rb = in_binding_rscope_ext(rscope, region_param_names);\n \n     let input_tys = do decl.inputs.mapi |i, a| {\n         let expected_arg_ty = do expected_tys.chain_ref |e| {"}, {"sha": "75c6bfd5d6405ff7e9d89e85245bad7be9b04e5c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/15688eaf284b54d29e42b4ec415c23c94e567b23/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15688eaf284b54d29e42b4ec415c23c94e567b23/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=15688eaf284b54d29e42b4ec415c23c94e567b23", "patch": "@@ -100,7 +100,7 @@ use middle::typeck::CrateCtxt;\n use middle::typeck::infer::{resolve_type, force_tvar, mk_eqty};\n use middle::typeck::infer;\n use middle::typeck::rscope::{binding_rscope, bound_self_region};\n-use middle::typeck::rscope::{RegionError};\n+use middle::typeck::rscope::{RegionError, RegionParameterization};\n use middle::typeck::rscope::{in_binding_rscope, region_scope, type_rscope};\n use middle::typeck::rscope;\n use middle::typeck::{isr_alist, lookup_def_ccx, method_map_entry};\n@@ -126,10 +126,11 @@ use syntax::ast_util::{Private, Public, is_local, local_def};\n use syntax::ast_util;\n use syntax::codemap::{span, spanned, respan};\n use syntax::codemap;\n+use syntax::opt_vec::OptVec;\n+use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust;\n use syntax::visit;\n-use syntax::opt_vec::OptVec;\n use syntax;\n \n pub mod _match;\n@@ -570,10 +571,12 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       ast::item_fn(ref decl, _, _, ref body) => {\n         check_bare_fn(ccx, decl, body, it.id, None);\n       }\n-      ast::item_impl(_, _, ty, ref ms) => {\n+      ast::item_impl(ref generics, _, ty, ref ms) => {\n         let rp = ccx.tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n         debug!(\"item_impl %s with id %d rp %?\",\n                *ccx.tcx.sess.str_of(it.ident), it.id, rp);\n+        let rp = RegionParameterization::from_variance_and_generics(\n+            rp, generics);\n         let self_ty = ccx.to_ty(&rscope::type_rscope(rp), ty);\n         for ms.each |m| {\n             check_method(ccx, *m, self_ty);\n@@ -1069,9 +1072,13 @@ pub fn impl_self_ty(vcx: &VtableContext,\n                   node: ast::item_impl(ref ts, _, st, _),\n                   _\n               }, _)) => {\n+            let region_parameterization =\n+                RegionParameterization::from_variance_and_generics(\n+                    region_param,\n+                    ts);\n             (ts.ty_params.len(),\n              region_param,\n-             vcx.ccx.to_ty(&rscope::type_rscope(region_param), st))\n+             vcx.ccx.to_ty(&rscope::type_rscope(region_parameterization), st))\n           }\n           Some(&ast_map::node_item(@ast::item {\n                   node: ast::item_struct(_, ref ts),\n@@ -1654,10 +1661,16 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         };\n \n         // construct the function type\n-        let mut fn_ty = astconv::ty_of_closure(\n-            fcx, fcx,\n-            sigil, purity, expected_onceness,\n-            None, decl, expected_tys, expr.span);\n+        let mut fn_ty = astconv::ty_of_closure(fcx,\n+                                               fcx,\n+                                               sigil,\n+                                               purity,\n+                                               expected_onceness,\n+                                               None,\n+                                               decl,\n+                                               expected_tys,\n+                                               &opt_vec::Empty,\n+                                               expr.span);\n \n         let mut fty_sig;\n         let fty = if error_happened {"}, {"sha": "6d304247c5d5d2967a44a74c876696ec633788bb", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 74, "deletions": 38, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/15688eaf284b54d29e42b4ec415c23c94e567b23/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15688eaf284b54d29e42b4ec415c23c94e567b23/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=15688eaf284b54d29e42b4ec415c23c94e567b23", "patch": "@@ -166,12 +166,15 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n \n     // Create a set of parameter types shared among all the variants.\n     for variants.each |variant| {\n+        let region_parameterization =\n+            RegionParameterization::from_variance_and_generics(rp, generics);\n+\n         // Nullary enum constructors get turned into constants; n-ary enum\n         // constructors get turned into functions.\n         let result_ty;\n         match variant.node.kind {\n             ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n-                let rs = type_rscope(rp);\n+                let rs = type_rscope(region_parameterization);\n                 let input_tys = args.map(|va| ccx.to_ty(&rs, va.ty));\n                 result_ty = Some(ty::mk_ctor_fn(tcx, input_tys, enum_ty));\n             }\n@@ -301,7 +304,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                 ccx,\n                 &ty_m,\n                 region_paramd,\n-                def_id\n+                def_id,\n+                generics\n             );\n             if ty_m.self_ty.node == ast::sty_static {\n                 make_static_method_ty(ccx, &ty_m, region_paramd,\n@@ -319,13 +323,14 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n                           id: ast::node_id,\n                           sp: codemap::span,\n                           rp: Option<ty::region_variance>,\n-                          trait_refs: &[@ast::trait_ref]) {\n+                          trait_refs: &[@ast::trait_ref],\n+                          generics: &ast::Generics) {\n     let tcx = ccx.tcx;\n     if tcx.supertraits.contains_key(&local_def(id)) { return; }\n \n     let mut instantiated = ~[];\n     for trait_refs.each |trait_ref| {\n-        let (did, tpt) = instantiate_trait_ref(ccx, *trait_ref, rp);\n+        let (did, tpt) = instantiate_trait_ref(ccx, *trait_ref, rp, generics);\n         if instantiated.any(|other_trait: &InstantiatedTraitRef|\n                             { other_trait.def_id == did }) {\n             // This means a trait inherited from the same supertrait more\n@@ -506,7 +511,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n                                    impl_ms: &[ConvertedMethod]) {\n \n     let tcx = ccx.tcx;\n-    let (did, tpt) = instantiate_trait_ref(ccx, a_trait_ty, rp);\n+    let (did, tpt) = instantiate_trait_ref(ccx, a_trait_ty, rp, generics);\n \n     if did.crate == ast::local_crate {\n         // NB: This is subtle. We need to do this on the type of the trait\n@@ -553,8 +558,11 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n pub fn convert_field(ccx: &CrateCtxt,\n                      rp: Option<ty::region_variance>,\n                      bounds: @~[ty::param_bounds],\n-                     v: @ast::struct_field) {\n-    let tt = ccx.to_ty(&type_rscope(rp), v.node.ty);\n+                     v: @ast::struct_field,\n+                     generics: &ast::Generics) {\n+    let region_parameterization =\n+        RegionParameterization::from_variance_and_generics(rp, generics);\n+    let tt = ccx.to_ty(&type_rscope(region_parameterization), v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n     ccx.tcx.tcache.insert(local_def(v.node.id),\n@@ -575,13 +583,14 @@ pub struct ConvertedMethod {\n pub fn convert_methods(ccx: &CrateCtxt,\n                        ms: &[@ast::method],\n                        rp: Option<ty::region_variance>,\n-                       rcvr_bounds: @~[ty::param_bounds])\n+                       rcvr_bounds: @~[ty::param_bounds],\n+                       rcvr_generics: &ast::Generics)\n                     -> ~[ConvertedMethod] {\n \n     let tcx = ccx.tcx;\n     do vec::map(ms) |m| {\n         let bounds = ty_param_bounds(ccx, &m.generics);\n-        let mty = ty_of_method(ccx, *m, rp);\n+        let mty = ty_of_method(ccx, *m, rp, rcvr_generics, &m.generics);\n         let fty = ty::mk_bare_fn(tcx, copy mty.fty);\n         tcx.tcache.insert(\n             local_def(m.id),\n@@ -633,7 +642,9 @@ pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n       }\n       ast::item_impl(ref generics, trait_ref, selfty, ref ms) => {\n         let i_bounds = ty_param_bounds(ccx, generics);\n-        let selfty = ccx.to_ty(&type_rscope(rp), selfty);\n+        let region_parameterization =\n+            RegionParameterization::from_variance_and_generics(rp, generics);\n+        let selfty = ccx.to_ty(&type_rscope(region_parameterization), selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n         tcx.tcache.insert(local_def(it.id),\n                           ty_param_bounds_and_ty {\n@@ -642,7 +653,7 @@ pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n                             ty: selfty});\n \n         // XXX: Bad copy of `ms` below.\n-        let cms = convert_methods(ccx, *ms, rp, i_bounds);\n+        let cms = convert_methods(ccx, *ms, rp, i_bounds, generics);\n         for trait_ref.each |t| {\n             check_methods_against_trait(ccx, generics, rp, selfty, *t, cms);\n         }\n@@ -653,12 +664,12 @@ pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n                it.id, ppaux::ty_to_str(tcx, tpt.ty));\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         ensure_trait_methods(ccx, it.id, tpt.ty);\n-        ensure_supertraits(ccx, it.id, it.span, rp, *supertraits);\n+        ensure_supertraits(ccx, it.id, it.span, rp, *supertraits, generics);\n \n         let (_, provided_methods) =\n             split_trait_methods(*trait_methods);\n         let (bounds, _) = mk_substs(ccx, generics, rp);\n-        let _ = convert_methods(ccx, provided_methods, rp, bounds);\n+        let _ = convert_methods(ccx, provided_methods, rp, bounds, generics);\n       }\n       ast::item_struct(struct_def, ref generics) => {\n         ensure_no_ty_param_bounds(ccx, it.span, generics, \"structure\");\n@@ -694,12 +705,17 @@ pub fn convert_struct(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n \n     for struct_def.dtor.each |dtor| {\n+        let region_parameterization =\n+            RegionParameterization::from_variance_and_generics(rp, generics);\n+\n         // Write the dtor type\n         let t_dtor = ty::mk_bare_fn(\n             tcx,\n             astconv::ty_of_bare_fn(\n-                ccx, &type_rscope(rp),\n-                ast::impure_fn, ast::RustAbi,\n+                ccx,\n+                &type_rscope(region_parameterization),\n+                ast::impure_fn,\n+                ast::RustAbi,\n                 &ast_util::dtor_dec()));\n         write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n         tcx.tcache.insert(local_def(dtor.node.id),\n@@ -711,7 +727,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n \n     // Write the type of each of the members\n     for struct_def.fields.each |f| {\n-       convert_field(ccx, rp, tpt.bounds, *f);\n+       convert_field(ccx, rp, tpt.bounds, *f, generics);\n     }\n     let (_, substs) = mk_substs(ccx, generics, rp);\n     let selfty = ty::mk_struct(tcx, local_def(id), substs);\n@@ -754,17 +770,23 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: @ast::foreign_item) {\n \n pub fn ty_of_method(ccx: &CrateCtxt,\n                     m: @ast::method,\n-                    rp: Option<ty::region_variance>) -> ty::method {\n-    let rscope = MethodRscope {\n-        self_ty: m.self_ty.node,\n-        region_parameterization: rp\n-    };\n-\n+                    rp: Option<ty::region_variance>,\n+                    rcvr_generics: &ast::Generics,\n+                    method_generics: &ast::Generics)\n+                 -> ty::method {\n+    let rscope = MethodRscope::new(m.self_ty.node,\n+                                   rp,\n+                                   rcvr_generics,\n+                                   method_generics);\n     ty::method {\n         ident: m.ident,\n         tps: ty_param_bounds(ccx, &m.generics),\n-        fty: astconv::ty_of_bare_fn(ccx, &rscope, m.purity,\n-                                    ast::RustAbi, &m.decl),\n+        fty: astconv::ty_of_bare_fn_ext(ccx,\n+                                        &rscope,\n+                                        m.purity,\n+                                        ast::RustAbi,\n+                                        &m.decl,\n+                                        rscope.region_param_names()),\n         self_ty: m.self_ty.node,\n         vis: m.vis,\n         def_id: local_def(m.id)\n@@ -774,17 +796,19 @@ pub fn ty_of_method(ccx: &CrateCtxt,\n pub fn ty_of_ty_method(self: &CrateCtxt,\n                        m: &ast::ty_method,\n                        rp: Option<ty::region_variance>,\n-                       id: ast::def_id) -> ty::method {\n-    let rscope = MethodRscope {\n-        self_ty: m.self_ty.node,\n-        region_parameterization: rp\n-    };\n-\n+                       id: ast::def_id,\n+                       generics: &ast::Generics)\n+                    -> ty::method {\n+    let rscope = MethodRscope::new(m.self_ty.node, rp, generics, &m.generics);\n     ty::method {\n         ident: m.ident,\n         tps: ty_param_bounds(self, &m.generics),\n-        fty: astconv::ty_of_bare_fn(self, &rscope, m.purity,\n-                                    ast::RustAbi, &m.decl),\n+        fty: astconv::ty_of_bare_fn_ext(self,\n+                                        &rscope,\n+                                        m.purity,\n+                                        ast::RustAbi,\n+                                        &m.decl,\n+                                        rscope.region_param_names()),\n         // assume public, because this is only invoked on trait methods\n         self_ty: m.self_ty.node,\n         vis: ast::public,\n@@ -797,13 +821,17 @@ pub fn ty_of_ty_method(self: &CrateCtxt,\n   it's bound to a valid trait type. Returns the def_id for the defining\n   trait. Fails if the type is a type other than an trait type.\n  */\n-pub fn instantiate_trait_ref(ccx: &CrateCtxt, t: @ast::trait_ref,\n-                             rp: Option<ty::region_variance>)\n+pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n+                             t: @ast::trait_ref,\n+                             rp: Option<ty::region_variance>,\n+                             generics: &ast::Generics)\n     -> (ast::def_id, ty_param_substs_and_ty) {\n \n     let sp = t.path.span, err = ~\"can only implement trait types\",\n         sess = ccx.tcx.sess;\n \n+    let rp = RegionParameterization::from_variance_and_generics(rp, generics);\n+\n     let rscope = type_rscope(rp);\n \n     match lookup_def_tcx(ccx.tcx, t.path.span, t.ref_id) {\n@@ -841,8 +869,13 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n       }\n       ast::item_fn(ref decl, purity, ref generics, _) => {\n         let bounds = ty_param_bounds(ccx, generics);\n-        let tofd = astconv::ty_of_bare_fn(ccx, &empty_rscope, purity,\n-                                          ast::RustAbi, decl);\n+        let region_param_names = RegionParamNames::from_generics(generics);\n+        let tofd = astconv::ty_of_bare_fn_ext(ccx,\n+                                              &empty_rscope,\n+                                              purity,\n+                                              ast::RustAbi,\n+                                              decl,\n+                                              region_param_names);\n         let tpt = ty_param_bounds_and_ty {\n             bounds: bounds,\n             region_param: None,\n@@ -862,9 +895,11 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n         }\n \n         let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n+        let region_parameterization =\n+            RegionParameterization::from_variance_and_generics(rp, generics);\n         let tpt = {\n             let ty = {\n-                let t0 = ccx.to_ty(&type_rscope(rp), t);\n+                let t0 = ccx.to_ty(&type_rscope(region_parameterization), t);\n                 // Do not associate a def id with a named, parameterized type\n                 // like \"foo<X>\".  This is because otherwise ty_to_str will\n                 // print the name as merely \"foo\", as it has no way to\n@@ -1007,7 +1042,8 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                              generics: &ast::Generics)\n                           -> ty::ty_param_bounds_and_ty {\n     let bounds = ty_param_bounds(ccx, generics);\n-    let rb = in_binding_rscope(&empty_rscope);\n+    let region_param_names = RegionParamNames::from_generics(generics);\n+    let rb = in_binding_rscope_ext(&empty_rscope, region_param_names);\n     let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, &rb, *a, None) );\n     let output_ty = ast_ty_to_ty(ccx, &rb, decl.output);\n "}, {"sha": "135993e18a20a9b0c437f0c83bb5624d4001d4e2", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 184, "deletions": 11, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/15688eaf284b54d29e42b4ec415c23c94e567b23/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15688eaf284b54d29e42b4ec415c23c94e567b23/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=15688eaf284b54d29e42b4ec415c23c94e567b23", "patch": "@@ -16,6 +16,9 @@ use core::result::Result;\n use core::result;\n use syntax::ast;\n use syntax::codemap::span;\n+use syntax::opt_vec::OptVec;\n+use syntax::opt_vec;\n+use syntax::parse::token::special_idents;\n \n pub struct RegionError {\n     msg: ~str,\n@@ -47,10 +50,130 @@ impl region_scope for empty_rscope {\n     }\n }\n \n+pub struct RegionParamNames(OptVec<ast::ident>);\n+\n+impl RegionParamNames {\n+    fn has_self(&self) -> bool {\n+        self.has_ident(special_idents::self_)\n+    }\n+\n+    fn has_ident(&self, ident: ast::ident) -> bool {\n+        for self.each |region_param_name| {\n+            if *region_param_name == ident {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n+    pub fn add_generics(&mut self, generics: &ast::Generics) {\n+        match generics.lifetimes {\n+            opt_vec::Empty => {}\n+            opt_vec::Vec(ref new_lifetimes) => {\n+                match **self {\n+                    opt_vec::Empty => {\n+                        *self = RegionParamNames(\n+                            opt_vec::Vec(new_lifetimes.map(|lt| lt.ident)));\n+                    }\n+                    opt_vec::Vec(ref mut existing_lifetimes) => {\n+                        for new_lifetimes.each |new_lifetime| {\n+                            existing_lifetimes.push(new_lifetime.ident);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Convenience function to produce the error for an unresolved name. The\n+    // optional argument specifies a custom replacement.\n+    pub fn undeclared_name(custom_replacement: Option<ty::Region>)\n+                        -> Result<ty::Region, RegionError> {\n+        let replacement = match custom_replacement {\n+            None => ty::re_bound(ty::br_self),\n+            Some(custom_replacement) => custom_replacement\n+        };\n+        Err(RegionError {\n+            msg: ~\"this lifetime must be declared\",\n+            replacement: replacement\n+        })\n+    }\n+\n+    pub fn from_generics(generics: &ast::Generics) -> RegionParamNames {\n+        match generics.lifetimes {\n+            opt_vec::Empty => RegionParamNames(opt_vec::Empty),\n+            opt_vec::Vec(ref lifetimes) => {\n+                RegionParamNames(opt_vec::Vec(lifetimes.map(|lt| lt.ident)))\n+            }\n+        }\n+    }\n+\n+    pub fn from_lifetimes(lifetimes: &opt_vec::OptVec<ast::Lifetime>)\n+                       -> RegionParamNames {\n+        match *lifetimes {\n+            opt_vec::Empty => RegionParamNames::new(),\n+            opt_vec::Vec(ref v) => {\n+                RegionParamNames(opt_vec::Vec(v.map(|lt| lt.ident)))\n+            }\n+        }\n+    }\n+\n+    fn new() -> RegionParamNames {\n+        RegionParamNames(opt_vec::Empty)\n+    }\n+}\n+\n+struct RegionParameterization {\n+    variance: ty::region_variance,\n+    region_param_names: RegionParamNames,\n+}\n+\n+impl RegionParameterization {\n+    pub fn from_variance_and_generics(variance: Option<ty::region_variance>,\n+                                      generics: &ast::Generics)\n+                                   -> Option<RegionParameterization> {\n+        match variance {\n+            None => None,\n+            Some(variance) => {\n+                Some(RegionParameterization {\n+                    variance: variance,\n+                    region_param_names:\n+                        RegionParamNames::from_generics(generics),\n+                })\n+            }\n+        }\n+    }\n+}\n+\n pub struct MethodRscope {\n     self_ty: ast::self_ty_,\n-    region_parameterization: Option<ty::region_variance>\n+    variance: Option<ty::region_variance>,\n+    region_param_names: RegionParamNames,\n+}\n+\n+impl MethodRscope {\n+    // `generics` here refers to the generics of the outer item (impl or\n+    // trait).\n+    pub fn new(self_ty: ast::self_ty_,\n+               variance: Option<ty::region_variance>,\n+               rcvr_generics: &ast::Generics,\n+               method_generics: &ast::Generics)\n+            -> MethodRscope {\n+        let mut region_param_names =\n+            RegionParamNames::from_generics(rcvr_generics);\n+        region_param_names.add_generics(method_generics);\n+        MethodRscope {\n+            self_ty: self_ty,\n+            variance: variance,\n+            region_param_names: region_param_names\n+        }\n+    }\n+\n+    pub fn region_param_names(&self) -> RegionParamNames {\n+        copy self.region_param_names\n+    }\n }\n+\n impl region_scope for MethodRscope {\n     fn anon_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n         result::Err(RegionError {\n@@ -59,12 +182,26 @@ impl region_scope for MethodRscope {\n         })\n     }\n     fn self_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n-        fail_unless!(self.region_parameterization.is_some() ||\n-            self.self_ty.is_borrowed());\n+        fail_unless!(self.variance.is_some() || self.self_ty.is_borrowed());\n+        match self.variance {\n+            None => {}  // must be borrowed self, so this is OK\n+            Some(_) => {\n+                if !self.self_ty.is_borrowed() &&\n+                        !self.region_param_names.has_self() {\n+                    return Err(RegionError {\n+                        msg: ~\"the `self` lifetime must be declared\",\n+                        replacement: ty::re_bound(ty::br_self)\n+                    })\n+                }\n+            }\n+        }\n         result::Ok(ty::re_bound(ty::br_self))\n     }\n     fn named_region(&self, span: span, id: ast::ident)\n                       -> Result<ty::Region, RegionError> {\n+        if !self.region_param_names.has_ident(id) {\n+            return RegionParamNames::undeclared_name(None);\n+        }\n         do empty_rscope.named_region(span, id).chain_err |_e| {\n             result::Err(RegionError {\n                 msg: ~\"lifetime is not in scope\",\n@@ -74,7 +211,7 @@ impl region_scope for MethodRscope {\n     }\n }\n \n-pub struct type_rscope(Option<ty::region_variance>);\n+pub struct type_rscope(Option<RegionParameterization>);\n \n impl type_rscope {\n     priv fn replacement(&self) -> ty::Region {\n@@ -93,17 +230,29 @@ impl region_scope for type_rscope {\n         })\n     }\n     fn self_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n-        // if the self region is used, region parameterization should\n-        // have inferred that this type is RP\n-        fail_unless!(self.is_some());\n+        match **self {\n+            None => {\n+                // if the self region is used, region parameterization should\n+                // have inferred that this type is RP\n+                fail!(~\"region parameterization should have inferred that \\\n+                        this type is RP\");\n+            }\n+            Some(ref region_parameterization) => {\n+                if !region_parameterization.region_param_names.has_self() {\n+                    return Err(RegionError {\n+                        msg: ~\"the `self` lifetime must be declared\",\n+                        replacement: ty::re_bound(ty::br_self)\n+                    })\n+                }\n+            }\n+        }\n         result::Ok(ty::re_bound(ty::br_self))\n     }\n     fn named_region(&self, span: span, id: ast::ident)\n                       -> Result<ty::Region, RegionError> {\n         do empty_rscope.named_region(span, id).chain_err |_e| {\n             result::Err(RegionError {\n-                msg: ~\"only 'self is allowed allowed as \\\n-                       part of a type declaration\",\n+                msg: ~\"only 'self is allowed as part of a type declaration\",\n                 replacement: self.replacement()\n             })\n         }\n@@ -121,14 +270,33 @@ pub fn bound_self_region(rp: Option<ty::region_variance>)\n pub struct binding_rscope {\n     base: @region_scope,\n     anon_bindings: @mut uint,\n+    region_param_names: RegionParamNames,\n }\n \n pub fn in_binding_rscope<RS:region_scope + Copy + Durable>(self: &RS)\n     -> binding_rscope {\n     let base = @copy *self;\n     let base = base as @region_scope;\n-    binding_rscope { base: base, anon_bindings: @mut 0 }\n+    binding_rscope {\n+        base: base,\n+        anon_bindings: @mut 0,\n+        region_param_names: RegionParamNames::new()\n+    }\n }\n+\n+pub fn in_binding_rscope_ext<RS:region_scope + Copy + Durable>(\n+        self: &RS,\n+        +region_param_names: RegionParamNames)\n+     -> binding_rscope {\n+    let base = @copy *self;\n+    let base = base as @region_scope;\n+    binding_rscope {\n+        base: base,\n+        anon_bindings: @mut 0,\n+        region_param_names: region_param_names,\n+    }\n+}\n+\n impl region_scope for binding_rscope {\n     fn anon_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n         let idx = *self.anon_bindings;\n@@ -143,7 +311,12 @@ impl region_scope for binding_rscope {\n                     id: ast::ident) -> Result<ty::Region, RegionError>\n     {\n         do self.base.named_region(span, id).chain_err |_e| {\n-            result::Ok(ty::re_bound(ty::br_named(id)))\n+            let result = ty::re_bound(ty::br_named(id));\n+            if self.region_param_names.has_ident(id) {\n+                result::Ok(result)\n+            } else {\n+                RegionParamNames::undeclared_name(Some(result))\n+            }\n         }\n     }\n }"}]}