{"sha": "283abbf0e7d20176f76006825b5c52e9a4234e4c", "node_id": "C_kwDOAAsO6NoAKDI4M2FiYmYwZTdkMjAxNzZmNzYwMDY4MjViNWM1MmU5YTQyMzRlNGM", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-09-20T03:03:59Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-10-07T12:10:40Z"}, "message": "Change InferCtxtBuilder from enter to build", "tree": {"sha": "169a55f89da9def5accb58df926ef0efd1cdf46d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/169a55f89da9def5accb58df926ef0efd1cdf46d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/283abbf0e7d20176f76006825b5c52e9a4234e4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/283abbf0e7d20176f76006825b5c52e9a4234e4c", "html_url": "https://github.com/rust-lang/rust/commit/283abbf0e7d20176f76006825b5c52e9a4234e4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/283abbf0e7d20176f76006825b5c52e9a4234e4c/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91269fa5b8a7272a2a45b0b5e8a6fa4be24fe96a", "url": "https://api.github.com/repos/rust-lang/rust/commits/91269fa5b8a7272a2a45b0b5e8a6fa4be24fe96a", "html_url": "https://github.com/rust-lang/rust/commit/91269fa5b8a7272a2a45b0b5e8a6fa4be24fe96a"}], "stats": {"total": 4184, "additions": 1984, "deletions": 2200}, "files": [{"sha": "b162095f8a6cdf0692738aaaa1fe3d4205782ca4", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -31,9 +31,8 @@ pub fn get_body_with_borrowck_facts<'tcx>(\n     def: ty::WithOptConstParam<LocalDefId>,\n ) -> BodyWithBorrowckFacts<'tcx> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n-    tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(def.did)).enter(|infcx| {\n-        let input_body: &Body<'_> = &input_body.borrow();\n-        let promoted: &IndexVec<_, _> = &promoted.borrow();\n-        *super::do_mir_borrowck(&infcx, input_body, promoted, true).1.unwrap()\n-    })\n+    let infcx = tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(def.did)).build();\n+    let input_body: &Body<'_> = &input_body.borrow();\n+    let promoted: &IndexVec<_, _> = &promoted.borrow();\n+    *super::do_mir_borrowck(&infcx, input_body, promoted, true).1.unwrap()\n }"}, {"sha": "02071ed6b36662975346651590ec08d5e74fb17a", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 28, "deletions": 60, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -238,20 +238,11 @@ impl<'tcx> TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        mbcx.infcx.tcx.infer_ctxt().enter_with_canonical(\n-            cause.span,\n-            &self.canonical_query,\n-            |ref infcx, key, _| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-                type_op_prove_predicate_with_cause(infcx, &mut *fulfill_cx, key, cause);\n-                try_extract_error_from_fulfill_cx(\n-                    fulfill_cx,\n-                    infcx,\n-                    placeholder_region,\n-                    error_region,\n-                )\n-            },\n-        )\n+        let (ref infcx, key, _) =\n+            mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n+        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+        type_op_prove_predicate_with_cause(infcx, &mut *fulfill_cx, key, cause);\n+        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n     }\n }\n \n@@ -288,37 +279,24 @@ where\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        mbcx.infcx.tcx.infer_ctxt().enter_with_canonical(\n-            cause.span,\n-            &self.canonical_query,\n-            |ref infcx, key, _| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n-                let mut selcx = SelectionContext::new(infcx);\n-\n-                // FIXME(lqd): Unify and de-duplicate the following with the actual\n-                // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n-                // `ObligationCause`. The normalization results are currently different between\n-                // `AtExt::normalize` used in the query and `normalize` called below: the former fails\n-                // to normalize the `nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs` test. Check\n-                // after #85499 lands to see if its fixes have erased this difference.\n-                let (param_env, value) = key.into_parts();\n-                let Normalized { value: _, obligations } = rustc_trait_selection::traits::normalize(\n-                    &mut selcx,\n-                    param_env,\n-                    cause,\n-                    value.value,\n-                );\n-                fulfill_cx.register_predicate_obligations(infcx, obligations);\n-\n-                try_extract_error_from_fulfill_cx(\n-                    fulfill_cx,\n-                    infcx,\n-                    placeholder_region,\n-                    error_region,\n-                )\n-            },\n-        )\n+        let (ref infcx, key, _) =\n+            mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n+        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+\n+        let mut selcx = SelectionContext::new(infcx);\n+\n+        // FIXME(lqd): Unify and de-duplicate the following with the actual\n+        // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n+        // `ObligationCause`. The normalization results are currently different between\n+        // `AtExt::normalize` used in the query and `normalize` called below: the former fails\n+        // to normalize the `nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs` test. Check\n+        // after #85499 lands to see if its fixes have erased this difference.\n+        let (param_env, value) = key.into_parts();\n+        let Normalized { value: _, obligations } =\n+            rustc_trait_selection::traits::normalize(&mut selcx, param_env, cause, value.value);\n+        fulfill_cx.register_predicate_obligations(infcx, obligations);\n+\n+        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n     }\n }\n \n@@ -349,21 +327,11 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        mbcx.infcx.tcx.infer_ctxt().enter_with_canonical(\n-            cause.span,\n-            &self.canonical_query,\n-            |ref infcx, key, _| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-                type_op_ascribe_user_type_with_span(infcx, &mut *fulfill_cx, key, Some(cause.span))\n-                    .ok()?;\n-                try_extract_error_from_fulfill_cx(\n-                    fulfill_cx,\n-                    infcx,\n-                    placeholder_region,\n-                    error_region,\n-                )\n-            },\n-        )\n+        let (ref infcx, key, _) =\n+            mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n+        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+        type_op_ascribe_user_type_with_span(infcx, &mut *fulfill_cx, key, Some(cause.span)).ok()?;\n+        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n     }\n }\n "}, {"sha": "2a8bd4d30abbffcd630417db567c0a273e3db6ac", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -492,11 +492,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let Some(default_trait) = tcx.get_diagnostic_item(sym::Default) else {\n                 return false;\n             };\n-            tcx.infer_ctxt().enter(|infcx| {\n-                infcx\n-                    .type_implements_trait(default_trait, ty, ty::List::empty(), param_env)\n-                    .may_apply()\n-            })\n+            tcx.infer_ctxt()\n+                .build()\n+                .type_implements_trait(default_trait, ty, ty::List::empty(), param_env)\n+                .may_apply()\n         };\n \n         let assign_value = match ty.kind() {\n@@ -606,41 +605,40 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .and_then(|def_id| tcx.hir().get_generics(def_id))\n         else { return; };\n         // Try to find predicates on *generic params* that would allow copying `ty`\n-        let predicates: Result<Vec<_>, _> = tcx.infer_ctxt().enter(|infcx| {\n-            let mut fulfill_cx = <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n+        let infcx = tcx.infer_ctxt().build();\n+        let mut fulfill_cx = <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n \n-            let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n-            let cause = ObligationCause::new(\n-                span,\n-                self.mir_hir_id(),\n-                rustc_infer::traits::ObligationCauseCode::MiscObligation,\n-            );\n-            fulfill_cx.register_bound(\n-                &infcx,\n-                self.param_env,\n-                // Erase any region vids from the type, which may not be resolved\n-                infcx.tcx.erase_regions(ty),\n-                copy_did,\n-                cause,\n-            );\n-            // Select all, including ambiguous predicates\n-            let errors = fulfill_cx.select_all_or_error(&infcx);\n-\n-            // Only emit suggestion if all required predicates are on generic\n-            errors\n-                .into_iter()\n-                .map(|err| match err.obligation.predicate.kind().skip_binder() {\n-                    PredicateKind::Trait(predicate) => match predicate.self_ty().kind() {\n-                        ty::Param(param_ty) => Ok((\n-                            generics.type_param(param_ty, tcx),\n-                            predicate.trait_ref.print_only_trait_path().to_string(),\n-                        )),\n-                        _ => Err(()),\n-                    },\n+        let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n+        let cause = ObligationCause::new(\n+            span,\n+            self.mir_hir_id(),\n+            rustc_infer::traits::ObligationCauseCode::MiscObligation,\n+        );\n+        fulfill_cx.register_bound(\n+            &infcx,\n+            self.param_env,\n+            // Erase any region vids from the type, which may not be resolved\n+            infcx.tcx.erase_regions(ty),\n+            copy_did,\n+            cause,\n+        );\n+        // Select all, including ambiguous predicates\n+        let errors = fulfill_cx.select_all_or_error(&infcx);\n+\n+        // Only emit suggestion if all required predicates are on generic\n+        let predicates: Result<Vec<_>, _> = errors\n+            .into_iter()\n+            .map(|err| match err.obligation.predicate.kind().skip_binder() {\n+                PredicateKind::Trait(predicate) => match predicate.self_ty().kind() {\n+                    ty::Param(param_ty) => Ok((\n+                        generics.type_param(param_ty, tcx),\n+                        predicate.trait_ref.print_only_trait_path().to_string(),\n+                    )),\n                     _ => Err(()),\n-                })\n-                .collect()\n-        });\n+                },\n+                _ => Err(()),\n+            })\n+            .collect();\n \n         if let Ok(predicates) = predicates {\n             suggest_constraining_type_params("}, {"sha": "534d9ecae6e6f0788d336bc7ac8b03110cc02482", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -1025,7 +1025,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if let Some((CallDesugaringKind::ForLoopIntoIter, _)) = desugaring {\n                         let ty = moved_place.ty(self.body, self.infcx.tcx).ty;\n                         let suggest = match self.infcx.tcx.get_diagnostic_item(sym::IntoIterator) {\n-                            Some(def_id) => self.infcx.tcx.infer_ctxt().enter(|infcx| {\n+                            Some(def_id) => {\n+                                let infcx = self.infcx.tcx.infer_ctxt().build();\n                                 type_known_to_meet_bound_modulo_regions(\n                                     &infcx,\n                                     self.param_env,\n@@ -1036,7 +1037,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     def_id,\n                                     DUMMY_SP,\n                                 )\n-                            }),\n+                            }\n                             _ => false,\n                         };\n                         if suggest {"}, {"sha": "abfe253d43df7edbf41cfdbba0e7c3bd474a56ae", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -131,14 +131,11 @@ fn mir_borrowck<'tcx>(\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n     let hir_owner = tcx.hir().local_def_id_to_hir_id(def.did).owner;\n \n-    let opt_closure_req = tcx\n-        .infer_ctxt()\n-        .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id))\n-        .enter(|infcx| {\n-            let input_body: &Body<'_> = &input_body.borrow();\n-            let promoted: &IndexVec<_, _> = &promoted.borrow();\n-            do_mir_borrowck(&infcx, input_body, promoted, false).0\n-        });\n+    let infcx =\n+        tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id)).build();\n+    let input_body: &Body<'_> = &input_body.borrow();\n+    let promoted: &IndexVec<_, _> = &promoted.borrow();\n+    let opt_closure_req = do_mir_borrowck(&infcx, input_body, promoted, false).0;\n     debug!(\"mir_borrowck done\");\n \n     tcx.arena.alloc(opt_closure_req)"}, {"sha": "a7c4671665f43915c4702c9859a761a75c3fd2ee", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 57, "deletions": 61, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -266,73 +266,69 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n \n         // Only check this for TAIT. RPIT already supports `src/test/ui/impl-trait/nested-return-type2.rs`\n         // on stable and we'd break that.\n-        if let OpaqueTyOrigin::TyAlias = origin {\n-            // This logic duplicates most of `check_opaque_meets_bounds`.\n-            // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n-            let param_env = self.tcx.param_env(def_id);\n-            let body_id = self.tcx.local_def_id_to_hir_id(def_id);\n-            // HACK This bubble is required for this tests to pass:\n-            // type-alias-impl-trait/issue-67844-nested-opaque.rs\n-            self.tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).enter(\n-                move |infcx| {\n-                    // Require the hidden type to be well-formed with only the generics of the opaque type.\n-                    // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n-                    // hidden type is well formed even without those bounds.\n-                    let predicate =\n-                        ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n-                            .to_predicate(infcx.tcx);\n-                    let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-\n-                    // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n-                    // the bounds that the function supplies.\n-                    match infcx.register_hidden_type(\n-                        OpaqueTypeKey { def_id, substs: id_substs },\n-                        ObligationCause::misc(instantiated_ty.span, body_id),\n-                        param_env,\n+        let OpaqueTyOrigin::TyAlias = origin else {\n+            return definition_ty;\n+        };\n+        // This logic duplicates most of `check_opaque_meets_bounds`.\n+        // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n+        let param_env = self.tcx.param_env(def_id);\n+        let body_id = self.tcx.local_def_id_to_hir_id(def_id);\n+        // HACK This bubble is required for this tests to pass:\n+        // type-alias-impl-trait/issue-67844-nested-opaque.rs\n+        let infcx =\n+            self.tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).build();\n+        // Require the hidden type to be well-formed with only the generics of the opaque type.\n+        // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n+        // hidden type is well formed even without those bounds.\n+        let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n+            .to_predicate(infcx.tcx);\n+        let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n+\n+        // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n+        // the bounds that the function supplies.\n+        match infcx.register_hidden_type(\n+            OpaqueTypeKey { def_id, substs: id_substs },\n+            ObligationCause::misc(instantiated_ty.span, body_id),\n+            param_env,\n+            definition_ty,\n+            origin,\n+        ) {\n+            Ok(infer_ok) => {\n+                for obligation in infer_ok.obligations {\n+                    fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n+                }\n+            }\n+            Err(err) => {\n+                infcx\n+                    .err_ctxt()\n+                    .report_mismatched_types(\n+                        &ObligationCause::misc(instantiated_ty.span, body_id),\n+                        self.tcx.mk_opaque(def_id.to_def_id(), id_substs),\n                         definition_ty,\n-                        origin,\n-                    ) {\n-                        Ok(infer_ok) => {\n-                            for obligation in infer_ok.obligations {\n-                                fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n-                            }\n-                        }\n-                        Err(err) => {\n-                            infcx\n-                                .err_ctxt()\n-                                .report_mismatched_types(\n-                                    &ObligationCause::misc(instantiated_ty.span, body_id),\n-                                    self.tcx.mk_opaque(def_id.to_def_id(), id_substs),\n-                                    definition_ty,\n-                                    err,\n-                                )\n-                                .emit();\n-                        }\n-                    }\n+                        err,\n+                    )\n+                    .emit();\n+            }\n+        }\n \n-                    fulfillment_cx.register_predicate_obligation(\n-                        &infcx,\n-                        Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n-                    );\n+        fulfillment_cx.register_predicate_obligation(\n+            &infcx,\n+            Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n+        );\n \n-                    // Check that all obligations are satisfied by the implementation's\n-                    // version.\n-                    let errors = fulfillment_cx.select_all_or_error(&infcx);\n+        // Check that all obligations are satisfied by the implementation's\n+        // version.\n+        let errors = fulfillment_cx.select_all_or_error(&infcx);\n \n-                    // This is still required for many(half of the tests in ui/type-alias-impl-trait)\n-                    // tests to pass\n-                    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+        // This is still required for many(half of the tests in ui/type-alias-impl-trait)\n+        // tests to pass\n+        let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n \n-                    if errors.is_empty() {\n-                        definition_ty\n-                    } else {\n-                        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n-                        self.tcx.ty_error()\n-                    }\n-                },\n-            )\n-        } else {\n+        if errors.is_empty() {\n             definition_ty\n+        } else {\n+            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+            self.tcx.ty_error()\n         }\n     }\n }"}, {"sha": "5eaddf682c3481d7975a82561076d9125946d300", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -737,14 +737,16 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     let obligation =\n                         Obligation::new(ObligationCause::dummy(), param_env, poly_trait_pred);\n \n-                    let implsrc = tcx.infer_ctxt().enter(|infcx| {\n+                    let implsrc = {\n+                        let infcx = tcx.infer_ctxt().build();\n                         let mut selcx = SelectionContext::new(&infcx);\n                         selcx.select(&obligation)\n-                    });\n+                    };\n \n                     // do a well-formedness check on the trait method being called. This is because typeck only does a\n                     // \"non-const\" check. This is required for correctness here.\n-                    tcx.infer_ctxt().enter(|infcx| {\n+                    {\n+                        let infcx = tcx.infer_ctxt().build();\n                         let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n                         let predicates = tcx.predicates_of(callee).instantiate(tcx, substs);\n                         let hir_id = tcx\n@@ -777,7 +779,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                         if !errors.is_empty() {\n                             infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n                         }\n-                    });\n+                    }\n \n                     match implsrc {\n                         Ok(Some(ImplSource::Param(_, ty::BoundConstness::ConstIfConst))) => {\n@@ -835,16 +837,15 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n                                 // improve diagnostics by showing what failed. Our requirements are stricter this time\n                                 // as we are going to error again anyways.\n-                                tcx.infer_ctxt().enter(|infcx| {\n-                                    if let Err(e) = implsrc {\n-                                        infcx.err_ctxt().report_selection_error(\n-                                            obligation.clone(),\n-                                            &obligation,\n-                                            &e,\n-                                            false,\n-                                        );\n-                                    }\n-                                });\n+                                let infcx = tcx.infer_ctxt().build();\n+                                if let Err(e) = implsrc {\n+                                    infcx.err_ctxt().report_selection_error(\n+                                        obligation.clone(),\n+                                        &obligation,\n+                                        &e,\n+                                        false,\n+                                    );\n+                                }\n \n                                 self.check_op(ops::FnCallNonConst {\n                                     caller,"}, {"sha": "b28d70194917bca694981d5b90d88e0f884a6873", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -156,10 +156,9 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                         }),\n                     );\n \n-                    let implsrc = tcx.infer_ctxt().enter(|infcx| {\n-                        let mut selcx = SelectionContext::new(&infcx);\n-                        selcx.select(&obligation)\n-                    });\n+                    let infcx = tcx.infer_ctxt().build();\n+                    let mut selcx = SelectionContext::new(&infcx);\n+                    let implsrc = selcx.select(&obligation);\n \n                     if let Ok(Some(ImplSource::UserDefined(data))) = implsrc {\n                         let span = tcx.def_span(data.impl_def_id);"}, {"sha": "b77b213b51a542fe4bb847a93a65ddaeaff2d5e3", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -168,30 +168,28 @@ impl Qualif for NeedsNonConstDrop {\n             }),\n         );\n \n-        cx.tcx.infer_ctxt().enter(|infcx| {\n-            let mut selcx = SelectionContext::new(&infcx);\n-            let Some(impl_src) = selcx.select(&obligation).ok().flatten() else {\n-                // If we couldn't select a const destruct candidate, then it's bad\n-                return true;\n-            };\n-\n-            if !matches!(\n-                impl_src,\n-                ImplSource::ConstDestruct(_)\n-                    | ImplSource::Param(_, ty::BoundConstness::ConstIfConst)\n-            ) {\n-                // If our const destruct candidate is not ConstDestruct or implied by the param env,\n-                // then it's bad\n-                return true;\n-            }\n+        let infcx = cx.tcx.infer_ctxt().build();\n+        let mut selcx = SelectionContext::new(&infcx);\n+        let Some(impl_src) = selcx.select(&obligation).ok().flatten() else {\n+            // If we couldn't select a const destruct candidate, then it's bad\n+            return true;\n+        };\n+\n+        if !matches!(\n+            impl_src,\n+            ImplSource::ConstDestruct(_) | ImplSource::Param(_, ty::BoundConstness::ConstIfConst)\n+        ) {\n+            // If our const destruct candidate is not ConstDestruct or implied by the param env,\n+            // then it's bad\n+            return true;\n+        }\n \n-            if impl_src.borrow_nested_obligations().is_empty() {\n-                return false;\n-            }\n+        if impl_src.borrow_nested_obligations().is_empty() {\n+            return false;\n+        }\n \n-            // If we had any errors, then it's bad\n-            !traits::fully_solve_obligations(&infcx, impl_src.nested_obligations()).is_empty()\n-        })\n+        // If we had any errors, then it's bad\n+        !traits::fully_solve_obligations(&infcx, impl_src.nested_obligations()).is_empty()\n     }\n \n     fn in_adt_inherently<'tcx>("}, {"sha": "23276e60982d3c9dd897e95e3f71b36fed1cfa60", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -105,7 +105,7 @@ pub fn equal_up_to_regions<'tcx>(\n             },\n         )\n     };\n-    tcx.infer_ctxt().enter(|infcx| infcx.can_eq(param_env, normalize(src), normalize(dest)).is_ok())\n+    tcx.infer_ctxt().build().can_eq(param_env, normalize(src), normalize(dest)).is_ok()\n }\n \n struct TypeChecker<'a, 'tcx> {"}, {"sha": "47915b4bd4e6ce6ff6e3948d59d42e2e34709b01", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -83,9 +83,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 Res::Def(DefKind::TyParam, src_def_id) => {\n                     if let Some(param_local_id) = param.def_id.as_local() {\n                         let param_name = tcx.hir().ty_param_name(param_local_id);\n-                        let param_type = tcx.infer_ctxt().enter(|infcx| {\n-                            infcx.resolve_numeric_literals_with_default(tcx.type_of(param.def_id))\n-                        });\n+                        let infcx = tcx.infer_ctxt().build();\n+                        let param_type =\n+                            infcx.resolve_numeric_literals_with_default(tcx.type_of(param.def_id));\n                         if param_type.is_suggestable(tcx, false) {\n                             err.span_suggestion(\n                                 tcx.def_span(src_def_id),"}, {"sha": "da5d0706bc08ee6d5208c0475a845b03459f2b8e", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -732,52 +732,52 @@ fn check_opaque_meets_bounds<'tcx>(\n     };\n     let param_env = tcx.param_env(defining_use_anchor);\n \n-    tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(defining_use_anchor)).enter(\n-        move |infcx| {\n-            let ocx = ObligationCtxt::new(&infcx);\n-            let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), substs);\n-\n-            let misc_cause = traits::ObligationCause::misc(span, hir_id);\n-\n-            match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_type) {\n-                Ok(infer_ok) => ocx.register_infer_ok_obligations(infer_ok),\n-                Err(ty_err) => {\n-                    tcx.sess.delay_span_bug(\n-                        span,\n-                        &format!(\"could not unify `{hidden_type}` with revealed type:\\n{ty_err}\"),\n-                    );\n-                }\n-            }\n+    let infcx = tcx\n+        .infer_ctxt()\n+        .with_opaque_type_inference(DefiningAnchor::Bind(defining_use_anchor))\n+        .build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+    let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), substs);\n+\n+    let misc_cause = traits::ObligationCause::misc(span, hir_id);\n+\n+    match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_type) {\n+        Ok(infer_ok) => ocx.register_infer_ok_obligations(infer_ok),\n+        Err(ty_err) => {\n+            tcx.sess.delay_span_bug(\n+                span,\n+                &format!(\"could not unify `{hidden_type}` with revealed type:\\n{ty_err}\"),\n+            );\n+        }\n+    }\n \n-            // Additionally require the hidden type to be well-formed with only the generics of the opaque type.\n-            // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n-            // hidden type is well formed even without those bounds.\n-            let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(hidden_type.into()))\n-                .to_predicate(tcx);\n-            ocx.register_obligation(Obligation::new(misc_cause, param_env, predicate));\n-\n-            // Check that all obligations are satisfied by the implementation's\n-            // version.\n-            let errors = ocx.select_all_or_error();\n-            if !errors.is_empty() {\n-                infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n-            }\n-            match origin {\n-                // Checked when type checking the function containing them.\n-                hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n-                // Can have different predicates to their defining use\n-                hir::OpaqueTyOrigin::TyAlias => {\n-                    let outlives_environment = OutlivesEnvironment::new(param_env);\n-                    infcx.check_region_obligations_and_report_errors(\n-                        defining_use_anchor,\n-                        &outlives_environment,\n-                    );\n-                }\n-            }\n-            // Clean up after ourselves\n-            let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-        },\n-    );\n+    // Additionally require the hidden type to be well-formed with only the generics of the opaque type.\n+    // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n+    // hidden type is well formed even without those bounds.\n+    let predicate =\n+        ty::Binder::dummy(ty::PredicateKind::WellFormed(hidden_type.into())).to_predicate(tcx);\n+    ocx.register_obligation(Obligation::new(misc_cause, param_env, predicate));\n+\n+    // Check that all obligations are satisfied by the implementation's\n+    // version.\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+    }\n+    match origin {\n+        // Checked when type checking the function containing them.\n+        hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n+        // Can have different predicates to their defining use\n+        hir::OpaqueTyOrigin::TyAlias => {\n+            let outlives_environment = OutlivesEnvironment::new(param_env);\n+            infcx.check_region_obligations_and_report_errors(\n+                defining_use_anchor,\n+                &outlives_environment,\n+            );\n+        }\n+    }\n+    // Clean up after ourselves\n+    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n }\n \n fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {"}, {"sha": "5e5dbedb4bd7bd67dcc31c8b198d29cba7a2ea19", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 506, "deletions": 521, "changes": 1027, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -215,224 +215,220 @@ fn compare_predicate_entailment<'tcx>(\n     );\n     let param_env = traits::normalize_param_env_or_error(tcx, param_env, normalize_cause);\n \n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        let ocx = ObligationCtxt::new(infcx);\n+    let infcx = &tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(infcx);\n \n-        debug!(\"compare_impl_method: caller_bounds={:?}\", param_env.caller_bounds());\n+    debug!(\"compare_impl_method: caller_bounds={:?}\", param_env.caller_bounds());\n \n-        let mut selcx = traits::SelectionContext::new(&infcx);\n-        let impl_m_own_bounds = impl_m_predicates.instantiate_own(tcx, impl_to_placeholder_substs);\n-        for (predicate, span) in iter::zip(impl_m_own_bounds.predicates, impl_m_own_bounds.spans) {\n-            let normalize_cause = traits::ObligationCause::misc(span, impl_m_hir_id);\n-            let traits::Normalized { value: predicate, obligations } =\n-                traits::normalize(&mut selcx, param_env, normalize_cause, predicate);\n+    let mut selcx = traits::SelectionContext::new(&infcx);\n+    let impl_m_own_bounds = impl_m_predicates.instantiate_own(tcx, impl_to_placeholder_substs);\n+    for (predicate, span) in iter::zip(impl_m_own_bounds.predicates, impl_m_own_bounds.spans) {\n+        let normalize_cause = traits::ObligationCause::misc(span, impl_m_hir_id);\n+        let traits::Normalized { value: predicate, obligations } =\n+            traits::normalize(&mut selcx, param_env, normalize_cause, predicate);\n \n-            ocx.register_obligations(obligations);\n-            let cause = ObligationCause::new(\n-                span,\n-                impl_m_hir_id,\n-                ObligationCauseCode::CompareImplItemObligation {\n-                    impl_item_def_id: impl_m.def_id.expect_local(),\n-                    trait_item_def_id: trait_m.def_id,\n-                    kind: impl_m.kind,\n-                },\n-            );\n-            ocx.register_obligation(traits::Obligation::new(cause, param_env, predicate));\n-        }\n-\n-        // We now need to check that the signature of the impl method is\n-        // compatible with that of the trait method. We do this by\n-        // checking that `impl_fty <: trait_fty`.\n-        //\n-        // FIXME. Unfortunately, this doesn't quite work right now because\n-        // associated type normalization is not integrated into subtype\n-        // checks. For the comparison to be valid, we need to\n-        // normalize the associated types in the impl/trait methods\n-        // first. However, because function types bind regions, just\n-        // calling `normalize_associated_types_in` would have no effect on\n-        // any associated types appearing in the fn arguments or return\n-        // type.\n-\n-        // Compute placeholder form of impl and trait method tys.\n-        let tcx = infcx.tcx;\n-\n-        let mut wf_tys = FxHashSet::default();\n-\n-        let impl_sig = infcx.replace_bound_vars_with_fresh_vars(\n-            impl_m_span,\n-            infer::HigherRankedType,\n-            tcx.fn_sig(impl_m.def_id),\n+        ocx.register_obligations(obligations);\n+        let cause = ObligationCause::new(\n+            span,\n+            impl_m_hir_id,\n+            ObligationCauseCode::CompareImplItemObligation {\n+                impl_item_def_id: impl_m.def_id.expect_local(),\n+                trait_item_def_id: trait_m.def_id,\n+                kind: impl_m.kind,\n+            },\n         );\n+        ocx.register_obligation(traits::Obligation::new(cause, param_env, predicate));\n+    }\n \n-        let norm_cause = ObligationCause::misc(impl_m_span, impl_m_hir_id);\n-        let impl_sig = ocx.normalize(norm_cause.clone(), param_env, impl_sig);\n-        let impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig));\n-        debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n-\n-        let trait_sig = tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs);\n-        let trait_sig = tcx.liberate_late_bound_regions(impl_m.def_id, trait_sig);\n-\n-        // Next, add all inputs and output as well-formed tys. Importantly,\n-        // we have to do this before normalization, since the normalized ty may\n-        // not contain the input parameters. See issue #87748.\n-        wf_tys.extend(trait_sig.inputs_and_output.iter());\n-        let trait_sig = ocx.normalize(norm_cause, param_env, trait_sig);\n-        // We also have to add the normalized trait signature\n-        // as we don't normalize during implied bounds computation.\n-        wf_tys.extend(trait_sig.inputs_and_output.iter());\n-        let trait_fty = tcx.mk_fn_ptr(ty::Binder::dummy(trait_sig));\n-\n-        debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n-\n-        // FIXME: We'd want to keep more accurate spans than \"the method signature\" when\n-        // processing the comparison between the trait and impl fn, but we sadly lose them\n-        // and point at the whole signature when a trait bound or specific input or output\n-        // type would be more appropriate. In other places we have a `Vec<Span>`\n-        // corresponding to their `Vec<Predicate>`, but we don't have that here.\n-        // Fixing this would improve the output of test `issue-83765.rs`.\n-        let mut result = infcx\n-            .at(&cause, param_env)\n-            .sup(trait_fty, impl_fty)\n-            .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok));\n-\n-        // HACK(RPITIT): #101614. When we are trying to infer the hidden types for\n-        // RPITITs, we need to equate the output tys instead of just subtyping. If\n-        // we just use `sup` above, we'll end up `&'static str <: _#1t`, which causes\n-        // us to infer `_#1t = #'_#2r str`, where `'_#2r` is unconstrained, which gets\n-        // fixed up to `ReEmpty`, and which is certainly not what we want.\n-        if trait_fty.has_infer_types() {\n-            result = result.and_then(|()| {\n-                infcx\n-                    .at(&cause, param_env)\n-                    .eq(trait_sig.output(), impl_sig.output())\n-                    .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok))\n-            });\n-        }\n+    // We now need to check that the signature of the impl method is\n+    // compatible with that of the trait method. We do this by\n+    // checking that `impl_fty <: trait_fty`.\n+    //\n+    // FIXME. Unfortunately, this doesn't quite work right now because\n+    // associated type normalization is not integrated into subtype\n+    // checks. For the comparison to be valid, we need to\n+    // normalize the associated types in the impl/trait methods\n+    // first. However, because function types bind regions, just\n+    // calling `normalize_associated_types_in` would have no effect on\n+    // any associated types appearing in the fn arguments or return\n+    // type.\n+\n+    // Compute placeholder form of impl and trait method tys.\n+    let tcx = infcx.tcx;\n \n-        if let Err(terr) = result {\n-            debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n+    let mut wf_tys = FxHashSet::default();\n \n-            let (impl_err_span, trait_err_span) =\n-                extract_spans_for_error_reporting(&infcx, terr, &cause, impl_m, trait_m);\n+    let impl_sig = infcx.replace_bound_vars_with_fresh_vars(\n+        impl_m_span,\n+        infer::HigherRankedType,\n+        tcx.fn_sig(impl_m.def_id),\n+    );\n \n-            cause.span = impl_err_span;\n+    let norm_cause = ObligationCause::misc(impl_m_span, impl_m_hir_id);\n+    let impl_sig = ocx.normalize(norm_cause.clone(), param_env, impl_sig);\n+    let impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig));\n+    debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n+\n+    let trait_sig = tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs);\n+    let trait_sig = tcx.liberate_late_bound_regions(impl_m.def_id, trait_sig);\n+\n+    // Next, add all inputs and output as well-formed tys. Importantly,\n+    // we have to do this before normalization, since the normalized ty may\n+    // not contain the input parameters. See issue #87748.\n+    wf_tys.extend(trait_sig.inputs_and_output.iter());\n+    let trait_sig = ocx.normalize(norm_cause, param_env, trait_sig);\n+    // We also have to add the normalized trait signature\n+    // as we don't normalize during implied bounds computation.\n+    wf_tys.extend(trait_sig.inputs_and_output.iter());\n+    let trait_fty = tcx.mk_fn_ptr(ty::Binder::dummy(trait_sig));\n+\n+    debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n+\n+    // FIXME: We'd want to keep more accurate spans than \"the method signature\" when\n+    // processing the comparison between the trait and impl fn, but we sadly lose them\n+    // and point at the whole signature when a trait bound or specific input or output\n+    // type would be more appropriate. In other places we have a `Vec<Span>`\n+    // corresponding to their `Vec<Predicate>`, but we don't have that here.\n+    // Fixing this would improve the output of test `issue-83765.rs`.\n+    let mut result = infcx\n+        .at(&cause, param_env)\n+        .sup(trait_fty, impl_fty)\n+        .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok));\n+\n+    // HACK(RPITIT): #101614. When we are trying to infer the hidden types for\n+    // RPITITs, we need to equate the output tys instead of just subtyping. If\n+    // we just use `sup` above, we'll end up `&'static str <: _#1t`, which causes\n+    // us to infer `_#1t = #'_#2r str`, where `'_#2r` is unconstrained, which gets\n+    // fixed up to `ReEmpty`, and which is certainly not what we want.\n+    if trait_fty.has_infer_types() {\n+        result = result.and_then(|()| {\n+            infcx\n+                .at(&cause, param_env)\n+                .eq(trait_sig.output(), impl_sig.output())\n+                .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok))\n+        });\n+    }\n \n-            let mut diag = struct_span_err!(\n-                tcx.sess,\n-                cause.span(),\n-                E0053,\n-                \"method `{}` has an incompatible type for trait\",\n-                trait_m.name\n-            );\n-            match &terr {\n-                TypeError::ArgumentMutability(0) | TypeError::ArgumentSorts(_, 0)\n-                    if trait_m.fn_has_self_parameter =>\n-                {\n-                    let ty = trait_sig.inputs()[0];\n-                    let sugg = match ExplicitSelf::determine(ty, |_| ty == impl_trait_ref.self_ty())\n-                    {\n-                        ExplicitSelf::ByValue => \"self\".to_owned(),\n-                        ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n-                        ExplicitSelf::ByReference(_, hir::Mutability::Mut) => {\n-                            \"&mut self\".to_owned()\n-                        }\n-                        _ => format!(\"self: {ty}\"),\n-                    };\n+    if let Err(terr) = result {\n+        debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n \n-                    // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n-                    // span points only at the type `Box<Self`>, but we want to cover the whole\n-                    // argument pattern and type.\n-                    let span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                        ImplItemKind::Fn(ref sig, body) => tcx\n-                            .hir()\n-                            .body_param_names(body)\n-                            .zip(sig.decl.inputs.iter())\n-                            .map(|(param, ty)| param.span.to(ty.span))\n-                            .next()\n-                            .unwrap_or(impl_err_span),\n-                        _ => bug!(\"{:?} is not a method\", impl_m),\n-                    };\n+        let (impl_err_span, trait_err_span) =\n+            extract_spans_for_error_reporting(&infcx, terr, &cause, impl_m, trait_m);\n+\n+        cause.span = impl_err_span;\n \n+        let mut diag = struct_span_err!(\n+            tcx.sess,\n+            cause.span(),\n+            E0053,\n+            \"method `{}` has an incompatible type for trait\",\n+            trait_m.name\n+        );\n+        match &terr {\n+            TypeError::ArgumentMutability(0) | TypeError::ArgumentSorts(_, 0)\n+                if trait_m.fn_has_self_parameter =>\n+            {\n+                let ty = trait_sig.inputs()[0];\n+                let sugg = match ExplicitSelf::determine(ty, |_| ty == impl_trait_ref.self_ty()) {\n+                    ExplicitSelf::ByValue => \"self\".to_owned(),\n+                    ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n+                    ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n+                    _ => format!(\"self: {ty}\"),\n+                };\n+\n+                // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n+                // span points only at the type `Box<Self`>, but we want to cover the whole\n+                // argument pattern and type.\n+                let span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n+                    ImplItemKind::Fn(ref sig, body) => tcx\n+                        .hir()\n+                        .body_param_names(body)\n+                        .zip(sig.decl.inputs.iter())\n+                        .map(|(param, ty)| param.span.to(ty.span))\n+                        .next()\n+                        .unwrap_or(impl_err_span),\n+                    _ => bug!(\"{:?} is not a method\", impl_m),\n+                };\n+\n+                diag.span_suggestion(\n+                    span,\n+                    \"change the self-receiver type to match the trait\",\n+                    sugg,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            TypeError::ArgumentMutability(i) | TypeError::ArgumentSorts(_, i) => {\n+                if trait_sig.inputs().len() == *i {\n+                    // Suggestion to change output type. We do not suggest in `async` functions\n+                    // to avoid complex logic or incorrect output.\n+                    match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n+                        ImplItemKind::Fn(ref sig, _)\n+                            if sig.header.asyncness == hir::IsAsync::NotAsync =>\n+                        {\n+                            let msg = \"change the output type to match the trait\";\n+                            let ap = Applicability::MachineApplicable;\n+                            match sig.decl.output {\n+                                hir::FnRetTy::DefaultReturn(sp) => {\n+                                    let sugg = format!(\"-> {} \", trait_sig.output());\n+                                    diag.span_suggestion_verbose(sp, msg, sugg, ap);\n+                                }\n+                                hir::FnRetTy::Return(hir_ty) => {\n+                                    let sugg = trait_sig.output();\n+                                    diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n+                                }\n+                            };\n+                        }\n+                        _ => {}\n+                    };\n+                } else if let Some(trait_ty) = trait_sig.inputs().get(*i) {\n                     diag.span_suggestion(\n-                        span,\n-                        \"change the self-receiver type to match the trait\",\n-                        sugg,\n+                        impl_err_span,\n+                        \"change the parameter type to match the trait\",\n+                        trait_ty,\n                         Applicability::MachineApplicable,\n                     );\n                 }\n-                TypeError::ArgumentMutability(i) | TypeError::ArgumentSorts(_, i) => {\n-                    if trait_sig.inputs().len() == *i {\n-                        // Suggestion to change output type. We do not suggest in `async` functions\n-                        // to avoid complex logic or incorrect output.\n-                        match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                            ImplItemKind::Fn(ref sig, _)\n-                                if sig.header.asyncness == hir::IsAsync::NotAsync =>\n-                            {\n-                                let msg = \"change the output type to match the trait\";\n-                                let ap = Applicability::MachineApplicable;\n-                                match sig.decl.output {\n-                                    hir::FnRetTy::DefaultReturn(sp) => {\n-                                        let sugg = format!(\"-> {} \", trait_sig.output());\n-                                        diag.span_suggestion_verbose(sp, msg, sugg, ap);\n-                                    }\n-                                    hir::FnRetTy::Return(hir_ty) => {\n-                                        let sugg = trait_sig.output();\n-                                        diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n-                                    }\n-                                };\n-                            }\n-                            _ => {}\n-                        };\n-                    } else if let Some(trait_ty) = trait_sig.inputs().get(*i) {\n-                        diag.span_suggestion(\n-                            impl_err_span,\n-                            \"change the parameter type to match the trait\",\n-                            trait_ty,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                }\n-                _ => {}\n             }\n+            _ => {}\n+        }\n \n-            infcx.err_ctxt().note_type_err(\n-                &mut diag,\n-                &cause,\n-                trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n-                Some(infer::ValuePairs::Terms(ExpectedFound {\n-                    expected: trait_fty.into(),\n-                    found: impl_fty.into(),\n-                })),\n-                terr,\n-                false,\n-                false,\n-            );\n+        infcx.err_ctxt().note_type_err(\n+            &mut diag,\n+            &cause,\n+            trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n+            Some(infer::ValuePairs::Terms(ExpectedFound {\n+                expected: trait_fty.into(),\n+                found: impl_fty.into(),\n+            })),\n+            terr,\n+            false,\n+            false,\n+        );\n \n-            return Err(diag.emit());\n-        }\n+        return Err(diag.emit());\n+    }\n \n-        // Check that all obligations are satisfied by the implementation's\n-        // version.\n-        let errors = ocx.select_all_or_error();\n-        if !errors.is_empty() {\n-            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n-            return Err(reported);\n-        }\n+    // Check that all obligations are satisfied by the implementation's\n+    // version.\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        return Err(reported);\n+    }\n \n-        // Finally, resolve all regions. This catches wily misuses of\n-        // lifetime parameters.\n-        let outlives_environment = OutlivesEnvironment::with_bounds(\n-            param_env,\n-            Some(infcx),\n-            infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys),\n-        );\n-        infcx.check_region_obligations_and_report_errors(\n-            impl_m.def_id.expect_local(),\n-            &outlives_environment,\n-        );\n+    // Finally, resolve all regions. This catches wily misuses of\n+    // lifetime parameters.\n+    let outlives_environment = OutlivesEnvironment::with_bounds(\n+        param_env,\n+        Some(infcx),\n+        infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys),\n+    );\n+    infcx.check_region_obligations_and_report_errors(\n+        impl_m.def_id.expect_local(),\n+        &outlives_environment,\n+    );\n \n-        Ok(())\n-    })\n+    Ok(())\n }\n \n pub fn collect_trait_impl_trait_tys<'tcx>(\n@@ -465,125 +461,120 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     let trait_to_placeholder_substs =\n         impl_to_placeholder_substs.rebase_onto(tcx, impl_m.container_id(tcx), trait_to_impl_substs);\n \n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        let ocx = ObligationCtxt::new(infcx);\n+    let infcx = &tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(infcx);\n \n-        let norm_cause = ObligationCause::misc(return_span, impl_m_hir_id);\n-        let impl_return_ty = ocx.normalize(\n-            norm_cause.clone(),\n-            param_env,\n-            infcx\n-                .replace_bound_vars_with_fresh_vars(\n-                    return_span,\n-                    infer::HigherRankedType,\n-                    tcx.fn_sig(impl_m.def_id),\n-                )\n-                .output(),\n-        );\n-\n-        let mut collector =\n-            ImplTraitInTraitCollector::new(&ocx, return_span, param_env, impl_m_hir_id);\n-        let unnormalized_trait_return_ty = tcx\n-            .liberate_late_bound_regions(\n-                impl_m.def_id,\n-                tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs),\n+    let norm_cause = ObligationCause::misc(return_span, impl_m_hir_id);\n+    let impl_return_ty = ocx.normalize(\n+        norm_cause.clone(),\n+        param_env,\n+        infcx\n+            .replace_bound_vars_with_fresh_vars(\n+                return_span,\n+                infer::HigherRankedType,\n+                tcx.fn_sig(impl_m.def_id),\n             )\n-            .output()\n-            .fold_with(&mut collector);\n-        let trait_return_ty =\n-            ocx.normalize(norm_cause.clone(), param_env, unnormalized_trait_return_ty);\n+            .output(),\n+    );\n \n-        let wf_tys = FxHashSet::from_iter([unnormalized_trait_return_ty, trait_return_ty]);\n+    let mut collector = ImplTraitInTraitCollector::new(&ocx, return_span, param_env, impl_m_hir_id);\n+    let unnormalized_trait_return_ty = tcx\n+        .liberate_late_bound_regions(\n+            impl_m.def_id,\n+            tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs),\n+        )\n+        .output()\n+        .fold_with(&mut collector);\n+    let trait_return_ty =\n+        ocx.normalize(norm_cause.clone(), param_env, unnormalized_trait_return_ty);\n \n-        match infcx.at(&cause, param_env).eq(trait_return_ty, impl_return_ty) {\n-            Ok(infer::InferOk { value: (), obligations }) => {\n-                ocx.register_obligations(obligations);\n-            }\n-            Err(terr) => {\n-                let mut diag = struct_span_err!(\n-                    tcx.sess,\n-                    cause.span(),\n-                    E0053,\n-                    \"method `{}` has an incompatible return type for trait\",\n-                    trait_m.name\n-                );\n-                let hir = tcx.hir();\n-                infcx.err_ctxt().note_type_err(\n-                    &mut diag,\n-                    &cause,\n-                    hir.get_if_local(impl_m.def_id)\n-                        .and_then(|node| node.fn_decl())\n-                        .map(|decl| (decl.output.span(), \"return type in trait\".to_owned())),\n-                    Some(infer::ValuePairs::Terms(ExpectedFound {\n-                        expected: trait_return_ty.into(),\n-                        found: impl_return_ty.into(),\n-                    })),\n-                    terr,\n-                    false,\n-                    false,\n-                );\n-                return Err(diag.emit());\n-            }\n-        }\n+    let wf_tys = FxHashSet::from_iter([unnormalized_trait_return_ty, trait_return_ty]);\n \n-        // Check that all obligations are satisfied by the implementation's\n-        // RPITs.\n-        let errors = ocx.select_all_or_error();\n-        if !errors.is_empty() {\n-            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n-            return Err(reported);\n+    match infcx.at(&cause, param_env).eq(trait_return_ty, impl_return_ty) {\n+        Ok(infer::InferOk { value: (), obligations }) => {\n+            ocx.register_obligations(obligations);\n         }\n+        Err(terr) => {\n+            let mut diag = struct_span_err!(\n+                tcx.sess,\n+                cause.span(),\n+                E0053,\n+                \"method `{}` has an incompatible return type for trait\",\n+                trait_m.name\n+            );\n+            let hir = tcx.hir();\n+            infcx.err_ctxt().note_type_err(\n+                &mut diag,\n+                &cause,\n+                hir.get_if_local(impl_m.def_id)\n+                    .and_then(|node| node.fn_decl())\n+                    .map(|decl| (decl.output.span(), \"return type in trait\".to_owned())),\n+                Some(infer::ValuePairs::Terms(ExpectedFound {\n+                    expected: trait_return_ty.into(),\n+                    found: impl_return_ty.into(),\n+                })),\n+                terr,\n+                false,\n+                false,\n+            );\n+            return Err(diag.emit());\n+        }\n+    }\n \n-        // Finally, resolve all regions. This catches wily misuses of\n-        // lifetime parameters.\n-        let outlives_environment = OutlivesEnvironment::with_bounds(\n-            param_env,\n-            Some(infcx),\n-            infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys),\n-        );\n-        infcx.check_region_obligations_and_report_errors(\n-            impl_m.def_id.expect_local(),\n-            &outlives_environment,\n-        );\n+    // Check that all obligations are satisfied by the implementation's\n+    // RPITs.\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        return Err(reported);\n+    }\n \n-        let mut collected_tys = FxHashMap::default();\n-        for (def_id, (ty, substs)) in collector.types {\n-            match infcx.fully_resolve(ty) {\n-                Ok(ty) => {\n-                    // `ty` contains free regions that we created earlier while liberating the\n-                    // trait fn signature.  However, projection normalization expects `ty` to\n-                    // contains `def_id`'s early-bound regions.\n-                    let id_substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    debug!(?id_substs, ?substs);\n-                    let map: FxHashMap<ty::GenericArg<'tcx>, ty::GenericArg<'tcx>> = substs\n-                        .iter()\n-                        .enumerate()\n-                        .map(|(index, arg)| (arg, id_substs[index]))\n-                        .collect();\n-                    debug!(?map);\n-\n-                    let ty = tcx.fold_regions(ty, |region, _| {\n-                        if let ty::ReFree(_) = region.kind() {\n-                            map[&region.into()].expect_region()\n-                        } else {\n-                            region\n-                        }\n-                    });\n-                    debug!(%ty);\n-                    collected_tys.insert(def_id, ty);\n-                }\n-                Err(err) => {\n-                    tcx.sess.delay_span_bug(\n-                        return_span,\n-                        format!(\"could not fully resolve: {ty} => {err:?}\"),\n-                    );\n-                    collected_tys.insert(def_id, tcx.ty_error());\n-                }\n+    // Finally, resolve all regions. This catches wily misuses of\n+    // lifetime parameters.\n+    let outlives_environment = OutlivesEnvironment::with_bounds(\n+        param_env,\n+        Some(infcx),\n+        infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys),\n+    );\n+    infcx.check_region_obligations_and_report_errors(\n+        impl_m.def_id.expect_local(),\n+        &outlives_environment,\n+    );\n+\n+    let mut collected_tys = FxHashMap::default();\n+    for (def_id, (ty, substs)) in collector.types {\n+        match infcx.fully_resolve(ty) {\n+            Ok(ty) => {\n+                // `ty` contains free regions that we created earlier while liberating the\n+                // trait fn signature.  However, projection normalization expects `ty` to\n+                // contains `def_id`'s early-bound regions.\n+                let id_substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                debug!(?id_substs, ?substs);\n+                let map: FxHashMap<ty::GenericArg<'tcx>, ty::GenericArg<'tcx>> =\n+                    substs.iter().enumerate().map(|(index, arg)| (arg, id_substs[index])).collect();\n+                debug!(?map);\n+\n+                let ty = tcx.fold_regions(ty, |region, _| {\n+                    if let ty::ReFree(_) = region.kind() {\n+                        map[&region.into()].expect_region()\n+                    } else {\n+                        region\n+                    }\n+                });\n+                debug!(%ty);\n+                collected_tys.insert(def_id, ty);\n+            }\n+            Err(err) => {\n+                tcx.sess.delay_span_bug(\n+                    return_span,\n+                    format!(\"could not fully resolve: {ty} => {err:?}\"),\n+                );\n+                collected_tys.insert(def_id, tcx.ty_error());\n             }\n         }\n+    }\n \n-        Ok(&*tcx.arena.alloc(collected_tys))\n-    })\n+    Ok(&*tcx.arena.alloc(collected_tys))\n }\n \n struct ImplTraitInTraitCollector<'a, 'tcx> {\n@@ -768,16 +759,15 @@ fn compare_self_type<'tcx>(\n         let self_arg_ty = tcx.fn_sig(method.def_id).input(0);\n         let param_env = ty::ParamEnv::reveal_all();\n \n-        tcx.infer_ctxt().enter(|infcx| {\n-            let self_arg_ty = tcx.liberate_late_bound_regions(method.def_id, self_arg_ty);\n-            let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n-            match ExplicitSelf::determine(self_arg_ty, can_eq_self) {\n-                ExplicitSelf::ByValue => \"self\".to_owned(),\n-                ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n-                ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n-                _ => format!(\"self: {self_arg_ty}\"),\n-            }\n-        })\n+        let infcx = tcx.infer_ctxt().build();\n+        let self_arg_ty = tcx.liberate_late_bound_regions(method.def_id, self_arg_ty);\n+        let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n+        match ExplicitSelf::determine(self_arg_ty, can_eq_self) {\n+            ExplicitSelf::ByValue => \"self\".to_owned(),\n+            ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n+            ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n+            _ => format!(\"self: {self_arg_ty}\"),\n+        }\n     };\n \n     match (trait_m.fn_has_self_parameter, impl_m.fn_has_self_parameter) {\n@@ -1312,104 +1302,102 @@ pub(crate) fn raw_compare_const_impl<'tcx>(\n \n     let impl_c_span = tcx.def_span(impl_const_item_def.to_def_id());\n \n-    tcx.infer_ctxt().enter(|infcx| {\n-        let param_env = tcx.param_env(impl_const_item_def.to_def_id());\n-        let ocx = ObligationCtxt::new(&infcx);\n-\n-        // The below is for the most part highly similar to the procedure\n-        // for methods above. It is simpler in many respects, especially\n-        // because we shouldn't really have to deal with lifetimes or\n-        // predicates. In fact some of this should probably be put into\n-        // shared functions because of DRY violations...\n-        let trait_to_impl_substs = impl_trait_ref.substs;\n-\n-        // Create a parameter environment that represents the implementation's\n-        // method.\n-        let impl_c_hir_id = tcx.hir().local_def_id_to_hir_id(impl_const_item_def);\n-\n-        // Compute placeholder form of impl and trait const tys.\n-        let impl_ty = tcx.type_of(impl_const_item_def.to_def_id());\n-        let trait_ty = tcx.bound_type_of(trait_const_item_def).subst(tcx, trait_to_impl_substs);\n-        let mut cause = ObligationCause::new(\n-            impl_c_span,\n-            impl_c_hir_id,\n-            ObligationCauseCode::CompareImplItemObligation {\n-                impl_item_def_id: impl_const_item_def,\n-                trait_item_def_id: trait_const_item_def,\n-                kind: impl_const_item.kind,\n-            },\n-        );\n+    let infcx = tcx.infer_ctxt().build();\n+    let param_env = tcx.param_env(impl_const_item_def.to_def_id());\n+    let ocx = ObligationCtxt::new(&infcx);\n \n-        // There is no \"body\" here, so just pass dummy id.\n-        let impl_ty = ocx.normalize(cause.clone(), param_env, impl_ty);\n+    // The below is for the most part highly similar to the procedure\n+    // for methods above. It is simpler in many respects, especially\n+    // because we shouldn't really have to deal with lifetimes or\n+    // predicates. In fact some of this should probably be put into\n+    // shared functions because of DRY violations...\n+    let trait_to_impl_substs = impl_trait_ref.substs;\n \n-        debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n+    // Create a parameter environment that represents the implementation's\n+    // method.\n+    let impl_c_hir_id = tcx.hir().local_def_id_to_hir_id(impl_const_item_def);\n \n-        let trait_ty = ocx.normalize(cause.clone(), param_env, trait_ty);\n+    // Compute placeholder form of impl and trait const tys.\n+    let impl_ty = tcx.type_of(impl_const_item_def.to_def_id());\n+    let trait_ty = tcx.bound_type_of(trait_const_item_def).subst(tcx, trait_to_impl_substs);\n+    let mut cause = ObligationCause::new(\n+        impl_c_span,\n+        impl_c_hir_id,\n+        ObligationCauseCode::CompareImplItemObligation {\n+            impl_item_def_id: impl_const_item_def,\n+            trait_item_def_id: trait_const_item_def,\n+            kind: impl_const_item.kind,\n+        },\n+    );\n \n-        debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n+    // There is no \"body\" here, so just pass dummy id.\n+    let impl_ty = ocx.normalize(cause.clone(), param_env, impl_ty);\n \n-        let err = infcx\n-            .at(&cause, param_env)\n-            .sup(trait_ty, impl_ty)\n-            .map(|ok| ocx.register_infer_ok_obligations(ok));\n+    debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n \n-        if let Err(terr) = err {\n-            debug!(\n-                \"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n-                impl_ty, trait_ty\n-            );\n+    let trait_ty = ocx.normalize(cause.clone(), param_env, trait_ty);\n \n-            // Locate the Span containing just the type of the offending impl\n-            match tcx.hir().expect_impl_item(impl_const_item_def).kind {\n-                ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n-                _ => bug!(\"{:?} is not a impl const\", impl_const_item),\n-            }\n-\n-            let mut diag = struct_span_err!(\n-                tcx.sess,\n-                cause.span,\n-                E0326,\n-                \"implemented const `{}` has an incompatible type for trait\",\n-                trait_const_item.name\n-            );\n+    debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n-            let trait_c_span = trait_const_item_def.as_local().map(|trait_c_def_id| {\n-                // Add a label to the Span containing just the type of the const\n-                match tcx.hir().expect_trait_item(trait_c_def_id).kind {\n-                    TraitItemKind::Const(ref ty, _) => ty.span,\n-                    _ => bug!(\"{:?} is not a trait const\", trait_const_item),\n-                }\n-            });\n+    let err = infcx\n+        .at(&cause, param_env)\n+        .sup(trait_ty, impl_ty)\n+        .map(|ok| ocx.register_infer_ok_obligations(ok));\n \n-            infcx.err_ctxt().note_type_err(\n-                &mut diag,\n-                &cause,\n-                trait_c_span.map(|span| (span, \"type in trait\".to_owned())),\n-                Some(infer::ValuePairs::Terms(ExpectedFound {\n-                    expected: trait_ty.into(),\n-                    found: impl_ty.into(),\n-                })),\n-                terr,\n-                false,\n-                false,\n-            );\n-            return Err(diag.emit());\n-        };\n+    if let Err(terr) = err {\n+        debug!(\n+            \"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n+            impl_ty, trait_ty\n+        );\n \n-        // Check that all obligations are satisfied by the implementation's\n-        // version.\n-        let errors = ocx.select_all_or_error();\n-        if !errors.is_empty() {\n-            return Err(infcx.err_ctxt().report_fulfillment_errors(&errors, None, false));\n+        // Locate the Span containing just the type of the offending impl\n+        match tcx.hir().expect_impl_item(impl_const_item_def).kind {\n+            ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n+            _ => bug!(\"{:?} is not a impl const\", impl_const_item),\n         }\n \n-        // FIXME return `ErrorReported` if region obligations error?\n-        let outlives_environment = OutlivesEnvironment::new(param_env);\n-        infcx\n-            .check_region_obligations_and_report_errors(impl_const_item_def, &outlives_environment);\n-        Ok(())\n-    })\n+        let mut diag = struct_span_err!(\n+            tcx.sess,\n+            cause.span,\n+            E0326,\n+            \"implemented const `{}` has an incompatible type for trait\",\n+            trait_const_item.name\n+        );\n+\n+        let trait_c_span = trait_const_item_def.as_local().map(|trait_c_def_id| {\n+            // Add a label to the Span containing just the type of the const\n+            match tcx.hir().expect_trait_item(trait_c_def_id).kind {\n+                TraitItemKind::Const(ref ty, _) => ty.span,\n+                _ => bug!(\"{:?} is not a trait const\", trait_const_item),\n+            }\n+        });\n+\n+        infcx.err_ctxt().note_type_err(\n+            &mut diag,\n+            &cause,\n+            trait_c_span.map(|span| (span, \"type in trait\".to_owned())),\n+            Some(infer::ValuePairs::Terms(ExpectedFound {\n+                expected: trait_ty.into(),\n+                found: impl_ty.into(),\n+            })),\n+            terr,\n+            false,\n+            false,\n+        );\n+        return Err(diag.emit());\n+    };\n+\n+    // Check that all obligations are satisfied by the implementation's\n+    // version.\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        return Err(infcx.err_ctxt().report_fulfillment_errors(&errors, None, false));\n+    }\n+\n+    // FIXME return `ErrorReported` if region obligations error?\n+    let outlives_environment = OutlivesEnvironment::new(param_env);\n+    infcx.check_region_obligations_and_report_errors(impl_const_item_def, &outlives_environment);\n+    Ok(())\n }\n \n pub(crate) fn compare_ty_impl<'tcx>(\n@@ -1490,52 +1478,50 @@ fn compare_type_predicate_entailment<'tcx>(\n         hir::Constness::NotConst,\n     );\n     let param_env = traits::normalize_param_env_or_error(tcx, param_env, normalize_cause);\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let ocx = ObligationCtxt::new(&infcx);\n+    let infcx = tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(&infcx);\n \n-        debug!(\"compare_type_predicate_entailment: caller_bounds={:?}\", param_env.caller_bounds());\n+    debug!(\"compare_type_predicate_entailment: caller_bounds={:?}\", param_env.caller_bounds());\n \n-        let mut selcx = traits::SelectionContext::new(&infcx);\n+    let mut selcx = traits::SelectionContext::new(&infcx);\n \n-        assert_eq!(impl_ty_own_bounds.predicates.len(), impl_ty_own_bounds.spans.len());\n-        for (span, predicate) in\n-            std::iter::zip(impl_ty_own_bounds.spans, impl_ty_own_bounds.predicates)\n-        {\n-            let cause = ObligationCause::misc(span, impl_ty_hir_id);\n-            let traits::Normalized { value: predicate, obligations } =\n-                traits::normalize(&mut selcx, param_env, cause, predicate);\n-\n-            let cause = ObligationCause::new(\n-                span,\n-                impl_ty_hir_id,\n-                ObligationCauseCode::CompareImplItemObligation {\n-                    impl_item_def_id: impl_ty.def_id.expect_local(),\n-                    trait_item_def_id: trait_ty.def_id,\n-                    kind: impl_ty.kind,\n-                },\n-            );\n-            ocx.register_obligations(obligations);\n-            ocx.register_obligation(traits::Obligation::new(cause, param_env, predicate));\n-        }\n-\n-        // Check that all obligations are satisfied by the implementation's\n-        // version.\n-        let errors = ocx.select_all_or_error();\n-        if !errors.is_empty() {\n-            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n-            return Err(reported);\n-        }\n+    assert_eq!(impl_ty_own_bounds.predicates.len(), impl_ty_own_bounds.spans.len());\n+    for (span, predicate) in std::iter::zip(impl_ty_own_bounds.spans, impl_ty_own_bounds.predicates)\n+    {\n+        let cause = ObligationCause::misc(span, impl_ty_hir_id);\n+        let traits::Normalized { value: predicate, obligations } =\n+            traits::normalize(&mut selcx, param_env, cause, predicate);\n \n-        // Finally, resolve all regions. This catches wily misuses of\n-        // lifetime parameters.\n-        let outlives_environment = OutlivesEnvironment::new(param_env);\n-        infcx.check_region_obligations_and_report_errors(\n-            impl_ty.def_id.expect_local(),\n-            &outlives_environment,\n+        let cause = ObligationCause::new(\n+            span,\n+            impl_ty_hir_id,\n+            ObligationCauseCode::CompareImplItemObligation {\n+                impl_item_def_id: impl_ty.def_id.expect_local(),\n+                trait_item_def_id: trait_ty.def_id,\n+                kind: impl_ty.kind,\n+            },\n         );\n+        ocx.register_obligations(obligations);\n+        ocx.register_obligation(traits::Obligation::new(cause, param_env, predicate));\n+    }\n \n-        Ok(())\n-    })\n+    // Check that all obligations are satisfied by the implementation's\n+    // version.\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        return Err(reported);\n+    }\n+\n+    // Finally, resolve all regions. This catches wily misuses of\n+    // lifetime parameters.\n+    let outlives_environment = OutlivesEnvironment::new(param_env);\n+    infcx.check_region_obligations_and_report_errors(\n+        impl_ty.def_id.expect_local(),\n+        &outlives_environment,\n+    );\n+\n+    Ok(())\n }\n \n /// Validate that `ProjectionCandidate`s created for this associated type will\n@@ -1695,95 +1681,94 @@ pub fn check_type_bounds<'tcx>(\n     let impl_ty_substs = InternalSubsts::identity_for_item(tcx, impl_ty.def_id);\n     let rebased_substs = impl_ty_substs.rebase_onto(tcx, container_id, impl_trait_ref.substs);\n \n-    tcx.infer_ctxt().enter(move |infcx| {\n-        let ocx = ObligationCtxt::new(&infcx);\n+    let infcx = tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(&infcx);\n \n-        let assumed_wf_types =\n-            ocx.assumed_wf_types(param_env, impl_ty_span, impl_ty.def_id.expect_local());\n+    let assumed_wf_types =\n+        ocx.assumed_wf_types(param_env, impl_ty_span, impl_ty.def_id.expect_local());\n \n-        let mut selcx = traits::SelectionContext::new(&infcx);\n-        let normalize_cause = ObligationCause::new(\n-            impl_ty_span,\n-            impl_ty_hir_id,\n-            ObligationCauseCode::CheckAssociatedTypeBounds {\n-                impl_item_def_id: impl_ty.def_id.expect_local(),\n-                trait_item_def_id: trait_ty.def_id,\n-            },\n-        );\n-        let mk_cause = |span: Span| {\n-            let code = if span.is_dummy() {\n-                traits::ItemObligation(trait_ty.def_id)\n-            } else {\n-                traits::BindingObligation(trait_ty.def_id, span)\n-            };\n-            ObligationCause::new(impl_ty_span, impl_ty_hir_id, code)\n+    let mut selcx = traits::SelectionContext::new(&infcx);\n+    let normalize_cause = ObligationCause::new(\n+        impl_ty_span,\n+        impl_ty_hir_id,\n+        ObligationCauseCode::CheckAssociatedTypeBounds {\n+            impl_item_def_id: impl_ty.def_id.expect_local(),\n+            trait_item_def_id: trait_ty.def_id,\n+        },\n+    );\n+    let mk_cause = |span: Span| {\n+        let code = if span.is_dummy() {\n+            traits::ItemObligation(trait_ty.def_id)\n+        } else {\n+            traits::BindingObligation(trait_ty.def_id, span)\n         };\n+        ObligationCause::new(impl_ty_span, impl_ty_hir_id, code)\n+    };\n \n-        let obligations = tcx\n-            .bound_explicit_item_bounds(trait_ty.def_id)\n-            .transpose_iter()\n-            .map(|e| e.map_bound(|e| *e).transpose_tuple2())\n-            .map(|(bound, span)| {\n-                debug!(?bound);\n-                // this is where opaque type is found\n-                let concrete_ty_bound = bound.subst(tcx, rebased_substs);\n-                debug!(\"check_type_bounds: concrete_ty_bound = {:?}\", concrete_ty_bound);\n-\n-                traits::Obligation::new(mk_cause(span.0), param_env, concrete_ty_bound)\n-            })\n-            .collect();\n-        debug!(\"check_type_bounds: item_bounds={:?}\", obligations);\n-\n-        for mut obligation in util::elaborate_obligations(tcx, obligations) {\n-            let traits::Normalized { value: normalized_predicate, obligations } = traits::normalize(\n-                &mut selcx,\n-                normalize_param_env,\n-                normalize_cause.clone(),\n-                obligation.predicate,\n-            );\n-            debug!(\"compare_projection_bounds: normalized predicate = {:?}\", normalized_predicate);\n-            obligation.predicate = normalized_predicate;\n+    let obligations = tcx\n+        .bound_explicit_item_bounds(trait_ty.def_id)\n+        .transpose_iter()\n+        .map(|e| e.map_bound(|e| *e).transpose_tuple2())\n+        .map(|(bound, span)| {\n+            debug!(?bound);\n+            // this is where opaque type is found\n+            let concrete_ty_bound = bound.subst(tcx, rebased_substs);\n+            debug!(\"check_type_bounds: concrete_ty_bound = {:?}\", concrete_ty_bound);\n+\n+            traits::Obligation::new(mk_cause(span.0), param_env, concrete_ty_bound)\n+        })\n+        .collect();\n+    debug!(\"check_type_bounds: item_bounds={:?}\", obligations);\n+\n+    for mut obligation in util::elaborate_obligations(tcx, obligations) {\n+        let traits::Normalized { value: normalized_predicate, obligations } = traits::normalize(\n+            &mut selcx,\n+            normalize_param_env,\n+            normalize_cause.clone(),\n+            obligation.predicate,\n+        );\n+        debug!(\"compare_projection_bounds: normalized predicate = {:?}\", normalized_predicate);\n+        obligation.predicate = normalized_predicate;\n \n-            ocx.register_obligations(obligations);\n-            ocx.register_obligation(obligation);\n-        }\n-        // Check that all obligations are satisfied by the implementation's\n-        // version.\n-        let errors = ocx.select_all_or_error();\n-        if !errors.is_empty() {\n-            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n-            return Err(reported);\n-        }\n+        ocx.register_obligations(obligations);\n+        ocx.register_obligation(obligation);\n+    }\n+    // Check that all obligations are satisfied by the implementation's\n+    // version.\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        return Err(reported);\n+    }\n \n-        // Finally, resolve all regions. This catches wily misuses of\n-        // lifetime parameters.\n-        let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_hir_id, assumed_wf_types);\n-        let outlives_environment =\n-            OutlivesEnvironment::with_bounds(param_env, Some(&infcx), implied_bounds);\n+    // Finally, resolve all regions. This catches wily misuses of\n+    // lifetime parameters.\n+    let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_hir_id, assumed_wf_types);\n+    let outlives_environment =\n+        OutlivesEnvironment::with_bounds(param_env, Some(&infcx), implied_bounds);\n \n-        infcx.check_region_obligations_and_report_errors(\n-            impl_ty.def_id.expect_local(),\n-            &outlives_environment,\n-        );\n+    infcx.check_region_obligations_and_report_errors(\n+        impl_ty.def_id.expect_local(),\n+        &outlives_environment,\n+    );\n \n-        let constraints = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-        for (key, value) in constraints {\n-            infcx\n-                .err_ctxt()\n-                .report_mismatched_types(\n-                    &ObligationCause::misc(\n-                        value.hidden_type.span,\n-                        tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local()),\n-                    ),\n-                    tcx.mk_opaque(key.def_id.to_def_id(), key.substs),\n-                    value.hidden_type.ty,\n-                    TypeError::Mismatch,\n-                )\n-                .emit();\n-        }\n+    let constraints = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+    for (key, value) in constraints {\n+        infcx\n+            .err_ctxt()\n+            .report_mismatched_types(\n+                &ObligationCause::misc(\n+                    value.hidden_type.span,\n+                    tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local()),\n+                ),\n+                tcx.mk_opaque(key.def_id.to_def_id(), key.substs),\n+                value.hidden_type.ty,\n+                TypeError::Mismatch,\n+            )\n+            .emit();\n+    }\n \n-        Ok(())\n-    })\n+    Ok(())\n }\n \n fn assoc_item_kind_str(impl_item: &ty::AssocItem) -> &'static str {"}, {"sha": "7a40def177ac9d85c813aa55e2a13ca5cce6b34f", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -876,18 +876,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let ty = self.tcx.erase_late_bound_regions(Binder::bind_with_vars(ty, bound_vars));\n             let ty = self.normalize_associated_types_in(expr.span, ty);\n             let ty = match self.tcx.asyncness(fn_id.owner) {\n-                hir::IsAsync::Async => self\n-                    .tcx\n-                    .infer_ctxt()\n-                    .enter(|infcx| {\n-                        infcx.get_impl_future_output_ty(ty).unwrap_or_else(|| {\n+                hir::IsAsync::Async => {\n+                    let infcx = self.tcx.infer_ctxt().build();\n+                    infcx\n+                        .get_impl_future_output_ty(ty)\n+                        .unwrap_or_else(|| {\n                             span_bug!(\n                                 fn_decl.output.span(),\n                                 \"failed to get output type of async function\"\n                             )\n                         })\n-                    })\n-                    .skip_binder(),\n+                        .skip_binder()\n+                }\n                 hir::IsAsync::NotAsync => ty,\n             };\n             if self.can_coerce(found, ty) {"}, {"sha": "0fb7651b3a1e1decbabc188f605e718ed56367c8", "filename": "compiler/rustc_hir_analysis/src/check/inherited.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Finherited.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -129,7 +129,7 @@ impl<'tcx> InheritedBuilder<'tcx> {\n         F: FnOnce(&Inherited<'tcx>) -> R,\n     {\n         let def_id = self.def_id;\n-        self.infcx.enter(|infcx| f(&Inherited::new(infcx, def_id, self.typeck_results)))\n+        f(&Inherited::new(self.infcx.build(), def_id, self.typeck_results))\n     }\n }\n "}, {"sha": "ba078ad0abbd9d1cff09d25a725c91352991a56f", "filename": "compiler/rustc_hir_analysis/src/check/method/probe.rs", "status": "modified", "additions": 56, "deletions": 60, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -472,69 +472,65 @@ fn method_autoderef_steps<'tcx>(\n ) -> MethodAutoderefStepsResult<'tcx> {\n     debug!(\"method_autoderef_steps({:?})\", goal);\n \n-    tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, &goal, |ref infcx, goal, inference_vars| {\n-        let ParamEnvAnd { param_env, value: self_ty } = goal;\n-\n-        let mut autoderef =\n-            Autoderef::new(infcx, param_env, hir::CRATE_HIR_ID, DUMMY_SP, self_ty, DUMMY_SP)\n-                .include_raw_pointers()\n-                .silence_errors();\n-        let mut reached_raw_pointer = false;\n-        let mut steps: Vec<_> = autoderef\n-            .by_ref()\n-            .map(|(ty, d)| {\n-                let step = CandidateStep {\n-                    self_ty: infcx.make_query_response_ignoring_pending_obligations(\n-                        inference_vars.clone(),\n-                        ty,\n-                    ),\n-                    autoderefs: d,\n-                    from_unsafe_deref: reached_raw_pointer,\n-                    unsize: false,\n-                };\n-                if let ty::RawPtr(_) = ty.kind() {\n-                    // all the subsequent steps will be from_unsafe_deref\n-                    reached_raw_pointer = true;\n-                }\n-                step\n-            })\n-            .collect();\n-\n-        let final_ty = autoderef.final_ty(true);\n-        let opt_bad_ty = match final_ty.kind() {\n-            ty::Infer(ty::TyVar(_)) | ty::Error(_) => Some(MethodAutoderefBadTy {\n-                reached_raw_pointer,\n-                ty: infcx\n-                    .make_query_response_ignoring_pending_obligations(inference_vars, final_ty),\n-            }),\n-            ty::Array(elem_ty, _) => {\n-                let dereferences = steps.len() - 1;\n-\n-                steps.push(CandidateStep {\n-                    self_ty: infcx.make_query_response_ignoring_pending_obligations(\n-                        inference_vars,\n-                        infcx.tcx.mk_slice(*elem_ty),\n-                    ),\n-                    autoderefs: dereferences,\n-                    // this could be from an unsafe deref if we had\n-                    // a *mut/const [T; N]\n-                    from_unsafe_deref: reached_raw_pointer,\n-                    unsize: true,\n-                });\n-\n-                None\n+    let (ref infcx, goal, inference_vars) = tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &goal);\n+    let ParamEnvAnd { param_env, value: self_ty } = goal;\n+\n+    let mut autoderef =\n+        Autoderef::new(infcx, param_env, hir::CRATE_HIR_ID, DUMMY_SP, self_ty, DUMMY_SP)\n+            .include_raw_pointers()\n+            .silence_errors();\n+    let mut reached_raw_pointer = false;\n+    let mut steps: Vec<_> = autoderef\n+        .by_ref()\n+        .map(|(ty, d)| {\n+            let step = CandidateStep {\n+                self_ty: infcx\n+                    .make_query_response_ignoring_pending_obligations(inference_vars.clone(), ty),\n+                autoderefs: d,\n+                from_unsafe_deref: reached_raw_pointer,\n+                unsize: false,\n+            };\n+            if let ty::RawPtr(_) = ty.kind() {\n+                // all the subsequent steps will be from_unsafe_deref\n+                reached_raw_pointer = true;\n             }\n-            _ => None,\n-        };\n-\n-        debug!(\"method_autoderef_steps: steps={:?} opt_bad_ty={:?}\", steps, opt_bad_ty);\n+            step\n+        })\n+        .collect();\n+\n+    let final_ty = autoderef.final_ty(true);\n+    let opt_bad_ty = match final_ty.kind() {\n+        ty::Infer(ty::TyVar(_)) | ty::Error(_) => Some(MethodAutoderefBadTy {\n+            reached_raw_pointer,\n+            ty: infcx.make_query_response_ignoring_pending_obligations(inference_vars, final_ty),\n+        }),\n+        ty::Array(elem_ty, _) => {\n+            let dereferences = steps.len() - 1;\n+\n+            steps.push(CandidateStep {\n+                self_ty: infcx.make_query_response_ignoring_pending_obligations(\n+                    inference_vars,\n+                    infcx.tcx.mk_slice(*elem_ty),\n+                ),\n+                autoderefs: dereferences,\n+                // this could be from an unsafe deref if we had\n+                // a *mut/const [T; N]\n+                from_unsafe_deref: reached_raw_pointer,\n+                unsize: true,\n+            });\n \n-        MethodAutoderefStepsResult {\n-            steps: tcx.arena.alloc_from_iter(steps),\n-            opt_bad_ty: opt_bad_ty.map(|ty| &*tcx.arena.alloc(ty)),\n-            reached_recursion_limit: autoderef.reached_recursion_limit(),\n+            None\n         }\n-    })\n+        _ => None,\n+    };\n+\n+    debug!(\"method_autoderef_steps: steps={:?} opt_bad_ty={:?}\", steps, opt_bad_ty);\n+\n+    MethodAutoderefStepsResult {\n+        steps: tcx.arena.alloc_from_iter(steps),\n+        opt_bad_ty: opt_bad_ty.map(|ty| &*tcx.arena.alloc(ty)),\n+        reached_recursion_limit: autoderef.reached_recursion_limit(),\n+    }\n }\n \n impl<'a, 'tcx> ProbeContext<'a, 'tcx> {"}, {"sha": "441eac03b50aeb3d3d8aafe30a9559c572f5367f", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -91,29 +91,28 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n {\n     let param_env = tcx.param_env(body_def_id);\n     let body_id = tcx.hir().local_def_id_to_hir_id(body_def_id);\n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        let ocx = ObligationCtxt::new(infcx);\n+    let infcx = &tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(infcx);\n \n-        let assumed_wf_types = ocx.assumed_wf_types(param_env, span, body_def_id);\n+    let assumed_wf_types = ocx.assumed_wf_types(param_env, span, body_def_id);\n \n-        let mut wfcx = WfCheckingCtxt { ocx, span, body_id, param_env };\n+    let mut wfcx = WfCheckingCtxt { ocx, span, body_id, param_env };\n \n-        if !tcx.features().trivial_bounds {\n-            wfcx.check_false_global_bounds()\n-        }\n-        f(&mut wfcx);\n-        let errors = wfcx.select_all_or_error();\n-        if !errors.is_empty() {\n-            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n-            return;\n-        }\n+    if !tcx.features().trivial_bounds {\n+        wfcx.check_false_global_bounds()\n+    }\n+    f(&mut wfcx);\n+    let errors = wfcx.select_all_or_error();\n+    if !errors.is_empty() {\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        return;\n+    }\n \n-        let implied_bounds = infcx.implied_bounds_tys(param_env, body_id, assumed_wf_types);\n-        let outlives_environment =\n-            OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n+    let implied_bounds = infcx.implied_bounds_tys(param_env, body_id, assumed_wf_types);\n+    let outlives_environment =\n+        OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n \n-        infcx.check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n-    })\n+    infcx.check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n }\n \n fn check_well_formed(tcx: TyCtxt<'_>, def_id: hir::OwnerId) {\n@@ -704,24 +703,23 @@ fn resolve_regions_with_wf_tys<'tcx>(\n     // Unfortunately, we have to use a new `InferCtxt` each call, because\n     // region constraints get added and solved there and we need to test each\n     // call individually.\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let outlives_environment = OutlivesEnvironment::with_bounds(\n-            param_env,\n-            Some(&infcx),\n-            infcx.implied_bounds_tys(param_env, id, wf_tys.clone()),\n-        );\n-        let region_bound_pairs = outlives_environment.region_bound_pairs();\n+    let infcx = tcx.infer_ctxt().build();\n+    let outlives_environment = OutlivesEnvironment::with_bounds(\n+        param_env,\n+        Some(&infcx),\n+        infcx.implied_bounds_tys(param_env, id, wf_tys.clone()),\n+    );\n+    let region_bound_pairs = outlives_environment.region_bound_pairs();\n \n-        add_constraints(&infcx, region_bound_pairs);\n+    add_constraints(&infcx, region_bound_pairs);\n \n-        let errors = infcx.resolve_regions(&outlives_environment);\n+    let errors = infcx.resolve_regions(&outlives_environment);\n \n-        debug!(?errors, \"errors\");\n+    debug!(?errors, \"errors\");\n \n-        // If we were able to prove that the type outlives the region without\n-        // an error, it must be because of the implied or explicit bounds...\n-        errors.is_empty()\n-    })\n+    // If we were able to prove that the type outlives the region without\n+    // an error, it must be because of the implied or explicit bounds...\n+    errors.is_empty()\n }\n \n /// TypeVisitor that looks for uses of GATs like"}, {"sha": "b6c91d425dff4bfd6ee4b788b5af7413962a10cd", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 314, "deletions": 331, "changes": 645, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -108,43 +108,42 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n                 // why this field does not implement Copy. This is useful because sometimes\n                 // it is not immediately clear why Copy is not implemented for a field, since\n                 // all we point at is the field itself.\n-                tcx.infer_ctxt().ignoring_regions().enter(|infcx| {\n-                    for error in traits::fully_solve_bound(\n-                        &infcx,\n-                        traits::ObligationCause::dummy_with_span(field_ty_span),\n-                        param_env,\n-                        ty,\n-                        tcx.lang_items().copy_trait().unwrap(),\n-                    ) {\n-                        let error_predicate = error.obligation.predicate;\n-                        // Only note if it's not the root obligation, otherwise it's trivial and\n-                        // should be self-explanatory (i.e. a field literally doesn't implement Copy).\n-\n-                        // FIXME: This error could be more descriptive, especially if the error_predicate\n-                        // contains a foreign type or if it's a deeply nested type...\n-                        if error_predicate != error.root_obligation.predicate {\n-                            errors\n-                                .entry((ty.to_string(), error_predicate.to_string()))\n-                                .or_default()\n-                                .push(error.obligation.cause.span);\n-                        }\n-                        if let ty::PredicateKind::Trait(ty::TraitPredicate {\n-                            trait_ref,\n-                            polarity: ty::ImplPolarity::Positive,\n-                            ..\n-                        }) = error_predicate.kind().skip_binder()\n-                        {\n-                            let ty = trait_ref.self_ty();\n-                            if let ty::Param(_) = ty.kind() {\n-                                bounds.push((\n-                                    format!(\"{ty}\"),\n-                                    trait_ref.print_only_trait_path().to_string(),\n-                                    Some(trait_ref.def_id),\n-                                ));\n-                            }\n+                let infcx = tcx.infer_ctxt().ignoring_regions().build();\n+                for error in traits::fully_solve_bound(\n+                    &infcx,\n+                    traits::ObligationCause::dummy_with_span(field_ty_span),\n+                    param_env,\n+                    ty,\n+                    tcx.lang_items().copy_trait().unwrap(),\n+                ) {\n+                    let error_predicate = error.obligation.predicate;\n+                    // Only note if it's not the root obligation, otherwise it's trivial and\n+                    // should be self-explanatory (i.e. a field literally doesn't implement Copy).\n+\n+                    // FIXME: This error could be more descriptive, especially if the error_predicate\n+                    // contains a foreign type or if it's a deeply nested type...\n+                    if error_predicate != error.root_obligation.predicate {\n+                        errors\n+                            .entry((ty.to_string(), error_predicate.to_string()))\n+                            .or_default()\n+                            .push(error.obligation.cause.span);\n+                    }\n+                    if let ty::PredicateKind::Trait(ty::TraitPredicate {\n+                        trait_ref,\n+                        polarity: ty::ImplPolarity::Positive,\n+                        ..\n+                    }) = error_predicate.kind().skip_binder()\n+                    {\n+                        let ty = trait_ref.self_ty();\n+                        if let ty::Param(_) = ty.kind() {\n+                            bounds.push((\n+                                format!(\"{ty}\"),\n+                                trait_ref.print_only_trait_path().to_string(),\n+                                Some(trait_ref.def_id),\n+                            ));\n                         }\n                     }\n-                });\n+                }\n             }\n             for ((ty, error_predicate), spans) in errors {\n                 let span: MultiSpan = spans.into();\n@@ -205,91 +204,89 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n \n     let create_err = |msg: &str| struct_span_err!(tcx.sess, span, E0378, \"{}\", msg);\n \n-    tcx.infer_ctxt().enter(|infcx| {\n-        let cause = ObligationCause::misc(span, impl_hir_id);\n-\n-        use rustc_type_ir::sty::TyKind::*;\n-        match (source.kind(), target.kind()) {\n-            (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n-                if infcx.at(&cause, param_env).eq(r_a, *r_b).is_ok() && mutbl_a == *mutbl_b => {}\n-            (&RawPtr(tm_a), &RawPtr(tm_b)) if tm_a.mutbl == tm_b.mutbl => (),\n-            (&Adt(def_a, substs_a), &Adt(def_b, substs_b))\n-                if def_a.is_struct() && def_b.is_struct() =>\n-            {\n-                if def_a != def_b {\n-                    let source_path = tcx.def_path_str(def_a.did());\n-                    let target_path = tcx.def_path_str(def_b.did());\n-\n-                    create_err(&format!(\n-                        \"the trait `DispatchFromDyn` may only be implemented \\\n-                                for a coercion between structures with the same \\\n-                                definition; expected `{}`, found `{}`\",\n-                        source_path, target_path,\n-                    ))\n-                    .emit();\n+    let infcx = tcx.infer_ctxt().build();\n+    let cause = ObligationCause::misc(span, impl_hir_id);\n+\n+    use rustc_type_ir::sty::TyKind::*;\n+    match (source.kind(), target.kind()) {\n+        (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n+            if infcx.at(&cause, param_env).eq(r_a, *r_b).is_ok() && mutbl_a == *mutbl_b => {}\n+        (&RawPtr(tm_a), &RawPtr(tm_b)) if tm_a.mutbl == tm_b.mutbl => (),\n+        (&Adt(def_a, substs_a), &Adt(def_b, substs_b))\n+            if def_a.is_struct() && def_b.is_struct() =>\n+        {\n+            if def_a != def_b {\n+                let source_path = tcx.def_path_str(def_a.did());\n+                let target_path = tcx.def_path_str(def_b.did());\n+\n+                create_err(&format!(\n+                    \"the trait `DispatchFromDyn` may only be implemented \\\n+                            for a coercion between structures with the same \\\n+                            definition; expected `{}`, found `{}`\",\n+                    source_path, target_path,\n+                ))\n+                .emit();\n \n-                    return;\n-                }\n+                return;\n+            }\n \n-                if def_a.repr().c() || def_a.repr().packed() {\n-                    create_err(\n-                        \"structs implementing `DispatchFromDyn` may not have \\\n-                             `#[repr(packed)]` or `#[repr(C)]`\",\n-                    )\n-                    .emit();\n-                }\n+            if def_a.repr().c() || def_a.repr().packed() {\n+                create_err(\n+                    \"structs implementing `DispatchFromDyn` may not have \\\n+                         `#[repr(packed)]` or `#[repr(C)]`\",\n+                )\n+                .emit();\n+            }\n \n-                let fields = &def_a.non_enum_variant().fields;\n+            let fields = &def_a.non_enum_variant().fields;\n \n-                let coerced_fields = fields\n-                    .iter()\n-                    .filter(|field| {\n-                        let ty_a = field.ty(tcx, substs_a);\n-                        let ty_b = field.ty(tcx, substs_b);\n+            let coerced_fields = fields\n+                .iter()\n+                .filter(|field| {\n+                    let ty_a = field.ty(tcx, substs_a);\n+                    let ty_b = field.ty(tcx, substs_b);\n \n-                        if let Ok(layout) = tcx.layout_of(param_env.and(ty_a)) {\n-                            if layout.is_zst() && layout.align.abi.bytes() == 1 {\n-                                // ignore ZST fields with alignment of 1 byte\n-                                return false;\n-                            }\n+                    if let Ok(layout) = tcx.layout_of(param_env.and(ty_a)) {\n+                        if layout.is_zst() && layout.align.abi.bytes() == 1 {\n+                            // ignore ZST fields with alignment of 1 byte\n+                            return false;\n                         }\n+                    }\n \n-                        if let Ok(ok) = infcx.at(&cause, param_env).eq(ty_a, ty_b) {\n-                            if ok.obligations.is_empty() {\n-                                create_err(\n-                                    \"the trait `DispatchFromDyn` may only be implemented \\\n-                                     for structs containing the field being coerced, \\\n-                                     ZST fields with 1 byte alignment, and nothing else\",\n-                                )\n-                                .note(&format!(\n-                                    \"extra field `{}` of type `{}` is not allowed\",\n-                                    field.name, ty_a,\n-                                ))\n-                                .emit();\n-\n-                                return false;\n-                            }\n+                    if let Ok(ok) = infcx.at(&cause, param_env).eq(ty_a, ty_b) {\n+                        if ok.obligations.is_empty() {\n+                            create_err(\n+                                \"the trait `DispatchFromDyn` may only be implemented \\\n+                                 for structs containing the field being coerced, \\\n+                                 ZST fields with 1 byte alignment, and nothing else\",\n+                            )\n+                            .note(&format!(\n+                                \"extra field `{}` of type `{}` is not allowed\",\n+                                field.name, ty_a,\n+                            ))\n+                            .emit();\n+\n+                            return false;\n                         }\n+                    }\n \n-                        return true;\n-                    })\n-                    .collect::<Vec<_>>();\n+                    return true;\n+                })\n+                .collect::<Vec<_>>();\n \n-                if coerced_fields.is_empty() {\n-                    create_err(\n-                        \"the trait `DispatchFromDyn` may only be implemented \\\n-                            for a coercion between structures with a single field \\\n-                            being coerced, none found\",\n-                    )\n-                    .emit();\n-                } else if coerced_fields.len() > 1 {\n-                    create_err(\n-                        \"implementing the `DispatchFromDyn` trait requires multiple coercions\",\n-                    )\n+            if coerced_fields.is_empty() {\n+                create_err(\n+                    \"the trait `DispatchFromDyn` may only be implemented \\\n+                        for a coercion between structures with a single field \\\n+                        being coerced, none found\",\n+                )\n+                .emit();\n+            } else if coerced_fields.len() > 1 {\n+                create_err(\"implementing the `DispatchFromDyn` trait requires multiple coercions\")\n                     .note(\n                         \"the trait `DispatchFromDyn` may only be implemented \\\n-                                for a coercion between structures with a single field \\\n-                                being coerced\",\n+                            for a coercion between structures with a single field \\\n+                            being coerced\",\n                     )\n                     .note(&format!(\n                         \"currently, {} fields need coercions: {}\",\n@@ -308,39 +305,38 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n                             .join(\", \")\n                     ))\n                     .emit();\n-                } else {\n-                    let errors = traits::fully_solve_obligations(\n-                        &infcx,\n-                        coerced_fields.into_iter().map(|field| {\n-                            predicate_for_trait_def(\n-                                tcx,\n-                                param_env,\n-                                cause.clone(),\n-                                dispatch_from_dyn_trait,\n-                                0,\n-                                field.ty(tcx, substs_a),\n-                                &[field.ty(tcx, substs_b).into()],\n-                            )\n-                        }),\n-                    );\n-                    if !errors.is_empty() {\n-                        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n-                    }\n-\n-                    // Finally, resolve all regions.\n-                    let outlives_env = OutlivesEnvironment::new(param_env);\n-                    infcx.check_region_obligations_and_report_errors(impl_did, &outlives_env);\n+            } else {\n+                let errors = traits::fully_solve_obligations(\n+                    &infcx,\n+                    coerced_fields.into_iter().map(|field| {\n+                        predicate_for_trait_def(\n+                            tcx,\n+                            param_env,\n+                            cause.clone(),\n+                            dispatch_from_dyn_trait,\n+                            0,\n+                            field.ty(tcx, substs_a),\n+                            &[field.ty(tcx, substs_b).into()],\n+                        )\n+                    }),\n+                );\n+                if !errors.is_empty() {\n+                    infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n                 }\n-            }\n-            _ => {\n-                create_err(\n-                    \"the trait `DispatchFromDyn` may only be implemented \\\n-                        for a coercion between structures\",\n-                )\n-                .emit();\n+\n+                // Finally, resolve all regions.\n+                let outlives_env = OutlivesEnvironment::new(param_env);\n+                infcx.check_region_obligations_and_report_errors(impl_did, &outlives_env);\n             }\n         }\n-    })\n+        _ => {\n+            create_err(\n+                \"the trait `DispatchFromDyn` may only be implemented \\\n+                    for a coercion between structures\",\n+            )\n+            .emit();\n+        }\n+    }\n }\n \n pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedInfo {\n@@ -369,221 +365,208 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n \n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (free)\", source, target);\n \n-    tcx.infer_ctxt().enter(|infcx| {\n-        let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_did);\n-        let cause = ObligationCause::misc(span, impl_hir_id);\n-        let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n-                           mt_b: ty::TypeAndMut<'tcx>,\n-                           mk_ptr: &dyn Fn(Ty<'tcx>) -> Ty<'tcx>| {\n-            if (mt_a.mutbl, mt_b.mutbl) == (hir::Mutability::Not, hir::Mutability::Mut) {\n-                infcx\n-                    .err_ctxt()\n-                    .report_mismatched_types(\n-                        &cause,\n-                        mk_ptr(mt_b.ty),\n-                        target,\n-                        ty::error::TypeError::Mutability,\n-                    )\n-                    .emit();\n-            }\n-            (mt_a.ty, mt_b.ty, unsize_trait, None)\n-        };\n-        let (source, target, trait_def_id, kind) = match (source.kind(), target.kind()) {\n-            (&ty::Ref(r_a, ty_a, mutbl_a), &ty::Ref(r_b, ty_b, mutbl_b)) => {\n-                infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n-                let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n-                let mt_b = ty::TypeAndMut { ty: ty_b, mutbl: mutbl_b };\n-                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n-            }\n+    let infcx = tcx.infer_ctxt().build();\n+    let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_did);\n+    let cause = ObligationCause::misc(span, impl_hir_id);\n+    let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n+                       mt_b: ty::TypeAndMut<'tcx>,\n+                       mk_ptr: &dyn Fn(Ty<'tcx>) -> Ty<'tcx>| {\n+        if (mt_a.mutbl, mt_b.mutbl) == (hir::Mutability::Not, hir::Mutability::Mut) {\n+            infcx\n+                .err_ctxt()\n+                .report_mismatched_types(\n+                    &cause,\n+                    mk_ptr(mt_b.ty),\n+                    target,\n+                    ty::error::TypeError::Mutability,\n+                )\n+                .emit();\n+        }\n+        (mt_a.ty, mt_b.ty, unsize_trait, None)\n+    };\n+    let (source, target, trait_def_id, kind) = match (source.kind(), target.kind()) {\n+        (&ty::Ref(r_a, ty_a, mutbl_a), &ty::Ref(r_b, ty_b, mutbl_b)) => {\n+            infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n+            let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n+            let mt_b = ty::TypeAndMut { ty: ty_b, mutbl: mutbl_b };\n+            check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n+        }\n \n-            (&ty::Ref(_, ty_a, mutbl_a), &ty::RawPtr(mt_b)) => {\n-                let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n-                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n-            }\n+        (&ty::Ref(_, ty_a, mutbl_a), &ty::RawPtr(mt_b)) => {\n+            let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n+            check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n+        }\n+\n+        (&ty::RawPtr(mt_a), &ty::RawPtr(mt_b)) => check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty)),\n \n-            (&ty::RawPtr(mt_a), &ty::RawPtr(mt_b)) => {\n-                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n+        (&ty::Adt(def_a, substs_a), &ty::Adt(def_b, substs_b))\n+            if def_a.is_struct() && def_b.is_struct() =>\n+        {\n+            if def_a != def_b {\n+                let source_path = tcx.def_path_str(def_a.did());\n+                let target_path = tcx.def_path_str(def_b.did());\n+                struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0377,\n+                    \"the trait `CoerceUnsized` may only be implemented \\\n+                           for a coercion between structures with the same \\\n+                           definition; expected `{}`, found `{}`\",\n+                    source_path,\n+                    target_path\n+                )\n+                .emit();\n+                return err_info;\n             }\n \n-            (&ty::Adt(def_a, substs_a), &ty::Adt(def_b, substs_b))\n-                if def_a.is_struct() && def_b.is_struct() =>\n-            {\n-                if def_a != def_b {\n-                    let source_path = tcx.def_path_str(def_a.did());\n-                    let target_path = tcx.def_path_str(def_b.did());\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        span,\n-                        E0377,\n-                        \"the trait `CoerceUnsized` may only be implemented \\\n-                               for a coercion between structures with the same \\\n-                               definition; expected `{}`, found `{}`\",\n-                        source_path,\n-                        target_path\n-                    )\n-                    .emit();\n-                    return err_info;\n-                }\n+            // Here we are considering a case of converting\n+            // `S<P0...Pn>` to S<Q0...Qn>`. As an example, let's imagine a struct `Foo<T, U>`,\n+            // which acts like a pointer to `U`, but carries along some extra data of type `T`:\n+            //\n+            //     struct Foo<T, U> {\n+            //         extra: T,\n+            //         ptr: *mut U,\n+            //     }\n+            //\n+            // We might have an impl that allows (e.g.) `Foo<T, [i32; 3]>` to be unsized\n+            // to `Foo<T, [i32]>`. That impl would look like:\n+            //\n+            //   impl<T, U: Unsize<V>, V> CoerceUnsized<Foo<T, V>> for Foo<T, U> {}\n+            //\n+            // Here `U = [i32; 3]` and `V = [i32]`. At runtime,\n+            // when this coercion occurs, we would be changing the\n+            // field `ptr` from a thin pointer of type `*mut [i32;\n+            // 3]` to a fat pointer of type `*mut [i32]` (with\n+            // extra data `3`).  **The purpose of this check is to\n+            // make sure that we know how to do this conversion.**\n+            //\n+            // To check if this impl is legal, we would walk down\n+            // the fields of `Foo` and consider their types with\n+            // both substitutes. We are looking to find that\n+            // exactly one (non-phantom) field has changed its\n+            // type, which we will expect to be the pointer that\n+            // is becoming fat (we could probably generalize this\n+            // to multiple thin pointers of the same type becoming\n+            // fat, but we don't). In this case:\n+            //\n+            // - `extra` has type `T` before and type `T` after\n+            // - `ptr` has type `*mut U` before and type `*mut V` after\n+            //\n+            // Since just one field changed, we would then check\n+            // that `*mut U: CoerceUnsized<*mut V>` is implemented\n+            // (in other words, that we know how to do this\n+            // conversion). This will work out because `U:\n+            // Unsize<V>`, and we have a builtin rule that `*mut\n+            // U` can be coerced to `*mut V` if `U: Unsize<V>`.\n+            let fields = &def_a.non_enum_variant().fields;\n+            let diff_fields = fields\n+                .iter()\n+                .enumerate()\n+                .filter_map(|(i, f)| {\n+                    let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n+\n+                    if tcx.type_of(f.did).is_phantom_data() {\n+                        // Ignore PhantomData fields\n+                        return None;\n+                    }\n \n-                // Here we are considering a case of converting\n-                // `S<P0...Pn>` to S<Q0...Qn>`. As an example, let's imagine a struct `Foo<T, U>`,\n-                // which acts like a pointer to `U`, but carries along some extra data of type `T`:\n-                //\n-                //     struct Foo<T, U> {\n-                //         extra: T,\n-                //         ptr: *mut U,\n-                //     }\n-                //\n-                // We might have an impl that allows (e.g.) `Foo<T, [i32; 3]>` to be unsized\n-                // to `Foo<T, [i32]>`. That impl would look like:\n-                //\n-                //   impl<T, U: Unsize<V>, V> CoerceUnsized<Foo<T, V>> for Foo<T, U> {}\n-                //\n-                // Here `U = [i32; 3]` and `V = [i32]`. At runtime,\n-                // when this coercion occurs, we would be changing the\n-                // field `ptr` from a thin pointer of type `*mut [i32;\n-                // 3]` to a fat pointer of type `*mut [i32]` (with\n-                // extra data `3`).  **The purpose of this check is to\n-                // make sure that we know how to do this conversion.**\n-                //\n-                // To check if this impl is legal, we would walk down\n-                // the fields of `Foo` and consider their types with\n-                // both substitutes. We are looking to find that\n-                // exactly one (non-phantom) field has changed its\n-                // type, which we will expect to be the pointer that\n-                // is becoming fat (we could probably generalize this\n-                // to multiple thin pointers of the same type becoming\n-                // fat, but we don't). In this case:\n-                //\n-                // - `extra` has type `T` before and type `T` after\n-                // - `ptr` has type `*mut U` before and type `*mut V` after\n-                //\n-                // Since just one field changed, we would then check\n-                // that `*mut U: CoerceUnsized<*mut V>` is implemented\n-                // (in other words, that we know how to do this\n-                // conversion). This will work out because `U:\n-                // Unsize<V>`, and we have a builtin rule that `*mut\n-                // U` can be coerced to `*mut V` if `U: Unsize<V>`.\n-                let fields = &def_a.non_enum_variant().fields;\n-                let diff_fields = fields\n-                    .iter()\n-                    .enumerate()\n-                    .filter_map(|(i, f)| {\n-                        let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n-\n-                        if tcx.type_of(f.did).is_phantom_data() {\n-                            // Ignore PhantomData fields\n+                    // Ignore fields that aren't changed; it may\n+                    // be that we could get away with subtyping or\n+                    // something more accepting, but we use\n+                    // equality because we want to be able to\n+                    // perform this check without computing\n+                    // variance where possible. (This is because\n+                    // we may have to evaluate constraint\n+                    // expressions in the course of execution.)\n+                    // See e.g., #41936.\n+                    if let Ok(ok) = infcx.at(&cause, param_env).eq(a, b) {\n+                        if ok.obligations.is_empty() {\n                             return None;\n                         }\n+                    }\n \n-                        // Ignore fields that aren't changed; it may\n-                        // be that we could get away with subtyping or\n-                        // something more accepting, but we use\n-                        // equality because we want to be able to\n-                        // perform this check without computing\n-                        // variance where possible. (This is because\n-                        // we may have to evaluate constraint\n-                        // expressions in the course of execution.)\n-                        // See e.g., #41936.\n-                        if let Ok(ok) = infcx.at(&cause, param_env).eq(a, b) {\n-                            if ok.obligations.is_empty() {\n-                                return None;\n-                            }\n-                        }\n+                    // Collect up all fields that were significantly changed\n+                    // i.e., those that contain T in coerce_unsized T -> U\n+                    Some((i, a, b))\n+                })\n+                .collect::<Vec<_>>();\n \n-                        // Collect up all fields that were significantly changed\n-                        // i.e., those that contain T in coerce_unsized T -> U\n-                        Some((i, a, b))\n-                    })\n-                    .collect::<Vec<_>>();\n-\n-                if diff_fields.is_empty() {\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        span,\n-                        E0374,\n-                        \"the trait `CoerceUnsized` may only be implemented \\\n-                               for a coercion between structures with one field \\\n-                               being coerced, none found\"\n-                    )\n-                    .emit();\n-                    return err_info;\n-                } else if diff_fields.len() > 1 {\n-                    let item = tcx.hir().expect_item(impl_did);\n-                    let span = if let ItemKind::Impl(hir::Impl { of_trait: Some(ref t), .. }) =\n-                        item.kind\n-                    {\n+            if diff_fields.is_empty() {\n+                struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0374,\n+                    \"the trait `CoerceUnsized` may only be implemented \\\n+                           for a coercion between structures with one field \\\n+                           being coerced, none found\"\n+                )\n+                .emit();\n+                return err_info;\n+            } else if diff_fields.len() > 1 {\n+                let item = tcx.hir().expect_item(impl_did);\n+                let span =\n+                    if let ItemKind::Impl(hir::Impl { of_trait: Some(ref t), .. }) = item.kind {\n                         t.path.span\n                     } else {\n                         tcx.def_span(impl_did)\n                     };\n \n-                    struct_span_err!(\n-                        tcx.sess,\n-                        span,\n-                        E0375,\n-                        \"implementing the trait \\\n-                                                    `CoerceUnsized` requires multiple \\\n-                                                    coercions\"\n-                    )\n-                    .note(\n-                        \"`CoerceUnsized` may only be implemented for \\\n-                              a coercion between structures with one field being coerced\",\n-                    )\n-                    .note(&format!(\n-                        \"currently, {} fields need coercions: {}\",\n-                        diff_fields.len(),\n-                        diff_fields\n-                            .iter()\n-                            .map(|&(i, a, b)| {\n-                                format!(\"`{}` (`{}` to `{}`)\", fields[i].name, a, b)\n-                            })\n-                            .collect::<Vec<_>>()\n-                            .join(\", \")\n-                    ))\n-                    .span_label(span, \"requires multiple coercions\")\n-                    .emit();\n-                    return err_info;\n-                }\n-\n-                let (i, a, b) = diff_fields[0];\n-                let kind = ty::adjustment::CustomCoerceUnsized::Struct(i);\n-                (a, b, coerce_unsized_trait, Some(kind))\n-            }\n-\n-            _ => {\n                 struct_span_err!(\n                     tcx.sess,\n                     span,\n-                    E0376,\n-                    \"the trait `CoerceUnsized` may only be implemented \\\n-                           for a coercion between structures\"\n+                    E0375,\n+                    \"implementing the trait \\\n+                                                `CoerceUnsized` requires multiple \\\n+                                                coercions\"\n+                )\n+                .note(\n+                    \"`CoerceUnsized` may only be implemented for \\\n+                          a coercion between structures with one field being coerced\",\n                 )\n+                .note(&format!(\n+                    \"currently, {} fields need coercions: {}\",\n+                    diff_fields.len(),\n+                    diff_fields\n+                        .iter()\n+                        .map(|&(i, a, b)| { format!(\"`{}` (`{}` to `{}`)\", fields[i].name, a, b) })\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")\n+                ))\n+                .span_label(span, \"requires multiple coercions\")\n                 .emit();\n                 return err_info;\n             }\n-        };\n-\n-        // Register an obligation for `A: Trait<B>`.\n-        let cause = traits::ObligationCause::misc(span, impl_hir_id);\n-        let predicate = predicate_for_trait_def(\n-            tcx,\n-            param_env,\n-            cause,\n-            trait_def_id,\n-            0,\n-            source,\n-            &[target.into()],\n-        );\n-        let errors = traits::fully_solve_obligation(&infcx, predicate);\n-        if !errors.is_empty() {\n-            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+\n+            let (i, a, b) = diff_fields[0];\n+            let kind = ty::adjustment::CustomCoerceUnsized::Struct(i);\n+            (a, b, coerce_unsized_trait, Some(kind))\n         }\n \n-        // Finally, resolve all regions.\n-        let outlives_env = OutlivesEnvironment::new(param_env);\n-        infcx.check_region_obligations_and_report_errors(impl_did, &outlives_env);\n+        _ => {\n+            struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0376,\n+                \"the trait `CoerceUnsized` may only be implemented \\\n+                       for a coercion between structures\"\n+            )\n+            .emit();\n+            return err_info;\n+        }\n+    };\n+\n+    // Register an obligation for `A: Trait<B>`.\n+    let cause = traits::ObligationCause::misc(span, impl_hir_id);\n+    let predicate =\n+        predicate_for_trait_def(tcx, param_env, cause, trait_def_id, 0, source, &[target.into()]);\n+    let errors = traits::fully_solve_obligation(&infcx, predicate);\n+    if !errors.is_empty() {\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+    }\n+\n+    // Finally, resolve all regions.\n+    let outlives_env = OutlivesEnvironment::new(param_env);\n+    infcx.check_region_obligations_and_report_errors(impl_did, &outlives_env);\n \n-        CoerceUnsizedInfo { custom_kind: kind }\n-    })\n+    CoerceUnsizedInfo { custom_kind: kind }\n }"}, {"sha": "53f636d19b41a1551aa11c6aa690ccd52a1c4357", "filename": "compiler/rustc_hir_analysis/src/hir_wf_check.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -64,38 +64,36 @@ fn diagnostic_hir_wf_check<'tcx>(\n \n     impl<'tcx> Visitor<'tcx> for HirWfCheck<'tcx> {\n         fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n-            self.tcx.infer_ctxt().enter(|infcx| {\n-                let tcx_ty =\n-                    self.icx.to_ty(ty).fold_with(&mut EraseAllBoundRegions { tcx: self.tcx });\n-                let cause = traits::ObligationCause::new(\n-                    ty.span,\n-                    self.hir_id,\n-                    traits::ObligationCauseCode::WellFormed(None),\n-                );\n-                let errors = traits::fully_solve_obligation(\n-                    &infcx,\n-                    traits::Obligation::new(\n-                        cause,\n-                        self.param_env,\n-                        ty::Binder::dummy(ty::PredicateKind::WellFormed(tcx_ty.into()))\n-                            .to_predicate(self.tcx),\n-                    ),\n-                );\n-                if !errors.is_empty() {\n-                    debug!(\"Wf-check got errors for {:?}: {:?}\", ty, errors);\n-                    for error in errors {\n-                        if error.obligation.predicate == self.predicate {\n-                            // Save the cause from the greatest depth - this corresponds\n-                            // to picking more-specific types (e.g. `MyStruct<u8>`)\n-                            // over less-specific types (e.g. `Option<MyStruct<u8>>`)\n-                            if self.depth >= self.cause_depth {\n-                                self.cause = Some(error.obligation.cause);\n-                                self.cause_depth = self.depth\n-                            }\n+            let infcx = self.tcx.infer_ctxt().build();\n+            let tcx_ty = self.icx.to_ty(ty).fold_with(&mut EraseAllBoundRegions { tcx: self.tcx });\n+            let cause = traits::ObligationCause::new(\n+                ty.span,\n+                self.hir_id,\n+                traits::ObligationCauseCode::WellFormed(None),\n+            );\n+            let errors = traits::fully_solve_obligation(\n+                &infcx,\n+                traits::Obligation::new(\n+                    cause,\n+                    self.param_env,\n+                    ty::Binder::dummy(ty::PredicateKind::WellFormed(tcx_ty.into()))\n+                        .to_predicate(self.tcx),\n+                ),\n+            );\n+            if !errors.is_empty() {\n+                debug!(\"Wf-check got errors for {:?}: {:?}\", ty, errors);\n+                for error in errors {\n+                    if error.obligation.predicate == self.predicate {\n+                        // Save the cause from the greatest depth - this corresponds\n+                        // to picking more-specific types (e.g. `MyStruct<u8>`)\n+                        // over less-specific types (e.g. `Option<MyStruct<u8>>`)\n+                        if self.depth >= self.cause_depth {\n+                            self.cause = Some(error.obligation.cause);\n+                            self.cause_depth = self.depth\n                         }\n                     }\n                 }\n-            });\n+            }\n             self.depth += 1;\n             intravisit::walk_ty(self, ty);\n             self.depth -= 1;"}, {"sha": "bfe5d4751e08f5eb489feaa05b4e249040873e0f", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 37, "deletions": 40, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -139,34 +139,33 @@ fn get_impl_substs<'tcx>(\n     impl1_def_id: LocalDefId,\n     impl2_node: Node,\n ) -> Option<(SubstsRef<'tcx>, SubstsRef<'tcx>)> {\n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        let ocx = ObligationCtxt::new(infcx);\n-        let param_env = tcx.param_env(impl1_def_id);\n-        let impl1_hir_id = tcx.hir().local_def_id_to_hir_id(impl1_def_id);\n+    let infcx = &tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(infcx);\n+    let param_env = tcx.param_env(impl1_def_id);\n+    let impl1_hir_id = tcx.hir().local_def_id_to_hir_id(impl1_def_id);\n \n-        let assumed_wf_types =\n-            ocx.assumed_wf_types(param_env, tcx.def_span(impl1_def_id), impl1_def_id);\n+    let assumed_wf_types =\n+        ocx.assumed_wf_types(param_env, tcx.def_span(impl1_def_id), impl1_def_id);\n \n-        let impl1_substs = InternalSubsts::identity_for_item(tcx, impl1_def_id.to_def_id());\n-        let impl2_substs =\n-            translate_substs(infcx, param_env, impl1_def_id.to_def_id(), impl1_substs, impl2_node);\n+    let impl1_substs = InternalSubsts::identity_for_item(tcx, impl1_def_id.to_def_id());\n+    let impl2_substs =\n+        translate_substs(infcx, param_env, impl1_def_id.to_def_id(), impl1_substs, impl2_node);\n \n-        let errors = ocx.select_all_or_error();\n-        if !errors.is_empty() {\n-            ocx.infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n-            return None;\n-        }\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        ocx.infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        return None;\n+    }\n \n-        let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_hir_id, assumed_wf_types);\n-        let outlives_env = OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n-        infcx.check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n-        let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n-            let span = tcx.def_span(impl1_def_id);\n-            tcx.sess.emit_err(SubstsOnOverriddenImpl { span });\n-            return None;\n-        };\n-        Some((impl1_substs, impl2_substs))\n-    })\n+    let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_hir_id, assumed_wf_types);\n+    let outlives_env = OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n+    infcx.check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n+    let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n+        let span = tcx.def_span(impl1_def_id);\n+        tcx.sess.emit_err(SubstsOnOverriddenImpl { span });\n+        return None;\n+    };\n+    Some((impl1_substs, impl2_substs))\n }\n \n /// Returns a list of all of the unconstrained subst of the given impl.\n@@ -344,23 +343,21 @@ fn check_predicates<'tcx>(\n \n     // Include the well-formed predicates of the type parameters of the impl.\n     for arg in tcx.impl_trait_ref(impl1_def_id).unwrap().substs {\n-        tcx.infer_ctxt().enter(|ref infcx| {\n-            let obligations = wf::obligations(\n-                infcx,\n-                tcx.param_env(impl1_def_id),\n-                tcx.hir().local_def_id_to_hir_id(impl1_def_id),\n-                0,\n-                arg,\n-                span,\n-            )\n-            .unwrap();\n+        let infcx = &tcx.infer_ctxt().build();\n+        let obligations = wf::obligations(\n+            infcx,\n+            tcx.param_env(impl1_def_id),\n+            tcx.hir().local_def_id_to_hir_id(impl1_def_id),\n+            0,\n+            arg,\n+            span,\n+        )\n+        .unwrap();\n \n-            assert!(!obligations.needs_infer());\n-            impl2_predicates.extend(\n-                traits::elaborate_obligations(tcx, obligations)\n-                    .map(|obligation| obligation.predicate),\n-            )\n-        })\n+        assert!(!obligations.needs_infer());\n+        impl2_predicates.extend(\n+            traits::elaborate_obligations(tcx, obligations).map(|obligation| obligation.predicate),\n+        )\n     }\n     impl2_predicates.extend(\n         traits::elaborate_predicates_with_span(tcx, always_applicable_traits)"}, {"sha": "b7d9fc8a2fe272b71b7af99f9254708950300687", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -141,24 +141,23 @@ fn require_same_types<'tcx>(\n     expected: Ty<'tcx>,\n     actual: Ty<'tcx>,\n ) -> bool {\n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        let param_env = ty::ParamEnv::empty();\n-        let errors = match infcx.at(cause, param_env).eq(expected, actual) {\n-            Ok(InferOk { obligations, .. }) => traits::fully_solve_obligations(infcx, obligations),\n-            Err(err) => {\n-                infcx.err_ctxt().report_mismatched_types(cause, expected, actual, err).emit();\n-                return false;\n-            }\n-        };\n+    let infcx = &tcx.infer_ctxt().build();\n+    let param_env = ty::ParamEnv::empty();\n+    let errors = match infcx.at(cause, param_env).eq(expected, actual) {\n+        Ok(InferOk { obligations, .. }) => traits::fully_solve_obligations(infcx, obligations),\n+        Err(err) => {\n+            infcx.err_ctxt().report_mismatched_types(cause, expected, actual, err).emit();\n+            return false;\n+        }\n+    };\n \n-        match &errors[..] {\n-            [] => true,\n-            errors => {\n-                infcx.err_ctxt().report_fulfillment_errors(errors, None, false);\n-                false\n-            }\n+    match &errors[..] {\n+        [] => true,\n+        errors => {\n+            infcx.err_ctxt().report_fulfillment_errors(errors, None, false);\n+            false\n         }\n-    })\n+    }\n }\n \n fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n@@ -305,23 +304,22 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n             error = true;\n         }\n         let return_ty = return_ty.skip_binder();\n-        tcx.infer_ctxt().enter(|infcx| {\n-            // Main should have no WC, so empty param env is OK here.\n-            let param_env = ty::ParamEnv::empty();\n-            let cause = traits::ObligationCause::new(\n-                return_ty_span,\n-                main_diagnostics_hir_id,\n-                ObligationCauseCode::MainFunctionType,\n-            );\n-            let ocx = traits::ObligationCtxt::new(&infcx);\n-            let norm_return_ty = ocx.normalize(cause.clone(), param_env, return_ty);\n-            ocx.register_bound(cause, param_env, norm_return_ty, term_did);\n-            let errors = ocx.select_all_or_error();\n-            if !errors.is_empty() {\n-                infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n-                error = true;\n-            }\n-        });\n+        let infcx = tcx.infer_ctxt().build();\n+        // Main should have no WC, so empty param env is OK here.\n+        let param_env = ty::ParamEnv::empty();\n+        let cause = traits::ObligationCause::new(\n+            return_ty_span,\n+            main_diagnostics_hir_id,\n+            ObligationCauseCode::MainFunctionType,\n+        );\n+        let ocx = traits::ObligationCtxt::new(&infcx);\n+        let norm_return_ty = ocx.normalize(cause.clone(), param_env, return_ty);\n+        ocx.register_bound(cause, param_env, norm_return_ty, term_did);\n+        let errors = ocx.select_all_or_error();\n+        if !errors.is_empty() {\n+            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+            error = true;\n+        }\n         // now we can take the return type of the given main function\n         expected_return_type = main_fnsig.output();\n     } else {"}, {"sha": "441dc3c7e888cb486ad78a3c7ace7562bec6c085", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -602,30 +602,27 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// `V` and a substitution `S`. This substitution `S` maps from\n     /// the bound values in `C` to their instantiated values in `V`\n     /// (in other words, `S(C) = V`).\n-    pub fn enter_with_canonical<T, R>(\n+    pub fn build_with_canonical<T>(\n         &mut self,\n         span: Span,\n         canonical: &Canonical<'tcx, T>,\n-        f: impl FnOnce(InferCtxt<'tcx>, T, CanonicalVarValues<'tcx>) -> R,\n-    ) -> R\n+    ) -> (InferCtxt<'tcx>, T, CanonicalVarValues<'tcx>)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        self.enter(|infcx| {\n-            let (value, subst) =\n-                infcx.instantiate_canonical_with_fresh_inference_vars(span, canonical);\n-            f(infcx, value, subst)\n-        })\n+        let infcx = self.build();\n+        let (value, subst) = infcx.instantiate_canonical_with_fresh_inference_vars(span, canonical);\n+        (infcx, value, subst)\n     }\n \n-    pub fn enter<R>(&mut self, f: impl FnOnce(InferCtxt<'tcx>) -> R) -> R {\n+    pub fn build(&mut self) -> InferCtxt<'tcx> {\n         let InferCtxtBuilder {\n             tcx,\n             defining_use_anchor,\n             considering_regions,\n             ref normalize_fn_sig_for_diagnostic,\n         } = *self;\n-        f(InferCtxt {\n+        InferCtxt {\n             tcx,\n             defining_use_anchor,\n             considering_regions,\n@@ -643,7 +640,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             normalize_fn_sig_for_diagnostic: normalize_fn_sig_for_diagnostic\n                 .as_ref()\n                 .map(|f| f.clone()),\n-        })\n+        }\n     }\n }\n "}, {"sha": "886b686e5e8d885dcddbdf659264b05c2eab29fa", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -151,21 +151,19 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n                 Some(ty_def) if cx.tcx.is_diagnostic_item(sym::String, ty_def.did()),\n             );\n \n-            let (suggest_display, suggest_debug) = cx.tcx.infer_ctxt().enter(|infcx| {\n-                let display = is_str\n-                    || cx.tcx.get_diagnostic_item(sym::Display).map(|t| {\n-                        infcx\n-                            .type_implements_trait(t, ty, InternalSubsts::empty(), cx.param_env)\n-                            .may_apply()\n-                    }) == Some(true);\n-                let debug = !display\n-                    && cx.tcx.get_diagnostic_item(sym::Debug).map(|t| {\n-                        infcx\n-                            .type_implements_trait(t, ty, InternalSubsts::empty(), cx.param_env)\n-                            .may_apply()\n-                    }) == Some(true);\n-                (display, debug)\n-            });\n+            let infcx = cx.tcx.infer_ctxt().build();\n+            let suggest_display = is_str\n+                || cx.tcx.get_diagnostic_item(sym::Display).map(|t| {\n+                    infcx\n+                        .type_implements_trait(t, ty, InternalSubsts::empty(), cx.param_env)\n+                        .may_apply()\n+                }) == Some(true);\n+            let suggest_debug = !suggest_display\n+                && cx.tcx.get_diagnostic_item(sym::Debug).map(|t| {\n+                    infcx\n+                        .type_implements_trait(t, ty, InternalSubsts::empty(), cx.param_env)\n+                        .may_apply()\n+                }) == Some(true);\n \n             let suggest_panic_any = !is_str && panic == sym::std_panic_macro;\n "}, {"sha": "81b9f55e7033aceffab179cc9789213e73aed64e", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "modified", "additions": 70, "deletions": 74, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -62,85 +62,81 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         let hir::ItemKind::OpaqueTy(_) = &item.kind else { return; };\n         let def_id = item.def_id.def_id.to_def_id();\n-        cx.tcx.infer_ctxt().enter(|ref infcx| {\n-            // For every projection predicate in the opaque type's explicit bounds,\n-            // check that the type that we're assigning actually satisfies the bounds\n-            // of the associated type.\n-            for &(pred, pred_span) in cx.tcx.explicit_item_bounds(def_id) {\n-                // Liberate bound regions in the predicate since we\n-                // don't actually care about lifetimes in this check.\n-                let predicate = cx.tcx.liberate_late_bound_regions(\n-                    def_id,\n-                    pred.kind(),\n-                );\n-                let ty::PredicateKind::Projection(proj) = predicate else {\n-                    continue;\n-                };\n-                // Only check types, since those are the only things that may\n-                // have opaques in them anyways.\n-                let Some(proj_term) = proj.term.ty() else { continue };\n+        let infcx = &cx.tcx.infer_ctxt().build();\n+        // For every projection predicate in the opaque type's explicit bounds,\n+        // check that the type that we're assigning actually satisfies the bounds\n+        // of the associated type.\n+        for &(pred, pred_span) in cx.tcx.explicit_item_bounds(def_id) {\n+            // Liberate bound regions in the predicate since we\n+            // don't actually care about lifetimes in this check.\n+            let predicate = cx.tcx.liberate_late_bound_regions(def_id, pred.kind());\n+            let ty::PredicateKind::Projection(proj) = predicate else {\n+                continue;\n+            };\n+            // Only check types, since those are the only things that may\n+            // have opaques in them anyways.\n+            let Some(proj_term) = proj.term.ty() else { continue };\n \n-                let proj_ty =\n-                    cx\n-                    .tcx\n-                    .mk_projection(proj.projection_ty.item_def_id, proj.projection_ty.substs);\n-                // For every instance of the projection type in the bounds,\n-                // replace them with the term we're assigning to the associated\n-                // type in our opaque type.\n-                let proj_replacer = &mut BottomUpFolder {\n-                    tcx: cx.tcx,\n-                    ty_op: |ty| if ty == proj_ty { proj_term } else { ty },\n-                    lt_op: |lt| lt,\n-                    ct_op: |ct| ct,\n+            let proj_ty =\n+                cx.tcx.mk_projection(proj.projection_ty.item_def_id, proj.projection_ty.substs);\n+            // For every instance of the projection type in the bounds,\n+            // replace them with the term we're assigning to the associated\n+            // type in our opaque type.\n+            let proj_replacer = &mut BottomUpFolder {\n+                tcx: cx.tcx,\n+                ty_op: |ty| if ty == proj_ty { proj_term } else { ty },\n+                lt_op: |lt| lt,\n+                ct_op: |ct| ct,\n+            };\n+            // For example, in `impl Trait<Assoc = impl Send>`, for all of the bounds on `Assoc`,\n+            // e.g. `type Assoc: OtherTrait`, replace `<impl Trait as Trait>::Assoc: OtherTrait`\n+            // with `impl Send: OtherTrait`.\n+            for assoc_pred_and_span in\n+                cx.tcx.bound_explicit_item_bounds(proj.projection_ty.item_def_id).transpose_iter()\n+            {\n+                let assoc_pred_span = assoc_pred_and_span.0.1;\n+                let assoc_pred = assoc_pred_and_span\n+                    .map_bound(|(pred, _)| *pred)\n+                    .subst(cx.tcx, &proj.projection_ty.substs)\n+                    .fold_with(proj_replacer);\n+                let Ok(assoc_pred) = traits::fully_normalize(infcx, traits::ObligationCause::dummy(), cx.param_env, assoc_pred) else {\n+                    continue;\n                 };\n-                // For example, in `impl Trait<Assoc = impl Send>`, for all of the bounds on `Assoc`,\n-                // e.g. `type Assoc: OtherTrait`, replace `<impl Trait as Trait>::Assoc: OtherTrait`\n-                // with `impl Send: OtherTrait`.\n-                for assoc_pred_and_span in cx\n-                    .tcx\n-                    .bound_explicit_item_bounds(proj.projection_ty.item_def_id)\n-                    .transpose_iter()\n-                {\n-                    let assoc_pred_span = assoc_pred_and_span.0.1;\n-                    let assoc_pred = assoc_pred_and_span\n-                        .map_bound(|(pred, _)| *pred)\n-                        .subst(cx.tcx, &proj.projection_ty.substs)\n-                        .fold_with(proj_replacer);\n-                    let Ok(assoc_pred) = traits::fully_normalize(infcx, traits::ObligationCause::dummy(), cx.param_env, assoc_pred) else {\n-                        continue;\n+                // If that predicate doesn't hold modulo regions (but passed during type-check),\n+                // then we must've taken advantage of the hack in `project_and_unify_types` where\n+                // we replace opaques with inference vars. Emit a warning!\n+                if !infcx.predicate_must_hold_modulo_regions(&traits::Obligation::new(\n+                    traits::ObligationCause::dummy(),\n+                    cx.param_env,\n+                    assoc_pred,\n+                )) {\n+                    // If it's a trait bound and an opaque that doesn't satisfy it,\n+                    // then we can emit a suggestion to add the bound.\n+                    let add_bound = match (proj_term.kind(), assoc_pred.kind().skip_binder()) {\n+                        (ty::Opaque(def_id, _), ty::PredicateKind::Trait(trait_pred)) => {\n+                            Some(AddBound {\n+                                suggest_span: cx.tcx.def_span(*def_id).shrink_to_hi(),\n+                                trait_ref: trait_pred.print_modifiers_and_trait_path(),\n+                            })\n+                        }\n+                        _ => None,\n                     };\n-                    // If that predicate doesn't hold modulo regions (but passed during type-check),\n-                    // then we must've taken advantage of the hack in `project_and_unify_types` where\n-                    // we replace opaques with inference vars. Emit a warning!\n-                    if !infcx.predicate_must_hold_modulo_regions(&traits::Obligation::new(\n-                        traits::ObligationCause::dummy(),\n-                        cx.param_env,\n-                        assoc_pred,\n-                    )) {\n-                        // If it's a trait bound and an opaque that doesn't satisfy it,\n-                        // then we can emit a suggestion to add the bound.\n-                        let add_bound =\n-                            match (proj_term.kind(), assoc_pred.kind().skip_binder()) {\n-                                (ty::Opaque(def_id, _), ty::PredicateKind::Trait(trait_pred)) => Some(AddBound {\n-                                    suggest_span: cx.tcx.def_span(*def_id).shrink_to_hi(),\n-                                    trait_ref: trait_pred.print_modifiers_and_trait_path(),\n-                                }),\n-                                _ => None,\n-                            };\n-                        cx.emit_spanned_lint(\n-                            OPAQUE_HIDDEN_INFERRED_BOUND,\n-                            pred_span,\n-                            OpaqueHiddenInferredBoundLint {\n-                                ty: cx.tcx.mk_opaque(def_id, ty::InternalSubsts::identity_for_item(cx.tcx, def_id)),\n-                                proj_ty: proj_term,\n-                                assoc_pred_span,\n-                                add_bound,\n-                            },\n-                        );\n-                    }\n+                    cx.emit_spanned_lint(\n+                        OPAQUE_HIDDEN_INFERRED_BOUND,\n+                        pred_span,\n+                        OpaqueHiddenInferredBoundLint {\n+                            ty: cx.tcx.mk_opaque(\n+                                def_id,\n+                                ty::InternalSubsts::identity_for_item(cx.tcx, def_id),\n+                            ),\n+                            proj_ty: proj_term,\n+                            assoc_pred_span,\n+                            add_bound,\n+                        },\n+                    );\n                 }\n             }\n-        });\n+        }\n     }\n }\n "}, {"sha": "cbcf9cd129f3f76c8886127cd9c10a167670c0de", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 61, "deletions": 67, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -481,54 +481,49 @@ fn construct_fn<'tcx>(\n         (None, fn_sig.output())\n     };\n \n-    let mut body = tcx.infer_ctxt().enter(|infcx| {\n-        let mut builder = Builder::new(\n-            thir,\n-            infcx,\n-            fn_def,\n-            fn_id,\n-            span_with_body,\n-            arguments.len(),\n-            safety,\n-            return_ty,\n-            return_ty_span,\n-            generator_kind,\n-        );\n+    let infcx = tcx.infer_ctxt().build();\n+    let mut builder = Builder::new(\n+        thir,\n+        infcx,\n+        fn_def,\n+        fn_id,\n+        span_with_body,\n+        arguments.len(),\n+        safety,\n+        return_ty,\n+        return_ty_span,\n+        generator_kind,\n+    );\n \n-        let call_site_scope =\n-            region::Scope { id: body_id.hir_id.local_id, data: region::ScopeData::CallSite };\n-        let arg_scope =\n-            region::Scope { id: body_id.hir_id.local_id, data: region::ScopeData::Arguments };\n-        let source_info = builder.source_info(span);\n-        let call_site_s = (call_site_scope, source_info);\n-        unpack!(builder.in_scope(call_site_s, LintLevel::Inherited, |builder| {\n-            let arg_scope_s = (arg_scope, source_info);\n-            // Attribute epilogue to function's closing brace\n-            let fn_end = span_with_body.shrink_to_hi();\n-            let return_block = unpack!(builder.in_breakable_scope(\n-                None,\n-                Place::return_place(),\n-                fn_end,\n-                |builder| {\n-                    Some(builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n-                        builder.args_and_body(\n-                            START_BLOCK,\n-                            fn_def.did,\n-                            arguments,\n-                            arg_scope,\n-                            &thir[expr],\n-                        )\n-                    }))\n-                }\n-            ));\n-            let source_info = builder.source_info(fn_end);\n-            builder.cfg.terminate(return_block, source_info, TerminatorKind::Return);\n-            builder.build_drop_trees();\n-            return_block.unit()\n-        }));\n-\n-        builder.finish()\n-    });\n+    let call_site_scope =\n+        region::Scope { id: body_id.hir_id.local_id, data: region::ScopeData::CallSite };\n+    let arg_scope =\n+        region::Scope { id: body_id.hir_id.local_id, data: region::ScopeData::Arguments };\n+    let source_info = builder.source_info(span);\n+    let call_site_s = (call_site_scope, source_info);\n+    unpack!(builder.in_scope(call_site_s, LintLevel::Inherited, |builder| {\n+        let arg_scope_s = (arg_scope, source_info);\n+        // Attribute epilogue to function's closing brace\n+        let fn_end = span_with_body.shrink_to_hi();\n+        let return_block =\n+            unpack!(builder.in_breakable_scope(None, Place::return_place(), fn_end, |builder| {\n+                Some(builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n+                    builder.args_and_body(\n+                        START_BLOCK,\n+                        fn_def.did,\n+                        arguments,\n+                        arg_scope,\n+                        &thir[expr],\n+                    )\n+                }))\n+            }));\n+        let source_info = builder.source_info(fn_end);\n+        builder.cfg.terminate(return_block, source_info, TerminatorKind::Return);\n+        builder.build_drop_trees();\n+        return_block.unit()\n+    }));\n+\n+    let mut body = builder.finish();\n \n     body.spread_arg = if abi == Abi::RustCall {\n         // RustCall pseudo-ABI untuples the last argument.\n@@ -584,30 +579,29 @@ fn construct_const<'a, 'tcx>(\n     let typeck_results = tcx.typeck_opt_const_arg(def);\n     let const_ty = typeck_results.node_type(hir_id);\n \n-    tcx.infer_ctxt().enter(|infcx| {\n-        let mut builder = Builder::new(\n-            thir,\n-            infcx,\n-            def,\n-            hir_id,\n-            span,\n-            0,\n-            Safety::Safe,\n-            const_ty,\n-            const_ty_span,\n-            None,\n-        );\n+    let infcx = tcx.infer_ctxt().build();\n+    let mut builder = Builder::new(\n+        thir,\n+        infcx,\n+        def,\n+        hir_id,\n+        span,\n+        0,\n+        Safety::Safe,\n+        const_ty,\n+        const_ty_span,\n+        None,\n+    );\n \n-        let mut block = START_BLOCK;\n-        unpack!(block = builder.expr_into_dest(Place::return_place(), block, &thir[expr]));\n+    let mut block = START_BLOCK;\n+    unpack!(block = builder.expr_into_dest(Place::return_place(), block, &thir[expr]));\n \n-        let source_info = builder.source_info(span);\n-        builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n+    let source_info = builder.source_info(span);\n+    builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n \n-        builder.build_drop_trees();\n+    builder.build_drop_trees();\n \n-        builder.finish()\n-    })\n+    builder.finish()\n }\n \n /// Construct MIR for an item that has had errors in type checking."}, {"sha": "cf8ae776be969ce8d4812ebe089ed273e229d40f", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -28,10 +28,9 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         span: Span,\n         mir_structural_match_violation: bool,\n     ) -> Box<Pat<'tcx>> {\n-        self.tcx.infer_ctxt().enter(|infcx| {\n-            let mut convert = ConstToPat::new(self, id, span, infcx);\n-            convert.to_pat(cv, mir_structural_match_violation)\n-        })\n+        let infcx = self.tcx.infer_ctxt().build();\n+        let mut convert = ConstToPat::new(self, id, span, infcx);\n+        convert.to_pat(cv, mir_structural_match_violation)\n     }\n }\n "}, {"sha": "1b58c9b864e4265386b13828038ee7c786a7d9cc", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -177,18 +177,10 @@ impl<'tcx> InferCtxtBuilderExt<'tcx> for InferCtxtBuilder<'tcx> {\n         R: Debug + TypeFoldable<'tcx>,\n         Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable<'tcx>,\n     {\n-        self.enter_with_canonical(\n-            DUMMY_SP,\n-            canonical_key,\n-            |ref infcx, key, canonical_inference_vars| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-                let value = operation(infcx, &mut *fulfill_cx, key)?;\n-                infcx.make_canonicalized_query_response(\n-                    canonical_inference_vars,\n-                    value,\n-                    &mut *fulfill_cx,\n-                )\n-            },\n-        )\n+        let (ref infcx, key, canonical_inference_vars) =\n+            self.build_with_canonical(DUMMY_SP, canonical_key);\n+        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+        let value = operation(infcx, &mut *fulfill_cx, key)?;\n+        infcx.make_canonicalized_query_response(canonical_inference_vars, value, &mut *fulfill_cx)\n     }\n }"}, {"sha": "c716c4b0be9051a6dddbd99b68ca83ceed1a2bce", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 91, "deletions": 129, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -10,7 +10,7 @@ use crate::traits::project::ProjectAndUnifyResult;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{Region, RegionVid};\n+use rustc_middle::ty::{PolyTraitRef, Region, RegionVid};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n \n@@ -90,143 +90,105 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n \n         let trait_pred = ty::Binder::dummy(trait_ref);\n \n-        let bail_out = tcx.infer_ctxt().enter(|infcx| {\n-            let mut selcx = SelectionContext::new(&infcx);\n-            let result = selcx.select(&Obligation::new(\n-                ObligationCause::dummy(),\n-                orig_env,\n-                trait_pred.to_poly_trait_predicate(),\n-            ));\n-\n-            match result {\n-                Ok(Some(ImplSource::UserDefined(_))) => {\n-                    debug!(\n-                        \"find_auto_trait_generics({:?}): \\\n-                         manual impl found, bailing out\",\n-                        trait_ref\n-                    );\n-                    return true;\n-                }\n-                _ => {}\n+        let infcx = tcx.infer_ctxt().build();\n+        let mut selcx = SelectionContext::new(&infcx);\n+        for f in [\n+            PolyTraitRef::to_poly_trait_predicate,\n+            PolyTraitRef::to_poly_trait_predicate_negative_polarity,\n+        ] {\n+            let result =\n+                selcx.select(&Obligation::new(ObligationCause::dummy(), orig_env, f(&trait_pred)));\n+            if let Ok(Some(ImplSource::UserDefined(_))) = result {\n+                debug!(\n+                    \"find_auto_trait_generics({:?}): \\\n+                 manual impl found, bailing out\",\n+                    trait_ref\n+                );\n+                // If an explicit impl exists, it always takes priority over an auto impl\n+                return AutoTraitResult::ExplicitImpl;\n             }\n-\n-            let result = selcx.select(&Obligation::new(\n-                ObligationCause::dummy(),\n-                orig_env,\n-                trait_pred.to_poly_trait_predicate_negative_polarity(),\n-            ));\n-\n-            match result {\n-                Ok(Some(ImplSource::UserDefined(_))) => {\n-                    debug!(\n-                        \"find_auto_trait_generics({:?}): \\\n-                         manual impl found, bailing out\",\n-                        trait_ref\n-                    );\n-                    true\n-                }\n-                _ => false,\n-            }\n-        });\n-\n-        // If an explicit impl exists, it always takes priority over an auto impl\n-        if bail_out {\n-            return AutoTraitResult::ExplicitImpl;\n         }\n \n-        tcx.infer_ctxt().enter(|infcx| {\n-            let mut fresh_preds = FxHashSet::default();\n+        let infcx = tcx.infer_ctxt().build();\n+        let mut fresh_preds = FxHashSet::default();\n+\n+        // Due to the way projections are handled by SelectionContext, we need to run\n+        // evaluate_predicates twice: once on the original param env, and once on the result of\n+        // the first evaluate_predicates call.\n+        //\n+        // The problem is this: most of rustc, including SelectionContext and traits::project,\n+        // are designed to work with a concrete usage of a type (e.g., Vec<u8>\n+        // fn<T>() { Vec<T> }. This information will generally never change - given\n+        // the 'T' in fn<T>() { ... }, we'll never know anything else about 'T'.\n+        // If we're unable to prove that 'T' implements a particular trait, we're done -\n+        // there's nothing left to do but error out.\n+        //\n+        // However, synthesizing an auto trait impl works differently. Here, we start out with\n+        // a set of initial conditions - the ParamEnv of the struct/enum/union we're dealing\n+        // with - and progressively discover the conditions we need to fulfill for it to\n+        // implement a certain auto trait. This ends up breaking two assumptions made by trait\n+        // selection and projection:\n+        //\n+        // * We can always cache the result of a particular trait selection for the lifetime of\n+        // an InfCtxt\n+        // * Given a projection bound such as '<T as SomeTrait>::SomeItem = K', if 'T:\n+        // SomeTrait' doesn't hold, then we don't need to care about the 'SomeItem = K'\n+        //\n+        // We fix the first assumption by manually clearing out all of the InferCtxt's caches\n+        // in between calls to SelectionContext.select. This allows us to keep all of the\n+        // intermediate types we create bound to the 'tcx lifetime, rather than needing to lift\n+        // them between calls.\n+        //\n+        // We fix the second assumption by reprocessing the result of our first call to\n+        // evaluate_predicates. Using the example of '<T as SomeTrait>::SomeItem = K', our first\n+        // pass will pick up 'T: SomeTrait', but not 'SomeItem = K'. On our second pass,\n+        // traits::project will see that 'T: SomeTrait' is in our ParamEnv, allowing\n+        // SelectionContext to return it back to us.\n+\n+        let Some((new_env, user_env)) = self.evaluate_predicates(\n+            &infcx,\n+            trait_did,\n+            ty,\n+            orig_env,\n+            orig_env,\n+            &mut fresh_preds,\n+            false,\n+        ) else {\n+            return AutoTraitResult::NegativeImpl;\n+        };\n+\n+        let (full_env, full_user_env) = self\n+            .evaluate_predicates(&infcx, trait_did, ty, new_env, user_env, &mut fresh_preds, true)\n+            .unwrap_or_else(|| {\n+                panic!(\"Failed to fully process: {:?} {:?} {:?}\", ty, trait_did, orig_env)\n+            });\n \n-            // Due to the way projections are handled by SelectionContext, we need to run\n-            // evaluate_predicates twice: once on the original param env, and once on the result of\n-            // the first evaluate_predicates call.\n-            //\n-            // The problem is this: most of rustc, including SelectionContext and traits::project,\n-            // are designed to work with a concrete usage of a type (e.g., Vec<u8>\n-            // fn<T>() { Vec<T> }. This information will generally never change - given\n-            // the 'T' in fn<T>() { ... }, we'll never know anything else about 'T'.\n-            // If we're unable to prove that 'T' implements a particular trait, we're done -\n-            // there's nothing left to do but error out.\n-            //\n-            // However, synthesizing an auto trait impl works differently. Here, we start out with\n-            // a set of initial conditions - the ParamEnv of the struct/enum/union we're dealing\n-            // with - and progressively discover the conditions we need to fulfill for it to\n-            // implement a certain auto trait. This ends up breaking two assumptions made by trait\n-            // selection and projection:\n-            //\n-            // * We can always cache the result of a particular trait selection for the lifetime of\n-            // an InfCtxt\n-            // * Given a projection bound such as '<T as SomeTrait>::SomeItem = K', if 'T:\n-            // SomeTrait' doesn't hold, then we don't need to care about the 'SomeItem = K'\n-            //\n-            // We fix the first assumption by manually clearing out all of the InferCtxt's caches\n-            // in between calls to SelectionContext.select. This allows us to keep all of the\n-            // intermediate types we create bound to the 'tcx lifetime, rather than needing to lift\n-            // them between calls.\n-            //\n-            // We fix the second assumption by reprocessing the result of our first call to\n-            // evaluate_predicates. Using the example of '<T as SomeTrait>::SomeItem = K', our first\n-            // pass will pick up 'T: SomeTrait', but not 'SomeItem = K'. On our second pass,\n-            // traits::project will see that 'T: SomeTrait' is in our ParamEnv, allowing\n-            // SelectionContext to return it back to us.\n-\n-            let Some((new_env, user_env)) = self.evaluate_predicates(\n-                &infcx,\n-                trait_did,\n-                ty,\n-                orig_env,\n-                orig_env,\n-                &mut fresh_preds,\n-                false,\n-            ) else {\n-                return AutoTraitResult::NegativeImpl;\n-            };\n-\n-            let (full_env, full_user_env) = self\n-                .evaluate_predicates(\n-                    &infcx,\n-                    trait_did,\n-                    ty,\n-                    new_env,\n-                    user_env,\n-                    &mut fresh_preds,\n-                    true,\n-                )\n-                .unwrap_or_else(|| {\n-                    panic!(\"Failed to fully process: {:?} {:?} {:?}\", ty, trait_did, orig_env)\n-                });\n-\n-            debug!(\n-                \"find_auto_trait_generics({:?}): fulfilling \\\n-                 with {:?}\",\n-                trait_ref, full_env\n-            );\n-            infcx.clear_caches();\n-\n-            // At this point, we already have all of the bounds we need. FulfillmentContext is used\n-            // to store all of the necessary region/lifetime bounds in the InferContext, as well as\n-            // an additional sanity check.\n-            let errors =\n-                super::fully_solve_bound(&infcx, ObligationCause::dummy(), full_env, ty, trait_did);\n-            if !errors.is_empty() {\n-                panic!(\"Unable to fulfill trait {:?} for '{:?}': {:?}\", trait_did, ty, errors);\n-            }\n+        debug!(\n+            \"find_auto_trait_generics({:?}): fulfilling \\\n+             with {:?}\",\n+            trait_ref, full_env\n+        );\n+        infcx.clear_caches();\n+\n+        // At this point, we already have all of the bounds we need. FulfillmentContext is used\n+        // to store all of the necessary region/lifetime bounds in the InferContext, as well as\n+        // an additional sanity check.\n+        let errors =\n+            super::fully_solve_bound(&infcx, ObligationCause::dummy(), full_env, ty, trait_did);\n+        if !errors.is_empty() {\n+            panic!(\"Unable to fulfill trait {:?} for '{:?}': {:?}\", trait_did, ty, errors);\n+        }\n \n-            infcx.process_registered_region_obligations(&Default::default(), full_env);\n+        infcx.process_registered_region_obligations(&Default::default(), full_env);\n \n-            let region_data = infcx\n-                .inner\n-                .borrow_mut()\n-                .unwrap_region_constraints()\n-                .region_constraint_data()\n-                .clone();\n+        let region_data =\n+            infcx.inner.borrow_mut().unwrap_region_constraints().region_constraint_data().clone();\n \n-            let vid_to_region = self.map_vid_to_region(&region_data);\n+        let vid_to_region = self.map_vid_to_region(&region_data);\n \n-            let info = AutoTraitInfo { full_user_env, region_data, vid_to_region };\n+        let info = AutoTraitInfo { full_user_env, region_data, vid_to_region };\n \n-            AutoTraitResult::PositiveImpl(auto_trait_callback(info))\n-        })\n+        AutoTraitResult::PositiveImpl(auto_trait_callback(info))\n     }\n }\n "}, {"sha": "8a62bf015674a5a392fbdc11f232ebc2cf1f4dd6", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -29,60 +29,61 @@ pub fn codegen_select_candidate<'tcx>(\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    let mut infcx_builder =\n-        tcx.infer_ctxt().ignoring_regions().with_opaque_type_inference(DefiningAnchor::Bubble);\n-    infcx_builder.enter(|infcx| {\n-        //~^ HACK `Bubble` is required for\n-        // this test to pass: type-alias-impl-trait/assoc-projection-ice.rs\n-        let mut selcx = SelectionContext::new(&infcx);\n+    let infcx = tcx\n+        .infer_ctxt()\n+        .ignoring_regions()\n+        .with_opaque_type_inference(DefiningAnchor::Bubble)\n+        .build();\n+    //~^ HACK `Bubble` is required for\n+    // this test to pass: type-alias-impl-trait/assoc-projection-ice.rs\n+    let mut selcx = SelectionContext::new(&infcx);\n \n-        let obligation_cause = ObligationCause::dummy();\n-        let obligation =\n-            Obligation::new(obligation_cause, param_env, trait_ref.to_poly_trait_predicate());\n+    let obligation_cause = ObligationCause::dummy();\n+    let obligation =\n+        Obligation::new(obligation_cause, param_env, trait_ref.to_poly_trait_predicate());\n \n-        let selection = match selcx.select(&obligation) {\n-            Ok(Some(selection)) => selection,\n-            Ok(None) => return Err(CodegenObligationError::Ambiguity),\n-            Err(Unimplemented) => return Err(CodegenObligationError::Unimplemented),\n-            Err(e) => {\n-                bug!(\"Encountered error `{:?}` selecting `{:?}` during codegen\", e, trait_ref)\n-            }\n-        };\n+    let selection = match selcx.select(&obligation) {\n+        Ok(Some(selection)) => selection,\n+        Ok(None) => return Err(CodegenObligationError::Ambiguity),\n+        Err(Unimplemented) => return Err(CodegenObligationError::Unimplemented),\n+        Err(e) => {\n+            bug!(\"Encountered error `{:?}` selecting `{:?}` during codegen\", e, trait_ref)\n+        }\n+    };\n \n-        debug!(?selection);\n+    debug!(?selection);\n \n-        // Currently, we use a fulfillment context to completely resolve\n-        // all nested obligations. This is because they can inform the\n-        // inference of the impl's type parameters.\n-        let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(tcx);\n-        let impl_source = selection.map(|predicate| {\n-            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-        });\n+    // Currently, we use a fulfillment context to completely resolve\n+    // all nested obligations. This is because they can inform the\n+    // inference of the impl's type parameters.\n+    let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(tcx);\n+    let impl_source = selection.map(|predicate| {\n+        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+    });\n \n-        // In principle, we only need to do this so long as `impl_source`\n-        // contains unbound type parameters. It could be a slight\n-        // optimization to stop iterating early.\n-        let errors = fulfill_cx.select_all_or_error(&infcx);\n-        if !errors.is_empty() {\n-            // `rustc_monomorphize::collector` assumes there are no type errors.\n-            // Cycle errors are the only post-monomorphization errors possible; emit them now so\n-            // `rustc_ty_utils::resolve_associated_item` doesn't return `None` post-monomorphization.\n-            for err in errors {\n-                if let FulfillmentErrorCode::CodeCycle(cycle) = err.code {\n-                    infcx.err_ctxt().report_overflow_error_cycle(&cycle);\n-                }\n+    // In principle, we only need to do this so long as `impl_source`\n+    // contains unbound type parameters. It could be a slight\n+    // optimization to stop iterating early.\n+    let errors = fulfill_cx.select_all_or_error(&infcx);\n+    if !errors.is_empty() {\n+        // `rustc_monomorphize::collector` assumes there are no type errors.\n+        // Cycle errors are the only post-monomorphization errors possible; emit them now so\n+        // `rustc_ty_utils::resolve_associated_item` doesn't return `None` post-monomorphization.\n+        for err in errors {\n+            if let FulfillmentErrorCode::CodeCycle(cycle) = err.code {\n+                infcx.err_ctxt().report_overflow_error_cycle(&cycle);\n             }\n-            return Err(CodegenObligationError::FulfillmentError);\n         }\n+        return Err(CodegenObligationError::FulfillmentError);\n+    }\n \n-        let impl_source = infcx.resolve_vars_if_possible(impl_source);\n-        let impl_source = infcx.tcx.erase_regions(impl_source);\n+    let impl_source = infcx.resolve_vars_if_possible(impl_source);\n+    let impl_source = infcx.tcx.erase_regions(impl_source);\n \n-        // Opaque types may have gotten their hidden types constrained, but we can ignore them safely\n-        // as they will get constrained elsewhere, too.\n-        // (ouz-a) This is required for `type-alias-impl-trait/assoc-projection-ice.rs` to pass\n-        let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+    // Opaque types may have gotten their hidden types constrained, but we can ignore them safely\n+    // as they will get constrained elsewhere, too.\n+    // (ouz-a) This is required for `type-alias-impl-trait/assoc-projection-ice.rs` to pass\n+    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n \n-        Ok(&*tcx.arena.alloc(impl_source))\n-    })\n+    Ok(&*tcx.arena.alloc(impl_source))\n }"}, {"sha": "7fc5c2ed0eae72408f23fb50a4bf467a53bc0683", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -100,25 +100,21 @@ where\n         return no_overlap();\n     }\n \n-    let overlaps = tcx.infer_ctxt().enter(|infcx| {\n-        let selcx = &mut SelectionContext::intercrate(&infcx);\n-        overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).is_some()\n-    });\n-\n+    let infcx = tcx.infer_ctxt().build();\n+    let selcx = &mut SelectionContext::intercrate(&infcx);\n+    let overlaps =\n+        overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).is_some();\n     if !overlaps {\n         return no_overlap();\n     }\n \n     // In the case where we detect an error, run the check again, but\n     // this time tracking intercrate ambiguity causes for better\n     // diagnostics. (These take time and can lead to false errors.)\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let selcx = &mut SelectionContext::intercrate(&infcx);\n-        selcx.enable_tracking_intercrate_ambiguity_causes();\n-        on_overlap(\n-            overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).unwrap(),\n-        )\n-    })\n+    let infcx = tcx.infer_ctxt().build();\n+    let selcx = &mut SelectionContext::intercrate(&infcx);\n+    selcx.enable_tracking_intercrate_ambiguity_causes();\n+    on_overlap(overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).unwrap())\n }\n \n fn with_fresh_ty_vars<'cx, 'tcx>(\n@@ -298,33 +294,32 @@ fn negative_impl<'cx, 'tcx>(\n     let tcx = selcx.infcx().tcx;\n \n     // Create an infcx, taking the predicates of impl1 as assumptions:\n-    tcx.infer_ctxt().enter(|infcx| {\n-        // create a parameter environment corresponding to a (placeholder) instantiation of impl1\n-        let impl_env = tcx.param_env(impl1_def_id);\n-        let subject1 = match traits::fully_normalize(\n-            &infcx,\n-            ObligationCause::dummy(),\n-            impl_env,\n-            tcx.impl_subject(impl1_def_id),\n-        ) {\n-            Ok(s) => s,\n-            Err(err) => {\n-                tcx.sess.delay_span_bug(\n-                    tcx.def_span(impl1_def_id),\n-                    format!(\"failed to fully normalize {:?}: {:?}\", impl1_def_id, err),\n-                );\n-                return false;\n-            }\n-        };\n+    let infcx = tcx.infer_ctxt().build();\n+    // create a parameter environment corresponding to a (placeholder) instantiation of impl1\n+    let impl_env = tcx.param_env(impl1_def_id);\n+    let subject1 = match traits::fully_normalize(\n+        &infcx,\n+        ObligationCause::dummy(),\n+        impl_env,\n+        tcx.impl_subject(impl1_def_id),\n+    ) {\n+        Ok(s) => s,\n+        Err(err) => {\n+            tcx.sess.delay_span_bug(\n+                tcx.def_span(impl1_def_id),\n+                format!(\"failed to fully normalize {:?}: {:?}\", impl1_def_id, err),\n+            );\n+            return false;\n+        }\n+    };\n \n-        // Attempt to prove that impl2 applies, given all of the above.\n-        let selcx = &mut SelectionContext::new(&infcx);\n-        let impl2_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl2_def_id);\n-        let (subject2, obligations) =\n-            impl_subject_and_oblig(selcx, impl_env, impl2_def_id, impl2_substs);\n+    // Attempt to prove that impl2 applies, given all of the above.\n+    let selcx = &mut SelectionContext::new(&infcx);\n+    let impl2_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl2_def_id);\n+    let (subject2, obligations) =\n+        impl_subject_and_oblig(selcx, impl_env, impl2_def_id, impl2_substs);\n \n-        !equate(&infcx, impl_env, subject1, subject2, obligations, impl1_def_id)\n-    })\n+    !equate(&infcx, impl_env, subject1, subject2, obligations, impl1_def_id)\n }\n \n fn equate<'tcx>("}, {"sha": "5b4fa1df426c0b82442558f663d41abd75c2b771", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -1930,16 +1930,11 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         }\n \n         let normalize = |candidate| {\n-            self.tcx.infer_ctxt().enter(|ref infcx| {\n-                let normalized = infcx\n-                    .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n-                    .normalize(candidate)\n-                    .ok();\n-                match normalized {\n-                    Some(normalized) => normalized.value,\n-                    None => candidate,\n-                }\n-            })\n+            let infcx = self.tcx.infer_ctxt().build();\n+            infcx\n+                .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n+                .normalize(candidate)\n+                .map_or(candidate, |normalized| normalized.value)\n         };\n \n         // Sort impl candidates so that ordering is consistent for UI tests."}, {"sha": "be603c609cb364438f148b0a9e11342abb1e3ef6", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 54, "deletions": 55, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -23,65 +23,64 @@ pub fn can_type_implement_copy<'tcx>(\n     parent_cause: ObligationCause<'tcx>,\n ) -> Result<(), CopyImplementationError<'tcx>> {\n     // FIXME: (@jroesch) float this code up\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let (adt, substs) = match self_type.kind() {\n-            // These types used to have a builtin impl.\n-            // Now libcore provides that impl.\n-            ty::Uint(_)\n-            | ty::Int(_)\n-            | ty::Bool\n-            | ty::Float(_)\n-            | ty::Char\n-            | ty::RawPtr(..)\n-            | ty::Never\n-            | ty::Ref(_, _, hir::Mutability::Not)\n-            | ty::Array(..) => return Ok(()),\n+    let infcx = tcx.infer_ctxt().build();\n+    let (adt, substs) = match self_type.kind() {\n+        // These types used to have a builtin impl.\n+        // Now libcore provides that impl.\n+        ty::Uint(_)\n+        | ty::Int(_)\n+        | ty::Bool\n+        | ty::Float(_)\n+        | ty::Char\n+        | ty::RawPtr(..)\n+        | ty::Never\n+        | ty::Ref(_, _, hir::Mutability::Not)\n+        | ty::Array(..) => return Ok(()),\n \n-            ty::Adt(adt, substs) => (adt, substs),\n+        ty::Adt(adt, substs) => (adt, substs),\n \n-            _ => return Err(CopyImplementationError::NotAnAdt),\n-        };\n+        _ => return Err(CopyImplementationError::NotAnAdt),\n+    };\n \n-        let mut infringing = Vec::new();\n-        for variant in adt.variants() {\n-            for field in &variant.fields {\n-                let ty = field.ty(tcx, substs);\n-                if ty.references_error() {\n-                    continue;\n-                }\n-                let span = tcx.def_span(field.did);\n-                // FIXME(compiler-errors): This gives us better spans for bad\n-                // projection types like in issue-50480.\n-                // If the ADT has substs, point to the cause we are given.\n-                // If it does not, then this field probably doesn't normalize\n-                // to begin with, and point to the bad field's span instead.\n-                let cause = if field\n-                    .ty(tcx, traits::InternalSubsts::identity_for_item(tcx, adt.did()))\n-                    .has_non_region_param()\n-                {\n-                    parent_cause.clone()\n-                } else {\n-                    ObligationCause::dummy_with_span(span)\n-                };\n-                match traits::fully_normalize(&infcx, cause, param_env, ty) {\n-                    Ok(ty) => {\n-                        if !infcx.type_is_copy_modulo_regions(param_env, ty, span) {\n-                            infringing.push((field, ty));\n-                        }\n-                    }\n-                    Err(errors) => {\n-                        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n-                    }\n-                };\n+    let mut infringing = Vec::new();\n+    for variant in adt.variants() {\n+        for field in &variant.fields {\n+            let ty = field.ty(tcx, substs);\n+            if ty.references_error() {\n+                continue;\n             }\n+            let span = tcx.def_span(field.did);\n+            // FIXME(compiler-errors): This gives us better spans for bad\n+            // projection types like in issue-50480.\n+            // If the ADT has substs, point to the cause we are given.\n+            // If it does not, then this field probably doesn't normalize\n+            // to begin with, and point to the bad field's span instead.\n+            let cause = if field\n+                .ty(tcx, traits::InternalSubsts::identity_for_item(tcx, adt.did()))\n+                .has_non_region_param()\n+            {\n+                parent_cause.clone()\n+            } else {\n+                ObligationCause::dummy_with_span(span)\n+            };\n+            match traits::fully_normalize(&infcx, cause, param_env, ty) {\n+                Ok(ty) => {\n+                    if !infcx.type_is_copy_modulo_regions(param_env, ty, span) {\n+                        infringing.push((field, ty));\n+                    }\n+                }\n+                Err(errors) => {\n+                    infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+                }\n+            };\n         }\n-        if !infringing.is_empty() {\n-            return Err(CopyImplementationError::InfrigingFields(infringing));\n-        }\n-        if adt.has_dtor(tcx) {\n-            return Err(CopyImplementationError::HasDestructor);\n-        }\n+    }\n+    if !infringing.is_empty() {\n+        return Err(CopyImplementationError::InfrigingFields(infringing));\n+    }\n+    if adt.has_dtor(tcx) {\n+        return Err(CopyImplementationError::HasDestructor);\n+    }\n \n-        Ok(())\n-    })\n+    Ok(())\n }"}, {"sha": "274a366873ce99904a83f4f918bb84e8dc2a9e0f", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 63, "deletions": 70, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -234,54 +234,51 @@ fn do_normalize_predicates<'tcx>(\n     // by wfcheck anyway, so I'm not sure we have to check\n     // them here too, and we will remove this function when\n     // we move over to lazy normalization *anyway*.\n-    tcx.infer_ctxt().ignoring_regions().enter(|infcx| {\n-        let predicates = match fully_normalize(&infcx, cause, elaborated_env, predicates) {\n-            Ok(predicates) => predicates,\n-            Err(errors) => {\n-                let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n-                return Err(reported);\n-            }\n-        };\n+    let infcx = tcx.infer_ctxt().ignoring_regions().build();\n+    let predicates = match fully_normalize(&infcx, cause, elaborated_env, predicates) {\n+        Ok(predicates) => predicates,\n+        Err(errors) => {\n+            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+            return Err(reported);\n+        }\n+    };\n \n-        debug!(\"do_normalize_predictes: normalized predicates = {:?}\", predicates);\n+    debug!(\"do_normalize_predictes: normalized predicates = {:?}\", predicates);\n \n-        // We can use the `elaborated_env` here; the region code only\n-        // cares about declarations like `'a: 'b`.\n-        let outlives_env = OutlivesEnvironment::new(elaborated_env);\n+    // We can use the `elaborated_env` here; the region code only\n+    // cares about declarations like `'a: 'b`.\n+    let outlives_env = OutlivesEnvironment::new(elaborated_env);\n+\n+    // FIXME: It's very weird that we ignore region obligations but apparently\n+    // still need to use `resolve_regions` as we need the resolved regions in\n+    // the normalized predicates.\n+    let errors = infcx.resolve_regions(&outlives_env);\n+    if !errors.is_empty() {\n+        tcx.sess.delay_span_bug(\n+            span,\n+            format!(\"failed region resolution while normalizing {elaborated_env:?}: {errors:?}\"),\n+        );\n+    }\n \n-        // FIXME: It's very weird that we ignore region obligations but apparently\n-        // still need to use `resolve_regions` as we need the resolved regions in\n-        // the normalized predicates.\n-        let errors = infcx.resolve_regions(&outlives_env);\n-        if !errors.is_empty() {\n-            tcx.sess.delay_span_bug(\n+    match infcx.fully_resolve(predicates) {\n+        Ok(predicates) => Ok(predicates),\n+        Err(fixup_err) => {\n+            // If we encounter a fixup error, it means that some type\n+            // variable wound up unconstrained. I actually don't know\n+            // if this can happen, and I certainly don't expect it to\n+            // happen often, but if it did happen it probably\n+            // represents a legitimate failure due to some kind of\n+            // unconstrained variable.\n+            //\n+            // @lcnr: Let's still ICE here for now. I want a test case\n+            // for that.\n+            span_bug!(\n                 span,\n-                format!(\n-                    \"failed region resolution while normalizing {elaborated_env:?}: {errors:?}\"\n-                ),\n+                \"inference variables in normalized parameter environment: {}\",\n+                fixup_err\n             );\n         }\n-\n-        match infcx.fully_resolve(predicates) {\n-            Ok(predicates) => Ok(predicates),\n-            Err(fixup_err) => {\n-                // If we encounter a fixup error, it means that some type\n-                // variable wound up unconstrained. I actually don't know\n-                // if this can happen, and I certainly don't expect it to\n-                // happen often, but if it did happen it probably\n-                // represents a legitimate failure due to some kind of\n-                // unconstrained variable.\n-                //\n-                // @lcnr: Let's still ICE here for now. I want a test case\n-                // for that.\n-                span_bug!(\n-                    span,\n-                    \"inference variables in normalized parameter environment: {}\",\n-                    fixup_err\n-                );\n-            }\n-        }\n-    })\n+    }\n }\n \n // FIXME: this is gonna need to be removed ...\n@@ -473,21 +470,20 @@ pub fn impossible_predicates<'tcx>(\n ) -> bool {\n     debug!(\"impossible_predicates(predicates={:?})\", predicates);\n \n-    let result = tcx.infer_ctxt().enter(|infcx| {\n-        let param_env = ty::ParamEnv::reveal_all();\n-        let ocx = ObligationCtxt::new(&infcx);\n-        let predicates = ocx.normalize(ObligationCause::dummy(), param_env, predicates);\n-        for predicate in predicates {\n-            let obligation = Obligation::new(ObligationCause::dummy(), param_env, predicate);\n-            ocx.register_obligation(obligation);\n-        }\n-        let errors = ocx.select_all_or_error();\n+    let infcx = tcx.infer_ctxt().build();\n+    let param_env = ty::ParamEnv::reveal_all();\n+    let ocx = ObligationCtxt::new(&infcx);\n+    let predicates = ocx.normalize(ObligationCause::dummy(), param_env, predicates);\n+    for predicate in predicates {\n+        let obligation = Obligation::new(ObligationCause::dummy(), param_env, predicate);\n+        ocx.register_obligation(obligation);\n+    }\n+    let errors = ocx.select_all_or_error();\n \n-        // Clean up after ourselves\n-        let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+    // Clean up after ourselves\n+    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n \n-        !errors.is_empty()\n-    });\n+    let result = !errors.is_empty();\n     debug!(\"impossible_predicates = {:?}\", result);\n     result\n }\n@@ -578,18 +574,16 @@ fn is_impossible_method<'tcx>(\n         }\n     });\n \n-    tcx.infer_ctxt().ignoring_regions().enter(|ref infcx| {\n-        for obligation in predicates_for_trait {\n-            // Ignore overflow error, to be conservative.\n-            if let Ok(result) = infcx.evaluate_obligation(&obligation)\n-                && !result.may_apply()\n-            {\n-                return true;\n-            }\n+    let infcx = tcx.infer_ctxt().ignoring_regions().build();\n+    for obligation in predicates_for_trait {\n+        // Ignore overflow error, to be conservative.\n+        if let Ok(result) = infcx.evaluate_obligation(&obligation)\n+            && !result.may_apply()\n+        {\n+            return true;\n         }\n-\n-        false\n-    })\n+    }\n+    false\n }\n \n #[derive(Clone, Debug)]\n@@ -952,10 +946,9 @@ pub fn vtable_trait_upcasting_coercion_new_vptr_slot<'tcx>(\n         }),\n     );\n \n-    let implsrc = tcx.infer_ctxt().enter(|infcx| {\n-        let mut selcx = SelectionContext::new(&infcx);\n-        selcx.select(&obligation).unwrap()\n-    });\n+    let infcx = tcx.infer_ctxt().build();\n+    let mut selcx = SelectionContext::new(&infcx);\n+    let implsrc = selcx.select(&obligation).unwrap();\n \n     let Some(ImplSource::TraitUpcasting(implsrc_traitcasting)) = implsrc else {\n         bug!();"}, {"sha": "31dd30c5c6a2b2822e71b7bd3f0ef7205eb7dea0", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -734,10 +734,9 @@ fn receiver_is_dispatchable<'tcx>(\n         Obligation::new(ObligationCause::dummy(), param_env, predicate)\n     };\n \n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        // the receiver is dispatchable iff the obligation holds\n-        infcx.predicate_must_hold_modulo_regions(&obligation)\n-    })\n+    let infcx = tcx.infer_ctxt().build();\n+    // the receiver is dispatchable iff the obligation holds\n+    infcx.predicate_must_hold_modulo_regions(&obligation)\n }\n \n fn contains_illegal_self_type_reference<'tcx, T: TypeVisitable<'tcx>>("}, {"sha": "c891658582a0a89b34222703a47894385c45a5e3", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -149,13 +149,9 @@ pub(super) fn specializes(tcx: TyCtxt<'_>, (impl1_def_id, impl2_def_id): (DefId,\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n \n     // Create an infcx, taking the predicates of impl1 as assumptions:\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let impl1_trait_ref = match traits::fully_normalize(\n-            &infcx,\n-            ObligationCause::dummy(),\n-            penv,\n-            impl1_trait_ref,\n-        ) {\n+    let infcx = tcx.infer_ctxt().build();\n+    let impl1_trait_ref =\n+        match traits::fully_normalize(&infcx, ObligationCause::dummy(), penv, impl1_trait_ref) {\n             Ok(impl1_trait_ref) => impl1_trait_ref,\n             Err(_errors) => {\n                 tcx.sess.delay_span_bug(\n@@ -166,9 +162,8 @@ pub(super) fn specializes(tcx: TyCtxt<'_>, (impl1_def_id, impl2_def_id): (DefId,\n             }\n         };\n \n-        // Attempt to prove that impl2 applies, given all of the above.\n-        fulfill_implication(&infcx, penv, impl1_trait_ref, impl2_def_id).is_ok()\n-    })\n+    // Attempt to prove that impl2 applies, given all of the above.\n+    fulfill_implication(&infcx, penv, impl1_trait_ref, impl2_def_id).is_ok()\n }\n \n /// Attempt to fulfill all obligations of `target_impl` after unification with"}, {"sha": "932dbbb81e5cc560645aaa011ec0a093fe07fba4", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -265,9 +265,8 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n \n pub fn provide(providers: &mut Providers) {\n     providers.has_structural_eq_impls = |tcx, ty| {\n-        tcx.infer_ctxt().enter(|infcx| {\n-            let cause = ObligationCause::dummy();\n-            type_marked_structural(&infcx, ty, cause)\n-        })\n+        let infcx = tcx.infer_ctxt().build();\n+        let cause = ObligationCause::dummy();\n+        type_marked_structural(&infcx, ty, cause)\n     };\n }"}, {"sha": "d5a8ca5ea784a2508c2c569785e1aeed6344a591", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 105, "deletions": 113, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -27,128 +27,120 @@ fn dropck_outlives<'tcx>(\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>, NoSolution> {\n     debug!(\"dropck_outlives(goal={:#?})\", canonical_goal);\n \n-    tcx.infer_ctxt().enter_with_canonical(\n-        DUMMY_SP,\n-        &canonical_goal,\n-        |ref infcx, goal, canonical_inference_vars| {\n-            let tcx = infcx.tcx;\n-            let ParamEnvAnd { param_env, value: for_ty } = goal;\n-\n-            let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n-\n-            // A stack of types left to process. Each round, we pop\n-            // something from the stack and invoke\n-            // `dtorck_constraint_for_ty`. This may produce new types that\n-            // have to be pushed on the stack. This continues until we have explored\n-            // all the reachable types from the type `for_ty`.\n-            //\n-            // Example: Imagine that we have the following code:\n-            //\n-            // ```rust\n-            // struct A {\n-            //     value: B,\n-            //     children: Vec<A>,\n-            // }\n-            //\n-            // struct B {\n-            //     value: u32\n-            // }\n-            //\n-            // fn f() {\n-            //   let a: A = ...;\n-            //   ..\n-            // } // here, `a` is dropped\n-            // ```\n-            //\n-            // at the point where `a` is dropped, we need to figure out\n-            // which types inside of `a` contain region data that may be\n-            // accessed by any destructors in `a`. We begin by pushing `A`\n-            // onto the stack, as that is the type of `a`. We will then\n-            // invoke `dtorck_constraint_for_ty` which will expand `A`\n-            // into the types of its fields `(B, Vec<A>)`. These will get\n-            // pushed onto the stack. Eventually, expanding `Vec<A>` will\n-            // lead to us trying to push `A` a second time -- to prevent\n-            // infinite recursion, we notice that `A` was already pushed\n-            // once and stop.\n-            let mut ty_stack = vec![(for_ty, 0)];\n-\n-            // Set used to detect infinite recursion.\n-            let mut ty_set = FxHashSet::default();\n-\n-            let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n-            let cause = ObligationCause::dummy();\n-            let mut constraints = DropckConstraint::empty();\n-            while let Some((ty, depth)) = ty_stack.pop() {\n-                debug!(\n-                    \"{} kinds, {} overflows, {} ty_stack\",\n-                    result.kinds.len(),\n-                    result.overflows.len(),\n-                    ty_stack.len()\n-                );\n-                dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n-\n-                // \"outlives\" represent types/regions that may be touched\n-                // by a destructor.\n-                result.kinds.append(&mut constraints.outlives);\n-                result.overflows.append(&mut constraints.overflows);\n-\n-                // If we have even one overflow, we should stop trying to evaluate further --\n-                // chances are, the subsequent overflows for this evaluation won't provide useful\n-                // information and will just decrease the speed at which we can emit these errors\n-                // (since we'll be printing for just that much longer for the often enormous types\n-                // that result here).\n-                if !result.overflows.is_empty() {\n-                    break;\n-                }\n+    let (ref infcx, goal, canonical_inference_vars) =\n+        tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n+    let tcx = infcx.tcx;\n+    let ParamEnvAnd { param_env, value: for_ty } = goal;\n+\n+    let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n+\n+    // A stack of types left to process. Each round, we pop\n+    // something from the stack and invoke\n+    // `dtorck_constraint_for_ty`. This may produce new types that\n+    // have to be pushed on the stack. This continues until we have explored\n+    // all the reachable types from the type `for_ty`.\n+    //\n+    // Example: Imagine that we have the following code:\n+    //\n+    // ```rust\n+    // struct A {\n+    //     value: B,\n+    //     children: Vec<A>,\n+    // }\n+    //\n+    // struct B {\n+    //     value: u32\n+    // }\n+    //\n+    // fn f() {\n+    //   let a: A = ...;\n+    //   ..\n+    // } // here, `a` is dropped\n+    // ```\n+    //\n+    // at the point where `a` is dropped, we need to figure out\n+    // which types inside of `a` contain region data that may be\n+    // accessed by any destructors in `a`. We begin by pushing `A`\n+    // onto the stack, as that is the type of `a`. We will then\n+    // invoke `dtorck_constraint_for_ty` which will expand `A`\n+    // into the types of its fields `(B, Vec<A>)`. These will get\n+    // pushed onto the stack. Eventually, expanding `Vec<A>` will\n+    // lead to us trying to push `A` a second time -- to prevent\n+    // infinite recursion, we notice that `A` was already pushed\n+    // once and stop.\n+    let mut ty_stack = vec![(for_ty, 0)];\n+\n+    // Set used to detect infinite recursion.\n+    let mut ty_set = FxHashSet::default();\n+\n+    let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+\n+    let cause = ObligationCause::dummy();\n+    let mut constraints = DropckConstraint::empty();\n+    while let Some((ty, depth)) = ty_stack.pop() {\n+        debug!(\n+            \"{} kinds, {} overflows, {} ty_stack\",\n+            result.kinds.len(),\n+            result.overflows.len(),\n+            ty_stack.len()\n+        );\n+        dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n+\n+        // \"outlives\" represent types/regions that may be touched\n+        // by a destructor.\n+        result.kinds.append(&mut constraints.outlives);\n+        result.overflows.append(&mut constraints.overflows);\n+\n+        // If we have even one overflow, we should stop trying to evaluate further --\n+        // chances are, the subsequent overflows for this evaluation won't provide useful\n+        // information and will just decrease the speed at which we can emit these errors\n+        // (since we'll be printing for just that much longer for the often enormous types\n+        // that result here).\n+        if !result.overflows.is_empty() {\n+            break;\n+        }\n \n-                // dtorck types are \"types that will get dropped but which\n-                // do not themselves define a destructor\", more or less. We have\n-                // to push them onto the stack to be expanded.\n-                for ty in constraints.dtorck_types.drain(..) {\n-                    match infcx.at(&cause, param_env).normalize(ty) {\n-                        Ok(Normalized { value: ty, obligations }) => {\n-                            fulfill_cx.register_predicate_obligations(infcx, obligations);\n-\n-                            debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n-\n-                            match ty.kind() {\n-                                // All parameters live for the duration of the\n-                                // function.\n-                                ty::Param(..) => {}\n-\n-                                // A projection that we couldn't resolve - it\n-                                // might have a destructor.\n-                                ty::Projection(..) | ty::Opaque(..) => {\n-                                    result.kinds.push(ty.into());\n-                                }\n-\n-                                _ => {\n-                                    if ty_set.insert(ty) {\n-                                        ty_stack.push((ty, depth + 1));\n-                                    }\n-                                }\n-                            }\n+        // dtorck types are \"types that will get dropped but which\n+        // do not themselves define a destructor\", more or less. We have\n+        // to push them onto the stack to be expanded.\n+        for ty in constraints.dtorck_types.drain(..) {\n+            match infcx.at(&cause, param_env).normalize(ty) {\n+                Ok(Normalized { value: ty, obligations }) => {\n+                    fulfill_cx.register_predicate_obligations(infcx, obligations);\n+\n+                    debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n+\n+                    match ty.kind() {\n+                        // All parameters live for the duration of the\n+                        // function.\n+                        ty::Param(..) => {}\n+\n+                        // A projection that we couldn't resolve - it\n+                        // might have a destructor.\n+                        ty::Projection(..) | ty::Opaque(..) => {\n+                            result.kinds.push(ty.into());\n                         }\n \n-                        // We don't actually expect to fail to normalize.\n-                        // That implies a WF error somewhere else.\n-                        Err(NoSolution) => {\n-                            return Err(NoSolution);\n+                        _ => {\n+                            if ty_set.insert(ty) {\n+                                ty_stack.push((ty, depth + 1));\n+                            }\n                         }\n                     }\n                 }\n+\n+                // We don't actually expect to fail to normalize.\n+                // That implies a WF error somewhere else.\n+                Err(NoSolution) => {\n+                    return Err(NoSolution);\n+                }\n             }\n+        }\n+    }\n \n-            debug!(\"dropck_outlives: result = {:#?}\", result);\n+    debug!(\"dropck_outlives: result = {:#?}\", result);\n \n-            infcx.make_canonicalized_query_response(\n-                canonical_inference_vars,\n-                result,\n-                &mut *fulfill_cx,\n-            )\n-        },\n-    )\n+    infcx.make_canonicalized_query_response(canonical_inference_vars, result, &mut *fulfill_cx)\n }\n \n /// Returns a set of constraints that needs to be satisfied in"}, {"sha": "493d5de0807a2c384315786f4bfd42c383c2992a", "filename": "compiler/rustc_traits/src/evaluate_obligation.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -18,17 +18,15 @@ fn evaluate_obligation<'tcx>(\n     debug!(\"evaluate_obligation(canonical_goal={:#?})\", canonical_goal);\n     // HACK This bubble is required for this tests to pass:\n     // impl-trait/issue99642.rs\n-    tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).enter_with_canonical(\n-        DUMMY_SP,\n-        &canonical_goal,\n-        |ref infcx, goal, _canonical_inference_vars| {\n-            debug!(\"evaluate_obligation: goal={:#?}\", goal);\n-            let ParamEnvAnd { param_env, value: predicate } = goal;\n+    let (ref infcx, goal, _canonical_inference_vars) = tcx\n+        .infer_ctxt()\n+        .with_opaque_type_inference(DefiningAnchor::Bubble)\n+        .build_with_canonical(DUMMY_SP, &canonical_goal);\n+    debug!(\"evaluate_obligation: goal={:#?}\", goal);\n+    let ParamEnvAnd { param_env, value: predicate } = goal;\n \n-            let mut selcx = SelectionContext::with_query_mode(&infcx, TraitQueryMode::Canonical);\n-            let obligation = Obligation::new(ObligationCause::dummy(), param_env, predicate);\n+    let mut selcx = SelectionContext::with_query_mode(&infcx, TraitQueryMode::Canonical);\n+    let obligation = Obligation::new(ObligationCause::dummy(), param_env, predicate);\n \n-            selcx.evaluate_root_obligation(&obligation)\n-        },\n-    )\n+    selcx.evaluate_root_obligation(&obligation)\n }"}, {"sha": "58b718ed12766b15ac9ddd7206e64c44d1c7ab8c", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -30,30 +30,29 @@ fn try_normalize_after_erasing_regions<'tcx, T: TypeFoldable<'tcx> + PartialEq +\n     goal: ParamEnvAnd<'tcx, T>,\n ) -> Result<T, NoSolution> {\n     let ParamEnvAnd { param_env, value } = goal;\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let cause = ObligationCause::dummy();\n-        match infcx.at(&cause, param_env).normalize(value) {\n-            Ok(Normalized { value: normalized_value, obligations: normalized_obligations }) => {\n-                // We don't care about the `obligations`; they are\n-                // always only region relations, and we are about to\n-                // erase those anyway:\n-                debug_assert_eq!(\n-                    normalized_obligations.iter().find(|p| not_outlives_predicate(p.predicate)),\n-                    None,\n-                );\n+    let infcx = tcx.infer_ctxt().build();\n+    let cause = ObligationCause::dummy();\n+    match infcx.at(&cause, param_env).normalize(value) {\n+        Ok(Normalized { value: normalized_value, obligations: normalized_obligations }) => {\n+            // We don't care about the `obligations`; they are\n+            // always only region relations, and we are about to\n+            // erase those anyway:\n+            debug_assert_eq!(\n+                normalized_obligations.iter().find(|p| not_outlives_predicate(p.predicate)),\n+                None,\n+            );\n \n-                let resolved_value = infcx.resolve_vars_if_possible(normalized_value);\n-                // It's unclear when `resolve_vars` would have an effect in a\n-                // fresh `InferCtxt`. If this assert does trigger, it will give\n-                // us a test case.\n-                debug_assert_eq!(normalized_value, resolved_value);\n-                let erased = infcx.tcx.erase_regions(resolved_value);\n-                debug_assert!(!erased.needs_infer(), \"{:?}\", erased);\n-                Ok(erased)\n-            }\n-            Err(NoSolution) => Err(NoSolution),\n+            let resolved_value = infcx.resolve_vars_if_possible(normalized_value);\n+            // It's unclear when `resolve_vars` would have an effect in a\n+            // fresh `InferCtxt`. If this assert does trigger, it will give\n+            // us a test case.\n+            debug_assert_eq!(normalized_value, resolved_value);\n+            let erased = infcx.tcx.erase_regions(resolved_value);\n+            debug_assert!(!erased.needs_infer(), \"{:?}\", erased);\n+            Ok(erased)\n         }\n-    })\n+        Err(NoSolution) => Err(NoSolution),\n+    }\n }\n \n fn not_outlives_predicate<'tcx>(p: ty::Predicate<'tcx>) -> bool {"}, {"sha": "d3169b6d962ecaf0f41cb006d6f34b53227c90ee", "filename": "compiler/rustc_ty_utils/src/common_traits.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_ty_utils%2Fsrc%2Fcommon_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_ty_utils%2Fsrc%2Fcommon_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fcommon_traits.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -29,15 +29,8 @@ fn is_item_raw<'tcx>(\n ) -> bool {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(item, None);\n-    tcx.infer_ctxt().enter(|infcx| {\n-        traits::type_known_to_meet_bound_modulo_regions(\n-            &infcx,\n-            param_env,\n-            ty,\n-            trait_def_id,\n-            DUMMY_SP,\n-        )\n-    })\n+    let infcx = tcx.infer_ctxt().build();\n+    traits::type_known_to_meet_bound_modulo_regions(&infcx, param_env, ty, trait_def_id, DUMMY_SP)\n }\n \n pub(crate) fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "5ed40515d8a98b259a502505c63cb2c3a3014b5f", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -134,19 +134,17 @@ fn resolve_associated_item<'tcx>(\n                 .unwrap_or_else(|| {\n                     bug!(\"{:?} not found in {:?}\", trait_item_id, impl_data.impl_def_id);\n                 });\n-\n-            let substs = tcx.infer_ctxt().enter(|infcx| {\n-                let param_env = param_env.with_reveal_all_normalized(tcx);\n-                let substs = rcvr_substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n-                let substs = translate_substs(\n-                    &infcx,\n-                    param_env,\n-                    impl_data.impl_def_id,\n-                    substs,\n-                    leaf_def.defining_node,\n-                );\n-                infcx.tcx.erase_regions(substs)\n-            });\n+            let infcx = tcx.infer_ctxt().build();\n+            let param_env = param_env.with_reveal_all_normalized(tcx);\n+            let substs = rcvr_substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n+            let substs = translate_substs(\n+                &infcx,\n+                param_env,\n+                impl_data.impl_def_id,\n+                substs,\n+                leaf_def.defining_node,\n+            );\n+            let substs = infcx.tcx.erase_regions(substs);\n \n             // Since this is a trait item, we need to see if the item is either a trait default item\n             // or a specialization because we can't resolve those unless we can `Reveal::All`."}, {"sha": "95061ae61e3f77dd055b894f90367b95d5860619", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 52, "deletions": 58, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -27,76 +27,70 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                 }\n                 // NOTE: doesn't use `for_each_relevant_impl` to avoid looking at anything besides blanket impls\n                 let trait_impls = cx.tcx.trait_impls_of(trait_def_id);\n-                for &impl_def_id in trait_impls.blanket_impls() {\n+                'blanket_impls: for &impl_def_id in trait_impls.blanket_impls() {\n                     trace!(\n                         \"get_blanket_impls: Considering impl for trait '{:?}' {:?}\",\n                         trait_def_id,\n                         impl_def_id\n                     );\n                     let trait_ref = cx.tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n-                    let is_param = matches!(trait_ref.0.self_ty().kind(), ty::Param(_));\n-                    let may_apply = is_param && cx.tcx.infer_ctxt().enter(|infcx| {\n-                        let substs = infcx.fresh_substs_for_item(DUMMY_SP, item_def_id);\n-                        let ty = ty.subst(infcx.tcx, substs);\n-                        let param_env = EarlyBinder(param_env).subst(infcx.tcx, substs);\n+                    if !matches!(trait_ref.0.self_ty().kind(), ty::Param(_)) {\n+                        continue;\n+                    }\n+                    let infcx = cx.tcx.infer_ctxt().build();\n+                    let substs = infcx.fresh_substs_for_item(DUMMY_SP, item_def_id);\n+                    let impl_ty = ty.subst(infcx.tcx, substs);\n+                    let param_env = EarlyBinder(param_env).subst(infcx.tcx, substs);\n \n-                        let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n-                        let trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n+                    let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+                    let impl_trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n \n-                        // Require the type the impl is implemented on to match\n-                        // our type, and ignore the impl if there was a mismatch.\n-                        let cause = traits::ObligationCause::dummy();\n-                        let eq_result = infcx.at(&cause, param_env).eq(trait_ref.self_ty(), ty);\n-                        if let Ok(InferOk { value: (), obligations }) = eq_result {\n-                            // FIXME(eddyb) ignoring `obligations` might cause false positives.\n-                            drop(obligations);\n+                    // Require the type the impl is implemented on to match\n+                    // our type, and ignore the impl if there was a mismatch.\n+                    let cause = traits::ObligationCause::dummy();\n+                    let Ok(eq_result) = infcx.at(&cause, param_env).eq(impl_trait_ref.self_ty(), impl_ty) else {\n+                        continue\n+                    };\n+                    let InferOk { value: (), obligations } = eq_result;\n+                    // FIXME(eddyb) ignoring `obligations` might cause false positives.\n+                    drop(obligations);\n \n-                            trace!(\n-                                \"invoking predicate_may_hold: param_env={:?}, trait_ref={:?}, ty={:?}\",\n-                                param_env,\n-                                trait_ref,\n-                                ty\n-                            );\n-                            let predicates = cx\n-                                .tcx\n-                                .predicates_of(impl_def_id)\n-                                .instantiate(cx.tcx, impl_substs)\n-                                .predicates\n-                                .into_iter()\n-                                .chain(Some(\n-                                    ty::Binder::dummy(trait_ref)\n-                                        .to_poly_trait_predicate()\n-                                        .map_bound(ty::PredicateKind::Trait)\n-                                        .to_predicate(infcx.tcx),\n-                                ));\n-                            for predicate in predicates {\n-                                debug!(\"testing predicate {:?}\", predicate);\n-                                let obligation = traits::Obligation::new(\n-                                    traits::ObligationCause::dummy(),\n-                                    param_env,\n-                                    predicate,\n-                                );\n-                                match infcx.evaluate_obligation(&obligation) {\n-                                    Ok(eval_result) if eval_result.may_apply() => {}\n-                                    Err(traits::OverflowError::Canonical) => {}\n-                                    Err(traits::OverflowError::ErrorReporting) => {}\n-                                    _ => {\n-                                        return false;\n-                                    }\n-                                }\n-                            }\n-                            true\n-                        } else {\n-                            false\n+                    trace!(\n+                        \"invoking predicate_may_hold: param_env={:?}, impl_trait_ref={:?}, impl_ty={:?}\",\n+                        param_env,\n+                        impl_trait_ref,\n+                        impl_ty\n+                    );\n+                    let predicates = cx\n+                        .tcx\n+                        .predicates_of(impl_def_id)\n+                        .instantiate(cx.tcx, impl_substs)\n+                        .predicates\n+                        .into_iter()\n+                        .chain(Some(\n+                            ty::Binder::dummy(impl_trait_ref)\n+                                .to_poly_trait_predicate()\n+                                .map_bound(ty::PredicateKind::Trait)\n+                                .to_predicate(infcx.tcx),\n+                        ));\n+                    for predicate in predicates {\n+                        debug!(\"testing predicate {:?}\", predicate);\n+                        let obligation = traits::Obligation::new(\n+                            traits::ObligationCause::dummy(),\n+                            param_env,\n+                            predicate,\n+                        );\n+                        match infcx.evaluate_obligation(&obligation) {\n+                            Ok(eval_result) if eval_result.may_apply() => {}\n+                            Err(traits::OverflowError::Canonical) => {}\n+                            Err(traits::OverflowError::ErrorReporting) => {}\n+                            _ => continue 'blanket_impls,\n                         }\n-                    });\n+                    }\n                     debug!(\n-                        \"get_blanket_impls: found applicable impl: {} for trait_ref={:?}, ty={:?}\",\n-                        may_apply, trait_ref, ty\n+                        \"get_blanket_impls: found applicable impl for trait_ref={:?}, ty={:?}\",\n+                        trait_ref, ty\n                     );\n-                    if !may_apply {\n-                        continue;\n-                    }\n \n                     cx.generated_synthetics.insert((ty.0, trait_def_id));\n "}, {"sha": "279e762d597a0cd50f2aa443df7e93502d2b6819", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -1564,12 +1564,11 @@ fn normalize<'tcx>(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n \n     // Try to normalize `<X as Y>::T` to a type\n     let lifted = ty.lift_to_tcx(cx.tcx).unwrap();\n-    let normalized = cx.tcx.infer_ctxt().enter(|infcx| {\n-        infcx\n-            .at(&ObligationCause::dummy(), cx.param_env)\n-            .normalize(lifted)\n-            .map(|resolved| infcx.resolve_vars_if_possible(resolved.value))\n-    });\n+    let infcx = cx.tcx.infer_ctxt().build();\n+    let normalized = infcx\n+        .at(&ObligationCause::dummy(), cx.param_env)\n+        .normalize(lifted)\n+        .map(|resolved| infcx.resolve_vars_if_possible(resolved.value));\n     match normalized {\n         Ok(normalized_value) => {\n             debug!(\"normalized {:?} to {:?}\", ty, normalized_value);"}, {"sha": "02a16f765b7324117fc9c9fc380b661caccc7bf9", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -831,11 +831,10 @@ fn walk_parents<'tcx>(\n                                 // Trait methods taking `self`\n                                 arg_ty\n                             } && impl_ty.is_ref()\n-                            && cx.tcx.infer_ctxt().enter(|infcx|\n-                                infcx\n-                                    .type_implements_trait(trait_id, impl_ty, subs, cx.param_env)\n-                                    .must_apply_modulo_regions()\n-                            )\n+                            && let infcx = cx.tcx.infer_ctxt().build()\n+                            && infcx\n+                                .type_implements_trait(trait_id, impl_ty, subs, cx.param_env)\n+                                .must_apply_modulo_regions()\n                         {\n                             return Some(Position::MethodReceiverRefImpl)\n                         }\n@@ -1119,9 +1118,8 @@ fn needless_borrow_impl_arg_position<'tcx>(\n \n             let predicate = EarlyBinder(predicate).subst(cx.tcx, &substs_with_referent_ty);\n             let obligation = Obligation::new(ObligationCause::dummy(), cx.param_env, predicate);\n-            cx.tcx\n-                .infer_ctxt()\n-                .enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n+            let infcx = cx.tcx.infer_ctxt().build();\n+            infcx.predicate_must_hold_modulo_regions(&obligation)\n         })\n     };\n "}, {"sha": "eb0455ae404c1d4c9f369fe0ef70eb3bebb5d385", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -106,9 +106,8 @@ impl<'tcx> LateLintPass<'tcx> for BoxedLocal {\n         };\n \n         let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n-        cx.tcx.infer_ctxt().enter(|infcx| {\n-            ExprUseVisitor::new(&mut v, &infcx, fn_def_id, cx.param_env, cx.typeck_results()).consume_body(body);\n-        });\n+        let infcx = cx.tcx.infer_ctxt().build();\n+        ExprUseVisitor::new(&mut v, &infcx, fn_def_id, cx.param_env, cx.typeck_results()).consume_body(body);\n \n         for node in v.set {\n             span_lint_hir("}, {"sha": "0519f9ac24682f7cfda45b50228e8a1f1fdca93e", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -77,29 +77,28 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n             if is_future {\n                 let send_trait = cx.tcx.get_diagnostic_item(sym::Send).unwrap();\n                 let span = decl.output.span();\n-                let send_errors = cx.tcx.infer_ctxt().enter(|infcx| {\n-                    let cause = traits::ObligationCause::misc(span, hir_id);\n-                    traits::fully_solve_bound(&infcx, cause, cx.param_env, ret_ty, send_trait)\n-                });\n+                let infcx = cx.tcx.infer_ctxt().build();\n+                let cause = traits::ObligationCause::misc(span, hir_id);\n+                let send_errors = traits::fully_solve_bound(&infcx, cause, cx.param_env, ret_ty, send_trait);\n                 if !send_errors.is_empty() {\n                     span_lint_and_then(\n                         cx,\n                         FUTURE_NOT_SEND,\n                         span,\n                         \"future cannot be sent between threads safely\",\n                         |db| {\n-                            cx.tcx.infer_ctxt().enter(|infcx| {\n-                                for FulfillmentError { obligation, .. } in send_errors {\n-                                    infcx.err_ctxt().maybe_note_obligation_cause_for_async_await(db, &obligation);\n-                                    if let Trait(trait_pred) = obligation.predicate.kind().skip_binder() {\n-                                        db.note(&format!(\n-                                            \"`{}` doesn't implement `{}`\",\n-                                            trait_pred.self_ty(),\n-                                            trait_pred.trait_ref.print_only_trait_path(),\n-                                        ));\n-                                    }\n+                            for FulfillmentError { obligation, .. } in send_errors {\n+                                infcx\n+                                    .err_ctxt()\n+                                    .maybe_note_obligation_cause_for_async_await(db, &obligation);\n+                                if let Trait(trait_pred) = obligation.predicate.kind().skip_binder() {\n+                                    db.note(&format!(\n+                                        \"`{}` doesn't implement `{}`\",\n+                                        trait_pred.self_ty(),\n+                                        trait_pred.trait_ref.print_only_trait_path(),\n+                                    ));\n                                 }\n-                            });\n+                            }\n                         },\n                     );\n                 }"}, {"sha": "db73ab55b37cf8fa90bc62f1975e408e6d0b3731", "filename": "src/tools/clippy/clippy_lints/src/loops/mut_range_bound.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -65,16 +65,15 @@ fn check_for_mutation<'tcx>(\n         span_low: None,\n         span_high: None,\n     };\n-    cx.tcx.infer_ctxt().enter(|infcx| {\n-        ExprUseVisitor::new(\n-            &mut delegate,\n-            &infcx,\n-            body.hir_id.owner.def_id,\n-            cx.param_env,\n-            cx.typeck_results(),\n-        )\n-        .walk_expr(body);\n-    });\n+    let infcx = cx.tcx.infer_ctxt().build();\n+    ExprUseVisitor::new(\n+        &mut delegate,\n+        &infcx,\n+        body.hir_id.owner.def_id,\n+        cx.param_env,\n+        cx.typeck_results(),\n+    )\n+    .walk_expr(body);\n \n     delegate.mutation_span()\n }"}, {"sha": "6017941452c06577873bd207be73c62512fe13da", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -420,9 +420,7 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n                         if trait_predicates.any(|predicate| {\n                             let predicate = EarlyBinder(predicate).subst(cx.tcx, new_subst);\n                             let obligation = Obligation::new(ObligationCause::dummy(), cx.param_env, predicate);\n-                            !cx.tcx\n-                                .infer_ctxt()\n-                                .enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n+                            !cx.tcx.infer_ctxt().build().predicate_must_hold_modulo_regions(&obligation)\n                         }) {\n                             return false;\n                         }"}, {"sha": "7f881e27dd27c39e542ab9b96a1a79316d6df786", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -138,10 +138,8 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n             ..\n         } = {\n             let mut ctx = MovedVariablesCtxt::default();\n-            cx.tcx.infer_ctxt().enter(|infcx| {\n-                euv::ExprUseVisitor::new(&mut ctx, &infcx, fn_def_id, cx.param_env, cx.typeck_results())\n-                    .consume_body(body);\n-            });\n+            let infcx = cx.tcx.infer_ctxt().build();\n+            euv::ExprUseVisitor::new(&mut ctx, &infcx, fn_def_id, cx.param_env, cx.typeck_results()).consume_body(body);\n             ctx\n         };\n "}, {"sha": "c7e964cf23e2c00d62d7c2b7ada106b668768c11", "filename": "src/tools/clippy/clippy_lints/src/operators/assign_op_pattern.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -123,16 +123,15 @@ fn imm_borrows_in_expr(cx: &LateContext<'_>, e: &hir::Expr<'_>) -> hir::HirIdSet\n     }\n \n     let mut s = S(hir::HirIdSet::default());\n-    cx.tcx.infer_ctxt().enter(|infcx| {\n-        let mut v = ExprUseVisitor::new(\n-            &mut s,\n-            &infcx,\n-            cx.tcx.hir().body_owner_def_id(cx.enclosing_body.unwrap()),\n-            cx.param_env,\n-            cx.typeck_results(),\n-        );\n-        v.consume_expr(e);\n-    });\n+    let infcx = cx.tcx.infer_ctxt().build();\n+    let mut v = ExprUseVisitor::new(\n+        &mut s,\n+        &infcx,\n+        cx.tcx.hir().body_owner_def_id(cx.enclosing_body.unwrap()),\n+        cx.param_env,\n+        cx.typeck_results(),\n+    );\n+    v.consume_expr(e);\n     s.0\n }\n \n@@ -156,15 +155,14 @@ fn mut_borrows_in_expr(cx: &LateContext<'_>, e: &hir::Expr<'_>) -> hir::HirIdSet\n     }\n \n     let mut s = S(hir::HirIdSet::default());\n-    cx.tcx.infer_ctxt().enter(|infcx| {\n-        let mut v = ExprUseVisitor::new(\n-            &mut s,\n-            &infcx,\n-            cx.tcx.hir().body_owner_def_id(cx.enclosing_body.unwrap()),\n-            cx.param_env,\n-            cx.typeck_results(),\n-        );\n-        v.consume_expr(e);\n-    });\n+    let infcx = cx.tcx.infer_ctxt().build();\n+    let mut v = ExprUseVisitor::new(\n+        &mut s,\n+        &infcx,\n+        cx.tcx.hir().body_owner_def_id(cx.enclosing_body.unwrap()),\n+        cx.param_env,\n+        cx.typeck_results(),\n+    );\n+    v.consume_expr(e);\n     s.0\n }"}, {"sha": "3c5dd92b9cd6d050a8db203756527ef923d7a48a", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -821,10 +821,9 @@ pub fn deref_closure_args<'tcx>(cx: &LateContext<'_>, closure: &'tcx hir::Expr<'\n         };\n \n         let fn_def_id = cx.tcx.hir().local_def_id(closure.hir_id);\n-        cx.tcx.infer_ctxt().enter(|infcx| {\n-            ExprUseVisitor::new(&mut visitor, &infcx, fn_def_id, cx.param_env, cx.typeck_results())\n-                .consume_body(closure_body);\n-        });\n+        let infcx = cx.tcx.infer_ctxt().build();\n+        ExprUseVisitor::new(&mut visitor, &infcx, fn_def_id, cx.param_env, cx.typeck_results())\n+            .consume_body(closure_body);\n \n         if !visitor.suggestion_start.is_empty() {\n             return Some(DerefClosure {"}, {"sha": "a15daec7c3ce3ed77f0a284c185c01eb5a07531d", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -172,11 +172,10 @@ pub fn implements_trait_with_env<'tcx>(\n         return false;\n     }\n     let ty_params = tcx.mk_substs(ty_params.iter());\n-    tcx.infer_ctxt().enter(|infcx| {\n-        infcx\n-            .type_implements_trait(trait_id, ty, ty_params, param_env)\n-            .must_apply_modulo_regions()\n-    })\n+    let infcx = tcx.infer_ctxt().build();\n+    infcx\n+        .type_implements_trait(trait_id, ty, ty_params, param_env)\n+        .must_apply_modulo_regions()\n }\n \n /// Checks whether this type implements `Drop`.\n@@ -242,27 +241,26 @@ fn is_normalizable_helper<'tcx>(\n     }\n     // prevent recursive loops, false-negative is better than endless loop leading to stack overflow\n     cache.insert(ty, false);\n-    let result = cx.tcx.infer_ctxt().enter(|infcx| {\n-        let cause = rustc_middle::traits::ObligationCause::dummy();\n-        if infcx.at(&cause, param_env).normalize(ty).is_ok() {\n-            match ty.kind() {\n-                ty::Adt(def, substs) => def.variants().iter().all(|variant| {\n-                    variant\n-                        .fields\n-                        .iter()\n-                        .all(|field| is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache))\n-                }),\n-                _ => ty.walk().all(|generic_arg| match generic_arg.unpack() {\n-                    GenericArgKind::Type(inner_ty) if inner_ty != ty => {\n-                        is_normalizable_helper(cx, param_env, inner_ty, cache)\n-                    },\n-                    _ => true, // if inner_ty == ty, we've already checked it\n-                }),\n-            }\n-        } else {\n-            false\n+    let infcx = cx.tcx.infer_ctxt().build();\n+    let cause = rustc_middle::traits::ObligationCause::dummy();\n+    let result = if infcx.at(&cause, param_env).normalize(ty).is_ok() {\n+        match ty.kind() {\n+            ty::Adt(def, substs) => def.variants().iter().all(|variant| {\n+                variant\n+                    .fields\n+                    .iter()\n+                    .all(|field| is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache))\n+            }),\n+            _ => ty.walk().all(|generic_arg| match generic_arg.unpack() {\n+                GenericArgKind::Type(inner_ty) if inner_ty != ty => {\n+                    is_normalizable_helper(cx, param_env, inner_ty, cache)\n+                },\n+                _ => true, // if inner_ty == ty, we've already checked it\n+            }),\n         }\n-    });\n+    } else {\n+        false\n+    };\n     cache.insert(ty, result);\n     result\n }"}, {"sha": "e32bae6ed1fd44af99562cff05263351f54ea1dc", "filename": "src/tools/clippy/clippy_utils/src/usage.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283abbf0e7d20176f76006825b5c52e9a4234e4c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs?ref=283abbf0e7d20176f76006825b5c52e9a4234e4c", "patch": "@@ -18,16 +18,15 @@ pub fn mutated_variables<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) ->\n         used_mutably: HirIdSet::default(),\n         skip: false,\n     };\n-    cx.tcx.infer_ctxt().enter(|infcx| {\n-        ExprUseVisitor::new(\n-            &mut delegate,\n-            &infcx,\n-            expr.hir_id.owner.def_id,\n-            cx.param_env,\n-            cx.typeck_results(),\n-        )\n-        .walk_expr(expr);\n-    });\n+    let infcx = cx.tcx.infer_ctxt().build();\n+    ExprUseVisitor::new(\n+        &mut delegate,\n+        &infcx,\n+        expr.hir_id.owner.def_id,\n+        cx.param_env,\n+        cx.typeck_results(),\n+    )\n+    .walk_expr(expr);\n \n     if delegate.skip {\n         return None;"}]}