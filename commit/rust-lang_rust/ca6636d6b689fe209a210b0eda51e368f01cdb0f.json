{"sha": "ca6636d6b689fe209a210b0eda51e368f01cdb0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNjYzNmQ2YjY4OWZlMjA5YTIxMGIwZWRhNTFlMzY4ZjAxY2RiMGY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-28T21:17:41Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-28T21:19:00Z"}, "message": "Allow references to \"self\" within classes\n\nAllow writing self.f within a class that has a field f. Currently,\nthe compiler accepts either self.f or f. In a future commit I'll\nrequire writing self.f and not f.\n\nNot sure whether self.f() works if f is a method (making sure that\nworks next).", "tree": {"sha": "7c979884781d3179bb918045f414426eb6158cea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c979884781d3179bb918045f414426eb6158cea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca6636d6b689fe209a210b0eda51e368f01cdb0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca6636d6b689fe209a210b0eda51e368f01cdb0f", "html_url": "https://github.com/rust-lang/rust/commit/ca6636d6b689fe209a210b0eda51e368f01cdb0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca6636d6b689fe209a210b0eda51e368f01cdb0f/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c141e7a068e3fbb1a5d24dcd000567b7731910bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c141e7a068e3fbb1a5d24dcd000567b7731910bb", "html_url": "https://github.com/rust-lang/rust/commit/c141e7a068e3fbb1a5d24dcd000567b7731910bb"}], "stats": {"total": 115, "additions": 82, "deletions": 33}, "files": [{"sha": "5ad5d42896f51142de360201cc14d5c35116d278", "filename": "src/rustc/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca6636d6b689fe209a210b0eda51e368f01cdb0f/src%2Frustc%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6636d6b689fe209a210b0eda51e368f01cdb0f/src%2Frustc%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Falias.rs?ref=ca6636d6b689fe209a210b0eda51e368f01cdb0f", "patch": "@@ -647,7 +647,7 @@ fn pattern_roots(tcx: ty::ctxt, mutbl: option<unsafe_ty>, pat: @ast::pat)\n // return-by-reference\n fn expr_root(cx: ctx, ex: @ast::expr, autoderef: bool)\n     -> {ex: @ast::expr, mutbl: option<unsafe_ty>} {\n-    let base_root = mutbl::expr_root(cx.tcx, ex, autoderef);\n+    let base_root = mutbl::expr_root_(cx.tcx, none, ex, autoderef);\n     let mut unsafe_ty = none;\n     for d in *base_root.ds {\n         if d.mutbl { unsafe_ty = some(contains(d.outer_t)); break; }"}, {"sha": "be06a16a0dccd4d102246832fdcdcbb0fe3fa858", "filename": "src/rustc/middle/mutbl.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ca6636d6b689fe209a210b0eda51e368f01cdb0f/src%2Frustc%2Fmiddle%2Fmutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6636d6b689fe209a210b0eda51e368f01cdb0f/src%2Frustc%2Fmiddle%2Fmutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmutbl.rs?ref=ca6636d6b689fe209a210b0eda51e368f01cdb0f", "patch": "@@ -12,7 +12,13 @@ type deref = @{mutbl: bool, kind: deref_t, outer_t: ty::t};\n // vec of dereferences that were used on this root. Note that, in this vec,\n // the inner derefs come in front, so foo.bar[1] becomes rec(ex=foo,\n // ds=[index,field])\n-fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n+fn expr_root(cx: @ctx, ex: @expr, autoderef: bool)\n+    -> {ex: @expr, ds: @[deref]} {\n+    expr_root_(cx.tcx, cx.in_ctor, ex, autoderef)\n+}\n+\n+fn expr_root_(tcx: ty::ctxt, ctor_self: option<node_id>,\n+             ex: @expr, autoderef: bool) ->\n    {ex: @expr, ds: @[deref]} {\n     fn maybe_auto_unbox(tcx: ty::ctxt, t: ty::t) -> {t: ty::t, ds: [deref]} {\n         let mut ds = [], t = t;\n@@ -58,13 +64,23 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n                 }\n               }\n               ty::ty_class(did, _) {\n-                  util::common::log_expr(*ex);\n+                  util::common::log_expr(*base);\n+                  let in_self = alt ctor_self {\n+                          some(selfid) {\n+                              alt tcx.def_map.find(base.id) {\n+                                 some(def_self(slfid)) { slfid == selfid }\n+                                 _ { false }\n+                              }\n+                          }\n+                          none { false }\n+                  };\n                   for fld: ty::field_ty in ty::lookup_class_fields(tcx, did) {\n-                    #debug(\"%s %?\", fld.ident, fld.mutability);\n                     if str::eq(ident, fld.ident) {\n-                        is_mutbl = fld.mutability == class_mutable;\n+                        is_mutbl = fld.mutability == class_mutable\n+                            || in_self; // all fields can be mutated\n+                                        // in the ctor\n+                        break;\n                     }\n-                    break;\n                   }\n               }\n               _ {}\n@@ -126,10 +142,11 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n type mutbl_map = std::map::hashmap<node_id, ()>;\n // Keep track of whether we're inside a ctor, so as to\n // allow mutating immutable fields in the same class\n-type ctx = {tcx: ty::ctxt, mutbl_map: mutbl_map, in_ctor: bool};\n+// if we are in a ctor, we track the self id\n+type ctx = {tcx: ty::ctxt, mutbl_map: mutbl_map, in_ctor: option<node_id>};\n \n fn check_crate(tcx: ty::ctxt, crate: @crate) -> mutbl_map {\n-    let cx = @{tcx: tcx, mutbl_map: std::map::int_hash(), in_ctor: false};\n+    let cx = @{tcx: tcx, mutbl_map: std::map::int_hash(), in_ctor: none};\n     let v = @{visit_expr: visit_expr,\n               visit_decl: visit_decl,\n               visit_item: visit_item\n@@ -204,7 +221,7 @@ fn visit_item(item: @item, &&cx: @ctx, v: visit::vt<@ctx>) {\n                             i.node.privacy, i.node.decl, cx, v); });\n                 v.visit_fn(visit::fk_ctor(item.ident, tps), ctor.node.dec,\n                            ctor.node.body, ctor.span, ctor.node.id,\n-                           @{in_ctor: true with *cx}, v);\n+                           @{in_ctor: some(ctor.node.self_id) with *cx}, v);\n             }\n             _ { visit::visit_item(item, cx, v); }\n     }\n@@ -221,7 +238,7 @@ fn check_lval(cx: @ctx, dest: @expr, msg: msg) {\n         cx.mutbl_map.insert(ast_util::def_id_of_def(def).node, ());\n       }\n       _ {\n-        let root = expr_root(cx.tcx, dest, false);\n+        let root = expr_root(cx, dest, false);\n         if vec::len(*root.ds) == 0u {\n             if msg != msg_move_out {\n                 mk_err(cx, dest.span, msg, \"non-lvalue\");\n@@ -251,7 +268,7 @@ fn check_move_rhs(cx: @ctx, src: @expr) {\n         check_lval(cx, src, msg_move_out);\n       }\n       _ {\n-        let root = expr_root(cx.tcx, src, false);\n+        let root = expr_root(cx, src, false);\n \n         // Not a path and no-derefs means this is a temporary.\n         if vec::len(*root.ds) != 0u &&\n@@ -339,7 +356,7 @@ fn is_illegal_to_modify_def(cx: @ctx, def: def, msg: msg) -> option<str> {\n \n       def_binding(_) { some(\"binding\") }\n       def_class_field(parent,fld) {\n-          if !cx.in_ctor {\n+          if option::is_none(cx.in_ctor) {\n              /* Enforce mutability *unless* we're inside a ctor */\n              alt ty::lookup_class_field(cx.tcx, parent, fld).mutability {\n                class_mutable { none }"}, {"sha": "91aac1c7d6aac8714249f1486ef49e398cc78173", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca6636d6b689fe209a210b0eda51e368f01cdb0f/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6636d6b689fe209a210b0eda51e368f01cdb0f/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=ca6636d6b689fe209a210b0eda51e368f01cdb0f", "patch": "@@ -523,17 +523,23 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n       }\n       ast::item_class(tps, members, ctor) {\n         visit::visit_ty_params(tps, sc, v);\n+        // Can maybe skip this now that we require self on class fields\n         let class_scope = cons(scope_item(i), @sc);\n         /* visit the constructor... */\n+        let ctor_scope = cons(scope_method(ctor.node.self_id, tps),\n+                              @class_scope);\n         visit_fn_with_scope(e, visit::fk_item_fn(i.ident, tps), ctor.node.dec,\n                             ctor.node.body, ctor.span, ctor.node.id,\n-                            class_scope, v);\n+                            ctor_scope, v);\n         /* visit the items */\n         for cm in members {\n             alt cm.node.decl {\n-              class_method(m) { visit_fn_with_scope(e,\n-                 visit::fk_item_fn(m.ident, tps), m.decl, m.body,\n-                 m.span, m.id, class_scope, v); }\n+              class_method(m) {\n+                  let msc = cons(scope_method(m.self_id, tps + m.tps),\n+                                 @class_scope);\n+                  visit_fn_with_scope(e,\n+                     visit::fk_item_fn(m.ident, tps), m.decl, m.body,\n+                                 m.span, m.id, msc, v); }\n               instance_var(_,t,_,_) { v.visit_ty(t, class_scope, v); }\n             }\n         }"}, {"sha": "63a30f02434f90a4bcdc068e4f0b479388824b9b", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ca6636d6b689fe209a210b0eda51e368f01cdb0f/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6636d6b689fe209a210b0eda51e368f01cdb0f/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=ca6636d6b689fe209a210b0eda51e368f01cdb0f", "patch": "@@ -49,7 +49,9 @@ type vtable_map = hashmap<ast::node_id, vtable_res>;\n type ty_table = hashmap<ast::def_id, ty::t>;\n \n // Used for typechecking the methods of an impl\n-enum self_info { self_impl(ty::t) }\n+// first field is the self type, second is the ID for the \"self\" object\n+// that's currently in scope\n+enum self_info { self_impl(ty::t, ast::node_id) }\n \n type crate_ctxt = {mut self_infos: [self_info],\n                    impl_map: resolve::impl_map,\n@@ -117,7 +119,7 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n       }\n       ast::def_self(_) {\n         alt get_self_info(fcx.ccx) {\n-          some(self_impl(impl_t)) {\n+          some(self_impl(impl_t,_)) {\n             ret {bounds: @[], ty: impl_t};\n           }\n           none {\n@@ -3128,20 +3130,28 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               // field\n               #debug(\"class named %s\", ty_to_str(tcx, base_t));\n               /*\n-                This is an external reference, so only consider public\n-                fields\n+                check whether this is a self-reference or not, which\n+                determines whether we look at all fields or only public\n+                ones\n                */\n-              let cls_items = lookup_public_fields(tcx, base_id);\n-              #debug(\"cls_items: %?\", cls_items);\n-              alt lookup_field_ty(tcx, base_id, cls_items, field) {\n+              let node_def = lookup_def(fcx, base.span, base.id);\n+              let cls_items = alt get_self_info(fcx.ccx) {\n+                      some(self_impl(_, n_id)) if alt node_def {\n+                          ast::def_self(base_id) { base_id == n_id }\n+                          _ { false }} {\n+                        // base expr is \"self\" -- consider all fields\n+                        ty::lookup_class_fields(tcx, base_id)\n+                      }\n+                      _ { lookup_public_fields(tcx, base_id) }\n+              };\n+               alt lookup_field_ty(tcx, base_id, cls_items, field) {\n                  some(field_ty) {\n-                     #debug(\"a\");\n                     // (2) look up what field's type is, and return it\n                     // FIXME: actually instantiate any type params\n                      write_ty(tcx, id, field_ty);\n                      handled = true;\n                  }\n-                 none { #debug(\"b\"); }\n+                 none {}\n               }\n           }\n           _ {}\n@@ -3659,11 +3669,16 @@ fn class_types(ccx: @crate_ctxt, members: [@ast::class_item]) -> class_map {\n     rslt\n }\n \n-fn check_class_member(ccx: @crate_ctxt, cm: ast::class_member) {\n+fn check_class_member(ccx: @crate_ctxt, class_t: ty::t,\n+                      cm: ast::class_member) {\n     alt cm {\n       ast::instance_var(_,t,_,_) {\n       }\n-      ast::class_method(m) { check_method(ccx, m); }\n+      ast::class_method(m) {\n+          ccx.self_infos += [self_impl(class_t, m.self_id)];\n+          check_method(ccx, m);\n+          vec::pop(ccx.self_infos);\n+      }\n     }\n }\n \n@@ -3681,20 +3696,28 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         let mut self_ty = ast_ty_to_ty(ccx.tcx, m_check, ty);\n         let self_region = ty::re_self;\n         self_ty = instantiate_self_regions(ccx.tcx, self_region, self_ty);\n-        ccx.self_infos += [self_impl(self_ty)];\n-        for m in ms { check_method(ccx, m); }\n-        vec::pop(ccx.self_infos);\n+        for m in ms {\n+             ccx.self_infos += [self_impl(self_ty, m.id)];\n+             check_method(ccx, m);\n+             vec::pop(ccx.self_infos);\n+        }\n       }\n       ast::item_class(tps, members, ctor) {\n           let cid = some(it.id);\n+          let class_t = node_id_to_type(ccx.tcx, it.id);\n           let members_info = class_types(ccx, members);\n+          // can also ditch the enclosing_class stuff once we move to self\n+          // FIXME\n           let class_ccx = @{enclosing_class_id:cid,\n                             enclosing_class:members_info with *ccx};\n+          class_ccx.self_infos += [self_impl(class_t, ctor.node.self_id)];\n           // typecheck the ctor\n           check_fn(class_ccx, ast::proto_bare, ctor.node.dec,\n                    ctor.node.body, ctor.node.id, false, none);\n+          vec::pop(class_ccx.self_infos);\n           // typecheck the members\n-          for m in members { check_class_member(class_ccx, m.node.decl); }\n+          for m in members { check_class_member(class_ccx, class_t,\n+                                                m.node.decl); }\n       }\n       _ {/* nothing to do */ }\n     }"}, {"sha": "447d754895e7c17bafad5e845dbfeda149e04d86", "filename": "src/rustc/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca6636d6b689fe209a210b0eda51e368f01cdb0f/src%2Frustc%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6636d6b689fe209a210b0eda51e368f01cdb0f/src%2Frustc%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast.rs?ref=ca6636d6b689fe209a210b0eda51e368f01cdb0f", "patch": "@@ -684,6 +684,7 @@ type class_ctor = spanned<class_ctor_>;\n \n #[auto_serialize]\n type class_ctor_ = {id: node_id,\n+                    self_id: node_id,\n                     dec: fn_decl,\n                     body: blk};\n "}, {"sha": "61cc675c492d63a63da2220c3144c5cdb8388c30", "filename": "src/rustc/syntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca6636d6b689fe209a210b0eda51e368f01cdb0f/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6636d6b689fe209a210b0eda51e368f01cdb0f/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs?ref=ca6636d6b689fe209a210b0eda51e368f01cdb0f", "patch": "@@ -2092,10 +2092,12 @@ fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     }\n     p.bump();\n     alt the_ctor {\n-      some((ct_d, ct_b, ct_s)) { ret mk_item(p, lo, p.last_span.hi,\n+      some((ct_d, ct_b, ct_s)) {\n+          ret mk_item(p, lo, p.last_span.hi,\n                                              class_name,\n          ast::item_class(ty_params, items,\n                          {node: {id: ctor_id,\n+                                 self_id: p.get_id(),\n                                  dec: ct_d,\n                                  body: ct_b},\n                           span: ct_s}), attrs); }"}, {"sha": "ae37fb9a9979841cc581f3ac6c2ce863c403e1e9", "filename": "src/test/run-pass/classes-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca6636d6b689fe209a210b0eda51e368f01cdb0f/src%2Ftest%2Frun-pass%2Fclasses-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6636d6b689fe209a210b0eda51e368f01cdb0f/src%2Ftest%2Frun-pass%2Fclasses-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-simple.rs?ref=ca6636d6b689fe209a210b0eda51e368f01cdb0f", "patch": "@@ -5,7 +5,7 @@ class cat {\n \n   let how_hungry : int;\n \n-  new(in_x : uint, in_y : int) { meows = in_x; how_hungry = in_y; }\n+  new(in_x : uint, in_y : int) { self.meows = in_x; self.how_hungry = in_y; }\n }\n \n fn main() {"}]}