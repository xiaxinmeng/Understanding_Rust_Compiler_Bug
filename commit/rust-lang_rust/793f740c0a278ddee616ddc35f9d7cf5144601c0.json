{"sha": "793f740c0a278ddee616ddc35f9d7cf5144601c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5M2Y3NDBjMGEyNzhkZGVlNjE2ZGRjMzVmOWQ3Y2Y1MTQ0NjAxYzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-16T05:51:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-16T05:51:42Z"}, "message": "auto merge of #11575 : pcwalton/rust/parse-substrs, r=alexcrichton\n\nThis was used by the quasiquoter.\r\n\r\nr? @alexcrichton", "tree": {"sha": "7ddee5f8d5c9eb08cab655e7d6cdbebdd9e1c98a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ddee5f8d5c9eb08cab655e7d6cdbebdd9e1c98a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/793f740c0a278ddee616ddc35f9d7cf5144601c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/793f740c0a278ddee616ddc35f9d7cf5144601c0", "html_url": "https://github.com/rust-lang/rust/commit/793f740c0a278ddee616ddc35f9d7cf5144601c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/793f740c0a278ddee616ddc35f9d7cf5144601c0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6708558c341d0c4fd467636ee2b2695c125ae4d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6708558c341d0c4fd467636ee2b2695c125ae4d3", "html_url": "https://github.com/rust-lang/rust/commit/6708558c341d0c4fd467636ee2b2695c125ae4d3"}, {"sha": "ff6c0af15baf35bf6d1867df7e846b47cd31b271", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff6c0af15baf35bf6d1867df7e846b47cd31b271", "html_url": "https://github.com/rust-lang/rust/commit/ff6c0af15baf35bf6d1867df7e846b47cd31b271"}], "stats": {"total": 91, "additions": 9, "deletions": 82}, "files": [{"sha": "904ef91d635713cb68f7e5c7a26efeeca1f9e7d0", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 8, "deletions": 42, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/793f740c0a278ddee616ddc35f9d7cf5144601c0/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793f740c0a278ddee616ddc35f9d7cf5144601c0/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=793f740c0a278ddee616ddc35f9d7cf5144601c0", "patch": "@@ -191,15 +191,6 @@ pub struct FileLines\n     lines: ~[uint]\n }\n \n-// represents the origin of a file:\n-pub enum FileSubstr {\n-    // indicates that this is a normal standalone file:\n-    FssNone,\n-    // indicates that this \"file\" is actually a substring\n-    // of another file that appears earlier in the codemap\n-    FssInternal(Span),\n-}\n-\n /// Identifies an offset of a multi-byte character in a FileMap\n pub struct MultiByteChar {\n     /// The absolute offset of the character in the CodeMap\n@@ -214,8 +205,6 @@ pub struct FileMap {\n     /// originate from files has names between angle brackets by convention,\n     /// e.g. `<anon>`\n     name: FileName,\n-    /// Extra information used by qquote\n-    substr: FileSubstr,\n     /// The complete source code\n     src: @str,\n     /// The start position of this source in the CodeMap\n@@ -278,16 +267,7 @@ impl CodeMap {\n         }\n     }\n \n-    /// Add a new FileMap to the CodeMap and return it\n     pub fn new_filemap(&self, filename: FileName, src: @str) -> @FileMap {\n-        return self.new_filemap_w_substr(filename, FssNone, src);\n-    }\n-\n-    pub fn new_filemap_w_substr(&self,\n-                                filename: FileName,\n-                                substr: FileSubstr,\n-                                src: @str)\n-                                -> @FileMap {\n         let mut files = self.files.borrow_mut();\n         let start_pos = if files.get().len() == 0 {\n             0\n@@ -298,7 +278,8 @@ impl CodeMap {\n         };\n \n         let filemap = @FileMap {\n-            name: filename, substr: substr, src: src,\n+            name: filename,\n+            src: src,\n             start_pos: Pos::from_uint(start_pos),\n             lines: RefCell::new(~[]),\n             multibyte_chars: RefCell::new(~[]),\n@@ -322,31 +303,16 @@ impl CodeMap {\n \n     pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt {\n         let loc = self.lookup_char_pos(pos);\n-        match (loc.file.substr) {\n-            FssNone =>\n-            LocWithOpt {\n-                filename: loc.file.name,\n-                line: loc.line,\n-                col: loc.col,\n-                file: Some(loc.file)},\n-            FssInternal(sp) =>\n-            self.lookup_char_pos_adj(\n-                sp.lo + (pos - loc.file.start_pos)),\n+        LocWithOpt {\n+            filename: loc.file.name,\n+            line: loc.line,\n+            col: loc.col,\n+            file: Some(loc.file)\n         }\n     }\n \n     pub fn adjust_span(&self, sp: Span) -> Span {\n-        let line = self.lookup_line(sp.lo);\n-        match (line.fm.substr) {\n-            FssNone => sp,\n-            FssInternal(s) => {\n-                self.adjust_span(Span {\n-                    lo: s.lo + (sp.lo - line.fm.start_pos),\n-                    hi: s.lo + (sp.hi - line.fm.start_pos),\n-                    expn_info: sp.expn_info\n-                })\n-            }\n-        }\n+        sp\n     }\n \n     pub fn span_to_str(&self, sp: Span) -> ~str {"}, {"sha": "c278fb2fc510404881b7e9bdef1ce21897213553", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/793f740c0a278ddee616ddc35f9d7cf5144601c0/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793f740c0a278ddee616ddc35f9d7cf5144601c0/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=793f740c0a278ddee616ddc35f9d7cf5144601c0", "patch": "@@ -12,7 +12,7 @@\n \n \n use ast;\n-use codemap::{Span, CodeMap, FileMap, FileSubstr};\n+use codemap::{Span, CodeMap, FileMap};\n use codemap;\n use diagnostic::{SpanHandler, mk_span_handler, mk_handler, Emitter};\n use parse::attr::ParserAttr;\n@@ -180,27 +180,6 @@ pub fn parse_tts_from_source_str(\n     maybe_aborted(p.parse_all_token_trees(),p)\n }\n \n-// given a function and parsing information (source str,\n-// filename, crate cfg, and sess), create a parser,\n-// apply the function, and check that the parser\n-// consumed all of the input before returning the function's\n-// result.\n-pub fn parse_from_source_str<T>(\n-                             f: |&mut Parser| -> T,\n-                             name: @str,\n-                             ss: codemap::FileSubstr,\n-                             source: @str,\n-                             cfg: ast::CrateConfig,\n-                             sess: @ParseSess)\n-                             -> T {\n-    let mut p = new_parser_from_source_substr(sess, cfg, name, ss, source);\n-    let r = f(&mut p);\n-    if !p.reader.is_eof() {\n-        p.reader.fatal(~\"expected end-of-string\");\n-    }\n-    maybe_aborted(r,p)\n-}\n-\n // Create a new parser from a source string\n pub fn new_parser_from_source_str(sess: @ParseSess,\n                                   cfg: ast::CrateConfig,\n@@ -210,17 +189,6 @@ pub fn new_parser_from_source_str(sess: @ParseSess,\n     filemap_to_parser(sess,string_to_filemap(sess,source,name),cfg)\n }\n \n-// Create a new parser from a source string where the origin\n-// is specified as a substring of another file.\n-pub fn new_parser_from_source_substr(sess: @ParseSess,\n-                                  cfg: ast::CrateConfig,\n-                                  name: @str,\n-                                  ss: codemap::FileSubstr,\n-                                  source: @str)\n-                               -> Parser {\n-    filemap_to_parser(sess,substring_to_filemap(sess,source,name,ss),cfg)\n-}\n-\n /// Create a new parser, handling errors as appropriate\n /// if the file doesn't exist\n pub fn new_parser_from_file(\n@@ -297,13 +265,6 @@ pub fn string_to_filemap(sess: @ParseSess, source: @str, path: @str)\n     sess.cm.new_filemap(path, source)\n }\n \n-// given a session and a string and a path and a FileSubStr, add\n-// the string to the CodeMap and return the new FileMap\n-pub fn substring_to_filemap(sess: @ParseSess, source: @str, path: @str,\n-                           filesubstr: FileSubstr) -> @FileMap {\n-    sess.cm.new_filemap_w_substr(path,filesubstr,source)\n-}\n-\n // given a filemap, produce a sequence of token-trees\n pub fn filemap_to_tts(sess: @ParseSess, filemap: @FileMap)\n     -> ~[ast::TokenTree] {"}]}