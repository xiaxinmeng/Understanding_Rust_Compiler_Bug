{"sha": "184665ff9b7b64730ecf481c1914a74e7191a6dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4NDY2NWZmOWI3YjY0NzMwZWNmNDgxYzE5MTRhNzRlNzE5MWE2ZGQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-21T22:04:32Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-21T22:04:32Z"}, "message": "Merge #315\n\n315: Split completion into manageable components r=matklad a=matklad\n\nThe main idea here is to do completion in two phases:\r\n\r\n* first, we figure out surrounding context\r\n* then, we run a series of completers on the given context. \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "4f5e97a0832821a4b06b784591d6cb3a417f1198", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f5e97a0832821a4b06b784591d6cb3a417f1198"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/184665ff9b7b64730ecf481c1914a74e7191a6dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/184665ff9b7b64730ecf481c1914a74e7191a6dd", "html_url": "https://github.com/rust-lang/rust/commit/184665ff9b7b64730ecf481c1914a74e7191a6dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/184665ff9b7b64730ecf481c1914a74e7191a6dd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "2351308d92f4c785d98cc24026a818d28945513e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2351308d92f4c785d98cc24026a818d28945513e", "html_url": "https://github.com/rust-lang/rust/commit/2351308d92f4c785d98cc24026a818d28945513e"}, {"sha": "2ae87ffc9afe67945e2ad655c3577b589ff640ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ae87ffc9afe67945e2ad655c3577b589ff640ab", "html_url": "https://github.com/rust-lang/rust/commit/2ae87ffc9afe67945e2ad655c3577b589ff640ab"}], "stats": {"total": 1649, "additions": 878, "deletions": 771}, "files": [{"sha": "2d61a3aef53e9abe91300f5059c434779644ac1e", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 27, "deletions": 137, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/184665ff9b7b64730ecf481c1914a74e7191a6dd/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/184665ff9b7b64730ecf481c1914a74e7191a6dd/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=184665ff9b7b64730ecf481c1914a74e7191a6dd", "patch": "@@ -1,112 +1,50 @@\n mod completion_item;\n-mod reference_completion;\n+mod completion_context;\n+\n+mod complete_fn_param;\n+mod complete_keyword;\n+mod complete_snippet;\n+mod complete_path;\n+mod complete_scope;\n \n-use ra_editor::find_node_at_offset;\n-use ra_text_edit::AtomTextEdit;\n-use ra_syntax::{\n-    algo::visit::{visitor_ctx, VisitorCtx},\n-    ast,\n-    AstNode,\n-    SyntaxNodeRef,\n-};\n use ra_db::SyntaxDatabase;\n-use rustc_hash::{FxHashMap};\n-use hir::source_binder;\n \n use crate::{\n     db,\n     Cancelable, FilePosition,\n-    completion::completion_item::{Completions, CompletionKind},\n+    completion::{\n+        completion_item::{Completions, CompletionKind},\n+        completion_context::CompletionContext,\n+    },\n };\n \n pub use crate::completion::completion_item::{CompletionItem, InsertText};\n \n+/// Main entry point for copmletion. We run comletion as a two-phase process.\n+///\n+/// First, we look at the position and collect a so-called `CompletionContext.\n+/// This is a somewhat messy process, because, during completion, syntax tree is\n+/// incomplete and can look readlly weired.\n+///\n+/// Once the context is collected, we run a series of completion routines whihc\n+/// look at the context and produce completion items.\n pub(crate) fn completions(\n     db: &db::RootDatabase,\n     position: FilePosition,\n ) -> Cancelable<Option<Completions>> {\n     let original_file = db.source_file(position.file_id);\n-    // Insert a fake ident to get a valid parse tree\n-    let file = {\n-        let edit = AtomTextEdit::insert(position.offset, \"intellijRulezz\".to_string());\n-        original_file.reparse(&edit)\n-    };\n-\n-    let module = ctry!(source_binder::module_from_position(db, position)?);\n+    let ctx = ctry!(CompletionContext::new(db, &original_file, position)?);\n \n     let mut acc = Completions::default();\n-    let mut has_completions = false;\n-    // First, let's try to complete a reference to some declaration.\n-    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n-        has_completions = true;\n-        reference_completion::completions(&mut acc, db, &module, &file, name_ref)?;\n-        // special case, `trait T { fn foo(i_am_a_name_ref) {} }`\n-        if is_node::<ast::Param>(name_ref.syntax()) {\n-            param_completions(&mut acc, name_ref.syntax());\n-        }\n-    }\n \n-    // Otherwise, if this is a declaration, use heuristics to suggest a name.\n-    if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), position.offset) {\n-        if is_node::<ast::Param>(name.syntax()) {\n-            has_completions = true;\n-            param_completions(&mut acc, name.syntax());\n-        }\n-    }\n-    if !has_completions {\n-        return Ok(None);\n-    }\n-    Ok(Some(acc))\n-}\n-\n-/// Complete repeated parametes, both name and type. For example, if all\n-/// functions in a file have a `spam: &mut Spam` parameter, a completion with\n-/// `spam: &mut Spam` insert text/label and `spam` lookup string will be\n-/// suggested.\n-fn param_completions(acc: &mut Completions, ctx: SyntaxNodeRef) {\n-    let mut params = FxHashMap::default();\n-    for node in ctx.ancestors() {\n-        let _ = visitor_ctx(&mut params)\n-            .visit::<ast::SourceFile, _>(process)\n-            .visit::<ast::ItemList, _>(process)\n-            .accept(node);\n-    }\n-    params\n-        .into_iter()\n-        .filter_map(|(label, (count, param))| {\n-            let lookup = param.pat()?.syntax().text().to_string();\n-            if count < 2 {\n-                None\n-            } else {\n-                Some((label, lookup))\n-            }\n-        })\n-        .for_each(|(label, lookup)| {\n-            CompletionItem::new(label)\n-                .lookup_by(lookup)\n-                .kind(CompletionKind::Magic)\n-                .add_to(acc)\n-        });\n-\n-    fn process<'a, N: ast::FnDefOwner<'a>>(\n-        node: N,\n-        params: &mut FxHashMap<String, (u32, ast::Param<'a>)>,\n-    ) {\n-        node.functions()\n-            .filter_map(|it| it.param_list())\n-            .flat_map(|it| it.params())\n-            .for_each(|param| {\n-                let text = param.syntax().text().to_string();\n-                params.entry(text).or_insert((0, param)).0 += 1;\n-            })\n-    }\n-}\n+    complete_fn_param::complete_fn_param(&mut acc, &ctx);\n+    complete_keyword::complete_expr_keyword(&mut acc, &ctx);\n+    complete_snippet::complete_expr_snippet(&mut acc, &ctx);\n+    complete_snippet::complete_item_snippet(&mut acc, &ctx);\n+    complete_path::complete_path(&mut acc, &ctx)?;\n+    complete_scope::complete_scope(&mut acc, &ctx)?;\n \n-fn is_node<'a, N: AstNode<'a>>(node: SyntaxNodeRef<'a>) -> bool {\n-    match node.ancestors().filter_map(N::cast).next() {\n-        None => false,\n-        Some(n) => n.syntax().range() == node.range(),\n-    }\n+    Ok(Some(acc))\n }\n \n #[cfg(test)]\n@@ -120,51 +58,3 @@ fn check_completion(code: &str, expected_completions: &str, kind: CompletionKind\n     let completions = completions(&analysis.imp.db, position).unwrap().unwrap();\n     completions.assert_match(expected_completions, kind);\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    fn check_magic_completion(code: &str, expected_completions: &str) {\n-        check_completion(code, expected_completions, CompletionKind::Magic);\n-    }\n-\n-    #[test]\n-    fn test_param_completion_last_param() {\n-        check_magic_completion(\n-            r\"\n-            fn foo(file_id: FileId) {}\n-            fn bar(file_id: FileId) {}\n-            fn baz(file<|>) {}\n-            \",\n-            r#\"file_id \"file_id: FileId\"\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_param_completion_nth_param() {\n-        check_magic_completion(\n-            r\"\n-            fn foo(file_id: FileId) {}\n-            fn bar(file_id: FileId) {}\n-            fn baz(file<|>, x: i32) {}\n-            \",\n-            r#\"file_id \"file_id: FileId\"\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_param_completion_trait_param() {\n-        check_magic_completion(\n-            r\"\n-            pub(crate) trait SourceRoot {\n-                pub fn contains(&self, file_id: FileId) -> bool;\n-                pub fn module_map(&self) -> &ModuleMap;\n-                pub fn lines(&self, file_id: FileId) -> &LineIndex;\n-                pub fn syntax(&self, file<|>)\n-            }\n-            \",\n-            r#\"file_id \"file_id: FileId\"\"#,\n-        );\n-    }\n-}"}, {"sha": "6a6213e67bfbcf5b934a181ca018deb819e07fdd", "filename": "crates/ra_analysis/src/completion/complete_fn_param.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/184665ff9b7b64730ecf481c1914a74e7191a6dd/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/184665ff9b7b64730ecf481c1914a74e7191a6dd/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs?ref=184665ff9b7b64730ecf481c1914a74e7191a6dd", "patch": "@@ -0,0 +1,103 @@\n+use ra_syntax::{\n+    algo::visit::{visitor_ctx, VisitorCtx},\n+    ast,\n+    AstNode,\n+};\n+use rustc_hash::FxHashMap;\n+\n+use crate::completion::{CompletionContext, Completions, CompletionKind, CompletionItem};\n+\n+/// Complete repeated parametes, both name and type. For example, if all\n+/// functions in a file have a `spam: &mut Spam` parameter, a completion with\n+/// `spam: &mut Spam` insert text/label and `spam` lookup string will be\n+/// suggested.\n+pub(super) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext) {\n+    if !ctx.is_param {\n+        return;\n+    }\n+\n+    let mut params = FxHashMap::default();\n+    for node in ctx.leaf.ancestors() {\n+        let _ = visitor_ctx(&mut params)\n+            .visit::<ast::SourceFile, _>(process)\n+            .visit::<ast::ItemList, _>(process)\n+            .accept(node);\n+    }\n+    params\n+        .into_iter()\n+        .filter_map(|(label, (count, param))| {\n+            let lookup = param.pat()?.syntax().text().to_string();\n+            if count < 2 {\n+                None\n+            } else {\n+                Some((label, lookup))\n+            }\n+        })\n+        .for_each(|(label, lookup)| {\n+            CompletionItem::new(label)\n+                .lookup_by(lookup)\n+                .kind(CompletionKind::Magic)\n+                .add_to(acc)\n+        });\n+\n+    fn process<'a, N: ast::FnDefOwner<'a>>(\n+        node: N,\n+        params: &mut FxHashMap<String, (u32, ast::Param<'a>)>,\n+    ) {\n+        node.functions()\n+            .filter_map(|it| it.param_list())\n+            .flat_map(|it| it.params())\n+            .for_each(|param| {\n+                let text = param.syntax().text().to_string();\n+                params.entry(text).or_insert((0, param)).0 += 1;\n+            })\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::*;\n+\n+    fn check_magic_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Magic);\n+    }\n+\n+    #[test]\n+    fn test_param_completion_last_param() {\n+        check_magic_completion(\n+            r\"\n+            fn foo(file_id: FileId) {}\n+            fn bar(file_id: FileId) {}\n+            fn baz(file<|>) {}\n+            \",\n+            r#\"file_id \"file_id: FileId\"\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_param_completion_nth_param() {\n+        check_magic_completion(\n+            r\"\n+            fn foo(file_id: FileId) {}\n+            fn bar(file_id: FileId) {}\n+            fn baz(file<|>, x: i32) {}\n+            \",\n+            r#\"file_id \"file_id: FileId\"\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_param_completion_trait_param() {\n+        check_magic_completion(\n+            r\"\n+            pub(crate) trait SourceRoot {\n+                pub fn contains(&self, file_id: FileId) -> bool;\n+                pub fn module_map(&self) -> &ModuleMap;\n+                pub fn lines(&self, file_id: FileId) -> &LineIndex;\n+                pub fn syntax(&self, file<|>)\n+            }\n+            \",\n+            r#\"file_id \"file_id: FileId\"\"#,\n+        );\n+    }\n+}"}, {"sha": "dead15bb6f059dd2fbf54d2d4f5eff558c266ffe", "filename": "crates/ra_analysis/src/completion/complete_keyword.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/184665ff9b7b64730ecf481c1914a74e7191a6dd/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/184665ff9b7b64730ecf481c1914a74e7191a6dd/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=184665ff9b7b64730ecf481c1914a74e7191a6dd", "patch": "@@ -0,0 +1,204 @@\n+use ra_syntax::{\n+    algo::visit::{visitor, Visitor},\n+    AstNode,\n+    ast::{self, LoopBodyOwner},\n+    SyntaxKind::*, SyntaxNodeRef,\n+};\n+\n+use crate::completion::{CompletionContext, CompletionItem, Completions, CompletionKind::*};\n+\n+pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n+    if !ctx.is_trivial_path {\n+        return;\n+    }\n+    let fn_def = match ctx.enclosing_fn {\n+        Some(it) => it,\n+        None => return,\n+    };\n+    acc.add(keyword(\"if\", \"if $0 {}\"));\n+    acc.add(keyword(\"match\", \"match $0 {}\"));\n+    acc.add(keyword(\"while\", \"while $0 {}\"));\n+    acc.add(keyword(\"loop\", \"loop {$0}\"));\n+\n+    if ctx.after_if {\n+        acc.add(keyword(\"else\", \"else {$0}\"));\n+        acc.add(keyword(\"else if\", \"else if $0 {}\"));\n+    }\n+    if is_in_loop_body(ctx.leaf) {\n+        acc.add(keyword(\"continue\", \"continue\"));\n+        acc.add(keyword(\"break\", \"break\"));\n+    }\n+    acc.add_all(complete_return(fn_def, ctx.is_stmt));\n+}\n+\n+fn is_in_loop_body(leaf: SyntaxNodeRef) -> bool {\n+    for node in leaf.ancestors() {\n+        if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n+            break;\n+        }\n+        let loop_body = visitor()\n+            .visit::<ast::ForExpr, _>(LoopBodyOwner::loop_body)\n+            .visit::<ast::WhileExpr, _>(LoopBodyOwner::loop_body)\n+            .visit::<ast::LoopExpr, _>(LoopBodyOwner::loop_body)\n+            .accept(node);\n+        if let Some(Some(body)) = loop_body {\n+            if leaf.range().is_subrange(&body.syntax().range()) {\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+fn complete_return(fn_def: ast::FnDef, is_stmt: bool) -> Option<CompletionItem> {\n+    let snip = match (is_stmt, fn_def.ret_type().is_some()) {\n+        (true, true) => \"return $0;\",\n+        (true, false) => \"return;\",\n+        (false, true) => \"return $0\",\n+        (false, false) => \"return\",\n+    };\n+    Some(keyword(\"return\", snip))\n+}\n+\n+fn keyword(kw: &str, snippet: &str) -> CompletionItem {\n+    CompletionItem::new(kw)\n+        .kind(Keyword)\n+        .snippet(snippet)\n+        .build()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::{CompletionKind, check_completion};\n+    fn check_keyword_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Keyword);\n+    }\n+\n+    #[test]\n+    fn test_completion_kewords() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() {\n+                <|>\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_else() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() {\n+                if true {\n+                    ()\n+                } <|>\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            else \"else {$0}\"\n+            else if \"else if $0 {}\"\n+            return \"return\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_return_value() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                <|>\n+                92\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return $0;\"\n+            \"#,\n+        );\n+        check_keyword_completion(\n+            r\"\n+            fn quux() {\n+                <|>\n+                92\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return;\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_return_no_stmt() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                match () {\n+                    () => <|>\n+                }\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return $0\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_continue_break_completion() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                loop { <|> }\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            continue \"continue\"\n+            break \"break\"\n+            return \"return $0\"\n+            \"#,\n+        );\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                loop { || { <|> } }\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return $0\"\n+            \"#,\n+        );\n+    }\n+}"}, {"sha": "5fc24af7209cd2d78094a89128b04d88dca240d7", "filename": "crates/ra_analysis/src/completion/complete_path.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/184665ff9b7b64730ecf481c1914a74e7191a6dd/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/184665ff9b7b64730ecf481c1914a74e7191a6dd/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=184665ff9b7b64730ecf481c1914a74e7191a6dd", "patch": "@@ -0,0 +1,95 @@\n+use crate::{\n+    Cancelable,\n+    completion::{CompletionItem, Completions, CompletionKind::*, CompletionContext},\n+};\n+\n+pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) -> Cancelable<()> {\n+    let (path, module) = match (&ctx.path_prefix, &ctx.module) {\n+        (Some(path), Some(module)) => (path.clone(), module),\n+        _ => return Ok(()),\n+    };\n+    let def_id = match module.resolve_path(ctx.db, path)? {\n+        Some(it) => it,\n+        None => return Ok(()),\n+    };\n+    let target_module = match def_id.resolve(ctx.db)? {\n+        hir::Def::Module(it) => it,\n+        _ => return Ok(()),\n+    };\n+    let module_scope = target_module.scope(ctx.db)?;\n+    module_scope.entries().for_each(|(name, _res)| {\n+        CompletionItem::new(name.to_string())\n+            .kind(Reference)\n+            .add_to(acc)\n+    });\n+    Ok(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::{CompletionKind, check_completion};\n+\n+    fn check_reference_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Reference);\n+    }\n+\n+    #[test]\n+    fn completes_use_item_starting_with_self() {\n+        check_reference_completion(\n+            r\"\n+            use self::m::<|>;\n+\n+            mod m {\n+                struct Bar;\n+            }\n+            \",\n+            \"Bar\",\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_use_item_starting_with_crate() {\n+        check_reference_completion(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+            struct Spam;\n+            //- /foo.rs\n+            use crate::Sp<|>\n+            \",\n+            \"Spam;foo\",\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_nested_use_tree() {\n+        check_reference_completion(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+            struct Spam;\n+            //- /foo.rs\n+            use crate::{Sp<|>};\n+            \",\n+            \"Spam;foo\",\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_deeply_nested_use_tree() {\n+        check_reference_completion(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+            pub mod bar {\n+                pub mod baz {\n+                    pub struct Spam;\n+                }\n+            }\n+            //- /foo.rs\n+            use crate::{bar::{baz::Sp<|>}};\n+            \",\n+            \"Spam\",\n+        );\n+    }\n+}"}, {"sha": "d07c0e46d97405ddd863edb48a48f3f4da19acf3", "filename": "crates/ra_analysis/src/completion/complete_scope.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/184665ff9b7b64730ecf481c1914a74e7191a6dd/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/184665ff9b7b64730ecf481c1914a74e7191a6dd/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=184665ff9b7b64730ecf481c1914a74e7191a6dd", "patch": "@@ -0,0 +1,171 @@\n+use rustc_hash::FxHashSet;\n+use ra_syntax::TextUnit;\n+\n+use crate::{\n+    Cancelable,\n+    completion::{CompletionItem, Completions, CompletionKind::*, CompletionContext},\n+};\n+\n+pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) -> Cancelable<()> {\n+    if !ctx.is_trivial_path {\n+        return Ok(());\n+    }\n+    if let Some(fn_def) = ctx.enclosing_fn {\n+        let scopes = hir::FnScopes::new(fn_def);\n+        complete_fn(acc, &scopes, ctx.offset);\n+    }\n+\n+    if let Some(module) = &ctx.module {\n+        let module_scope = module.scope(ctx.db)?;\n+        module_scope\n+            .entries()\n+            .filter(|(_name, res)| {\n+                // Don't expose this item\n+                match res.import {\n+                    None => true,\n+                    Some(import) => {\n+                        let range = import.range(ctx.db, module.source().file_id());\n+                        !range.is_subrange(&ctx.leaf.range())\n+                    }\n+                }\n+            })\n+            .for_each(|(name, _res)| {\n+                CompletionItem::new(name.to_string())\n+                    .kind(Reference)\n+                    .add_to(acc)\n+            });\n+    }\n+\n+    Ok(())\n+}\n+\n+fn complete_fn(acc: &mut Completions, scopes: &hir::FnScopes, offset: TextUnit) {\n+    let mut shadowed = FxHashSet::default();\n+    scopes\n+        .scope_chain_for_offset(offset)\n+        .flat_map(|scope| scopes.entries(scope).iter())\n+        .filter(|entry| shadowed.insert(entry.name()))\n+        .for_each(|entry| {\n+            CompletionItem::new(entry.name().to_string())\n+                .kind(Reference)\n+                .add_to(acc)\n+        });\n+    if scopes.self_param.is_some() {\n+        CompletionItem::new(\"self\").kind(Reference).add_to(acc);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::{CompletionKind, check_completion};\n+\n+    fn check_reference_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Reference);\n+    }\n+\n+    #[test]\n+    fn completes_bindings_from_let() {\n+        check_reference_completion(\n+            r\"\n+            fn quux(x: i32) {\n+                let y = 92;\n+                1 + <|>;\n+                let z = ();\n+            }\n+            \",\n+            \"y;x;quux\",\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_bindings_from_if_let() {\n+        check_reference_completion(\n+            r\"\n+            fn quux() {\n+                if let Some(x) = foo() {\n+                    let y = 92;\n+                };\n+                if let Some(a) = bar() {\n+                    let b = 62;\n+                    1 + <|>\n+                }\n+            }\n+            \",\n+            \"b;a;quux\",\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_bindings_from_for() {\n+        check_reference_completion(\n+            r\"\n+            fn quux() {\n+                for x in &[1, 2, 3] {\n+                    <|>\n+                }\n+            }\n+            \",\n+            \"x;quux\",\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_module_items() {\n+        check_reference_completion(\n+            r\"\n+            struct Foo;\n+            enum Baz {}\n+            fn quux() {\n+                <|>\n+            }\n+            \",\n+            \"quux;Foo;Baz\",\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_module_items_in_nested_modules() {\n+        check_reference_completion(\n+            r\"\n+            struct Foo;\n+            mod m {\n+                struct Bar;\n+                fn quux() { <|> }\n+            }\n+            \",\n+            \"quux;Bar\",\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_return_type() {\n+        check_reference_completion(\n+            r\"\n+            struct Foo;\n+            fn x() -> <|>\n+            \",\n+            \"Foo;x\",\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_show_to_completions_for_shadowing() {\n+        check_reference_completion(\n+            r\"\n+            fn foo() -> {\n+                let bar = 92;\n+                {\n+                    let bar = 62;\n+                    <|>\n+                }\n+            }\n+            \",\n+            \"bar;foo\",\n+        )\n+    }\n+\n+    #[test]\n+    fn completes_self_in_methods() {\n+        check_reference_completion(r\"impl S { fn foo(&self) { <|> } }\", \"self\")\n+    }\n+}"}, {"sha": "ccd68832b4aba5e2144cb8c3d6549648750a455a", "filename": "crates/ra_analysis/src/completion/complete_snippet.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/184665ff9b7b64730ecf481c1914a74e7191a6dd/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/184665ff9b7b64730ecf481c1914a74e7191a6dd/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs?ref=184665ff9b7b64730ecf481c1914a74e7191a6dd", "patch": "@@ -0,0 +1,76 @@\n+use crate::completion::{CompletionItem, Completions, CompletionKind::*, CompletionContext};\n+\n+pub(super) fn complete_expr_snippet(acc: &mut Completions, ctx: &CompletionContext) {\n+    if !(ctx.is_trivial_path && ctx.enclosing_fn.is_some()) {\n+        return;\n+    }\n+    CompletionItem::new(\"pd\")\n+        .snippet(\"eprintln!(\\\"$0 = {:?}\\\", $0);\")\n+        .kind(Snippet)\n+        .add_to(acc);\n+    CompletionItem::new(\"ppd\")\n+        .snippet(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\")\n+        .kind(Snippet)\n+        .add_to(acc);\n+}\n+\n+pub(super) fn complete_item_snippet(acc: &mut Completions, ctx: &CompletionContext) {\n+    if !ctx.is_new_item {\n+        return;\n+    }\n+    CompletionItem::new(\"Test function\")\n+        .lookup_by(\"tfn\")\n+        .snippet(\n+            \"\\\n+#[test]\n+fn ${1:feature}() {\n+    $0\n+}\",\n+        )\n+        .kind(Snippet)\n+        .add_to(acc);\n+    CompletionItem::new(\"pub(crate)\")\n+        .snippet(\"pub(crate) $0\")\n+        .kind(Snippet)\n+        .add_to(acc);\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::{CompletionKind, check_completion};\n+    fn check_snippet_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Snippet);\n+    }\n+\n+    #[test]\n+    fn completes_snippets_in_expressions() {\n+        check_snippet_completion(\n+            r\"fn foo(x: i32) { <|> }\",\n+            r##\"\n+            pd \"eprintln!(\\\"$0 = {:?}\\\", $0);\"\n+            ppd \"eprintln!(\\\"$0 = {:#?}\\\", $0);\"\n+            \"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_snippets_in_items() {\n+        // check_snippet_completion(r\"\n+        //     <|>\n+        //     \",\n+        //     r##\"[CompletionItem { label: \"Test function\", lookup: None, snippet: Some(\"#[test]\\nfn test_${1:feature}() {\\n$0\\n}\"##,\n+        // );\n+        check_snippet_completion(\n+            r\"\n+            #[cfg(test)]\n+            mod tests {\n+                <|>\n+            }\n+            \",\n+            r##\"\n+            tfn \"Test function\" \"#[test]\\nfn ${1:feature}() {\\n    $0\\n}\"\n+            pub(crate) \"pub(crate) $0\"\n+            \"##,\n+        );\n+    }\n+}"}, {"sha": "064fbc6f7be89751ea910863e9b784e3224691b3", "filename": "crates/ra_analysis/src/completion/completion_context.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/184665ff9b7b64730ecf481c1914a74e7191a6dd/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/184665ff9b7b64730ecf481c1914a74e7191a6dd/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=184665ff9b7b64730ecf481c1914a74e7191a6dd", "patch": "@@ -0,0 +1,156 @@\n+use ra_editor::find_node_at_offset;\n+use ra_text_edit::AtomTextEdit;\n+use ra_syntax::{\n+    algo::find_leaf_at_offset,\n+    ast,\n+    AstNode,\n+    SyntaxNodeRef,\n+    SourceFileNode,\n+    TextUnit,\n+    SyntaxKind::*,\n+};\n+use hir::source_binder;\n+\n+use crate::{db, FilePosition, Cancelable};\n+\n+/// `CompletionContext` is created early during completion to figure out, where\n+/// exactly is the cursor, syntax-wise.\n+#[derive(Debug)]\n+pub(super) struct CompletionContext<'a> {\n+    pub(super) db: &'a db::RootDatabase,\n+    pub(super) offset: TextUnit,\n+    pub(super) leaf: SyntaxNodeRef<'a>,\n+    pub(super) module: Option<hir::Module>,\n+    pub(super) enclosing_fn: Option<ast::FnDef<'a>>,\n+    pub(super) is_param: bool,\n+    /// A single-indent path, like `foo`.\n+    pub(super) is_trivial_path: bool,\n+    /// If not a trivial, path, the prefix (qualifier).\n+    pub(super) path_prefix: Option<hir::Path>,\n+    pub(super) after_if: bool,\n+    pub(super) is_stmt: bool,\n+    /// Something is typed at the \"top\" level, in module or impl/trait.\n+    pub(super) is_new_item: bool,\n+}\n+\n+impl<'a> CompletionContext<'a> {\n+    pub(super) fn new(\n+        db: &'a db::RootDatabase,\n+        original_file: &'a SourceFileNode,\n+        position: FilePosition,\n+    ) -> Cancelable<Option<CompletionContext<'a>>> {\n+        let module = source_binder::module_from_position(db, position)?;\n+        let leaf =\n+            ctry!(find_leaf_at_offset(original_file.syntax(), position.offset).left_biased());\n+        let mut ctx = CompletionContext {\n+            db,\n+            leaf,\n+            offset: position.offset,\n+            module,\n+            enclosing_fn: None,\n+            is_param: false,\n+            is_trivial_path: false,\n+            path_prefix: None,\n+            after_if: false,\n+            is_stmt: false,\n+            is_new_item: false,\n+        };\n+        ctx.fill(original_file, position.offset);\n+        Ok(Some(ctx))\n+    }\n+\n+    fn fill(&mut self, original_file: &SourceFileNode, offset: TextUnit) {\n+        // Insert a fake ident to get a valid parse tree. We will use this file\n+        // to determine context, though the original_file will be used for\n+        // actual completion.\n+        let file = {\n+            let edit = AtomTextEdit::insert(offset, \"intellijRulezz\".to_string());\n+            original_file.reparse(&edit)\n+        };\n+\n+        // First, let's try to complete a reference to some declaration.\n+        if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), offset) {\n+            // Special case, `trait T { fn foo(i_am_a_name_ref) {} }`.\n+            // See RFC#1685.\n+            if is_node::<ast::Param>(name_ref.syntax()) {\n+                self.is_param = true;\n+                return;\n+            }\n+            self.classify_name_ref(&file, name_ref);\n+        }\n+\n+        // Otherwise, see if this is a declaration. We can use heuristics to\n+        // suggest declaration names, see `CompletionKind::Magic`.\n+        if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), offset) {\n+            if is_node::<ast::Param>(name.syntax()) {\n+                self.is_param = true;\n+                return;\n+            }\n+        }\n+    }\n+    fn classify_name_ref(&mut self, file: &SourceFileNode, name_ref: ast::NameRef) {\n+        let name_range = name_ref.syntax().range();\n+        let top_node = name_ref\n+            .syntax()\n+            .ancestors()\n+            .take_while(|it| it.range() == name_range)\n+            .last()\n+            .unwrap();\n+\n+        match top_node.parent().map(|it| it.kind()) {\n+            Some(SOURCE_FILE) | Some(ITEM_LIST) => {\n+                self.is_new_item = true;\n+                return;\n+            }\n+            _ => (),\n+        }\n+\n+        let parent = match name_ref.syntax().parent() {\n+            Some(it) => it,\n+            None => return,\n+        };\n+        if let Some(segment) = ast::PathSegment::cast(parent) {\n+            let path = segment.parent_path();\n+            if let Some(mut path) = hir::Path::from_ast(path) {\n+                if !path.is_ident() {\n+                    path.segments.pop().unwrap();\n+                    self.path_prefix = Some(path);\n+                    return;\n+                }\n+            }\n+            if path.qualifier().is_none() {\n+                self.is_trivial_path = true;\n+                self.enclosing_fn = self\n+                    .leaf\n+                    .ancestors()\n+                    .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n+                    .find_map(ast::FnDef::cast);\n+\n+                self.is_stmt = match name_ref\n+                    .syntax()\n+                    .ancestors()\n+                    .filter_map(ast::ExprStmt::cast)\n+                    .next()\n+                {\n+                    None => false,\n+                    Some(expr_stmt) => expr_stmt.syntax().range() == name_ref.syntax().range(),\n+                };\n+\n+                if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n+                    if let Some(if_expr) = find_node_at_offset::<ast::IfExpr>(file.syntax(), off) {\n+                        if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n+                            self.after_if = true;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn is_node<'a, N: AstNode<'a>>(node: SyntaxNodeRef<'a>) -> bool {\n+    match node.ancestors().filter_map(N::cast).next() {\n+        None => false,\n+        Some(n) => n.syntax().range() == node.range(),\n+    }\n+}"}, {"sha": "c2ac9545376a56f2b02b5235305efc0fd48f8f00", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "removed", "additions": 0, "deletions": 633, "changes": 633, "blob_url": "https://github.com/rust-lang/rust/blob/2351308d92f4c785d98cc24026a818d28945513e/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2351308d92f4c785d98cc24026a818d28945513e/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=2351308d92f4c785d98cc24026a818d28945513e", "patch": "@@ -1,633 +0,0 @@\n-use rustc_hash::{FxHashSet};\n-use ra_editor::find_node_at_offset;\n-use ra_syntax::{\n-    algo::visit::{visitor, Visitor},\n-    SourceFileNode, AstNode,\n-    ast::{self, LoopBodyOwner},\n-    SyntaxKind::*,\n-};\n-use hir::{\n-    self,\n-    FnScopes, Def, Path\n-};\n-\n-use crate::{\n-    db::RootDatabase,\n-    completion::{CompletionItem, Completions, CompletionKind::*},\n-    Cancelable\n-};\n-\n-pub(super) fn completions(\n-    acc: &mut Completions,\n-    db: &RootDatabase,\n-    module: &hir::Module,\n-    file: &SourceFileNode,\n-    name_ref: ast::NameRef,\n-) -> Cancelable<()> {\n-    let kind = match classify_name_ref(name_ref) {\n-        Some(it) => it,\n-        None => return Ok(()),\n-    };\n-\n-    match kind {\n-        NameRefKind::LocalRef { enclosing_fn } => {\n-            if let Some(fn_def) = enclosing_fn {\n-                let scopes = FnScopes::new(fn_def);\n-                complete_fn(name_ref, &scopes, acc);\n-                complete_expr_keywords(&file, fn_def, name_ref, acc);\n-                complete_expr_snippets(acc);\n-            }\n-\n-            let module_scope = module.scope(db)?;\n-            module_scope\n-                .entries()\n-                .filter(|(_name, res)| {\n-                    // Don't expose this item\n-                    match res.import {\n-                        None => true,\n-                        Some(import) => {\n-                            let range = import.range(db, module.source().file_id());\n-                            !range.is_subrange(&name_ref.syntax().range())\n-                        }\n-                    }\n-                })\n-                .for_each(|(name, _res)| {\n-                    CompletionItem::new(name.to_string())\n-                        .kind(Reference)\n-                        .add_to(acc)\n-                });\n-        }\n-        NameRefKind::Path(path) => complete_path(acc, db, module, path)?,\n-        NameRefKind::BareIdentInMod => {\n-            let name_range = name_ref.syntax().range();\n-            let top_node = name_ref\n-                .syntax()\n-                .ancestors()\n-                .take_while(|it| it.range() == name_range)\n-                .last()\n-                .unwrap();\n-            match top_node.parent().map(|it| it.kind()) {\n-                Some(SOURCE_FILE) | Some(ITEM_LIST) => complete_mod_item_snippets(acc),\n-                _ => (),\n-            }\n-        }\n-    }\n-    Ok(())\n-}\n-\n-enum NameRefKind<'a> {\n-    /// NameRef is a part of single-segment path, for example, a refernece to a\n-    /// local variable.\n-    LocalRef {\n-        enclosing_fn: Option<ast::FnDef<'a>>,\n-    },\n-    /// NameRef is the last segment in some path\n-    Path(Path),\n-    /// NameRef is bare identifier at the module's root.\n-    /// Used for keyword completion\n-    BareIdentInMod,\n-}\n-\n-fn classify_name_ref(name_ref: ast::NameRef) -> Option<NameRefKind> {\n-    let name_range = name_ref.syntax().range();\n-    let top_node = name_ref\n-        .syntax()\n-        .ancestors()\n-        .take_while(|it| it.range() == name_range)\n-        .last()\n-        .unwrap();\n-    match top_node.parent().map(|it| it.kind()) {\n-        Some(SOURCE_FILE) | Some(ITEM_LIST) => return Some(NameRefKind::BareIdentInMod),\n-        _ => (),\n-    }\n-\n-    let parent = name_ref.syntax().parent()?;\n-    if let Some(segment) = ast::PathSegment::cast(parent) {\n-        let path = segment.parent_path();\n-        if let Some(path) = Path::from_ast(path) {\n-            if !path.is_ident() {\n-                return Some(NameRefKind::Path(path));\n-            }\n-        }\n-        if path.qualifier().is_none() {\n-            let enclosing_fn = name_ref\n-                .syntax()\n-                .ancestors()\n-                .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n-                .find_map(ast::FnDef::cast);\n-            return Some(NameRefKind::LocalRef { enclosing_fn });\n-        }\n-    }\n-    None\n-}\n-\n-fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Completions) {\n-    let mut shadowed = FxHashSet::default();\n-    scopes\n-        .scope_chain(name_ref.syntax())\n-        .flat_map(|scope| scopes.entries(scope).iter())\n-        .filter(|entry| shadowed.insert(entry.name()))\n-        .for_each(|entry| {\n-            CompletionItem::new(entry.name().to_string())\n-                .kind(Reference)\n-                .add_to(acc)\n-        });\n-    if scopes.self_param.is_some() {\n-        CompletionItem::new(\"self\").kind(Reference).add_to(acc);\n-    }\n-}\n-\n-fn complete_path(\n-    acc: &mut Completions,\n-    db: &RootDatabase,\n-    module: &hir::Module,\n-    mut path: Path,\n-) -> Cancelable<()> {\n-    if path.segments.is_empty() {\n-        return Ok(());\n-    }\n-    path.segments.pop();\n-    let def_id = match module.resolve_path(db, path)? {\n-        None => return Ok(()),\n-        Some(it) => it,\n-    };\n-    let target_module = match def_id.resolve(db)? {\n-        Def::Module(it) => it,\n-        _ => return Ok(()),\n-    };\n-    let module_scope = target_module.scope(db)?;\n-    module_scope.entries().for_each(|(name, _res)| {\n-        CompletionItem::new(name.to_string())\n-            .kind(Reference)\n-            .add_to(acc)\n-    });\n-    Ok(())\n-}\n-\n-fn complete_mod_item_snippets(acc: &mut Completions) {\n-    CompletionItem::new(\"Test function\")\n-        .lookup_by(\"tfn\")\n-        .snippet(\n-            \"\\\n-#[test]\n-fn ${1:feature}() {\n-    $0\n-}\",\n-        )\n-        .kind(Snippet)\n-        .add_to(acc);\n-    CompletionItem::new(\"pub(crate)\")\n-        .snippet(\"pub(crate) $0\")\n-        .kind(Snippet)\n-        .add_to(acc);\n-}\n-\n-fn complete_expr_keywords(\n-    file: &SourceFileNode,\n-    fn_def: ast::FnDef,\n-    name_ref: ast::NameRef,\n-    acc: &mut Completions,\n-) {\n-    acc.add(keyword(\"if\", \"if $0 {}\"));\n-    acc.add(keyword(\"match\", \"match $0 {}\"));\n-    acc.add(keyword(\"while\", \"while $0 {}\"));\n-    acc.add(keyword(\"loop\", \"loop {$0}\"));\n-\n-    if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n-        if let Some(if_expr) = find_node_at_offset::<ast::IfExpr>(file.syntax(), off) {\n-            if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n-                acc.add(keyword(\"else\", \"else {$0}\"));\n-                acc.add(keyword(\"else if\", \"else if $0 {}\"));\n-            }\n-        }\n-    }\n-    if is_in_loop_body(name_ref) {\n-        acc.add(keyword(\"continue\", \"continue\"));\n-        acc.add(keyword(\"break\", \"break\"));\n-    }\n-    acc.add_all(complete_return(fn_def, name_ref));\n-}\n-\n-fn is_in_loop_body(name_ref: ast::NameRef) -> bool {\n-    for node in name_ref.syntax().ancestors() {\n-        if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n-            break;\n-        }\n-        let loop_body = visitor()\n-            .visit::<ast::ForExpr, _>(LoopBodyOwner::loop_body)\n-            .visit::<ast::WhileExpr, _>(LoopBodyOwner::loop_body)\n-            .visit::<ast::LoopExpr, _>(LoopBodyOwner::loop_body)\n-            .accept(node);\n-        if let Some(Some(body)) = loop_body {\n-            if name_ref\n-                .syntax()\n-                .range()\n-                .is_subrange(&body.syntax().range())\n-            {\n-                return true;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n-fn complete_return(fn_def: ast::FnDef, name_ref: ast::NameRef) -> Option<CompletionItem> {\n-    // let is_last_in_block = name_ref.syntax().ancestors().filter_map(ast::Expr::cast)\n-    //     .next()\n-    //     .and_then(|it| it.syntax().parent())\n-    //     .and_then(ast::Block::cast)\n-    //     .is_some();\n-\n-    // if is_last_in_block {\n-    //     return None;\n-    // }\n-\n-    let is_stmt = match name_ref\n-        .syntax()\n-        .ancestors()\n-        .filter_map(ast::ExprStmt::cast)\n-        .next()\n-    {\n-        None => false,\n-        Some(expr_stmt) => expr_stmt.syntax().range() == name_ref.syntax().range(),\n-    };\n-    let snip = match (is_stmt, fn_def.ret_type().is_some()) {\n-        (true, true) => \"return $0;\",\n-        (true, false) => \"return;\",\n-        (false, true) => \"return $0\",\n-        (false, false) => \"return\",\n-    };\n-    Some(keyword(\"return\", snip))\n-}\n-\n-fn keyword(kw: &str, snippet: &str) -> CompletionItem {\n-    CompletionItem::new(kw)\n-        .kind(Keyword)\n-        .snippet(snippet)\n-        .build()\n-}\n-\n-fn complete_expr_snippets(acc: &mut Completions) {\n-    CompletionItem::new(\"pd\")\n-        .snippet(\"eprintln!(\\\"$0 = {:?}\\\", $0);\")\n-        .kind(Snippet)\n-        .add_to(acc);\n-    CompletionItem::new(\"ppd\")\n-        .snippet(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\")\n-        .kind(Snippet)\n-        .add_to(acc);\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::completion::{CompletionKind, check_completion};\n-\n-    fn check_reference_completion(code: &str, expected_completions: &str) {\n-        check_completion(code, expected_completions, CompletionKind::Reference);\n-    }\n-\n-    fn check_keyword_completion(code: &str, expected_completions: &str) {\n-        check_completion(code, expected_completions, CompletionKind::Keyword);\n-    }\n-\n-    fn check_snippet_completion(code: &str, expected_completions: &str) {\n-        check_completion(code, expected_completions, CompletionKind::Snippet);\n-    }\n-\n-    #[test]\n-    fn test_completion_let_scope() {\n-        check_reference_completion(\n-            r\"\n-            fn quux(x: i32) {\n-                let y = 92;\n-                1 + <|>;\n-                let z = ();\n-            }\n-            \",\n-            \"y;x;quux\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_if_let_scope() {\n-        check_reference_completion(\n-            r\"\n-            fn quux() {\n-                if let Some(x) = foo() {\n-                    let y = 92;\n-                };\n-                if let Some(a) = bar() {\n-                    let b = 62;\n-                    1 + <|>\n-                }\n-            }\n-            \",\n-            \"b;a;quux\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_for_scope() {\n-        check_reference_completion(\n-            r\"\n-            fn quux() {\n-                for x in &[1, 2, 3] {\n-                    <|>\n-                }\n-            }\n-            \",\n-            \"x;quux\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope() {\n-        check_reference_completion(\n-            r\"\n-            struct Foo;\n-            enum Baz {}\n-            fn quux() {\n-                <|>\n-            }\n-            \",\n-            \"quux;Foo;Baz\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope_no_self_use() {\n-        check_reference_completion(\n-            r\"\n-            use foo<|>;\n-            \",\n-            \"\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_self_path() {\n-        check_reference_completion(\n-            r\"\n-            use self::m::<|>;\n-\n-            mod m {\n-                struct Bar;\n-            }\n-            \",\n-            \"Bar\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope_nested() {\n-        check_reference_completion(\n-            r\"\n-            struct Foo;\n-            mod m {\n-                struct Bar;\n-                fn quux() { <|> }\n-            }\n-            \",\n-            \"quux;Bar\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_complete_type() {\n-        check_reference_completion(\n-            r\"\n-            struct Foo;\n-            fn x() -> <|>\n-            \",\n-            \"Foo;x\",\n-        )\n-    }\n-\n-    #[test]\n-    fn test_complete_shadowing() {\n-        check_reference_completion(\n-            r\"\n-            fn foo() -> {\n-                let bar = 92;\n-                {\n-                    let bar = 62;\n-                    <|>\n-                }\n-            }\n-            \",\n-            \"bar;foo\",\n-        )\n-    }\n-\n-    #[test]\n-    fn test_complete_self() {\n-        check_reference_completion(r\"impl S { fn foo(&self) { <|> } }\", \"self\")\n-    }\n-\n-    #[test]\n-    fn test_complete_crate_path() {\n-        check_reference_completion(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-            struct Spam;\n-            //- /foo.rs\n-            use crate::Sp<|>\n-            \",\n-            \"Spam;foo\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_complete_crate_path_with_braces() {\n-        check_reference_completion(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-            struct Spam;\n-            //- /foo.rs\n-            use crate::{Sp<|>};\n-            \",\n-            \"Spam;foo\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_complete_crate_path_in_nested_tree() {\n-        check_reference_completion(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-            pub mod bar {\n-                pub mod baz {\n-                    pub struct Spam;\n-                }\n-            }\n-            //- /foo.rs\n-            use crate::{bar::{baz::Sp<|>}};\n-            \",\n-            \"Spam\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_kewords() {\n-        check_keyword_completion(\n-            r\"\n-            fn quux() {\n-                <|>\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return\"\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_else() {\n-        check_keyword_completion(\n-            r\"\n-            fn quux() {\n-                if true {\n-                    ()\n-                } <|>\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            else \"else {$0}\"\n-            else if \"else if $0 {}\"\n-            return \"return\"\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_return_value() {\n-        check_keyword_completion(\n-            r\"\n-            fn quux() -> i32 {\n-                <|>\n-                92\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return $0;\"\n-            \"#,\n-        );\n-        check_keyword_completion(\n-            r\"\n-            fn quux() {\n-                <|>\n-                92\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return;\"\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_return_no_stmt() {\n-        check_keyword_completion(\n-            r\"\n-            fn quux() -> i32 {\n-                match () {\n-                    () => <|>\n-                }\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return $0\"\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_continue_break_completion() {\n-        check_keyword_completion(\n-            r\"\n-            fn quux() -> i32 {\n-                loop { <|> }\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            continue \"continue\"\n-            break \"break\"\n-            return \"return $0\"\n-            \"#,\n-        );\n-        check_keyword_completion(\n-            r\"\n-            fn quux() -> i32 {\n-                loop { || { <|> } }\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return $0\"\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_snippets_in_expressions() {\n-        check_snippet_completion(\n-            r\"fn foo(x: i32) { <|> }\",\n-            r##\"\n-            pd \"eprintln!(\\\"$0 = {:?}\\\", $0);\"\n-            ppd \"eprintln!(\\\"$0 = {:#?}\\\", $0);\"\n-            \"##,\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_snippets_in_items() {\n-        // check_snippet_completion(r\"\n-        //     <|>\n-        //     \",\n-        //     r##\"[CompletionItem { label: \"Test function\", lookup: None, snippet: Some(\"#[test]\\nfn test_${1:feature}() {\\n$0\\n}\"##,\n-        // );\n-        check_snippet_completion(\n-            r\"\n-            #[cfg(test)]\n-            mod tests {\n-                <|>\n-            }\n-            \",\n-            r##\"\n-            tfn \"Test function\" \"#[test]\\nfn ${1:feature}() {\\n    $0\\n}\"\n-            pub(crate) \"pub(crate) $0\"\n-            \"##,\n-        );\n-    }\n-\n-}"}, {"sha": "9f1aa1ef2d876fc3e0c589a1c3cdda18e9a6b9a1", "filename": "crates/ra_hir/src/function/scope.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/184665ff9b7b64730ecf481c1914a74e7191a6dd/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/184665ff9b7b64730ecf481c1914a74e7191a6dd/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs?ref=184665ff9b7b64730ecf481c1914a74e7191a6dd", "patch": "@@ -1,7 +1,7 @@\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use ra_syntax::{\n-    AstNode, SmolStr, SyntaxNodeRef, TextRange,\n+    AstNode, SmolStr, SyntaxNodeRef, TextUnit, TextRange,\n     algo::generate,\n     ast::{self, ArgListOwner, LoopBodyOwner, NameOwner},\n };\n@@ -57,6 +57,48 @@ impl FnScopes {\n             self.scopes[scope].parent\n         })\n     }\n+    pub fn scope_chain_for_offset<'a>(\n+        &'a self,\n+        offset: TextUnit,\n+    ) -> impl Iterator<Item = ScopeId> + 'a {\n+        let scope = self\n+            .scope_for\n+            .iter()\n+            // find containin scope\n+            .min_by_key(|(ptr, _scope)| {\n+                (\n+                    !(ptr.range().start() <= offset && offset <= ptr.range().end()),\n+                    ptr.range().len(),\n+                )\n+            })\n+            .map(|(ptr, scope)| self.adjust(*ptr, *scope, offset));\n+\n+        generate(scope, move |&scope| self.scopes[scope].parent)\n+    }\n+    // XXX: during completion, cursor might be outside of any particular\n+    // expression. Try to figure out the correct scope...\n+    fn adjust(&self, ptr: LocalSyntaxPtr, original_scope: ScopeId, offset: TextUnit) -> ScopeId {\n+        let r = ptr.range();\n+        let child_scopes = self\n+            .scope_for\n+            .iter()\n+            .map(|(ptr, scope)| (ptr.range(), scope))\n+            .filter(|(range, _)| range.start() <= offset && range.is_subrange(&r) && *range != r);\n+\n+        child_scopes\n+            .max_by(|(r1, _), (r2, _)| {\n+                if r2.is_subrange(&r1) {\n+                    std::cmp::Ordering::Greater\n+                } else if r1.is_subrange(&r2) {\n+                    std::cmp::Ordering::Less\n+                } else {\n+                    r1.start().cmp(&r2.start())\n+                }\n+            })\n+            .map(|(ptr, scope)| *scope)\n+            .unwrap_or(original_scope)\n+    }\n+\n     pub fn resolve_local_name<'a>(&'a self, name_ref: ast::NameRef) -> Option<&'a ScopeEntry> {\n         let mut shadowed = FxHashSet::default();\n         let ret = self\n@@ -144,6 +186,8 @@ impl ScopeEntry {\n }\n \n fn compute_block_scopes(block: ast::Block, scopes: &mut FnScopes, mut scope: ScopeId) {\n+    // A hack for completion :(\n+    scopes.set_scope(block.syntax(), scope);\n     for stmt in block.statements() {\n         match stmt {\n             ast::Stmt::LetStmt(stmt) => {\n@@ -165,6 +209,7 @@ fn compute_block_scopes(block: ast::Block, scopes: &mut FnScopes, mut scope: Sco\n         }\n     }\n     if let Some(expr) = block.expr() {\n+        eprintln!(\"{:?}\", expr);\n         scopes.set_scope(expr.syntax(), scope);\n         compute_expr_scopes(expr, scopes, scope);\n     }"}]}