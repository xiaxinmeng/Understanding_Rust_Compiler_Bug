{"sha": "a23273e82c8156974553e43f7d61826651397fbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMzI3M2U4MmM4MTU2OTc0NTUzZTQzZjdkNjE4MjY2NTEzOTdmYmM=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-02-18T02:30:39Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-03-22T16:39:54Z"}, "message": "Add `debug-refcell` feature to libcore\n\nSee https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/Attaching.20backtraces.20to.20RefCell/near/226273614\nfor some background discussion\n\nThis PR adds a new off-by-default feature `debug-refcell` to libcore.\nWhen enabled, this feature stores additional debugging information in\n`RefCell`. This information is included in the panic message when\n`borrow()` or `borrow_mut()` panics, to make it easier to track down the\nsource of the issue.\n\nCurrently, we store the caller location for the earliest active borrow.\nThis has a number of advantages:\n* There is only a constant amount of overhead per `RefCell`\n* We don't need any heap memory, so it can easily be implemented in core\n* Since we are storing the *earliest* active borrow, we don't need any\n  extra logic in the `Drop` implementation for `Ref` and `RefMut`\n\nLimitations:\n* We only store the caller location, not a full `Backtrace`. Until\n  we get support for `Backtrace` in libcore, this is the best tha we can\ndo.\n* The captured location is only displayed when `borrow()` or\n  `borrow_mut()` panics. If a crate calls `try_borrow().unwrap()`\n  or `try_borrow_mut().unwrap()`, this extra information will be lost.\n\nTo make testing easier, I've enabled the `debug-refcell` feature by\ndefault. I'm not sure how to write a test for this feature - we would\nneed to rebuild core from the test framework, and create a separate\nsysroot.\n\nSince this feature will be off-by-default, users will need to use\n`xargo` or `cargo -Z build-std` to enable this feature. For users using\na prebuilt standard library, this feature will be disabled with zero\noverhead.\n\nI've created a simple test program:\n\n```rust\nuse std::cell::RefCell;\n\nfn main() {\n    let _ = std::panic::catch_unwind(|| {\n        let val = RefCell::new(true);\n        let _first = val.borrow();\n        let _second = val.borrow();\n        let _third = val.borrow_mut();\n    });\n\n    let _ = std::panic::catch_unwind(|| {\n        let val  = RefCell::new(true);\n        let first = val.borrow_mut();\n        drop(first);\n\n        let _second = val.borrow_mut();\n\n        let _thid = val.borrow();\n    });\n}\n```\n\nwhich produces the following output:\n\n```\nthread 'main' panicked at 'already borrowed: BorrowMutError { location: Location { file: \"refcell_test.rs\", line: 6, col: 26 } }', refcell_test.rs:8:26\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nthread 'main' panicked at 'already mutably borrowed: BorrowError { location: Location { file: \"refcell_test.rs\", line: 16, col: 27 } }', refcell_test.rs:18:25\n```", "tree": {"sha": "46a1ef0df692984d3330327ff7b2dbb112ac0344", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46a1ef0df692984d3330327ff7b2dbb112ac0344"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a23273e82c8156974553e43f7d61826651397fbc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmBYyFsACgkQtAh+UQ6Y\nsWQBcxAAuHcjNhqIdqw1Cd93khcPXO3ztPhdYTcvEVz2zkrmEP3q2jHu0lPSjjVK\nlZ/4nckhVl0lKfSNaHCAT7got+qAumad1iIZ9Eu/ZSxj+NQVJP3EIndUA2dPFkSM\nP0nc37USOktXrls6WacjJeZyxdYM/3sxvZoW/SZKkSv9Wyf810AjinKIPt082rZE\n6YZArpJP8trO6//2VT0gucxpngZkU/UAflHkV2MO9ieSZ7XVwRc53D9iUyZv37C+\nHKOHtisM32G2nyQfCysif/CqLdJMHurqOo9D3rN/BhiYOo7s4LVLu+AZ2iCTVWF3\nBPCJyqB3iDPAoelWawnLWVj9TTwopDyKd/wHblH7iDSsqKxjoWmBaTmWzG3hJwan\nXI8TCrJkdttaAfpqy4nd2NVqkZTvqe7ozpmT44bq2DeMeb2byI7zsE1412aTm9y+\n1efKQhKNRgAtMFHI3oZPLDw0yIitMHT/zQKMszJmQZ/XBwSLq1r2QaP9okUKx6LN\nxREMXoNGBF8sxdF1fNNM63wNYJFaw/MHvfiN8BRc72vhSFkBEwACDge2OCH+nREc\neJnZEHH9kbdjen/HR8/9U5iIIgIEBNTEBEiC/hZ7bobjTU81/HjPPzjfRLAPnDsm\nfX2adjLhAQREm4cjaVFxEWYib2EuUUAlTMHF6fPfImKsx0L36o0=\n=IOI0\n-----END PGP SIGNATURE-----", "payload": "tree 46a1ef0df692984d3330327ff7b2dbb112ac0344\nparent d04c3aa8656f6588c87bafafb34d51239dab98bb\nauthor Aaron Hill <aa1ronham@gmail.com> 1613615439 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1616431194 -0400\n\nAdd `debug-refcell` feature to libcore\n\nSee https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/Attaching.20backtraces.20to.20RefCell/near/226273614\nfor some background discussion\n\nThis PR adds a new off-by-default feature `debug-refcell` to libcore.\nWhen enabled, this feature stores additional debugging information in\n`RefCell`. This information is included in the panic message when\n`borrow()` or `borrow_mut()` panics, to make it easier to track down the\nsource of the issue.\n\nCurrently, we store the caller location for the earliest active borrow.\nThis has a number of advantages:\n* There is only a constant amount of overhead per `RefCell`\n* We don't need any heap memory, so it can easily be implemented in core\n* Since we are storing the *earliest* active borrow, we don't need any\n  extra logic in the `Drop` implementation for `Ref` and `RefMut`\n\nLimitations:\n* We only store the caller location, not a full `Backtrace`. Until\n  we get support for `Backtrace` in libcore, this is the best tha we can\ndo.\n* The captured location is only displayed when `borrow()` or\n  `borrow_mut()` panics. If a crate calls `try_borrow().unwrap()`\n  or `try_borrow_mut().unwrap()`, this extra information will be lost.\n\nTo make testing easier, I've enabled the `debug-refcell` feature by\ndefault. I'm not sure how to write a test for this feature - we would\nneed to rebuild core from the test framework, and create a separate\nsysroot.\n\nSince this feature will be off-by-default, users will need to use\n`xargo` or `cargo -Z build-std` to enable this feature. For users using\na prebuilt standard library, this feature will be disabled with zero\noverhead.\n\nI've created a simple test program:\n\n```rust\nuse std::cell::RefCell;\n\nfn main() {\n    let _ = std::panic::catch_unwind(|| {\n        let val = RefCell::new(true);\n        let _first = val.borrow();\n        let _second = val.borrow();\n        let _third = val.borrow_mut();\n    });\n\n    let _ = std::panic::catch_unwind(|| {\n        let val  = RefCell::new(true);\n        let first = val.borrow_mut();\n        drop(first);\n\n        let _second = val.borrow_mut();\n\n        let _thid = val.borrow();\n    });\n}\n```\n\nwhich produces the following output:\n\n```\nthread 'main' panicked at 'already borrowed: BorrowMutError { location: Location { file: \"refcell_test.rs\", line: 6, col: 26 } }', refcell_test.rs:8:26\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nthread 'main' panicked at 'already mutably borrowed: BorrowError { location: Location { file: \"refcell_test.rs\", line: 16, col: 27 } }', refcell_test.rs:18:25\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a23273e82c8156974553e43f7d61826651397fbc", "html_url": "https://github.com/rust-lang/rust/commit/a23273e82c8156974553e43f7d61826651397fbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a23273e82c8156974553e43f7d61826651397fbc/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d04c3aa8656f6588c87bafafb34d51239dab98bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d04c3aa8656f6588c87bafafb34d51239dab98bb", "html_url": "https://github.com/rust-lang/rust/commit/d04c3aa8656f6588c87bafafb34d51239dab98bb"}], "stats": {"total": 87, "additions": 76, "deletions": 11}, "files": [{"sha": "7eb1a397337cb8e9b222303cc7d2665a4d8e72ff", "filename": "library/core/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a23273e82c8156974553e43f7d61826651397fbc/library%2Fcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a23273e82c8156974553e43f7d61826651397fbc/library%2Fcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2FCargo.toml?ref=a23273e82c8156974553e43f7d61826651397fbc", "patch": "@@ -25,3 +25,6 @@ rand = \"0.7\"\n [features]\n # Make panics and failed asserts immediately abort without formatting any message\n panic_immediate_abort = []\n+# Make `RefCell` store additional debugging information, which is printed out when\n+# a borrow error occurs\n+debug_refcell = []"}, {"sha": "770169219aad2470d9f67000bd575084fc3d1aad", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 73, "deletions": 11, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a23273e82c8156974553e43f7d61826651397fbc/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a23273e82c8156974553e43f7d61826651397fbc/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=a23273e82c8156974553e43f7d61826651397fbc", "patch": "@@ -575,19 +575,32 @@ impl<T> Cell<[T]> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefCell<T: ?Sized> {\n     borrow: Cell<BorrowFlag>,\n+    // Stores the location of the earliest currently active borrow.\n+    // This gets updated whenver we go from having zero borrows\n+    // to having a single borrow. When a borrow occurs, this gets included\n+    // in the generated `BorroeError/`BorrowMutError`\n+    #[cfg(feature = \"debug_refcell\")]\n+    borrowed_at: Cell<Option<&'static crate::panic::Location<'static>>>,\n     value: UnsafeCell<T>,\n }\n \n /// An error returned by [`RefCell::try_borrow`].\n #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n pub struct BorrowError {\n     _private: (),\n+    #[cfg(feature = \"debug_refcell\")]\n+    location: &'static crate::panic::Location<'static>,\n }\n \n #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n impl Debug for BorrowError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"BorrowError\").finish()\n+        let mut builder = f.debug_struct(\"BorrowError\");\n+\n+        #[cfg(feature = \"debug_refcell\")]\n+        builder.field(\"location\", self.location);\n+\n+        builder.finish()\n     }\n }\n \n@@ -602,12 +615,19 @@ impl Display for BorrowError {\n #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n pub struct BorrowMutError {\n     _private: (),\n+    #[cfg(feature = \"debug_refcell\")]\n+    location: &'static crate::panic::Location<'static>,\n }\n \n #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n impl Debug for BorrowMutError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"BorrowMutError\").finish()\n+        let mut builder = f.debug_struct(\"BorrowMutError\");\n+\n+        #[cfg(feature = \"debug_refcell\")]\n+        builder.field(\"location\", self.location);\n+\n+        builder.finish()\n     }\n }\n \n@@ -658,7 +678,12 @@ impl<T> RefCell<T> {\n     #[rustc_const_stable(feature = \"const_refcell_new\", since = \"1.24.0\")]\n     #[inline]\n     pub const fn new(value: T) -> RefCell<T> {\n-        RefCell { value: UnsafeCell::new(value), borrow: Cell::new(UNUSED) }\n+        RefCell {\n+            value: UnsafeCell::new(value),\n+            borrow: Cell::new(UNUSED),\n+            #[cfg(feature = \"debug_refcell\")]\n+            borrowed_at: Cell::new(None),\n+        }\n     }\n \n     /// Consumes the `RefCell`, returning the wrapped value.\n@@ -823,12 +848,29 @@ impl<T: ?Sized> RefCell<T> {\n     /// ```\n     #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n     #[inline]\n+    #[cfg_attr(feature = \"debug_refcell\", track_caller)]\n     pub fn try_borrow(&self) -> Result<Ref<'_, T>, BorrowError> {\n         match BorrowRef::new(&self.borrow) {\n-            // SAFETY: `BorrowRef` ensures that there is only immutable access\n-            // to the value while borrowed.\n-            Some(b) => Ok(Ref { value: unsafe { &*self.value.get() }, borrow: b }),\n-            None => Err(BorrowError { _private: () }),\n+            Some(b) => {\n+                #[cfg(feature = \"debug_refcell\")]\n+                {\n+                    // `borrowed_at` is always the *first* active borrow\n+                    if b.borrow.get() == 1 {\n+                        self.borrowed_at.set(Some(crate::panic::Location::caller()));\n+                    }\n+                }\n+\n+                // SAFETY: `BorrowRef` ensures that there is only immutable access\n+                // to the value while borrowed.\n+                Ok(Ref { value: unsafe { &*self.value.get() }, borrow: b })\n+            }\n+            None => Err(BorrowError {\n+                _private: (),\n+                // If a borrow occured, then we must already have an outstanding borrow,\n+                // so `borrowed_at` will be `Some`\n+                #[cfg(feature = \"debug_refcell\")]\n+                location: self.borrowed_at.get().unwrap(),\n+            }),\n         }\n     }\n \n@@ -896,11 +938,25 @@ impl<T: ?Sized> RefCell<T> {\n     /// ```\n     #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n     #[inline]\n+    #[cfg_attr(feature = \"debug_refcell\", track_caller)]\n     pub fn try_borrow_mut(&self) -> Result<RefMut<'_, T>, BorrowMutError> {\n         match BorrowRefMut::new(&self.borrow) {\n-            // SAFETY: `BorrowRef` guarantees unique access.\n-            Some(b) => Ok(RefMut { value: unsafe { &mut *self.value.get() }, borrow: b }),\n-            None => Err(BorrowMutError { _private: () }),\n+            Some(b) => {\n+                #[cfg(feature = \"debug_refcell\")]\n+                {\n+                    self.borrowed_at.set(Some(crate::panic::Location::caller()));\n+                }\n+\n+                // SAFETY: `BorrowRef` guarantees unique access.\n+                Ok(RefMut { value: unsafe { &mut *self.value.get() }, borrow: b })\n+            }\n+            None => Err(BorrowMutError {\n+                _private: (),\n+                // If a borrow occured, then we must already have an outstanding borrow,\n+                // so `borrowed_at` will be `Some`\n+                #[cfg(feature = \"debug_refcell\")]\n+                location: self.borrowed_at.get().unwrap(),\n+            }),\n         }\n     }\n \n@@ -1016,7 +1072,13 @@ impl<T: ?Sized> RefCell<T> {\n             // and is thus guaranteed to be valid for the lifetime of `self`.\n             Ok(unsafe { &*self.value.get() })\n         } else {\n-            Err(BorrowError { _private: () })\n+            Err(BorrowError {\n+                _private: (),\n+                // If a borrow occured, then we must already have an outstanding borrow,\n+                // so `borrowed_at` will be `Some`\n+                #[cfg(feature = \"debug_refcell\")]\n+                location: self.borrowed_at.get().unwrap(),\n+            })\n         }\n     }\n }"}]}