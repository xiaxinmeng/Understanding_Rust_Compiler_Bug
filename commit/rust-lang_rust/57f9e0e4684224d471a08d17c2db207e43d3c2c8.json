{"sha": "57f9e0e4684224d471a08d17c2db207e43d3c2c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZjllMGU0Njg0MjI0ZDQ3MWEwOGQxN2MyZGIyMDdlNDNkM2MyYzg=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2018-01-26T14:31:39Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-08T07:34:11Z"}, "message": "Move lit_to_const to `pattern` and remove the now-empty `eval` module", "tree": {"sha": "ed0ad38ac98ceac003f26df7e566fb3a06e5128b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed0ad38ac98ceac003f26df7e566fb3a06e5128b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57f9e0e4684224d471a08d17c2db207e43d3c2c8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqg53MACgkQpp+NIls6\n19krKw/8DC2uzBVVN8Unj7YSfkE4+xfYC8pBNjGMe+1sPtbCRIcEbreg+jiIxFBv\n9khmwVadPnOvmpeShvdy/VTcCyRPoLF9NwNSYKQRCUztbdxT/PiGZl+b+MwWlLEE\nve0Y3IN+UVRmteFUtQWTcda9TZFlBG3JyOJwyWxIFGe3WjPcUT6B4EvyPkyKpdrc\nm64QLG6UszbLT6PxnxsRpxMawjs9I1sEDnjPthn+M288CwgpEh76V7cqlw73y1do\nnhr/tq7H2KrGVzBq3wt+fmsC9xJTrjSIdkPEaCli8GkfmXIwZLVSoRs+hleXxPS5\nt8zMszZjy8KUgmG/dIHDQmZKr/lyUZ7aOozbI2oDxa9224Gh0/3SIgPPyKwbfgUB\nWdWUSBV2fvK1Ev3X3/E1P/JYHvvsEiIriQhLOHjP+K/BysLUeAHWjzvEVl0iFRmi\nffPVuKYebV/ZBsPusVYxmZ2qsiW2RY3jVLAxVh5k5R0tWEjzn9XNiFGd0PqHJAja\nX9hFVOsiYnIzBEXkaJgktd0W4azFtVQIBjHOEviI0I0nBbnSLzBuzgAmEZnF835l\nGs5yHJaTxT+kOoEJa/JHq6tmOjcuTr1Cj52Pfn2A4QwoMSLCXb2oQ/ETuwn2opkB\n7vxRgOTv0N2dEXjp7ZzGn8hgXNcmG28mj1RpNqepeOa7NHRf4oc=\n=pFoN\n-----END PGP SIGNATURE-----", "payload": "tree ed0ad38ac98ceac003f26df7e566fb3a06e5128b\nparent b38e8af5eb038d3afd4aebc0dd0f0b64b646aee0\nauthor Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1516977099 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520494451 +0100\n\nMove lit_to_const to `pattern` and remove the now-empty `eval` module\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57f9e0e4684224d471a08d17c2db207e43d3c2c8", "html_url": "https://github.com/rust-lang/rust/commit/57f9e0e4684224d471a08d17c2db207e43d3c2c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57f9e0e4684224d471a08d17c2db207e43d3c2c8/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b38e8af5eb038d3afd4aebc0dd0f0b64b646aee0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b38e8af5eb038d3afd4aebc0dd0f0b64b646aee0", "html_url": "https://github.com/rust-lang/rust/commit/b38e8af5eb038d3afd4aebc0dd0f0b64b646aee0"}], "stats": {"total": 217, "additions": 98, "deletions": 119}, "files": [{"sha": "29c0cd499b3aa838193887bc6fc32a553e108957", "filename": "src/librustc_mir/const_eval/eval.rs", "status": "removed", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/b38e8af5eb038d3afd4aebc0dd0f0b64b646aee0/src%2Flibrustc_mir%2Fconst_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38e8af5eb038d3afd4aebc0dd0f0b64b646aee0/src%2Flibrustc_mir%2Fconst_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval.rs?ref=b38e8af5eb038d3afd4aebc0dd0f0b64b646aee0", "patch": "@@ -1,114 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::middle::const_val::ConstVal;\n-\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::subst::Substs;\n-\n-use syntax::ast;\n-\n-use rustc_const_math::*;\n-\n-pub fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          ty: Ty<'tcx>,\n-                          neg: bool)\n-                          -> Result<ConstVal<'tcx>, ()> {\n-    use syntax::ast::*;\n-\n-    use rustc::mir::interpret::*;\n-    let lit = match *lit {\n-        LitKind::Str(ref s, _) => {\n-            let s = s.as_str();\n-            let id = tcx.allocate_cached(s.as_bytes());\n-            let ptr = MemoryPointer::new(id, 0);\n-            Value::ByValPair(\n-                PrimVal::Ptr(ptr),\n-                PrimVal::from_u128(s.len() as u128),\n-            )\n-        },\n-        LitKind::ByteStr(ref data) => {\n-            let id = tcx.allocate_cached(data);\n-            let ptr = MemoryPointer::new(id, 0);\n-            Value::ByVal(PrimVal::Ptr(ptr))\n-        },\n-        LitKind::Byte(n) => Value::ByVal(PrimVal::Bytes(n as u128)),\n-        LitKind::Int(n, _) => {\n-            enum Int {\n-                Signed(IntTy),\n-                Unsigned(UintTy),\n-            }\n-            let ty = match ty.sty {\n-                ty::TyInt(IntTy::Isize) => Int::Signed(tcx.sess.target.isize_ty),\n-                ty::TyInt(other) => Int::Signed(other),\n-                ty::TyUint(UintTy::Usize) => Int::Unsigned(tcx.sess.target.usize_ty),\n-                ty::TyUint(other) => Int::Unsigned(other),\n-                _ => bug!(),\n-            };\n-            let n = match ty {\n-                // FIXME(oli-obk): are these casts correct?\n-                Int::Signed(IntTy::I8) if neg =>\n-                    (n as i128 as i8).overflowing_neg().0 as i128 as u128,\n-                Int::Signed(IntTy::I16) if neg =>\n-                    (n as i128 as i16).overflowing_neg().0 as i128 as u128,\n-                Int::Signed(IntTy::I32) if neg =>\n-                    (n as i128 as i32).overflowing_neg().0 as i128 as u128,\n-                Int::Signed(IntTy::I64) if neg =>\n-                    (n as i128 as i64).overflowing_neg().0 as i128 as u128,\n-                Int::Signed(IntTy::I128) if neg =>\n-                    (n as i128).overflowing_neg().0 as u128,\n-                Int::Signed(IntTy::I8) => n as i128 as i8 as i128 as u128,\n-                Int::Signed(IntTy::I16) => n as i128 as i16 as i128 as u128,\n-                Int::Signed(IntTy::I32) => n as i128 as i32 as i128 as u128,\n-                Int::Signed(IntTy::I64) => n as i128 as i64 as i128 as u128,\n-                Int::Signed(IntTy::I128) => n,\n-                Int::Unsigned(UintTy::U8) => n as u8 as u128,\n-                Int::Unsigned(UintTy::U16) => n as u16 as u128,\n-                Int::Unsigned(UintTy::U32) => n as u32 as u128,\n-                Int::Unsigned(UintTy::U64) => n as u64 as u128,\n-                Int::Unsigned(UintTy::U128) => n,\n-                _ => bug!(),\n-            };\n-            Value::ByVal(PrimVal::Bytes(n))\n-        },\n-        LitKind::Float(n, fty) => {\n-            let n = n.as_str();\n-            let mut f = parse_float(&n, fty)?;\n-            if neg {\n-                f = -f;\n-            }\n-            let bits = f.bits;\n-            Value::ByVal(PrimVal::Bytes(bits))\n-        }\n-        LitKind::FloatUnsuffixed(n) => {\n-            let fty = match ty.sty {\n-                ty::TyFloat(fty) => fty,\n-                _ => bug!()\n-            };\n-            let n = n.as_str();\n-            let mut f = parse_float(&n, fty)?;\n-            if neg {\n-                f = -f;\n-            }\n-            let bits = f.bits;\n-            Value::ByVal(PrimVal::Bytes(bits))\n-        }\n-        LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n-        LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n-    };\n-    Ok(ConstVal::Value(lit))\n-}\n-\n-fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n-                     -> Result<ConstFloat, ()> {\n-    ConstFloat::from_str(num, fty).map_err(|_| ())\n-}"}, {"sha": "fff1122387f257ddea2a5aa2a98f08353b5e4400", "filename": "src/librustc_mir/const_eval/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57f9e0e4684224d471a08d17c2db207e43d3c2c8/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f9e0e4684224d471a08d17c2db207e43d3c2c8/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs?ref=57f9e0e4684224d471a08d17c2db207e43d3c2c8", "patch": "@@ -10,10 +10,7 @@\n \n //! constant evaluation on the HIR and code to validate patterns/matches\n \n-mod eval;\n mod _match;\n pub mod check_match;\n pub mod pattern;\n pub mod check;\n-\n-pub use self::eval::*;"}, {"sha": "2678984092a52b9cfe4e0a6f03964e29147dcee7", "filename": "src/librustc_mir/const_eval/pattern.rs", "status": "modified", "additions": 98, "deletions": 2, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/57f9e0e4684224d471a08d17c2db207e43d3c2c8/src%2Flibrustc_mir%2Fconst_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f9e0e4684224d471a08d17c2db207e43d3c2c8/src%2Flibrustc_mir%2Fconst_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fpattern.rs?ref=57f9e0e4684224d471a08d17c2db207e43d3c2c8", "patch": "@@ -20,6 +20,7 @@ use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n \n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_const_math::ConstFloat;\n \n use std::cmp::Ordering;\n use std::fmt;\n@@ -716,7 +717,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         match expr.node {\n             hir::ExprLit(ref lit) => {\n                 let ty = self.tables.expr_ty(expr);\n-                match super::eval::lit_to_const(&lit.node, self.tcx, ty, false) {\n+                match lit_to_const(&lit.node, self.tcx, ty, false) {\n                     Ok(val) => {\n                         let instance = ty::Instance::new(\n                             self.tables.local_id_root.expect(\"literal outside any scope\"),\n@@ -738,7 +739,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     hir::ExprLit(ref lit) => lit,\n                     _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n                 };\n-                match super::eval::lit_to_const(&lit.node, self.tcx, ty, true) {\n+                match lit_to_const(&lit.node, self.tcx, ty, true) {\n                     Ok(val) => {\n                         let instance = ty::Instance::new(\n                             self.tables.local_id_root.expect(\"literal outside any scope\"),\n@@ -1089,3 +1090,98 @@ pub fn compare_const_vals(a: &ConstVal, b: &ConstVal, ty: Ty) -> Option<Ordering\n         _ => None,\n     }\n }\n+\n+fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          ty: Ty<'tcx>,\n+                          neg: bool)\n+                          -> Result<ConstVal<'tcx>, ()> {\n+    use syntax::ast::*;\n+\n+    use rustc::mir::interpret::*;\n+    let lit = match *lit {\n+        LitKind::Str(ref s, _) => {\n+            let s = s.as_str();\n+            let id = tcx.allocate_cached(s.as_bytes());\n+            let ptr = MemoryPointer::new(id, 0);\n+            Value::ByValPair(\n+                PrimVal::Ptr(ptr),\n+                PrimVal::from_u128(s.len() as u128),\n+            )\n+        },\n+        LitKind::ByteStr(ref data) => {\n+            let id = tcx.allocate_cached(data);\n+            let ptr = MemoryPointer::new(id, 0);\n+            Value::ByVal(PrimVal::Ptr(ptr))\n+        },\n+        LitKind::Byte(n) => Value::ByVal(PrimVal::Bytes(n as u128)),\n+        LitKind::Int(n, _) => {\n+            enum Int {\n+                Signed(IntTy),\n+                Unsigned(UintTy),\n+            }\n+            let ty = match ty.sty {\n+                ty::TyInt(IntTy::Isize) => Int::Signed(tcx.sess.target.isize_ty),\n+                ty::TyInt(other) => Int::Signed(other),\n+                ty::TyUint(UintTy::Usize) => Int::Unsigned(tcx.sess.target.usize_ty),\n+                ty::TyUint(other) => Int::Unsigned(other),\n+                _ => bug!(),\n+            };\n+            let n = match ty {\n+                // FIXME(oli-obk): are these casts correct?\n+                Int::Signed(IntTy::I8) if neg =>\n+                    (n as i128 as i8).overflowing_neg().0 as i128 as u128,\n+                Int::Signed(IntTy::I16) if neg =>\n+                    (n as i128 as i16).overflowing_neg().0 as i128 as u128,\n+                Int::Signed(IntTy::I32) if neg =>\n+                    (n as i128 as i32).overflowing_neg().0 as i128 as u128,\n+                Int::Signed(IntTy::I64) if neg =>\n+                    (n as i128 as i64).overflowing_neg().0 as i128 as u128,\n+                Int::Signed(IntTy::I128) if neg =>\n+                    (n as i128).overflowing_neg().0 as u128,\n+                Int::Signed(IntTy::I8) => n as i128 as i8 as i128 as u128,\n+                Int::Signed(IntTy::I16) => n as i128 as i16 as i128 as u128,\n+                Int::Signed(IntTy::I32) => n as i128 as i32 as i128 as u128,\n+                Int::Signed(IntTy::I64) => n as i128 as i64 as i128 as u128,\n+                Int::Signed(IntTy::I128) => n,\n+                Int::Unsigned(UintTy::U8) => n as u8 as u128,\n+                Int::Unsigned(UintTy::U16) => n as u16 as u128,\n+                Int::Unsigned(UintTy::U32) => n as u32 as u128,\n+                Int::Unsigned(UintTy::U64) => n as u64 as u128,\n+                Int::Unsigned(UintTy::U128) => n,\n+                _ => bug!(),\n+            };\n+            Value::ByVal(PrimVal::Bytes(n))\n+        },\n+        LitKind::Float(n, fty) => {\n+            let n = n.as_str();\n+            let mut f = parse_float(&n, fty)?;\n+            if neg {\n+                f = -f;\n+            }\n+            let bits = f.bits;\n+            Value::ByVal(PrimVal::Bytes(bits))\n+        }\n+        LitKind::FloatUnsuffixed(n) => {\n+            let fty = match ty.sty {\n+                ty::TyFloat(fty) => fty,\n+                _ => bug!()\n+            };\n+            let n = n.as_str();\n+            let mut f = parse_float(&n, fty)?;\n+            if neg {\n+                f = -f;\n+            }\n+            let bits = f.bits;\n+            Value::ByVal(PrimVal::Bytes(bits))\n+        }\n+        LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n+        LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n+    };\n+    Ok(ConstVal::Value(lit))\n+}\n+\n+fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n+                     -> Result<ConstFloat, ()> {\n+    ConstFloat::from_str(num, fty).map_err(|_| ())\n+}"}]}