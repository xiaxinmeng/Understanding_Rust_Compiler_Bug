{"sha": "5ed3453af9db9c516e564e25ba9ee28056d48103", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlZDM0NTNhZjlkYjljNTE2ZTU2NGUyNWJhOWVlMjgwNTZkNDgxMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-14T02:04:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-14T02:04:49Z"}, "message": "Auto merge of #69716 - jonas-schievink:generator-size, r=tmandry\n\nDon't store locals in generators that are immediately overwritten with the resume argument\n\nThis fixes https://github.com/rust-lang/rust/issues/69672 and makes https://github.com/rust-lang/rust/pull/69033 pass the async fn size tests again (in other words, there will be no size regression of async fn if both this and https://github.com/rust-lang/rust/pull/69033 land).\n\n~~This is a small botch and I'd rather have a more precise analysis, but that seems much harder to pull off, so this special-cases `Yield` terminators that store the resume argument into a simple local (ie. without any field projections) and explicitly marks that local as \"not live\" in the suspend point of that yield. We know that this local does not need to be stored in the generator for this suspend point because the next resume would immediately overwrite it with the passed-in resume argument anyways. The local might still end up in the state if it is used across another yield.~~ (this now properly updates the dataflow framework to handle this case)", "tree": {"sha": "65db0063b1b17f28b7c2c553c13e87b1b27bb5aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65db0063b1b17f28b7c2c553c13e87b1b27bb5aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ed3453af9db9c516e564e25ba9ee28056d48103", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ed3453af9db9c516e564e25ba9ee28056d48103", "html_url": "https://github.com/rust-lang/rust/commit/5ed3453af9db9c516e564e25ba9ee28056d48103", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ed3453af9db9c516e564e25ba9ee28056d48103/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be055d96c4c223a5ad49a0181f0b43bc46781708", "url": "https://api.github.com/repos/rust-lang/rust/commits/be055d96c4c223a5ad49a0181f0b43bc46781708", "html_url": "https://github.com/rust-lang/rust/commit/be055d96c4c223a5ad49a0181f0b43bc46781708"}, {"sha": "b26e27c5f3e7f24982f90183630b3fcffc3f7b8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b26e27c5f3e7f24982f90183630b3fcffc3f7b8a", "html_url": "https://github.com/rust-lang/rust/commit/b26e27c5f3e7f24982f90183630b3fcffc3f7b8a"}], "stats": {"total": 151, "additions": 120, "deletions": 31}, "files": [{"sha": "170157aca5ddd678391efc9083286821b27898d8", "filename": "src/librustc_mir/dataflow/generic/cursor.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fcursor.rs?ref=5ed3453af9db9c516e564e25ba9ee28056d48103", "patch": "@@ -2,7 +2,7 @@\n \n use std::borrow::Borrow;\n \n-use rustc::mir::{self, BasicBlock, Location};\n+use rustc::mir::{self, BasicBlock, Location, TerminatorKind};\n use rustc_index::bit_set::BitSet;\n \n use super::{Analysis, Results};\n@@ -29,14 +29,14 @@ where\n \n     pos: CursorPosition,\n \n-    /// When this flag is set, the cursor is pointing at a `Call` terminator whose call return\n-    /// effect has been applied to `state`.\n+    /// When this flag is set, the cursor is pointing at a `Call` or `Yield` terminator whose call\n+    /// return or resume effect has been applied to `state`.\n     ///\n-    /// This flag helps to ensure that multiple calls to `seek_after_assume_call_returns` with the\n+    /// This flag helps to ensure that multiple calls to `seek_after_assume_success` with the\n     /// same target will result in exactly one invocation of `apply_call_return_effect`. It is\n     /// sufficient to clear this only in `seek_to_block_start`, since seeking away from a\n     /// terminator will always require a cursor reset.\n-    call_return_effect_applied: bool,\n+    success_effect_applied: bool,\n }\n \n impl<'mir, 'tcx, A, R> ResultsCursor<'mir, 'tcx, A, R>\n@@ -50,7 +50,7 @@ where\n             body,\n             pos: CursorPosition::BlockStart(mir::START_BLOCK),\n             state: results.borrow().entry_sets[mir::START_BLOCK].clone(),\n-            call_return_effect_applied: false,\n+            success_effect_applied: false,\n             results,\n         }\n     }\n@@ -76,14 +76,14 @@ where\n     pub fn seek_to_block_start(&mut self, block: BasicBlock) {\n         self.state.overwrite(&self.results.borrow().entry_sets[block]);\n         self.pos = CursorPosition::BlockStart(block);\n-        self.call_return_effect_applied = false;\n+        self.success_effect_applied = false;\n     }\n \n     /// Advances the cursor to hold all effects up to and including to the \"before\" effect of the\n     /// statement (or terminator) at the given location.\n     ///\n     /// If you wish to observe the full effect of a statement or terminator, not just the \"before\"\n-    /// effect, use `seek_after` or `seek_after_assume_call_returns`.\n+    /// effect, use `seek_after` or `seek_after_assume_success`.\n     pub fn seek_before(&mut self, target: Location) {\n         assert!(target <= self.body.terminator_loc(target.block));\n         self.seek_(target, false);\n@@ -93,15 +93,15 @@ where\n     /// terminators) up to and including the `target`.\n     ///\n     /// If the `target` is a `Call` terminator, any call return effect for that terminator will\n-    /// **not** be observed. Use `seek_after_assume_call_returns` if you wish to observe the call\n+    /// **not** be observed. Use `seek_after_assume_success` if you wish to observe the call\n     /// return effect.\n     pub fn seek_after(&mut self, target: Location) {\n         assert!(target <= self.body.terminator_loc(target.block));\n \n         // If we have already applied the call return effect, we are currently pointing at a `Call`\n         // terminator. Unconditionally reset the dataflow cursor, since there is no way to \"undo\"\n         // the call return effect.\n-        if self.call_return_effect_applied {\n+        if self.success_effect_applied {\n             self.seek_to_block_start(target.block);\n         }\n \n@@ -111,25 +111,25 @@ where\n     /// Advances the cursor to hold all effects up to and including of the statement (or\n     /// terminator) at the given location.\n     ///\n-    /// If the `target` is a `Call` terminator, any call return effect for that terminator will\n-    /// be observed. Use `seek_after` if you do **not** wish to observe the call return effect.\n-    pub fn seek_after_assume_call_returns(&mut self, target: Location) {\n+    /// If the `target` is a `Call` or `Yield` terminator, any call return or resume effect for that\n+    /// terminator will be observed. Use `seek_after` if you do **not** wish to observe the\n+    /// \"success\" effect.\n+    pub fn seek_after_assume_success(&mut self, target: Location) {\n         let terminator_loc = self.body.terminator_loc(target.block);\n         assert!(target.statement_index <= terminator_loc.statement_index);\n \n         self.seek_(target, true);\n \n-        if target != terminator_loc {\n+        if target != terminator_loc || self.success_effect_applied {\n             return;\n         }\n \n+        // Apply the effect of the \"success\" path of the terminator.\n+\n+        self.success_effect_applied = true;\n         let terminator = self.body.basic_blocks()[target.block].terminator();\n-        if let mir::TerminatorKind::Call {\n-            destination: Some((return_place, _)), func, args, ..\n-        } = &terminator.kind\n-        {\n-            if !self.call_return_effect_applied {\n-                self.call_return_effect_applied = true;\n+        match &terminator.kind {\n+            TerminatorKind::Call { destination: Some((return_place, _)), func, args, .. } => {\n                 self.results.borrow().analysis.apply_call_return_effect(\n                     &mut self.state,\n                     target.block,\n@@ -138,6 +138,14 @@ where\n                     return_place,\n                 );\n             }\n+            TerminatorKind::Yield { resume, resume_arg, .. } => {\n+                self.results.borrow().analysis.apply_yield_resume_effect(\n+                    &mut self.state,\n+                    *resume,\n+                    resume_arg,\n+                );\n+            }\n+            _ => {}\n         }\n     }\n \n@@ -172,7 +180,7 @@ where\n                 self.seek_to_block_start(target.block)\n             }\n \n-            // N.B., `call_return_effect_applied` is checked in `seek_after`, not here.\n+            // N.B., `success_effect_applied` is checked in `seek_after`, not here.\n             _ => (),\n         }\n "}, {"sha": "d32072125b3b9fcd101dfbc5bea2de536a0382e3", "filename": "src/librustc_mir/dataflow/generic/engine.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs?ref=5ed3453af9db9c516e564e25ba9ee28056d48103", "patch": "@@ -218,15 +218,18 @@ where\n \n             Goto { target }\n             | Assert { target, cleanup: None, .. }\n-            | Yield { resume: target, drop: None, .. }\n             | Drop { target, location: _, unwind: None }\n             | DropAndReplace { target, value: _, location: _, unwind: None } => {\n                 self.propagate_bits_into_entry_set_for(in_out, target, dirty_list)\n             }\n \n-            Yield { resume: target, drop: Some(drop), .. } => {\n+            Yield { resume: target, drop, resume_arg, .. } => {\n+                if let Some(drop) = drop {\n+                    self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n+                }\n+\n+                self.analysis.apply_yield_resume_effect(in_out, target, &resume_arg);\n                 self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-                self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n             }\n \n             Assert { target, cleanup: Some(unwind), .. }"}, {"sha": "36decf7f5a9c3d6e73b37f652b90b56b0f0a105e", "filename": "src/librustc_mir/dataflow/generic/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs?ref=5ed3453af9db9c516e564e25ba9ee28056d48103", "patch": "@@ -241,7 +241,7 @@ where\n                     )?;\n \n                     let state_on_unwind = this.results.get().clone();\n-                    this.results.seek_after_assume_call_returns(terminator_loc);\n+                    this.results.seek_after_assume_success(terminator_loc);\n                     write_diff(w, this.results.analysis(), &state_on_unwind, this.results.get())?;\n \n                     write!(w, \"</td>\")"}, {"sha": "fb4b7b9c5be315b276c29eb249c178dc5a0ed00b", "filename": "src/librustc_mir/dataflow/generic/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs?ref=5ed3453af9db9c516e564e25ba9ee28056d48103", "patch": "@@ -191,6 +191,20 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n         return_place: &mir::Place<'tcx>,\n     );\n \n+    /// Updates the current dataflow state with the effect of resuming from a `Yield` terminator.\n+    ///\n+    /// This is similar to `apply_call_return_effect` in that it only takes place after the\n+    /// generator is resumed, not when it is dropped.\n+    ///\n+    /// By default, no effects happen.\n+    fn apply_yield_resume_effect(\n+        &self,\n+        _state: &mut BitSet<Self::Idx>,\n+        _resume_block: BasicBlock,\n+        _resume_place: &mir::Place<'tcx>,\n+    ) {\n+    }\n+\n     /// Updates the current dataflow state with the effect of taking a particular branch in a\n     /// `SwitchInt` terminator.\n     ///\n@@ -284,6 +298,15 @@ pub trait GenKillAnalysis<'tcx>: Analysis<'tcx> {\n         return_place: &mir::Place<'tcx>,\n     );\n \n+    /// See `Analysis::apply_yield_resume_effect`.\n+    fn yield_resume_effect(\n+        &self,\n+        _trans: &mut BitSet<Self::Idx>,\n+        _resume_block: BasicBlock,\n+        _resume_place: &mir::Place<'tcx>,\n+    ) {\n+    }\n+\n     /// See `Analysis::apply_discriminant_switch_effect`.\n     fn discriminant_switch_effect(\n         &self,\n@@ -347,6 +370,15 @@ where\n         self.call_return_effect(state, block, func, args, return_place);\n     }\n \n+    fn apply_yield_resume_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        resume_block: BasicBlock,\n+        resume_place: &mir::Place<'tcx>,\n+    ) {\n+        self.yield_resume_effect(state, resume_block, resume_place);\n+    }\n+\n     fn apply_discriminant_switch_effect(\n         &self,\n         state: &mut BitSet<Self::Idx>,"}, {"sha": "8f07a10e1b01ce11734a44859e60faceea5fe0be", "filename": "src/librustc_mir/dataflow/generic/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Ftests.rs?ref=5ed3453af9db9c516e564e25ba9ee28056d48103", "patch": "@@ -294,7 +294,7 @@ fn cursor_seek() {\n \n     cursor.seek_after(call_terminator_loc);\n     assert!(!cursor.get().contains(call_return_effect));\n-    cursor.seek_after_assume_call_returns(call_terminator_loc);\n+    cursor.seek_after_assume_success(call_terminator_loc);\n     assert!(cursor.get().contains(call_return_effect));\n \n     let every_target = || {\n@@ -310,7 +310,7 @@ fn cursor_seek() {\n             BlockStart(block) => cursor.seek_to_block_start(block),\n             Before(loc) => cursor.seek_before(loc),\n             After(loc) => cursor.seek_after(loc),\n-            AfterAssumeCallReturns(loc) => cursor.seek_after_assume_call_returns(loc),\n+            AfterAssumeCallReturns(loc) => cursor.seek_after_assume_success(loc),\n         }\n \n         assert_eq!(cursor.get(), &cursor.analysis().expected_state_at_target(targ));"}, {"sha": "5341d661b1db62379e1fc424fdbbe36fedbb3254", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=5ed3453af9db9c516e564e25ba9ee28056d48103", "patch": "@@ -161,11 +161,16 @@ impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir,\n         self.borrowed_locals.borrow().analysis().terminator_effect(trans, terminator, loc);\n \n         match &terminator.kind {\n-            TerminatorKind::Call { destination: Some((place, _)), .. }\n-            | TerminatorKind::Yield { resume_arg: place, .. } => {\n+            TerminatorKind::Call { destination: Some((place, _)), .. } => {\n                 trans.gen(place.local);\n             }\n \n+            // Note that we do *not* gen the `resume_arg` of `Yield` terminators. The reason for\n+            // that is that a `yield` will return from the function, and `resume_arg` is written\n+            // only when the generator is later resumed. Unlike `Call`, this doesn't require the\n+            // place to have storage *before* the yield, only after.\n+            TerminatorKind::Yield { .. } => {}\n+\n             // Nothing to do for these. Match exhaustively so this fails to compile when new\n             // variants are added.\n             TerminatorKind::Call { destination: None, .. }\n@@ -230,6 +235,15 @@ impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir,\n     ) {\n         trans.gen(return_place.local);\n     }\n+\n+    fn yield_resume_effect(\n+        &self,\n+        trans: &mut BitSet<Self::Idx>,\n+        _resume_block: BasicBlock,\n+        resume_place: &mir::Place<'tcx>,\n+    ) {\n+        trans.gen(resume_place.local);\n+    }\n }\n \n impl<'mir, 'tcx> MaybeRequiresStorage<'mir, 'tcx> {"}, {"sha": "7418a7519ba2b8adbab8ed6fef36af28b4fe440c", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=5ed3453af9db9c516e564e25ba9ee28056d48103", "patch": "@@ -539,7 +539,7 @@ fn locals_live_across_suspend_points(\n             let mut live_locals_here = storage_required;\n             live_locals_here.intersect(&liveness.outs[block]);\n \n-            // The generator argument is ignored\n+            // The generator argument is ignored.\n             live_locals_here.remove(self_arg());\n \n             debug!(\"loc = {:?}, live_locals_here = {:?}\", loc, live_locals_here);"}, {"sha": "30788e3c1864bb1935c4ae4a1ee029b74c6e56a6", "filename": "src/test/ui/generator/generator-yielding-or-returning-itself.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-yielding-or-returning-itself.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-yielding-or-returning-itself.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-yielding-or-returning-itself.rs?ref=5ed3453af9db9c516e564e25ba9ee28056d48103", "previous_filename": "src/test/ui/generator-yielding-or-returning-itself.rs"}, {"sha": "fc8064d8225bf5db7b665be067d8c1f8678fb56e", "filename": "src/test/ui/generator/generator-yielding-or-returning-itself.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-yielding-or-returning-itself.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-yielding-or-returning-itself.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-yielding-or-returning-itself.stderr?ref=5ed3453af9db9c516e564e25ba9ee28056d48103", "previous_filename": "src/test/ui/generator-yielding-or-returning-itself.stderr"}, {"sha": "ccc141860aa5f908683fb4d3ada63de8a96c1ff6", "filename": "src/test/ui/generator/issue-69039.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Ftest%2Fui%2Fgenerator%2Fissue-69039.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Ftest%2Fui%2Fgenerator%2Fissue-69039.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-69039.rs?ref=5ed3453af9db9c516e564e25ba9ee28056d48103", "patch": "@@ -4,11 +4,15 @@\n \n use std::ops::{Generator, GeneratorState};\n \n+fn mkstr(my_name: String, my_mood: String) -> String {\n+    format!(\"{} is {}\", my_name.trim(), my_mood.trim())\n+}\n+\n fn my_scenario() -> impl Generator<String, Yield = &'static str, Return = String> {\n     |_arg: String| {\n         let my_name = yield \"What is your name?\";\n         let my_mood = yield \"How are you feeling?\";\n-        format!(\"{} is {}\", my_name.trim(), my_mood.trim())\n+        mkstr(my_name, my_mood)\n     }\n }\n "}, {"sha": "ffdc98d6f1984f9a45818498a3501df56cae3aad", "filename": "src/test/ui/generator/resume-arg-size.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed3453af9db9c516e564e25ba9ee28056d48103/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-size.rs?ref=5ed3453af9db9c516e564e25ba9ee28056d48103", "patch": "@@ -0,0 +1,28 @@\n+#![feature(generators)]\n+\n+// run-pass\n+\n+use std::mem::size_of_val;\n+\n+fn main() {\n+    // Generator taking a `Copy`able resume arg.\n+    let gen_copy = |mut x: usize| {\n+        loop {\n+            drop(x);\n+            x = yield;\n+        }\n+    };\n+\n+    // Generator taking a non-`Copy` resume arg.\n+    let gen_move = |mut x: Box<usize>| {\n+        loop {\n+            drop(x);\n+            x = yield;\n+        }\n+    };\n+\n+    // Neither of these generators have the resume arg live across the `yield`, so they should be\n+    // 4 Bytes in size (only storing the discriminant)\n+    assert_eq!(size_of_val(&gen_copy), 4);\n+    assert_eq!(size_of_val(&gen_move), 4);\n+}"}]}