{"sha": "04c387efe7bef9b071596a7a4004297bf9e3c77c", "node_id": "C_kwDOAAsO6NoAKDA0YzM4N2VmZTdiZWY5YjA3MTU5NmE3YTQwMDQyOTdiZjllM2M3N2M", "commit": {"author": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2023-04-06T10:32:32Z"}, "committer": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2023-04-06T10:32:32Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup", "tree": {"sha": "720c87c930096dbd7ed4f965fad170c082a73707", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/720c87c930096dbd7ed4f965fad170c082a73707"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04c387efe7bef9b071596a7a4004297bf9e3c77c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmQun8IACgkQHKDfKvWd\naKX7mBAAyurBZyvoVf3Bz/diZV/OY3NksjRV2y09pg6ZmK9ZmGyzqn05BjWOg297\npDLQ1Bh8wV6xJUPPrmxxUozTSNe2OSLS/W7Mvo4U3uuxEvVsoFBwGa24e0Ml1KoT\nsDYYupuVq5cs/Bh198YR67EW8SBDNA4CcEsM5tYFl6483nmqgPK7cnSIJ7D3yg+B\nZN4GK3dpZZ54nK3EptpizU9LiJKH/BDiIZhsl43kN5Mg+gYBwSdWOas8dvHXvVh5\npytwvx6IWG9ip566S4SfKMQMV54OER21AHDMTMpI9fQADvoWe/iKp32ZwEh0IU1Z\nG2tvJfp2gCNHbGA/04dPoDTtzru07MsVRYYbDPAGuxmR6tYzVoxubd0yyGLQMXHA\nEi/kcMJb4vr07nGDMzPQrtltOrX5GLMLFpZ0oRFjYYmWclHeA2xV88K+SRnglglh\njgenTOlVTA3MKxeDmEiqQTrt5g6tAFUeHUcLQwAsHTLswqj2AsFhlw13hwj+uLHm\nXxpOTMdihLfZmdftv1AL6//d53X014VbPhJtPhZVhHdWck7B+X6UJFEXQoNi/yw+\nuho4+JyYlNlsV6CG0rsAofgYSRDjUgrg1anHW8DI84Up6FcH7525iovKy/+TsJop\nIbuFyCQ8z1ebSxQS1Yww9ZAf/W+w3duFI5Asl3QyPLvme3WNotw=\n=JnIe\n-----END PGP SIGNATURE-----", "payload": "tree 720c87c930096dbd7ed4f965fad170c082a73707\nparent e9c7fb10b92c47e9bb2713fae5ef74a07efce92d\nparent 26e245d2ff38671e6c58395d853cd253adc7343b\nauthor Philipp Krones <hello@philkrones.com> 1680777152 +0200\ncommitter Philipp Krones <hello@philkrones.com> 1680777152 +0200\n\nMerge remote-tracking branch 'upstream/master' into rustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04c387efe7bef9b071596a7a4004297bf9e3c77c", "html_url": "https://github.com/rust-lang/rust/commit/04c387efe7bef9b071596a7a4004297bf9e3c77c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04c387efe7bef9b071596a7a4004297bf9e3c77c/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9c7fb10b92c47e9bb2713fae5ef74a07efce92d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9c7fb10b92c47e9bb2713fae5ef74a07efce92d", "html_url": "https://github.com/rust-lang/rust/commit/e9c7fb10b92c47e9bb2713fae5ef74a07efce92d"}, {"sha": "26e245d2ff38671e6c58395d853cd253adc7343b", "url": "https://api.github.com/repos/rust-lang/rust/commits/26e245d2ff38671e6c58395d853cd253adc7343b", "html_url": "https://github.com/rust-lang/rust/commit/26e245d2ff38671e6c58395d853cd253adc7343b"}], "stats": {"total": 4668, "additions": 3026, "deletions": 1642}, "files": [{"sha": "4d80d3ce63dac89aae6de38076d10a9feb89e047", "filename": ".cargo/config.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/.cargo%2Fconfig.toml", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/.cargo%2Fconfig.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.cargo%2Fconfig.toml?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -11,3 +11,6 @@ target-dir = \"target\"\n \n [unstable]\n binary-dep-depinfo = true\n+\n+[profile.dev]\n+split-debuginfo = \"unpacked\""}, {"sha": "93198aabdb5f5ae8f04369e580ee1ca54ce7f00f", "filename": ".github/workflows/clippy_bors.yml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_bors.yml?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -180,6 +180,8 @@ jobs:\n \n     # Run\n     - name: Build Integration Test\n+      env:\n+        CARGO_PROFILE_DEV_SPLIT_DEBUGINFO: off\n       run: cargo test --test integration --features integration --no-run\n \n     # Upload"}, {"sha": "ba10cb53ec9294f3e557c48798a068b37c0f9e23", "filename": "CHANGELOG.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -4441,6 +4441,7 @@ Released 2018-09-13\n [`chars_last_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#chars_last_cmp\n [`chars_next_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#chars_next_cmp\n [`checked_conversions`]: https://rust-lang.github.io/rust-clippy/master/index.html#checked_conversions\n+[`clear_with_drain`]: https://rust-lang.github.io/rust-clippy/master/index.html#clear_with_drain\n [`clone_double_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_double_ref\n [`clone_on_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_copy\n [`clone_on_ref_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_ref_ptr\n@@ -4632,6 +4633,7 @@ Released 2018-09-13\n [`large_const_arrays`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_const_arrays\n [`large_digit_groups`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_digit_groups\n [`large_enum_variant`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_enum_variant\n+[`large_futures`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_futures\n [`large_include_file`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_include_file\n [`large_stack_arrays`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_stack_arrays\n [`large_types_passed_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_types_passed_by_value\n@@ -4645,6 +4647,7 @@ Released 2018-09-13\n [`let_underscore_untyped`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_underscore_untyped\n [`let_unit_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_unit_value\n [`let_with_type_underscore`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_with_type_underscore\n+[`lines_filter_map_ok`]: https://rust-lang.github.io/rust-clippy/master/index.html#lines_filter_map_ok\n [`linkedlist`]: https://rust-lang.github.io/rust-clippy/master/index.html#linkedlist\n [`logic_bug`]: https://rust-lang.github.io/rust-clippy/master/index.html#logic_bug\n [`lossy_float_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#lossy_float_literal\n@@ -4933,6 +4936,7 @@ Released 2018-09-13\n [`tabs_in_doc_comments`]: https://rust-lang.github.io/rust-clippy/master/index.html#tabs_in_doc_comments\n [`temporary_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_assignment\n [`temporary_cstring_as_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_cstring_as_ptr\n+[`tests_outside_test_module`]: https://rust-lang.github.io/rust-clippy/master/index.html#tests_outside_test_module\n [`to_digit_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_digit_is_some\n [`to_string_in_display`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_display\n [`to_string_in_format_args`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_format_args\n@@ -4974,6 +4978,7 @@ Released 2018-09-13\n [`unit_hash`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_hash\n [`unit_return_expecting_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_return_expecting_ord\n [`unknown_clippy_lints`]: https://rust-lang.github.io/rust-clippy/master/index.html#unknown_clippy_lints\n+[`unnecessary_box_returns`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_box_returns\n [`unnecessary_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n [`unnecessary_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_filter_map\n [`unnecessary_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_find_map"}, {"sha": "85798e0e80c15ea5a2abaff1c5dcbaeb5883aaa9", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -11,7 +11,7 @@ Lints are divided into categories, each with a default [lint level](https://doc.\n You can choose how much Clippy is supposed to ~~annoy~~ help you by changing the lint level by category.\n \n | Category              | Description                                                                         | Default level |\n-| --------------------- | ----------------------------------------------------------------------------------- | ------------- |\n+|-----------------------|-------------------------------------------------------------------------------------|---------------|\n | `clippy::all`         | all lints that are on by default (correctness, suspicious, style, complexity, perf) | **warn/deny** |\n | `clippy::correctness` | code that is outright wrong or useless                                              | **deny**      |\n | `clippy::suspicious`  | code that is most likely wrong or useless                                           | **warn**      |\n@@ -130,7 +130,7 @@ for example.\n \n You can add Clippy to Travis CI in the same way you use it locally:\n \n-```yml\n+```yaml\n language: rust\n rust:\n   - stable\n@@ -253,7 +253,7 @@ rust-version = \"1.30\"\n \n The MSRV can also be specified as an attribute, like below.\n \n-```rust\n+```rust,ignore\n #![feature(custom_inner_attributes)]\n #![clippy::msrv = \"1.30.0\"]\n "}, {"sha": "3b6270962680efdf48033a12083986de2fec4cf8", "filename": "book/src/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2FREADME.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -14,7 +14,7 @@ much Clippy is supposed to ~~annoy~~ help you by changing the lint level by\n category.\n \n | Category              | Description                                                                         | Default level |\n-| --------------------- | ----------------------------------------------------------------------------------- | ------------- |\n+|-----------------------|-------------------------------------------------------------------------------------|---------------|\n | `clippy::all`         | all lints that are on by default (correctness, suspicious, style, complexity, perf) | **warn/deny** |\n | `clippy::correctness` | code that is outright wrong or useless                                              | **deny**      |\n | `clippy::suspicious`  | code that is most likely wrong or useless                                           | **warn**      |"}, {"sha": "1304f6a8c2f095bc4056824fc9d1afe2aca3afb3", "filename": "book/src/configuration.md", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fconfiguration.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fconfiguration.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fconfiguration.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -3,7 +3,7 @@\n > **Note:** The configuration file is unstable and may be deprecated in the future.\n \n Some lints can be configured in a TOML file named `clippy.toml` or `.clippy.toml`. It contains a\n-basic `variable = value` mapping eg.\n+basic `variable = value` mapping e.g.\n \n ```toml\n avoid-breaking-exported-api = false\n@@ -60,7 +60,7 @@ And to warn on `lint_name`, run\n cargo clippy -- -W clippy::lint_name\n ```\n \n-This also works with lint groups. For example you can run Clippy with warnings for all lints enabled:\n+This also works with lint groups. For example, you can run Clippy with warnings for all lints enabled:\n \n ```terminal\n cargo clippy -- -W clippy::pedantic\n@@ -84,7 +84,7 @@ msrv = \"1.30.0\"\n \n The MSRV can also be specified as an attribute, like below.\n \n-```rust\n+```rust,ignore\n #![feature(custom_inner_attributes)]\n #![clippy::msrv = \"1.30.0\"]\n \n@@ -96,7 +96,28 @@ fn main() {\n You can also omit the patch version when specifying the MSRV, so `msrv = 1.30`\n is equivalent to `msrv = 1.30.0`.\n \n-Note: `custom_inner_attributes` is an unstable feature so it has to be enabled explicitly.\n+Note: `custom_inner_attributes` is an unstable feature, so it has to be enabled explicitly.\n \n Lints that recognize this configuration option can be\n found [here](https://rust-lang.github.io/rust-clippy/master/index.html#msrv)\n+\n+### Disabling evaluation of certain code\n+\n+> **Note:** This should only be used in cases where other solutions, like `#[allow(clippy::all)]`, are not sufficient.\n+\n+Very rarely, you may wish to prevent Clippy from evaluating certain sections of code entirely. You can do this with\n+[conditional compilation](https://doc.rust-lang.org/reference/conditional-compilation.html) by checking that the\n+`cargo-clippy` feature is not set. You may need to provide a stub so that the code compiles:\n+\n+```rust\n+#[cfg(not(feature = \"cargo-clippy\"))]\n+include!(concat!(env!(\"OUT_DIR\"), \"/my_big_function-generated.rs\"));\n+\n+#[cfg(feature = \"cargo-clippy\")]\n+fn my_big_function(_input: &str) -> Option<MyStruct> {\n+    None\n+}\n+```\n+\n+This feature is not actually part of your crate, so specifying `--all-features` to other tools, e.g. `cargo test\n+--all-features`, will not disable it."}, {"sha": "616e6d182b729d5d97d8402d283ea12b3f270480", "filename": "book/src/development/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2FREADME.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -5,7 +5,7 @@ making Clippy better by contributing to it. In that case, welcome to the\n project!\n \n > _Note:_ If you're just interested in using Clippy, there's nothing to see from\n-> this point onward and you should return to one of the earlier chapters.\n+> this point onward, and you should return to one of the earlier chapters.\n \n ## Getting started\n "}, {"sha": "3f4088e74eaf7e573b7053c0113e4e6f78c1cc82", "filename": "book/src/development/adding_lints.md", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fadding_lints.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -18,12 +18,13 @@ because that's clearly a non-descriptive name.\n     - [Cargo lints](#cargo-lints)\n   - [Rustfix tests](#rustfix-tests)\n   - [Testing manually](#testing-manually)\n+  - [Running directly](#running-directly)\n   - [Lint declaration](#lint-declaration)\n   - [Lint registration](#lint-registration)\n   - [Lint passes](#lint-passes)\n   - [Emitting a lint](#emitting-a-lint)\n   - [Adding the lint logic](#adding-the-lint-logic)\n-  - [Specifying the lint's minimum supported Rust version (MSRV)](#specifying-the-lints-minimum-supported-rust-version-msrv)\n+  - [Specifying the lint's minimum supported Rust version (MSRV)](#specifying-the-lints-minimum-supported-rust-version--msrv-)\n   - [Author lint](#author-lint)\n   - [Print HIR lint](#print-hir-lint)\n   - [Documentation](#documentation)\n@@ -186,6 +187,15 @@ cargo dev lint input.rs\n from the working copy root. With tests in place, let's have a look at\n implementing our lint now.\n \n+## Running directly\n+\n+While it's easier to just use `cargo dev lint`, it might be desirable to get\n+`target/release/cargo-clippy` and `target/release/clippy-driver` to work as well in some cases.\n+By default, they don't work because clippy dynamically links rustc. To help them find rustc,\n+add the path printed by`rustc --print target-libdir` (ran inside this workspace so that the rustc version matches)\n+to your library search path.\n+On linux, this can be done by setting the `LD_LIBRARY_PATH` environment variable to that path.\n+\n ## Lint declaration\n \n Let's start by opening the new file created in the `clippy_lints` crate at\n@@ -265,7 +275,7 @@ When declaring a new lint by hand and `cargo dev update_lints` is used, the lint\n pass may have to be registered manually in the `register_plugins` function in\n `clippy_lints/src/lib.rs`:\n \n-```rust\n+```rust,ignore\n store.register_early_pass(|| Box::new(foo_functions::FooFunctions));\n ```\n \n@@ -291,7 +301,7 @@ either [`EarlyLintPass`][early_lint_pass] or [`LateLintPass`][late_lint_pass].\n \n In short, the `LateLintPass` has access to type information while the\n `EarlyLintPass` doesn't. If you don't need access to type information, use the\n-`EarlyLintPass`. The `EarlyLintPass` is also faster. However linting speed\n+`EarlyLintPass`. The `EarlyLintPass` is also faster. However, linting speed\n hasn't really been a concern with Clippy so far.\n \n Since we don't need type information for checking the function name, we used\n@@ -308,7 +318,7 @@ implementation of the lint logic.\n \n Let's start by implementing the `EarlyLintPass` for our `FooFunctions`:\n \n-```rust\n+```rust,ignore\n impl EarlyLintPass for FooFunctions {\n     fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, span: Span, _: NodeId) {\n         // TODO: Emit lint here\n@@ -327,10 +337,10 @@ variety of lint emission functions. They can all be found in\n [`clippy_utils/src/diagnostics.rs`][diagnostics].\n \n `span_lint_and_help` seems most appropriate in this case. It allows us to\n-provide an extra help message and we can't really suggest a better name\n+provide an extra help message, and we can't really suggest a better name\n automatically. This is how it looks:\n \n-```rust\n+```rust,ignore\n impl EarlyLintPass for FooFunctions {\n     fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, span: Span, _: NodeId) {\n         span_lint_and_help(\n@@ -469,7 +479,7 @@ the value from `clippy.toml`. This can be accounted for using the\n `extract_msrv_attr!(LintContext)` macro and passing\n `LateContext`/`EarlyContext`.\n \n-```rust\n+```rust,ignore\n impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         ...\n@@ -483,7 +493,7 @@ the lint's test file, `tests/ui/manual_strip.rs` in this example. It should\n have a case for the version below the MSRV and one with the same contents but\n for the MSRV version itself.\n \n-```rust\n+```rust,ignore\n ...\n \n #[clippy::msrv = \"1.44\"]\n@@ -514,7 +524,7 @@ define_Conf! {\n \n If you have trouble implementing your lint, there is also the internal `author`\n lint to generate Clippy code that detects the offending pattern. It does not\n-work for all of the Rust syntax, but can give a good starting point.\n+work for all the Rust syntax, but can give a good starting point.\n \n The quickest way to use it, is the [Rust playground:\n play.rust-lang.org][author_example]. Put the code you want to lint into the\n@@ -607,7 +617,7 @@ output in the `stdout` part.\n \n ## PR Checklist\n \n-Before submitting your PR make sure you followed all of the basic requirements:\n+Before submitting your PR make sure you followed all the basic requirements:\n \n <!-- Sync this with `.github/PULL_REQUEST_TEMPLATE` -->\n \n@@ -627,7 +637,7 @@ for some users. Adding a configuration is done in the following steps:\n \n 1. Adding a new configuration entry to [`clippy_lints::utils::conf`] like this:\n \n-   ```rust\n+   ```rust,ignore\n    /// Lint: LINT_NAME.\n    ///\n    /// <The configuration field doc comment>\n@@ -680,7 +690,7 @@ for some users. Adding a configuration is done in the following steps:\n    configuration value is now cloned or copied into a local value that is then\n    passed to the impl struct like this:\n \n-   ```rust\n+   ```rust,ignore\n    // Default generated registration:\n    store.register_*_pass(|| box module::StructName);\n "}, {"sha": "b07d3de7187e546fb316d088d42855029e521e3e", "filename": "book/src/development/basics.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Fbasics.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Fbasics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fbasics.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -125,7 +125,7 @@ We follow a rustc no merge-commit policy. See\n ## Common Abbreviations\n \n | Abbreviation | Meaning                                |\n-| ------------ | -------------------------------------- |\n+|--------------|----------------------------------------|\n | UB           | Undefined Behavior                     |\n | FP           | False Positive                         |\n | FN           | False Negative                         |"}, {"sha": "09171d86a2097965e286812d951c73fc6c9dddb2", "filename": "book/src/development/common_tools_writing_lints.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -3,7 +3,7 @@\n You may need following tooltips to catch up with common operations.\n \n - [Common tools for writing lints](#common-tools-for-writing-lints)\n-  - [Retrieving the type of an expression](#retrieving-the-type-of-an-expression)\n+  - [Retrieving the type of expression](#retrieving-the-type-of-expression)\n   - [Checking if an expr is calling a specific method](#checking-if-an-expr-is-calling-a-specific-method)\n   - [Checking for a specific type](#checking-for-a-specific-type)\n   - [Checking if a type implements a specific trait](#checking-if-a-type-implements-a-specific-trait)\n@@ -16,7 +16,7 @@ Useful Rustc dev guide links:\n - [Type checking](https://rustc-dev-guide.rust-lang.org/type-checking.html)\n - [Ty module](https://rustc-dev-guide.rust-lang.org/ty.html)\n \n-## Retrieving the type of an expression\n+## Retrieving the type of expression\n \n Sometimes you may want to retrieve the type `Ty` of an expression `Expr`, for\n example to answer following questions:\n@@ -45,7 +45,7 @@ impl LateLintPass<'_> for MyStructLint {\n }\n ```\n \n-Similarly in [`TypeckResults`][TypeckResults] methods, you have the\n+Similarly, in [`TypeckResults`][TypeckResults] methods, you have the\n [`pat_ty()`][pat_ty] method to retrieve a type from a pattern.\n \n Two noticeable items here:\n@@ -192,7 +192,7 @@ functions to deal with macros:\n - `span.from_expansion()`: detects if a span is from macro expansion or\n   desugaring. Checking this is a common first step in a lint.\n \n-   ```rust\n+   ```rust,ignore\n    if expr.span.from_expansion() {\n        // just forget it\n        return;\n@@ -203,11 +203,11 @@ functions to deal with macros:\n   if so, which macro call expanded it. It is sometimes useful to check if the\n   context of two spans are equal.\n \n-  ```rust\n+  ```rust,ignore\n   // expands to `1 + 0`, but don't lint\n   1 + mac!()\n   ```\n-  ```rust\n+  ```rust,ignore\n   if left.span.ctxt() != right.span.ctxt() {\n       // the coder most likely cannot modify this expression\n       return;\n@@ -246,7 +246,7 @@ functions to deal with macros:\n   `macro_rules!` with `a == $b`, `$b` is expanded to some expression with a\n   different context from `a`.\n \n-   ```rust\n+   ```rust,ignore\n    macro_rules! m {\n        ($a:expr, $b:expr) => {\n            if $a.is_some() {"}, {"sha": "de5de4bebaa91ef8bb0dc079a5a480ea22440f44", "filename": "book/src/development/infrastructure/book.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fbook.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fbook.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fbook.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -13,7 +13,7 @@ guide to Clippy that you're reading right now. The Clippy book is formatted with\n While not strictly necessary since the book source is simply Markdown text\n files, having mdBook locally will allow you to build, test and serve the book\n locally to view changes before you commit them to the repository. You likely\n-already have `cargo` installed, so the easiest option is to simply:\n+already have `cargo` installed, so the easiest option is to:\n \n ```shell\n cargo install mdbook\n@@ -26,7 +26,7 @@ instructions for other options.\n \n The book's\n [src](https://github.com/rust-lang/rust-clippy/tree/master/book/src)\n-directory contains all of the markdown files used to generate the book. If you\n+directory contains all the markdown files used to generate the book. If you\n want to see your changes in real time, you can use the mdBook `serve` command to\n run a web server locally that will automatically update changes as they are\n made. From the top level of your `rust-clippy` directory:"}, {"sha": "df9b1bbe18f326a385bf53c0c0c58be6200ce0c6", "filename": "book/src/development/infrastructure/changelog_update.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fchangelog_update.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fchangelog_update.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fchangelog_update.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -101,7 +101,7 @@ Look for the [`beta-accepted`] label and make sure to also include the PRs with\n that label in the changelog. If you can, remove the `beta-accepted` labels\n **after** the changelog PR was merged.\n \n-> _Note:_ Some of those PRs might even got backported to the previous `beta`.\n+> _Note:_ Some of those PRs might even get backported to the previous `beta`.\n > Those have to be included in the changelog of the _previous_ release.\n \n ### 4. Update `clippy::version` attributes"}, {"sha": "98fabf8e89aee9e66dd3ed51c0bf13b9010556f5", "filename": "book/src/development/infrastructure/release.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Frelease.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Frelease.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Frelease.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -44,7 +44,7 @@ $ git push origin backport_remerge  # This can be pushed to your fork\n ```\n \n After this, open a PR to the master branch. In this PR, the commit hash of the\n-`HEAD` of the `beta` branch must exists. In addition to that, no files should be\n+`HEAD` of the `beta` branch must exist. In addition to that, no files should be\n changed by this PR.\n \n ## Update the `beta` branch"}, {"sha": "e1fe92f95250d35d9d59287c17c181b38ae63ed6", "filename": "book/src/development/infrastructure/sync.md", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fsync.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fsync.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fsync.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -19,8 +19,7 @@ to beta. For reference, the first sync following this cadence was performed the\n 2020-08-27.\n \n This process is described in detail in the following sections. For general\n-information about `subtree`s in the Rust repository see [Rust's\n-`CONTRIBUTING.md`][subtree].\n+information about `subtree`s in the Rust repository see [the rustc-dev-guide][subtree].\n \n ## Patching git-subtree to work with big repos\n \n@@ -47,7 +46,7 @@ sudo chown --reference=/usr/lib/git-core/git-subtree~ /usr/lib/git-core/git-subt\n \n > _Note:_ If you are a Debian user, `dash` is the shell used by default for\n > scripts instead of `sh`. This shell has a hardcoded recursion limit set to\n-> 1000. In order to make this process work, you need to force the script to run\n+> 1,000. In order to make this process work, you need to force the script to run\n > `bash` instead. You can do this by editing the first line of the `git-subtree`\n > script and changing `sh` to `bash`.\n \n@@ -71,10 +70,10 @@ $ git remote add clippy-local /path/to/rust-clippy\n \n ## Performing the sync from [`rust-lang/rust`] to Clippy\n \n-Here is a TL;DR version of the sync process (all of the following commands have\n+Here is a TL;DR version of the sync process (all the following commands have\n to be run inside the `rust` directory):\n \n-1. Clone the [`rust-lang/rust`] repository or make sure it is up to date.\n+1. Clone the [`rust-lang/rust`] repository or make sure it is up-to-date.\n 2. Checkout the commit from the latest available nightly. You can get it using\n    `rustup check`.\n 3. Sync the changes to the rust-copy of Clippy to your Clippy fork:\n@@ -107,7 +106,7 @@ to be run inside the `rust` directory):\n \n ## Performing the sync from Clippy to [`rust-lang/rust`]\n \n-All of the following commands have to be run inside the `rust` directory.\n+All the following commands have to be run inside the `rust` directory.\n \n 1. Make sure you have checked out the latest `master` of `rust-lang/rust`.\n 2. Sync the `rust-lang/rust-clippy` master to the rust-copy of Clippy:\n@@ -118,5 +117,5 @@ All of the following commands have to be run inside the `rust` directory.\n 3. Open a PR to [`rust-lang/rust`]\n \n [gitgitgadget-pr]: https://github.com/gitgitgadget/git/pull/493\n-[subtree]: https://rustc-dev-guide.rust-lang.org/contributing.html#external-dependencies-subtree\n+[subtree]: https://rustc-dev-guide.rust-lang.org/external-repos.html#external-dependencies-subtree\n [`rust-lang/rust`]: https://github.com/rust-lang/rust"}, {"sha": "059c22ce1ce8c003b02e4023b39945a57f7b18d9", "filename": "book/src/development/proposals/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Fproposals%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Fproposals%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fproposals%2FREADME.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -6,6 +6,6 @@ or around Clippy in the long run.\n Besides adding more and more lints and improve the lints that Clippy already\n has, Clippy is also interested in making the experience of its users, developers\n and maintainers better over time. Projects that address bigger picture things\n-like this usually take more time and it is useful to have a proposal for those\n+like this usually take more time, and it is useful to have a proposal for those\n first. This is the place where such proposals are collected, so that we can\n refer to them when working on them."}, {"sha": "4406616bbb613c4faee3aba01b832bc28a621e4d", "filename": "book/src/development/proposals/roadmap-2021.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Fproposals%2Froadmap-2021.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Fproposals%2Froadmap-2021.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fproposals%2Froadmap-2021.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -52,8 +52,8 @@ In the following, plans to improve the usability are covered.\n \n #### No Output After `cargo check`\n \n-Currently when `cargo clippy` is run after `cargo check`, it does not produce\n-any output. This is especially problematic since `rust-analyzer` is on the rise\n+Currently, when `cargo clippy` is run after `cargo check`, it does not produce\n+any output. This is especially problematic since `rust-analyzer` is on the rise,\n and it uses `cargo check` for checking code. A fix is already implemented, but\n it still has to be pushed over the finish line. This also includes the\n stabilization of the `cargo clippy --fix` command or the support of multi-span\n@@ -221,7 +221,7 @@ regarding the user facing issues.\n \n Rust's roadmap process was established by [RFC 1728] in 2016. Since then every\n year a roadmap was published, that defined the bigger plans for the coming\n-years. This years roadmap can be found [here][Rust Roadmap 2021].\n+years. This year roadmap can be found [here][Rust Roadmap 2021].\n \n [RFC 1728]: https://rust-lang.github.io/rfcs/1728-north-star.html\n "}, {"sha": "36d722609f4ace2bf6bd2a136f6cf713ff7e7d51", "filename": "book/src/development/proposals/syntax-tree-patterns.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Fproposals%2Fsyntax-tree-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fdevelopment%2Fproposals%2Fsyntax-tree-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fproposals%2Fsyntax-tree-patterns.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -16,7 +16,7 @@ lints. For non-trivial lints, it often requires nested pattern matching of AST /\n HIR nodes. For example, testing that an expression is a boolean literal requires\n the following checks:\n \n-```rust\n+```rust,ignore\n if let ast::ExprKind::Lit(lit) = &expr.node {\n     if let ast::LitKind::Bool(_) = &lit.node {\n         ...\n@@ -28,7 +28,7 @@ Writing this kind of matching code quickly becomes a complex task and the\n resulting code is often hard to comprehend. The code below shows a simplified\n version of the pattern matching required by the `collapsible_if` lint:\n \n-```rust\n+```rust,ignore\n // simplified version of the collapsible_if lint\n if let ast::ExprKind::If(check, then, None) = &expr.node {\n     if then.stmts.len() == 1 {\n@@ -111,7 +111,7 @@ expressions that are boolean literals with value `false`.\n \n The pattern can then be used to implement lints in the following way:\n \n-```rust\n+```rust,ignore\n ...\n \n impl EarlyLintPass for MyAwesomeLint {\n@@ -346,7 +346,7 @@ pattern!{\n one could get references to the nodes that matched the subpatterns in the\n following way:\n \n-```rust\n+```rust,ignore\n ...\n fn check_expr(expr: &syntax::ast::Expr) {\n     if let Some(result) = my_pattern(expr) {\n@@ -372,7 +372,7 @@ matches arrays that consist of any number of literal expressions. Because those\n expressions are named `foo`, the result struct contains a `foo` attribute which\n is a vector of expressions:\n \n-```rust\n+```rust,ignore\n ...\n if let Some(result) = my_pattern_seq(expr) {\n     result.foo        // type: Vec<&syntax::ast::Expr>\n@@ -394,7 +394,7 @@ In the pattern above, the `bar` name is only defined if the pattern matches a\n boolean literal. If it matches an integer literal, the name isn't set. To\n account for this, the result struct's `bar` attribute is an option type:\n \n-```rust\n+```rust,ignore\n ...\n if let Some(result) = my_pattern_alt(expr) {\n     result.bar        // type: Option<&bool>\n@@ -404,7 +404,7 @@ if let Some(result) = my_pattern_alt(expr) {\n It's also possible to use a name in multiple alternation branches if they have\n compatible types:\n \n-```rust\n+```rust,ignore\n pattern!{\n     // matches if expression is a boolean or integer literal\n     my_pattern_mult: Expr =\n@@ -519,7 +519,7 @@ The `Alt`, `Seq` and `Opt` structs look like these:\n > Note: The current implementation can be found\n > [here](https://github.com/fkohlgrueber/pattern-matching/blob/dfb3bc9fbab69cec7c91e72564a63ebaa2ede638/pattern-match/src/matchers.rs#L35-L60).\n \n-```rust\n+```rust,ignore\n pub enum Alt<T> {\n     Any,\n     Elmt(Box<T>),\n@@ -580,7 +580,7 @@ implementations is the `IsMatch` trait. It defines how to match *PatternTree*\n nodes against specific syntax tree nodes. A simplified implementation of the\n `IsMatch` trait is shown below:\n \n-```rust\n+```rust,ignore\n pub trait IsMatch<O> {\n     fn is_match(&self, other: &'o O) -> bool;\n }\n@@ -619,7 +619,7 @@ approach (matching against the coarse pattern first and checking for additional\n properties later) might be slower than the current practice of checking for\n structure and additional properties in one pass. For example, the following lint\n \n-```rust\n+```rust,ignore\n pattern!{\n     pat_if_without_else: Expr =\n         If(\n@@ -644,7 +644,7 @@ first matches against the pattern and then checks that the `then` block doesn't\n start with a comment. Using clippy's current approach, it's possible to check\n for these conditions earlier:\n \n-```rust\n+```rust,ignore\n fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     if_chain! {\n         if let ast::ExprKind::If(ref check, ref then, None) = expr.node;\n@@ -708,7 +708,7 @@ is similar to actual Rust syntax (probably like the `quote!` macro). For\n example, a pattern that matches `if` expressions that have `false` in their\n condition could look like this:\n \n-```rust\n+```rust,ignore\n if false {\n     #[*]\n }\n@@ -742,7 +742,7 @@ affects the structure of the resulting AST. `1 + 0 + 0` is parsed as `(1 + 0) +\n Another example of a problem would be named submatches. Take a look at this\n pattern:\n \n-```rust\n+```rust,ignore\n fn test() {\n     1 #foo\n }\n@@ -862,7 +862,7 @@ op b` and recommends changing it to `a op= b` requires that both occurrences of\n `a` are the same. Using `=#...` as syntax for backreferences, the lint could be\n implemented like this:\n \n-```rust\n+```rust,ignore\n pattern!{\n     assign_op_pattern: Expr =\n         Assign(_#target, Binary(_, =#target, _)"}, {"sha": "d54fff9deba1847f436599dcf58d1580fa06bc20", "filename": "book/src/installation.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Finstallation.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Finstallation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Finstallation.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -17,8 +17,8 @@ $ rustup component add clippy [--toolchain=<name>]\n \n ## From Source\n \n-Take a look at the [Basics] chapter in the Clippy developer guide to find step\n-by step instructions on how to build and install Clippy from source.\n+Take a look at the [Basics] chapter in the Clippy developer guide to find step-by-step\n+instructions on how to build and install Clippy from source.\n \n [Basics]: development/basics.md#install-from-source\n [Usage]: usage.md"}, {"sha": "78e1a55cff32e5ade599b92f3ee8cdd254e6a308", "filename": "book/src/lint_configuration.md", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Flint_configuration.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Flint_configuration.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Flint_configuration.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -54,6 +54,7 @@ Please use that command to update the file and do not edit it by hand.\n | [allow-mixed-uninlined-format-args](#allow-mixed-uninlined-format-args) | `true` |\n | [suppress-restriction-lint-in-const](#suppress-restriction-lint-in-const) | `false` |\n | [missing-docs-in-crate-items](#missing-docs-in-crate-items) | `false` |\n+| [future-size-threshold](#future-size-threshold) | `16384` |\n \n ### arithmetic-side-effects-allowed\n Suppress checking of the passed type names in all types of operations.\n@@ -130,6 +131,7 @@ Suppress lints whenever the suggested change would cause breakage for other crat\n * [option_option](https://rust-lang.github.io/rust-clippy/master/index.html#option_option)\n * [linkedlist](https://rust-lang.github.io/rust-clippy/master/index.html#linkedlist)\n * [rc_mutex](https://rust-lang.github.io/rust-clippy/master/index.html#rc_mutex)\n+* [unnecessary_box_returns](https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_box_returns)\n \n \n ### msrv\n@@ -193,7 +195,7 @@ The maximum cognitive complexity a function can have\n ### disallowed-names\n The list of disallowed names to lint about. NB: `bar` is not here since it has legitimate uses. The value\n `\"..\"` can be used as part of the list to indicate, that the configured values should be appended to the\n-default configuration of Clippy. By default any configuration will replace the default value.\n+default configuration of Clippy. By default, any configuration will replace the default value.\n \n **Default Value:** `[\"foo\", \"baz\", \"quux\"]` (`Vec<String>`)\n \n@@ -203,7 +205,7 @@ default configuration of Clippy. By default any configuration will replace the d\n ### doc-valid-idents\n The list of words this lint should not consider as identifiers needing ticks. The value\n `\"..\"` can be used as part of the list to indicate, that the configured values should be appended to the\n-default configuration of Clippy. By default any configuraction will replace the default value. For example:\n+default configuration of Clippy. By default, any configuration will replace the default value. For example:\n * `doc-valid-idents = [\"ClipPy\"]` would replace the default list with `[\"ClipPy\"]`.\n * `doc-valid-idents = [\"ClipPy\", \"..\"]` would append `ClipPy` to the default list.\n \n@@ -413,7 +415,7 @@ For internal testing only, ignores the current `publish` settings in the Cargo m\n Enforce the named macros always use the braces specified.\n \n A `MacroMatcher` can be added like so `{ name = \"macro_name\", brace = \"(\" }`. If the macro\n-is could be used with a full path two `MacroMatcher`s have to be added one with the full path\n+could be used with a full path two `MacroMatcher`s have to be added one with the full path\n `crate_name::macro_name` and one with just the macro name.\n \n **Default Value:** `[]` (`Vec<crate::nonstandard_macro_braces::MacroMatcher>`)\n@@ -447,7 +449,7 @@ Whether to apply the raw pointer heuristic to determine if a type is `Send`.\n \n ### max-suggested-slice-pattern-length\n When Clippy suggests using a slice pattern, this is the maximum number of elements allowed in\n-the slice pattern that is suggested. If more elements would be necessary, the lint is suppressed.\n+the slice pattern that is suggested. If more elements are necessary, the lint is suppressed.\n For example, `[_, _, _, e, ..]` is a slice pattern with 4 elements.\n \n **Default Value:** `3` (`u64`)\n@@ -551,4 +553,12 @@ crate. For example, `pub(crate)` items.\n * [missing_docs_in_private_items](https://rust-lang.github.io/rust-clippy/master/index.html#missing_docs_in_private_items)\n \n \n+### future-size-threshold\n+The maximum byte size a `Future` can have, before it triggers the `clippy::large_futures` lint\n+\n+**Default Value:** `16384` (`u64`)\n+\n+* [large_futures](https://rust-lang.github.io/rust-clippy/master/index.html#large_futures)\n+\n+\n "}, {"sha": "442dc63914e9dafb8df2202369e8a88bab406662", "filename": "book/src/lints.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Flints.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Flints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Flints.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -17,7 +17,7 @@ The different lint groups were defined in the [Clippy 1.0 RFC].\n The `clippy::correctness` group is the only lint group in Clippy which lints are\n deny-by-default and abort the compilation when triggered. This is for good\n reason: If you see a `correctness` lint, it means that your code is outright\n-wrong or useless and you should try to fix it.\n+wrong or useless, and you should try to fix it.\n \n Lints in this category are carefully picked and should be free of false\n positives. So just `#[allow]`ing those lints is not recommended.\n@@ -41,7 +41,7 @@ simplify your code. It mostly focuses on code that can be written in a shorter\n and more readable way, while preserving the semantics.\n \n If you should see a complexity lint, it usually means that you can remove or\n-replace some code and it is recommended to do so. However, if you need the more\n+replace some code, and it is recommended to do so. However, if you need the more\n complex code for some expressiveness reason, it is recommended to allow\n complexity lints on a case-by-case basis.\n \n@@ -50,9 +50,9 @@ complexity lints on a case-by-case basis.\n The `clippy::perf` group gives you suggestions on how you can increase the\n performance of your code. Those lints are mostly about code that the compiler\n can't trivially optimize, but has to be written in a slightly different way to\n-make the optimizer's job easier.\n+make the optimizer job easier.\n \n-Perf lints are usually easy to apply and it is recommended to do so.\n+Perf lints are usually easy to apply, and it is recommended to do so.\n \n ## Style\n \n@@ -91,7 +91,7 @@ and your use case.\n \n Lints from this group will restrict you in some way. If you enable a restriction\n lint for your crate it is recommended to also fix code that this lint triggers\n-on. However, those lints are really strict by design and you might want to\n+on. However, those lints are really strict by design, and you might want to\n `#[allow]` them in some special cases, with a comment justifying that.\n \n ## Cargo"}, {"sha": "32084a9199b7327213fd04f5d0339d87b44166dc", "filename": "book/src/usage.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fusage.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/book%2Fsrc%2Fusage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fusage.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -19,7 +19,7 @@ cargo clippy\n ### Lint configuration\n \n The above command will run the default set of lints, which are included in the\n-lint group `clippy::all`. You might want to use even more lints or you might not\n+lint group `clippy::all`. You might want to use even more lints, or you may not\n agree with every Clippy lint, and for that there are ways to configure lint\n levels.\n \n@@ -98,7 +98,7 @@ other of Clippy's lint groups.\n You can configure lint levels in source code the same way you can configure\n `rustc` lints:\n \n-```rust\n+```rust,ignore\n #![allow(clippy::style)]\n \n #[warn(clippy::double_neg)]"}, {"sha": "3a8b070d735160de7c23225b6b438a82cd9a3857", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,3 +1,4 @@\n+#![feature(lazy_cell)]\n #![feature(let_chains)]\n #![feature(rustc_private)]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]"}, {"sha": "13a2770342781a3b5892cb0a5583a01184f39b6b", "filename": "clippy_dev/src/new_lint.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fnew_lint.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -369,9 +369,7 @@ fn create_lint_for_ty(lint: &LintData<'_>, enable_msrv: bool, ty: &str) -> io::R\n                     }}\n                     todo!();\n                 }}\n-           \"#,\n-            context_import = context_import,\n-            name_upper = name_upper,\n+           \"#\n         );\n     } else {\n         let _: fmt::Result = writedoc!(\n@@ -385,9 +383,7 @@ fn create_lint_for_ty(lint: &LintData<'_>, enable_msrv: bool, ty: &str) -> io::R\n                 pub(super) fn check(cx: &{context_import}) {{\n                     todo!();\n                 }}\n-           \"#,\n-            context_import = context_import,\n-            name_upper = name_upper,\n+           \"#\n         );\n     }\n "}, {"sha": "95222a9acdfc53305efcf717d6f792a872bbe2f8", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -537,17 +537,13 @@ fn declare_deprecated(name: &str, path: &Path, reason: &str) -> io::Result<()> {\n             /// Nothing. This lint has been deprecated.\n             ///\n             /// ### Deprecation reason\n-            /// {}\n-            #[clippy::version = \\\"{}\\\"]\n-            pub {},\n-            \\\"{}\\\"\n+            /// {deprecation_reason}\n+            #[clippy::version = \\\"{version}\\\"]\n+            pub {name},\n+            \\\"{reason}\\\"\n         }}\n \n-        \",\n-        deprecation_reason,\n-        version,\n-        name,\n-        reason,\n+        \"\n     )\n }\n "}, {"sha": "5c6040f63f50f336dbc0f44ad521407bf4db26de", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -9,6 +9,7 @@ keywords = [\"clippy\", \"lint\", \"plugin\"]\n edition = \"2021\"\n \n [dependencies]\n+arrayvec = { version = \"0.7\", default-features = false }\n cargo_metadata = \"0.15.3\"\n clippy_utils = { path = \"../clippy_utils\" }\n declare_clippy_lint = { path = \"../declare_clippy_lint\" }\n@@ -19,7 +20,7 @@ quine-mc_cluskey = \"0.2\"\n regex-syntax = \"0.6\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = { version = \"1.0\", optional = true }\n-tempfile = { version = \"3.2\", optional = true }\n+tempfile = { version = \"3.3.0\", optional = true }\n toml = \"0.5\"\n unicode-normalization = \"0.1\"\n unicode-script = { version = \"0.5\", default-features = false }"}, {"sha": "569bf27c3e716e13e3802e7e4cd6fe8bab627135", "filename": "clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -85,8 +85,7 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n                             );\n                         }\n                     } else {\n-                        let span =\n-                            block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n+                        let span = block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n                         if span.from_expansion() || expr.span.from_expansion() {\n                             return;\n                         }"}, {"sha": "455f0df7cd0adcc3ab2d8728138e212a34fd9a31", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -7,7 +7,7 @@ use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n use rustc_hir::{BinOpKind, Body, Expr, ExprKind, FnDecl, UnOp};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, Level};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map::Span;\n@@ -430,23 +430,25 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                 }\n             }\n             let nonminimal_bool_lint = |suggestions: Vec<_>| {\n-                span_lint_hir_and_then(\n-                    self.cx,\n-                    NONMINIMAL_BOOL,\n-                    e.hir_id,\n-                    e.span,\n-                    \"this boolean expression can be simplified\",\n-                    |diag| {\n-                        diag.span_suggestions(\n-                            e.span,\n-                            \"try\",\n-                            suggestions.into_iter(),\n-                            // nonminimal_bool can produce minimal but\n-                            // not human readable expressions (#3141)\n-                            Applicability::Unspecified,\n-                        );\n-                    },\n-                );\n+                if self.cx.tcx.lint_level_at_node(NONMINIMAL_BOOL, e.hir_id).0 != Level::Allow {\n+                    span_lint_hir_and_then(\n+                        self.cx,\n+                        NONMINIMAL_BOOL,\n+                        e.hir_id,\n+                        e.span,\n+                        \"this boolean expression can be simplified\",\n+                        |diag| {\n+                            diag.span_suggestions(\n+                                e.span,\n+                                \"try\",\n+                                suggestions.into_iter(),\n+                                // nonminimal_bool can produce minimal but\n+                                // not human readable expressions (#3141)\n+                                Applicability::Unspecified,\n+                            );\n+                        },\n+                    );\n+                }\n             };\n             if improvements.is_empty() {\n                 let mut visitor = NotSimplificationVisitor { cx: self.cx };\n@@ -498,6 +500,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NotSimplificationVisitor<'a, 'tcx> {\n         if let ExprKind::Unary(UnOp::Not, inner) = &expr.kind &&\n             !inner.span.from_expansion() &&\n             let Some(suggestion) = simplify_not(self.cx, inner)\n+\t\t\t&& self.cx.tcx.lint_level_at_node(NONMINIMAL_BOOL, expr.hir_id).0 != Level::Allow\n         {\n             span_lint_and_sugg(\n                 self.cx,"}, {"sha": "95c2ecbf791b5a5262cf308e4ce3338a9a763dd2", "filename": "clippy_lints/src/casts/cast_possible_truncation.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -2,8 +2,9 @@ use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use clippy_utils::expr_or_init;\n use clippy_utils::source::snippet;\n+use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{get_discriminant_value, is_isize_or_usize};\n-use rustc_errors::{Applicability, SuggestionStyle};\n+use rustc_errors::{Applicability, Diagnostic, SuggestionStyle};\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::LateContext;\n@@ -163,19 +164,34 @@ pub(super) fn check(\n         _ => return,\n     };\n \n-    let name_of_cast_from = snippet(cx, cast_expr.span, \"..\");\n-    let cast_to_snip = snippet(cx, cast_to_span, \"..\");\n-    let suggestion = format!(\"{cast_to_snip}::try_from({name_of_cast_from})\");\n-\n     span_lint_and_then(cx, CAST_POSSIBLE_TRUNCATION, expr.span, &msg, |diag| {\n         diag.help(\"if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\");\n-        diag.span_suggestion_with_style(\n-            expr.span,\n-            \"... or use `try_from` and handle the error accordingly\",\n-            suggestion,\n-            Applicability::Unspecified,\n-            // always show the suggestion in a separate line\n-            SuggestionStyle::ShowAlways,\n-        );\n+        if !cast_from.is_floating_point() {\n+            offer_suggestion(cx, expr, cast_expr, cast_to_span, diag);\n+        }\n     });\n }\n+\n+fn offer_suggestion(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    cast_expr: &Expr<'_>,\n+    cast_to_span: Span,\n+    diag: &mut Diagnostic,\n+) {\n+    let cast_to_snip = snippet(cx, cast_to_span, \"..\");\n+    let suggestion = if cast_to_snip == \"_\" {\n+        format!(\"{}.try_into()\", Sugg::hir(cx, cast_expr, \"..\").maybe_par())\n+    } else {\n+        format!(\"{cast_to_snip}::try_from({})\", Sugg::hir(cx, cast_expr, \"..\"))\n+    };\n+\n+    diag.span_suggestion_with_style(\n+        expr.span,\n+        \"... or use `try_from` and handle the error accordingly\",\n+        suggestion,\n+        Applicability::Unspecified,\n+        // always show the suggestion in a separate line\n+        SuggestionStyle::ShowAlways,\n+    );\n+}"}, {"sha": "b451055703354920f762a7b390405db2d262a61f", "filename": "clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -218,6 +218,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::iter_not_returning_iterator::ITER_NOT_RETURNING_ITERATOR_INFO,\n     crate::large_const_arrays::LARGE_CONST_ARRAYS_INFO,\n     crate::large_enum_variant::LARGE_ENUM_VARIANT_INFO,\n+    crate::large_futures::LARGE_FUTURES_INFO,\n     crate::large_include_file::LARGE_INCLUDE_FILE_INFO,\n     crate::large_stack_arrays::LARGE_STACK_ARRAYS_INFO,\n     crate::len_zero::COMPARISON_TO_EMPTY_INFO,\n@@ -231,6 +232,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::let_with_type_underscore::LET_WITH_TYPE_UNDERSCORE_INFO,\n     crate::lifetimes::EXTRA_UNUSED_LIFETIMES_INFO,\n     crate::lifetimes::NEEDLESS_LIFETIMES_INFO,\n+    crate::lines_filter_map_ok::LINES_FILTER_MAP_OK_INFO,\n     crate::literal_representation::DECIMAL_LITERAL_REPRESENTATION_INFO,\n     crate::literal_representation::INCONSISTENT_DIGIT_GROUPING_INFO,\n     crate::literal_representation::LARGE_DIGIT_GROUPS_INFO,\n@@ -307,6 +309,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::methods::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS_INFO,\n     crate::methods::CHARS_LAST_CMP_INFO,\n     crate::methods::CHARS_NEXT_CMP_INFO,\n+    crate::methods::CLEAR_WITH_DRAIN_INFO,\n     crate::methods::CLONED_INSTEAD_OF_COPIED_INFO,\n     crate::methods::CLONE_DOUBLE_REF_INFO,\n     crate::methods::CLONE_ON_COPY_INFO,\n@@ -574,6 +577,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::swap_ptr_to_ref::SWAP_PTR_TO_REF_INFO,\n     crate::tabs_in_doc_comments::TABS_IN_DOC_COMMENTS_INFO,\n     crate::temporary_assignment::TEMPORARY_ASSIGNMENT_INFO,\n+    crate::tests_outside_test_module::TESTS_OUTSIDE_TEST_MODULE_INFO,\n     crate::to_digit_is_some::TO_DIGIT_IS_SOME_INFO,\n     crate::trailing_empty_array::TRAILING_EMPTY_ARRAY_INFO,\n     crate::trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS_INFO,\n@@ -616,6 +620,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::unit_types::UNIT_CMP_INFO,\n     crate::unnamed_address::FN_ADDRESS_COMPARISONS_INFO,\n     crate::unnamed_address::VTABLE_ADDRESS_COMPARISONS_INFO,\n+    crate::unnecessary_box_returns::UNNECESSARY_BOX_RETURNS_INFO,\n     crate::unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS_INFO,\n     crate::unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS_INFO,\n     crate::unnecessary_struct_initialization::UNNECESSARY_STRUCT_INITIALIZATION_INFO,"}, {"sha": "c9fad98e43730c167a281aeaaec3e9fbafb3f4f5", "filename": "clippy_lints/src/disallowed_script_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fdisallowed_script_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fdisallowed_script_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_script_idents.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -32,7 +32,7 @@ declare_clippy_lint! {\n     /// ### Example\n     /// ```rust\n     /// // Assuming that `clippy.toml` contains the following line:\n-    /// // allowed-locales = [\"Latin\", \"Cyrillic\"]\n+    /// // allowed-scripts = [\"Latin\", \"Cyrillic\"]\n     /// let counter = 10; // OK, latin is allowed.\n     /// let \u0441\u0447\u0451\u0442\u0447\u0438\u043a = 10; // OK, cyrillic is allowed.\n     /// let z\u00e4hler = 10; // OK, it's still latin."}, {"sha": "315df6c714ffc4681d7189552347f773c4bca68f", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::macros::FormatArgsExpn;\n+use clippy_utils::macros::{find_format_args, format_args_inputs_span};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{is_expn_of, match_function_call, paths};\n use if_chain::if_chain;\n@@ -8,7 +8,7 @@ use rustc_hir::def::Res;\n use rustc_hir::{BindingAnnotation, Block, BlockCheckMode, Expr, ExprKind, Node, PatKind, QPath, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n+use rustc_span::{sym, ExpnId};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -43,23 +43,22 @@ declare_lint_pass!(ExplicitWrite => [EXPLICIT_WRITE]);\n \n impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            // match call to unwrap\n-            if let ExprKind::MethodCall(unwrap_fun, write_call, [], _) = expr.kind;\n-            if unwrap_fun.ident.name == sym::unwrap;\n+        // match call to unwrap\n+        if let ExprKind::MethodCall(unwrap_fun, write_call, [], _) = expr.kind\n+            && unwrap_fun.ident.name == sym::unwrap\n             // match call to write_fmt\n-            if let ExprKind::MethodCall(write_fun, write_recv, [write_arg], _) = look_in_block(cx, &write_call.kind);\n-            if write_fun.ident.name == sym!(write_fmt);\n+            && let ExprKind::MethodCall(write_fun, write_recv, [write_arg], _) = look_in_block(cx, &write_call.kind)\n+            && write_fun.ident.name == sym!(write_fmt)\n             // match calls to std::io::stdout() / std::io::stderr ()\n-            if let Some(dest_name) = if match_function_call(cx, write_recv, &paths::STDOUT).is_some() {\n+            && let Some(dest_name) = if match_function_call(cx, write_recv, &paths::STDOUT).is_some() {\n                 Some(\"stdout\")\n             } else if match_function_call(cx, write_recv, &paths::STDERR).is_some() {\n                 Some(\"stderr\")\n             } else {\n                 None\n-            };\n-            if let Some(format_args) = FormatArgsExpn::parse(cx, write_arg);\n-            then {\n+            }\n+        {\n+            find_format_args(cx, write_arg, ExpnId::root(), |format_args| {\n                 let calling_macro =\n                     // ordering is important here, since `writeln!` uses `write!` internally\n                     if is_expn_of(write_call.span, \"writeln\").is_some() {\n@@ -92,7 +91,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let inputs_snippet = snippet_with_applicability(\n                     cx,\n-                    format_args.inputs_span(),\n+                    format_args_inputs_span(format_args),\n                     \"..\",\n                     &mut applicability,\n                 );\n@@ -104,8 +103,8 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n                     \"try this\",\n                     format!(\"{prefix}{sugg_mac}!({inputs_snippet})\"),\n                     applicability,\n-                )\n-            }\n+                );\n+            });\n         }\n     }\n }"}, {"sha": "eeb4de8b58f484557079b9bf6674195b033254cd", "filename": "clippy_lints/src/extra_unused_type_parameters.rs", "status": "modified", "additions": 117, "deletions": 60, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fextra_unused_type_parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fextra_unused_type_parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fextra_unused_type_parameters.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,10 +1,10 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::trait_ref_of_method;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::MultiSpan;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_impl_item, walk_item, walk_param_bound, walk_ty, Visitor};\n use rustc_hir::{\n-    BodyId, ExprKind, GenericBound, GenericParamKind, Generics, ImplItem, ImplItemKind, Item, ItemKind,\n+    BodyId, ExprKind, GenericBound, GenericParam, GenericParamKind, Generics, ImplItem, ImplItemKind, Item, ItemKind,\n     PredicateOrigin, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -53,13 +53,19 @@ impl ExtraUnusedTypeParameters {\n         }\n     }\n \n-    /// Don't lint external macros or functions with empty bodies. Also, don't lint public items if\n-    /// the `avoid_breaking_exported_api` config option is set.\n-    fn check_false_positive(&self, cx: &LateContext<'_>, span: Span, def_id: LocalDefId, body_id: BodyId) -> bool {\n+    /// Don't lint external macros or functions with empty bodies. Also, don't lint exported items\n+    /// if the `avoid_breaking_exported_api` config option is set.\n+    fn is_empty_exported_or_macro(\n+        &self,\n+        cx: &LateContext<'_>,\n+        span: Span,\n+        def_id: LocalDefId,\n+        body_id: BodyId,\n+    ) -> bool {\n         let body = cx.tcx.hir().body(body_id).value;\n         let fn_empty = matches!(&body.kind, ExprKind::Block(blk, None) if blk.stmts.is_empty() && blk.expr.is_none());\n         let is_exported = cx.effective_visibilities.is_exported(def_id);\n-        in_external_macro(cx.sess(), span) || (self.avoid_breaking_exported_api && is_exported) || fn_empty\n+        in_external_macro(cx.sess(), span) || fn_empty || (is_exported && self.avoid_breaking_exported_api)\n     }\n }\n \n@@ -69,85 +75,129 @@ impl_lint_pass!(ExtraUnusedTypeParameters => [EXTRA_UNUSED_TYPE_PARAMETERS]);\n /// trait bounds those parameters have.\n struct TypeWalker<'cx, 'tcx> {\n     cx: &'cx LateContext<'tcx>,\n-    /// Collection of all the function's type parameters.\n+    /// Collection of the function's type parameters. Once the function has been walked, this will\n+    /// contain only unused type parameters.\n     ty_params: FxHashMap<DefId, Span>,\n-    /// Collection of any (inline) trait bounds corresponding to each type parameter.\n-    bounds: FxHashMap<DefId, Span>,\n+    /// Collection of any inline trait bounds corresponding to each type parameter.\n+    inline_bounds: FxHashMap<DefId, Span>,\n+    /// Collection of any type parameters with trait bounds that appear in a where clause.\n+    where_bounds: FxHashSet<DefId>,\n     /// The entire `Generics` object of the function, useful for querying purposes.\n     generics: &'tcx Generics<'tcx>,\n-    /// The value of this will remain `true` if *every* parameter:\n-    ///   1. Is a type parameter, and\n-    ///   2. Goes unused in the function.\n-    /// Otherwise, if any type parameters end up being used, or if any lifetime or const-generic\n-    /// parameters are present, this will be set to `false`.\n-    all_params_unused: bool,\n }\n \n impl<'cx, 'tcx> TypeWalker<'cx, 'tcx> {\n     fn new(cx: &'cx LateContext<'tcx>, generics: &'tcx Generics<'tcx>) -> Self {\n-        let mut all_params_unused = true;\n         let ty_params = generics\n             .params\n             .iter()\n-            .filter_map(|param| {\n-                if let GenericParamKind::Type { synthetic, .. } = param.kind {\n-                    (!synthetic).then_some((param.def_id.into(), param.span))\n-                } else {\n-                    if !param.is_elided_lifetime() {\n-                        all_params_unused = false;\n-                    }\n-                    None\n-                }\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Type { synthetic, .. } if !synthetic => Some((param.def_id.into(), param.span)),\n+                _ => None,\n             })\n             .collect();\n \n         Self {\n             cx,\n             ty_params,\n-            bounds: FxHashMap::default(),\n+            inline_bounds: FxHashMap::default(),\n+            where_bounds: FxHashSet::default(),\n             generics,\n-            all_params_unused,\n         }\n     }\n \n-    fn mark_param_used(&mut self, def_id: DefId) {\n-        if self.ty_params.remove(&def_id).is_some() {\n-            self.all_params_unused = false;\n-        }\n+    fn get_bound_span(&self, param: &'tcx GenericParam<'tcx>) -> Span {\n+        self.inline_bounds\n+            .get(&param.def_id.to_def_id())\n+            .map_or(param.span, |bound_span| param.span.with_hi(bound_span.hi()))\n+    }\n+\n+    fn emit_help(&self, spans: Vec<Span>, msg: &str, help: &'static str) {\n+        span_lint_and_help(self.cx, EXTRA_UNUSED_TYPE_PARAMETERS, spans, msg, None, help);\n+    }\n+\n+    fn emit_sugg(&self, spans: Vec<Span>, msg: &str, help: &'static str) {\n+        let suggestions: Vec<(Span, String)> = spans.iter().copied().zip(std::iter::repeat(String::new())).collect();\n+        span_lint_and_then(self.cx, EXTRA_UNUSED_TYPE_PARAMETERS, spans, msg, |diag| {\n+            diag.multipart_suggestion(help, suggestions, Applicability::MachineApplicable);\n+        });\n     }\n \n     fn emit_lint(&self) {\n-        let (msg, help) = match self.ty_params.len() {\n+        let explicit_params = self\n+            .generics\n+            .params\n+            .iter()\n+            .filter(|param| !param.is_elided_lifetime() && !param.is_impl_trait())\n+            .collect::<Vec<_>>();\n+\n+        let extra_params = explicit_params\n+            .iter()\n+            .enumerate()\n+            .filter(|(_, param)| self.ty_params.contains_key(&param.def_id.to_def_id()))\n+            .collect::<Vec<_>>();\n+\n+        let (msg, help) = match extra_params.len() {\n             0 => return,\n             1 => (\n-                \"type parameter goes unused in function definition\",\n+                format!(\n+                    \"type parameter `{}` goes unused in function definition\",\n+                    extra_params[0].1.name.ident()\n+                ),\n                 \"consider removing the parameter\",\n             ),\n             _ => (\n-                \"type parameters go unused in function definition\",\n+                format!(\n+                    \"type parameters go unused in function definition: {}\",\n+                    extra_params\n+                        .iter()\n+                        .map(|(_, param)| param.name.ident().to_string())\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")\n+                ),\n                 \"consider removing the parameters\",\n             ),\n         };\n \n-        let source_map = self.cx.sess().source_map();\n-        let span = if self.all_params_unused {\n-            self.generics.span.into() // Remove the entire list of generics\n+        // If any parameters are bounded in where clauses, don't try to form a suggestion.\n+        // Otherwise, the leftover where bound would produce code that wouldn't compile.\n+        if extra_params\n+            .iter()\n+            .any(|(_, param)| self.where_bounds.contains(&param.def_id.to_def_id()))\n+        {\n+            let spans = extra_params\n+                .iter()\n+                .map(|(_, param)| self.get_bound_span(param))\n+                .collect::<Vec<_>>();\n+            self.emit_help(spans, &msg, help);\n         } else {\n-            MultiSpan::from_spans(\n-                self.ty_params\n+            let spans = if explicit_params.len() == extra_params.len() {\n+                vec![self.generics.span] // Remove the entire list of generics\n+            } else {\n+                let mut end: Option<LocalDefId> = None;\n+                extra_params\n                     .iter()\n-                    .map(|(def_id, &span)| {\n-                        // Extend the span past any trait bounds, and include the comma at the end.\n-                        let span_to_extend = self.bounds.get(def_id).copied().map_or(span, Span::shrink_to_hi);\n-                        let comma_range = source_map.span_extend_to_next_char(span_to_extend, '>', false);\n-                        let comma_span = source_map.span_through_char(comma_range, ',');\n-                        span.with_hi(comma_span.hi())\n+                    .rev()\n+                    .map(|(idx, param)| {\n+                        if let Some(next) = explicit_params.get(idx + 1) && end != Some(next.def_id) {\n+                        // Extend the current span forward, up until the next param in the list.\n+                        param.span.until(next.span)\n+                    } else {\n+                        // Extend the current span back to include the comma following the previous\n+                        // param. If the span of the next param in the list has already been\n+                        // extended, we continue the chain. This is why we're iterating in reverse.\n+                        end = Some(param.def_id);\n+\n+                        // idx will never be 0, else we'd be removing the entire list of generics\n+                        let prev = explicit_params[idx - 1];\n+                        let prev_span = self.get_bound_span(prev);\n+                        self.get_bound_span(param).with_lo(prev_span.hi())\n+                    }\n                     })\n-                    .collect(),\n-            )\n+                    .collect()\n+            };\n+            self.emit_sugg(spans, &msg, help);\n         };\n-\n-        span_lint_and_help(self.cx, EXTRA_UNUSED_TYPE_PARAMETERS, span, msg, None, help);\n     }\n }\n \n@@ -162,7 +212,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for TypeWalker<'cx, 'tcx> {\n \n     fn visit_ty(&mut self, t: &'tcx Ty<'tcx>) {\n         if let Some((def_id, _)) = t.peel_refs().as_generic_param() {\n-            self.mark_param_used(def_id);\n+            self.ty_params.remove(&def_id);\n         } else if let TyKind::OpaqueDef(id, _, _) = t.kind {\n             // Explicitly walk OpaqueDef. Normally `walk_ty` would do the job, but it calls\n             // `visit_nested_item`, which checks that `Self::NestedFilter::INTER` is set. We're\n@@ -176,9 +226,18 @@ impl<'cx, 'tcx> Visitor<'tcx> for TypeWalker<'cx, 'tcx> {\n \n     fn visit_where_predicate(&mut self, predicate: &'tcx WherePredicate<'tcx>) {\n         if let WherePredicate::BoundPredicate(predicate) = predicate {\n-            // Collect spans for any bounds on type parameters. We only keep bounds that appear in\n-            // the list of generics (not in a where-clause).\n+            // Collect spans for any bounds on type parameters.\n             if let Some((def_id, _)) = predicate.bounded_ty.peel_refs().as_generic_param() {\n+                match predicate.origin {\n+                    PredicateOrigin::GenericParam => {\n+                        self.inline_bounds.insert(def_id, predicate.span);\n+                    },\n+                    PredicateOrigin::WhereClause => {\n+                        self.where_bounds.insert(def_id);\n+                    },\n+                    PredicateOrigin::ImplTrait => (),\n+                }\n+\n                 // If the bound contains non-public traits, err on the safe side and don't lint the\n                 // corresponding parameter.\n                 if !predicate\n@@ -187,12 +246,10 @@ impl<'cx, 'tcx> Visitor<'tcx> for TypeWalker<'cx, 'tcx> {\n                     .filter_map(bound_to_trait_def_id)\n                     .all(|id| self.cx.effective_visibilities.is_exported(id))\n                 {\n-                    self.mark_param_used(def_id);\n-                } else if let PredicateOrigin::GenericParam = predicate.origin {\n-                    self.bounds.insert(def_id, predicate.span);\n+                    self.ty_params.remove(&def_id);\n                 }\n             }\n-            // Only walk the right-hand side of where-bounds\n+            // Only walk the right-hand side of where bounds\n             for bound in predicate.bounds {\n                 walk_param_bound(self, bound);\n             }\n@@ -207,7 +264,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for TypeWalker<'cx, 'tcx> {\n impl<'tcx> LateLintPass<'tcx> for ExtraUnusedTypeParameters {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n         if let ItemKind::Fn(_, generics, body_id) = item.kind\n-            && !self.check_false_positive(cx, item.span, item.owner_id.def_id, body_id)\n+            && !self.is_empty_exported_or_macro(cx, item.span, item.owner_id.def_id, body_id)\n         {\n             let mut walker = TypeWalker::new(cx, generics);\n             walk_item(&mut walker, item);\n@@ -219,7 +276,7 @@ impl<'tcx> LateLintPass<'tcx> for ExtraUnusedTypeParameters {\n         // Only lint on inherent methods, not trait methods.\n         if let ImplItemKind::Fn(.., body_id) = item.kind\n             && trait_ref_of_method(cx, item.owner_id.def_id).is_none()\n-            && !self.check_false_positive(cx, item.span, item.owner_id.def_id, body_id)\n+            && !self.is_empty_exported_or_macro(cx, item.span, item.owner_id.def_id, body_id)\n         {\n             let mut walker = TypeWalker::new(cx, item.generics);\n             walk_impl_item(&mut walker, item);"}, {"sha": "d34d6e9279e4dde86fff5f9f0c5d82cec7685471", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 44, "deletions": 47, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,14 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn};\n-use clippy_utils::source::snippet_with_context;\n+use clippy_utils::macros::{find_format_arg_expr, find_format_args, root_macro_call_first_node};\n+use clippy_utils::source::{snippet_opt, snippet_with_context};\n use clippy_utils::sugg::Sugg;\n-use if_chain::if_chain;\n+use rustc_ast::{FormatArgsPiece, FormatOptions, FormatTrait};\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::kw;\n use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n@@ -44,55 +43,53 @@ declare_lint_pass!(UselessFormat => [USELESS_FORMAT]);\n \n impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let (format_args, call_site) = if_chain! {\n-            if let Some(macro_call) = root_macro_call_first_node(cx, expr);\n-            if cx.tcx.is_diagnostic_item(sym::format_macro, macro_call.def_id);\n-            if let Some(format_args) = FormatArgsExpn::find_nested(cx, expr, macro_call.expn);\n-            then {\n-                (format_args, macro_call.span)\n-            } else {\n-                return\n-            }\n-        };\n+        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return };\n+        if !cx.tcx.is_diagnostic_item(sym::format_macro, macro_call.def_id) {\n+            return;\n+        }\n+\n+        find_format_args(cx, expr, macro_call.expn, |format_args| {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let call_site = macro_call.span;\n \n-        let mut applicability = Applicability::MachineApplicable;\n-        if format_args.args.is_empty() {\n-            match *format_args.format_string.parts {\n-                [] => span_useless_format_empty(cx, call_site, \"String::new()\".to_owned(), applicability),\n-                [_] => {\n+            match (format_args.arguments.all_args(), &format_args.template[..]) {\n+                ([], []) => span_useless_format_empty(cx, call_site, \"String::new()\".to_owned(), applicability),\n+                ([], [_]) => {\n                     // Simulate macro expansion, converting {{ and }} to { and }.\n-                    let s_expand = format_args.format_string.snippet.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n+                    let Some(snippet) = snippet_opt(cx, format_args.span) else { return };\n+                    let s_expand = snippet.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n                     let sugg = format!(\"{s_expand}.to_string()\");\n                     span_useless_format(cx, call_site, sugg, applicability);\n                 },\n-                [..] => {},\n-            }\n-        } else if let [arg] = &*format_args.args {\n-            let value = arg.param.value;\n-            if_chain! {\n-                if format_args.format_string.parts == [kw::Empty];\n-                if arg.format.is_default();\n-                if match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n-                    ty::Adt(adt, _) => Some(adt.did()) == cx.tcx.lang_items().string(),\n-                    ty::Str => true,\n-                    _ => false,\n-                };\n-                then {\n-                    let is_new_string = match value.kind {\n-                        ExprKind::Binary(..) => true,\n-                        ExprKind::MethodCall(path, ..) => path.ident.name == sym::to_string,\n-                        _ => false,\n-                    };\n-                    let sugg = if is_new_string {\n-                        snippet_with_context(cx, value.span, call_site.ctxt(), \"..\", &mut applicability).0.into_owned()\n-                    } else {\n-                        let sugg = Sugg::hir_with_context(cx, value, call_site.ctxt(), \"<arg>\", &mut applicability);\n-                        format!(\"{}.to_string()\", sugg.maybe_par())\n-                    };\n-                    span_useless_format(cx, call_site, sugg, applicability);\n-                }\n+                ([arg], [piece]) => {\n+                    if let Ok(value) = find_format_arg_expr(expr, arg)\n+                        && let FormatArgsPiece::Placeholder(placeholder) = piece\n+                        && placeholder.format_trait == FormatTrait::Display\n+                        && placeholder.format_options == FormatOptions::default()\n+                        && match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n+                            ty::Adt(adt, _) => Some(adt.did()) == cx.tcx.lang_items().string(),\n+                            ty::Str => true,\n+                            _ => false,\n+                        }\n+                    {\n+                        let is_new_string = match value.kind {\n+                            ExprKind::Binary(..) => true,\n+                            ExprKind::MethodCall(path, ..) => path.ident.name == sym::to_string,\n+                            _ => false,\n+                        };\n+                        let sugg = if is_new_string {\n+                            snippet_with_context(cx, value.span, call_site.ctxt(), \"..\", &mut applicability).0.into_owned()\n+                        } else {\n+                            let sugg = Sugg::hir_with_context(cx, value, call_site.ctxt(), \"<arg>\", &mut applicability);\n+                            format!(\"{}.to_string()\", sugg.maybe_par())\n+                        };\n+                        span_useless_format(cx, call_site, sugg, applicability);\n+\n+                    }\n+                },\n+                _ => {},\n             }\n-        };\n+        });\n     }\n }\n "}, {"sha": "08e45ed7d0ec8e45a08f1bcc9cdff0630e82354a", "filename": "clippy_lints/src/format_args.rs", "status": "modified", "additions": 132, "deletions": 92, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_args.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,27 +1,31 @@\n+use arrayvec::ArrayVec;\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::is_diag_trait_item;\n-use clippy_utils::macros::FormatParamKind::{Implicit, Named, NamedInline, Numbered, Starred};\n use clippy_utils::macros::{\n-    is_assert_macro, is_format_macro, is_panic, root_macro_call, Count, FormatArg, FormatArgsExpn, FormatParam,\n-    FormatParamUsage,\n+    find_format_arg_expr, find_format_args, format_arg_removal_span, format_placeholder_format_span, is_assert_macro,\n+    is_format_macro, is_panic, root_macro_call, root_macro_call_first_node, FormatParamUsage,\n };\n use clippy_utils::msrvs::{self, Msrv};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{implements_trait, is_type_lang_item};\n use if_chain::if_chain;\n use itertools::Itertools;\n+use rustc_ast::{\n+    FormatArgPosition, FormatArgPositionKind, FormatArgsPiece, FormatArgumentKind, FormatCount, FormatOptions,\n+    FormatPlaceholder, FormatTrait,\n+};\n use rustc_errors::{\n     Applicability,\n     SuggestionStyle::{CompletelyHidden, ShowCode},\n };\n-use rustc_hir::{Expr, ExprKind, HirId, LangItem, QPath};\n+use rustc_hir::{Expr, ExprKind, LangItem};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_middle::ty::Ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::def_id::DefId;\n use rustc_span::edition::Edition::Edition2021;\n-use rustc_span::{sym, ExpnData, ExpnKind, Span, Symbol};\n+use rustc_span::{sym, Span, Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -184,111 +188,120 @@ impl FormatArgs {\n \n impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if let Some(format_args) = FormatArgsExpn::parse(cx, expr)\n-            && let expr_expn_data = expr.span.ctxt().outer_expn_data()\n-            && let outermost_expn_data = outermost_expn_data(expr_expn_data)\n-            && let Some(macro_def_id) = outermost_expn_data.macro_def_id\n-            && is_format_macro(cx, macro_def_id)\n-            && let ExpnKind::Macro(_, name) = outermost_expn_data.kind\n-        {\n-            for arg in &format_args.args {\n-                check_unused_format_specifier(cx, arg);\n-                if !arg.format.is_default() {\n-                    continue;\n-                }\n-                if is_aliased(&format_args, arg.param.value.hir_id) {\n-                    continue;\n+        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return };\n+        if !is_format_macro(cx, macro_call.def_id) {\n+            return;\n+        }\n+        let name = cx.tcx.item_name(macro_call.def_id);\n+\n+        find_format_args(cx, expr, macro_call.expn, |format_args| {\n+            for piece in &format_args.template {\n+                if let FormatArgsPiece::Placeholder(placeholder) = piece\n+                    && let Ok(index) = placeholder.argument.index\n+                    && let Some(arg) = format_args.arguments.all_args().get(index)\n+                {\n+                    let arg_expr = find_format_arg_expr(expr, arg);\n+\n+                    check_unused_format_specifier(cx, placeholder, arg_expr);\n+\n+                    if placeholder.format_trait != FormatTrait::Display\n+                        || placeholder.format_options != FormatOptions::default()\n+                        || is_aliased(format_args, index)\n+                    {\n+                        continue;\n+                    }\n+\n+                    if let Ok(arg_hir_expr) = arg_expr {\n+                        check_format_in_format_args(cx, macro_call.span, name, arg_hir_expr);\n+                        check_to_string_in_format_args(cx, name, arg_hir_expr);\n+                    }\n                 }\n-                check_format_in_format_args(cx, outermost_expn_data.call_site, name, arg.param.value);\n-                check_to_string_in_format_args(cx, name, arg.param.value);\n             }\n+\n             if self.msrv.meets(msrvs::FORMAT_ARGS_CAPTURE) {\n-                check_uninlined_args(cx, &format_args, outermost_expn_data.call_site, macro_def_id, self.ignore_mixed);\n+                check_uninlined_args(cx, format_args, macro_call.span, macro_call.def_id, self.ignore_mixed);\n             }\n-        }\n+        });\n     }\n \n     extract_msrv_attr!(LateContext);\n }\n \n-fn check_unused_format_specifier(cx: &LateContext<'_>, arg: &FormatArg<'_>) {\n-    let param_ty = cx.typeck_results().expr_ty(arg.param.value).peel_refs();\n+fn check_unused_format_specifier(\n+    cx: &LateContext<'_>,\n+    placeholder: &FormatPlaceholder,\n+    arg_expr: Result<&Expr<'_>, &rustc_ast::Expr>,\n+) {\n+    let ty_or_ast_expr = arg_expr.map(|expr| cx.typeck_results().expr_ty(expr).peel_refs());\n \n-    if let Count::Implied(Some(mut span)) = arg.format.precision\n-        && !span.is_empty()\n-    {\n-        span_lint_and_then(\n-            cx,\n-            UNUSED_FORMAT_SPECS,\n-            span,\n-            \"empty precision specifier has no effect\",\n-            |diag| {\n-                if param_ty.is_floating_point() {\n-                    diag.note(\"a precision specifier is not required to format floats\");\n-                }\n+    let is_format_args = match ty_or_ast_expr {\n+        Ok(ty) => is_type_lang_item(cx, ty, LangItem::FormatArguments),\n+        Err(expr) => matches!(expr.peel_parens_and_refs().kind, rustc_ast::ExprKind::FormatArgs(_)),\n+    };\n \n-                if arg.format.is_default() {\n-                    // If there's no other specifiers remove the `:` too\n-                    span = arg.format_span();\n-                }\n+    let options = &placeholder.format_options;\n \n-                diag.span_suggestion_verbose(span, \"remove the `.`\", \"\", Applicability::MachineApplicable);\n-            },\n-        );\n-    }\n+    let arg_span = match arg_expr {\n+        Ok(expr) => expr.span,\n+        Err(expr) => expr.span,\n+    };\n \n-    if is_type_lang_item(cx, param_ty, LangItem::FormatArguments) && !arg.format.is_default_for_trait() {\n+    if let Some(placeholder_span) = placeholder.span\n+        && is_format_args\n+        && *options != FormatOptions::default()\n+    {\n         span_lint_and_then(\n             cx,\n             UNUSED_FORMAT_SPECS,\n-            arg.span,\n+            placeholder_span,\n             \"format specifiers have no effect on `format_args!()`\",\n             |diag| {\n-                let mut suggest_format = |spec, span| {\n+                let mut suggest_format = |spec| {\n                     let message = format!(\"for the {spec} to apply consider using `format!()`\");\n \n-                    if let Some(mac_call) = root_macro_call(arg.param.value.span)\n+                    if let Some(mac_call) = root_macro_call(arg_span)\n                         && cx.tcx.is_diagnostic_item(sym::format_args_macro, mac_call.def_id)\n-                        && arg.span.eq_ctxt(mac_call.span)\n                     {\n                         diag.span_suggestion(\n                             cx.sess().source_map().span_until_char(mac_call.span, '!'),\n                             message,\n                             \"format\",\n                             Applicability::MaybeIncorrect,\n                         );\n-                    } else if let Some(span) = span {\n-                        diag.span_help(span, message);\n+                    } else {\n+                        diag.help(message);\n                     }\n                 };\n \n-                if !arg.format.width.is_implied() {\n-                    suggest_format(\"width\", arg.format.width.span());\n+                if options.width.is_some() {\n+                    suggest_format(\"width\");\n                 }\n \n-                if !arg.format.precision.is_implied() {\n-                    suggest_format(\"precision\", arg.format.precision.span());\n+                if options.precision.is_some() {\n+                    suggest_format(\"precision\");\n                 }\n \n-                diag.span_suggestion_verbose(\n-                    arg.format_span(),\n-                    \"if the current behavior is intentional, remove the format specifiers\",\n-                    \"\",\n-                    Applicability::MaybeIncorrect,\n-                );\n+                if let Some(format_span) = format_placeholder_format_span(placeholder) {\n+                    diag.span_suggestion_verbose(\n+                        format_span,\n+                        \"if the current behavior is intentional, remove the format specifiers\",\n+                        \"\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n             },\n         );\n     }\n }\n \n fn check_uninlined_args(\n     cx: &LateContext<'_>,\n-    args: &FormatArgsExpn<'_>,\n+    args: &rustc_ast::FormatArgs,\n     call_site: Span,\n     def_id: DefId,\n     ignore_mixed: bool,\n ) {\n-    if args.format_string.span.from_expansion() {\n+    if args.span.from_expansion() {\n         return;\n     }\n     if call_site.edition() < Edition2021 && (is_panic(cx, def_id) || is_assert_macro(cx, def_id)) {\n@@ -303,7 +316,13 @@ fn check_uninlined_args(\n     // we cannot remove any other arguments in the format string,\n     // because the index numbers might be wrong after inlining.\n     // Example of an un-inlinable format:  print!(\"{}{1}\", foo, 2)\n-    if !args.params().all(|p| check_one_arg(args, &p, &mut fixes, ignore_mixed)) || fixes.is_empty() {\n+    for (pos, usage) in format_arg_positions(args) {\n+        if !check_one_arg(args, pos, usage, &mut fixes, ignore_mixed) {\n+            return;\n+        }\n+    }\n+\n+    if fixes.is_empty() {\n         return;\n     }\n \n@@ -332,47 +351,40 @@ fn check_uninlined_args(\n }\n \n fn check_one_arg(\n-    args: &FormatArgsExpn<'_>,\n-    param: &FormatParam<'_>,\n+    args: &rustc_ast::FormatArgs,\n+    pos: &FormatArgPosition,\n+    usage: FormatParamUsage,\n     fixes: &mut Vec<(Span, String)>,\n     ignore_mixed: bool,\n ) -> bool {\n-    if matches!(param.kind, Implicit | Starred | Named(_) | Numbered)\n-        && let ExprKind::Path(QPath::Resolved(None, path)) = param.value.kind\n-        && let [segment] = path.segments\n+    let index = pos.index.unwrap();\n+    let arg = &args.arguments.all_args()[index];\n+\n+    if !matches!(arg.kind, FormatArgumentKind::Captured(_))\n+        && let rustc_ast::ExprKind::Path(None, path) = &arg.expr.kind\n+        && let [segment] = path.segments.as_slice()\n         && segment.args.is_none()\n-        && let Some(arg_span) = args.value_with_prev_comma_span(param.value.hir_id)\n+        && let Some(arg_span) = format_arg_removal_span(args, index)\n+        && let Some(pos_span) = pos.span\n     {\n-        let replacement = match param.usage {\n+        let replacement = match usage {\n             FormatParamUsage::Argument => segment.ident.name.to_string(),\n             FormatParamUsage::Width => format!(\"{}$\", segment.ident.name),\n             FormatParamUsage::Precision => format!(\".{}$\", segment.ident.name),\n         };\n-        fixes.push((param.span, replacement));\n+        fixes.push((pos_span, replacement));\n         fixes.push((arg_span, String::new()));\n         true  // successful inlining, continue checking\n     } else {\n         // Do not continue inlining (return false) in case\n         // * if we can't inline a numbered argument, e.g. `print!(\"{0} ...\", foo.bar, ...)`\n         // * if allow_mixed_uninlined_format_args is false and this arg hasn't been inlined already\n-        param.kind != Numbered && (!ignore_mixed || matches!(param.kind, NamedInline(_)))\n-    }\n-}\n-\n-fn outermost_expn_data(expn_data: ExpnData) -> ExpnData {\n-    if expn_data.call_site.from_expansion() {\n-        outermost_expn_data(expn_data.call_site.ctxt().outer_expn_data())\n-    } else {\n-        expn_data\n+        pos.kind != FormatArgPositionKind::Number\n+            && (!ignore_mixed || matches!(arg.kind, FormatArgumentKind::Captured(_)))\n     }\n }\n \n-fn check_format_in_format_args(\n-    cx: &LateContext<'_>,\n-    call_site: Span,\n-    name: Symbol,\n-    arg: &Expr<'_>,\n-) {\n+fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symbol, arg: &Expr<'_>) {\n     let expn_data = arg.span.ctxt().outer_expn_data();\n     if expn_data.call_site.from_expansion() {\n         return;\n@@ -443,9 +455,33 @@ fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Ex\n     }\n }\n \n-/// Returns true if `hir_id` is referred to by multiple format params\n-fn is_aliased(args: &FormatArgsExpn<'_>, hir_id: HirId) -> bool {\n-    args.params().filter(|param| param.value.hir_id == hir_id).at_most_one().is_err()\n+fn format_arg_positions(\n+    format_args: &rustc_ast::FormatArgs,\n+) -> impl Iterator<Item = (&FormatArgPosition, FormatParamUsage)> {\n+    format_args.template.iter().flat_map(|piece| match piece {\n+        FormatArgsPiece::Placeholder(placeholder) => {\n+            let mut positions = ArrayVec::<_, 3>::new();\n+\n+            positions.push((&placeholder.argument, FormatParamUsage::Argument));\n+            if let Some(FormatCount::Argument(position)) = &placeholder.format_options.width {\n+                positions.push((position, FormatParamUsage::Width));\n+            }\n+            if let Some(FormatCount::Argument(position)) = &placeholder.format_options.precision {\n+                positions.push((position, FormatParamUsage::Precision));\n+            }\n+\n+            positions\n+        },\n+        FormatArgsPiece::Literal(_) => ArrayVec::new(),\n+    })\n+}\n+\n+/// Returns true if the format argument at `index` is referred to by multiple format params\n+fn is_aliased(format_args: &rustc_ast::FormatArgs, index: usize) -> bool {\n+    format_arg_positions(format_args)\n+        .filter(|(position, _)| position.index == Ok(index))\n+        .at_most_one()\n+        .is_err()\n }\n \n fn count_needed_derefs<'tcx, I>(mut ty: Ty<'tcx>, mut iter: I) -> (usize, Ty<'tcx>)\n@@ -455,7 +491,11 @@ where\n     let mut n_total = 0;\n     let mut n_needed = 0;\n     loop {\n-        if let Some(Adjustment { kind: Adjust::Deref(overloaded_deref), target }) = iter.next() {\n+        if let Some(Adjustment {\n+            kind: Adjust::Deref(overloaded_deref),\n+            target,\n+        }) = iter.next()\n+        {\n             n_total += 1;\n             if overloaded_deref.is_some() {\n                 n_needed = n_total;"}, {"sha": "e3ddbfb5981f8fd1e1425b9cc85625caa5e36e91", "filename": "clippy_lints/src/format_impl.rs", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fformat_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fformat_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_impl.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,11 +1,13 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n-use clippy_utils::macros::{is_format_macro, root_macro_call_first_node, FormatArg, FormatArgsExpn};\n+use clippy_utils::macros::{find_format_arg_expr, find_format_args, is_format_macro, root_macro_call_first_node};\n use clippy_utils::{get_parent_as_impl, is_diag_trait_item, path_to_local, peel_ref_operators};\n use if_chain::if_chain;\n+use rustc_ast::{FormatArgsPiece, FormatTrait};\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, Impl, ImplItem, ImplItemKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n use rustc_span::{sym, symbol::kw, Symbol};\n \n declare_clippy_lint! {\n@@ -89,7 +91,7 @@ declare_clippy_lint! {\n }\n \n #[derive(Clone, Copy)]\n-struct FormatTrait {\n+struct FormatTraitNames {\n     /// e.g. `sym::Display`\n     name: Symbol,\n     /// `f` in `fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {}`\n@@ -99,7 +101,7 @@ struct FormatTrait {\n #[derive(Default)]\n pub struct FormatImpl {\n     // Whether we are inside Display or Debug trait impl - None for neither\n-    format_trait_impl: Option<FormatTrait>,\n+    format_trait_impl: Option<FormatTraitNames>,\n }\n \n impl FormatImpl {\n@@ -161,43 +163,57 @@ fn check_to_string_in_display(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     }\n }\n \n-fn check_self_in_format_args<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, impl_trait: FormatTrait) {\n+fn check_self_in_format_args<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, impl_trait: FormatTraitNames) {\n     // Check each arg in format calls - do we ever use Display on self (directly or via deref)?\n-    if_chain! {\n-        if let Some(outer_macro) = root_macro_call_first_node(cx, expr);\n-        if let macro_def_id = outer_macro.def_id;\n-        if let Some(format_args) = FormatArgsExpn::find_nested(cx, expr, outer_macro.expn);\n-        if is_format_macro(cx, macro_def_id);\n-        then {\n-            for arg in format_args.args {\n-                if arg.format.r#trait != impl_trait.name {\n-                    continue;\n+    if let Some(outer_macro) = root_macro_call_first_node(cx, expr)\n+        && let macro_def_id = outer_macro.def_id\n+        && is_format_macro(cx, macro_def_id)\n+    {\n+        find_format_args(cx, expr, outer_macro.expn, |format_args| {\n+            for piece in &format_args.template {\n+                if let FormatArgsPiece::Placeholder(placeholder) = piece\n+                    && let trait_name = match placeholder.format_trait {\n+                        FormatTrait::Display => sym::Display,\n+                        FormatTrait::Debug => sym::Debug,\n+                        FormatTrait::LowerExp => sym!(LowerExp),\n+                        FormatTrait::UpperExp => sym!(UpperExp),\n+                        FormatTrait::Octal => sym!(Octal),\n+                        FormatTrait::Pointer => sym::Pointer,\n+                        FormatTrait::Binary => sym!(Binary),\n+                        FormatTrait::LowerHex => sym!(LowerHex),\n+                        FormatTrait::UpperHex => sym!(UpperHex),\n+                    }\n+                    && trait_name == impl_trait.name\n+                    && let Ok(index) = placeholder.argument.index\n+                    && let Some(arg) = format_args.arguments.all_args().get(index)\n+                    && let Ok(arg_expr) = find_format_arg_expr(expr, arg)\n+                {\n+                    check_format_arg_self(cx, expr.span, arg_expr, impl_trait);\n                 }\n-                check_format_arg_self(cx, expr, &arg, impl_trait);\n             }\n-        }\n+        });\n     }\n }\n \n-fn check_format_arg_self(cx: &LateContext<'_>, expr: &Expr<'_>, arg: &FormatArg<'_>, impl_trait: FormatTrait) {\n+fn check_format_arg_self(cx: &LateContext<'_>, span: Span, arg: &Expr<'_>, impl_trait: FormatTraitNames) {\n     // Handle multiple dereferencing of references e.g. &&self\n     // Handle dereference of &self -> self that is equivalent (i.e. via *self in fmt() impl)\n     // Since the argument to fmt is itself a reference: &self\n-    let reference = peel_ref_operators(cx, arg.param.value);\n+    let reference = peel_ref_operators(cx, arg);\n     let map = cx.tcx.hir();\n     // Is the reference self?\n     if path_to_local(reference).map(|x| map.name(x)) == Some(kw::SelfLower) {\n-        let FormatTrait { name, .. } = impl_trait;\n+        let FormatTraitNames { name, .. } = impl_trait;\n         span_lint(\n             cx,\n             RECURSIVE_FORMAT_IMPL,\n-            expr.span,\n+            span,\n             &format!(\"using `self` as `{name}` in `impl {name}` will cause infinite recursion\"),\n         );\n     }\n }\n \n-fn check_print_in_format_impl(cx: &LateContext<'_>, expr: &Expr<'_>, impl_trait: FormatTrait) {\n+fn check_print_in_format_impl(cx: &LateContext<'_>, expr: &Expr<'_>, impl_trait: FormatTraitNames) {\n     if_chain! {\n         if let Some(macro_call) = root_macro_call_first_node(cx, expr);\n         if let Some(name) = cx.tcx.get_diagnostic_name(macro_call.def_id);\n@@ -227,7 +243,7 @@ fn check_print_in_format_impl(cx: &LateContext<'_>, expr: &Expr<'_>, impl_trait:\n     }\n }\n \n-fn is_format_trait_impl(cx: &LateContext<'_>, impl_item: &ImplItem<'_>) -> Option<FormatTrait> {\n+fn is_format_trait_impl(cx: &LateContext<'_>, impl_item: &ImplItem<'_>) -> Option<FormatTraitNames> {\n     if_chain! {\n         if impl_item.ident.name == sym::fmt;\n         if let ImplItemKind::Fn(_, body_id) = impl_item.kind;\n@@ -241,7 +257,7 @@ fn is_format_trait_impl(cx: &LateContext<'_>, impl_item: &ImplItem<'_>) -> Optio\n                 .and_then(|param| param.pat.simple_ident())\n                 .map(|ident| ident.name);\n \n-            Some(FormatTrait {\n+            Some(FormatTraitNames {\n                 name,\n                 formatter_name,\n             })"}, {"sha": "d0ad26282642c491bd7f7827729d5aa4fa3240a1", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,7 +1,9 @@\n+use hir::FnSig;\n use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::DefIdSet;\n use rustc_hir::{self as hir, def::Res, QPath};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::{\n     lint::in_external_macro,\n@@ -27,7 +29,7 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>\n         let is_public = cx.effective_visibilities.is_exported(item.owner_id.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some(attr) = attr {\n-            check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n+            check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr, sig);\n         } else if is_public && !is_proc_macro(attrs) && !attrs.iter().any(|a| a.has_name(sym::no_mangle)) {\n             check_must_use_candidate(\n                 cx,\n@@ -49,7 +51,7 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Imp\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n         let attr = cx.tcx.get_attr(item.owner_id, sym::must_use);\n         if let Some(attr) = attr {\n-            check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n+            check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr, sig);\n         } else if is_public && !is_proc_macro(attrs) && trait_ref_of_method(cx, item.owner_id.def_id).is_none() {\n             check_must_use_candidate(\n                 cx,\n@@ -72,7 +74,7 @@ pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Tr\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n         let attr = cx.tcx.get_attr(item.owner_id, sym::must_use);\n         if let Some(attr) = attr {\n-            check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n+            check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr, sig);\n         } else if let hir::TraitFn::Provided(eid) = *eid {\n             let body = cx.tcx.hir().body(eid);\n             if attr.is_none() && is_public && !is_proc_macro(attrs) {\n@@ -97,6 +99,7 @@ fn check_needless_must_use(\n     item_span: Span,\n     fn_header_span: Span,\n     attr: &Attribute,\n+    sig: &FnSig<'_>,\n ) {\n     if in_external_macro(cx.sess(), item_span) {\n         return;\n@@ -112,6 +115,15 @@ fn check_needless_must_use(\n             },\n         );\n     } else if attr.value_str().is_none() && is_must_use_ty(cx, return_ty(cx, item_id)) {\n+        // Ignore async functions unless Future::Output type is a must_use type\n+        if sig.header.is_async() {\n+            let infcx = cx.tcx.infer_ctxt().build();\n+            if let Some(future_ty) = infcx.get_impl_future_output_ty(return_ty(cx, item_id))\n+\t\t\t&& !is_must_use_ty(cx, future_ty) {\n+\t\t\t\treturn;\n+\t\t\t}\n+        }\n+\n         span_lint_and_help(\n             cx,\n             DOUBLE_MUST_USE,"}, {"sha": "a7ec57e28505beeeea10087d118cb2fd0113aebe", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,8 +1,8 @@\n //! lint when items are used after statements\n \n-use clippy_utils::diagnostics::span_lint;\n-use rustc_ast::ast::{Block, ItemKind, StmtKind};\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use clippy_utils::diagnostics::span_lint_hir;\n+use rustc_hir::{Block, ItemKind, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -52,33 +52,34 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ItemsAfterStatements => [ITEMS_AFTER_STATEMENTS]);\n \n-impl EarlyLintPass for ItemsAfterStatements {\n-    fn check_block(&mut self, cx: &EarlyContext<'_>, item: &Block) {\n-        if in_external_macro(cx.sess(), item.span) {\n+impl LateLintPass<'_> for ItemsAfterStatements {\n+    fn check_block(&mut self, cx: &LateContext<'_>, block: &Block<'_>) {\n+        if in_external_macro(cx.sess(), block.span) {\n             return;\n         }\n \n-        // skip initial items and trailing semicolons\n-        let stmts = item\n+        // skip initial items\n+        let stmts = block\n             .stmts\n             .iter()\n-            .map(|stmt| &stmt.kind)\n-            .skip_while(|s| matches!(**s, StmtKind::Item(..) | StmtKind::Empty));\n+            .skip_while(|stmt| matches!(stmt.kind, StmtKind::Item(..)));\n \n         // lint on all further items\n         for stmt in stmts {\n-            if let StmtKind::Item(ref it) = *stmt {\n-                if in_external_macro(cx.sess(), it.span) {\n+            if let StmtKind::Item(item_id) = stmt.kind {\n+                let item = cx.tcx.hir().item(item_id);\n+                if in_external_macro(cx.sess(), item.span) || !item.span.eq_ctxt(block.span) {\n                     return;\n                 }\n-                if let ItemKind::MacroDef(..) = it.kind {\n+                if let ItemKind::Macro(..) = item.kind {\n                     // do not lint `macro_rules`, but continue processing further statements\n                     continue;\n                 }\n-                span_lint(\n+                span_lint_hir(\n                     cx,\n                     ITEMS_AFTER_STATEMENTS,\n-                    it.span,\n+                    item.hir_id(),\n+                    item.span,\n                     \"adding items after statements is confusing, since items exist from the \\\n                      start of the scope\",\n                 );"}, {"sha": "1b0544813718abe08f58d6abf48f3c44012f6944", "filename": "clippy_lints/src/large_futures.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Flarge_futures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Flarge_futures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_futures.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,87 @@\n+use clippy_utils::source::snippet;\n+use clippy_utils::{diagnostics::span_lint_and_sugg, ty::implements_trait};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, LangItem, MatchSource, QPath};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_target::abi::Size;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// It checks for the size of a `Future` created by `async fn` or `async {}`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Due to the current [unideal implemention](https://github.com/rust-lang/rust/issues/69826) of `Generator`,\n+    /// large size of a `Future` may cause stack overflows.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// async fn wait(f: impl std::future::Future<Output = ()>) {}\n+    ///\n+    /// async fn big_fut(arg: [u8; 1024]) {}\n+    ///\n+    /// pub async fn test() {\n+    ///     let fut = big_fut([0u8; 1024]);\n+    ///     wait(fut).await;\n+    /// }\n+    /// ```\n+    ///\n+    /// `Box::pin` the big future instead.\n+    ///\n+    /// ```rust\n+    /// async fn wait(f: impl std::future::Future<Output = ()>) {}\n+    ///\n+    /// async fn big_fut(arg: [u8; 1024]) {}\n+    ///\n+    /// pub async fn test() {\n+    ///     let fut = Box::pin(big_fut([0u8; 1024]));\n+    ///     wait(fut).await;\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.68.0\"]\n+    pub LARGE_FUTURES,\n+    pedantic,\n+    \"large future may lead to unexpected stack overflows\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct LargeFuture {\n+    future_size_threshold: u64,\n+}\n+\n+impl LargeFuture {\n+    pub fn new(future_size_threshold: u64) -> Self {\n+        Self { future_size_threshold }\n+    }\n+}\n+\n+impl_lint_pass!(LargeFuture => [LARGE_FUTURES]);\n+\n+impl<'tcx> LateLintPass<'tcx> for LargeFuture {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if matches!(expr.span.ctxt().outer_expn_data().kind, rustc_span::ExpnKind::Macro(..)) {\n+            return;\n+        }\n+        if let ExprKind::Match(expr, _, MatchSource::AwaitDesugar) = expr.kind {\n+            if let ExprKind::Call(func, [expr, ..]) = expr.kind\n+                && let ExprKind::Path(QPath::LangItem(LangItem::IntoFutureIntoFuture, ..)) = func.kind\n+                && let ty = cx.typeck_results().expr_ty(expr)\n+                && let Some(future_trait_def_id) = cx.tcx.lang_items().future_trait()\n+                && implements_trait(cx, ty, future_trait_def_id, &[])\n+                && let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty))\n+                && let size = layout.layout.size()\n+                && size >= Size::from_bytes(self.future_size_threshold)\n+            {\n+                span_lint_and_sugg(\n+                    cx,\n+                    LARGE_FUTURES,\n+                    expr.span,\n+                    &format!(\"large future with a size of {} bytes\", size.bytes()),\n+                    \"consider `Box::pin` on it\",\n+                    format!(\"Box::pin({})\", snippet(cx, expr.span, \"..\")),\n+                    Applicability::Unspecified,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "b14cd36a04cd7573cd32b2ec3de4e22d47cbc84d", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -162,13 +162,15 @@ mod items_after_statements;\n mod iter_not_returning_iterator;\n mod large_const_arrays;\n mod large_enum_variant;\n+mod large_futures;\n mod large_include_file;\n mod large_stack_arrays;\n mod len_zero;\n mod let_if_seq;\n mod let_underscore;\n mod let_with_type_underscore;\n mod lifetimes;\n+mod lines_filter_map_ok;\n mod literal_representation;\n mod loops;\n mod macro_use;\n@@ -288,6 +290,7 @@ mod swap;\n mod swap_ptr_to_ref;\n mod tabs_in_doc_comments;\n mod temporary_assignment;\n+mod tests_outside_test_module;\n mod to_digit_is_some;\n mod trailing_empty_array;\n mod trait_bounds;\n@@ -299,6 +302,7 @@ mod uninit_vec;\n mod unit_return_expecting_ord;\n mod unit_types;\n mod unnamed_address;\n+mod unnecessary_box_returns;\n mod unnecessary_owned_empty_strings;\n mod unnecessary_self_imports;\n mod unnecessary_struct_initialization;\n@@ -344,13 +348,17 @@ pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore, sess: &Se\n }\n \n #[doc(hidden)]\n-pub fn read_conf(sess: &Session, path: &io::Result<Option<PathBuf>>) -> Conf {\n+pub fn read_conf(sess: &Session, path: &io::Result<(Option<PathBuf>, Vec<String>)>) -> Conf {\n+    if let Ok((_, warnings)) = path {\n+        for warning in warnings {\n+            sess.warn(warning);\n+        }\n+    }\n     let file_name = match path {\n-        Ok(Some(path)) => path,\n-        Ok(None) => return Conf::default(),\n+        Ok((Some(path), _)) => path,\n+        Ok((None, _)) => return Conf::default(),\n         Err(error) => {\n-            sess.struct_err(format!(\"error finding Clippy's configuration file: {error}\"))\n-                .emit();\n+            sess.err(format!(\"error finding Clippy's configuration file: {error}\"));\n             return Conf::default();\n         },\n     };\n@@ -746,7 +754,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| Box::new(unused_unit::UnusedUnit));\n     store.register_late_pass(|_| Box::new(returns::Return));\n     store.register_early_pass(|| Box::new(collapsible_if::CollapsibleIf));\n-    store.register_early_pass(|| Box::new(items_after_statements::ItemsAfterStatements));\n+    store.register_late_pass(|_| Box::new(items_after_statements::ItemsAfterStatements));\n     store.register_early_pass(|| Box::new(precedence::Precedence));\n     store.register_late_pass(|_| Box::new(needless_parens_on_range_literals::NeedlessParensOnRangeLiterals));\n     store.register_early_pass(|| Box::new(needless_continue::NeedlessContinue));\n@@ -808,6 +816,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move |_| Box::new(dereference::Dereferencing::new(msrv())));\n     store.register_late_pass(|_| Box::new(option_if_let_else::OptionIfLetElse));\n     store.register_late_pass(|_| Box::new(future_not_send::FutureNotSend));\n+    let future_size_threshold = conf.future_size_threshold;\n+    store.register_late_pass(move |_| Box::new(large_futures::LargeFuture::new(future_size_threshold)));\n     store.register_late_pass(|_| Box::new(if_let_mutex::IfLetMutex));\n     store.register_late_pass(|_| Box::new(if_not_else::IfNotElse));\n     store.register_late_pass(|_| Box::new(equatable_if_let::PatternEquality));\n@@ -934,11 +944,18 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(no_mangle_with_rust_abi::NoMangleWithRustAbi));\n     store.register_late_pass(|_| Box::new(collection_is_never_read::CollectionIsNeverRead));\n     store.register_late_pass(|_| Box::new(missing_assert_message::MissingAssertMessage));\n-    store.register_early_pass(|| Box::new(redundant_async_block::RedundantAsyncBlock));\n+    store.register_late_pass(|_| Box::new(redundant_async_block::RedundantAsyncBlock));\n     store.register_late_pass(|_| Box::new(let_with_type_underscore::UnderscoreTyped));\n     store.register_late_pass(|_| Box::new(allow_attributes::AllowAttribute));\n     store.register_late_pass(move |_| Box::new(manual_main_separator_str::ManualMainSeparatorStr::new(msrv())));\n     store.register_late_pass(|_| Box::new(unnecessary_struct_initialization::UnnecessaryStruct));\n+    store.register_late_pass(move |_| {\n+        Box::new(unnecessary_box_returns::UnnecessaryBoxReturns::new(\n+            avoid_breaking_exported_api,\n+        ))\n+    });\n+    store.register_late_pass(|_| Box::new(lines_filter_map_ok::LinesFilterMapOk));\n+    store.register_late_pass(|_| Box::new(tests_outside_test_module::TestsOutsideTestModule));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "b0f9276475d3ee96fc491a2bc3e8aed25a752615", "filename": "clippy_lints/src/lines_filter_map_ok.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Flines_filter_map_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Flines_filter_map_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flines_filter_map_ok.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,100 @@\n+use clippy_utils::{\n+    diagnostics::span_lint_and_then, is_diag_item_method, is_trait_method, match_def_path, path_to_local_id, paths,\n+    ty::match_type,\n+};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Body, Closure, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detect uses of `lines.filter_map(Result::ok)` or `lines.flat_map(Result::ok)`\n+    /// when `lines` has type `std::io::Lines`.\n+    ///\n+    /// ### Why is this bad?\n+    /// `Lines` instances might produce a never-ending stream of `Err`, in which case\n+    /// `filter_map(Result::ok)` will enter an infinite loop while waiting for an\n+    /// `Ok` variant. Calling `next()` once is sufficient to enter the infinite loop,\n+    /// even in the absence of explicit loops in the user code.\n+    ///\n+    /// This situation can arise when working with user-provided paths. On some platforms,\n+    /// `std::fs::File::open(path)` might return `Ok(fs)` even when `path` is a directory,\n+    /// but any later attempt to read from `fs` will return an error.\n+    ///\n+    /// ### Known problems\n+    /// This lint suggests replacing `filter_map()` or `flat_map()` applied to a `Lines`\n+    /// instance in all cases. There two cases where the suggestion might not be\n+    /// appropriate or necessary:\n+    ///\n+    /// - If the `Lines` instance can never produce any error, or if an error is produced\n+    ///   only once just before terminating the iterator, using `map_while()` is not\n+    ///   necessary but will not do any harm.\n+    /// - If the `Lines` instance can produce intermittent errors then recover and produce\n+    ///   successful results, using `map_while()` would stop at the first error.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::{fs::File, io::{self, BufRead, BufReader}};\n+    /// # let _ = || -> io::Result<()> {\n+    /// let mut lines = BufReader::new(File::open(\"some-path\")?).lines().filter_map(Result::ok);\n+    /// // If \"some-path\" points to a directory, the next statement never terminates:\n+    /// let first_line: Option<String> = lines.next();\n+    /// # Ok(()) };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::{fs::File, io::{self, BufRead, BufReader}};\n+    /// # let _ = || -> io::Result<()> {\n+    /// let mut lines = BufReader::new(File::open(\"some-path\")?).lines().map_while(Result::ok);\n+    /// let first_line: Option<String> = lines.next();\n+    /// # Ok(()) };\n+    /// ```\n+    #[clippy::version = \"1.70.0\"]\n+    pub LINES_FILTER_MAP_OK,\n+    suspicious,\n+    \"filtering `std::io::Lines` with `filter_map()` or `flat_map()` might cause an infinite loop\"\n+}\n+declare_lint_pass!(LinesFilterMapOk => [LINES_FILTER_MAP_OK]);\n+\n+impl LateLintPass<'_> for LinesFilterMapOk {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        if let ExprKind::MethodCall(fm_method, fm_receiver, [fm_arg], fm_span) = expr.kind &&\n+            is_trait_method(cx, expr, sym::Iterator) &&\n+            (fm_method.ident.as_str() == \"filter_map\" || fm_method.ident.as_str() == \"flat_map\") &&\n+            match_type(cx, cx.typeck_results().expr_ty_adjusted(fm_receiver), &paths::STD_IO_LINES)\n+        {\n+            let lint = match &fm_arg.kind {\n+                // Detect `Result::ok`\n+                ExprKind::Path(qpath) =>\n+                    cx.qpath_res(qpath, fm_arg.hir_id).opt_def_id().map(|did|\n+                        match_def_path(cx, did, &paths::CORE_RESULT_OK_METHOD)).unwrap_or_default(),\n+                // Detect `|x| x.ok()`\n+                ExprKind::Closure(Closure { body, .. }) =>\n+                    if let Body { params: [param], value, .. } = cx.tcx.hir().body(*body) &&\n+                        let ExprKind::MethodCall(method, receiver, [], _) = value.kind &&\n+                        path_to_local_id(receiver, param.pat.hir_id) &&\n+                        let Some(method_did) = cx.typeck_results().type_dependent_def_id(value.hir_id)\n+                    {\n+                        is_diag_item_method(cx, method_did, sym::Result) && method.ident.as_str() == \"ok\"\n+                    } else {\n+                        false\n+                    }\n+                _ => false,\n+            };\n+            if lint {\n+                span_lint_and_then(cx,\n+                    LINES_FILTER_MAP_OK,\n+                    fm_span,\n+                    &format!(\"`{}()` will run forever if the iterator repeatedly produces an `Err`\", fm_method.ident),\n+                    |diag| {\n+                        diag.span_note(\n+                            fm_receiver.span,\n+                            \"this expression returning a `std::io::Lines` may produce an infinite number of `Err` in case of a read error\");\n+                        diag.span_suggestion(fm_span, \"replace with\", \"map_while(Result::ok)\", Applicability::MaybeIncorrect);\n+                    });\n+                }\n+        }\n+    }\n+}"}, {"sha": "26ae4b409c79570d116147e24477ee335bda9c3f", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -35,7 +35,8 @@ struct PathAndSpan {\n     span: Span,\n }\n \n-/// `MacroRefData` includes the name of the macro.\n+/// `MacroRefData` includes the name of the macro\n+/// and the path from `SourceMap::span_to_filename`.\n #[derive(Debug, Clone)]\n pub struct MacroRefData {\n     name: String,"}, {"sha": "24496bd4689f59776bfab246471b7141eef8c713", "filename": "clippy_lints/src/methods/clear_with_drain.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fmethods%2Fclear_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fmethods%2Fclear_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclear_with_drain.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,28 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_range_full;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n+\n+use super::CLEAR_WITH_DRAIN;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span, arg: &Expr<'_>) {\n+    let ty = cx.typeck_results().expr_ty(recv);\n+    if is_type_diagnostic_item(cx, ty, sym::Vec)\n+        && let ExprKind::Path(QPath::Resolved(None, container_path)) = recv.kind\n+        && is_range_full(cx, arg, Some(container_path))\n+    {\n+        span_lint_and_sugg(\n+            cx,\n+            CLEAR_WITH_DRAIN,\n+            span.with_hi(expr.span.hi()),\n+            \"`drain` used to clear a `Vec`\",\n+            \"try\",\n+            \"clear()\".to_string(),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}"}, {"sha": "92d21bb893262af134609248e159380ca1d88efe", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn};\n+use clippy_utils::macros::{find_format_args, format_args_inputs_span, root_macro_call_first_node};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use rustc_errors::Applicability;\n@@ -136,18 +136,19 @@ pub(super) fn check<'tcx>(\n         if !cx.tcx.is_diagnostic_item(sym::format_macro, macro_call.def_id) {\n             return;\n         }\n-        let Some(format_args) = FormatArgsExpn::find_nested(cx, arg_root, macro_call.expn) else { return };\n-        let span = format_args.inputs_span();\n-        let sugg = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n-        span_lint_and_sugg(\n-            cx,\n-            EXPECT_FUN_CALL,\n-            span_replace_word,\n-            &format!(\"use of `{name}` followed by a function call\"),\n-            \"try this\",\n-            format!(\"unwrap_or_else({closure_args} panic!({sugg}))\"),\n-            applicability,\n-        );\n+        find_format_args(cx, arg_root, macro_call.expn, |format_args| {\n+            let span = format_args_inputs_span(format_args);\n+            let sugg = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n+            span_lint_and_sugg(\n+                cx,\n+                EXPECT_FUN_CALL,\n+                span_replace_word,\n+                &format!(\"use of `{name}` followed by a function call\"),\n+                \"try this\",\n+                format!(\"unwrap_or_else({closure_args} panic!({sugg}))\"),\n+                applicability,\n+            );\n+        });\n         return;\n     }\n "}, {"sha": "122088f4857cd5925b37b8c744fecaf34b3578ed", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -7,7 +7,7 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::symbol::{Symbol, sym};\n+use rustc_span::symbol::{sym, Symbol};\n \n use super::INEFFICIENT_TO_STRING;\n "}, {"sha": "f6772c5c6b369c03ea12cff1c39647f9577794e6", "filename": "clippy_lints/src/methods/iter_with_drain.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,7 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher::Range;\n-use clippy_utils::is_integer_const;\n-use rustc_ast::ast::RangeLimits;\n+use clippy_utils::is_range_full;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, QPath};\n use rustc_lint::LateContext;\n@@ -15,8 +13,8 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span\n         && let Some(adt) = cx.typeck_results().expr_ty(recv).ty_adt_def()\n         && let Some(ty_name) = cx.tcx.get_diagnostic_name(adt.did())\n         && matches!(ty_name, sym::Vec | sym::VecDeque)\n-        && let Some(range) = Range::hir(arg)\n-        && is_full_range(cx, recv, range)\n+        && let ExprKind::Path(QPath::Resolved(None, container_path)) = recv.kind\n+        && is_range_full(cx, arg, Some(container_path))\n     {\n         span_lint_and_sugg(\n             cx,\n@@ -29,19 +27,3 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span\n         );\n     };\n }\n-\n-fn is_full_range(cx: &LateContext<'_>, container: &Expr<'_>, range: Range<'_>) -> bool {\n-    range.start.map_or(true, |e| is_integer_const(cx, e, 0))\n-        && range.end.map_or(true, |e| {\n-            if range.limits == RangeLimits::HalfOpen\n-                && let ExprKind::Path(QPath::Resolved(None, container_path)) = container.kind\n-                && let ExprKind::MethodCall(name, self_arg, [], _) = e.kind\n-                && name.ident.name == sym::len\n-                && let ExprKind::Path(QPath::Resolved(None, path)) = self_arg.kind\n-            {\n-                container_path.res == path.res\n-            } else {\n-                false\n-            }\n-        })\n-}"}, {"sha": "257bc4eccc302925702ea4faf4c72168ed7386ef", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -9,6 +9,7 @@ mod chars_last_cmp;\n mod chars_last_cmp_with_unwrap;\n mod chars_next_cmp;\n mod chars_next_cmp_with_unwrap;\n+mod clear_with_drain;\n mod clone_on_copy;\n mod clone_on_ref_ptr;\n mod cloned_instead_of_copied;\n@@ -110,7 +111,7 @@ use clippy_utils::ty::{contains_ty_adt_constructor_opaque, implements_trait, is_\n use clippy_utils::{contains_return, is_bool, is_trait_method, iter_input_pats, return_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n-use rustc_hir::{Expr, ExprKind, TraitItem, TraitItemKind};\n+use rustc_hir::{Expr, ExprKind, Node, Stmt, StmtKind, TraitItem, TraitItemKind};\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -3190,6 +3191,31 @@ declare_clippy_lint! {\n     \"single command line argument that looks like it should be multiple arguments\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usage of `.drain(..)` for the sole purpose of clearing a `Vec`.\n+    ///\n+    /// ### Why is this bad?\n+    /// This creates an unnecessary iterator that is dropped immediately.\n+    ///\n+    /// Calling `.clear()` also makes the intent clearer.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let mut v = vec![1, 2, 3];\n+    /// v.drain(..);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut v = vec![1, 2, 3];\n+    /// v.clear();\n+    /// ```\n+    #[clippy::version = \"1.69.0\"]\n+    pub CLEAR_WITH_DRAIN,\n+    nursery,\n+    \"calling `drain` in order to `clear` a `Vec`\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Msrv,\n@@ -3318,6 +3344,7 @@ impl_lint_pass!(Methods => [\n     SEEK_TO_START_INSTEAD_OF_REWIND,\n     NEEDLESS_COLLECT,\n     SUSPICIOUS_COMMAND_ARG_SPACE,\n+    CLEAR_WITH_DRAIN,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -3563,7 +3590,13 @@ impl Methods {\n                     _ => {},\n                 },\n                 (\"drain\", [arg]) => {\n-                    iter_with_drain::check(cx, expr, recv, span, arg);\n+                if let Node::Stmt(Stmt { hir_id: _, kind, .. }) = cx.tcx.hir().get_parent(expr.hir_id)\n+                    && matches!(kind, StmtKind::Semi(_))\n+                    {\n+                        clear_with_drain::check(cx, expr, recv, span, arg);\n+                    } else {\n+                        iter_with_drain::check(cx, expr, recv, span, arg);\n+                    }\n                 },\n                 (\"ends_with\", [arg]) => {\n                     if let ExprKind::MethodCall(.., span) = expr.kind {"}, {"sha": "3ef0c6634598474189ba0b5415d733304b2d2671", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -92,10 +92,6 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 self.found = true;\n                 return;\n             },\n-            ExprKind::If(..) => {\n-                self.found = true;\n-                return;\n-            },\n             ExprKind::Path(_) => {\n                 if let Some(adj) = self.cx.typeck_results().adjustments().get(expr.hir_id) {\n                     if adj"}, {"sha": "e5713735672dadd5cea82a5e3f48145afd1ae134", "filename": "clippy_lints/src/operators/arithmetic_side_effects.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -154,10 +154,18 @@ impl ArithmeticSideEffects {\n                 Self::literal_integer(cx, actual_rhs),\n             ) {\n                 (None, None) => false,\n-                (None, Some(n)) | (Some(n), None) => match (&op.node, n) {\n+                (None, Some(n)) => match (&op.node, n) {\n                     // Division and module are always valid if applied to non-zero integers\n                     (hir::BinOpKind::Div | hir::BinOpKind::Rem, local_n) if local_n != 0 => true,\n-                    // Addition or subtracting zeros is always a no-op\n+                    // Adding or subtracting zeros is always a no-op\n+                    (hir::BinOpKind::Add | hir::BinOpKind::Sub, 0)\n+                    // Multiplication by 1 or 0 will never overflow\n+                    | (hir::BinOpKind::Mul, 0 | 1)\n+                    => true,\n+                    _ => false,\n+                },\n+                (Some(n), None) => match (&op.node, n) {\n+                    // Adding or subtracting zeros is always a no-op\n                     (hir::BinOpKind::Add | hir::BinOpKind::Sub, 0)\n                     // Multiplication by 1 or 0 will never overflow\n                     | (hir::BinOpKind::Mul, 0 | 1)"}, {"sha": "a0f831764d071ddb1247e093bce93caa5c6f3745", "filename": "clippy_lints/src/redundant_async_block.rs", "status": "modified", "additions": 67, "deletions": 78, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fredundant_async_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fredundant_async_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_async_block.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,8 +1,15 @@\n-use clippy_utils::{diagnostics::span_lint_and_sugg, source::snippet};\n-use rustc_ast::ast::{Expr, ExprKind, Stmt, StmtKind};\n-use rustc_ast::visit::Visitor as AstVisitor;\n+use std::ops::ControlFlow;\n+\n+use clippy_utils::{\n+    diagnostics::span_lint_and_sugg,\n+    peel_blocks,\n+    source::{snippet, walk_span_to_context},\n+    visitors::for_each_expr,\n+};\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_hir::{AsyncGeneratorKind, Closure, Expr, ExprKind, GeneratorKind, MatchSource};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::{lint::in_external_macro, ty::UpvarCapture};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -14,106 +21,88 @@ declare_clippy_lint! {\n     ///\n     /// ### Example\n     /// ```rust\n-    /// async fn f() -> i32 {\n-    ///     1 + 2\n-    /// }\n-    ///\n+    /// let f = async {\n+    ///    1 + 2\n+    /// };\n     /// let fut = async {\n-    ///     f().await\n+    ///     f.await\n     /// };\n     /// ```\n     /// Use instead:\n     /// ```rust\n-    /// async fn f() -> i32 {\n-    ///     1 + 2\n-    /// }\n-    ///\n-    /// let fut = f();\n+    /// let f = async {\n+    ///    1 + 2\n+    /// };\n+    /// let fut = f;\n     /// ```\n     #[clippy::version = \"1.69.0\"]\n     pub REDUNDANT_ASYNC_BLOCK,\n-    nursery,\n+    complexity,\n     \"`async { future.await }` can be replaced by `future`\"\n }\n declare_lint_pass!(RedundantAsyncBlock => [REDUNDANT_ASYNC_BLOCK]);\n \n-impl EarlyLintPass for RedundantAsyncBlock {\n-    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-        if let ExprKind::Async(_, block) = &expr.kind && block.stmts.len() == 1 &&\n-            let Some(Stmt { kind: StmtKind::Expr(last), .. }) = block.stmts.last() &&\n-            let ExprKind::Await(future) = &last.kind &&\n-            !future.span.from_expansion() &&\n-            !await_in_expr(future)\n+impl<'tcx> LateLintPass<'tcx> for RedundantAsyncBlock {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        let span = expr.span;\n+        if !in_external_macro(cx.tcx.sess, span) &&\n+            let Some(body_expr) = desugar_async_block(cx, expr) &&\n+            let Some(expr) = desugar_await(peel_blocks(body_expr)) &&\n+            // The await prefix must not come from a macro as its content could change in the future.\n+            expr.span.ctxt() == body_expr.span.ctxt() &&\n+            // An async block does not have immediate side-effects from a `.await` point-of-view.\n+            (!expr.can_have_side_effects() || desugar_async_block(cx, expr).is_some()) &&\n+            let Some(shortened_span) = walk_span_to_context(expr.span, span.ctxt())\n         {\n-            if captures_value(last) {\n-                // If the async block captures variables then there is no equivalence.\n-                return;\n-            }\n-\n             span_lint_and_sugg(\n                 cx,\n                 REDUNDANT_ASYNC_BLOCK,\n-                expr.span,\n+                span,\n                 \"this async expression only awaits a single future\",\n                 \"you can reduce it to\",\n-                snippet(cx, future.span, \"..\").into_owned(),\n+                snippet(cx, shortened_span, \"..\").into_owned(),\n                 Applicability::MachineApplicable,\n             );\n         }\n     }\n }\n \n-/// Check whether an expression contains `.await`\n-fn await_in_expr(expr: &Expr) -> bool {\n-    let mut detector = AwaitDetector::default();\n-    detector.visit_expr(expr);\n-    detector.await_found\n-}\n-\n-#[derive(Default)]\n-struct AwaitDetector {\n-    await_found: bool,\n-}\n-\n-impl<'ast> AstVisitor<'ast> for AwaitDetector {\n-    fn visit_expr(&mut self, ex: &'ast Expr) {\n-        match (&ex.kind, self.await_found) {\n-            (ExprKind::Await(_), _) => self.await_found = true,\n-            (_, false) => rustc_ast::visit::walk_expr(self, ex),\n-            _ => (),\n-        }\n+/// If `expr` is a desugared `async` block, return the original expression if it does not capture\n+/// any variable by ref.\n+fn desugar_async_block<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if let ExprKind::Closure(Closure { body, def_id, .. }) = expr.kind &&\n+        let body = cx.tcx.hir().body(*body) &&\n+        matches!(body.generator_kind, Some(GeneratorKind::Async(AsyncGeneratorKind::Block)))\n+    {\n+        cx\n+            .typeck_results()\n+            .closure_min_captures\n+            .get(def_id)\n+            .map_or(true, |m| {\n+                m.values().all(|places| {\n+                    places\n+                        .iter()\n+                        .all(|place| matches!(place.info.capture_kind, UpvarCapture::ByValue))\n+                })\n+            })\n+            .then_some(body.value)\n+    } else {\n+        None\n     }\n }\n \n-/// Check whether an expression may have captured a local variable.\n-/// This is done by looking for paths with only one segment, except as\n-/// a prefix of `.await` since this would be captured by value.\n-///\n-/// This function will sometimes return `true` even tough there are no\n-/// captures happening: at the AST level, it is impossible to\n-/// dinstinguish a function call from a call to a closure which comes\n-/// from the local environment.\n-fn captures_value(expr: &Expr) -> bool {\n-    let mut detector = CaptureDetector::default();\n-    detector.visit_expr(expr);\n-    detector.capture_found\n-}\n-\n-#[derive(Default)]\n-struct CaptureDetector {\n-    capture_found: bool,\n-}\n-\n-impl<'ast> AstVisitor<'ast> for CaptureDetector {\n-    fn visit_expr(&mut self, ex: &'ast Expr) {\n-        match (&ex.kind, self.capture_found) {\n-            (ExprKind::Await(fut), _) if matches!(fut.kind, ExprKind::Path(..)) => (),\n-            (ExprKind::Path(_, path), _) if path.segments.len() == 1 => self.capture_found = true,\n-            (_, false) => rustc_ast::visit::walk_expr(self, ex),\n-            _ => (),\n-        }\n+/// If `expr` is a desugared `.await`, return the original expression if it does not come from a\n+/// macro expansion.\n+fn desugar_await<'tcx>(expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if let ExprKind::Match(match_value, _, MatchSource::AwaitDesugar) = expr.kind &&\n+        let ExprKind::Call(_, [into_future_arg]) = match_value.kind &&\n+        let ctxt = expr.span.ctxt() &&\n+        for_each_expr(into_future_arg, |e|\n+            walk_span_to_context(e.span, ctxt)\n+                .map_or(ControlFlow::Break(()), |_| ControlFlow::Continue(()))).is_none()\n+    {\n+        Some(into_future_arg)\n+    } else {\n+        None\n     }\n }"}, {"sha": "038dfe8e4803ca8417801108048bf91a6cc9afa4", "filename": "clippy_lints/src/redundant_static_lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::msrvs::{self, Msrv};\n use clippy_utils::source::snippet;\n-use rustc_ast::ast::{Item, ItemKind, Ty, TyKind, StaticItem, ConstItem};\n+use rustc_ast::ast::{ConstItem, Item, ItemKind, StaticItem, Ty, TyKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -106,7 +106,7 @@ impl EarlyLintPass for RedundantStaticLifetimes {\n                 // #2438)\n             }\n \n-            if let ItemKind::Static(box StaticItem { ty: ref var_type,.. }) = item.kind {\n+            if let ItemKind::Static(box StaticItem { ty: ref var_type, .. }) = item.kind {\n                 Self::visit_type(var_type, cx, \"statics have by default a `'static` lifetime\");\n             }\n         }"}, {"sha": "45433b2adf0657177b95ef7b17646e93c661b035", "filename": "clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsame_name_method.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -55,11 +55,11 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n             if matches!(cx.tcx.def_kind(id.owner_id), DefKind::Impl { .. })\n                 && let item = cx.tcx.hir().item(id)\n                 && let ItemKind::Impl(Impl {\n-                  items,\n-                  of_trait,\n-                  self_ty,\n-                  ..\n-                                      }) = &item.kind\n+                    items,\n+                    of_trait,\n+                    self_ty,\n+                    ..\n+                }) = &item.kind\n                 && let TyKind::Path(QPath::Resolved(_, Path { res, .. })) = self_ty.kind\n             {\n                 if !map.contains_key(res) {"}, {"sha": "0a0a77082e02ffc485826197166ba30fbaefa691", "filename": "clippy_lints/src/tests_outside_test_module.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Ftests_outside_test_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Ftests_outside_test_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftests_outside_test_module.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,71 @@\n+use clippy_utils::{diagnostics::span_lint_and_note, is_in_cfg_test, is_in_test_function};\n+use rustc_hir::{intravisit::FnKind, Body, FnDecl};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{def_id::LocalDefId, Span};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Triggers when a testing function (marked with the `#[test]` attribute) isn't inside a testing module\n+    /// (marked with `#[cfg(test)]`).\n+    /// ### Why is this bad?\n+    /// The idiomatic (and more performant) way of writing tests is inside a testing module (flagged with `#[cfg(test)]`),\n+    /// having test functions outside of this module is confusing and may lead to them being \"hidden\".\n+    /// ### Example\n+    /// ```rust\n+    /// #[test]\n+    /// fn my_cool_test() {\n+    ///     // [...]\n+    /// }\n+    ///\n+    /// #[cfg(test)]\n+    /// mod tests {\n+    ///     // [...]\n+    /// }\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// #[cfg(test)]\n+    /// mod tests {\n+    ///     #[test]\n+    ///     fn my_cool_test() {\n+    ///         // [...]\n+    ///     }\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.70.0\"]\n+    pub TESTS_OUTSIDE_TEST_MODULE,\n+    restriction,\n+    \"A test function is outside the testing module.\"\n+}\n+\n+declare_lint_pass!(TestsOutsideTestModule => [TESTS_OUTSIDE_TEST_MODULE]);\n+\n+impl LateLintPass<'_> for TestsOutsideTestModule {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'_>,\n+        kind: FnKind<'_>,\n+        _: &FnDecl<'_>,\n+        body: &Body<'_>,\n+        sp: Span,\n+        _: LocalDefId,\n+    ) {\n+        if_chain! {\n+            if !matches!(kind, FnKind::Closure);\n+            if is_in_test_function(cx.tcx, body.id().hir_id);\n+            if !is_in_cfg_test(cx.tcx, body.id().hir_id);\n+            then {\n+                span_lint_and_note(\n+                    cx,\n+                    TESTS_OUTSIDE_TEST_MODULE,\n+                    sp,\n+                    \"this function marked with #[test] is outside a #[cfg(test)] module\",\n+                    None,\n+                    \"move it to a testing module marked with #[cfg(test)]\",\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "85cd74f23ef7e27c5b57a87332974f459001e2d2", "filename": "clippy_lints/src/transmute/transmutes_expressible_as_ptr_casts.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -2,8 +2,9 @@ use super::utils::check_cast;\n use super::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::sugg::Sugg;\n+use rustc_ast::ExprPrecedence;\n use rustc_errors::Applicability;\n-use rustc_hir::Expr;\n+use rustc_hir::{Expr, Node};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{cast::CastKind, Ty};\n \n@@ -19,7 +20,7 @@ pub(super) fn check<'tcx>(\n ) -> bool {\n     use CastKind::{AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast};\n     let mut app = Applicability::MachineApplicable;\n-    let sugg = match check_cast(cx, e, from_ty, to_ty) {\n+    let mut sugg = match check_cast(cx, e, from_ty, to_ty) {\n         Some(PtrPtrCast | AddrPtrCast | ArrayPtrCast | FnPtrPtrCast | FnPtrAddrCast) => {\n             Sugg::hir_with_context(cx, arg, e.span.ctxt(), \"..\", &mut app)\n                 .as_ty(to_ty.to_string())\n@@ -39,6 +40,12 @@ pub(super) fn check<'tcx>(\n         _ => return false,\n     };\n \n+    if let Node::Expr(parent) = cx.tcx.hir().get_parent(e.hir_id)\n+        && parent.precedence().order() > ExprPrecedence::Cast.order()\n+    {\n+        sugg = format!(\"({sugg})\");\n+    }\n+\n     span_lint_and_sugg(\n         cx,\n         TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,"}, {"sha": "912bcda630b83b179d39f42dedeb81dadebb2b55", "filename": "clippy_lints/src/unnecessary_box_returns.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Funnecessary_box_returns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Funnecessary_box_returns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_box_returns.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,120 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use rustc_errors::Applicability;\n+use rustc_hir::{def_id::LocalDefId, FnDecl, FnRetTy, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Symbol;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Checks for a return type containing a `Box<T>` where `T` implements `Sized`\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// It's better to just return `T` in these cases. The caller may not need\n+    /// the value to be boxed, and it's expensive to free the memory once the\n+    /// `Box<T>` been dropped.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn foo() -> Box<String> {\n+    ///     Box::new(String::from(\"Hello, world!\"))\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn foo() -> String {\n+    ///     String::from(\"Hello, world!\")\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.70.0\"]\n+    pub UNNECESSARY_BOX_RETURNS,\n+    pedantic,\n+    \"Needlessly returning a Box\"\n+}\n+\n+pub struct UnnecessaryBoxReturns {\n+    avoid_breaking_exported_api: bool,\n+}\n+\n+impl_lint_pass!(UnnecessaryBoxReturns => [UNNECESSARY_BOX_RETURNS]);\n+\n+impl UnnecessaryBoxReturns {\n+    pub fn new(avoid_breaking_exported_api: bool) -> Self {\n+        Self {\n+            avoid_breaking_exported_api,\n+        }\n+    }\n+\n+    fn check_fn_item(&mut self, cx: &LateContext<'_>, decl: &FnDecl<'_>, def_id: LocalDefId, name: Symbol) {\n+        // we don't want to tell someone to break an exported function if they ask us not to\n+        if self.avoid_breaking_exported_api && cx.effective_visibilities.is_exported(def_id) {\n+            return;\n+        }\n+\n+        // functions which contain the word \"box\" are exempt from this lint\n+        if name.as_str().contains(\"box\") {\n+            return;\n+        }\n+\n+        let FnRetTy::Return(return_ty_hir) = &decl.output else { return };\n+\n+        let return_ty = cx\n+            .tcx\n+            .erase_late_bound_regions(cx.tcx.fn_sig(def_id).skip_binder())\n+            .output();\n+\n+        if !return_ty.is_box() {\n+            return;\n+        }\n+\n+        let boxed_ty = return_ty.boxed_ty();\n+\n+        // it's sometimes useful to return Box<T> if T is unsized, so don't lint those\n+        if boxed_ty.is_sized(cx.tcx, cx.param_env) {\n+            span_lint_and_then(\n+                cx,\n+                UNNECESSARY_BOX_RETURNS,\n+                return_ty_hir.span,\n+                format!(\"boxed return of the sized type `{boxed_ty}`\").as_str(),\n+                |diagnostic| {\n+                    diagnostic.span_suggestion(\n+                        return_ty_hir.span,\n+                        \"try\",\n+                        boxed_ty.to_string(),\n+                        // the return value and function callers also needs to\n+                        // be changed, so this can't be MachineApplicable\n+                        Applicability::Unspecified,\n+                    );\n+                    diagnostic.help(\"changing this also requires a change to the return expressions in this function\");\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+impl LateLintPass<'_> for UnnecessaryBoxReturns {\n+    fn check_trait_item(&mut self, cx: &LateContext<'_>, item: &TraitItem<'_>) {\n+        let TraitItemKind::Fn(signature, _) = &item.kind else { return };\n+        self.check_fn_item(cx, signature.decl, item.owner_id.def_id, item.ident.name);\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'_>, item: &rustc_hir::ImplItem<'_>) {\n+        // Ignore implementations of traits, because the lint should be on the\n+        // trait, not on the implmentation of it.\n+        let Node::Item(parent) = cx.tcx.hir().get_parent(item.hir_id()) else { return };\n+        let ItemKind::Impl(parent) = parent.kind else { return };\n+        if parent.of_trait.is_some() {\n+            return;\n+        }\n+\n+        let ImplItemKind::Fn(signature, ..) = &item.kind else { return };\n+        self.check_fn_item(cx, signature.decl, item.owner_id.def_id, item.ident.name);\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        let ItemKind::Fn(signature, ..) = &item.kind else { return };\n+        self.check_fn_item(cx, signature.decl, item.owner_id.def_id, item.ident.name);\n+    }\n+}"}, {"sha": "084b031982d8c64c010fa9a2e7657ab427bd69f6", "filename": "clippy_lints/src/unnecessary_struct_initialization.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Funnecessary_struct_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Funnecessary_struct_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_struct_initialization.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -9,7 +9,7 @@ declare_clippy_lint! {\n     /// any field.\n     ///\n     /// ### Why is this bad?\n-    /// Readibility suffers from unnecessary struct building.\n+    /// Readability suffers from unnecessary struct building.\n     ///\n     /// ### Example\n     /// ```rust\n@@ -25,9 +25,13 @@ declare_clippy_lint! {\n     /// let a = S { s: String::from(\"Hello, world!\") };\n     /// let b = a;\n     /// ```\n+    ///\n+    /// ### Known Problems\n+    /// Has false positives when the base is a place expression that cannot be\n+    /// moved out of, see [#10547](https://github.com/rust-lang/rust-clippy/issues/10547).\n     #[clippy::version = \"1.70.0\"]\n     pub UNNECESSARY_STRUCT_INITIALIZATION,\n-    complexity,\n+    nursery,\n     \"struct built from a base that can be written mode concisely\"\n }\n declare_lint_pass!(UnnecessaryStruct => [UNNECESSARY_STRUCT_INITIALIZATION]);"}, {"sha": "5a02987453c41ff670e408157dade8f573e3f04c", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -10,8 +10,8 @@ use rustc_hir::{\n     def::{CtorOf, DefKind, Res},\n     def_id::LocalDefId,\n     intravisit::{walk_inf, walk_ty, Visitor},\n-    Expr, ExprKind, FnRetTy, FnSig, GenericArg, GenericArgsParentheses, GenericParam, GenericParamKind, HirId, Impl, ImplItemKind, Item,\n-    ItemKind, Pat, PatKind, Path, QPath, Ty, TyKind,\n+    Expr, ExprKind, FnRetTy, FnSig, GenericArg, GenericArgsParentheses, GenericParam, GenericParamKind, HirId, Impl,\n+    ImplItemKind, Item, ItemKind, Pat, PatKind, Path, QPath, Ty, TyKind,\n };\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{LateContext, LateLintPass};"}, {"sha": "896a01af37d995b10924acdacca1c9ef9305bbc9", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -249,7 +249,7 @@ define_Conf! {\n     /// arithmetic-side-effects-allowed-unary = [\"SomeType\", \"AnotherType\"]\n     /// ```\n     (arithmetic_side_effects_allowed_unary: rustc_data_structures::fx::FxHashSet<String> = <_>::default()),\n-    /// Lint: ENUM_VARIANT_NAMES, LARGE_TYPES_PASSED_BY_VALUE, TRIVIALLY_COPY_PASS_BY_REF, UNNECESSARY_WRAPS, UNUSED_SELF, UPPER_CASE_ACRONYMS, WRONG_SELF_CONVENTION, BOX_COLLECTION, REDUNDANT_ALLOCATION, RC_BUFFER, VEC_BOX, OPTION_OPTION, LINKEDLIST, RC_MUTEX.\n+    /// Lint: ENUM_VARIANT_NAMES, LARGE_TYPES_PASSED_BY_VALUE, TRIVIALLY_COPY_PASS_BY_REF, UNNECESSARY_WRAPS, UNUSED_SELF, UPPER_CASE_ACRONYMS, WRONG_SELF_CONVENTION, BOX_COLLECTION, REDUNDANT_ALLOCATION, RC_BUFFER, VEC_BOX, OPTION_OPTION, LINKEDLIST, RC_MUTEX, UNNECESSARY_BOX_RETURNS.\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n@@ -275,13 +275,13 @@ define_Conf! {\n     ///\n     /// The list of disallowed names to lint about. NB: `bar` is not here since it has legitimate uses. The value\n     /// `\"..\"` can be used as part of the list to indicate, that the configured values should be appended to the\n-    /// default configuration of Clippy. By default any configuration will replace the default value.\n+    /// default configuration of Clippy. By default, any configuration will replace the default value.\n     (disallowed_names: Vec<String> = super::DEFAULT_DISALLOWED_NAMES.iter().map(ToString::to_string).collect()),\n     /// Lint: DOC_MARKDOWN.\n     ///\n     /// The list of words this lint should not consider as identifiers needing ticks. The value\n     /// `\"..\"` can be used as part of the list to indicate, that the configured values should be appended to the\n-    /// default configuration of Clippy. By default any configuraction will replace the default value. For example:\n+    /// default configuration of Clippy. By default, any configuration will replace the default value. For example:\n     /// * `doc-valid-idents = [\"ClipPy\"]` would replace the default list with `[\"ClipPy\"]`.\n     /// * `doc-valid-idents = [\"ClipPy\", \"..\"]` would append `ClipPy` to the default list.\n     ///\n@@ -390,7 +390,7 @@ define_Conf! {\n     /// Enforce the named macros always use the braces specified.\n     ///\n     /// A `MacroMatcher` can be added like so `{ name = \"macro_name\", brace = \"(\" }`. If the macro\n-    /// is could be used with a full path two `MacroMatcher`s have to be added one with the full path\n+    /// could be used with a full path two `MacroMatcher`s have to be added one with the full path\n     /// `crate_name::macro_name` and one with just the macro name.\n     (standard_macro_braces: Vec<crate::nonstandard_macro_braces::MacroMatcher> = Vec::new()),\n     /// Lint: MISSING_ENFORCED_IMPORT_RENAMES.\n@@ -408,7 +408,7 @@ define_Conf! {\n     /// Lint: INDEX_REFUTABLE_SLICE.\n     ///\n     /// When Clippy suggests using a slice pattern, this is the maximum number of elements allowed in\n-    /// the slice pattern that is suggested. If more elements would be necessary, the lint is suppressed.\n+    /// the slice pattern that is suggested. If more elements are necessary, the lint is suppressed.\n     /// For example, `[_, _, _, e, ..]` is a slice pattern with 4 elements.\n     (max_suggested_slice_pattern_length: u64 = 3),\n     /// Lint: AWAIT_HOLDING_INVALID_TYPE.\n@@ -459,24 +459,30 @@ define_Conf! {\n     /// Whether to **only** check for missing documentation in items visible within the current\n     /// crate. For example, `pub(crate)` items.\n     (missing_docs_in_crate_items: bool = false),\n+    /// Lint: LARGE_FUTURES.\n+    ///\n+    /// The maximum byte size a `Future` can have, before it triggers the `clippy::large_futures` lint\n+    (future_size_threshold: u64 = 16 * 1024),\n }\n \n /// Search for the configuration file.\n ///\n /// # Errors\n ///\n /// Returns any unexpected filesystem error encountered when searching for the config file\n-pub fn lookup_conf_file() -> io::Result<Option<PathBuf>> {\n+pub fn lookup_conf_file() -> io::Result<(Option<PathBuf>, Vec<String>)> {\n     /// Possible filename to search for.\n     const CONFIG_FILE_NAMES: [&str; 2] = [\".clippy.toml\", \"clippy.toml\"];\n \n     // Start looking for a config file in CLIPPY_CONF_DIR, or failing that, CARGO_MANIFEST_DIR.\n     // If neither of those exist, use \".\".\n     let mut current = env::var_os(\"CLIPPY_CONF_DIR\")\n         .or_else(|| env::var_os(\"CARGO_MANIFEST_DIR\"))\n-        .map_or_else(|| PathBuf::from(\".\"), PathBuf::from);\n+        .map_or_else(|| PathBuf::from(\".\"), PathBuf::from)\n+        .canonicalize()?;\n \n     let mut found_config: Option<PathBuf> = None;\n+    let mut warnings = vec![];\n \n     loop {\n         for config_file_name in &CONFIG_FILE_NAMES {\n@@ -487,12 +493,12 @@ pub fn lookup_conf_file() -> io::Result<Option<PathBuf>> {\n                     Ok(md) if md.is_dir() => {},\n                     Ok(_) => {\n                         // warn if we happen to find two config files #8323\n-                        if let Some(ref found_config_) = found_config {\n-                            eprintln!(\n-                                \"Using config file `{}`\\nWarning: `{}` will be ignored.\",\n-                                found_config_.display(),\n-                                config_file.display(),\n-                            );\n+                        if let Some(ref found_config) = found_config {\n+                            warnings.push(format!(\n+                                \"using config file `{}`, `{}` will be ignored\",\n+                                found_config.display(),\n+                                config_file.display()\n+                            ));\n                         } else {\n                             found_config = Some(config_file);\n                         }\n@@ -502,12 +508,12 @@ pub fn lookup_conf_file() -> io::Result<Option<PathBuf>> {\n         }\n \n         if found_config.is_some() {\n-            return Ok(found_config);\n+            return Ok((found_config, warnings));\n         }\n \n         // If the current directory has no parent, we're done searching.\n         if !current.pop() {\n-            return Ok(None);\n+            return Ok((None, warnings));\n         }\n     }\n }"}, {"sha": "09fcb82c37c88d95b78a87e20c7b3e7a7359c72a", "filename": "clippy_lints/src/utils/format_args_collector.rs", "status": "modified", "additions": 77, "deletions": 2, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Futils%2Fformat_args_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Futils%2Fformat_args_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fformat_args_collector.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,7 +1,12 @@\n use clippy_utils::macros::collect_ast_format_args;\n-use rustc_ast::{Expr, ExprKind};\n+use clippy_utils::source::snippet_opt;\n+use itertools::Itertools;\n+use rustc_ast::{Expr, ExprKind, FormatArgs};\n+use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::hygiene;\n+use std::iter::once;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -15,9 +20,79 @@ declare_clippy_lint! {\n declare_lint_pass!(FormatArgsCollector => [FORMAT_ARGS_COLLECTOR]);\n \n impl EarlyLintPass for FormatArgsCollector {\n-    fn check_expr(&mut self, _: &EarlyContext<'_>, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         if let ExprKind::FormatArgs(args) = &expr.kind {\n+            if has_span_from_proc_macro(cx, args) {\n+                return;\n+            }\n+\n             collect_ast_format_args(expr.span, args);\n         }\n     }\n }\n+\n+/// Detects if the format string or an argument has its span set by a proc macro to something inside\n+/// a macro callsite, e.g.\n+///\n+/// ```ignore\n+/// println!(some_proc_macro!(\"input {}\"), a);\n+/// ```\n+///\n+/// Where `some_proc_macro` expands to\n+///\n+/// ```ignore\n+/// println!(\"output {}\", a);\n+/// ```\n+///\n+/// But with the span of `\"output {}\"` set to the macro input\n+///\n+/// ```ignore\n+/// println!(some_proc_macro!(\"input {}\"), a);\n+/// //                        ^^^^^^^^^^\n+/// ```\n+fn has_span_from_proc_macro(cx: &EarlyContext<'_>, args: &FormatArgs) -> bool {\n+    let ctxt = args.span.ctxt();\n+\n+    // `format!(\"{} {} {c}\", \"one\", \"two\", c = \"three\")`\n+    //                       ^^^^^  ^^^^^      ^^^^^^^\n+    let argument_span = args\n+        .arguments\n+        .explicit_args()\n+        .iter()\n+        .map(|argument| hygiene::walk_chain(argument.expr.span, ctxt));\n+\n+    // `format!(\"{} {} {c}\", \"one\", \"two\", c = \"three\")`\n+    //                     ^^     ^^     ^^^^^^\n+    let between_spans = once(args.span)\n+        .chain(argument_span)\n+        .tuple_windows()\n+        .map(|(start, end)| start.between(end));\n+\n+    for between_span in between_spans {\n+        let mut seen_comma = false;\n+\n+        let Some(snippet) = snippet_opt(cx, between_span) else { return true };\n+        for token in tokenize(&snippet) {\n+            match token.kind {\n+                TokenKind::LineComment { .. } | TokenKind::BlockComment { .. } | TokenKind::Whitespace => {},\n+                TokenKind::Comma if !seen_comma => seen_comma = true,\n+                // named arguments, `start_val, name = end_val`\n+                //                            ^^^^^^^^^ between_span\n+                TokenKind::Ident | TokenKind::Eq if seen_comma => {},\n+                // An unexpected token usually indicates that we crossed a macro boundary\n+                //\n+                // `println!(some_proc_macro!(\"input {}\"), a)`\n+                //                                      ^^^ between_span\n+                // `println!(\"{}\", val!(x))`\n+                //               ^^^^^^^ between_span\n+                _ => return true,\n+            }\n+        }\n+\n+        if !seen_comma {\n+            return true;\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "d7c94b909bdc5ea386ae48e314e83d136fb21961", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -463,12 +463,18 @@ fn check_literal(cx: &LateContext<'_>, format_args: &FormatArgs, name: &str) {\n             && let Some(value_string) = snippet_opt(cx, arg.expr.span)\n     {\n             let (replacement, replace_raw) = match lit.kind {\n-                LitKind::Str | LitKind::StrRaw(_)  => extract_str_literal(&value_string),\n+                LitKind::Str | LitKind::StrRaw(_)  => match extract_str_literal(&value_string) {\n+                    Some(extracted) => extracted,\n+                    None => return,\n+                },\n                 LitKind::Char => (\n                     match lit.symbol.as_str() {\n                         \"\\\"\" => \"\\\\\\\"\",\n                         \"\\\\'\" => \"'\",\n-                        _ => &value_string[1..value_string.len() - 1],\n+                        _ => match value_string.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\'')) {\n+                            Some(stripped) => stripped,\n+                            None => return,\n+                        },\n                     }\n                     .to_string(),\n                     false,\n@@ -533,13 +539,13 @@ fn check_literal(cx: &LateContext<'_>, format_args: &FormatArgs, name: &str) {\n /// `r#\"a\"#` -> (`a`, true)\n ///\n /// `\"b\"` -> (`b`, false)\n-fn extract_str_literal(literal: &str) -> (String, bool) {\n+fn extract_str_literal(literal: &str) -> Option<(String, bool)> {\n     let (literal, raw) = match literal.strip_prefix('r') {\n         Some(stripped) => (stripped.trim_matches('#'), true),\n         None => (literal, false),\n     };\n \n-    (literal[1..literal.len() - 1].to_string(), raw)\n+    Some((literal.strip_prefix('\"')?.strip_suffix('\"')?.to_string(), raw))\n }\n \n enum UnescapeErr {"}, {"sha": "1f15598db36d9438b98c6283a424f3872b65f3b0", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -286,8 +286,30 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n     match (l, r) {\n         (ExternCrate(l), ExternCrate(r)) => l == r,\n         (Use(l), Use(r)) => eq_use_tree(l, r),\n-        (Static(box ast::StaticItem { ty: lt, mutability: lm, expr: le}), Static(box ast::StaticItem { ty: rt, mutability: rm, expr: re})) => lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re),\n-        (Const(box ast::ConstItem { defaultness: ld, ty: lt, expr: le}), Const(box ast::ConstItem { defaultness: rd, ty: rt, expr: re} )) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n+        (\n+            Static(box ast::StaticItem {\n+                ty: lt,\n+                mutability: lm,\n+                expr: le,\n+            }),\n+            Static(box ast::StaticItem {\n+                ty: rt,\n+                mutability: rm,\n+                expr: re,\n+            }),\n+        ) => lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re),\n+        (\n+            Const(box ast::ConstItem {\n+                defaultness: ld,\n+                ty: lt,\n+                expr: le,\n+            }),\n+            Const(box ast::ConstItem {\n+                defaultness: rd,\n+                ty: rt,\n+                expr: re,\n+            }),\n+        ) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n         (\n             Fn(box ast::Fn {\n                 defaultness: ld,\n@@ -451,7 +473,18 @@ pub fn eq_foreign_item_kind(l: &ForeignItemKind, r: &ForeignItemKind) -> bool {\n pub fn eq_assoc_item_kind(l: &AssocItemKind, r: &AssocItemKind) -> bool {\n     use AssocItemKind::*;\n     match (l, r) {\n-        (Const(box ast::ConstItem { defaultness: ld, ty: lt, expr: le}), Const(box ast::ConstItem { defaultness: rd, ty: rt, expr: re})) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n+        (\n+            Const(box ast::ConstItem {\n+                defaultness: ld,\n+                ty: lt,\n+                expr: le,\n+            }),\n+            Const(box ast::ConstItem {\n+                defaultness: rd,\n+                ty: rt,\n+                expr: re,\n+            }),\n+        ) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n         (\n             Fn(box ast::Fn {\n                 defaultness: ld,"}, {"sha": "f1d2ae220f81d3180922408666bb1b795c0cec2c", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -32,7 +32,6 @@ extern crate rustc_lexer;\n extern crate rustc_lint;\n extern crate rustc_middle;\n extern crate rustc_mir_dataflow;\n-extern crate rustc_parse_format;\n extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n@@ -77,7 +76,7 @@ use std::sync::OnceLock;\n use std::sync::{Mutex, MutexGuard};\n \n use if_chain::if_chain;\n-use rustc_ast::ast::{self, LitKind};\n+use rustc_ast::ast::{self, LitKind, RangeLimits};\n use rustc_ast::Attribute;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::unhash::UnhashMap;\n@@ -95,6 +94,7 @@ use rustc_hir::{\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::place::PlaceBase;\n+use rustc_middle::mir::ConstantKind;\n use rustc_middle::ty as rustc_ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc_middle::ty::binding::BindingMode;\n@@ -113,7 +113,8 @@ use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::abi::Integer;\n \n-use crate::consts::{constant, Constant};\n+use crate::consts::{constant, miri_to_const, Constant};\n+use crate::higher::Range;\n use crate::ty::{can_partially_move_ty, expr_sig, is_copy, is_recursively_primitive_type, ty_is_fn_once_param};\n use crate::visitors::for_each_expr;\n \n@@ -1490,6 +1491,68 @@ pub fn is_else_clause(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n     }\n }\n \n+/// Checks whether the given `Expr` is a range equivalent to a `RangeFull`.\n+/// For the lower bound, this means that:\n+/// - either there is none\n+/// - or it is the smallest value that can be represented by the range's integer type\n+/// For the upper bound, this means that:\n+/// - either there is none\n+/// - or it is the largest value that can be represented by the range's integer type and is\n+///   inclusive\n+/// - or it is a call to some container's `len` method and is exclusive, and the range is passed to\n+///   a method call on that same container (e.g. `v.drain(..v.len())`)\n+/// If the given `Expr` is not some kind of range, the function returns `false`.\n+pub fn is_range_full(cx: &LateContext<'_>, expr: &Expr<'_>, container_path: Option<&Path<'_>>) -> bool {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    if let Some(Range { start, end, limits }) = Range::hir(expr) {\n+        let start_is_none_or_min = start.map_or(true, |start| {\n+            if let rustc_ty::Adt(_, subst) = ty.kind()\n+                && let bnd_ty = subst.type_at(0)\n+                && let Some(min_val) = bnd_ty.numeric_min_val(cx.tcx)\n+                && let const_val = cx.tcx.valtree_to_const_val((bnd_ty, min_val.to_valtree()))\n+                && let min_const_kind = ConstantKind::from_value(const_val, bnd_ty)\n+                && let Some(min_const) = miri_to_const(cx.tcx, min_const_kind)\n+                && let Some((start_const, _)) = constant(cx, cx.typeck_results(), start)\n+            {\n+                start_const == min_const\n+            } else {\n+                false\n+            }\n+        });\n+        let end_is_none_or_max = end.map_or(true, |end| {\n+            match limits {\n+                RangeLimits::Closed => {\n+                    if let rustc_ty::Adt(_, subst) = ty.kind()\n+                        && let bnd_ty = subst.type_at(0)\n+                        && let Some(max_val) = bnd_ty.numeric_max_val(cx.tcx)\n+                        && let const_val = cx.tcx.valtree_to_const_val((bnd_ty, max_val.to_valtree()))\n+                        && let max_const_kind = ConstantKind::from_value(const_val, bnd_ty)\n+                        && let Some(max_const) = miri_to_const(cx.tcx, max_const_kind)\n+                        && let Some((end_const, _)) = constant(cx, cx.typeck_results(), end)\n+                    {\n+                        end_const == max_const\n+                    } else {\n+                        false\n+                    }\n+                },\n+                RangeLimits::HalfOpen => {\n+                    if let Some(container_path) = container_path\n+                        && let ExprKind::MethodCall(name, self_arg, [], _) = end.kind\n+                        && name.ident.name == sym::len\n+                        && let ExprKind::Path(QPath::Resolved(None, path)) = self_arg.kind\n+                    {\n+                        container_path.res == path.res\n+                    } else {\n+                        false\n+                    }\n+                },\n+            }\n+        });\n+        return start_is_none_or_min && end_is_none_or_max;\n+    }\n+    false\n+}\n+\n /// Checks whether the given expression is a constant integer of the given value.\n /// unlike `is_integer_literal`, this version does const folding\n pub fn is_integer_const(cx: &LateContext<'_>, e: &Expr<'_>, value: u128) -> bool {\n@@ -2104,8 +2167,7 @@ pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n         .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n     traits::impossible_predicates(\n         cx.tcx,\n-        traits::elaborate_predicates(cx.tcx, predicates)\n-            .collect::<Vec<_>>(),\n+        traits::elaborate_predicates(cx.tcx, predicates).collect::<Vec<_>>(),\n     )\n }\n "}, {"sha": "62d388a5ece8d00fbd5979162997fdd611610f85", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 69, "deletions": 731, "changes": 800, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,24 +1,16 @@\n #![allow(clippy::similar_names)] // `expr` and `expn`\n \n-use crate::source::snippet_opt;\n use crate::visitors::{for_each_expr, Descend};\n \n use arrayvec::ArrayVec;\n-use itertools::{izip, Either, Itertools};\n-use rustc_ast::ast::LitKind;\n-use rustc_ast::FormatArgs;\n+use rustc_ast::{FormatArgs, FormatArgument, FormatPlaceholder};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{self as hir, Expr, ExprField, ExprKind, HirId, LangItem, Node, QPath, TyKind};\n-use rustc_lexer::unescape::unescape_literal;\n-use rustc_lexer::{tokenize, unescape, LiteralKind, TokenKind};\n+use rustc_hir::{self as hir, Expr, ExprKind, HirId, Node, QPath};\n use rustc_lint::LateContext;\n-use rustc_parse_format::{self as rpf, Alignment};\n use rustc_span::def_id::DefId;\n use rustc_span::hygiene::{self, MacroKind, SyntaxContext};\n-use rustc_span::{sym, BytePos, ExpnData, ExpnId, ExpnKind, Pos, Span, SpanData, Symbol};\n+use rustc_span::{sym, BytePos, ExpnData, ExpnId, ExpnKind, Span, Symbol};\n use std::cell::RefCell;\n-use std::iter::{once, zip};\n use std::ops::ControlFlow;\n use std::sync::atomic::{AtomicBool, Ordering};\n \n@@ -226,11 +218,11 @@ pub enum PanicExpn<'a> {\n     /// A single argument that implements `Display` - `panic!(\"{}\", object)`\n     Display(&'a Expr<'a>),\n     /// Anything else - `panic!(\"error {}: {}\", a, b)`\n-    Format(FormatArgsExpn<'a>),\n+    Format(&'a Expr<'a>),\n }\n \n impl<'a> PanicExpn<'a> {\n-    pub fn parse(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Self> {\n+    pub fn parse(expr: &'a Expr<'a>) -> Option<Self> {\n         let ExprKind::Call(callee, [arg, rest @ ..]) = &expr.kind else { return None };\n         let ExprKind::Path(QPath::Resolved(_, path)) = &callee.kind else { return None };\n         let result = match path.segments.last().unwrap().ident.as_str() {\n@@ -240,7 +232,7 @@ impl<'a> PanicExpn<'a> {\n                 let ExprKind::AddrOf(_, _, e) = &arg.kind else { return None };\n                 Self::Display(e)\n             },\n-            \"panic_fmt\" => Self::Format(FormatArgsExpn::parse(cx, arg)?),\n+            \"panic_fmt\" => Self::Format(arg),\n             // Since Rust 1.52, `assert_{eq,ne}` macros expand to use:\n             // `core::panicking::assert_failed(.., left_val, right_val, None | Some(format_args!(..)));`\n             \"assert_failed\" => {\n@@ -252,7 +244,7 @@ impl<'a> PanicExpn<'a> {\n                 // `msg_arg` is either `None` (no custom message) or `Some(format_args!(..))` (custom message)\n                 let msg_arg = &rest[2];\n                 match msg_arg.kind {\n-                    ExprKind::Call(_, [fmt_arg]) => Self::Format(FormatArgsExpn::parse(cx, fmt_arg)?),\n+                    ExprKind::Call(_, [fmt_arg]) => Self::Format(fmt_arg),\n                     _ => Self::Empty,\n                 }\n             },\n@@ -304,7 +296,7 @@ fn find_assert_args_inner<'a, const N: usize>(\n     let mut args = ArrayVec::new();\n     let panic_expn = for_each_expr(expr, |e| {\n         if args.is_full() {\n-            match PanicExpn::parse(cx, e) {\n+            match PanicExpn::parse(e) {\n                 Some(expn) => ControlFlow::Break(expn),\n                 None => ControlFlow::Continue(Descend::Yes),\n             }\n@@ -391,30 +383,82 @@ pub fn collect_ast_format_args(span: Span, format_args: &FormatArgs) {\n     });\n }\n \n-/// Calls `callback` with an AST [`FormatArgs`] node if one is found\n+/// Calls `callback` with an AST [`FormatArgs`] node if a `format_args` expansion is found as a\n+/// descendant of `expn_id`\n pub fn find_format_args(cx: &LateContext<'_>, start: &Expr<'_>, expn_id: ExpnId, callback: impl FnOnce(&FormatArgs)) {\n     let format_args_expr = for_each_expr(start, |expr| {\n         let ctxt = expr.span.ctxt();\n-        if ctxt == start.span.ctxt() {\n-            ControlFlow::Continue(Descend::Yes)\n-        } else if ctxt.outer_expn().is_descendant_of(expn_id)\n-            && macro_backtrace(expr.span)\n+        if ctxt.outer_expn().is_descendant_of(expn_id) {\n+            if macro_backtrace(expr.span)\n                 .map(|macro_call| cx.tcx.item_name(macro_call.def_id))\n                 .any(|name| matches!(name, sym::const_format_args | sym::format_args | sym::format_args_nl))\n-        {\n-            ControlFlow::Break(expr)\n+            {\n+                ControlFlow::Break(expr)\n+            } else {\n+                ControlFlow::Continue(Descend::Yes)\n+            }\n         } else {\n             ControlFlow::Continue(Descend::No)\n         }\n     });\n \n-    if let Some(format_args_expr) = format_args_expr {\n+    if let Some(expr) = format_args_expr {\n         AST_FORMAT_ARGS.with(|ast_format_args| {\n-            ast_format_args.borrow().get(&format_args_expr.span).map(callback);\n+            ast_format_args.borrow().get(&expr.span).map(callback);\n         });\n     }\n }\n \n+/// Attempt to find the [`rustc_hir::Expr`] that corresponds to the [`FormatArgument`]'s value, if\n+/// it cannot be found it will return the [`rustc_ast::Expr`].\n+pub fn find_format_arg_expr<'hir, 'ast>(\n+    start: &'hir Expr<'hir>,\n+    target: &'ast FormatArgument,\n+) -> Result<&'hir rustc_hir::Expr<'hir>, &'ast rustc_ast::Expr> {\n+    for_each_expr(start, |expr| {\n+        if expr.span == target.expr.span {\n+            ControlFlow::Break(expr)\n+        } else {\n+            ControlFlow::Continue(())\n+        }\n+    })\n+    .ok_or(&target.expr)\n+}\n+\n+/// Span of the `:` and format specifiers\n+///\n+/// ```ignore\n+/// format!(\"{:.}\"), format!(\"{foo:.}\")\n+///           ^^                  ^^\n+/// ```\n+pub fn format_placeholder_format_span(placeholder: &FormatPlaceholder) -> Option<Span> {\n+    let base = placeholder.span?.data();\n+\n+    // `base.hi` is `{...}|`, subtract 1 byte (the length of '}') so that it points before the closing\n+    // brace `{...|}`\n+    Some(Span::new(\n+        placeholder.argument.span?.hi(),\n+        base.hi - BytePos(1),\n+        base.ctxt,\n+        base.parent,\n+    ))\n+}\n+\n+/// Span covering the format string and values\n+///\n+/// ```ignore\n+/// format(\"{}.{}\", 10, 11)\n+/// //     ^^^^^^^^^^^^^^^\n+/// ```\n+pub fn format_args_inputs_span(format_args: &FormatArgs) -> Span {\n+    match format_args.arguments.explicit_args() {\n+        [] => format_args.span,\n+        [.., last] => format_args\n+            .span\n+            .to(hygiene::walk_chain(last.expr.span, format_args.span.ctxt())),\n+    }\n+}\n+\n /// Returns the [`Span`] of the value at `index` extended to the previous comma, e.g. for the value\n /// `10`\n ///\n@@ -436,251 +480,6 @@ pub fn format_arg_removal_span(format_args: &FormatArgs, index: usize) -> Option\n     Some(current.with_lo(prev.hi()))\n }\n \n-/// The format string doesn't exist in the HIR, so we reassemble it from source code\n-#[derive(Debug)]\n-pub struct FormatString {\n-    /// Span of the whole format string literal, including `[r#]\"`.\n-    pub span: Span,\n-    /// Snippet of the whole format string literal, including `[r#]\"`.\n-    pub snippet: String,\n-    /// If the string is raw `r\"...\"`/`r#\"\"#`, how many `#`s does it have on each side.\n-    pub style: Option<usize>,\n-    /// The unescaped value of the format string, e.g. `\"val \u2013 {}\"` for the literal\n-    /// `\"val \\u{2013} {}\"`.\n-    pub unescaped: String,\n-    /// The format string split by format args like `{..}`.\n-    pub parts: Vec<Symbol>,\n-}\n-\n-impl FormatString {\n-    fn new(cx: &LateContext<'_>, pieces: &Expr<'_>) -> Option<Self> {\n-        // format_args!(r\"a {} b \\\", 1);\n-        //\n-        // expands to\n-        //\n-        // ::core::fmt::Arguments::new_v1(&[\"a \", \" b \\\\\"],\n-        //      &[::core::fmt::ArgumentV1::new_display(&1)]);\n-        //\n-        // where `pieces` is the expression `&[\"a \", \" b \\\\\"]`. It has the span of `r\"a {} b \\\"`\n-        let span = pieces.span;\n-        let snippet = snippet_opt(cx, span)?;\n-\n-        let (inner, style) = match tokenize(&snippet).next()?.kind {\n-            TokenKind::Literal { kind, .. } => {\n-                let style = match kind {\n-                    LiteralKind::Str { .. } => None,\n-                    LiteralKind::RawStr { n_hashes: Some(n), .. } => Some(n.into()),\n-                    _ => return None,\n-                };\n-\n-                let start = style.map_or(1, |n| 2 + n);\n-                let end = snippet.len() - style.map_or(1, |n| 1 + n);\n-\n-                (&snippet[start..end], style)\n-            },\n-            _ => return None,\n-        };\n-\n-        let mode = if style.is_some() {\n-            unescape::Mode::RawStr\n-        } else {\n-            unescape::Mode::Str\n-        };\n-\n-        let mut unescaped = String::with_capacity(inner.len());\n-        // Sometimes the original string comes from a macro which accepts a malformed string, such as in a\n-        // #[display(\"\"somestring)] attribute (accepted by the `displaythis` crate). Reconstructing the\n-        // string from the span will not be possible, so we will just return None here.\n-        let mut unparsable = false;\n-        unescape_literal(inner, mode, &mut |_, ch| match ch {\n-            Ok(ch) => unescaped.push(ch),\n-            Err(e) if !e.is_fatal() => (),\n-            Err(_) => unparsable = true,\n-        });\n-        if unparsable {\n-            return None;\n-        }\n-\n-        let mut parts = Vec::new();\n-        let _: Option<!> = for_each_expr(pieces, |expr| {\n-            if let ExprKind::Lit(lit) = &expr.kind\n-                && let LitKind::Str(symbol, _) = lit.node\n-            {\n-                parts.push(symbol);\n-            }\n-            ControlFlow::Continue(())\n-        });\n-\n-        Some(Self {\n-            span,\n-            snippet,\n-            style,\n-            unescaped,\n-            parts,\n-        })\n-    }\n-}\n-\n-struct FormatArgsValues<'tcx> {\n-    /// Values passed after the format string and implicit captures. `[1, z + 2, x]` for\n-    /// `format!(\"{x} {} {}\", 1, z + 2)`.\n-    value_args: Vec<&'tcx Expr<'tcx>>,\n-    /// Maps an `rt::v1::Argument::position` or an `rt::v1::Count::Param` to its index in\n-    /// `value_args`\n-    pos_to_value_index: Vec<usize>,\n-    /// Used to check if a value is declared inline & to resolve `InnerSpan`s.\n-    format_string_span: SpanData,\n-}\n-\n-impl<'tcx> FormatArgsValues<'tcx> {\n-    fn new_empty(format_string_span: SpanData) -> Self {\n-        Self {\n-            value_args: Vec::new(),\n-            pos_to_value_index: Vec::new(),\n-            format_string_span,\n-        }\n-    }\n-\n-    fn new(args: &'tcx Expr<'tcx>, format_string_span: SpanData) -> Self {\n-        let mut pos_to_value_index = Vec::new();\n-        let mut value_args = Vec::new();\n-        let _: Option<!> = for_each_expr(args, |expr| {\n-            if expr.span.ctxt() == args.span.ctxt() {\n-                // ArgumentV1::new_<format_trait>(<val>)\n-                // ArgumentV1::from_usize(<val>)\n-                if let ExprKind::Call(callee, [val]) = expr.kind\n-                    && let ExprKind::Path(QPath::TypeRelative(ty, _)) = callee.kind\n-                    && let TyKind::Path(QPath::LangItem(LangItem::FormatArgument, _, _)) = ty.kind\n-                {\n-                    let val_idx = if val.span.ctxt() == expr.span.ctxt()\n-                        && let ExprKind::Field(_, field) = val.kind\n-                        && let Ok(idx) = field.name.as_str().parse()\n-                    {\n-                        // tuple index\n-                        idx\n-                    } else {\n-                        // assume the value expression is passed directly\n-                        pos_to_value_index.len()\n-                    };\n-\n-                    pos_to_value_index.push(val_idx);\n-                }\n-                ControlFlow::Continue(Descend::Yes)\n-            } else {\n-                // assume that any expr with a differing span is a value\n-                value_args.push(expr);\n-                ControlFlow::Continue(Descend::No)\n-            }\n-        });\n-\n-        Self {\n-            value_args,\n-            pos_to_value_index,\n-            format_string_span,\n-        }\n-    }\n-}\n-\n-/// The positions of a format argument's value, precision and width\n-///\n-/// A position is an index into the second argument of `Arguments::new_v1[_formatted]`\n-#[derive(Debug, Default, Copy, Clone)]\n-struct ParamPosition {\n-    /// The position stored in `rt::v1::Argument::position`.\n-    value: usize,\n-    /// The position stored in `rt::v1::FormatSpec::width` if it is a `Count::Param`.\n-    width: Option<usize>,\n-    /// The position stored in `rt::v1::FormatSpec::precision` if it is a `Count::Param`.\n-    precision: Option<usize>,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for ParamPosition {\n-    fn visit_expr_field(&mut self, field: &'tcx ExprField<'tcx>) {\n-        match field.ident.name {\n-            sym::position => {\n-                if let ExprKind::Lit(lit) = &field.expr.kind\n-                    && let LitKind::Int(pos, _) = lit.node\n-                {\n-                    self.value = pos as usize;\n-                }\n-            },\n-            sym::precision => {\n-                self.precision = parse_count(field.expr);\n-            },\n-            sym::width => {\n-                self.width = parse_count(field.expr);\n-            },\n-            _ => walk_expr(self, field.expr),\n-        }\n-    }\n-}\n-\n-fn parse_count(expr: &Expr<'_>) -> Option<usize> {\n-    // <::core::fmt::rt::v1::Count>::Param(1usize),\n-    if let ExprKind::Call(ctor, [val]) = expr.kind\n-        && let ExprKind::Path(QPath::TypeRelative(_, path)) = ctor.kind\n-            && path.ident.name == sym::Param\n-            && let ExprKind::Lit(lit) = &val.kind\n-            && let LitKind::Int(pos, _) = lit.node\n-    {\n-        Some(pos as usize)\n-    } else {\n-        None\n-    }\n-}\n-\n-/// Parses the `fmt` arg of `Arguments::new_v1_formatted(pieces, args, fmt, _)`\n-fn parse_rt_fmt<'tcx>(fmt_arg: &'tcx Expr<'tcx>) -> Option<impl Iterator<Item = ParamPosition> + 'tcx> {\n-    if let ExprKind::AddrOf(.., array) = fmt_arg.kind\n-        && let ExprKind::Array(specs) = array.kind\n-    {\n-        Some(specs.iter().map(|spec| {\n-            if let ExprKind::Call(f, args) = spec.kind\n-                && let ExprKind::Path(QPath::TypeRelative(ty, f)) = f.kind\n-                && let TyKind::Path(QPath::LangItem(LangItem::FormatPlaceholder, _, _)) = ty.kind\n-                && f.ident.name == sym::new\n-                && let [position, _fill, _align, _flags, precision, width] = args\n-                && let ExprKind::Lit(position) = &position.kind\n-                && let LitKind::Int(position, _) = position.node {\n-                    ParamPosition {\n-                        value: position as usize,\n-                        width: parse_count(width),\n-                        precision: parse_count(precision),\n-                    }\n-            } else {\n-                ParamPosition::default()\n-            }\n-        }))\n-    } else {\n-        None\n-    }\n-}\n-\n-/// `Span::from_inner`, but for `rustc_parse_format`'s `InnerSpan`\n-fn span_from_inner(base: SpanData, inner: rpf::InnerSpan) -> Span {\n-    Span::new(\n-        base.lo + BytePos::from_usize(inner.start),\n-        base.lo + BytePos::from_usize(inner.end),\n-        base.ctxt,\n-        base.parent,\n-    )\n-}\n-\n-/// How a format parameter is used in the format string\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub enum FormatParamKind {\n-    /// An implicit parameter , such as `{}` or `{:?}`.\n-    Implicit,\n-    /// A parameter with an explicit number, e.g. `{1}`, `{0:?}`, or `{:.0$}`\n-    Numbered,\n-    /// A parameter with an asterisk precision. e.g. `{:.*}`.\n-    Starred,\n-    /// A named parameter with a named `value_arg`, such as the `x` in `format!(\"{x}\", x = 1)`.\n-    Named(Symbol),\n-    /// An implicit named parameter, such as the `y` in `format!(\"{y}\")`.\n-    NamedInline(Symbol),\n-}\n-\n /// Where a format parameter is being used in the format string\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum FormatParamUsage {\n@@ -692,467 +491,6 @@ pub enum FormatParamUsage {\n     Precision,\n }\n \n-/// A `FormatParam` is any place in a `FormatArgument` that refers to a supplied value, e.g.\n-///\n-/// ```\n-/// let precision = 2;\n-/// format!(\"{:.precision$}\", 0.1234);\n-/// ```\n-///\n-/// has two `FormatParam`s, a [`FormatParamKind::Implicit`] `.kind` with a `.value` of `0.1234`\n-/// and a [`FormatParamKind::NamedInline(\"precision\")`] `.kind` with a `.value` of `2`\n-#[derive(Debug, Copy, Clone)]\n-pub struct FormatParam<'tcx> {\n-    /// The expression this parameter refers to.\n-    pub value: &'tcx Expr<'tcx>,\n-    /// How this parameter refers to its `value`.\n-    pub kind: FormatParamKind,\n-    /// Where this format param is being used - argument/width/precision\n-    pub usage: FormatParamUsage,\n-    /// Span of the parameter, may be zero width. Includes the whitespace of implicit parameters.\n-    ///\n-    /// ```text\n-    /// format!(\"{}, {  }, {0}, {name}\", ...);\n-    ///          ^    ~~    ~    ~~~~\n-    /// ```\n-    pub span: Span,\n-}\n-\n-impl<'tcx> FormatParam<'tcx> {\n-    fn new(\n-        mut kind: FormatParamKind,\n-        usage: FormatParamUsage,\n-        position: usize,\n-        inner: rpf::InnerSpan,\n-        values: &FormatArgsValues<'tcx>,\n-    ) -> Option<Self> {\n-        let value_index = *values.pos_to_value_index.get(position)?;\n-        let value = *values.value_args.get(value_index)?;\n-        let span = span_from_inner(values.format_string_span, inner);\n-\n-        // if a param is declared inline, e.g. `format!(\"{x}\")`, the generated expr's span points\n-        // into the format string\n-        if let FormatParamKind::Named(name) = kind && values.format_string_span.contains(value.span.data()) {\n-            kind = FormatParamKind::NamedInline(name);\n-        }\n-\n-        Some(Self {\n-            value,\n-            kind,\n-            usage,\n-            span,\n-        })\n-    }\n-}\n-\n-/// Used by [width](https://doc.rust-lang.org/std/fmt/#width) and\n-/// [precision](https://doc.rust-lang.org/std/fmt/#precision) specifiers.\n-#[derive(Debug, Copy, Clone)]\n-pub enum Count<'tcx> {\n-    /// Specified with a literal number, stores the value.\n-    Is(usize, Span),\n-    /// Specified using `$` and `*` syntaxes. The `*` format is still considered to be\n-    /// `FormatParamKind::Numbered`.\n-    Param(FormatParam<'tcx>),\n-    /// Not specified.\n-    Implied(Option<Span>),\n-}\n-\n-impl<'tcx> Count<'tcx> {\n-    fn new(\n-        usage: FormatParamUsage,\n-        count: rpf::Count<'_>,\n-        position: Option<usize>,\n-        inner: Option<rpf::InnerSpan>,\n-        values: &FormatArgsValues<'tcx>,\n-    ) -> Option<Self> {\n-        let span = inner.map(|inner| span_from_inner(values.format_string_span, inner));\n-\n-        Some(match count {\n-            rpf::Count::CountIs(val) => Self::Is(val, span?),\n-            rpf::Count::CountIsName(name, _) => Self::Param(FormatParam::new(\n-                FormatParamKind::Named(Symbol::intern(name)),\n-                usage,\n-                position?,\n-                inner?,\n-                values,\n-            )?),\n-            rpf::Count::CountIsParam(_) => Self::Param(FormatParam::new(\n-                FormatParamKind::Numbered,\n-                usage,\n-                position?,\n-                inner?,\n-                values,\n-            )?),\n-            rpf::Count::CountIsStar(_) => Self::Param(FormatParam::new(\n-                FormatParamKind::Starred,\n-                usage,\n-                position?,\n-                inner?,\n-                values,\n-            )?),\n-            rpf::Count::CountImplied => Self::Implied(span),\n-        })\n-    }\n-\n-    pub fn is_implied(self) -> bool {\n-        matches!(self, Count::Implied(_))\n-    }\n-\n-    pub fn param(self) -> Option<FormatParam<'tcx>> {\n-        match self {\n-            Count::Param(param) => Some(param),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn span(self) -> Option<Span> {\n-        match self {\n-            Count::Is(_, span) => Some(span),\n-            Count::Param(param) => Some(param.span),\n-            Count::Implied(span) => span,\n-        }\n-    }\n-}\n-\n-/// Specification for the formatting of an argument in the format string. See\n-/// <https://doc.rust-lang.org/std/fmt/index.html#formatting-parameters> for the precise meanings.\n-#[derive(Debug)]\n-pub struct FormatSpec<'tcx> {\n-    /// Optionally specified character to fill alignment with.\n-    pub fill: Option<char>,\n-    /// Optionally specified alignment.\n-    pub align: Alignment,\n-    /// Whether all flag options are set to default (no flags specified).\n-    pub no_flags: bool,\n-    /// Represents either the maximum width or the integer precision.\n-    pub precision: Count<'tcx>,\n-    /// The minimum width, will be padded according to `width`/`align`\n-    pub width: Count<'tcx>,\n-    /// The formatting trait used by the argument, e.g. `sym::Display` for `{}`, `sym::Debug` for\n-    /// `{:?}`.\n-    pub r#trait: Symbol,\n-    pub trait_span: Option<Span>,\n-}\n-\n-impl<'tcx> FormatSpec<'tcx> {\n-    fn new(spec: rpf::FormatSpec<'_>, positions: ParamPosition, values: &FormatArgsValues<'tcx>) -> Option<Self> {\n-        Some(Self {\n-            fill: spec.fill,\n-            align: spec.align,\n-            no_flags: spec.sign.is_none() && !spec.alternate && !spec.zero_pad && spec.debug_hex.is_none(),\n-            precision: Count::new(\n-                FormatParamUsage::Precision,\n-                spec.precision,\n-                positions.precision,\n-                spec.precision_span,\n-                values,\n-            )?,\n-            width: Count::new(\n-                FormatParamUsage::Width,\n-                spec.width,\n-                positions.width,\n-                spec.width_span,\n-                values,\n-            )?,\n-            r#trait: match spec.ty {\n-                \"\" => sym::Display,\n-                \"?\" => sym::Debug,\n-                \"o\" => sym!(Octal),\n-                \"x\" => sym!(LowerHex),\n-                \"X\" => sym!(UpperHex),\n-                \"p\" => sym::Pointer,\n-                \"b\" => sym!(Binary),\n-                \"e\" => sym!(LowerExp),\n-                \"E\" => sym!(UpperExp),\n-                _ => return None,\n-            },\n-            trait_span: spec\n-                .ty_span\n-                .map(|span| span_from_inner(values.format_string_span, span)),\n-        })\n-    }\n-\n-    /// Returns true if this format spec is unchanged from the default. e.g. returns true for `{}`,\n-    /// `{foo}` and `{2}`, but false for `{:?}`, `{foo:5}` and `{3:.5}`\n-    pub fn is_default(&self) -> bool {\n-        self.r#trait == sym::Display && self.is_default_for_trait()\n-    }\n-\n-    /// Has no other formatting specifiers than setting the format trait. returns true for `{}`,\n-    /// `{foo}`, `{:?}`, but false for `{foo:5}`, `{3:.5?}`\n-    pub fn is_default_for_trait(&self) -> bool {\n-        self.width.is_implied() && self.precision.is_implied() && self.align == Alignment::AlignUnknown && self.no_flags\n-    }\n-}\n-\n-/// A format argument, such as `{}`, `{foo:?}`.\n-#[derive(Debug)]\n-pub struct FormatArg<'tcx> {\n-    /// The parameter the argument refers to.\n-    pub param: FormatParam<'tcx>,\n-    /// How to format `param`.\n-    pub format: FormatSpec<'tcx>,\n-    /// span of the whole argument, `{..}`.\n-    pub span: Span,\n-}\n-\n-impl<'tcx> FormatArg<'tcx> {\n-    /// Span of the `:` and format specifiers\n-    ///\n-    /// ```ignore\n-    /// format!(\"{:.}\"), format!(\"{foo:.}\")\n-    ///           ^^                  ^^\n-    /// ```\n-    pub fn format_span(&self) -> Span {\n-        let base = self.span.data();\n-\n-        // `base.hi` is `{...}|`, subtract 1 byte (the length of '}') so that it points before the closing\n-        // brace `{...|}`\n-        Span::new(self.param.span.hi(), base.hi - BytePos(1), base.ctxt, base.parent)\n-    }\n-}\n-\n-/// A parsed `format_args!` expansion.\n-#[derive(Debug)]\n-pub struct FormatArgsExpn<'tcx> {\n-    /// The format string literal.\n-    pub format_string: FormatString,\n-    /// The format arguments, such as `{:?}`.\n-    pub args: Vec<FormatArg<'tcx>>,\n-    /// Has an added newline due to `println!()`/`writeln!()`/etc. The last format string part will\n-    /// include this added newline.\n-    pub newline: bool,\n-    /// Spans of the commas between the format string and explicit values, excluding any trailing\n-    /// comma\n-    ///\n-    /// ```ignore\n-    /// format!(\"..\", 1, 2, 3,)\n-    /// //          ^  ^  ^\n-    /// ```\n-    comma_spans: Vec<Span>,\n-    /// Explicit values passed after the format string, ignoring implicit captures. `[1, z + 2]` for\n-    /// `format!(\"{x} {} {y}\", 1, z + 2)`.\n-    explicit_values: Vec<&'tcx Expr<'tcx>>,\n-}\n-\n-impl<'tcx> FormatArgsExpn<'tcx> {\n-    /// Gets the spans of the commas inbetween the format string and explicit args, not including\n-    /// any trailing comma\n-    ///\n-    /// ```ignore\n-    /// format!(\"{} {}\", a, b)\n-    /// //             ^  ^\n-    /// ```\n-    ///\n-    /// Ensures that the format string and values aren't coming from a proc macro that sets the\n-    /// output span to that of its input\n-    fn comma_spans(cx: &LateContext<'_>, explicit_values: &[&Expr<'_>], fmt_span: Span) -> Option<Vec<Span>> {\n-        // `format!(\"{} {} {c}\", \"one\", \"two\", c = \"three\")`\n-        //                       ^^^^^  ^^^^^      ^^^^^^^\n-        let value_spans = explicit_values\n-            .iter()\n-            .map(|val| hygiene::walk_chain(val.span, fmt_span.ctxt()));\n-\n-        // `format!(\"{} {} {c}\", \"one\", \"two\", c = \"three\")`\n-        //                     ^^     ^^     ^^^^^^\n-        let between_spans = once(fmt_span)\n-            .chain(value_spans)\n-            .tuple_windows()\n-            .map(|(start, end)| start.between(end));\n-\n-        let mut comma_spans = Vec::new();\n-        for between_span in between_spans {\n-            let mut offset = 0;\n-            let mut seen_comma = false;\n-\n-            for token in tokenize(&snippet_opt(cx, between_span)?) {\n-                match token.kind {\n-                    TokenKind::LineComment { .. } | TokenKind::BlockComment { .. } | TokenKind::Whitespace => {},\n-                    TokenKind::Comma if !seen_comma => {\n-                        seen_comma = true;\n-\n-                        let base = between_span.data();\n-                        comma_spans.push(Span::new(\n-                            base.lo + BytePos(offset),\n-                            base.lo + BytePos(offset + 1),\n-                            base.ctxt,\n-                            base.parent,\n-                        ));\n-                    },\n-                    // named arguments, `start_val, name = end_val`\n-                    //                            ^^^^^^^^^ between_span\n-                    TokenKind::Ident | TokenKind::Eq if seen_comma => {},\n-                    // An unexpected token usually indicates the format string or a value came from a proc macro output\n-                    // that sets the span of its output to an input, e.g. `println!(some_proc_macro!(\"input\"), ..)` that\n-                    // emits a string literal with the span set to that of `\"input\"`\n-                    _ => return None,\n-                }\n-                offset += token.len;\n-            }\n-\n-            if !seen_comma {\n-                return None;\n-            }\n-        }\n-\n-        Some(comma_spans)\n-    }\n-\n-    pub fn parse(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<Self> {\n-        let macro_name = macro_backtrace(expr.span)\n-            .map(|macro_call| cx.tcx.item_name(macro_call.def_id))\n-            .find(|&name| matches!(name, sym::const_format_args | sym::format_args | sym::format_args_nl))?;\n-        let newline = macro_name == sym::format_args_nl;\n-\n-        // ::core::fmt::Arguments::new_const(pieces)\n-        // ::core::fmt::Arguments::new_v1(pieces, args)\n-        // ::core::fmt::Arguments::new_v1_formatted(pieces, args, fmt, _unsafe_arg)\n-        if let ExprKind::Call(callee, [pieces, rest @ ..]) = expr.kind\n-            && let ExprKind::Path(QPath::TypeRelative(ty, seg)) = callee.kind\n-            && let TyKind::Path(QPath::LangItem(LangItem::FormatArguments, _, _)) = ty.kind\n-            && matches!(seg.ident.as_str(), \"new_const\" | \"new_v1\" | \"new_v1_formatted\")\n-        {\n-            let format_string = FormatString::new(cx, pieces)?;\n-\n-            let mut parser = rpf::Parser::new(\n-                &format_string.unescaped,\n-                format_string.style,\n-                Some(format_string.snippet.clone()),\n-                // `format_string.unescaped` does not contain the appended newline\n-                false,\n-                rpf::ParseMode::Format,\n-            );\n-\n-            let parsed_args = parser\n-                .by_ref()\n-                .filter_map(|piece| match piece {\n-                    rpf::Piece::NextArgument(a) => Some(a),\n-                    rpf::Piece::String(_) => None,\n-                })\n-                .collect_vec();\n-            if !parser.errors.is_empty() {\n-                return None;\n-            }\n-\n-            let positions = if let Some(fmt_arg) = rest.get(1) {\n-                // If the argument contains format specs, `new_v1_formatted(_, _, fmt, _)`, parse\n-                // them.\n-\n-                Either::Left(parse_rt_fmt(fmt_arg)?)\n-            } else {\n-                // If no format specs are given, the positions are in the given order and there are\n-                // no `precision`/`width`s to consider.\n-\n-                Either::Right((0..).map(|n| ParamPosition {\n-                    value: n,\n-                    width: None,\n-                    precision: None,\n-                }))\n-            };\n-\n-            let values = if let Some(args) = rest.first() {\n-                FormatArgsValues::new(args, format_string.span.data())\n-            } else {\n-                FormatArgsValues::new_empty(format_string.span.data())\n-            };\n-\n-            let args = izip!(positions, parsed_args, parser.arg_places)\n-                .map(|(position, parsed_arg, arg_span)| {\n-                    Some(FormatArg {\n-                        param: FormatParam::new(\n-                            match parsed_arg.position {\n-                                rpf::Position::ArgumentImplicitlyIs(_) => FormatParamKind::Implicit,\n-                                rpf::Position::ArgumentIs(_) => FormatParamKind::Numbered,\n-                                // NamedInline is handled by `FormatParam::new()`\n-                                rpf::Position::ArgumentNamed(name) => FormatParamKind::Named(Symbol::intern(name)),\n-                            },\n-                            FormatParamUsage::Argument,\n-                            position.value,\n-                            parsed_arg.position_span,\n-                            &values,\n-                        )?,\n-                        format: FormatSpec::new(parsed_arg.format, position, &values)?,\n-                        span: span_from_inner(values.format_string_span, arg_span),\n-                    })\n-                })\n-                .collect::<Option<Vec<_>>>()?;\n-\n-            let mut explicit_values = values.value_args;\n-            // remove values generated for implicitly captured vars\n-            let len = explicit_values\n-                .iter()\n-                .take_while(|val| !format_string.span.contains(val.span))\n-                .count();\n-            explicit_values.truncate(len);\n-\n-            let comma_spans = Self::comma_spans(cx, &explicit_values, format_string.span)?;\n-\n-            Some(Self {\n-                format_string,\n-                args,\n-                newline,\n-                comma_spans,\n-                explicit_values,\n-            })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn find_nested(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, expn_id: ExpnId) -> Option<Self> {\n-        for_each_expr(expr, |e| {\n-            let e_ctxt = e.span.ctxt();\n-            if e_ctxt == expr.span.ctxt() {\n-                ControlFlow::Continue(Descend::Yes)\n-            } else if e_ctxt.outer_expn().is_descendant_of(expn_id) {\n-                if let Some(args) = FormatArgsExpn::parse(cx, e) {\n-                    ControlFlow::Break(args)\n-                } else {\n-                    ControlFlow::Continue(Descend::No)\n-                }\n-            } else {\n-                ControlFlow::Continue(Descend::No)\n-            }\n-        })\n-    }\n-\n-    /// Source callsite span of all inputs\n-    pub fn inputs_span(&self) -> Span {\n-        match *self.explicit_values {\n-            [] => self.format_string.span,\n-            [.., last] => self\n-                .format_string\n-                .span\n-                .to(hygiene::walk_chain(last.span, self.format_string.span.ctxt())),\n-        }\n-    }\n-\n-    /// Get the span of a value expanded to the previous comma, e.g. for the value `10`\n-    ///\n-    /// ```ignore\n-    /// format(\"{}.{}\", 10, 11)\n-    /// //            ^^^^\n-    /// ```\n-    pub fn value_with_prev_comma_span(&self, value_id: HirId) -> Option<Span> {\n-        for (comma_span, value) in zip(&self.comma_spans, &self.explicit_values) {\n-            if value.hir_id == value_id {\n-                return Some(comma_span.to(hygiene::walk_chain(value.span, comma_span.ctxt())));\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    /// Iterator of all format params, both values and those referenced by `width`/`precision`s.\n-    pub fn params(&'tcx self) -> impl Iterator<Item = FormatParam<'tcx>> {\n-        self.args\n-            .iter()\n-            .flat_map(|arg| [Some(arg.param), arg.format.precision.param(), arg.format.width.param()])\n-            .flatten()\n-    }\n-}\n-\n /// A node with a `HirId` and a `Span`\n pub trait HirNode {\n     fn hir_id(&self) -> HirId;"}, {"sha": "9be2d0eae80aad31bcc3be248e1dde9403f3d881", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -23,6 +23,7 @@ pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CORE_ITER_CLONED: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"cloned\"];\n pub const CORE_ITER_COPIED: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"copied\"];\n pub const CORE_ITER_FILTER: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"filter\"];\n+pub const CORE_RESULT_OK_METHOD: [&str; 4] = [\"core\", \"result\", \"Result\", \"ok\"];\n pub const CSTRING_AS_C_STR: [&str; 5] = [\"alloc\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n@@ -113,6 +114,7 @@ pub const STDERR: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stderr\"];\n pub const STDOUT: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stdout\"];\n pub const CONVERT_IDENTITY: [&str; 3] = [\"core\", \"convert\", \"identity\"];\n pub const STD_FS_CREATE_DIR: [&str; 3] = [\"std\", \"fs\", \"create_dir\"];\n+pub const STD_IO_LINES: [&str; 3] = [\"std\", \"io\", \"Lines\"];\n pub const STD_IO_SEEK: [&str; 3] = [\"std\", \"io\", \"Seek\"];\n pub const STD_IO_SEEK_FROM_CURRENT: [&str; 4] = [\"std\", \"io\", \"SeekFrom\", \"Current\"];\n pub const STD_IO_SEEKFROM_START: [&str; 4] = [\"std\", \"io\", \"SeekFrom\", \"Start\"];"}, {"sha": "9449f0b55674dbf0a8560cd24342e075411bd2be", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -541,9 +541,25 @@ pub fn same_type_and_consts<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n pub fn is_uninit_value_valid_for_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     cx.tcx\n         .check_validity_requirement((ValidityRequirement::Uninit, cx.param_env.and(ty)))\n-        // For types containing generic parameters we cannot get a layout to check.\n-        // Therefore, we are conservative and assume that they don't allow uninit.\n-        .unwrap_or(false)\n+        .unwrap_or_else(|_| is_uninit_value_valid_for_ty_fallback(cx, ty))\n+}\n+\n+/// A fallback for polymorphic types, which are not supported by `check_validity_requirement`.\n+fn is_uninit_value_valid_for_ty_fallback<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match *ty.kind() {\n+        // The array length may be polymorphic, let's try the inner type.\n+        ty::Array(component, _) => is_uninit_value_valid_for_ty(cx, component),\n+        // Peek through tuples and try their fallbacks.\n+        ty::Tuple(types) => types.iter().all(|ty| is_uninit_value_valid_for_ty(cx, ty)),\n+        // Unions are always fine right now.\n+        // This includes MaybeUninit, the main way people use uninitialized memory.\n+        // For ADTs, we could look at all fields just like for tuples, but that's potentially\n+        // exponential, so let's avoid doing that for now. Code doing that is sketchy enough to\n+        // just use an `#[allow()]`.\n+        ty::Adt(adt, _) => adt.is_union(),\n+        // For the rest, conservatively assume that they cannot be uninit.\n+        _ => false,\n+    }\n }\n \n /// Gets an iterator over all predicates which apply to the given item."}, {"sha": "ffb99cde4f8690facf16da165cef8d8f802d3951", "filename": "etc/relicense/RELICENSE_DOCUMENTATION.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/etc%2Frelicense%2FRELICENSE_DOCUMENTATION.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/etc%2Frelicense%2FRELICENSE_DOCUMENTATION.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/etc%2Frelicense%2FRELICENSE_DOCUMENTATION.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -35,7 +35,7 @@ relicensing are archived on GitHub. We also have saved Wayback Machine copies of\n \n The usernames of commenters on these issues can be found in relicense_comments.txt\n \n-There are a couple people in relicense_comments.txt who are not found in contributors.txt:\n+There are a few people in relicense_comments.txt who are not found in contributors.txt:\n \n - @EpocSquadron has [made minor text contributions to the\n   README](https://github.com/rust-lang/rust-clippy/commits?author=EpocSquadron) which have since been overwritten, and\n@@ -55,7 +55,7 @@ There are a couple people in relicense_comments.txt who are not found in contrib\n   we rewrote (see below)\n \n \n-Two of these contributors had nonminor contributions (#2184, #427) requiring a rewrite, carried out in #3251\n+Two of these contributors had non-minor contributions (#2184, #427) requiring a rewrite, carried out in #3251\n ([archive](http://web.archive.org/web/20181005192411/https://github.com/rust-lang-nursery/rust-clippy/pull/3251),\n [screenshot](https://user-images.githubusercontent.com/1617736/46573515-5cb69580-c94b-11e8-86e5-b456452121b2.png))\n "}, {"sha": "faf3ce9093a21c29601ddc623ff3518188e6005a", "filename": "lintcheck/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/lintcheck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/lintcheck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2FREADME.md?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -16,7 +16,7 @@ or\n cargo lintcheck\n ```\n \n-By default the logs will be saved into\n+By default, the logs will be saved into\n `lintcheck-logs/lintcheck_crates_logs.txt`.\n \n You can set a custom sources.toml by adding `--crates-toml custom.toml` or using"}, {"sha": "718bc41fb9924c751c64ce7879f89d427a146cc9", "filename": "src/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -130,7 +130,7 @@ impl rustc_driver::Callbacks for ClippyCallbacks {\n     #[allow(rustc::bad_opt_access)]\n     fn config(&mut self, config: &mut interface::Config) {\n         let conf_path = clippy_lints::lookup_conf_file();\n-        let conf_path_string = if let Ok(Some(path)) = &conf_path {\n+        let conf_path_string = if let Ok((Some(path), _)) = &conf_path {\n             path.to_str().map(String::from)\n         } else {\n             None"}, {"sha": "aa1b3c638a036ba0a9e62a9aeb4c97526b258f12", "filename": "tests/ui-cargo/multiple_config_files/warn/src/main.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fsrc%2Fmain.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,2 +1,4 @@\n-Using config file `$SRC_DIR/.clippy.toml`\n-Warning: `$SRC_DIR/clippy.toml` will be ignored.\n+warning: using config file `$SRC_DIR/.clippy.toml`, `$SRC_DIR/clippy.toml` will be ignored\n+\n+warning: 1 warning emitted\n+"}, {"sha": "1be0cda12fc11213b304bdfad651c7649c695667", "filename": "tests/ui-toml/allow_mixed_uninlined_format_args/uninlined_format_args.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui-toml%2Fallow_mixed_uninlined_format_args%2Funinlined_format_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui-toml%2Fallow_mixed_uninlined_format_args%2Funinlined_format_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fallow_mixed_uninlined_format_args%2Funinlined_format_args.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -11,29 +11,29 @@ LL -     println!(\"val='{}'\", local_i32);\n LL +     println!(\"val='{local_i32}'\");\n    |\n \n-error: literal with an empty format string\n-  --> $DIR/uninlined_format_args.rs:10:35\n+error: variables can be used directly in the `format!` string\n+  --> $DIR/uninlined_format_args.rs:10:5\n    |\n LL |     println!(\"Hello {} is {:.*}\", \"x\", local_i32, local_f64);\n-   |                                   ^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: `-D clippy::print-literal` implied by `-D warnings`\n-help: try this\n+help: change this to\n    |\n LL -     println!(\"Hello {} is {:.*}\", \"x\", local_i32, local_f64);\n-LL +     println!(\"Hello x is {:.*}\", local_i32, local_f64);\n+LL +     println!(\"Hello {} is {local_f64:.local_i32$}\", \"x\");\n    |\n \n-error: variables can be used directly in the `format!` string\n-  --> $DIR/uninlined_format_args.rs:10:5\n+error: literal with an empty format string\n+  --> $DIR/uninlined_format_args.rs:10:35\n    |\n LL |     println!(\"Hello {} is {:.*}\", \"x\", local_i32, local_f64);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                   ^^^\n    |\n-help: change this to\n+   = note: `-D clippy::print-literal` implied by `-D warnings`\n+help: try this\n    |\n LL -     println!(\"Hello {} is {:.*}\", \"x\", local_i32, local_f64);\n-LL +     println!(\"Hello {} is {local_f64:.local_i32$}\", \"x\");\n+LL +     println!(\"Hello x is {:.*}\", local_i32, local_f64);\n    |\n \n error: variables can be used directly in the `format!` string"}, {"sha": "5f304987aa94a4e34d506e82a7ae7bf3c0111ce0", "filename": "tests/ui-toml/extra_unused_type_parameters/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fclippy.toml?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1 @@\n+avoid-breaking-exported-api = true"}, {"sha": "5655232455cb784eb653b0017a8f2c39fc38772d", "filename": "tests/ui-toml/extra_unused_type_parameters/extra_unused_type_parameters.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fextra_unused_type_parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fextra_unused_type_parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fextra_unused_type_parameters.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,9 @@\n+pub struct S;\n+\n+impl S {\n+    pub fn exported_fn<T>() {\n+        unimplemented!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "61bb17fdf6bdb4c8b3f85a400a1bce7dff4f2486", "filename": "tests/ui-toml/large_futures/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui-toml%2Flarge_futures%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui-toml%2Flarge_futures%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Flarge_futures%2Fclippy.toml?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1 @@\n+future-size-threshold = 1024"}, {"sha": "4158df8b5ff55ad8f1acc72f8fb022d19f015668", "filename": "tests/ui-toml/large_futures/large_futures.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui-toml%2Flarge_futures%2Flarge_futures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui-toml%2Flarge_futures%2Flarge_futures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Flarge_futures%2Flarge_futures.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,27 @@\n+#![warn(clippy::large_futures)]\n+\n+fn main() {}\n+\n+pub async fn should_warn() {\n+    let x = [0u8; 1024];\n+    async {}.await;\n+    dbg!(x);\n+}\n+\n+pub async fn should_not_warn() {\n+    let x = [0u8; 1020];\n+    async {}.await;\n+    dbg!(x);\n+}\n+\n+pub async fn bar() {\n+    should_warn().await;\n+\n+    async {\n+        let x = [0u8; 1024];\n+        dbg!(x);\n+    }\n+    .await;\n+\n+    should_not_warn().await;\n+}"}, {"sha": "b92734de2f08c7ff93861caf8b8e1d30e32ecd3d", "filename": "tests/ui-toml/large_futures/large_futures.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui-toml%2Flarge_futures%2Flarge_futures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui-toml%2Flarge_futures%2Flarge_futures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Flarge_futures%2Flarge_futures.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,10 @@\n+error: large future with a size of 1026 bytes\n+  --> $DIR/large_futures.rs:18:5\n+   |\n+LL |     should_warn().await;\n+   |     ^^^^^^^^^^^^^ help: consider `Box::pin` on it: `Box::pin(should_warn())`\n+   |\n+   = note: `-D clippy::large-futures` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "8447c31722dd015249440af39faddafc7cd125e3", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -24,6 +24,7 @@ error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown fie\n            enforced-import-renames\n            enum-variant-name-threshold\n            enum-variant-size-threshold\n+           future-size-threshold\n            ignore-interior-mutability\n            large-error-threshold\n            literal-representation-threshold"}, {"sha": "3c06676d7228a4a8a2a52bfb12f6b96333895948", "filename": "tests/ui/arithmetic_side_effects.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Farithmetic_side_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Farithmetic_side_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Farithmetic_side_effects.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -425,4 +425,8 @@ pub fn integer_arithmetic() {\n     i ^= i;\n }\n \n+pub fn issue_10583(a: u16) -> u16 {\n+    10 / a\n+}\n+\n fn main() {}"}, {"sha": "2c8ee2884e7328bc140f50166d481f38a4d02209", "filename": "tests/ui/arithmetic_side_effects.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Farithmetic_side_effects.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Farithmetic_side_effects.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Farithmetic_side_effects.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -576,6 +576,12 @@ error: arithmetic operation that can potentially result in unexpected side-effec\n LL |     i * 2;\n    |     ^^^^^\n \n+error: arithmetic operation that can potentially result in unexpected side-effects\n+  --> $DIR/arithmetic_side_effects.rs:394:5\n+   |\n+LL |     1 % i / 2;\n+   |     ^^^^^\n+\n error: arithmetic operation that can potentially result in unexpected side-effects\n   --> $DIR/arithmetic_side_effects.rs:395:5\n    |\n@@ -642,5 +648,11 @@ error: arithmetic operation that can potentially result in unexpected side-effec\n LL |     i %= var2;\n    |     ^^^^^^^^^\n \n-error: aborting due to 107 previous errors\n+error: arithmetic operation that can potentially result in unexpected side-effects\n+  --> $DIR/arithmetic_side_effects.rs:429:5\n+   |\n+LL |     10 / a\n+   |     ^^^^^^\n+\n+error: aborting due to 109 previous errors\n "}, {"sha": "3d5beab1eff1ce1c6f0cd394270c9634c17bcd47", "filename": "tests/ui/auxiliary/proc_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fauxiliary%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fauxiliary%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fproc_macros.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -63,7 +63,7 @@ fn group_with_span(delimiter: Delimiter, stream: TokenStream, span: Span) -> Gro\n /// Token used to escape the following token from the macro's span rules.\n const ESCAPE_CHAR: char = '$';\n \n-/// Takes a single token followed by a sequence tokens. Returns the sequence of tokens with their\n+/// Takes a single token followed by a sequence of tokens. Returns the sequence of tokens with their\n /// span set to that of the first token. Tokens may be escaped with either `#ident` or `#(tokens)`.\n #[proc_macro]\n pub fn with_span(input: TokenStream) -> TokenStream {"}, {"sha": "a86b85706a345f7b4da741d7fb549a9a6eff7cb2", "filename": "tests/ui/cast.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -29,6 +29,12 @@ fn main() {\n     1f64 as isize;\n     1f64 as usize;\n     1f32 as u32 as u16;\n+    {\n+        let _x: i8 = 1i32 as _;\n+        1f32 as i32;\n+        1f64 as i32;\n+        1f32 as u8;\n+    }\n     // Test clippy::cast_possible_wrap\n     1u8 as i8;\n     1u16 as i16;"}, {"sha": "65ecf1aa37aaad744a9ba13f6b7c17e449fdfd9e", "filename": "tests/ui/cast.stderr", "status": "modified", "additions": 65, "deletions": 47, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fcast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fcast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -44,10 +44,6 @@ LL |     1f32 as i32;\n    |\n    = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n    = note: `-D clippy::cast-possible-truncation` implied by `-D warnings`\n-help: ... or use `try_from` and handle the error accordingly\n-   |\n-LL |     i32::try_from(1f32);\n-   |     ~~~~~~~~~~~~~~~~~~~\n \n error: casting `f32` to `u32` may truncate the value\n   --> $DIR/cast.rs:25:5\n@@ -56,10 +52,6 @@ LL |     1f32 as u32;\n    |     ^^^^^^^^^^^\n    |\n    = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n-help: ... or use `try_from` and handle the error accordingly\n-   |\n-LL |     u32::try_from(1f32);\n-   |     ~~~~~~~~~~~~~~~~~~~\n \n error: casting `f32` to `u32` may lose the sign of the value\n   --> $DIR/cast.rs:25:5\n@@ -76,10 +68,6 @@ LL |     1f64 as f32;\n    |     ^^^^^^^^^^^\n    |\n    = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n-help: ... or use `try_from` and handle the error accordingly\n-   |\n-LL |     f32::try_from(1f64);\n-   |     ~~~~~~~~~~~~~~~~~~~\n \n error: casting `i32` to `i8` may truncate the value\n   --> $DIR/cast.rs:27:5\n@@ -112,10 +100,6 @@ LL |     1f64 as isize;\n    |     ^^^^^^^^^^^^^\n    |\n    = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n-help: ... or use `try_from` and handle the error accordingly\n-   |\n-LL |     isize::try_from(1f64);\n-   |     ~~~~~~~~~~~~~~~~~~~~~\n \n error: casting `f64` to `usize` may truncate the value\n   --> $DIR/cast.rs:30:5\n@@ -124,10 +108,6 @@ LL |     1f64 as usize;\n    |     ^^^^^^^^^^^^^\n    |\n    = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n-help: ... or use `try_from` and handle the error accordingly\n-   |\n-LL |     usize::try_from(1f64);\n-   |     ~~~~~~~~~~~~~~~~~~~~~\n \n error: casting `f64` to `usize` may lose the sign of the value\n   --> $DIR/cast.rs:30:5\n@@ -154,63 +134,101 @@ LL |     1f32 as u32 as u16;\n    |     ^^^^^^^^^^^\n    |\n    = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n-help: ... or use `try_from` and handle the error accordingly\n-   |\n-LL |     u32::try_from(1f32) as u16;\n-   |     ~~~~~~~~~~~~~~~~~~~\n \n error: casting `f32` to `u32` may lose the sign of the value\n   --> $DIR/cast.rs:31:5\n    |\n LL |     1f32 as u32 as u16;\n    |     ^^^^^^^^^^^\n \n+error: casting `i32` to `i8` may truncate the value\n+  --> $DIR/cast.rs:33:22\n+   |\n+LL |         let _x: i8 = 1i32 as _;\n+   |                      ^^^^^^^^^\n+   |\n+   = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n+help: ... or use `try_from` and handle the error accordingly\n+   |\n+LL |         let _x: i8 = 1i32.try_into();\n+   |                      ~~~~~~~~~~~~~~~\n+\n+error: casting `f32` to `i32` may truncate the value\n+  --> $DIR/cast.rs:34:9\n+   |\n+LL |         1f32 as i32;\n+   |         ^^^^^^^^^^^\n+   |\n+   = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n+\n+error: casting `f64` to `i32` may truncate the value\n+  --> $DIR/cast.rs:35:9\n+   |\n+LL |         1f64 as i32;\n+   |         ^^^^^^^^^^^\n+   |\n+   = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n+\n+error: casting `f32` to `u8` may truncate the value\n+  --> $DIR/cast.rs:36:9\n+   |\n+LL |         1f32 as u8;\n+   |         ^^^^^^^^^^\n+   |\n+   = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n+\n+error: casting `f32` to `u8` may lose the sign of the value\n+  --> $DIR/cast.rs:36:9\n+   |\n+LL |         1f32 as u8;\n+   |         ^^^^^^^^^^\n+\n error: casting `u8` to `i8` may wrap around the value\n-  --> $DIR/cast.rs:33:5\n+  --> $DIR/cast.rs:39:5\n    |\n LL |     1u8 as i8;\n    |     ^^^^^^^^^\n    |\n    = note: `-D clippy::cast-possible-wrap` implied by `-D warnings`\n \n error: casting `u16` to `i16` may wrap around the value\n-  --> $DIR/cast.rs:34:5\n+  --> $DIR/cast.rs:40:5\n    |\n LL |     1u16 as i16;\n    |     ^^^^^^^^^^^\n \n error: casting `u32` to `i32` may wrap around the value\n-  --> $DIR/cast.rs:35:5\n+  --> $DIR/cast.rs:41:5\n    |\n LL |     1u32 as i32;\n    |     ^^^^^^^^^^^\n \n error: casting `u64` to `i64` may wrap around the value\n-  --> $DIR/cast.rs:36:5\n+  --> $DIR/cast.rs:42:5\n    |\n LL |     1u64 as i64;\n    |     ^^^^^^^^^^^\n \n error: casting `usize` to `isize` may wrap around the value\n-  --> $DIR/cast.rs:37:5\n+  --> $DIR/cast.rs:43:5\n    |\n LL |     1usize as isize;\n    |     ^^^^^^^^^^^^^^^\n \n error: casting `i32` to `u32` may lose the sign of the value\n-  --> $DIR/cast.rs:40:5\n+  --> $DIR/cast.rs:46:5\n    |\n LL |     -1i32 as u32;\n    |     ^^^^^^^^^^^^\n \n error: casting `isize` to `usize` may lose the sign of the value\n-  --> $DIR/cast.rs:42:5\n+  --> $DIR/cast.rs:48:5\n    |\n LL |     -1isize as usize;\n    |     ^^^^^^^^^^^^^^^^\n \n error: casting `i64` to `i8` may truncate the value\n-  --> $DIR/cast.rs:109:5\n+  --> $DIR/cast.rs:115:5\n    |\n LL |     (-99999999999i64).min(1) as i8; // should be linted because signed\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -222,7 +240,7 @@ LL |     i8::try_from((-99999999999i64).min(1)); // should be linted because sig\n    |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: casting `u64` to `u8` may truncate the value\n-  --> $DIR/cast.rs:121:5\n+  --> $DIR/cast.rs:127:5\n    |\n LL |     999999u64.clamp(0, 256) as u8; // should still be linted\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -234,7 +252,7 @@ LL |     u8::try_from(999999u64.clamp(0, 256)); // should still be linted\n    |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: casting `main::E2` to `u8` may truncate the value\n-  --> $DIR/cast.rs:142:21\n+  --> $DIR/cast.rs:148:21\n    |\n LL |             let _ = self as u8;\n    |                     ^^^^^^^^^^\n@@ -246,15 +264,15 @@ LL |             let _ = u8::try_from(self);\n    |                     ~~~~~~~~~~~~~~~~~~\n \n error: casting `main::E2::B` to `u8` will truncate the value\n-  --> $DIR/cast.rs:143:21\n+  --> $DIR/cast.rs:149:21\n    |\n LL |             let _ = Self::B as u8;\n    |                     ^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::cast-enum-truncation` implied by `-D warnings`\n \n error: casting `main::E5` to `i8` may truncate the value\n-  --> $DIR/cast.rs:179:21\n+  --> $DIR/cast.rs:185:21\n    |\n LL |             let _ = self as i8;\n    |                     ^^^^^^^^^^\n@@ -266,13 +284,13 @@ LL |             let _ = i8::try_from(self);\n    |                     ~~~~~~~~~~~~~~~~~~\n \n error: casting `main::E5::A` to `i8` will truncate the value\n-  --> $DIR/cast.rs:180:21\n+  --> $DIR/cast.rs:186:21\n    |\n LL |             let _ = Self::A as i8;\n    |                     ^^^^^^^^^^^^^\n \n error: casting `main::E6` to `i16` may truncate the value\n-  --> $DIR/cast.rs:194:21\n+  --> $DIR/cast.rs:200:21\n    |\n LL |             let _ = self as i16;\n    |                     ^^^^^^^^^^^\n@@ -284,7 +302,7 @@ LL |             let _ = i16::try_from(self);\n    |                     ~~~~~~~~~~~~~~~~~~~\n \n error: casting `main::E7` to `usize` may truncate the value on targets with 32-bit wide pointers\n-  --> $DIR/cast.rs:209:21\n+  --> $DIR/cast.rs:215:21\n    |\n LL |             let _ = self as usize;\n    |                     ^^^^^^^^^^^^^\n@@ -296,7 +314,7 @@ LL |             let _ = usize::try_from(self);\n    |                     ~~~~~~~~~~~~~~~~~~~~~\n \n error: casting `main::E10` to `u16` may truncate the value\n-  --> $DIR/cast.rs:250:21\n+  --> $DIR/cast.rs:256:21\n    |\n LL |             let _ = self as u16;\n    |                     ^^^^^^^^^^^\n@@ -308,28 +326,28 @@ LL |             let _ = u16::try_from(self);\n    |                     ~~~~~~~~~~~~~~~~~~~\n \n error: casting `u32` to `u8` may truncate the value\n-  --> $DIR/cast.rs:258:13\n+  --> $DIR/cast.rs:264:13\n    |\n LL |     let c = (q >> 16) as u8;\n    |             ^^^^^^^^^^^^^^^\n    |\n    = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n help: ... or use `try_from` and handle the error accordingly\n    |\n-LL |     let c = u8::try_from((q >> 16));\n-   |             ~~~~~~~~~~~~~~~~~~~~~~~\n+LL |     let c = u8::try_from(q >> 16);\n+   |             ~~~~~~~~~~~~~~~~~~~~~\n \n error: casting `u32` to `u8` may truncate the value\n-  --> $DIR/cast.rs:261:13\n+  --> $DIR/cast.rs:267:13\n    |\n LL |     let c = (q / 1000) as u8;\n    |             ^^^^^^^^^^^^^^^^\n    |\n    = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n help: ... or use `try_from` and handle the error accordingly\n    |\n-LL |     let c = u8::try_from((q / 1000));\n-   |             ~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |     let c = u8::try_from(q / 1000);\n+   |             ~~~~~~~~~~~~~~~~~~~~~~\n \n-error: aborting due to 36 previous errors\n+error: aborting due to 41 previous errors\n "}, {"sha": "9c4dc010ca7fb87f47fead83809c2962cca4c050", "filename": "tests/ui/clear_with_drain.fixed", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fclear_with_drain.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fclear_with_drain.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclear_with_drain.fixed?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,86 @@\n+// run-rustfix\n+#![allow(unused)]\n+#![warn(clippy::clear_with_drain)]\n+\n+fn range() {\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(0..v.len()); // Yay\n+\n+    let mut v = vec![1, 2, 3];\n+    let n = v.drain(0..v.len()).count(); // Yay\n+\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(usize::MIN..v.len()); // Yay\n+    let n = iter.count();\n+\n+    let mut v = vec![1, 2, 3];\n+    v.clear(); // Nay\n+\n+    let mut v = vec![1, 2, 3];\n+    v.clear(); // Nay\n+}\n+\n+fn range_from() {\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(0..); // Yay\n+\n+    let mut v = vec![1, 2, 3];\n+    let mut iter = v.drain(0..); // Yay\n+    let next = iter.next();\n+\n+    let mut v = vec![1, 2, 3];\n+    let next = v.drain(usize::MIN..).next(); // Yay\n+\n+    let mut v = vec![1, 2, 3];\n+    v.clear(); // Nay\n+\n+    let mut v = vec![1, 2, 3];\n+    v.clear(); // Nay\n+}\n+\n+fn range_full() {\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(..); // Yay\n+\n+    let mut v = vec![1, 2, 3];\n+    // Yay\n+    for x in v.drain(..) {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    let mut v = vec![1, 2, 3];\n+    v.clear(); // Nay\n+}\n+\n+fn range_to() {\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(..v.len()); // Yay\n+\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(..v.len()); // Yay\n+    for x in iter {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    let mut v = vec![1, 2, 3];\n+    v.clear(); // Nay\n+}\n+\n+fn partial_drains() {\n+    let mut v = vec![1, 2, 3];\n+    v.drain(1..); // Yay\n+    let mut v = vec![1, 2, 3];\n+    v.drain(1..).max(); // Yay\n+\n+    let mut v = vec![1, 2, 3];\n+    v.drain(..v.len() - 1); // Yay\n+    let mut v = vec![1, 2, 3];\n+    v.drain(..v.len() - 1).min(); // Yay\n+\n+    let mut v = vec![1, 2, 3];\n+    v.drain(1..v.len() - 1); // Yay\n+    let mut v = vec![1, 2, 3];\n+    let w: Vec<i8> = v.drain(1..v.len() - 1).collect(); // Yay\n+}\n+\n+fn main() {}"}, {"sha": "f00dbab234cc80e2baa18c741fc9fc20953fdf37", "filename": "tests/ui/clear_with_drain.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fclear_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fclear_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclear_with_drain.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,86 @@\n+// run-rustfix\n+#![allow(unused)]\n+#![warn(clippy::clear_with_drain)]\n+\n+fn range() {\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(0..v.len()); // Yay\n+\n+    let mut v = vec![1, 2, 3];\n+    let n = v.drain(0..v.len()).count(); // Yay\n+\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(usize::MIN..v.len()); // Yay\n+    let n = iter.count();\n+\n+    let mut v = vec![1, 2, 3];\n+    v.drain(0..v.len()); // Nay\n+\n+    let mut v = vec![1, 2, 3];\n+    v.drain(usize::MIN..v.len()); // Nay\n+}\n+\n+fn range_from() {\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(0..); // Yay\n+\n+    let mut v = vec![1, 2, 3];\n+    let mut iter = v.drain(0..); // Yay\n+    let next = iter.next();\n+\n+    let mut v = vec![1, 2, 3];\n+    let next = v.drain(usize::MIN..).next(); // Yay\n+\n+    let mut v = vec![1, 2, 3];\n+    v.drain(0..); // Nay\n+\n+    let mut v = vec![1, 2, 3];\n+    v.drain(usize::MIN..); // Nay\n+}\n+\n+fn range_full() {\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(..); // Yay\n+\n+    let mut v = vec![1, 2, 3];\n+    // Yay\n+    for x in v.drain(..) {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    let mut v = vec![1, 2, 3];\n+    v.drain(..); // Nay\n+}\n+\n+fn range_to() {\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(..v.len()); // Yay\n+\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(..v.len()); // Yay\n+    for x in iter {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    let mut v = vec![1, 2, 3];\n+    v.drain(..v.len()); // Nay\n+}\n+\n+fn partial_drains() {\n+    let mut v = vec![1, 2, 3];\n+    v.drain(1..); // Yay\n+    let mut v = vec![1, 2, 3];\n+    v.drain(1..).max(); // Yay\n+\n+    let mut v = vec![1, 2, 3];\n+    v.drain(..v.len() - 1); // Yay\n+    let mut v = vec![1, 2, 3];\n+    v.drain(..v.len() - 1).min(); // Yay\n+\n+    let mut v = vec![1, 2, 3];\n+    v.drain(1..v.len() - 1); // Yay\n+    let mut v = vec![1, 2, 3];\n+    let w: Vec<i8> = v.drain(1..v.len() - 1).collect(); // Yay\n+}\n+\n+fn main() {}"}, {"sha": "c88aa1a23cb65d60f565772aa800be9091552ea4", "filename": "tests/ui/clear_with_drain.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fclear_with_drain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fclear_with_drain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclear_with_drain.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,40 @@\n+error: `drain` used to clear a `Vec`\n+  --> $DIR/clear_with_drain.rs:17:7\n+   |\n+LL |     v.drain(0..v.len()); // Nay\n+   |       ^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+   |\n+   = note: `-D clippy::clear-with-drain` implied by `-D warnings`\n+\n+error: `drain` used to clear a `Vec`\n+  --> $DIR/clear_with_drain.rs:20:7\n+   |\n+LL |     v.drain(usize::MIN..v.len()); // Nay\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `Vec`\n+  --> $DIR/clear_with_drain.rs:35:7\n+   |\n+LL |     v.drain(0..); // Nay\n+   |       ^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `Vec`\n+  --> $DIR/clear_with_drain.rs:38:7\n+   |\n+LL |     v.drain(usize::MIN..); // Nay\n+   |       ^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `Vec`\n+  --> $DIR/clear_with_drain.rs:52:7\n+   |\n+LL |     v.drain(..); // Nay\n+   |       ^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `Vec`\n+  --> $DIR/clear_with_drain.rs:66:7\n+   |\n+LL |     v.drain(..v.len()); // Nay\n+   |       ^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "843e1df8bc6bbf77d73c70f67e0f8ca45948ad6e", "filename": "tests/ui/derive.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,7 +1,6 @@\n #![allow(dead_code)]\n #![warn(clippy::expl_impl_clone_on_copy)]\n \n-\n #[derive(Copy)]\n struct Qux;\n "}, {"sha": "d37f7fa73319679e97a2c61f67cfae6cd3eee762", "filename": "tests/ui/derive.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fderive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fderive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,5 +1,5 @@\n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:8:1\n+  --> $DIR/derive.rs:7:1\n    |\n LL | / impl Clone for Qux {\n LL | |     fn clone(&self) -> Self {\n@@ -9,7 +9,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:8:1\n+  --> $DIR/derive.rs:7:1\n    |\n LL | / impl Clone for Qux {\n LL | |     fn clone(&self) -> Self {\n@@ -20,7 +20,7 @@ LL | | }\n    = note: `-D clippy::expl-impl-clone-on-copy` implied by `-D warnings`\n \n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:32:1\n+  --> $DIR/derive.rs:31:1\n    |\n LL | / impl<'a> Clone for Lt<'a> {\n LL | |     fn clone(&self) -> Self {\n@@ -30,7 +30,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:32:1\n+  --> $DIR/derive.rs:31:1\n    |\n LL | / impl<'a> Clone for Lt<'a> {\n LL | |     fn clone(&self) -> Self {\n@@ -40,7 +40,7 @@ LL | | }\n    | |_^\n \n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:43:1\n+  --> $DIR/derive.rs:42:1\n    |\n LL | / impl Clone for BigArray {\n LL | |     fn clone(&self) -> Self {\n@@ -50,7 +50,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:43:1\n+  --> $DIR/derive.rs:42:1\n    |\n LL | / impl Clone for BigArray {\n LL | |     fn clone(&self) -> Self {\n@@ -60,7 +60,7 @@ LL | | }\n    | |_^\n \n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:54:1\n+  --> $DIR/derive.rs:53:1\n    |\n LL | / impl Clone for FnPtr {\n LL | |     fn clone(&self) -> Self {\n@@ -70,7 +70,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:54:1\n+  --> $DIR/derive.rs:53:1\n    |\n LL | / impl Clone for FnPtr {\n LL | |     fn clone(&self) -> Self {\n@@ -80,7 +80,7 @@ LL | | }\n    | |_^\n \n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:74:1\n+  --> $DIR/derive.rs:73:1\n    |\n LL | / impl<T: Clone> Clone for Generic2<T> {\n LL | |     fn clone(&self) -> Self {\n@@ -90,7 +90,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:74:1\n+  --> $DIR/derive.rs:73:1\n    |\n LL | / impl<T: Clone> Clone for Generic2<T> {\n LL | |     fn clone(&self) -> Self {"}, {"sha": "26a387b3cf04972f1fe654993930d9db0e6b4d66", "filename": "tests/ui/double_must_use.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fdouble_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fdouble_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdouble_must_use.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -21,6 +21,17 @@ pub fn must_use_with_note() -> Result<(), ()> {\n     unimplemented!();\n }\n \n+// vvvv Should not lint (#10486)\n+#[must_use]\n+async fn async_must_use() -> usize {\n+    unimplemented!();\n+}\n+\n+#[must_use]\n+async fn async_must_use_result() -> Result<(), ()> {\n+    Ok(())\n+}\n+\n fn main() {\n     must_use_result();\n     must_use_tuple();"}, {"sha": "49ab2ea3e12b42c2f287acb45fa6d55d05f10687", "filename": "tests/ui/double_must_use.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fdouble_must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fdouble_must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdouble_must_use.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -23,5 +23,13 @@ LL | pub fn must_use_array() -> [Result<(), ()>; 1] {\n    |\n    = help: either add some descriptive text or remove the attribute\n \n-error: aborting due to 3 previous errors\n+error: this function has an empty `#[must_use]` attribute, but returns a type already marked as `#[must_use]`\n+  --> $DIR/double_must_use.rs:31:1\n+   |\n+LL | async fn async_must_use_result() -> Result<(), ()> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: either add some descriptive text or remove the attribute\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "018f875d60bfa24ec5fd1a625b84d7cb9c457e66", "filename": "tests/ui/expect_tool_lint_rfc_2383.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fexpect_tool_lint_rfc_2383.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fexpect_tool_lint_rfc_2383.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexpect_tool_lint_rfc_2383.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -22,9 +22,9 @@ mod rustc_ok {\n \n         #[expect(illegal_floating_point_literal_pattern)]\n         match x {\n-            5.0 => {}\n-            6.0 => {}\n-            _ => {}\n+            5.0 => {},\n+            6.0 => {},\n+            _ => {},\n         }\n     }\n }\n@@ -38,9 +38,9 @@ mod rustc_warn {\n \n         #[expect(illegal_floating_point_literal_pattern)]\n         match x {\n-            5 => {}\n-            6 => {}\n-            _ => {}\n+            5 => {},\n+            6 => {},\n+            _ => {},\n         }\n     }\n }"}, {"sha": "19e718625582c594ccfa3407e63780062150ad36", "filename": "tests/ui/extra_unused_type_parameters.fixed", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fextra_unused_type_parameters.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fextra_unused_type_parameters.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters.fixed?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,105 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_lifetimes)]\n+#![warn(clippy::extra_unused_type_parameters)]\n+\n+fn unused_ty(x: u8) {\n+    unimplemented!()\n+}\n+\n+fn unused_multi(x: u8) {\n+    unimplemented!()\n+}\n+\n+fn unused_with_lt<'a>(x: &'a u8) {\n+    unimplemented!()\n+}\n+\n+fn used_ty<T>(x: T, y: u8) {}\n+\n+fn used_ref<'a, T>(x: &'a T) {}\n+\n+fn used_ret<T: Default>(x: u8) -> T {\n+    T::default()\n+}\n+\n+fn unused_bounded<U>(x: U) {\n+    unimplemented!();\n+}\n+\n+fn some_unused<B, C>(b: B, c: C) {\n+    unimplemented!();\n+}\n+\n+fn used_opaque<A>(iter: impl Iterator<Item = A>) -> usize {\n+    iter.count()\n+}\n+\n+fn used_ret_opaque<A>() -> impl Iterator<Item = A> {\n+    std::iter::empty()\n+}\n+\n+fn used_vec_box<T>(x: Vec<Box<T>>) {}\n+\n+fn used_body<T: Default + ToString>() -> String {\n+    T::default().to_string()\n+}\n+\n+fn used_closure<T: Default + ToString>() -> impl Fn() {\n+    || println!(\"{}\", T::default().to_string())\n+}\n+\n+struct S;\n+\n+impl S {\n+    fn unused_ty_impl(&self) {\n+        unimplemented!()\n+    }\n+}\n+\n+// Don't lint on trait methods\n+trait Foo {\n+    fn bar<T>(&self);\n+}\n+\n+impl Foo for S {\n+    fn bar<T>(&self) {}\n+}\n+\n+fn skip_index<A, Iter>(iter: Iter, index: usize) -> impl Iterator<Item = A>\n+where\n+    Iter: Iterator<Item = A>,\n+{\n+    iter.enumerate()\n+        .filter_map(move |(i, a)| if i == index { None } else { Some(a) })\n+}\n+\n+fn unused_opaque(dummy: impl Default) {\n+    unimplemented!()\n+}\n+\n+mod unexported_trait_bounds {\n+    mod private {\n+        pub trait Private {}\n+    }\n+\n+    fn priv_trait_bound<T: private::Private>() {\n+        unimplemented!();\n+    }\n+\n+    fn unused_with_priv_trait_bound<T: private::Private>() {\n+        unimplemented!();\n+    }\n+}\n+\n+mod issue10319 {\n+    fn assert_send<T: Send>() {}\n+\n+    fn assert_send_where<T>()\n+    where\n+        T: Send,\n+    {\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e53bb587e89acd0a438b7076afd5ec7b6bd09bb1", "filename": "tests/ui/extra_unused_type_parameters.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fextra_unused_type_parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fextra_unused_type_parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n #![allow(unused, clippy::needless_lifetimes)]\n #![warn(clippy::extra_unused_type_parameters)]\n \n@@ -21,14 +23,7 @@ fn used_ret<T: Default>(x: u8) -> T {\n     T::default()\n }\n \n-fn unused_bounded<T: Default, U>(x: U) {\n-    unimplemented!();\n-}\n-\n-fn unused_where_clause<T, U>(x: U)\n-where\n-    T: Default,\n-{\n+fn unused_bounded<T: Default, U, V: Default>(x: U) {\n     unimplemented!();\n }\n "}, {"sha": "c042a5a2290e51de8147b7fdece161df2181ccdd", "filename": "tests/ui/extra_unused_type_parameters.stderr", "status": "modified", "additions": 34, "deletions": 45, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fextra_unused_type_parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fextra_unused_type_parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,75 +1,64 @@\n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:4:13\n+error: type parameter `T` goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:6:13\n    |\n LL | fn unused_ty<T>(x: u8) {\n-   |             ^^^\n+   |             ^^^ help: consider removing the parameter\n    |\n-   = help: consider removing the parameter\n    = note: `-D clippy::extra-unused-type-parameters` implied by `-D warnings`\n \n-error: type parameters go unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:8:16\n+error: type parameters go unused in function definition: T, U\n+  --> $DIR/extra_unused_type_parameters.rs:10:16\n    |\n LL | fn unused_multi<T, U>(x: u8) {\n-   |                ^^^^^^\n-   |\n-   = help: consider removing the parameters\n+   |                ^^^^^^ help: consider removing the parameters\n \n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:12:23\n+error: type parameter `T` goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:14:21\n    |\n LL | fn unused_with_lt<'a, T>(x: &'a u8) {\n-   |                       ^\n-   |\n-   = help: consider removing the parameter\n+   |                     ^^^ help: consider removing the parameter\n \n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:24:19\n+error: type parameters go unused in function definition: T, V\n+  --> $DIR/extra_unused_type_parameters.rs:26:19\n    |\n-LL | fn unused_bounded<T: Default, U>(x: U) {\n-   |                   ^^^^^^^^^^^\n+LL | fn unused_bounded<T: Default, U, V: Default>(x: U) {\n+   |                   ^^^^^^^^^^^^ ^^^^^^^^^^^^\n    |\n-   = help: consider removing the parameter\n-\n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:28:24\n+help: consider removing the parameters\n    |\n-LL | fn unused_where_clause<T, U>(x: U)\n-   |                        ^^\n+LL - fn unused_bounded<T: Default, U, V: Default>(x: U) {\n+LL + fn unused_bounded<U>(x: U) {\n    |\n-   = help: consider removing the parameter\n \n-error: type parameters go unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:35:16\n+error: type parameters go unused in function definition: A, D, E\n+  --> $DIR/extra_unused_type_parameters.rs:30:16\n    |\n LL | fn some_unused<A, B, C, D: Iterator<Item = (B, C)>, E>(b: B, c: C) {\n-   |                ^^       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^\n+   |                ^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider removing the parameters\n+   |\n+LL - fn some_unused<A, B, C, D: Iterator<Item = (B, C)>, E>(b: B, c: C) {\n+LL + fn some_unused<B, C>(b: B, c: C) {\n    |\n-   = help: consider removing the parameters\n \n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:60:22\n+error: type parameter `T` goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:55:22\n    |\n LL |     fn unused_ty_impl<T>(&self) {\n-   |                      ^^^\n-   |\n-   = help: consider removing the parameter\n+   |                      ^^^ help: consider removing the parameter\n \n-error: type parameters go unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:82:17\n+error: type parameters go unused in function definition: A, B\n+  --> $DIR/extra_unused_type_parameters.rs:77:17\n    |\n LL | fn unused_opaque<A, B>(dummy: impl Default) {\n-   |                 ^^^^^^\n-   |\n-   = help: consider removing the parameters\n+   |                 ^^^^^^ help: consider removing the parameters\n \n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:95:58\n+error: type parameter `U` goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:90:56\n    |\n LL |     fn unused_with_priv_trait_bound<T: private::Private, U>() {\n-   |                                                          ^\n-   |\n-   = help: consider removing the parameter\n+   |                                                        ^^^ help: consider removing the parameter\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "10b39aa8f2c5b3c101a728f9648a0b6fdf665c36", "filename": "tests/ui/extra_unused_type_parameters_unfixable.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fextra_unused_type_parameters_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fextra_unused_type_parameters_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters_unfixable.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,24 @@\n+#![warn(clippy::extra_unused_type_parameters)]\n+\n+fn unused_where_clause<T, U>(x: U)\n+where\n+    T: Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn unused_multi_where_clause<T, U, V: Default>(x: U)\n+where\n+    T: Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn unused_all_where_clause<T, U: Default, V: Default>()\n+where\n+    T: Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn main() {}"}, {"sha": "a9580cc894f35bf7324470f5b24f0558507addcb", "filename": "tests/ui/extra_unused_type_parameters_unfixable.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fextra_unused_type_parameters_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fextra_unused_type_parameters_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters_unfixable.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,27 @@\n+error: type parameter `T` goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters_unfixable.rs:3:24\n+   |\n+LL | fn unused_where_clause<T, U>(x: U)\n+   |                        ^\n+   |\n+   = help: consider removing the parameter\n+   = note: `-D clippy::extra-unused-type-parameters` implied by `-D warnings`\n+\n+error: type parameters go unused in function definition: T, V\n+  --> $DIR/extra_unused_type_parameters_unfixable.rs:10:30\n+   |\n+LL | fn unused_multi_where_clause<T, U, V: Default>(x: U)\n+   |                              ^     ^^^^^^^^^^\n+   |\n+   = help: consider removing the parameters\n+\n+error: type parameters go unused in function definition: T, U, V\n+  --> $DIR/extra_unused_type_parameters_unfixable.rs:17:28\n+   |\n+LL | fn unused_all_where_clause<T, U: Default, V: Default>()\n+   |                            ^  ^^^^^^^^^^  ^^^^^^^^^^\n+   |\n+   = help: consider removing the parameters\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "423bfaf97965ea54b7951eb201f5825bd0afe070", "filename": "tests/ui/format_args_unfixable.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fformat_args_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fformat_args_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_args_unfixable.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::format_in_format_args, clippy::to_string_in_format_args)]\n+#![allow(unused)]\n #![allow(clippy::assertions_on_constants, clippy::eq_op, clippy::uninlined_format_args)]\n \n use std::io::{stdout, Error, ErrorKind, Write};\n@@ -57,3 +58,46 @@ fn main() {\n     my_macro!();\n     println!(\"error: {}\", my_other_macro!());\n }\n+\n+macro_rules! _internal {\n+    ($($args:tt)*) => {\n+        println!(\"{}\", format_args!($($args)*))\n+    };\n+}\n+\n+macro_rules! my_println2 {\n+   ($target:expr, $($args:tt)+) => {{\n+       if $target {\n+           _internal!($($args)+)\n+       }\n+    }};\n+}\n+\n+macro_rules! my_println2_args {\n+    ($target:expr, $($args:tt)+) => {{\n+       if $target {\n+           _internal!(\"foo: {}\", format_args!($($args)+))\n+       }\n+    }};\n+}\n+\n+fn test2() {\n+    let error = Error::new(ErrorKind::Other, \"bad thing\");\n+\n+    // None of these should be linted without the config change\n+    my_println2!(true, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    my_println2!(\n+        true,\n+        \"{}: {}\",\n+        error,\n+        format!(\"something failed at {}\", Location::caller())\n+    );\n+\n+    my_println2_args!(true, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    my_println2_args!(\n+        true,\n+        \"{}: {}\",\n+        error,\n+        format!(\"something failed at {}\", Location::caller())\n+    );\n+}"}, {"sha": "c1be48c3b726944b4693057885ef793ac1e7e6c9", "filename": "tests/ui/format_args_unfixable.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fformat_args_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fformat_args_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_args_unfixable.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,5 +1,5 @@\n error: `format!` in `println!` args\n-  --> $DIR/format_args_unfixable.rs:25:5\n+  --> $DIR/format_args_unfixable.rs:26:5\n    |\n LL |     println!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -9,7 +9,7 @@ LL |     println!(\"error: {}\", format!(\"something failed at {}\", Location::calle\n    = note: `-D clippy::format-in-format-args` implied by `-D warnings`\n \n error: `format!` in `println!` args\n-  --> $DIR/format_args_unfixable.rs:26:5\n+  --> $DIR/format_args_unfixable.rs:27:5\n    |\n LL |     println!(\"{}: {}\", error, format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -18,7 +18,7 @@ LL |     println!(\"{}: {}\", error, format!(\"something failed at {}\", Location::c\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `println!` args\n-  --> $DIR/format_args_unfixable.rs:27:5\n+  --> $DIR/format_args_unfixable.rs:28:5\n    |\n LL |     println!(\"{:?}: {}\", error, format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -27,7 +27,7 @@ LL |     println!(\"{:?}: {}\", error, format!(\"something failed at {}\", Location:\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `println!` args\n-  --> $DIR/format_args_unfixable.rs:28:5\n+  --> $DIR/format_args_unfixable.rs:29:5\n    |\n LL |     println!(\"{{}}: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -36,7 +36,7 @@ LL |     println!(\"{{}}: {}\", format!(\"something failed at {}\", Location::caller\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `println!` args\n-  --> $DIR/format_args_unfixable.rs:29:5\n+  --> $DIR/format_args_unfixable.rs:30:5\n    |\n LL |     println!(r#\"error: \"{}\"\"#, format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -45,7 +45,7 @@ LL |     println!(r#\"error: \"{}\"\"#, format!(\"something failed at {}\", Location::\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `println!` args\n-  --> $DIR/format_args_unfixable.rs:30:5\n+  --> $DIR/format_args_unfixable.rs:31:5\n    |\n LL |     println!(\"error: {}\", format!(r#\"something failed at \"{}\"\"#, Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -54,7 +54,7 @@ LL |     println!(\"error: {}\", format!(r#\"something failed at \"{}\"\"#, Location::\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `println!` args\n-  --> $DIR/format_args_unfixable.rs:31:5\n+  --> $DIR/format_args_unfixable.rs:32:5\n    |\n LL |     println!(\"error: {}\", format!(\"something failed at {} {0}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -63,7 +63,7 @@ LL |     println!(\"error: {}\", format!(\"something failed at {} {0}\", Location::c\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `format!` args\n-  --> $DIR/format_args_unfixable.rs:32:13\n+  --> $DIR/format_args_unfixable.rs:33:13\n    |\n LL |     let _ = format!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -72,7 +72,7 @@ LL |     let _ = format!(\"error: {}\", format!(\"something failed at {}\", Location\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `write!` args\n-  --> $DIR/format_args_unfixable.rs:33:13\n+  --> $DIR/format_args_unfixable.rs:34:13\n    |\n LL |       let _ = write!(\n    |  _____________^\n@@ -86,7 +86,7 @@ LL | |     );\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `writeln!` args\n-  --> $DIR/format_args_unfixable.rs:38:13\n+  --> $DIR/format_args_unfixable.rs:39:13\n    |\n LL |       let _ = writeln!(\n    |  _____________^\n@@ -100,7 +100,7 @@ LL | |     );\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `print!` args\n-  --> $DIR/format_args_unfixable.rs:43:5\n+  --> $DIR/format_args_unfixable.rs:44:5\n    |\n LL |     print!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -109,7 +109,7 @@ LL |     print!(\"error: {}\", format!(\"something failed at {}\", Location::caller(\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `eprint!` args\n-  --> $DIR/format_args_unfixable.rs:44:5\n+  --> $DIR/format_args_unfixable.rs:45:5\n    |\n LL |     eprint!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -118,7 +118,7 @@ LL |     eprint!(\"error: {}\", format!(\"something failed at {}\", Location::caller\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `eprintln!` args\n-  --> $DIR/format_args_unfixable.rs:45:5\n+  --> $DIR/format_args_unfixable.rs:46:5\n    |\n LL |     eprintln!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -127,7 +127,7 @@ LL |     eprintln!(\"error: {}\", format!(\"something failed at {}\", Location::call\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `format_args!` args\n-  --> $DIR/format_args_unfixable.rs:46:13\n+  --> $DIR/format_args_unfixable.rs:47:13\n    |\n LL |     let _ = format_args!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -136,7 +136,7 @@ LL |     let _ = format_args!(\"error: {}\", format!(\"something failed at {}\", Loc\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `assert!` args\n-  --> $DIR/format_args_unfixable.rs:47:5\n+  --> $DIR/format_args_unfixable.rs:48:5\n    |\n LL |     assert!(true, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -145,7 +145,7 @@ LL |     assert!(true, \"error: {}\", format!(\"something failed at {}\", Location::\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `assert_eq!` args\n-  --> $DIR/format_args_unfixable.rs:48:5\n+  --> $DIR/format_args_unfixable.rs:49:5\n    |\n LL |     assert_eq!(0, 0, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -154,7 +154,7 @@ LL |     assert_eq!(0, 0, \"error: {}\", format!(\"something failed at {}\", Locatio\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `assert_ne!` args\n-  --> $DIR/format_args_unfixable.rs:49:5\n+  --> $DIR/format_args_unfixable.rs:50:5\n    |\n LL |     assert_ne!(0, 0, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -163,7 +163,7 @@ LL |     assert_ne!(0, 0, \"error: {}\", format!(\"something failed at {}\", Locatio\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `panic!` args\n-  --> $DIR/format_args_unfixable.rs:50:5\n+  --> $DIR/format_args_unfixable.rs:51:5\n    |\n LL |     panic!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "f12cb8f22e2703286c6218ea5d2891f1bf1de586", "filename": "tests/ui/items_after_statement.rs", "status": "renamed", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fitems_after_statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fitems_after_statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fitems_after_statement.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -51,3 +51,20 @@ fn semicolon() {\n \n     let _ = S::new(3);\n }\n+\n+fn item_from_macro() {\n+    macro_rules! static_assert_size {\n+        ($ty:ty, $size:expr) => {\n+            const _: [(); $size] = [(); ::std::mem::size_of::<$ty>()];\n+        };\n+    }\n+\n+    let _ = 1;\n+    static_assert_size!(u32, 4);\n+}\n+\n+fn allow_attribute() {\n+    let _ = 1;\n+    #[allow(clippy::items_after_statements)]\n+    const _: usize = 1;\n+}", "previous_filename": "tests/ui/item_after_statement.rs"}, {"sha": "f69635a977bd7ca89a4cabb0f5a5c4dd2c22ada8", "filename": "tests/ui/items_after_statement.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fitems_after_statement.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fitems_after_statement.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fitems_after_statement.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,5 +1,5 @@\n error: adding items after statements is confusing, since items exist from the start of the scope\n-  --> $DIR/item_after_statement.rs:13:5\n+  --> $DIR/items_after_statement.rs:13:5\n    |\n LL | /     fn foo() {\n LL | |         println!(\"foo\");\n@@ -9,15 +9,15 @@ LL | |     }\n    = note: `-D clippy::items-after-statements` implied by `-D warnings`\n \n error: adding items after statements is confusing, since items exist from the start of the scope\n-  --> $DIR/item_after_statement.rs:20:5\n+  --> $DIR/items_after_statement.rs:20:5\n    |\n LL | /     fn foo() {\n LL | |         println!(\"foo\");\n LL | |     }\n    | |_____^\n \n error: adding items after statements is confusing, since items exist from the start of the scope\n-  --> $DIR/item_after_statement.rs:33:13\n+  --> $DIR/items_after_statement.rs:33:13\n    |\n LL | /             fn say_something() {\n LL | |                 println!(\"something\");", "previous_filename": "tests/ui/item_after_statement.stderr"}, {"sha": "4a8ba995da556f0546b526b987f6f4a44a80d4f2", "filename": "tests/ui/large_futures.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Flarge_futures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Flarge_futures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_futures.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,61 @@\n+#![feature(generators)]\n+#![warn(clippy::large_futures)]\n+#![allow(clippy::future_not_send)]\n+#![allow(clippy::manual_async_fn)]\n+\n+async fn big_fut(_arg: [u8; 1024 * 16]) {}\n+\n+async fn wait() {\n+    let f = async {\n+        big_fut([0u8; 1024 * 16]).await;\n+    };\n+    f.await\n+}\n+async fn calls_fut(fut: impl std::future::Future<Output = ()>) {\n+    loop {\n+        wait().await;\n+        if true {\n+            return fut.await;\n+        } else {\n+            wait().await;\n+        }\n+    }\n+}\n+\n+pub async fn test() {\n+    let fut = big_fut([0u8; 1024 * 16]);\n+    foo().await;\n+    calls_fut(fut).await;\n+}\n+\n+pub fn foo() -> impl std::future::Future<Output = ()> {\n+    async {\n+        let x = [0i32; 1024 * 16];\n+        async {}.await;\n+        dbg!(x);\n+    }\n+}\n+\n+pub async fn lines() {\n+    async {\n+        let x = [0i32; 1024 * 16];\n+        async {}.await;\n+        println!(\"{:?}\", x);\n+    }\n+    .await;\n+}\n+\n+pub async fn macro_expn() {\n+    macro_rules! macro_ {\n+        () => {\n+            async {\n+                let x = [0i32; 1024 * 16];\n+                async {}.await;\n+                println!(\"macro: {:?}\", x);\n+            }\n+        };\n+    }\n+    macro_!().await\n+}\n+\n+fn main() {}"}, {"sha": "67e0fceff6ef313f8d527564385a9ed8a3a6a3f2", "filename": "tests/ui/large_futures.stderr", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Flarge_futures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Flarge_futures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_futures.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,82 @@\n+error: large future with a size of 16385 bytes\n+  --> $DIR/large_futures.rs:10:9\n+   |\n+LL |         big_fut([0u8; 1024 * 16]).await;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider `Box::pin` on it: `Box::pin(big_fut([0u8; 1024 * 16]))`\n+   |\n+   = note: `-D clippy::large-futures` implied by `-D warnings`\n+\n+error: large future with a size of 16386 bytes\n+  --> $DIR/large_futures.rs:12:5\n+   |\n+LL |     f.await\n+   |     ^ help: consider `Box::pin` on it: `Box::pin(f)`\n+\n+error: large future with a size of 16387 bytes\n+  --> $DIR/large_futures.rs:16:9\n+   |\n+LL |         wait().await;\n+   |         ^^^^^^ help: consider `Box::pin` on it: `Box::pin(wait())`\n+\n+error: large future with a size of 16387 bytes\n+  --> $DIR/large_futures.rs:20:13\n+   |\n+LL |             wait().await;\n+   |             ^^^^^^ help: consider `Box::pin` on it: `Box::pin(wait())`\n+\n+error: large future with a size of 65540 bytes\n+  --> $DIR/large_futures.rs:27:5\n+   |\n+LL |     foo().await;\n+   |     ^^^^^ help: consider `Box::pin` on it: `Box::pin(foo())`\n+\n+error: large future with a size of 49159 bytes\n+  --> $DIR/large_futures.rs:28:5\n+   |\n+LL |     calls_fut(fut).await;\n+   |     ^^^^^^^^^^^^^^ help: consider `Box::pin` on it: `Box::pin(calls_fut(fut))`\n+\n+error: large future with a size of 65540 bytes\n+  --> $DIR/large_futures.rs:40:5\n+   |\n+LL | /     async {\n+LL | |         let x = [0i32; 1024 * 16];\n+LL | |         async {}.await;\n+LL | |         println!(\"{:?}\", x);\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider `Box::pin` on it\n+   |\n+LL ~     Box::pin(async {\n+LL +         let x = [0i32; 1024 * 16];\n+LL +         async {}.await;\n+LL +         println!(\"{:?}\", x);\n+LL +     })\n+   |\n+\n+error: large future with a size of 65540 bytes\n+  --> $DIR/large_futures.rs:51:13\n+   |\n+LL | /             async {\n+LL | |                 let x = [0i32; 1024 * 16];\n+LL | |                 async {}.await;\n+LL | |                 println!(\"macro: {:?}\", x);\n+LL | |             }\n+   | |_____________^\n+...\n+LL |       macro_!().await\n+   |       --------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `macro_` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider `Box::pin` on it\n+   |\n+LL ~             Box::pin(async {\n+LL +                 let x = [0i32; 1024 * 16];\n+LL +                 async {}.await;\n+LL +                 println!(\"macro: {:?}\", x);\n+LL +             })\n+   |\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "f4033cd8ed85069c3b5b59cf04ca728ebeb56aed", "filename": "tests/ui/lines_filter_map_ok.fixed", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Flines_filter_map_ok.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Flines_filter_map_ok.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flines_filter_map_ok.fixed?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,29 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::map_identity)]\n+#![warn(clippy::lines_filter_map_ok)]\n+\n+use std::io::{self, BufRead, BufReader};\n+\n+fn main() -> io::Result<()> {\n+    let f = std::fs::File::open(\"/\")?;\n+    // Lint\n+    BufReader::new(f).lines().map_while(Result::ok).for_each(|_| ());\n+    // Lint\n+    let f = std::fs::File::open(\"/\")?;\n+    BufReader::new(f).lines().map_while(Result::ok).for_each(|_| ());\n+    let s = \"foo\\nbar\\nbaz\\n\";\n+    // Lint\n+    io::stdin().lines().map_while(Result::ok).for_each(|_| ());\n+    // Lint\n+    io::stdin().lines().map_while(Result::ok).for_each(|_| ());\n+    // Do not lint (not a `Lines` iterator)\n+    io::stdin()\n+        .lines()\n+        .map(std::convert::identity)\n+        .filter_map(|x| x.ok())\n+        .for_each(|_| ());\n+    // Do not lint (not a `Result::ok()` extractor)\n+    io::stdin().lines().filter_map(|x| x.err()).for_each(|_| ());\n+    Ok(())\n+}"}, {"sha": "7e11816b2acd3b7e3f8eaf0f9bbf01db3d85696c", "filename": "tests/ui/lines_filter_map_ok.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Flines_filter_map_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Flines_filter_map_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flines_filter_map_ok.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,29 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::map_identity)]\n+#![warn(clippy::lines_filter_map_ok)]\n+\n+use std::io::{self, BufRead, BufReader};\n+\n+fn main() -> io::Result<()> {\n+    let f = std::fs::File::open(\"/\")?;\n+    // Lint\n+    BufReader::new(f).lines().filter_map(Result::ok).for_each(|_| ());\n+    // Lint\n+    let f = std::fs::File::open(\"/\")?;\n+    BufReader::new(f).lines().flat_map(Result::ok).for_each(|_| ());\n+    let s = \"foo\\nbar\\nbaz\\n\";\n+    // Lint\n+    io::stdin().lines().filter_map(Result::ok).for_each(|_| ());\n+    // Lint\n+    io::stdin().lines().filter_map(|x| x.ok()).for_each(|_| ());\n+    // Do not lint (not a `Lines` iterator)\n+    io::stdin()\n+        .lines()\n+        .map(std::convert::identity)\n+        .filter_map(|x| x.ok())\n+        .for_each(|_| ());\n+    // Do not lint (not a `Result::ok()` extractor)\n+    io::stdin().lines().filter_map(|x| x.err()).for_each(|_| ());\n+    Ok(())\n+}"}, {"sha": "cddd403d589c383639c5333877022b100d5cf9f3", "filename": "tests/ui/lines_filter_map_ok.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Flines_filter_map_ok.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Flines_filter_map_ok.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flines_filter_map_ok.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,51 @@\n+error: `filter_map()` will run forever if the iterator repeatedly produces an `Err`\n+  --> $DIR/lines_filter_map_ok.rs:11:31\n+   |\n+LL |     BufReader::new(f).lines().filter_map(Result::ok).for_each(|_| ());\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `map_while(Result::ok)`\n+   |\n+note: this expression returning a `std::io::Lines` may produce an infinite number of `Err` in case of a read error\n+  --> $DIR/lines_filter_map_ok.rs:11:5\n+   |\n+LL |     BufReader::new(f).lines().filter_map(Result::ok).for_each(|_| ());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `-D clippy::lines-filter-map-ok` implied by `-D warnings`\n+\n+error: `flat_map()` will run forever if the iterator repeatedly produces an `Err`\n+  --> $DIR/lines_filter_map_ok.rs:14:31\n+   |\n+LL |     BufReader::new(f).lines().flat_map(Result::ok).for_each(|_| ());\n+   |                               ^^^^^^^^^^^^^^^^^^^^ help: replace with: `map_while(Result::ok)`\n+   |\n+note: this expression returning a `std::io::Lines` may produce an infinite number of `Err` in case of a read error\n+  --> $DIR/lines_filter_map_ok.rs:14:5\n+   |\n+LL |     BufReader::new(f).lines().flat_map(Result::ok).for_each(|_| ());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `filter_map()` will run forever if the iterator repeatedly produces an `Err`\n+  --> $DIR/lines_filter_map_ok.rs:17:25\n+   |\n+LL |     io::stdin().lines().filter_map(Result::ok).for_each(|_| ());\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `map_while(Result::ok)`\n+   |\n+note: this expression returning a `std::io::Lines` may produce an infinite number of `Err` in case of a read error\n+  --> $DIR/lines_filter_map_ok.rs:17:5\n+   |\n+LL |     io::stdin().lines().filter_map(Result::ok).for_each(|_| ());\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: `filter_map()` will run forever if the iterator repeatedly produces an `Err`\n+  --> $DIR/lines_filter_map_ok.rs:19:25\n+   |\n+LL |     io::stdin().lines().filter_map(|x| x.ok()).for_each(|_| ());\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `map_while(Result::ok)`\n+   |\n+note: this expression returning a `std::io::Lines` may produce an infinite number of `Err` in case of a read error\n+  --> $DIR/lines_filter_map_ok.rs:19:5\n+   |\n+LL |     io::stdin().lines().filter_map(|x| x.ok()).for_each(|_| ());\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "80cc7c60f56e586d67cf8be08aaf4733edbc2a17", "filename": "tests/ui/nonminimal_bool.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fnonminimal_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fnonminimal_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnonminimal_bool.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -92,3 +92,21 @@ fn issue_10523_2() {\n     }\n     if a!() {}\n }\n+\n+fn issue_10435() {\n+    let x = vec![0];\n+    let y = vec![1];\n+    let z = vec![2];\n+\n+    // vvv Should not lint\n+    #[allow(clippy::nonminimal_bool)]\n+    if !x.is_empty() && !(y.is_empty() || z.is_empty()) {\n+        println!(\"{}\", line!());\n+    }\n+\n+    // vvv Should not lint (#10435 talks about a bug where it lints)\n+    #[allow(clippy::nonminimal_bool)]\n+    if !(x == [0]) {\n+        println!(\"{}\", line!());\n+    }\n+}"}, {"sha": "538513e9156f8851fe0f76b6cf9999937994c395", "filename": "tests/ui/print_literal.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fprint_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fprint_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_literal.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -38,4 +38,8 @@ fn main() {\n     // named args shouldn't change anything either\n     println!(\"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n     println!(\"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n+\n+    // The string literal from `file!()` has a callsite span that isn't marked as coming from an\n+    // expansion\n+    println!(\"file: {}\", file!());\n }"}, {"sha": "ad96993c4a78c470968025745e6ea90b66aa06a5", "filename": "tests/ui/redundant_async_block.fixed", "status": "modified", "additions": 115, "deletions": 33, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fredundant_async_block.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fredundant_async_block.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_async_block.fixed?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused)]\n+#![allow(unused, clippy::manual_async_fn)]\n #![warn(clippy::redundant_async_block)]\n \n use std::future::Future;\n@@ -16,40 +16,16 @@ async fn func2() -> String {\n     x.await\n }\n \n-macro_rules! await_in_macro {\n-    ($e:expr) => {\n-        std::convert::identity($e).await\n-    };\n-}\n-\n-async fn func3(n: usize) -> usize {\n-    // Do not lint (suggestion would be `std::convert::identity(func1(n))`\n-    // which copies code from inside the macro)\n-    async move { await_in_macro!(func1(n)) }.await\n-}\n-\n-// This macro should never be linted as `$e` might contain `.await`\n-macro_rules! async_await_parameter_in_macro {\n-    ($e:expr) => {\n-        async { $e.await }\n-    };\n-}\n-\n-// MISSED OPPORTUNITY: this macro could be linted as the `async` block does not\n-// contain code coming from the parameters\n-macro_rules! async_await_in_macro {\n-    ($f:expr) => {\n-        ($f)(async { func2().await })\n-    };\n-}\n-\n fn main() {\n     let fut1 = async { 17 };\n+    // Lint\n     let fut2 = fut1;\n \n     let fut1 = async { 25 };\n+    // Lint\n     let fut2 = fut1;\n \n+    // Lint\n     let fut = async { 42 };\n \n     // Do not lint: not a single expression\n@@ -60,15 +36,12 @@ fn main() {\n \n     // Do not lint: expression contains `.await`\n     let fut = async { func1(func2().await.len()).await };\n-\n-    let fut = async_await_parameter_in_macro!(func2());\n-    let fut = async_await_in_macro!(std::convert::identity);\n }\n \n #[allow(clippy::let_and_return)]\n fn capture_local() -> impl Future<Output = i32> {\n-    // Lint\n     let fut = async { 17 };\n+    // Lint\n     fut\n }\n \n@@ -80,11 +53,39 @@ fn capture_local_closure(s: &str) -> impl Future<Output = &str> {\n \n #[allow(clippy::let_and_return)]\n fn capture_arg(s: &str) -> impl Future<Output = &str> {\n-    // Lint\n     let fut = async move { s };\n+    // Lint\n     fut\n }\n \n+fn capture_future_arg<T>(f: impl Future<Output = T>) -> impl Future<Output = T> {\n+    // Lint\n+    f\n+}\n+\n+fn capture_func_result<FN, F, T>(f: FN) -> impl Future<Output = T>\n+where\n+    F: Future<Output = T>,\n+    FN: FnOnce() -> F,\n+{\n+    // Do not lint, as f() would be evaluated prematurely\n+    async { f().await }\n+}\n+\n+fn double_future(f: impl Future<Output = impl Future<Output = u32>>) -> impl Future<Output = u32> {\n+    // Do not lint, we will get a `.await` outside a `.async`\n+    async { f.await.await }\n+}\n+\n+fn await_in_async<F, R>(f: F) -> impl Future<Output = u32>\n+where\n+    F: FnOnce() -> R,\n+    R: Future<Output = u32>,\n+{\n+    // Lint\n+    async { f().await + 1 }\n+}\n+\n #[derive(Debug, Clone)]\n struct F {}\n \n@@ -109,3 +110,84 @@ fn capture() {\n     // Do not lint: `val` would not live long enough\n     spawn(async { work(&{ val }).await });\n }\n+\n+fn await_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e:expr) => {\n+            $e.await\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    // or return different things depending on its argument\n+    async { mac!(async { 42 }) }\n+}\n+\n+fn async_expr_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            async { 42 }\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    async { mac!().await }\n+}\n+\n+fn async_expr_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            async { 42 }\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    async { ({ mac!() }).await }\n+}\n+\n+fn all_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            // Lint\n+            async { 42 }\n+        };\n+    }\n+    mac!()\n+}\n+\n+fn parts_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Do not lint: `$e` might not always be side-effect free\n+            async { $e.await }\n+        };\n+    }\n+    mac!(async { 42 })\n+}\n+\n+fn safe_parts_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Lint\n+            async { $e }\n+        };\n+    }\n+    mac!(42)\n+}\n+\n+fn parts_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Do not lint: `$e` might not always be side-effect free\n+            async { ($e,).0.await }\n+        };\n+    }\n+    let f = std::future::ready(42);\n+    mac!(f)\n+}\n+\n+fn await_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e:expr) => {{ $e }.await};\n+    }\n+    // Do not lint: the macro may change in the future\n+    // or return different things depending on its argument\n+    async { mac!(async { 42 }) }\n+}"}, {"sha": "7ae235583694dd2e66371440b9fc1a5920e0b7cd", "filename": "tests/ui/redundant_async_block.rs", "status": "modified", "additions": 115, "deletions": 33, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fredundant_async_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fredundant_async_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_async_block.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused)]\n+#![allow(unused, clippy::manual_async_fn)]\n #![warn(clippy::redundant_async_block)]\n \n use std::future::Future;\n@@ -16,40 +16,16 @@ async fn func2() -> String {\n     x.await\n }\n \n-macro_rules! await_in_macro {\n-    ($e:expr) => {\n-        std::convert::identity($e).await\n-    };\n-}\n-\n-async fn func3(n: usize) -> usize {\n-    // Do not lint (suggestion would be `std::convert::identity(func1(n))`\n-    // which copies code from inside the macro)\n-    async move { await_in_macro!(func1(n)) }.await\n-}\n-\n-// This macro should never be linted as `$e` might contain `.await`\n-macro_rules! async_await_parameter_in_macro {\n-    ($e:expr) => {\n-        async { $e.await }\n-    };\n-}\n-\n-// MISSED OPPORTUNITY: this macro could be linted as the `async` block does not\n-// contain code coming from the parameters\n-macro_rules! async_await_in_macro {\n-    ($f:expr) => {\n-        ($f)(async { func2().await })\n-    };\n-}\n-\n fn main() {\n     let fut1 = async { 17 };\n+    // Lint\n     let fut2 = async { fut1.await };\n \n     let fut1 = async { 25 };\n+    // Lint\n     let fut2 = async move { fut1.await };\n \n+    // Lint\n     let fut = async { async { 42 }.await };\n \n     // Do not lint: not a single expression\n@@ -60,15 +36,12 @@ fn main() {\n \n     // Do not lint: expression contains `.await`\n     let fut = async { func1(func2().await.len()).await };\n-\n-    let fut = async_await_parameter_in_macro!(func2());\n-    let fut = async_await_in_macro!(std::convert::identity);\n }\n \n #[allow(clippy::let_and_return)]\n fn capture_local() -> impl Future<Output = i32> {\n-    // Lint\n     let fut = async { 17 };\n+    // Lint\n     async move { fut.await }\n }\n \n@@ -80,11 +53,39 @@ fn capture_local_closure(s: &str) -> impl Future<Output = &str> {\n \n #[allow(clippy::let_and_return)]\n fn capture_arg(s: &str) -> impl Future<Output = &str> {\n-    // Lint\n     let fut = async move { s };\n+    // Lint\n     async move { fut.await }\n }\n \n+fn capture_future_arg<T>(f: impl Future<Output = T>) -> impl Future<Output = T> {\n+    // Lint\n+    async { f.await }\n+}\n+\n+fn capture_func_result<FN, F, T>(f: FN) -> impl Future<Output = T>\n+where\n+    F: Future<Output = T>,\n+    FN: FnOnce() -> F,\n+{\n+    // Do not lint, as f() would be evaluated prematurely\n+    async { f().await }\n+}\n+\n+fn double_future(f: impl Future<Output = impl Future<Output = u32>>) -> impl Future<Output = u32> {\n+    // Do not lint, we will get a `.await` outside a `.async`\n+    async { f.await.await }\n+}\n+\n+fn await_in_async<F, R>(f: F) -> impl Future<Output = u32>\n+where\n+    F: FnOnce() -> R,\n+    R: Future<Output = u32>,\n+{\n+    // Lint\n+    async { async { f().await + 1 }.await }\n+}\n+\n #[derive(Debug, Clone)]\n struct F {}\n \n@@ -109,3 +110,84 @@ fn capture() {\n     // Do not lint: `val` would not live long enough\n     spawn(async { work(&{ val }).await });\n }\n+\n+fn await_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e:expr) => {\n+            $e.await\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    // or return different things depending on its argument\n+    async { mac!(async { 42 }) }\n+}\n+\n+fn async_expr_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            async { 42 }\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    async { mac!().await }\n+}\n+\n+fn async_expr_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            async { 42 }\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    async { ({ mac!() }).await }\n+}\n+\n+fn all_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            // Lint\n+            async { async { 42 }.await }\n+        };\n+    }\n+    mac!()\n+}\n+\n+fn parts_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Do not lint: `$e` might not always be side-effect free\n+            async { $e.await }\n+        };\n+    }\n+    mac!(async { 42 })\n+}\n+\n+fn safe_parts_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Lint\n+            async { async { $e }.await }\n+        };\n+    }\n+    mac!(42)\n+}\n+\n+fn parts_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Do not lint: `$e` might not always be side-effect free\n+            async { ($e,).0.await }\n+        };\n+    }\n+    let f = std::future::ready(42);\n+    mac!(f)\n+}\n+\n+fn await_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e:expr) => {{ $e }.await};\n+    }\n+    // Do not lint: the macro may change in the future\n+    // or return different things depending on its argument\n+    async { mac!(async { 42 }) }\n+}"}, {"sha": "f3dcb09b4440ade2e5211149a8e09134d040af9e", "filename": "tests/ui/redundant_async_block.stderr", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fredundant_async_block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Fredundant_async_block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_async_block.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -7,34 +7,68 @@ LL |     let x = async { f.await };\n    = note: `-D clippy::redundant-async-block` implied by `-D warnings`\n \n error: this async expression only awaits a single future\n-  --> $DIR/redundant_async_block.rs:48:16\n+  --> $DIR/redundant_async_block.rs:22:16\n    |\n LL |     let fut2 = async { fut1.await };\n    |                ^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `fut1`\n \n error: this async expression only awaits a single future\n-  --> $DIR/redundant_async_block.rs:51:16\n+  --> $DIR/redundant_async_block.rs:26:16\n    |\n LL |     let fut2 = async move { fut1.await };\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `fut1`\n \n error: this async expression only awaits a single future\n-  --> $DIR/redundant_async_block.rs:53:15\n+  --> $DIR/redundant_async_block.rs:29:15\n    |\n LL |     let fut = async { async { 42 }.await };\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `async { 42 }`\n \n error: this async expression only awaits a single future\n-  --> $DIR/redundant_async_block.rs:72:5\n+  --> $DIR/redundant_async_block.rs:45:5\n    |\n LL |     async move { fut.await }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `fut`\n \n error: this async expression only awaits a single future\n-  --> $DIR/redundant_async_block.rs:85:5\n+  --> $DIR/redundant_async_block.rs:58:5\n    |\n LL |     async move { fut.await }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `fut`\n \n-error: aborting due to 6 previous errors\n+error: this async expression only awaits a single future\n+  --> $DIR/redundant_async_block.rs:63:5\n+   |\n+LL |     async { f.await }\n+   |     ^^^^^^^^^^^^^^^^^ help: you can reduce it to: `f`\n+\n+error: this async expression only awaits a single future\n+  --> $DIR/redundant_async_block.rs:86:5\n+   |\n+LL |     async { async { f().await + 1 }.await }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `async { f().await + 1 }`\n+\n+error: this async expression only awaits a single future\n+  --> $DIR/redundant_async_block.rs:149:13\n+   |\n+LL |             async { async { 42 }.await }\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `async { 42 }`\n+...\n+LL |     mac!()\n+   |     ------ in this macro invocation\n+   |\n+   = note: this error originates in the macro `mac` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: this async expression only awaits a single future\n+  --> $DIR/redundant_async_block.rs:169:13\n+   |\n+LL |             async { async { $e }.await }\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `async { $e }`\n+...\n+LL |     mac!(42)\n+   |     -------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `mac` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "ac4c1bc65979fb5f38661d3f8ac37487ef802e89", "filename": "tests/ui/temporary_assignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,5 +1,4 @@\n #![warn(clippy::temporary_assignment)]\n-#![allow(const_item_mutation)]\n \n use std::ops::{Deref, DerefMut};\n "}, {"sha": "7d79901a28d1be70a17f22f33806278c09b0e340", "filename": "tests/ui/temporary_assignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Ftemporary_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Ftemporary_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,13 +1,13 @@\n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:48:5\n+  --> $DIR/temporary_assignment.rs:47:5\n    |\n LL |     Struct { field: 0 }.field = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::temporary-assignment` implied by `-D warnings`\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:49:5\n+  --> $DIR/temporary_assignment.rs:48:5\n    |\n LL | /     MultiStruct {\n LL | |         structure: Struct { field: 0 },\n@@ -17,13 +17,13 @@ LL | |     .field = 1;\n    | |______________^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:54:5\n+  --> $DIR/temporary_assignment.rs:53:5\n    |\n LL |     ArrayStruct { array: [0] }.array[0] = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:55:5\n+  --> $DIR/temporary_assignment.rs:54:5\n    |\n LL |     (0, 0).0 = 1;\n    |     ^^^^^^^^^^^^"}, {"sha": "1982b1d0107f8c473904885a7489622c2681daca", "filename": "tests/ui/tests_outside_test_module.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Ftests_outside_test_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Ftests_outside_test_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftests_outside_test_module.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,18 @@\n+// compile-flags: --test\n+#![allow(unused)]\n+#![warn(clippy::tests_outside_test_module)]\n+\n+fn main() {\n+    // test code goes here\n+}\n+\n+// Should lint\n+#[test]\n+fn my_test() {}\n+\n+#[cfg(test)]\n+mod tests {\n+    // Should not lint\n+    #[test]\n+    fn my_test() {}\n+}"}, {"sha": "125a79d6edfed9e98eb528a5f17cbda967a902ee", "filename": "tests/ui/tests_outside_test_module.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Ftests_outside_test_module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Ftests_outside_test_module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftests_outside_test_module.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,11 @@\n+error: this function marked with #[test] is outside a #[cfg(test)] module\n+  --> $DIR/tests_outside_test_module.rs:11:1\n+   |\n+LL | fn my_test() {}\n+   | ^^^^^^^^^^^^^^^\n+   |\n+   = note: move it to a testing module marked with #[cfg(test)]\n+   = note: `-D clippy::tests-outside-test-module` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "cc84ba25bd0d79edf9ef503b3ff218ebad3404df", "filename": "tests/ui/transmutes_expressible_as_ptr_casts.fixed", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -4,7 +4,7 @@\n // would otherwise be responsible for\n #![warn(clippy::useless_transmute)]\n #![warn(clippy::transmute_ptr_to_ptr)]\n-#![allow(dead_code, unused_unsafe, clippy::borrow_as_ptr)]\n+#![allow(unused, clippy::borrow_as_ptr)]\n \n use std::mem::{size_of, transmute};\n \n@@ -77,3 +77,9 @@ fn cannot_be_expressed_as_pointer_cast(in_param: Single) -> Pair {\n \n     unsafe { transmute::<Single, Pair>(in_param) }\n }\n+\n+fn issue_10449() {\n+    fn f() {}\n+\n+    let _x: u8 = unsafe { *(f as *const u8) };\n+}"}, {"sha": "aa65ab4dd2475372fa1ba7ab3ddf2a119a279e0e", "filename": "tests/ui/transmutes_expressible_as_ptr_casts.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -4,7 +4,7 @@\n // would otherwise be responsible for\n #![warn(clippy::useless_transmute)]\n #![warn(clippy::transmute_ptr_to_ptr)]\n-#![allow(dead_code, unused_unsafe, clippy::borrow_as_ptr)]\n+#![allow(unused, clippy::borrow_as_ptr)]\n \n use std::mem::{size_of, transmute};\n \n@@ -77,3 +77,9 @@ fn cannot_be_expressed_as_pointer_cast(in_param: Single) -> Pair {\n \n     unsafe { transmute::<Single, Pair>(in_param) }\n }\n+\n+fn issue_10449() {\n+    fn f() {}\n+\n+    let _x: u8 = unsafe { *std::mem::transmute::<fn(), *const u8>(f) };\n+}"}, {"sha": "58f5162c78e78839bdafd892fa8dd5a096cb3095", "filename": "tests/ui/transmutes_expressible_as_ptr_casts.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -58,5 +58,11 @@ error: transmute from a reference to a pointer\n LL |     unsafe { transmute::<&[i32; 1], *const u8>(in_param) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `in_param as *const [i32; 1] as *const u8`\n \n-error: aborting due to 9 previous errors\n+error: transmute from `fn()` to `*const u8` which could be expressed as a pointer cast instead\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:84:28\n+   |\n+LL |     let _x: u8 = unsafe { *std::mem::transmute::<fn(), *const u8>(f) };\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(f as *const u8)`\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "c996de89422b57a7f63f1dee5dd7fdd22b2396ae", "filename": "tests/ui/uninit.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,7 +1,7 @@\n #![feature(stmt_expr_attributes)]\n #![allow(clippy::let_unit_value, invalid_value)]\n \n-use std::mem::{self, MaybeUninit};\n+use std::mem::MaybeUninit;\n \n union MyOwnMaybeUninit {\n     value: u8,\n@@ -30,12 +30,24 @@ fn main() {\n     let _: [u8; 0] = unsafe { MaybeUninit::uninit().assume_init() };\n \n     // Was a false negative.\n-    let _: usize = unsafe { mem::MaybeUninit::uninit().assume_init() };\n+    let _: usize = unsafe { MaybeUninit::uninit().assume_init() };\n \n     polymorphic::<()>();\n+    polymorphic_maybe_uninit_array::<10>();\n+    polymorphic_maybe_uninit::<u8>();\n \n     fn polymorphic<T>() {\n         // We are conservative around polymorphic types.\n-        let _: T = unsafe { mem::MaybeUninit::uninit().assume_init() };\n+        let _: T = unsafe { MaybeUninit::uninit().assume_init() };\n+    }\n+\n+    fn polymorphic_maybe_uninit_array<const N: usize>() {\n+        // While the type is polymorphic, MaybeUninit<u8> is not.\n+        let _: [MaybeUninit<u8>; N] = unsafe { MaybeUninit::uninit().assume_init() };\n+    }\n+\n+    fn polymorphic_maybe_uninit<T>() {\n+        // The entire type is polymorphic, but it's wrapped in a MaybeUninit.\n+        let _: MaybeUninit<T> = unsafe { MaybeUninit::uninit().assume_init() };\n     }\n }"}, {"sha": "248de56da76cbab3e6140038f642da1e473e5203", "filename": "tests/ui/uninit.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funinit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funinit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -9,14 +9,14 @@ LL |     let _: usize = unsafe { MaybeUninit::uninit().assume_init() };\n error: this call for this type may be undefined behavior\n   --> $DIR/uninit.rs:33:29\n    |\n-LL |     let _: usize = unsafe { mem::MaybeUninit::uninit().assume_init() };\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _: usize = unsafe { MaybeUninit::uninit().assume_init() };\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this call for this type may be undefined behavior\n-  --> $DIR/uninit.rs:39:29\n+  --> $DIR/uninit.rs:41:29\n    |\n-LL |         let _: T = unsafe { mem::MaybeUninit::uninit().assume_init() };\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: T = unsafe { MaybeUninit::uninit().assume_init() };\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "79effc82fdf7cbf7c1003e74cf854d0473b32c7c", "filename": "tests/ui/uninit_vec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit_vec.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -124,4 +124,12 @@ fn main() {\n             vec.set_len(10);\n         }\n     }\n+\n+    fn poly_maybe_uninit<T>() {\n+        // We are conservative around polymorphic types.\n+        let mut vec: Vec<MaybeUninit<T>> = Vec::with_capacity(1000);\n+        unsafe {\n+            vec.set_len(10);\n+        }\n+    }\n }"}, {"sha": "3122081a44f98b4aded0fdd62401a82f8efb7a67", "filename": "tests/ui/uninlined_format_args.fixed", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funinlined_format_args.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funinlined_format_args.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinlined_format_args.fixed?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,7 +1,7 @@\n // aux-build:proc_macros.rs\n // run-rustfix\n #![warn(clippy::uninlined_format_args)]\n-#![allow(named_arguments_used_positionally, unused_imports, unused_macros, unused_variables)]\n+#![allow(named_arguments_used_positionally, unused)]\n #![allow(clippy::eq_op, clippy::format_in_format_args, clippy::print_literal)]\n \n extern crate proc_macros;\n@@ -119,7 +119,7 @@ fn tester(fn_arg: i32) {\n     println!(\"Width = {local_i32}, value with width = {local_f64:local_i32$}\");\n     println!(\"{local_i32:width$.prec$}\");\n     println!(\"{width:width$.prec$}\");\n-    println!(\"{}\", format!(\"{local_i32}\"));\n+    println!(\"{}\", format!(\"{}\", local_i32));\n     my_println!(\"{}\", local_i32);\n     my_println_args!(\"{}\", local_i32);\n \n@@ -178,3 +178,87 @@ fn _meets_msrv() {\n fn _do_not_fire() {\n     println!(\"{:?}\", None::<()>);\n }\n+\n+macro_rules! _internal {\n+    ($($args:tt)*) => {\n+        println!(\"{}\", format_args!($($args)*))\n+    };\n+}\n+\n+macro_rules! my_println2 {\n+   ($target:expr, $($args:tt)+) => {{\n+       if $target {\n+           _internal!($($args)+)\n+       }\n+    }};\n+}\n+\n+macro_rules! my_println2_args {\n+    ($target:expr, $($args:tt)+) => {{\n+       if $target {\n+           _internal!(\"foo: {}\", format_args!($($args)+))\n+       }\n+    }};\n+}\n+\n+macro_rules! my_concat {\n+    ($fmt:literal $(, $e:expr)*) => {\n+        println!(concat!(\"ERROR: \", $fmt), $($e,)*)\n+    }\n+}\n+\n+macro_rules! my_good_macro {\n+    ($fmt:literal $(, $e:expr)* $(,)?) => {\n+        println!($fmt $(, $e)*)\n+    }\n+}\n+\n+macro_rules! my_bad_macro {\n+    ($fmt:literal, $($e:expr),*) => {\n+        println!($fmt, $($e,)*)\n+    }\n+}\n+\n+macro_rules! my_bad_macro2 {\n+    ($fmt:literal) => {\n+        let s = $fmt.clone();\n+        println!(\"{}\", s);\n+    };\n+    ($fmt:literal, $($e:expr)+) => {\n+        println!($fmt, $($e,)*)\n+    };\n+}\n+\n+// This abomination was suggested by @Alexendoo, may the Rust gods have mercy on their soul...\n+// https://github.com/rust-lang/rust-clippy/pull/9948#issuecomment-1327965962\n+macro_rules! used_twice {\n+    (\n+        large = $large:literal,\n+        small = $small:literal,\n+        $val:expr,\n+    ) => {\n+        if $val < 5 {\n+            println!($small, $val);\n+        } else {\n+            println!($large, $val);\n+        }\n+    };\n+}\n+\n+fn tester2() {\n+    let local_i32 = 1;\n+    my_println2_args!(true, \"{}\", local_i32);\n+    my_println2!(true, \"{}\", local_i32);\n+    my_concat!(\"{}\", local_i32);\n+    my_good_macro!(\"{}\", local_i32);\n+    my_good_macro!(\"{}\", local_i32,);\n+\n+    // FIXME: Broken false positives, currently unhandled\n+    my_bad_macro!(\"{}\", local_i32);\n+    my_bad_macro2!(\"{}\", local_i32);\n+    used_twice! {\n+        large = \"large value: {}\",\n+        small = \"small value: {}\",\n+        local_i32,\n+    };\n+}"}, {"sha": "b153ef256e0c2d25f38a8f463da6a124dfca386d", "filename": "tests/ui/uninlined_format_args.rs", "status": "modified", "additions": 85, "deletions": 1, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funinlined_format_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funinlined_format_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinlined_format_args.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -1,7 +1,7 @@\n // aux-build:proc_macros.rs\n // run-rustfix\n #![warn(clippy::uninlined_format_args)]\n-#![allow(named_arguments_used_positionally, unused_imports, unused_macros, unused_variables)]\n+#![allow(named_arguments_used_positionally, unused)]\n #![allow(clippy::eq_op, clippy::format_in_format_args, clippy::print_literal)]\n \n extern crate proc_macros;\n@@ -183,3 +183,87 @@ fn _meets_msrv() {\n fn _do_not_fire() {\n     println!(\"{:?}\", None::<()>);\n }\n+\n+macro_rules! _internal {\n+    ($($args:tt)*) => {\n+        println!(\"{}\", format_args!($($args)*))\n+    };\n+}\n+\n+macro_rules! my_println2 {\n+   ($target:expr, $($args:tt)+) => {{\n+       if $target {\n+           _internal!($($args)+)\n+       }\n+    }};\n+}\n+\n+macro_rules! my_println2_args {\n+    ($target:expr, $($args:tt)+) => {{\n+       if $target {\n+           _internal!(\"foo: {}\", format_args!($($args)+))\n+       }\n+    }};\n+}\n+\n+macro_rules! my_concat {\n+    ($fmt:literal $(, $e:expr)*) => {\n+        println!(concat!(\"ERROR: \", $fmt), $($e,)*)\n+    }\n+}\n+\n+macro_rules! my_good_macro {\n+    ($fmt:literal $(, $e:expr)* $(,)?) => {\n+        println!($fmt $(, $e)*)\n+    }\n+}\n+\n+macro_rules! my_bad_macro {\n+    ($fmt:literal, $($e:expr),*) => {\n+        println!($fmt, $($e,)*)\n+    }\n+}\n+\n+macro_rules! my_bad_macro2 {\n+    ($fmt:literal) => {\n+        let s = $fmt.clone();\n+        println!(\"{}\", s);\n+    };\n+    ($fmt:literal, $($e:expr)+) => {\n+        println!($fmt, $($e,)*)\n+    };\n+}\n+\n+// This abomination was suggested by @Alexendoo, may the Rust gods have mercy on their soul...\n+// https://github.com/rust-lang/rust-clippy/pull/9948#issuecomment-1327965962\n+macro_rules! used_twice {\n+    (\n+        large = $large:literal,\n+        small = $small:literal,\n+        $val:expr,\n+    ) => {\n+        if $val < 5 {\n+            println!($small, $val);\n+        } else {\n+            println!($large, $val);\n+        }\n+    };\n+}\n+\n+fn tester2() {\n+    let local_i32 = 1;\n+    my_println2_args!(true, \"{}\", local_i32);\n+    my_println2!(true, \"{}\", local_i32);\n+    my_concat!(\"{}\", local_i32);\n+    my_good_macro!(\"{}\", local_i32);\n+    my_good_macro!(\"{}\", local_i32,);\n+\n+    // FIXME: Broken false positives, currently unhandled\n+    my_bad_macro!(\"{}\", local_i32);\n+    my_bad_macro2!(\"{}\", local_i32);\n+    used_twice! {\n+        large = \"large value: {}\",\n+        small = \"small value: {}\",\n+        local_i32,\n+    };\n+}"}, {"sha": "dc4af6ef42ecd5a8201bf00218b4f69b524d8abe", "filename": "tests/ui/uninlined_format_args.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funinlined_format_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funinlined_format_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinlined_format_args.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -774,18 +774,6 @@ LL -     println!(\"{:w$.p$}\", w = width, p = prec);\n LL +     println!(\"{width:width$.prec$}\");\n    |\n \n-error: variables can be used directly in the `format!` string\n-  --> $DIR/uninlined_format_args.rs:125:20\n-   |\n-LL |     println!(\"{}\", format!(\"{}\", local_i32));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: change this to\n-   |\n-LL -     println!(\"{}\", format!(\"{}\", local_i32));\n-LL +     println!(\"{}\", format!(\"{local_i32}\"));\n-   |\n-\n error: variables can be used directly in the `format!` string\n   --> $DIR/uninlined_format_args.rs:143:5\n    |\n@@ -856,5 +844,5 @@ LL -     println!(\"expand='{}'\", local_i32);\n LL +     println!(\"expand='{local_i32}'\");\n    |\n \n-error: aborting due to 72 previous errors\n+error: aborting due to 71 previous errors\n "}, {"sha": "fe60d929759ba8eff87cc691df8f89d345ea78d1", "filename": "tests/ui/unnecessary_box_returns.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funnecessary_box_returns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funnecessary_box_returns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_box_returns.rs?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,60 @@\n+#![warn(clippy::unnecessary_box_returns)]\n+\n+trait Bar {\n+    // lint\n+    fn baz(&self) -> Box<usize>;\n+}\n+\n+pub struct Foo {}\n+\n+impl Bar for Foo {\n+    // don't lint: this is a problem with the trait, not the implementation\n+    fn baz(&self) -> Box<usize> {\n+        Box::new(42)\n+    }\n+}\n+\n+impl Foo {\n+    fn baz(&self) -> Box<usize> {\n+        // lint\n+        Box::new(13)\n+    }\n+}\n+\n+// lint\n+fn bxed_usize() -> Box<usize> {\n+    Box::new(5)\n+}\n+\n+// lint\n+fn _bxed_foo() -> Box<Foo> {\n+    Box::new(Foo {})\n+}\n+\n+// don't lint: this is exported\n+pub fn bxed_foo() -> Box<Foo> {\n+    Box::new(Foo {})\n+}\n+\n+// don't lint: str is unsized\n+fn bxed_str() -> Box<str> {\n+    \"Hello, world!\".to_string().into_boxed_str()\n+}\n+\n+// don't lint: function contains the word, \"box\"\n+fn boxed_usize() -> Box<usize> {\n+    Box::new(7)\n+}\n+\n+// don't lint: this has an unspecified return type\n+fn default() {}\n+\n+// don't lint: this doesn't return a Box\n+fn string() -> String {\n+    String::from(\"Hello, world\")\n+}\n+\n+fn main() {\n+    // don't lint: this is a closure\n+    let a = || -> Box<usize> { Box::new(5) };\n+}"}, {"sha": "b17512c10a1773c343d9c9eb9a7b7dd82f6698b4", "filename": "tests/ui/unnecessary_box_returns.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funnecessary_box_returns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funnecessary_box_returns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_box_returns.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -0,0 +1,35 @@\n+error: boxed return of the sized type `usize`\n+  --> $DIR/unnecessary_box_returns.rs:5:22\n+   |\n+LL |     fn baz(&self) -> Box<usize>;\n+   |                      ^^^^^^^^^^ help: try: `usize`\n+   |\n+   = help: changing this also requires a change to the return expressions in this function\n+   = note: `-D clippy::unnecessary-box-returns` implied by `-D warnings`\n+\n+error: boxed return of the sized type `usize`\n+  --> $DIR/unnecessary_box_returns.rs:18:22\n+   |\n+LL |     fn baz(&self) -> Box<usize> {\n+   |                      ^^^^^^^^^^ help: try: `usize`\n+   |\n+   = help: changing this also requires a change to the return expressions in this function\n+\n+error: boxed return of the sized type `usize`\n+  --> $DIR/unnecessary_box_returns.rs:25:20\n+   |\n+LL | fn bxed_usize() -> Box<usize> {\n+   |                    ^^^^^^^^^^ help: try: `usize`\n+   |\n+   = help: changing this also requires a change to the return expressions in this function\n+\n+error: boxed return of the sized type `Foo`\n+  --> $DIR/unnecessary_box_returns.rs:30:19\n+   |\n+LL | fn _bxed_foo() -> Box<Foo> {\n+   |                   ^^^^^^^^ help: try: `Foo`\n+   |\n+   = help: changing this also requires a change to the return expressions in this function\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "2930722b42d9d4f39d33deb8119a3659b11df891", "filename": "tests/ui/unused_format_specs.fixed", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e9c7fb10b92c47e9bb2713fae5ef74a07efce92d/tests%2Fui%2Funused_format_specs.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e9c7fb10b92c47e9bb2713fae5ef74a07efce92d/tests%2Fui%2Funused_format_specs.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs.fixed?ref=e9c7fb10b92c47e9bb2713fae5ef74a07efce92d", "patch": "@@ -1,18 +0,0 @@\n-// run-rustfix\n-\n-#![warn(clippy::unused_format_specs)]\n-#![allow(unused)]\n-\n-fn main() {\n-    let f = 1.0f64;\n-    println!(\"{}\", 1.0);\n-    println!(\"{f} {f:?}\");\n-\n-    println!(\"{}\", 1);\n-}\n-\n-fn should_not_lint() {\n-    let f = 1.0f64;\n-    println!(\"{:.1}\", 1.0);\n-    println!(\"{f:.w$} {f:.*?}\", 3, w = 2);\n-}"}, {"sha": "ee192a000d4b55e6fd4d1a8c8ba72238cc626a4f", "filename": "tests/ui/unused_format_specs.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e9c7fb10b92c47e9bb2713fae5ef74a07efce92d/tests%2Fui%2Funused_format_specs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c7fb10b92c47e9bb2713fae5ef74a07efce92d/tests%2Fui%2Funused_format_specs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs.rs?ref=e9c7fb10b92c47e9bb2713fae5ef74a07efce92d", "patch": "@@ -1,18 +0,0 @@\n-// run-rustfix\n-\n-#![warn(clippy::unused_format_specs)]\n-#![allow(unused)]\n-\n-fn main() {\n-    let f = 1.0f64;\n-    println!(\"{:.}\", 1.0);\n-    println!(\"{f:.} {f:.?}\");\n-\n-    println!(\"{:.}\", 1);\n-}\n-\n-fn should_not_lint() {\n-    let f = 1.0f64;\n-    println!(\"{:.1}\", 1.0);\n-    println!(\"{f:.w$} {f:.*?}\", 3, w = 2);\n-}"}, {"sha": "7231c17e74c19cd9de5c4c36d6c227594917f147", "filename": "tests/ui/unused_format_specs.stderr", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e9c7fb10b92c47e9bb2713fae5ef74a07efce92d/tests%2Fui%2Funused_format_specs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e9c7fb10b92c47e9bb2713fae5ef74a07efce92d/tests%2Fui%2Funused_format_specs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs.stderr?ref=e9c7fb10b92c47e9bb2713fae5ef74a07efce92d", "patch": "@@ -1,54 +0,0 @@\n-error: empty precision specifier has no effect\n-  --> $DIR/unused_format_specs.rs:8:17\n-   |\n-LL |     println!(\"{:.}\", 1.0);\n-   |                 ^\n-   |\n-   = note: a precision specifier is not required to format floats\n-   = note: `-D clippy::unused-format-specs` implied by `-D warnings`\n-help: remove the `.`\n-   |\n-LL -     println!(\"{:.}\", 1.0);\n-LL +     println!(\"{}\", 1.0);\n-   |\n-\n-error: empty precision specifier has no effect\n-  --> $DIR/unused_format_specs.rs:9:18\n-   |\n-LL |     println!(\"{f:.} {f:.?}\");\n-   |                  ^\n-   |\n-   = note: a precision specifier is not required to format floats\n-help: remove the `.`\n-   |\n-LL -     println!(\"{f:.} {f:.?}\");\n-LL +     println!(\"{f} {f:.?}\");\n-   |\n-\n-error: empty precision specifier has no effect\n-  --> $DIR/unused_format_specs.rs:9:24\n-   |\n-LL |     println!(\"{f:.} {f:.?}\");\n-   |                        ^\n-   |\n-   = note: a precision specifier is not required to format floats\n-help: remove the `.`\n-   |\n-LL -     println!(\"{f:.} {f:.?}\");\n-LL +     println!(\"{f:.} {f:?}\");\n-   |\n-\n-error: empty precision specifier has no effect\n-  --> $DIR/unused_format_specs.rs:11:17\n-   |\n-LL |     println!(\"{:.}\", 1);\n-   |                 ^\n-   |\n-help: remove the `.`\n-   |\n-LL -     println!(\"{:.}\", 1);\n-LL +     println!(\"{}\", 1);\n-   |\n-\n-error: aborting due to 4 previous errors\n-"}, {"sha": "cb7156b6baf0d8cec40121b324b0e6fa9626f258", "filename": "tests/ui/unused_format_specs_unfixable.stderr", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funused_format_specs_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04c387efe7bef9b071596a7a4004297bf9e3c77c/tests%2Fui%2Funused_format_specs_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs_unfixable.stderr?ref=04c387efe7bef9b071596a7a4004297bf9e3c77c", "patch": "@@ -37,11 +37,7 @@ error: format specifiers have no effect on `format_args!()`\n LL |     println!(\"{:5}.\", format_args_from_macro!());\n    |               ^^^^\n    |\n-help: for the width to apply consider using `format!()`\n-  --> $DIR/unused_format_specs_unfixable.rs:16:17\n-   |\n-LL |     println!(\"{:5}.\", format_args_from_macro!());\n-   |                 ^\n+   = help: for the width to apply consider using `format!()`\n help: if the current behavior is intentional, remove the format specifiers\n    |\n LL -     println!(\"{:5}.\", format_args_from_macro!());\n@@ -54,11 +50,7 @@ error: format specifiers have no effect on `format_args!()`\n LL |     println!(\"{args:5}\");\n    |               ^^^^^^^^\n    |\n-help: for the width to apply consider using `format!()`\n-  --> $DIR/unused_format_specs_unfixable.rs:19:21\n-   |\n-LL |     println!(\"{args:5}\");\n-   |                     ^\n+   = help: for the width to apply consider using `format!()`\n help: if the current behavior is intentional, remove the format specifiers\n    |\n LL -     println!(\"{args:5}\");"}]}