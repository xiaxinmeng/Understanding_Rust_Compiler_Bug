{"sha": "012d5fd8d7bd22cd08d83449afbdf30392022e1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMmQ1ZmQ4ZDdiZDIyY2QwOGQ4MzQ0OWFmYmRmMzAzOTIwMjJlMWQ=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-11-24T12:17:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-24T12:17:45Z"}, "message": "Rollup merge of #79354 - ssomers:btree_bereave_BoxedNode, r=Mark-Simulacrum\n\nBTreeMap: cut out the ceremony around BoxedNode\n\nThe opposite direction of #79093.\n\nr? ``@Mark-Simulacrum``", "tree": {"sha": "da147787c96f90d06657c13ac4e8de1a8e719541", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da147787c96f90d06657c13ac4e8de1a8e719541"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/012d5fd8d7bd22cd08d83449afbdf30392022e1d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfvPnpCRBK7hj4Ov3rIwAAdHIIAAsBaWG0x4KIVbnCL9utYmPF\ngPDEYrg3qGyWLH01n7QpraH+PXCJK7Xie7FnnsPF+TilUUTD3HW9Eu35cPie0sEa\n0VTtJoKVrBt9qdmGSYVfe66Kj0mLWuFpOSgMEcjevQ20sOEQ89J6jIRvoEm1QngX\ng4a2QZnVAAJh8p95O0nNtruwgT2SpmJa1Pg8Oy098bgCN/jkY4AoyPa0FQSmx8AE\n3qR0yaLjJQCEeAm1qQmXteVF2lnvuUU1cZaqLLddDbbxLHLa+Fyb+uU6xbf4fL/B\nRzv9W0PBcT4psUVDbNsQu0r4GS2h4E0MOYiCRp4ZWWbWQOU2yt9EH7Qpp5hN87g=\n=LQiG\n-----END PGP SIGNATURE-----\n", "payload": "tree da147787c96f90d06657c13ac4e8de1a8e719541\nparent ed5d539c62c47f6b21d1e63164c1e41d7c310fc4\nparent 8526c313c115bb997a10d6c012864f6c4a5c6853\nauthor Jonas Schievink <jonasschievink@gmail.com> 1606220265 +0100\ncommitter GitHub <noreply@github.com> 1606220265 +0100\n\nRollup merge of #79354 - ssomers:btree_bereave_BoxedNode, r=Mark-Simulacrum\n\nBTreeMap: cut out the ceremony around BoxedNode\n\nThe opposite direction of #79093.\n\nr? ``@Mark-Simulacrum``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/012d5fd8d7bd22cd08d83449afbdf30392022e1d", "html_url": "https://github.com/rust-lang/rust/commit/012d5fd8d7bd22cd08d83449afbdf30392022e1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/012d5fd8d7bd22cd08d83449afbdf30392022e1d/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed5d539c62c47f6b21d1e63164c1e41d7c310fc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed5d539c62c47f6b21d1e63164c1e41d7c310fc4", "html_url": "https://github.com/rust-lang/rust/commit/ed5d539c62c47f6b21d1e63164c1e41d7c310fc4"}, {"sha": "8526c313c115bb997a10d6c012864f6c4a5c6853", "url": "https://api.github.com/repos/rust-lang/rust/commits/8526c313c115bb997a10d6c012864f6c4a5c6853", "html_url": "https://github.com/rust-lang/rust/commit/8526c313c115bb997a10d6c012864f6c4a5c6853"}], "stats": {"total": 62, "additions": 18, "deletions": 44}, "files": [{"sha": "6a8be441513a0b7b7b4fa7a43ba9a56a386b947f", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 12, "deletions": 38, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/012d5fd8d7bd22cd08d83449afbdf30392022e1d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012d5fd8d7bd22cd08d83449afbdf30392022e1d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=012d5fd8d7bd22cd08d83449afbdf30392022e1d", "patch": "@@ -112,20 +112,8 @@ impl<K, V> InternalNode<K, V> {\n ///\n /// However, `BoxedNode` contains no information as to which of the two types\n /// of nodes it actually contains, and, partially due to this lack of information,\n-/// has no destructor.\n-struct BoxedNode<K, V> {\n-    ptr: NonNull<LeafNode<K, V>>,\n-}\n-\n-impl<K, V> BoxedNode<K, V> {\n-    fn from_owned(ptr: NonNull<LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr }\n-    }\n-\n-    fn as_ptr(&self) -> NonNull<LeafNode<K, V>> {\n-        self.ptr\n-    }\n-}\n+/// is not a separate type and has no destructor.\n+type BoxedNode<K, V> = NonNull<LeafNode<K, V>>;\n \n /// An owned tree.\n ///\n@@ -168,11 +156,6 @@ impl<K, V, Type> NodeRef<marker::Owned, K, V, Type> {\n     pub fn borrow_valmut(&mut self) -> NodeRef<marker::ValMut<'_>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n-\n-    /// Packs the reference, aware of type and height, into a type-agnostic pointer.\n-    fn into_boxed_node(self) -> BoxedNode<K, V> {\n-        BoxedNode::from_owned(self.node)\n-    }\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n@@ -181,7 +164,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     /// and is the opposite of `pop_internal_level`.\n     pub fn push_internal_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n-        new_node.edges[0].write(BoxedNode::from_owned(self.node));\n+        new_node.edges[0].write(self.node);\n         let mut new_root = NodeRef::from_new_internal(new_node, self.height + 1);\n         new_root.borrow_mut().first_edge().correct_parent_link();\n         *self = new_root.forget_type();\n@@ -288,13 +271,6 @@ unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::Mut<'\n unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::ValMut<'a>, K, V, Type> {}\n unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Owned, K, V, Type> {}\n \n-impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n-    /// Unpack a node reference that was packed by `Root::into_boxed_node`.\n-    fn from_boxed_node(boxed_node: BoxedNode<K, V>, height: usize) -> Self {\n-        NodeRef { height, node: boxed_node.as_ptr(), _marker: PhantomData }\n-    }\n-}\n-\n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n     /// Unpack a node reference that was packed as `NodeRef::parent`.\n     fn from_internal(node: NonNull<InternalNode<K, V>>, height: usize) -> Self {\n@@ -695,7 +671,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         unsafe {\n             self.reborrow_mut().into_key_area_mut_at(idx).write(key);\n             self.reborrow_mut().into_val_area_mut_at(idx).write(val);\n-            self.reborrow_mut().into_edge_area_mut_at(idx + 1).write(edge.into_boxed_node());\n+            self.reborrow_mut().into_edge_area_mut_at(idx + 1).write(edge.node);\n             Handle::new_edge(self.reborrow_mut(), idx + 1).correct_parent_link();\n         }\n     }\n@@ -710,7 +686,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n             *self.reborrow_mut().into_len_mut() += 1;\n             slice_insert(self.reborrow_mut().into_key_area_slice(), 0, key);\n             slice_insert(self.reborrow_mut().into_val_area_slice(), 0, val);\n-            slice_insert(self.reborrow_mut().into_edge_area_slice(), 0, edge.into_boxed_node());\n+            slice_insert(self.reborrow_mut().into_edge_area_slice(), 0, edge.node);\n         }\n \n         self.correct_all_childrens_parent_links();\n@@ -732,8 +708,8 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(internal) => {\n-                    let boxed_node = ptr::read(internal.reborrow().edge_at(idx + 1));\n-                    let mut edge = Root::from_boxed_node(boxed_node, internal.height - 1);\n+                    let node = ptr::read(internal.reborrow().edge_at(idx + 1));\n+                    let mut edge = Root { node, height: internal.height - 1, _marker: PhantomData };\n                     // In practice, clearing the parent is a waste of time, because we will\n                     // insert the node elsewhere and set its parent link again.\n                     edge.borrow_mut().clear_parent_link();\n@@ -760,9 +736,8 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(mut internal) => {\n-                    let boxed_node =\n-                        slice_remove(internal.reborrow_mut().into_edge_area_slice(), 0);\n-                    let mut edge = Root::from_boxed_node(boxed_node, internal.height - 1);\n+                    let node = slice_remove(internal.reborrow_mut().into_edge_area_slice(), 0);\n+                    let mut edge = Root { node, height: internal.height - 1, _marker: PhantomData };\n                     // In practice, clearing the parent is a waste of time, because we will\n                     // insert the node elsewhere and set its parent link again.\n                     edge.borrow_mut().clear_parent_link();\n@@ -1041,12 +1016,11 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n         debug_assert!(self.node.len() < CAPACITY);\n         debug_assert!(edge.height == self.node.height - 1);\n \n-        let boxed_node = edge.into_boxed_node();\n         unsafe {\n             *self.node.reborrow_mut().into_len_mut() += 1;\n             slice_insert(self.node.reborrow_mut().into_key_area_slice(), self.idx, key);\n             slice_insert(self.node.reborrow_mut().into_val_area_slice(), self.idx, val);\n-            slice_insert(self.node.reborrow_mut().into_edge_area_slice(), self.idx + 1, boxed_node);\n+            slice_insert(self.node.reborrow_mut().into_edge_area_slice(), self.idx + 1, edge.node);\n \n             self.node.correct_childrens_parent_links((self.idx + 1)..=self.node.len());\n         }\n@@ -1135,8 +1109,8 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marke\n         // reference (Rust issue #73987) and invalidate any other references\n         // to or inside the array, should any be around.\n         let parent_ptr = NodeRef::as_internal_ptr(&self.node);\n-        let boxed_node = unsafe { (*parent_ptr).edges.get_unchecked(self.idx).assume_init_read() };\n-        NodeRef::from_boxed_node(boxed_node, self.node.height - 1)\n+        let node = unsafe { (*parent_ptr).edges.get_unchecked(self.idx).assume_init_read() };\n+        NodeRef { node, height: self.node.height - 1, _marker: PhantomData }\n     }\n }\n "}, {"sha": "b74d47a80027ad5dc455f29a94d402a1a9e12be5", "filename": "src/etc/gdb_providers.py", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/012d5fd8d7bd22cd08d83449afbdf30392022e1d/src%2Fetc%2Fgdb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/012d5fd8d7bd22cd08d83449afbdf30392022e1d/src%2Fetc%2Fgdb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_providers.py?ref=012d5fd8d7bd22cd08d83449afbdf30392022e1d", "patch": "@@ -216,6 +216,10 @@ def cast_to_internal(node):\n             internal_type = lookup_type(internal_type_name)\n             return node.cast(internal_type.pointer())\n \n+        if node_ptr.type.name.startswith(\"alloc::collections::btree::node::BoxedNode<\"):\n+            # BACKCOMPAT: rust 1.49\n+            node_ptr = node_ptr[\"ptr\"]\n+        node_ptr = unwrap_unique_or_non_null(node_ptr)\n         leaf = node_ptr.dereference()\n         keys = leaf[\"keys\"]\n         vals = leaf[\"vals\"]\n@@ -224,9 +228,8 @@ def cast_to_internal(node):\n \n         for i in xrange(0, length + 1):\n             if height > 0:\n-                boxed_child_node = edges[i][\"value\"][\"value\"]\n-                child_node = unwrap_unique_or_non_null(boxed_child_node[\"ptr\"])\n-                for child in children_of_node(child_node, height - 1):\n+                child_ptr = edges[i][\"value\"][\"value\"]\n+                for child in children_of_node(child_ptr, height - 1):\n                     yield child\n             if i < length:\n                 # Avoid \"Cannot perform pointer math on incomplete type\" on zero-sized arrays.\n@@ -239,9 +242,6 @@ def cast_to_internal(node):\n         if root.type.name.startswith(\"core::option::Option<\"):\n             root = root.cast(gdb.lookup_type(root.type.name[21:-1]))\n         node_ptr = root[\"node\"]\n-        if node_ptr.type.name.startswith(\"alloc::collections::btree::node::BoxedNode<\"):\n-            node_ptr = node_ptr[\"ptr\"]\n-        node_ptr = unwrap_unique_or_non_null(node_ptr)\n         height = root[\"height\"]\n         for child in children_of_node(node_ptr, height):\n             yield child"}]}