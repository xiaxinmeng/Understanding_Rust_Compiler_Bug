{"sha": "542119f61f376fa71bfc4b34fbb25be604279dc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MjExOWY2MWYzNzZmYTcxYmZjNGIzNGZiYjI1YmU2MDQyNzlkYzQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-01T22:32:37Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-03T00:49:32Z"}, "message": "libcore: Remove `fn@`, `fn~`, and `fn&` from libcore. rs=defun", "tree": {"sha": "602ff5fb56417907652c1f3c5042603b9fdbbd0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/602ff5fb56417907652c1f3c5042603b9fdbbd0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/542119f61f376fa71bfc4b34fbb25be604279dc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/542119f61f376fa71bfc4b34fbb25be604279dc4", "html_url": "https://github.com/rust-lang/rust/commit/542119f61f376fa71bfc4b34fbb25be604279dc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/542119f61f376fa71bfc4b34fbb25be604279dc4/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a38cbebd8c21f2a9ea97d5a5802cdc34045e9cc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a38cbebd8c21f2a9ea97d5a5802cdc34045e9cc1", "html_url": "https://github.com/rust-lang/rust/commit/a38cbebd8c21f2a9ea97d5a5802cdc34045e9cc1"}], "stats": {"total": 105, "additions": 51, "deletions": 54}, "files": [{"sha": "4f9b8ccf7576cea0cecb298401b0b76ea753dc0a", "filename": "src/libcore/io.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/542119f61f376fa71bfc4b34fbb25be604279dc4/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542119f61f376fa71bfc4b34fbb25be604279dc4/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=542119f61f376fa71bfc4b34fbb25be604279dc4", "patch": "@@ -1139,7 +1139,7 @@ pub mod fsync {\n     pub struct Arg<t> {\n         val: t,\n         opt_level: Option<Level>,\n-        fsync_fn: fn@(f: t, Level) -> int,\n+        fsync_fn: @fn(f: t, Level) -> int,\n     }\n \n     // fsync file after executing blk\n@@ -1150,9 +1150,9 @@ pub mod fsync {\n         unsafe {\n             blk(Res(Arg {\n                 val: file.f, opt_level: opt_level,\n-                fsync_fn: fn@(file: *libc::FILE, l: Level) -> int {\n+                fsync_fn: |file, l| {\n                     unsafe {\n-                        return os::fsync_fd(libc::fileno(file), l) as int;\n+                        os::fsync_fd(libc::fileno(file), l) as int\n                     }\n                 }\n             }));\n@@ -1164,9 +1164,7 @@ pub mod fsync {\n                        blk: fn(v: Res<fd_t>)) {\n         blk(Res(Arg {\n             val: fd.fd, opt_level: opt_level,\n-            fsync_fn: fn@(fd: fd_t, l: Level) -> int {\n-                return os::fsync_fd(fd, l) as int;\n-            }\n+            fsync_fn: |fd, l| os::fsync_fd(fd, l) as int\n         }));\n     }\n \n@@ -1178,9 +1176,7 @@ pub mod fsync {\n                     blk: fn(v: Res<FSyncable>)) {\n         blk(Res(Arg {\n             val: o, opt_level: opt_level,\n-            fsync_fn: fn@(o: FSyncable, l: Level) -> int {\n-                return o.fsync(l);\n-            }\n+            fsync_fn: |o, l| o.fsync(l)\n         }));\n     }\n }"}, {"sha": "e4fc9528f23fc2e31077af2d901493831d8ec7bf", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/542119f61f376fa71bfc4b34fbb25be604279dc4/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542119f61f376fa71bfc4b34fbb25be604279dc4/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=542119f61f376fa71bfc4b34fbb25be604279dc4", "patch": "@@ -910,11 +910,10 @@ endpoint is passed to the new task.\n \n */\n pub fn spawn_service<T:Owned,Tb:Owned>(\n-    init: extern fn() -> (SendPacketBuffered<T, Tb>,\n-                          RecvPacketBuffered<T, Tb>),\n-    service: fn~(v: RecvPacketBuffered<T, Tb>))\n-    -> SendPacketBuffered<T, Tb>\n-{\n+            init: extern fn() -> (SendPacketBuffered<T, Tb>,\n+                                  RecvPacketBuffered<T, Tb>),\n+            service: ~fn(v: RecvPacketBuffered<T, Tb>))\n+        -> SendPacketBuffered<T, Tb> {\n     let (client, server) = init();\n \n     // This is some nasty gymnastics required to safely move the pipe\n@@ -932,11 +931,10 @@ receive state.\n \n */\n pub fn spawn_service_recv<T:Owned,Tb:Owned>(\n-    init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n-                          SendPacketBuffered<T, Tb>),\n-    service: fn~(v: SendPacketBuffered<T, Tb>))\n-    -> RecvPacketBuffered<T, Tb>\n-{\n+        init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n+                              SendPacketBuffered<T, Tb>),\n+        service: ~fn(v: SendPacketBuffered<T, Tb>))\n+        -> RecvPacketBuffered<T, Tb> {\n     let (client, server) = init();\n \n     // This is some nasty gymnastics required to safely move the pipe"}, {"sha": "06ae4eb17a534614bee1fcc667230cc76942239b", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/542119f61f376fa71bfc4b34fbb25be604279dc4/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542119f61f376fa71bfc4b34fbb25be604279dc4/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=542119f61f376fa71bfc4b34fbb25be604279dc4", "patch": "@@ -489,9 +489,9 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_closure_ptr(&self, ck: uint) -> bool {\n-        self.align_to::<fn@()>();\n+        self.align_to::<@fn()>();\n         if ! self.inner.visit_closure_ptr(ck) { return false; }\n-        self.bump_past::<fn@()>();\n+        self.bump_past::<@fn()>();\n         true\n     }\n }"}, {"sha": "0835d4400ede80b54d708277f59a6d20690ee1f2", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/542119f61f376fa71bfc4b34fbb25be604279dc4/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542119f61f376fa71bfc4b34fbb25be604279dc4/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=542119f61f376fa71bfc4b34fbb25be604279dc4", "patch": "@@ -191,7 +191,7 @@ pub struct TaskOpts {\n // FIXME (#3724): Replace the 'consumed' bit with move mode on self\n pub struct TaskBuilder {\n     opts: TaskOpts,\n-    gen_body: fn@(v: fn~()) -> fn~(),\n+    gen_body: @fn(v: ~fn()) -> ~fn(),\n     can_not_copy: Option<util::NonCopyable>,\n     mut consumed: bool,\n }\n@@ -357,7 +357,7 @@ pub impl TaskBuilder {\n      * generator by applying the task body which results from the\n      * existing body generator to the new body generator.\n      */\n-    fn add_wrapper(wrapper: fn@(v: fn~()) -> fn~()) -> TaskBuilder {\n+    fn add_wrapper(wrapper: @fn(v: ~fn()) -> ~fn()) -> TaskBuilder {\n         let prev_gen_body = self.gen_body;\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         TaskBuilder {\n@@ -385,7 +385,7 @@ pub impl TaskBuilder {\n      * When spawning into a new scheduler, the number of threads requested\n      * must be greater than zero.\n      */\n-    fn spawn(f: fn~()) {\n+    fn spawn(f: ~fn()) {\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         let x = self.consume();\n         let opts = TaskOpts {\n@@ -397,7 +397,7 @@ pub impl TaskBuilder {\n         spawn::spawn_raw(opts, (x.gen_body)(f));\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n-    fn spawn_with<A:Owned>(arg: A, f: fn~(v: A)) {\n+    fn spawn_with<A:Owned>(arg: A, f: ~fn(v: A)) {\n         let arg = Cell(arg);\n         do self.spawn {\n             f(arg.take());\n@@ -417,7 +417,7 @@ pub impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn try<T:Owned>(f: fn~() -> T) -> Result<T,()> {\n+    fn try<T:Owned>(f: ~fn() -> T) -> Result<T,()> {\n         let (po, ch) = stream::<T>();\n         let mut result = None;\n \n@@ -458,7 +458,7 @@ pub fn default_task_opts() -> TaskOpts {\n \n /* Spawn convenience functions */\n \n-pub fn spawn(f: fn~()) {\n+pub fn spawn(f: ~fn()) {\n     /*!\n      * Creates and executes a new child task\n      *\n@@ -471,7 +471,7 @@ pub fn spawn(f: fn~()) {\n     task().spawn(f)\n }\n \n-pub fn spawn_unlinked(f: fn~()) {\n+pub fn spawn_unlinked(f: ~fn()) {\n     /*!\n      * Creates a child task unlinked from the current one. If either this\n      * task or the child task fails, the other will not be killed.\n@@ -480,7 +480,7 @@ pub fn spawn_unlinked(f: fn~()) {\n     task().unlinked().spawn(f)\n }\n \n-pub fn spawn_supervised(f: fn~()) {\n+pub fn spawn_supervised(f: ~fn()) {\n     /*!\n      * Creates a child task unlinked from the current one. If either this\n      * task or the child task fails, the other will not be killed.\n@@ -489,7 +489,7 @@ pub fn spawn_supervised(f: fn~()) {\n     task().supervised().spawn(f)\n }\n \n-pub fn spawn_with<A:Owned>(arg: A, f: fn~(v: A)) {\n+pub fn spawn_with<A:Owned>(arg: A, f: ~fn(v: A)) {\n     /*!\n      * Runs a task, while transfering ownership of one argument to the\n      * child.\n@@ -503,7 +503,7 @@ pub fn spawn_with<A:Owned>(arg: A, f: fn~(v: A)) {\n     task().spawn_with(arg, f)\n }\n \n-pub fn spawn_sched(mode: SchedMode, f: fn~()) {\n+pub fn spawn_sched(mode: SchedMode, f: ~fn()) {\n     /*!\n      * Creates a new task on a new or existing scheduler\n \n@@ -519,7 +519,7 @@ pub fn spawn_sched(mode: SchedMode, f: fn~()) {\n     task().sched_mode(mode).spawn(f)\n }\n \n-pub fn try<T:Owned>(f: fn~() -> T) -> Result<T,()> {\n+pub fn try<T:Owned>(f: ~fn() -> T) -> Result<T,()> {\n     /*!\n      * Execute a function in another task and return either the return value\n      * of the function or result::err.\n@@ -840,11 +840,12 @@ fn test_add_wrapper() {\n     let ch = Wrapper { f: Some(ch) };\n     let b1 = do b0.add_wrapper |body| {\n         let ch = Wrapper { f: Some(ch.f.swap_unwrap()) };\n-        fn~() {\n+        let result: ~fn() = || {\n             let ch = ch.f.swap_unwrap();\n             body();\n             ch.send(());\n-        }\n+        };\n+        result\n     };\n     do b1.spawn { }\n     po.recv();\n@@ -1015,7 +1016,7 @@ fn test_spawn_sched_blocking() {\n }\n \n #[cfg(test)]\n-fn avoid_copying_the_body(spawnfn: fn(v: fn~())) {\n+fn avoid_copying_the_body(spawnfn: &fn(v: ~fn())) {\n     let (p, ch) = stream::<uint>();\n \n     let x = ~1;\n@@ -1164,7 +1165,7 @@ fn test_child_doesnt_ref_parent() {\n     // (well, it would if the constant were 8000+ - I lowered it to be more\n     // valgrind-friendly. try this at home, instead..!)\n     const generations: uint = 16;\n-    fn child_no(x: uint) -> fn~() {\n+    fn child_no(x: uint) -> ~fn() {\n         return || {\n             if x < generations {\n                 task::spawn(child_no(x+1));"}, {"sha": "152e602eeee070902322b19d7961d60325358c8c", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/542119f61f376fa71bfc4b34fbb25be604279dc4/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542119f61f376fa71bfc4b34fbb25be604279dc4/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=542119f61f376fa71bfc4b34fbb25be604279dc4", "patch": "@@ -173,19 +173,19 @@ fn access_ancestors<U>(x: &unstable::Exclusive<AncestorNode>,\n //     taskgroups that forward_blk already ran on successfully (Note: bail_blk\n //     is NOT called on the block that forward_blk broke on!).\n // (3) As a bonus, coalesces away all 'dead' taskgroup nodes in the list.\n-// FIXME(#2190): Change Option<fn@(...)> to Option<fn&(...)>, to save on\n+// FIXME(#2190): Change Option<@fn(...)> to Option<&fn(...)>, to save on\n // allocations. Once that bug is fixed, changing the sigil should suffice.\n fn each_ancestor(list:        &mut AncestorList,\n-                     bail_opt:    Option<fn@(TaskGroupInner)>,\n-                     forward_blk: fn(TaskGroupInner) -> bool)\n-        -> bool {\n+                 bail_opt:    Option<@fn(TaskGroupInner)>,\n+                 forward_blk: fn(TaskGroupInner) -> bool)\n+              -> bool {\n     // \"Kickoff\" call - there was no last generation.\n     return !coalesce(list, bail_opt, forward_blk, uint::max_value);\n \n     // Recursively iterates, and coalesces afterwards if needed. Returns\n     // whether or not unwinding is needed (i.e., !successful iteration).\n     fn coalesce(list:            &mut AncestorList,\n-                bail_opt:        Option<fn@(TaskGroupInner)>,\n+                bail_opt:        Option<@fn(TaskGroupInner)>,\n                 forward_blk:     fn(TaskGroupInner) -> bool,\n                 last_generation: uint) -> bool {\n         // Need to swap the list out to use it, to appease borrowck.\n@@ -213,9 +213,10 @@ fn each_ancestor(list:        &mut AncestorList,\n     //     True if the supplied block did 'break', here or in any recursive\n     //     calls. If so, must call the unwinder on all previous nodes.\n     fn iterate(ancestors:       &AncestorList,\n-               bail_opt:        Option<fn@(TaskGroupInner)>,\n-               forward_blk:     fn(TaskGroupInner) -> bool,\n-               last_generation: uint) -> (Option<AncestorList>, bool) {\n+               bail_opt:        Option<@fn(TaskGroupInner)>,\n+               forward_blk:     &fn(TaskGroupInner) -> bool,\n+               last_generation: uint)\n+            -> (Option<AncestorList>, bool) {\n         // At each step of iteration, three booleans are at play which govern\n         // how the iteration should behave.\n         // 'nobe_is_dead' - Should the list should be coalesced at this point?\n@@ -532,7 +533,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n     }\n }\n \n-pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n+pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n     let (child_tg, ancestors, is_main) =\n         gen_child_taskgroup(opts.linked, opts.supervised);\n \n@@ -577,9 +578,10 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n     fn make_child_wrapper(child: *rust_task, child_arc: TaskGroupArc,\n                           ancestors: AncestorList, is_main: bool,\n                           notify_chan: Option<Chan<TaskResult>>,\n-                          f: fn~()) -> fn~() {\n+                          f: ~fn())\n+                       -> ~fn() {\n         let child_data = Cell((child_arc, ancestors));\n-        return fn~() {\n+        let result: ~fn() = || {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n             let mut (child_arc, ancestors) = child_data.take();\n             // Child task runs this code.\n@@ -613,6 +615,7 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n             // FIXME #4428: Crashy.\n             // unsafe { cleanup::annihilate(); }\n         };\n+        return result;\n \n         // Set up membership in taskgroup and descendantship in all ancestor\n         // groups. If any enlistment fails, Some task was already failing, so"}, {"sha": "c995d914a7a65136d2dbff0b59a974c8a3b84440", "filename": "src/libcore/unstable/finally.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/542119f61f376fa71bfc4b34fbb25be604279dc4/src%2Flibcore%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542119f61f376fa71bfc4b34fbb25be604279dc4/src%2Flibcore%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Ffinally.rs?ref=542119f61f376fa71bfc4b34fbb25be604279dc4", "patch": "@@ -79,9 +79,8 @@ fn test_fail() {\n \n #[test]\n fn test_retval() {\n-    let i = do (fn&() -> int {\n-        10\n-    }).finally { };\n+    let closure: &fn() -> int = || 10;\n+    let i = do closure.finally { };\n     assert i == 10;\n }\n "}, {"sha": "bff5e9750ec103cc973b371b9a968f405455f242", "filename": "src/libcore/unstable/weak_task.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/542119f61f376fa71bfc4b34fbb25be604279dc4/src%2Flibcore%2Funstable%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542119f61f376fa71bfc4b34fbb25be604279dc4/src%2Flibcore%2Funstable%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fweak_task.rs?ref=542119f61f376fa71bfc4b34fbb25be604279dc4", "patch": "@@ -43,9 +43,9 @@ pub unsafe fn weaken_task(f: &fn(Port<ShutdownMsg>)) {\n     // Expect the weak task service to be alive\n     assert service.try_send(RegisterWeakTask(task, shutdown_chan));\n     unsafe { rust_dec_kernel_live_count(); }\n-    do fn&() {\n+    do (|| {\n         f(shutdown_port.take())\n-    }.finally || {\n+    }).finally || {\n         unsafe { rust_inc_kernel_live_count(); }\n         // Service my have already exited\n         service.send(UnregisterWeakTask(task));\n@@ -74,13 +74,13 @@ fn create_global_service() -> ~WeakTaskService {\n     do task().unlinked().spawn {\n         debug!(\"running global weak task service\");\n         let port = Cell(port.take());\n-        do fn&() {\n+        do (|| {\n             let port = port.take();\n             // The weak task service is itself a weak task\n             debug!(\"weakening the weak service task\");\n             unsafe { rust_dec_kernel_live_count(); }\n             run_weak_task_service(port);\n-        }.finally {\n+        }).finally {\n             debug!(\"unweakening the weak service task\");\n             unsafe { rust_inc_kernel_live_count(); }\n         }"}]}