{"sha": "87e73c1f8288823e689ca254cdee9ab6c1723154", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ZTczYzFmODI4ODgyM2U2ODljYTI1NGNkZWU5YWI2YzE3MjMxNTQ=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-07-31T00:51:20Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-07-31T00:51:20Z"}, "message": "Remove redundant method with const variable resolution", "tree": {"sha": "500bfb251e6b9616995402a9893a57954f03b3e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/500bfb251e6b9616995402a9893a57954f03b3e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87e73c1f8288823e689ca254cdee9ab6c1723154", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87e73c1f8288823e689ca254cdee9ab6c1723154", "html_url": "https://github.com/rust-lang/rust/commit/87e73c1f8288823e689ca254cdee9ab6c1723154", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87e73c1f8288823e689ca254cdee9ab6c1723154/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04b88a9eba8abbac87eddcb2998beea09589c2c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/04b88a9eba8abbac87eddcb2998beea09589c2c9", "html_url": "https://github.com/rust-lang/rust/commit/04b88a9eba8abbac87eddcb2998beea09589c2c9"}], "stats": {"total": 41, "additions": 10, "deletions": 31}, "files": [{"sha": "db724875b8aa390b16aaf4b3fe7ef722a1818054", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87e73c1f8288823e689ca254cdee9ab6c1723154/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e73c1f8288823e689ca254cdee9ab6c1723154/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=87e73c1f8288823e689ca254cdee9ab6c1723154", "patch": "@@ -693,7 +693,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         const_var: &'tcx ty::Const<'tcx>\n     ) -> &'tcx ty::Const<'tcx> {\n         let infcx = self.infcx.expect(\"encountered const-var without infcx\");\n-        let bound_to = infcx.resolve_const_var(const_var);\n+        let bound_to = infcx.shallow_resolve(const_var);\n         if bound_to != const_var {\n             self.fold_const(bound_to)\n         } else {"}, {"sha": "e1d77a97c116068fd0c26828d486c03e40b47dc9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/87e73c1f8288823e689ca254cdee9ab6c1723154/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e73c1f8288823e689ca254cdee9ab6c1723154/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=87e73c1f8288823e689ca254cdee9ab6c1723154", "patch": "@@ -1351,23 +1351,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_const_var(\n-        &self,\n-        ct: &'tcx ty::Const<'tcx>\n-    ) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const { val: ConstValue::Infer(InferConst::Var(v)), .. } = ct {\n-            self.const_unification_table\n-                .borrow_mut()\n-                .probe_value(*v)\n-                .val\n-                .known()\n-                .map(|c| self.resolve_const_var(c))\n-                .unwrap_or(ct)\n-        } else {\n-            ct\n-        }\n-    }\n-\n     pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<'tcx, T> {\n         /*!\n          * Attempts to resolve all type/region/const variables in\n@@ -1586,7 +1569,7 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n                 // it can be resolved to an int/float variable, which\n                 // can then be recursively resolved, hence the\n                 // recursion. Note though that we prevent type\n-                // variables from unifyxing to other type variables\n+                // variables from unifying to other type variables\n                 // directly (though they may be embedded\n                 // structurally), and we prevent cycles in any case,\n                 // so this recursion should always be of very limited\n@@ -1626,17 +1609,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        match ct {\n-            ty::Const { val: ConstValue::Infer(InferConst::Var(vid)), .. } => {\n+        if let ty::Const { val: ConstValue::Infer(InferConst::Var(vid)), .. } = ct {\n                 self.infcx.const_unification_table\n                     .borrow_mut()\n                     .probe_value(*vid)\n                     .val\n                     .known()\n-                    .map(|c| self.fold_const(c))\n                     .unwrap_or(ct)\n-            }\n-            _ => ct,\n+        } else {\n+            ct\n         }\n     }\n }"}, {"sha": "ca54f63b83afe0c2acc30e6f38162a9cbf7dedb8", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/87e73c1f8288823e689ca254cdee9ab6c1723154/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e73c1f8288823e689ca254cdee9ab6c1723154/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=87e73c1f8288823e689ca254cdee9ab6c1723154", "patch": "@@ -594,13 +594,11 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n                 ty: a.ty,\n             }))\n         }\n-        (ConstValue::ByRef { .. }, _) => {\n-            bug!(\n-                \"non-Scalar ConstValue encountered in super_relate_consts {:?} {:?}\",\n-                a,\n-                b,\n-            );\n-        }\n+\n+        // FIXME(const_generics): we should either handle `Scalar::Ptr` or add a comment\n+        // saying that we're not handling it intentionally.\n+\n+        // FIXME(const_generics): handle `ConstValue::ByRef` and `ConstValue::Slice`.\n \n         // FIXME(const_generics): this is wrong, as it is a projection\n         (ConstValue::Unevaluated(a_def_id, a_substs),"}]}