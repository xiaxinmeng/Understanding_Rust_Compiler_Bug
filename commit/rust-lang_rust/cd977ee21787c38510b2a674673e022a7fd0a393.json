{"sha": "cd977ee21787c38510b2a674673e022a7fd0a393", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkOTc3ZWUyMTc4N2MzODUxMGIyYTY3NDY3M2UwMjJhN2ZkMGEzOTM=", "commit": {"author": {"name": "Edward Wang", "email": "edward.yu.wang@gmail.com", "date": "2015-01-31T14:19:13Z"}, "committer": {"name": "Edward Wang", "email": "edward.yu.wang@gmail.com", "date": "2015-02-01T06:08:14Z"}, "message": "Make sure type inference with `a..b` as good as `range(a,b)`\n\nThe new `::ops::Range` has separated implementations for each of the\nnumeric types, while the old `::iter::Range` has one for type `Int`.\nHowever, we do not take output bindings into account when selecting\ntraits. So it confuses `typeck` and makes the new range does not work as\ngood as the old one when it comes to type inference.\n\nThis patch implements `Iterator` for the new range for one type `Int`.\nThis limitation could be lifted, however, if we ever reconsider the\noutput types' role in type inference.\n\nCloses #21595\nCloses #21649\nCloses #21672", "tree": {"sha": "aa7e5f689584a74ad7b8b869ad3ac89bb40e4204", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa7e5f689584a74ad7b8b869ad3ac89bb40e4204"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd977ee21787c38510b2a674673e022a7fd0a393", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd977ee21787c38510b2a674673e022a7fd0a393", "html_url": "https://github.com/rust-lang/rust/commit/cd977ee21787c38510b2a674673e022a7fd0a393", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd977ee21787c38510b2a674673e022a7fd0a393/comments", "author": {"login": "edwardw", "id": 454049, "node_id": "MDQ6VXNlcjQ1NDA0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/454049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwardw", "html_url": "https://github.com/edwardw", "followers_url": "https://api.github.com/users/edwardw/followers", "following_url": "https://api.github.com/users/edwardw/following{/other_user}", "gists_url": "https://api.github.com/users/edwardw/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwardw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwardw/subscriptions", "organizations_url": "https://api.github.com/users/edwardw/orgs", "repos_url": "https://api.github.com/users/edwardw/repos", "events_url": "https://api.github.com/users/edwardw/events{/privacy}", "received_events_url": "https://api.github.com/users/edwardw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwardw", "id": 454049, "node_id": "MDQ6VXNlcjQ1NDA0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/454049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwardw", "html_url": "https://github.com/edwardw", "followers_url": "https://api.github.com/users/edwardw/followers", "following_url": "https://api.github.com/users/edwardw/following{/other_user}", "gists_url": "https://api.github.com/users/edwardw/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwardw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwardw/subscriptions", "organizations_url": "https://api.github.com/users/edwardw/orgs", "repos_url": "https://api.github.com/users/edwardw/repos", "events_url": "https://api.github.com/users/edwardw/events{/privacy}", "received_events_url": "https://api.github.com/users/edwardw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "474b324eda10440d6568ef872a7307d38e7de95b", "url": "https://api.github.com/repos/rust-lang/rust/commits/474b324eda10440d6568ef872a7307d38e7de95b", "html_url": "https://github.com/rust-lang/rust/commit/474b324eda10440d6568ef872a7307d38e7de95b"}], "stats": {"total": 144, "additions": 75, "deletions": 69}, "files": [{"sha": "0a9dc23f18d1aa57cdf2f9d4d11852d1705a75be", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 47, "deletions": 69, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/cd977ee21787c38510b2a674673e022a7fd0a393/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd977ee21787c38510b2a674673e022a7fd0a393/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=cd977ee21787c38510b2a674673e022a7fd0a393", "patch": "@@ -2796,93 +2796,71 @@ impl<A: Int> Iterator for RangeStepInclusive<A> {\n     }\n }\n \n-macro_rules! range_impl {\n+macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Iterator for ::ops::Range<$t> {\n-            type Item = $t;\n-\n+        impl ExactSizeIterator for ::ops::Range<$t> {\n             #[inline]\n-            fn next(&mut self) -> Option<$t> {\n-                if self.start < self.end {\n-                    let result = self.start;\n-                    self.start += 1;\n-                    return Some(result);\n-                }\n-\n-                return None;\n-            }\n-\n-            #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n+            fn len(&self) -> usize {\n                 debug_assert!(self.end >= self.start);\n-                let hint = (self.end - self.start) as usize;\n-                (hint, Some(hint))\n+                (self.end - self.start) as usize\n             }\n         }\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl ExactSizeIterator for ::ops::Range<$t> {}\n     )*)\n }\n \n-macro_rules! range_impl_no_hint {\n-    ($($t:ty)*) => ($(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Iterator for ::ops::Range<$t> {\n-            type Item = $t;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<$t> {\n-                if self.start < self.end {\n-                    let result = self.start;\n-                    self.start += 1;\n-                    return Some(result);\n-                }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Int> Iterator for ::ops::Range<A> {\n+    type Item = A;\n \n-                return None;\n-            }\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        if self.start < self.end {\n+            let result = self.start;\n+            self.start = self.start + Int::one();\n+            Some(result)\n+        } else {\n+            None\n         }\n-    )*)\n-}\n-\n-macro_rules! range_other_impls {\n-    ($($t:ty)*) => ($(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl DoubleEndedIterator for ::ops::Range<$t> {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$t> {\n-                if self.start < self.end {\n-                    self.end -= 1;\n-                    return Some(self.end);\n-                }\n+    }\n \n-                return None;\n-            }\n-        }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        debug_assert!(self.end >= self.start);\n+        let hint = (self.end - self.start).to_uint();\n+        (hint.unwrap_or(0), hint)\n+    }\n+}\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Iterator for ::ops::RangeFrom<$t> {\n-            type Item = $t;\n+range_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\n+#[cfg(target_pointer_width = \"64\")]\n+range_exact_iter_impl!(u64 i64);\n \n-            #[inline]\n-            fn next(&mut self) -> Option<$t> {\n-                let result = self.start;\n-                self.start += 1;\n-                debug_assert!(result < self.start);\n-                return Some(result);\n-            }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Int> DoubleEndedIterator for ::ops::Range<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        if self.start < self.end {\n+            self.end = self.end - Int::one();\n+            Some(self.end)\n+        } else {\n+            None\n         }\n-    )*)\n+    }\n }\n \n-range_impl!(usize u8 u16 u32 isize i8 i16 i32);\n-#[cfg(target_pointer_width = \"64\")]\n-range_impl!(u64 i64);\n-#[cfg(target_pointer_width = \"32\")]\n-range_impl_no_hint!(u64 i64);\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Int> Iterator for ::ops::RangeFrom<A> {\n+    type Item = A;\n \n-range_other_impls!(usize u8 u16 u32 u64 isize i8 i16 i32 i64);\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        let result = self.start;\n+        self.start = self.start + Int::one();\n+        debug_assert!(result < self.start);\n+        Some(result)\n+    }\n+}\n \n /// An iterator that repeats an element endlessly\n #[derive(Clone)]"}, {"sha": "51945a4677d916c41a81dd48cc90b77717fc659f", "filename": "src/test/run-pass/range-type-infer.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd977ee21787c38510b2a674673e022a7fd0a393/src%2Ftest%2Frun-pass%2Frange-type-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd977ee21787c38510b2a674673e022a7fd0a393/src%2Ftest%2Frun-pass%2Frange-type-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange-type-infer.rs?ref=cd977ee21787c38510b2a674673e022a7fd0a393", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure the type inference for the new range expression work as\n+// good as the old one. Check out issue #21672, #21595 and #21649 for\n+// more details.\n+\n+fn main() {\n+    let xs = (0..8).map(|i| i == 1u64).collect::<Vec<_>>();\n+    assert_eq!(xs[1], true);\n+    let xs = (0..8).map(|i| 1u64 == i).collect::<Vec<_>>();\n+    assert_eq!(xs[1], true);\n+    let xs: Vec<u8> = (0..10).collect();\n+    assert_eq!(xs.len(), 10);\n+\n+    for x in 0..10 { x % 2; }\n+    for x in 0..100 { x as f32; }\n+\n+    let array = [true, false];\n+    for i in 0..1 { array[i]; }\n+}"}]}