{"sha": "0f6144a115b2535feb8a84914105a2896e7e8e92", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNjE0NGExMTViMjUzNWZlYjhhODQ5MTQxMDVhMjg5NmU3ZThlOTI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-03-27T00:23:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-27T00:23:47Z"}, "message": "Rollup merge of #69644 - ecstatic-morse:unified-dataflow-cleanup, r=eddyb\n\nRemove framework in `dataflow/mod.rs` in favor of \"generic\" one\n\nThis is the culmination of the work described in rust-lang/compiler-team#202. All dataflow analyses (including the one in `clippy`) have been ported to use the framework in `dataflow/generic`, which can efficiently handle both gen/kill and generic problems. This PR moves the framework in `dataflow/generic` to `dataflow/framework`, and removes the gen/kill framework in `dataflow/mod.rs`.\n\nMore comprehensive documentation for the new framework is tracked in rust-lang/rustc-guide#564.\n\n`clippy` will need to change the path it uses to import the dataflow analysis traits.", "tree": {"sha": "749503dc9233a7d26dc5b9fb2bb7ba5710cffd87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/749503dc9233a7d26dc5b9fb2bb7ba5710cffd87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f6144a115b2535feb8a84914105a2896e7e8e92", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJefUeTCRBK7hj4Ov3rIwAAdHIIAB3nEddUYpAlZH87sOYNLi4s\n/In2DKD0U3t/XtTrMhPZZDjKdnvRlMY9tKy8RiHAwzm+/rDOWCrpbPAaiIFF4ReQ\nNxoHxQd63D8sSz4KmTNi/sOVtsDGPq8czY05rgxQ/U5QqLXJTTptijXrhsGP5AoH\nHcbpc42UlDE4pWMzT6e7+rO6HOkjZZA7C+aIXtocXe9gmcDwlSCuy01gllZQCdB6\nlxrqB+yE/zWy/IXbHkQ66rhLxAih2zhTbO01wwzyfWEi/t5p9/05LB9QqVSATUJl\n4ZDFYerckRlr+n/S6Zp/8nCfUT86GIUtQDWbVnrQRkpqE2Ch/79ja91blxmd+Xs=\n=+zAm\n-----END PGP SIGNATURE-----\n", "payload": "tree 749503dc9233a7d26dc5b9fb2bb7ba5710cffd87\nparent 62c6006450d8bd33a351673c1f969846d768aab4\nparent 89d6009461918a5939520fe5424ee499ed6d504d\nauthor Dylan DPC <dylan.dpc@gmail.com> 1585268627 +0100\ncommitter GitHub <noreply@github.com> 1585268627 +0100\n\nRollup merge of #69644 - ecstatic-morse:unified-dataflow-cleanup, r=eddyb\n\nRemove framework in `dataflow/mod.rs` in favor of \"generic\" one\n\nThis is the culmination of the work described in rust-lang/compiler-team#202. All dataflow analyses (including the one in `clippy`) have been ported to use the framework in `dataflow/generic`, which can efficiently handle both gen/kill and generic problems. This PR moves the framework in `dataflow/generic` to `dataflow/framework`, and removes the gen/kill framework in `dataflow/mod.rs`.\n\nMore comprehensive documentation for the new framework is tracked in rust-lang/rustc-guide#564.\n\n`clippy` will need to change the path it uses to import the dataflow analysis traits.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f6144a115b2535feb8a84914105a2896e7e8e92", "html_url": "https://github.com/rust-lang/rust/commit/0f6144a115b2535feb8a84914105a2896e7e8e92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f6144a115b2535feb8a84914105a2896e7e8e92/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62c6006450d8bd33a351673c1f969846d768aab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/62c6006450d8bd33a351673c1f969846d768aab4", "html_url": "https://github.com/rust-lang/rust/commit/62c6006450d8bd33a351673c1f969846d768aab4"}, {"sha": "89d6009461918a5939520fe5424ee499ed6d504d", "url": "https://api.github.com/repos/rust-lang/rust/commits/89d6009461918a5939520fe5424ee499ed6d504d", "html_url": "https://github.com/rust-lang/rust/commit/89d6009461918a5939520fe5424ee499ed6d504d"}], "stats": {"total": 1197, "additions": 89, "deletions": 1108}, "files": [{"sha": "882c6bd0333eeaffc6f4cac9c7dd8279c90db799", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "patch": "@@ -29,12 +29,12 @@ use std::mem;\n use std::rc::Rc;\n \n use crate::dataflow;\n-use crate::dataflow::generic::{Analysis, BorrowckFlowState as Flows, BorrowckResults};\n use crate::dataflow::indexes::{BorrowIndex, InitIndex, MoveOutIndex, MovePathIndex};\n use crate::dataflow::move_paths::{InitLocation, LookupResult, MoveData, MoveError};\n use crate::dataflow::Borrows;\n use crate::dataflow::EverInitializedPlaces;\n use crate::dataflow::MoveDataParamEnv;\n+use crate::dataflow::{Analysis, BorrowckFlowState as Flows, BorrowckResults};\n use crate::dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use crate::transform::MirSource;\n \n@@ -298,7 +298,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         mbcx.report_move_errors(errors);\n     }\n \n-    dataflow::generic::visit_results(\n+    dataflow::visit_results(\n         &*body,\n         traversal::reverse_postorder(&*body).map(|(bb, _)| bb),\n         &results,\n@@ -509,7 +509,7 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n // 2. loans made in overlapping scopes do not conflict\n // 3. assignments do not affect things loaned out as immutable\n // 4. moves do not affect things loaned out in any way\n-impl<'cx, 'tcx> dataflow::generic::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx> {\n+impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx> {\n     type FlowState = Flows<'cx, 'tcx>;\n \n     fn visit_statement("}, {"sha": "8e929a4fa22f48ee640d73dee11f434985525069", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "patch": "@@ -21,9 +21,9 @@ use std::str::FromStr;\n use self::mir_util::PassWhere;\n use polonius_engine::{Algorithm, Output};\n \n-use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::move_paths::{InitKind, InitLocation, MoveData};\n use crate::dataflow::MaybeInitializedPlaces;\n+use crate::dataflow::ResultsCursor;\n use crate::transform::MirSource;\n use crate::util as mir_util;\n use crate::util::pretty;"}, {"sha": "a55529ed0ef12efd2c1adc93d76c40013a480f83", "filename": "src/librustc_mir/borrow_check/type_check/liveness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "patch": "@@ -3,9 +3,9 @@ use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use std::rc::Rc;\n \n-use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::MaybeInitializedPlaces;\n+use crate::dataflow::ResultsCursor;\n \n use crate::borrow_check::{\n     constraints::OutlivesConstraintSet,"}, {"sha": "75b269c79b96e59e16b45957cd4cb9348f3ff06e", "filename": "src/librustc_mir/borrow_check/type_check/liveness/trace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "patch": "@@ -8,10 +8,10 @@ use rustc_trait_selection::traits::query::type_op::outlives::DropckOutlives;\n use rustc_trait_selection::traits::query::type_op::TypeOp;\n use std::rc::Rc;\n \n-use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::indexes::MovePathIndex;\n use crate::dataflow::move_paths::{HasMoveData, MoveData};\n use crate::dataflow::MaybeInitializedPlaces;\n+use crate::dataflow::ResultsCursor;\n \n use crate::borrow_check::{\n     region_infer::values::{self, PointIndex, RegionValueElements},"}, {"sha": "02f6bcade23a2cdc1200caaa039571b6e0af23f5", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "patch": "@@ -39,9 +39,9 @@ use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligations};\n \n-use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::MaybeInitializedPlaces;\n+use crate::dataflow::ResultsCursor;\n use crate::transform::promote_consts::should_suggest_const_in_array_repeat_expressions_attribute;\n \n use crate::borrow_check::{"}, {"sha": "e4eb8506846c0b60b571ef0fc9603e780f2a2277", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -1,169 +0,0 @@\n-//! A nice wrapper to consume dataflow results at several CFG\n-//! locations.\n-\n-use rustc::mir::{BasicBlock, Location};\n-use rustc_index::bit_set::{BitIter, BitSet, HybridBitSet};\n-\n-use crate::dataflow::{BitDenotation, DataflowResults, GenKillSet};\n-\n-use std::borrow::Borrow;\n-use std::iter;\n-\n-/// A trait for \"cartesian products\" of multiple FlowAtLocation.\n-///\n-/// There's probably a way to auto-impl this, but I think\n-/// it is cleaner to have manual visitor impls.\n-pub trait FlowsAtLocation {\n-    /// Reset the state bitvector to represent the entry to block `bb`.\n-    fn reset_to_entry_of(&mut self, bb: BasicBlock);\n-\n-    /// Reset the state bitvector to represent the exit of the\n-    /// terminator of block `bb`.\n-    ///\n-    /// **Important:** In the case of a `Call` terminator, these\n-    /// effects do *not* include the result of storing the destination\n-    /// of the call, since that is edge-dependent (in other words, the\n-    /// effects don't apply to the unwind edge).\n-    fn reset_to_exit_of(&mut self, bb: BasicBlock);\n-\n-    /// Builds gen and kill sets for statement at `loc`.\n-    ///\n-    /// Note that invoking this method alone does not change the\n-    /// `curr_state` -- you must invoke `apply_local_effect`\n-    /// afterwards.\n-    fn reconstruct_statement_effect(&mut self, loc: Location);\n-\n-    /// Builds gen and kill sets for terminator for `loc`.\n-    ///\n-    /// Note that invoking this method alone does not change the\n-    /// `curr_state` -- you must invoke `apply_local_effect`\n-    /// afterwards.\n-    fn reconstruct_terminator_effect(&mut self, loc: Location);\n-\n-    /// Apply current gen + kill sets to `flow_state`.\n-    ///\n-    /// (`loc` parameters can be ignored if desired by\n-    /// client. For the terminator, the `stmt_idx` will be the number\n-    /// of statements in the block.)\n-    fn apply_local_effect(&mut self, loc: Location);\n-}\n-\n-/// Represents the state of dataflow at a particular\n-/// CFG location, both before and after it is\n-/// executed.\n-///\n-/// Data flow results are typically computed only as basic block\n-/// boundaries. A `FlowInProgress` allows you to reconstruct the\n-/// effects at any point in the control-flow graph by starting with\n-/// the state at the start of the basic block (`reset_to_entry_of`)\n-/// and then replaying the effects of statements and terminators\n-/// (e.g., via `reconstruct_statement_effect` and\n-/// `reconstruct_terminator_effect`; don't forget to call\n-/// `apply_local_effect`).\n-pub struct FlowAtLocation<'tcx, BD, DR = DataflowResults<'tcx, BD>>\n-where\n-    BD: BitDenotation<'tcx>,\n-    DR: Borrow<DataflowResults<'tcx, BD>>,\n-{\n-    base_results: DR,\n-    curr_state: BitSet<BD::Idx>,\n-    stmt_trans: GenKillSet<BD::Idx>,\n-}\n-\n-impl<'tcx, BD, DR> FlowAtLocation<'tcx, BD, DR>\n-where\n-    BD: BitDenotation<'tcx>,\n-    DR: Borrow<DataflowResults<'tcx, BD>>,\n-{\n-    /// Iterate over each bit set in the current state.\n-    pub fn each_state_bit<F>(&self, f: F)\n-    where\n-        F: FnMut(BD::Idx),\n-    {\n-        self.curr_state.iter().for_each(f)\n-    }\n-\n-    /// Iterate over each `gen` bit in the current effect (invoke\n-    /// `reconstruct_statement_effect` or\n-    /// `reconstruct_terminator_effect` first).\n-    pub fn each_gen_bit<F>(&self, f: F)\n-    where\n-        F: FnMut(BD::Idx),\n-    {\n-        self.stmt_trans.gen_set.iter().for_each(f)\n-    }\n-\n-    pub fn new(results: DR) -> Self {\n-        let bits_per_block = results.borrow().sets().bits_per_block();\n-        let curr_state = BitSet::new_empty(bits_per_block);\n-        let stmt_trans = GenKillSet::from_elem(HybridBitSet::new_empty(bits_per_block));\n-        FlowAtLocation { base_results: results, curr_state, stmt_trans }\n-    }\n-\n-    /// Access the underlying operator.\n-    pub fn operator(&self) -> &BD {\n-        self.base_results.borrow().operator()\n-    }\n-\n-    pub fn contains(&self, x: BD::Idx) -> bool {\n-        self.curr_state.contains(x)\n-    }\n-\n-    /// Returns an iterator over the elements present in the current state.\n-    pub fn iter_incoming(&self) -> iter::Peekable<BitIter<'_, BD::Idx>> {\n-        self.curr_state.iter().peekable()\n-    }\n-\n-    /// Creates a clone of the current state and applies the local\n-    /// effects to the clone (leaving the state of self intact).\n-    /// Invokes `f` with an iterator over the resulting state.\n-    pub fn with_iter_outgoing<F>(&self, f: F)\n-    where\n-        F: FnOnce(BitIter<'_, BD::Idx>),\n-    {\n-        let mut curr_state = self.curr_state.clone();\n-        self.stmt_trans.apply(&mut curr_state);\n-        f(curr_state.iter());\n-    }\n-\n-    /// Returns a bitset of the elements present in the current state.\n-    pub fn as_dense(&self) -> &BitSet<BD::Idx> {\n-        &self.curr_state\n-    }\n-}\n-\n-impl<'tcx, BD, DR> FlowsAtLocation for FlowAtLocation<'tcx, BD, DR>\n-where\n-    BD: BitDenotation<'tcx>,\n-    DR: Borrow<DataflowResults<'tcx, BD>>,\n-{\n-    fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n-        self.curr_state.overwrite(self.base_results.borrow().sets().entry_set_for(bb.index()));\n-    }\n-\n-    fn reset_to_exit_of(&mut self, bb: BasicBlock) {\n-        self.reset_to_entry_of(bb);\n-        let trans = self.base_results.borrow().sets().trans_for(bb.index());\n-        trans.apply(&mut self.curr_state)\n-    }\n-\n-    fn reconstruct_statement_effect(&mut self, loc: Location) {\n-        self.stmt_trans.clear();\n-        self.base_results.borrow().operator().before_statement_effect(&mut self.stmt_trans, loc);\n-        self.stmt_trans.apply(&mut self.curr_state);\n-\n-        self.base_results.borrow().operator().statement_effect(&mut self.stmt_trans, loc);\n-    }\n-\n-    fn reconstruct_terminator_effect(&mut self, loc: Location) {\n-        self.stmt_trans.clear();\n-        self.base_results.borrow().operator().before_terminator_effect(&mut self.stmt_trans, loc);\n-        self.stmt_trans.apply(&mut self.curr_state);\n-\n-        self.base_results.borrow().operator().terminator_effect(&mut self.stmt_trans, loc);\n-    }\n-\n-    fn apply_local_effect(&mut self, _loc: Location) {\n-        self.stmt_trans.apply(&mut self.curr_state)\n-    }\n-}"}, {"sha": "170157aca5ddd678391efc9083286821b27898d8", "filename": "src/librustc_mir/dataflow/framework/cursor.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "previous_filename": "src/librustc_mir/dataflow/generic/cursor.rs"}, {"sha": "d32072125b3b9fcd101dfbc5bea2de536a0382e3", "filename": "src/librustc_mir/dataflow/framework/engine.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "previous_filename": "src/librustc_mir/dataflow/generic/engine.rs"}, {"sha": "c15f2a726ee705e5d2f4c570be1a4615ae3691ca", "filename": "src/librustc_mir/dataflow/framework/graphviz.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fgraphviz.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "previous_filename": "src/librustc_mir/dataflow/generic/graphviz.rs"}, {"sha": "8556be7e740623ab05e6297ce684ad4116f0ab57", "filename": "src/librustc_mir/dataflow/framework/mod.rs", "status": "renamed", "additions": 56, "deletions": 19, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "patch": "@@ -1,26 +1,25 @@\n //! A framework that can express both [gen-kill] and generic dataflow problems.\n //!\n-//! There is another interface for dataflow in the compiler in `librustc_mir/dataflow/mod.rs`. The\n-//! interface in this module will eventually [replace that one][design-meeting].\n+//! To actually use this framework, you must implement either the `Analysis` or the\n+//! `GenKillAnalysis` trait. If your transfer function can be expressed with only gen/kill\n+//! operations, prefer `GenKillAnalysis` since it will run faster while iterating to fixpoint. The\n+//! `impls` module contains several examples of gen/kill dataflow analyses.\n //!\n-//! To actually use this framework, you must implement either the `Analysis` or the `GenKillAnalysis`\n-//! trait. If your transfer function can be expressed with only gen/kill operations, prefer\n-//! `GenKillAnalysis` since it will run faster while iterating to fixpoint. Create an `Engine` using\n-//! the appropriate constructor and call `iterate_to_fixpoint`. You can use a `ResultsCursor` to\n-//! inspect the fixpoint solution to your dataflow problem.\n+//! Create an `Engine` for your analysis using the `into_engine` method on the `Analysis` trait,\n+//! then call `iterate_to_fixpoint`. From there, you can use a `ResultsCursor` to inspect the\n+//! fixpoint solution to your dataflow problem, or implement the `ResultsVisitor` interface and use\n+//! `visit_results`. The following example uses the `ResultsCursor` approach.\n //!\n //! ```ignore(cross-crate-imports)\n-//! fn do_my_analysis(tcx: TyCtxt<'tcx>, body: &mir::Body<'tcx>, did: DefId) {\n-//!     let analysis = MyAnalysis::new();\n-//!\n-//!     // If `MyAnalysis` implements `GenKillAnalysis`.\n-//!     let results = Engine::new_gen_kill(tcx, body, did, analysis).iterate_to_fixpoint();\n+//! use rustc_mir::dataflow::Analysis; // Makes `into_engine` available.\n //!\n-//!     // If `MyAnalysis` implements `Analysis`.\n-//!     // let results = Engine::new_generic(tcx, body, did, analysis).iterate_to_fixpoint();\n-//!\n-//!     let mut cursor = ResultsCursor::new(body, results);\n+//! fn do_my_analysis(tcx: TyCtxt<'tcx>, body: &mir::Body<'tcx>, did: DefId) {\n+//!     let analysis = MyAnalysis::new()\n+//!         .into_engine(tcx, body, did)\n+//!         .iterate_to_fixpoint()\n+//!         .into_results_cursor(body);\n //!\n+//!     // Print the dataflow state *after* each statement in the start block.\n //!     for (_, statement_index) in body.block_data[START_BLOCK].statements.iter_enumerated() {\n //!         cursor.seek_after(Location { block: START_BLOCK, statement_index });\n //!         let state = cursor.get();\n@@ -30,7 +29,6 @@\n //! ```\n //!\n //! [gen-kill]: https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems\n-//! [design-meeting]https://github.com/rust-lang/compiler-team/issues/202\n \n use std::io;\n \n@@ -41,8 +39,6 @@ use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::{BitSet, HybridBitSet};\n use rustc_index::vec::{Idx, IndexVec};\n \n-use crate::dataflow::BottomValue;\n-\n mod cursor;\n mod engine;\n mod graphviz;\n@@ -95,6 +91,47 @@ where\n     }\n }\n \n+/// Parameterization for the precise form of data flow that is used.\n+///\n+/// `BottomValue` determines whether the initial entry set for each basic block is empty or full.\n+/// This also determines the semantics of the lattice `join` operator used to merge dataflow\n+/// results, since dataflow works by starting at the bottom and moving monotonically to a fixed\n+/// point.\n+///\n+/// This means, for propagation across the graph, that you either want to start at all-zeroes and\n+/// then use Union as your merge when propagating, or you start at all-ones and then use Intersect\n+/// as your merge when propagating.\n+pub trait BottomValue {\n+    /// Specifies the initial value for each bit in the entry set for each basic block.\n+    const BOTTOM_VALUE: bool;\n+\n+    /// Merges `in_set` into `inout_set`, returning `true` if `inout_set` changed.\n+    ///\n+    /// It is almost certainly wrong to override this, since it automatically applies\n+    /// * `inout_set & in_set` if `BOTTOM_VALUE == true`\n+    /// * `inout_set | in_set` if `BOTTOM_VALUE == false`\n+    ///\n+    /// This means that if a bit is not `BOTTOM_VALUE`, it is propagated into all target blocks.\n+    /// For clarity, the above statement again from a different perspective:\n+    /// A bit in the block's entry set is `!BOTTOM_VALUE` if *any* predecessor block's bit value is\n+    /// `!BOTTOM_VALUE`.\n+    ///\n+    /// There are situations where you want the opposite behaviour: propagate only if *all*\n+    /// predecessor blocks's value is `!BOTTOM_VALUE`.\n+    /// E.g. if you want to know whether a bit is *definitely* set at a specific location. This\n+    /// means that all code paths leading to the location must have set the bit, instead of any\n+    /// code path leading there.\n+    ///\n+    /// If you want this kind of \"definitely set\" analysis, you need to\n+    /// 1. Invert `BOTTOM_VALUE`\n+    /// 2. Reset the `entry_set` in `start_block_effect` to `!BOTTOM_VALUE`\n+    /// 3. Override `join` to do the opposite from what it's doing now.\n+    #[inline]\n+    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n+        if !Self::BOTTOM_VALUE { inout_set.union(in_set) } else { inout_set.intersect(in_set) }\n+    }\n+}\n+\n /// Define the domain of a dataflow problem.\n ///\n /// This trait specifies the lattice on which this analysis operates. For now, this must be a", "previous_filename": "src/librustc_mir/dataflow/generic/mod.rs"}, {"sha": "8f07a10e1b01ce11734a44859e60faceea5fe0be", "filename": "src/librustc_mir/dataflow/framework/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "previous_filename": "src/librustc_mir/dataflow/generic/tests.rs"}, {"sha": "6e1513bcd1dd0beb042e6d673cb0f0e9c49c9a12", "filename": "src/librustc_mir/dataflow/framework/visitor.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "previous_filename": "src/librustc_mir/dataflow/generic/visitor.rs"}, {"sha": "955021d83aa098a69ba4e50cbde0f58219546286", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "patch": "@@ -1,6 +1,6 @@\n pub use super::*;\n \n-use crate::dataflow::generic::{AnalysisDomain, GenKill, GenKillAnalysis};\n+use crate::dataflow::{AnalysisDomain, GenKill, GenKillAnalysis};\n use rustc::mir::visit::Visitor;\n use rustc::mir::*;\n use rustc::ty::{ParamEnv, TyCtxt};"}, {"sha": "9e9e414ad648bf4445c815de5ef5c2f6177b7fd9", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "patch": "@@ -8,8 +8,8 @@ use rustc_index::bit_set::BitSet;\n use crate::borrow_check::{\n     places_conflict, BorrowSet, PlaceConflictBias, PlaceExt, RegionInferenceContext, ToRegionVid,\n };\n-use crate::dataflow::generic::{self, GenKill};\n use crate::dataflow::BottomValue;\n+use crate::dataflow::{self, GenKill};\n \n use std::rc::Rc;\n \n@@ -226,7 +226,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     }\n }\n \n-impl<'tcx> generic::AnalysisDomain<'tcx> for Borrows<'_, 'tcx> {\n+impl<'tcx> dataflow::AnalysisDomain<'tcx> for Borrows<'_, 'tcx> {\n     type Idx = BorrowIndex;\n \n     const NAME: &'static str = \"borrows\";\n@@ -245,7 +245,7 @@ impl<'tcx> generic::AnalysisDomain<'tcx> for Borrows<'_, 'tcx> {\n     }\n }\n \n-impl<'tcx> generic::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n+impl<'tcx> dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n     fn before_statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,"}, {"sha": "180094e412b15ce665d905c802aea283a3b7b00f", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "patch": "@@ -12,9 +12,8 @@ use super::MoveDataParamEnv;\n \n use crate::util::elaborate_drops::DropFlagState;\n \n-use super::generic::{AnalysisDomain, GenKill, GenKillAnalysis};\n use super::move_paths::{HasMoveData, InitIndex, InitKind, LookupResult, MoveData, MovePathIndex};\n-use super::BottomValue;\n+use super::{AnalysisDomain, BottomValue, GenKill, GenKillAnalysis};\n \n use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;"}, {"sha": "f8d1efabd33c055197790e198f4f9532ed309ed2", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "patch": "@@ -1,7 +1,7 @@\n pub use super::*;\n \n-use crate::dataflow::generic::{self as dataflow, GenKill, Results, ResultsRefCursor};\n use crate::dataflow::BottomValue;\n+use crate::dataflow::{self, GenKill, Results, ResultsRefCursor};\n use rustc::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc::mir::*;\n use std::cell::RefCell;"}, {"sha": "96e5b6936a191e7523f6d5a609196309fd5736cc", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 14, "deletions": 900, "changes": 914, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "patch": "@@ -1,35 +1,22 @@\n-use rustc::mir::traversal;\n-use rustc::mir::{self, BasicBlock, BasicBlockData, Body, Location, Statement, Terminator};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty;\n use rustc_ast::ast::{self, MetaItem};\n-use rustc_ast_pretty::pprust;\n-use rustc_data_structures::work_queue::WorkQueue;\n-use rustc_hir::def_id::DefId;\n-use rustc_index::bit_set::{BitSet, HybridBitSet};\n-use rustc_index::vec::Idx;\n-use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n \n-use std::borrow::Borrow;\n-use std::fmt;\n-use std::io;\n-use std::path::PathBuf;\n-\n-pub use self::at_location::{FlowAtLocation, FlowsAtLocation};\n pub(crate) use self::drop_flag_effects::*;\n-pub use self::impls::borrows::Borrows;\n-pub use self::impls::DefinitelyInitializedPlaces;\n-pub use self::impls::EverInitializedPlaces;\n-pub use self::impls::{MaybeBorrowedLocals, MaybeMutBorrowedLocals};\n-pub use self::impls::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n-pub use self::impls::{MaybeRequiresStorage, MaybeStorageLive};\n+pub use self::framework::{\n+    visit_results, Analysis, AnalysisDomain, BorrowckFlowState, BorrowckResults, BottomValue,\n+    Engine, GenKill, GenKillAnalysis, Results, ResultsCursor, ResultsRefCursor, ResultsVisitor,\n+};\n+pub use self::impls::{\n+    borrows::Borrows, DefinitelyInitializedPlaces, EverInitializedPlaces, MaybeBorrowedLocals,\n+    MaybeInitializedPlaces, MaybeMutBorrowedLocals, MaybeRequiresStorage, MaybeStorageLive,\n+    MaybeUninitializedPlaces,\n+};\n \n use self::move_paths::MoveData;\n \n-mod at_location;\n pub mod drop_flag_effects;\n-pub mod generic;\n-mod graphviz;\n+mod framework;\n mod impls;\n pub mod move_paths;\n \n@@ -40,74 +27,9 @@ pub(crate) mod indexes {\n     };\n }\n \n-pub(crate) struct DataflowBuilder<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    def_id: DefId,\n-    flow_state: DataflowAnalysis<'a, 'tcx, BD>,\n-    print_preflow_to: Option<String>,\n-    print_postflow_to: Option<String>,\n-}\n-\n-/// `DebugFormatted` encapsulates the \"{:?}\" rendering of some\n-/// arbitrary value. This way: you pay cost of allocating an extra\n-/// string (as well as that of rendering up-front); in exchange, you\n-/// don't have to hand over ownership of your value or deal with\n-/// borrowing it.\n-pub struct DebugFormatted(String);\n-\n-impl DebugFormatted {\n-    pub fn new(input: &dyn fmt::Debug) -> DebugFormatted {\n-        DebugFormatted(format!(\"{:?}\", input))\n-    }\n-}\n-\n-impl fmt::Debug for DebugFormatted {\n-    fn fmt(&self, w: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(w, \"{}\", self.0)\n-    }\n-}\n-\n-pub trait Dataflow<'tcx, BD: BitDenotation<'tcx>> {\n-    /// Sets up and runs the dataflow problem, using `p` to render results if\n-    /// implementation so chooses.\n-    fn dataflow<P>(&mut self, p: P)\n-    where\n-        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-    {\n-        let _ = p; // default implementation does not instrument process.\n-        self.build_sets();\n-        self.propagate();\n-    }\n-\n-    /// Sets up the entry, gen, and kill sets for this instance of a dataflow problem.\n-    fn build_sets(&mut self);\n-\n-    /// Finds a fixed-point solution to this instance of a dataflow problem.\n-    fn propagate(&mut self);\n-}\n-\n-impl<'a, 'tcx, BD> Dataflow<'tcx, BD> for DataflowBuilder<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    fn dataflow<P>(&mut self, p: P)\n-    where\n-        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-    {\n-        self.flow_state.build_sets();\n-        self.pre_dataflow_instrumentation(|c, i| p(c, i)).unwrap();\n-        self.flow_state.propagate();\n-        self.post_dataflow_instrumentation(|c, i| p(c, i)).unwrap();\n-    }\n-\n-    fn build_sets(&mut self) {\n-        self.flow_state.build_sets();\n-    }\n-    fn propagate(&mut self) {\n-        self.flow_state.propagate();\n-    }\n+pub struct MoveDataParamEnv<'tcx> {\n+    pub(crate) move_data: MoveData<'tcx>,\n+    pub(crate) param_env: ty::ParamEnv<'tcx>,\n }\n \n pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: Symbol) -> Option<MetaItem> {\n@@ -124,811 +46,3 @@ pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: Symbol) -> Opti\n     }\n     None\n }\n-\n-pub struct MoveDataParamEnv<'tcx> {\n-    pub(crate) move_data: MoveData<'tcx>,\n-    pub(crate) param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-pub fn do_dataflow<'a, 'tcx, BD, P>(\n-    tcx: TyCtxt<'tcx>,\n-    body: &'a Body<'tcx>,\n-    def_id: DefId,\n-    attributes: &[ast::Attribute],\n-    dead_unwinds: &BitSet<BasicBlock>,\n-    bd: BD,\n-    p: P,\n-) -> DataflowResults<'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-    P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-{\n-    let flow_state = DataflowAnalysis::new(body, dead_unwinds, bd);\n-    flow_state.run(tcx, def_id, attributes, p)\n-}\n-\n-impl<'a, 'tcx, BD> DataflowAnalysis<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    pub(crate) fn run<P>(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        attributes: &[ast::Attribute],\n-        p: P,\n-    ) -> DataflowResults<'tcx, BD>\n-    where\n-        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-    {\n-        let name_found = |sess: &Session, attrs: &[ast::Attribute], name| -> Option<String> {\n-            if let Some(item) = has_rustc_mir_with(attrs, name) {\n-                if let Some(s) = item.value_str() {\n-                    return Some(s.to_string());\n-                } else {\n-                    let path = pprust::path_to_string(&item.path);\n-                    sess.span_err(item.span, &format!(\"{} attribute requires a path\", path));\n-                    return None;\n-                }\n-            }\n-            None\n-        };\n-\n-        let print_preflow_to = name_found(tcx.sess, attributes, sym::borrowck_graphviz_preflow);\n-        let print_postflow_to = name_found(tcx.sess, attributes, sym::borrowck_graphviz_postflow);\n-\n-        let mut mbcx =\n-            DataflowBuilder { def_id, print_preflow_to, print_postflow_to, flow_state: self };\n-\n-        mbcx.dataflow(p);\n-        mbcx.flow_state.results()\n-    }\n-}\n-\n-struct PropagationContext<'b, 'a, 'tcx, O>\n-where\n-    O: BitDenotation<'tcx>,\n-{\n-    builder: &'b mut DataflowAnalysis<'a, 'tcx, O>,\n-}\n-\n-impl<'a, 'tcx, BD> DataflowAnalysis<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    fn propagate(&mut self) {\n-        let mut temp = BitSet::new_empty(self.flow_state.sets.bits_per_block);\n-        let mut propcx = PropagationContext { builder: self };\n-        propcx.walk_cfg(&mut temp);\n-    }\n-\n-    fn build_sets(&mut self) {\n-        // Build the transfer function for each block.\n-        for (bb, data) in self.body.basic_blocks().iter_enumerated() {\n-            let &mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = data;\n-\n-            let trans = self.flow_state.sets.trans_mut_for(bb.index());\n-            for j_stmt in 0..statements.len() {\n-                let location = Location { block: bb, statement_index: j_stmt };\n-                self.flow_state.operator.before_statement_effect(trans, location);\n-                self.flow_state.operator.statement_effect(trans, location);\n-            }\n-\n-            if terminator.is_some() {\n-                let location = Location { block: bb, statement_index: statements.len() };\n-                self.flow_state.operator.before_terminator_effect(trans, location);\n-                self.flow_state.operator.terminator_effect(trans, location);\n-            }\n-        }\n-\n-        // Initialize the flow state at entry to the start block.\n-        let on_entry = self.flow_state.sets.entry_set_mut_for(mir::START_BLOCK.index());\n-        self.flow_state.operator.start_block_effect(on_entry);\n-    }\n-}\n-\n-impl<'b, 'a, 'tcx, BD> PropagationContext<'b, 'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    fn walk_cfg(&mut self, in_out: &mut BitSet<BD::Idx>) {\n-        let body = self.builder.body;\n-\n-        // Initialize the dirty queue in reverse post-order. This makes it more likely that the\n-        // entry state for each basic block will have the effects of its predecessors applied\n-        // before it is processed. In fact, for CFGs without back edges, this guarantees that\n-        // dataflow will converge in exactly `N` iterations, where `N` is the number of basic\n-        // blocks.\n-        let mut dirty_queue: WorkQueue<mir::BasicBlock> =\n-            WorkQueue::with_none(body.basic_blocks().len());\n-        for (bb, _) in traversal::reverse_postorder(body) {\n-            dirty_queue.insert(bb);\n-        }\n-\n-        // Add blocks which are not reachable from START_BLOCK to the work queue. These blocks will\n-        // be processed after the ones added above.\n-        for bb in body.basic_blocks().indices() {\n-            dirty_queue.insert(bb);\n-        }\n-\n-        while let Some(bb) = dirty_queue.pop() {\n-            let (on_entry, trans) = self.builder.flow_state.sets.get_mut(bb.index());\n-            debug_assert!(in_out.words().len() == on_entry.words().len());\n-            in_out.overwrite(on_entry);\n-            trans.apply(in_out);\n-\n-            let bb_data = &body[bb];\n-            self.builder.propagate_bits_into_graph_successors_of(\n-                in_out,\n-                (bb, bb_data),\n-                &mut dirty_queue,\n-            );\n-        }\n-    }\n-}\n-\n-fn dataflow_path(context: &str, path: &str) -> PathBuf {\n-    let mut path = PathBuf::from(path);\n-    let new_file_name = {\n-        let orig_file_name = path.file_name().unwrap().to_str().unwrap();\n-        format!(\"{}_{}\", context, orig_file_name)\n-    };\n-    path.set_file_name(new_file_name);\n-    path\n-}\n-\n-impl<'a, 'tcx, BD> DataflowBuilder<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    fn pre_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n-    where\n-        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-    {\n-        if let Some(ref path_str) = self.print_preflow_to {\n-            let path = dataflow_path(BD::name(), path_str);\n-            graphviz::print_borrowck_graph_to(self, &path, p)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    fn post_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n-    where\n-        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-    {\n-        if let Some(ref path_str) = self.print_postflow_to {\n-            let path = dataflow_path(BD::name(), path_str);\n-            graphviz::print_borrowck_graph_to(self, &path, p)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-}\n-\n-/// DataflowResultsConsumer abstracts over walking the MIR with some\n-/// already constructed dataflow results.\n-///\n-/// It abstracts over the FlowState and also completely hides the\n-/// underlying flow analysis results, because it needs to handle cases\n-/// where we are combining the results of *multiple* flow analyses\n-/// (e.g., borrows + inits + uninits).\n-pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n-    type FlowState: FlowsAtLocation;\n-\n-    // Observation Hooks: override (at least one of) these to get analysis feedback.\n-    fn visit_block_entry(&mut self, _bb: BasicBlock, _flow_state: &Self::FlowState) {}\n-\n-    fn visit_statement_entry(\n-        &mut self,\n-        _loc: Location,\n-        _stmt: &'a Statement<'tcx>,\n-        _flow_state: &Self::FlowState,\n-    ) {\n-    }\n-\n-    fn visit_terminator_entry(\n-        &mut self,\n-        _loc: Location,\n-        _term: &'a Terminator<'tcx>,\n-        _flow_state: &Self::FlowState,\n-    ) {\n-    }\n-\n-    // Main entry point: this drives the processing of results.\n-\n-    fn analyze_results(&mut self, flow_uninit: &mut Self::FlowState) {\n-        let flow = flow_uninit;\n-        for (bb, _) in traversal::reverse_postorder(self.body()) {\n-            flow.reset_to_entry_of(bb);\n-            self.process_basic_block(bb, flow);\n-        }\n-    }\n-\n-    fn process_basic_block(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n-        self.visit_block_entry(bb, flow_state);\n-\n-        let BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = self.body()[bb];\n-        let mut location = Location { block: bb, statement_index: 0 };\n-        for stmt in statements.iter() {\n-            flow_state.reconstruct_statement_effect(location);\n-            self.visit_statement_entry(location, stmt, flow_state);\n-            flow_state.apply_local_effect(location);\n-            location.statement_index += 1;\n-        }\n-\n-        if let Some(ref term) = *terminator {\n-            flow_state.reconstruct_terminator_effect(location);\n-            self.visit_terminator_entry(location, term, flow_state);\n-\n-            // We don't need to apply the effect of the terminator,\n-            // since we are only visiting dataflow state on control\n-            // flow entry to the various nodes. (But we still need to\n-            // reconstruct the effect, because the visit method might\n-            // inspect it.)\n-        }\n-    }\n-\n-    // Delegated Hooks: Provide access to the MIR and process the flow state.\n-\n-    fn body(&self) -> &'a Body<'tcx>;\n-}\n-\n-/// Allows iterating dataflow results in a flexible and reasonably fast way.\n-pub struct DataflowResultsCursor<'mir, 'tcx, BD, DR = DataflowResults<'tcx, BD>>\n-where\n-    BD: BitDenotation<'tcx>,\n-    DR: Borrow<DataflowResults<'tcx, BD>>,\n-{\n-    flow_state: FlowAtLocation<'tcx, BD, DR>,\n-\n-    // The statement (or terminator) whose effect has been reconstructed in\n-    // flow_state.\n-    curr_loc: Option<Location>,\n-\n-    body: &'mir Body<'tcx>,\n-}\n-\n-pub type DataflowResultsRefCursor<'mir, 'tcx, BD> =\n-    DataflowResultsCursor<'mir, 'tcx, BD, &'mir DataflowResults<'tcx, BD>>;\n-\n-impl<'mir, 'tcx, BD, DR> DataflowResultsCursor<'mir, 'tcx, BD, DR>\n-where\n-    BD: BitDenotation<'tcx>,\n-    DR: Borrow<DataflowResults<'tcx, BD>>,\n-{\n-    pub fn new(result: DR, body: &'mir Body<'tcx>) -> Self {\n-        DataflowResultsCursor { flow_state: FlowAtLocation::new(result), curr_loc: None, body }\n-    }\n-\n-    /// Seek to the given location in MIR. This method is fast if you are\n-    /// traversing your MIR statements in order.\n-    ///\n-    /// After calling `seek`, the current state will reflect all effects up to\n-    /// and including the `before_statement_effect` of the statement at location\n-    /// `loc`. The `statement_effect` of the statement at `loc` will be\n-    /// available as the current effect (see e.g. `each_gen_bit`).\n-    ///\n-    /// If `loc.statement_index` equals the number of statements in the block,\n-    /// we will reconstruct the terminator effect in the same way as described\n-    /// above.\n-    pub fn seek(&mut self, loc: Location) {\n-        if self.curr_loc.map(|cur| loc == cur).unwrap_or(false) {\n-            return;\n-        }\n-\n-        let start_index;\n-        let should_reset = match self.curr_loc {\n-            None => true,\n-            Some(cur) if loc.block != cur.block || loc.statement_index < cur.statement_index => {\n-                true\n-            }\n-            _ => false,\n-        };\n-        if should_reset {\n-            self.flow_state.reset_to_entry_of(loc.block);\n-            start_index = 0;\n-        } else {\n-            let curr_loc = self.curr_loc.unwrap();\n-            start_index = curr_loc.statement_index;\n-            // Apply the effect from the last seek to the current state.\n-            self.flow_state.apply_local_effect(curr_loc);\n-        }\n-\n-        for stmt in start_index..loc.statement_index {\n-            let mut stmt_loc = loc;\n-            stmt_loc.statement_index = stmt;\n-            self.flow_state.reconstruct_statement_effect(stmt_loc);\n-            self.flow_state.apply_local_effect(stmt_loc);\n-        }\n-\n-        if loc.statement_index == self.body[loc.block].statements.len() {\n-            self.flow_state.reconstruct_terminator_effect(loc);\n-        } else {\n-            self.flow_state.reconstruct_statement_effect(loc);\n-        }\n-        self.curr_loc = Some(loc);\n-    }\n-\n-    /// Return whether the current state contains bit `x`.\n-    pub fn contains(&self, x: BD::Idx) -> bool {\n-        self.flow_state.contains(x)\n-    }\n-\n-    /// Iterate over each `gen` bit in the current effect (invoke `seek` first).\n-    pub fn each_gen_bit<F>(&self, f: F)\n-    where\n-        F: FnMut(BD::Idx),\n-    {\n-        self.flow_state.each_gen_bit(f)\n-    }\n-\n-    pub fn get(&self) -> &BitSet<BD::Idx> {\n-        self.flow_state.as_dense()\n-    }\n-}\n-\n-pub struct DataflowAnalysis<'a, 'tcx, O>\n-where\n-    O: BitDenotation<'tcx>,\n-{\n-    flow_state: DataflowState<'tcx, O>,\n-    dead_unwinds: &'a BitSet<mir::BasicBlock>,\n-    body: &'a Body<'tcx>,\n-}\n-\n-impl<'a, 'tcx, O> DataflowAnalysis<'a, 'tcx, O>\n-where\n-    O: BitDenotation<'tcx>,\n-{\n-    pub fn results(self) -> DataflowResults<'tcx, O> {\n-        DataflowResults(self.flow_state)\n-    }\n-\n-    pub fn body(&self) -> &'a Body<'tcx> {\n-        self.body\n-    }\n-}\n-\n-pub struct DataflowResults<'tcx, O>(pub(crate) DataflowState<'tcx, O>)\n-where\n-    O: BitDenotation<'tcx>;\n-\n-impl<'tcx, O: BitDenotation<'tcx>> DataflowResults<'tcx, O> {\n-    pub fn sets(&self) -> &AllSets<O::Idx> {\n-        &self.0.sets\n-    }\n-\n-    pub fn operator(&self) -> &O {\n-        &self.0.operator\n-    }\n-}\n-\n-/// State of a dataflow analysis; couples a collection of bit sets\n-/// with operator used to initialize and merge bits during analysis.\n-pub struct DataflowState<'tcx, O: BitDenotation<'tcx>> {\n-    /// All the sets for the analysis. (Factored into its\n-    /// own structure so that we can borrow it mutably\n-    /// on its own separate from other fields.)\n-    pub sets: AllSets<O::Idx>,\n-\n-    /// operator used to initialize, combine, and interpret bits.\n-    pub(crate) operator: O,\n-}\n-\n-impl<'tcx, O: BitDenotation<'tcx>> DataflowState<'tcx, O> {\n-    pub(crate) fn interpret_set<'c, P>(\n-        &self,\n-        o: &'c O,\n-        set: &BitSet<O::Idx>,\n-        render_idx: &P,\n-    ) -> Vec<DebugFormatted>\n-    where\n-        P: Fn(&O, O::Idx) -> DebugFormatted,\n-    {\n-        set.iter().map(|i| render_idx(o, i)).collect()\n-    }\n-\n-    pub(crate) fn interpret_hybrid_set<'c, P>(\n-        &self,\n-        o: &'c O,\n-        set: &HybridBitSet<O::Idx>,\n-        render_idx: &P,\n-    ) -> Vec<DebugFormatted>\n-    where\n-        P: Fn(&O, O::Idx) -> DebugFormatted,\n-    {\n-        set.iter().map(|i| render_idx(o, i)).collect()\n-    }\n-}\n-\n-/// A 2-tuple representing the \"gen\" and \"kill\" bitsets during\n-/// dataflow analysis.\n-///\n-/// It is best to ensure that the intersection of `gen_set` and\n-/// `kill_set` is empty; otherwise the results of the dataflow will\n-/// have a hidden dependency on what order the bits are generated and\n-/// killed during the iteration. (This is such a good idea that the\n-/// `fn gen` and `fn kill` methods that set their state enforce this\n-/// for you.)\n-#[derive(Debug, Clone, Copy)]\n-pub struct GenKill<T> {\n-    pub(crate) gen_set: T,\n-    pub(crate) kill_set: T,\n-}\n-\n-pub type GenKillSet<T> = GenKill<HybridBitSet<T>>;\n-\n-impl<T> GenKill<T> {\n-    /// Creates a new tuple where `gen_set == kill_set == elem`.\n-    pub(crate) fn from_elem(elem: T) -> Self\n-    where\n-        T: Clone,\n-    {\n-        GenKill { gen_set: elem.clone(), kill_set: elem }\n-    }\n-}\n-\n-impl<E: Idx> GenKillSet<E> {\n-    pub fn clear(&mut self) {\n-        self.gen_set.clear();\n-        self.kill_set.clear();\n-    }\n-\n-    pub fn gen(&mut self, e: E) {\n-        self.gen_set.insert(e);\n-        self.kill_set.remove(e);\n-    }\n-\n-    pub fn gen_all(&mut self, i: impl IntoIterator<Item: Borrow<E>>) {\n-        for j in i {\n-            self.gen(*j.borrow());\n-        }\n-    }\n-\n-    pub fn kill(&mut self, e: E) {\n-        self.gen_set.remove(e);\n-        self.kill_set.insert(e);\n-    }\n-\n-    pub fn kill_all(&mut self, i: impl IntoIterator<Item: Borrow<E>>) {\n-        for j in i {\n-            self.kill(*j.borrow());\n-        }\n-    }\n-\n-    /// Computes `(set \u222a gen) - kill` and assigns the result to `set`.\n-    pub(crate) fn apply(&self, set: &mut BitSet<E>) {\n-        set.union(&self.gen_set);\n-        set.subtract(&self.kill_set);\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct AllSets<E: Idx> {\n-    /// Analysis bitwidth for each block.\n-    bits_per_block: usize,\n-\n-    /// For each block, bits valid on entry to the block.\n-    on_entry: Vec<BitSet<E>>,\n-\n-    /// The transfer function of each block expressed as the set of bits\n-    /// generated and killed by executing the statements + terminator in the\n-    /// block -- with one caveat. In particular, for *call terminators*, the\n-    /// effect of storing the destination is not included, since that only takes\n-    /// effect on the **success** edge (and not the unwind edge).\n-    trans: Vec<GenKillSet<E>>,\n-}\n-\n-impl<E: Idx> AllSets<E> {\n-    pub fn bits_per_block(&self) -> usize {\n-        self.bits_per_block\n-    }\n-\n-    pub fn get_mut(&mut self, block_idx: usize) -> (&mut BitSet<E>, &mut GenKillSet<E>) {\n-        (&mut self.on_entry[block_idx], &mut self.trans[block_idx])\n-    }\n-\n-    pub fn trans_for(&self, block_idx: usize) -> &GenKillSet<E> {\n-        &self.trans[block_idx]\n-    }\n-    pub fn trans_mut_for(&mut self, block_idx: usize) -> &mut GenKillSet<E> {\n-        &mut self.trans[block_idx]\n-    }\n-    pub fn entry_set_for(&self, block_idx: usize) -> &BitSet<E> {\n-        &self.on_entry[block_idx]\n-    }\n-    pub fn entry_set_mut_for(&mut self, block_idx: usize) -> &mut BitSet<E> {\n-        &mut self.on_entry[block_idx]\n-    }\n-    pub fn gen_set_for(&self, block_idx: usize) -> &HybridBitSet<E> {\n-        &self.trans_for(block_idx).gen_set\n-    }\n-    pub fn kill_set_for(&self, block_idx: usize) -> &HybridBitSet<E> {\n-        &self.trans_for(block_idx).kill_set\n-    }\n-}\n-\n-/// Parameterization for the precise form of data flow that is used.\n-///\n-/// `BottomValue` determines whether the initial entry set for each basic block is empty or full.\n-/// This also determines the semantics of the lattice `join` operator used to merge dataflow\n-/// results, since dataflow works by starting at the bottom and moving monotonically to a fixed\n-/// point.\n-///\n-/// This means, for propagation across the graph, that you either want to start at all-zeroes and\n-/// then use Union as your merge when propagating, or you start at all-ones and then use Intersect\n-/// as your merge when propagating.\n-pub trait BottomValue {\n-    /// Specifies the initial value for each bit in the entry set for each basic block.\n-    const BOTTOM_VALUE: bool;\n-\n-    /// Merges `in_set` into `inout_set`, returning `true` if `inout_set` changed.\n-    ///\n-    /// It is almost certainly wrong to override this, since it automatically applies\n-    /// * `inout_set & in_set` if `BOTTOM_VALUE == true`\n-    /// * `inout_set | in_set` if `BOTTOM_VALUE == false`\n-    ///\n-    /// This means that if a bit is not `BOTTOM_VALUE`, it is propagated into all target blocks.\n-    /// For clarity, the above statement again from a different perspective:\n-    /// A bit in the block's entry set is `!BOTTOM_VALUE` if *any* predecessor block's bit value is\n-    /// `!BOTTOM_VALUE`.\n-    ///\n-    /// There are situations where you want the opposite behaviour: propagate only if *all*\n-    /// predecessor blocks's value is `!BOTTOM_VALUE`.\n-    /// E.g. if you want to know whether a bit is *definitely* set at a specific location. This\n-    /// means that all code paths leading to the location must have set the bit, instead of any\n-    /// code path leading there.\n-    ///\n-    /// If you want this kind of \"definitely set\" analysis, you need to\n-    /// 1. Invert `BOTTOM_VALUE`\n-    /// 2. Reset the `entry_set` in `start_block_effect` to `!BOTTOM_VALUE`\n-    /// 3. Override `join` to do the opposite from what it's doing now.\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        if !Self::BOTTOM_VALUE { inout_set.union(in_set) } else { inout_set.intersect(in_set) }\n-    }\n-}\n-\n-/// A specific flavor of dataflow analysis.\n-///\n-/// To run a dataflow analysis, one sets up an initial state for the\n-/// `START_BLOCK` via `start_block_effect` and a transfer function (`trans`)\n-/// for each block individually. The entry set for all other basic blocks is\n-/// initialized to `Self::BOTTOM_VALUE`. The dataflow analysis then\n-/// iteratively modifies the various entry sets (but leaves the the transfer\n-/// function unchanged). `BottomValue::join` is used to merge the bitsets from\n-/// two blocks (e.g. when two blocks' terminator jumps to a single block, that\n-/// target block's state is the merged state of both incoming blocks).\n-pub trait BitDenotation<'tcx>: BottomValue {\n-    /// Specifies what index type is used to access the bitvector.\n-    type Idx: Idx;\n-\n-    /// A name describing the dataflow analysis that this\n-    /// `BitDenotation` is supporting. The name should be something\n-    /// suitable for plugging in as part of a filename (i.e., avoid\n-    /// space-characters or other things that tend to look bad on a\n-    /// file system, like slashes or periods). It is also better for\n-    /// the name to be reasonably short, again because it will be\n-    /// plugged into a filename.\n-    fn name() -> &'static str;\n-\n-    /// Size of each bitvector allocated for each block in the analysis.\n-    fn bits_per_block(&self) -> usize;\n-\n-    /// Mutates the entry set according to the effects that\n-    /// have been established *prior* to entering the start\n-    /// block. This can't access the gen/kill sets, because\n-    /// these won't be accounted for correctly.\n-    ///\n-    /// (For example, establishing the call arguments.)\n-    fn start_block_effect(&self, entry_set: &mut BitSet<Self::Idx>);\n-\n-    /// Similar to `statement_effect`, except it applies\n-    /// *just before* the statement rather than *just after* it.\n-    ///\n-    /// This matters for \"dataflow at location\" APIs, because the\n-    /// before-statement effect is visible while visiting the\n-    /// statement, while the after-statement effect only becomes\n-    /// visible at the next statement.\n-    ///\n-    /// Both the before-statement and after-statement effects are\n-    /// applied, in that order, before moving for the next\n-    /// statement.\n-    fn before_statement_effect(&self, _trans: &mut GenKillSet<Self::Idx>, _location: Location) {}\n-\n-    /// Mutates the block-sets (the flow sets for the given\n-    /// basic block) according to the effects of evaluating statement.\n-    ///\n-    /// This is used, in particular, for building up the\n-    /// \"transfer-function\" representing the overall-effect of the\n-    /// block, represented via GEN and KILL sets.\n-    ///\n-    /// The statement is identified as `bb_data[idx_stmt]`, where\n-    /// `bb_data` is the sequence of statements identified by `bb` in\n-    /// the MIR.\n-    fn statement_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location);\n-\n-    /// Similar to `terminator_effect`, except it applies\n-    /// *just before* the terminator rather than *just after* it.\n-    ///\n-    /// This matters for \"dataflow at location\" APIs, because the\n-    /// before-terminator effect is visible while visiting the\n-    /// terminator, while the after-terminator effect only becomes\n-    /// visible at the terminator's successors.\n-    ///\n-    /// Both the before-terminator and after-terminator effects are\n-    /// applied, in that order, before moving for the next\n-    /// terminator.\n-    fn before_terminator_effect(&self, _trans: &mut GenKillSet<Self::Idx>, _location: Location) {}\n-\n-    /// Mutates the block-sets (the flow sets for the given\n-    /// basic block) according to the effects of evaluating\n-    /// the terminator.\n-    ///\n-    /// This is used, in particular, for building up the\n-    /// \"transfer-function\" representing the overall-effect of the\n-    /// block, represented via GEN and KILL sets.\n-    ///\n-    /// The effects applied here cannot depend on which branch the\n-    /// terminator took.\n-    fn terminator_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location);\n-\n-    /// Mutates the block-sets according to the (flow-dependent)\n-    /// effect of a successful return from a Call terminator.\n-    ///\n-    /// If basic-block BB_x ends with a call-instruction that, upon\n-    /// successful return, flows to BB_y, then this method will be\n-    /// called on the exit flow-state of BB_x in order to set up the\n-    /// entry flow-state of BB_y.\n-    ///\n-    /// This is used, in particular, as a special case during the\n-    /// \"propagate\" loop where all of the basic blocks are repeatedly\n-    /// visited. Since the effects of a Call terminator are\n-    /// flow-dependent, the current MIR cannot encode them via just\n-    /// GEN and KILL sets attached to the block, and so instead we add\n-    /// this extra machinery to represent the flow-dependent effect.\n-    //\n-    // FIXME: right now this is a bit of a wart in the API. It might\n-    // be better to represent this as an additional gen- and\n-    // kill-sets associated with each edge coming out of the basic\n-    // block.\n-    fn propagate_call_return(\n-        &self,\n-        in_out: &mut BitSet<Self::Idx>,\n-        call_bb: mir::BasicBlock,\n-        dest_bb: mir::BasicBlock,\n-        dest_place: &mir::Place<'tcx>,\n-    );\n-}\n-\n-impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D>\n-where\n-    D: BitDenotation<'tcx>,\n-{\n-    pub fn new(\n-        body: &'a Body<'tcx>,\n-        dead_unwinds: &'a BitSet<mir::BasicBlock>,\n-        denotation: D,\n-    ) -> Self {\n-        let bits_per_block = denotation.bits_per_block();\n-        let num_blocks = body.basic_blocks().len();\n-\n-        let on_entry = if D::BOTTOM_VALUE {\n-            vec![BitSet::new_filled(bits_per_block); num_blocks]\n-        } else {\n-            vec![BitSet::new_empty(bits_per_block); num_blocks]\n-        };\n-        let nop = GenKill::from_elem(HybridBitSet::new_empty(bits_per_block));\n-\n-        DataflowAnalysis {\n-            body,\n-            dead_unwinds,\n-            flow_state: DataflowState {\n-                sets: AllSets { bits_per_block, on_entry, trans: vec![nop; num_blocks] },\n-                operator: denotation,\n-            },\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D>\n-where\n-    D: BitDenotation<'tcx>,\n-{\n-    /// Propagates the bits of `in_out` into all the successors of `bb`,\n-    /// using bitwise operator denoted by `self.operator`.\n-    ///\n-    /// For most blocks, this is entirely uniform. However, for blocks\n-    /// that end with a call terminator, the effect of the call on the\n-    /// dataflow state may depend on whether the call returned\n-    /// successfully or unwound.\n-    ///\n-    /// To reflect this, the `propagate_call_return` method of the\n-    /// `BitDenotation` mutates `in_out` when propagating `in_out` via\n-    /// a call terminator; such mutation is performed *last*, to\n-    /// ensure its side-effects do not leak elsewhere (e.g., into\n-    /// unwind target).\n-    fn propagate_bits_into_graph_successors_of(\n-        &mut self,\n-        in_out: &mut BitSet<D::Idx>,\n-        (bb, bb_data): (mir::BasicBlock, &mir::BasicBlockData<'tcx>),\n-        dirty_list: &mut WorkQueue<mir::BasicBlock>,\n-    ) {\n-        match bb_data.terminator().kind {\n-            mir::TerminatorKind::Return\n-            | mir::TerminatorKind::Resume\n-            | mir::TerminatorKind::Abort\n-            | mir::TerminatorKind::GeneratorDrop\n-            | mir::TerminatorKind::Unreachable => {}\n-            mir::TerminatorKind::Goto { target }\n-            | mir::TerminatorKind::Assert { target, cleanup: None, .. }\n-            | mir::TerminatorKind::Yield { resume: target, drop: None, .. }\n-            | mir::TerminatorKind::Drop { target, location: _, unwind: None }\n-            | mir::TerminatorKind::DropAndReplace { target, value: _, location: _, unwind: None } =>\n-            {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-            }\n-            mir::TerminatorKind::Yield { resume: target, drop: Some(drop), .. } => {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-                self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n-            }\n-            mir::TerminatorKind::Assert { target, cleanup: Some(unwind), .. }\n-            | mir::TerminatorKind::Drop { target, location: _, unwind: Some(unwind) }\n-            | mir::TerminatorKind::DropAndReplace {\n-                target,\n-                value: _,\n-                location: _,\n-                unwind: Some(unwind),\n-            } => {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-                if !self.dead_unwinds.contains(bb) {\n-                    self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                }\n-            }\n-            mir::TerminatorKind::SwitchInt { ref targets, .. } => {\n-                for target in targets {\n-                    self.propagate_bits_into_entry_set_for(in_out, *target, dirty_list);\n-                }\n-            }\n-            mir::TerminatorKind::Call { cleanup, ref destination, .. } => {\n-                if let Some(unwind) = cleanup {\n-                    if !self.dead_unwinds.contains(bb) {\n-                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                    }\n-                }\n-                if let Some((ref dest_place, dest_bb)) = *destination {\n-                    // N.B.: This must be done *last*, after all other\n-                    // propagation, as documented in comment above.\n-                    self.flow_state.operator.propagate_call_return(in_out, bb, dest_bb, dest_place);\n-                    self.propagate_bits_into_entry_set_for(in_out, dest_bb, dirty_list);\n-                }\n-            }\n-            mir::TerminatorKind::FalseEdges { real_target, imaginary_target } => {\n-                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n-                self.propagate_bits_into_entry_set_for(in_out, imaginary_target, dirty_list);\n-            }\n-            mir::TerminatorKind::FalseUnwind { real_target, unwind } => {\n-                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n-                if let Some(unwind) = unwind {\n-                    if !self.dead_unwinds.contains(bb) {\n-                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn propagate_bits_into_entry_set_for(\n-        &mut self,\n-        in_out: &BitSet<D::Idx>,\n-        bb: mir::BasicBlock,\n-        dirty_queue: &mut WorkQueue<mir::BasicBlock>,\n-    ) {\n-        let entry_set = self.flow_state.sets.entry_set_mut_for(bb.index());\n-        let set_changed = self.flow_state.operator.join(entry_set, &in_out);\n-        if set_changed {\n-            dirty_queue.insert(bb);\n-        }\n-    }\n-}"}, {"sha": "5f761ce344880baec15db92e3a2164d1ec1f6b15", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "patch": "@@ -9,7 +9,7 @@ use rustc_index::bit_set::BitSet;\n use std::marker::PhantomData;\n \n use super::{qualifs, Item, Qualif};\n-use crate::dataflow::{self as old_dataflow, generic as dataflow};\n+use crate::dataflow;\n \n /// A `Visitor` that propagates qualifs between locals. This defines the transfer function of\n /// `FlowSensitiveAnalysis`.\n@@ -165,7 +165,7 @@ where\n     }\n }\n \n-impl<Q> old_dataflow::BottomValue for FlowSensitiveAnalysis<'_, '_, '_, Q> {\n+impl<Q> dataflow::BottomValue for FlowSensitiveAnalysis<'_, '_, '_, Q> {\n     const BOTTOM_VALUE: bool = false;\n }\n "}, {"sha": "7f4714e9f9c1999e2276ba5c4a6747db92ab69bd", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "patch": "@@ -22,8 +22,8 @@ use super::qualifs::{self, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n use super::{is_lang_panic_fn, ConstKind, Item, Qualif};\n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n-use crate::dataflow::generic::{self as dataflow, Analysis};\n use crate::dataflow::MaybeMutBorrowedLocals;\n+use crate::dataflow::{self, Analysis};\n \n // We are using `MaybeMutBorrowedLocals` as a proxy for whether an item may have been mutated\n // through a pointer prior to the given point. This is okay even though `MaybeMutBorrowedLocals`"}, {"sha": "4ec4ef0206105c82e0eee6f372f3273c01946546", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "patch": "@@ -1,9 +1,9 @@\n use crate::dataflow;\n-use crate::dataflow::generic::{Analysis, ResultsCursor};\n use crate::dataflow::move_paths::{LookupResult, MoveData, MovePathIndex};\n use crate::dataflow::on_lookup_result_bits;\n use crate::dataflow::MoveDataParamEnv;\n use crate::dataflow::{on_all_children_bits, on_all_drop_children_bits};\n+use crate::dataflow::{Analysis, ResultsCursor};\n use crate::dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use crate::transform::{MirPass, MirSource};\n use crate::util::elaborate_drops::{elaborate_drop, DropFlagState, Unwind};"}, {"sha": "1945efb6bf7ccf8f9b3d78c418c8a69a494942bb", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "patch": "@@ -49,7 +49,7 @@\n //! For generators with state 1 (returned) and state 2 (poisoned) it does nothing.\n //! Otherwise it drops all the values in scope at the last suspension point.\n \n-use crate::dataflow::generic::{self as dataflow, Analysis};\n+use crate::dataflow::{self, Analysis};\n use crate::dataflow::{MaybeBorrowedLocals, MaybeRequiresStorage, MaybeStorageLive};\n use crate::transform::no_landing_pads::no_landing_pads;\n use crate::transform::simplify;"}, {"sha": "c9a00166f0f9c9b61f757d6ae974552fd2ef6c1b", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6144a115b2535feb8a84914105a2896e7e8e92/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=0f6144a115b2535feb8a84914105a2896e7e8e92", "patch": "@@ -9,11 +9,11 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n \n-use crate::dataflow::generic::{Analysis, Results, ResultsCursor};\n use crate::dataflow::move_paths::{HasMoveData, MoveData};\n use crate::dataflow::move_paths::{LookupResult, MovePathIndex};\n use crate::dataflow::MaybeMutBorrowedLocals;\n use crate::dataflow::MoveDataParamEnv;\n+use crate::dataflow::{Analysis, Results, ResultsCursor};\n use crate::dataflow::{\n     DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeUninitializedPlaces,\n };"}]}