{"sha": "dc91467db05ba6ee2a2a72c440e8c48008abb7a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjOTE0NjdkYjA1YmE2ZWUyYTJhNzJjNDQwZThjNDgwMDhhYmI3YTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-26T15:32:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-26T15:32:21Z"}, "message": "Auto merge of #33766 - jseyfried:cleanup_expansion, r=nrc\n\nCleanup macro expansion and improve diagnostics\n\nCleanup macro expansion and improve diagnostics. Fixes #33709.\nr? @nrc", "tree": {"sha": "eadb38c70a25e9b59c6e18d2778b9e12067dd214", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eadb38c70a25e9b59c6e18d2778b9e12067dd214"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc91467db05ba6ee2a2a72c440e8c48008abb7a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc91467db05ba6ee2a2a72c440e8c48008abb7a3", "html_url": "https://github.com/rust-lang/rust/commit/dc91467db05ba6ee2a2a72c440e8c48008abb7a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc91467db05ba6ee2a2a72c440e8c48008abb7a3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c795e08d6f4a532f12f3f8e1837db5e0647f8b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c795e08d6f4a532f12f3f8e1837db5e0647f8b0", "html_url": "https://github.com/rust-lang/rust/commit/3c795e08d6f4a532f12f3f8e1837db5e0647f8b0"}, {"sha": "e9c0283369bbb9879e0be2440d77f23d806b5537", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9c0283369bbb9879e0be2440d77f23d806b5537", "html_url": "https://github.com/rust-lang/rust/commit/e9c0283369bbb9879e0be2440d77f23d806b5537"}], "stats": {"total": 604, "additions": 191, "deletions": 413}, "files": [{"sha": "596faac35882af13748a8dcf04fc7c7467184b6f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 183, "deletions": 411, "changes": 594, "blob_url": "https://github.com/rust-lang/rust/blob/dc91467db05ba6ee2a2a72c440e8c48008abb7a3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc91467db05ba6ee2a2a72c440e8c48008abb7a3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=dc91467db05ba6ee2a2a72c440e8c48008abb7a3", "patch": "@@ -16,7 +16,7 @@ use ast;\n use ext::mtwt;\n use ext::build::AstBuilder;\n use attr;\n-use attr::{AttrMetaMethods, WithAttrs};\n+use attr::{AttrMetaMethods, WithAttrs, ThinAttributesExt};\n use codemap;\n use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use ext::base::*;\n@@ -35,59 +35,55 @@ use std_inject;\n use std::collections::HashSet;\n use std::env;\n \n-// this function is called to detect use of feature-gated or invalid attributes\n-// on macro invoations since they will not be detected after macro expansion\n-fn check_attributes(attrs: &[ast::Attribute], fld: &MacroExpander) {\n-    for attr in attrs.iter() {\n-        feature_gate::check_attribute(&attr, &fld.cx.parse_sess.span_diagnostic,\n-                                      &fld.cx.parse_sess.codemap(),\n-                                      &fld.cx.ecfg.features.unwrap());\n-    }\n+// A trait for AST nodes and AST node lists into which macro invocations may expand.\n+trait MacroGenerable: Sized {\n+    // Expand the given MacResult using its appropriate `make_*` method.\n+    fn make_with<'a>(result: Box<MacResult + 'a>) -> Option<Self>;\n+\n+    // Fold this node or list of nodes using the given folder.\n+    fn fold_with<F: Folder>(self, folder: &mut F) -> Self;\n+\n+    // Return a placeholder expansion to allow compilation to continue after an erroring expansion.\n+    fn dummy(span: Span) -> Self;\n+\n+    // The user-friendly name of the node type (e.g. \"expression\", \"item\", etc.) for diagnostics.\n+    fn kind_name() -> &'static str;\n+}\n+\n+macro_rules! impl_macro_generable {\n+    ($($ty:ty: $kind_name:expr, .$make:ident, $(.$fold:ident)* $(lift .$fold_elt:ident)*,\n+               |$span:ident| $dummy:expr;)*) => { $(\n+        impl MacroGenerable for $ty {\n+            fn kind_name() -> &'static str { $kind_name }\n+            fn make_with<'a>(result: Box<MacResult + 'a>) -> Option<Self> { result.$make() }\n+            fn fold_with<F: Folder>(self, folder: &mut F) -> Self {\n+                $( folder.$fold(self) )*\n+                $( self.into_iter().flat_map(|item| folder. $fold_elt (item)).collect() )*\n+            }\n+            fn dummy($span: Span) -> Self { $dummy }\n+        }\n+    )* }\n+}\n+\n+impl_macro_generable! {\n+    P<ast::Expr>: \"expression\", .make_expr, .fold_expr, |span| DummyResult::raw_expr(span);\n+    P<ast::Pat>:  \"pattern\",    .make_pat,  .fold_pat,  |span| P(DummyResult::raw_pat(span));\n+    P<ast::Ty>:   \"type\",       .make_ty,   .fold_ty,   |span| DummyResult::raw_ty(span);\n+    SmallVector<ast::ImplItem>:\n+        \"impl item\", .make_impl_items, lift .fold_impl_item, |_span| SmallVector::zero();\n+    SmallVector<P<ast::Item>>:\n+        \"item\",      .make_items,      lift .fold_item,      |_span| SmallVector::zero();\n+    SmallVector<ast::Stmt>:\n+        \"statement\", .make_stmts,      lift .fold_stmt,      |_span| SmallVector::zero();\n }\n \n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n-    let expr_span = e.span;\n     return e.and_then(|ast::Expr {id, node, span, attrs}| match node {\n \n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ast::ExprKind::Mac(mac) => {\n-            if let Some(ref attrs) = attrs {\n-                check_attributes(attrs, fld);\n-            }\n-\n-            // Assert that we drop any macro attributes on the floor here\n-            drop(attrs);\n-\n-            let expanded_expr = match expand_mac_invoc(mac, span,\n-                                                       |r| r.make_expr(),\n-                                                       mark_expr, fld) {\n-                Some(expr) => expr,\n-                None => {\n-                    return DummyResult::raw_expr(span);\n-                }\n-            };\n-\n-            // Keep going, outside-in.\n-            let fully_expanded = fld.fold_expr(expanded_expr);\n-            fld.cx.bt_pop();\n-\n-            fully_expanded\n-        }\n-\n-        ast::ExprKind::InPlace(placer, value_expr) => {\n-            // Ensure feature-gate is enabled\n-            if !fld.cx.ecfg.features.unwrap().placement_in_syntax {\n-                feature_gate::emit_feature_err(\n-                    &fld.cx.parse_sess.span_diagnostic, \"placement_in_syntax\", expr_span,\n-                    feature_gate::GateIssue::Language, feature_gate::EXPLAIN_PLACEMENT_IN\n-                );\n-            }\n-\n-            let placer = fld.fold_expr(placer);\n-            let value_expr = fld.fold_expr(value_expr);\n-            fld.cx.expr(span, ast::ExprKind::InPlace(placer, value_expr))\n-                .with_attrs(fold_thin_attrs(attrs, fld))\n+            expand_mac_invoc(mac, None, attrs.into_attr_vec(), span, fld)\n         }\n \n         ast::ExprKind::While(cond, body, opt_ident) => {\n@@ -182,93 +178,154 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     });\n }\n \n-/// Expand a (not-ident-style) macro invocation. Returns the result\n-/// of expansion and the mark which must be applied to the result.\n-/// Our current interface doesn't allow us to apply the mark to the\n-/// result until after calling make_expr, make_items, etc.\n-fn expand_mac_invoc<T, F, G>(mac: ast::Mac,\n-                             span: codemap::Span,\n-                             parse_thunk: F,\n-                             mark_thunk: G,\n-                             fld: &mut MacroExpander)\n-                             -> Option<T> where\n-    F: for<'a> FnOnce(Box<MacResult+'a>) -> Option<T>,\n-    G: FnOnce(T, Mrk) -> T,\n+/// Expand a macro invocation. Returns the result of expansion.\n+fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attribute>, span: Span,\n+                       fld: &mut MacroExpander) -> T\n+    where T: MacroGenerable,\n {\n-    // it would almost certainly be cleaner to pass the whole\n-    // macro invocation in, rather than pulling it apart and\n-    // marking the tts and the ctxt separately. This also goes\n-    // for the other three macro invocation chunks of code\n-    // in this file.\n-\n-    let Mac_ { path: pth, tts, .. } = mac.node;\n-    if pth.segments.len() > 1 {\n-        fld.cx.span_err(pth.span,\n-                        \"expected macro name without module \\\n-                        separators\");\n-        // let compilation continue\n-        return None;\n-    }\n-    let extname = pth.segments[0].identifier.name;\n-    match fld.cx.syntax_env.find(extname) {\n-        None => {\n-            let mut err = fld.cx.struct_span_err(\n-                pth.span,\n-                &format!(\"macro undefined: '{}!'\",\n-                        &extname));\n+    // It would almost certainly be cleaner to pass the whole macro invocation in,\n+    // rather than pulling it apart and marking the tts and the ctxt separately.\n+    let Mac_ { path, tts, .. } = mac.node;\n+    let mark = fresh_mark();\n+\n+    fn mac_result<'a>(path: &ast::Path, ident: Option<Ident>, tts: Vec<TokenTree>, mark: Mrk,\n+                      attrs: Vec<ast::Attribute>, call_site: Span, fld: &'a mut MacroExpander)\n+                      -> Option<Box<MacResult + 'a>> {\n+        // Detect use of feature-gated or invalid attributes on macro invoations\n+        // since they will not be detected after macro expansion.\n+        for attr in attrs.iter() {\n+            feature_gate::check_attribute(&attr, &fld.cx.parse_sess.span_diagnostic,\n+                                          &fld.cx.parse_sess.codemap(),\n+                                          &fld.cx.ecfg.features.unwrap());\n+        }\n+\n+        if path.segments.len() > 1 {\n+            fld.cx.span_err(path.span, \"expected macro name without module separators\");\n+            return None;\n+        }\n+\n+        let extname = path.segments[0].identifier.name;\n+        let extension = if let Some(extension) = fld.cx.syntax_env.find(extname) {\n+            extension\n+        } else {\n+            let mut err = fld.cx.struct_span_err(path.span,\n+                                                 &format!(\"macro undefined: '{}!'\", &extname));\n             fld.cx.suggest_macro_name(&extname.as_str(), &mut err);\n             err.emit();\n+            return None;\n+        };\n \n-            // let compilation continue\n-            None\n-        }\n-        Some(rc) => match *rc {\n+        let ident = ident.unwrap_or(keywords::Invalid.ident());\n+        match *extension {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n+                if ident.name != keywords::Invalid.name() {\n+                    let msg =\n+                        format!(\"macro {}! expects no ident argument, given '{}'\", extname, ident);\n+                    fld.cx.span_err(path.span, &msg);\n+                    return None;\n+                }\n+\n                 fld.cx.bt_push(ExpnInfo {\n-                        call_site: span,\n-                        callee: NameAndSpan {\n-                            format: MacroBang(extname),\n-                            span: exp_span,\n-                            allow_internal_unstable: allow_internal_unstable,\n-                        },\n-                    });\n-                let fm = fresh_mark();\n-                let marked_before = mark_tts(&tts[..], fm);\n+                    call_site: call_site,\n+                    callee: NameAndSpan {\n+                        format: MacroBang(extname),\n+                        span: exp_span,\n+                        allow_internal_unstable: allow_internal_unstable,\n+                    },\n+                });\n \n                 // The span that we pass to the expanders we want to\n                 // be the root of the call stack. That's the most\n                 // relevant span and it's the actual invocation of\n                 // the macro.\n                 let mac_span = fld.cx.original_span();\n \n-                let opt_parsed = {\n-                    let expanded = expandfun.expand(fld.cx,\n-                                                    mac_span,\n-                                                    &marked_before[..]);\n-                    parse_thunk(expanded)\n+                let marked_tts = mark_tts(&tts[..], mark);\n+                Some(expandfun.expand(fld.cx, mac_span, &marked_tts))\n+            }\n+\n+            IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n+                if ident.name == keywords::Invalid.name() {\n+                    fld.cx.span_err(path.span,\n+                                    &format!(\"macro {}! expects an ident argument\", extname));\n+                    return None;\n                 };\n-                let parsed = match opt_parsed {\n-                    Some(e) => e,\n-                    None => {\n-                        fld.cx.span_err(\n-                            pth.span,\n-                            &format!(\"non-expression macro in expression position: {}\",\n-                                    extname\n-                                    ));\n-                        return None;\n+\n+                fld.cx.bt_push(ExpnInfo {\n+                    call_site: call_site,\n+                    callee: NameAndSpan {\n+                        format: MacroBang(extname),\n+                        span: tt_span,\n+                        allow_internal_unstable: allow_internal_unstable,\n                     }\n+                });\n+\n+                let marked_tts = mark_tts(&tts, mark);\n+                Some(expander.expand(fld.cx, call_site, ident, marked_tts))\n+            }\n+\n+            MacroRulesTT => {\n+                if ident.name == keywords::Invalid.name() {\n+                    fld.cx.span_err(path.span,\n+                                    &format!(\"macro {}! expects an ident argument\", extname));\n+                    return None;\n                 };\n-                Some(mark_thunk(parsed,fm))\n+\n+                fld.cx.bt_push(ExpnInfo {\n+                    call_site: call_site,\n+                    callee: NameAndSpan {\n+                        format: MacroBang(extname),\n+                        span: None,\n+                        // `macro_rules!` doesn't directly allow unstable\n+                        // (this is orthogonal to whether the macro it creates allows it)\n+                        allow_internal_unstable: false,\n+                    }\n+                });\n+\n+                // DON'T mark before expansion.\n+                fld.cx.insert_macro(ast::MacroDef {\n+                    ident: ident,\n+                    id: ast::DUMMY_NODE_ID,\n+                    span: call_site,\n+                    imported_from: None,\n+                    use_locally: true,\n+                    body: tts,\n+                    export: attr::contains_name(&attrs, \"macro_export\"),\n+                    allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n+                    attrs: attrs,\n+                });\n+\n+                // macro_rules! has a side effect but expands to nothing.\n+                fld.cx.bt_pop();\n+                None\n             }\n-            _ => {\n-                fld.cx.span_err(\n-                    pth.span,\n-                    &format!(\"'{}' is not a tt-style macro\",\n-                            extname));\n+\n+            MultiDecorator(..) | MultiModifier(..) => {\n+                fld.cx.span_err(path.span,\n+                                &format!(\"`{}` can only be used in attributes\", extname));\n                 None\n             }\n         }\n     }\n+\n+    let opt_expanded = T::make_with(match mac_result(&path, ident, tts, mark, attrs, span, fld) {\n+        Some(result) => result,\n+        None => return T::dummy(span),\n+    });\n+\n+    let expanded = if let Some(expanded) = opt_expanded {\n+        expanded\n+    } else {\n+        let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n+                          name = path.segments[0].identifier.name, kind = T::kind_name());\n+        fld.cx.span_err(path.span, &msg);\n+        return T::dummy(span);\n+    };\n+\n+    let marked = expanded.fold_with(&mut Marker { mark: mark });\n+    let fully_expanded = marked.fold_with(fld);\n+    fld.cx.bt_pop();\n+    fully_expanded\n }\n \n /// Rename loop label and expand its loop body\n@@ -367,141 +424,6 @@ fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool\n     false\n }\n \n-// Support for item-position macro invocations, exactly the same\n-// logic as for expression-position macro invocations.\n-pub fn expand_item_mac(it: P<ast::Item>,\n-                       fld: &mut MacroExpander) -> SmallVector<P<ast::Item>> {\n-    let (extname, path_span, tts, span, attrs, ident) = it.and_then(|it| match it.node {\n-        ItemKind::Mac(codemap::Spanned { node: Mac_ { path, tts, .. }, .. }) =>\n-            (path.segments[0].identifier.name, path.span, tts, it.span, it.attrs, it.ident),\n-        _ => fld.cx.span_bug(it.span, \"invalid item macro invocation\")\n-    });\n-\n-    check_attributes(&attrs, fld);\n-\n-    let fm = fresh_mark();\n-    let items = {\n-        let expanded = match fld.cx.syntax_env.find(extname) {\n-            None => {\n-                fld.cx.span_err(path_span,\n-                                &format!(\"macro undefined: '{}!'\",\n-                                        extname));\n-                // let compilation continue\n-                return SmallVector::zero();\n-            }\n-\n-            Some(rc) => match *rc {\n-                NormalTT(ref expander, tt_span, allow_internal_unstable) => {\n-                    if ident.name != keywords::Invalid.name() {\n-                        fld.cx\n-                            .span_err(path_span,\n-                                      &format!(\"macro {}! expects no ident argument, given '{}'\",\n-                                               extname,\n-                                               ident));\n-                        return SmallVector::zero();\n-                    }\n-                    fld.cx.bt_push(ExpnInfo {\n-                        call_site: span,\n-                        callee: NameAndSpan {\n-                            format: MacroBang(extname),\n-                            span: tt_span,\n-                            allow_internal_unstable: allow_internal_unstable,\n-                        }\n-                    });\n-                    // mark before expansion:\n-                    let marked_before = mark_tts(&tts[..], fm);\n-                    expander.expand(fld.cx, span, &marked_before[..])\n-                }\n-                IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n-                    if ident.name == keywords::Invalid.name() {\n-                        fld.cx.span_err(path_span,\n-                                        &format!(\"macro {}! expects an ident argument\",\n-                                                extname));\n-                        return SmallVector::zero();\n-                    }\n-                    fld.cx.bt_push(ExpnInfo {\n-                        call_site: span,\n-                        callee: NameAndSpan {\n-                            format: MacroBang(extname),\n-                            span: tt_span,\n-                            allow_internal_unstable: allow_internal_unstable,\n-                        }\n-                    });\n-                    // mark before expansion:\n-                    let marked_tts = mark_tts(&tts[..], fm);\n-                    expander.expand(fld.cx, span, ident, marked_tts)\n-                }\n-                MacroRulesTT => {\n-                    if ident.name == keywords::Invalid.name() {\n-                        fld.cx.span_err(path_span, \"macro_rules! expects an ident argument\");\n-                        return SmallVector::zero();\n-                    }\n-\n-                    fld.cx.bt_push(ExpnInfo {\n-                        call_site: span,\n-                        callee: NameAndSpan {\n-                            format: MacroBang(extname),\n-                            span: None,\n-                            // `macro_rules!` doesn't directly allow\n-                            // unstable (this is orthogonal to whether\n-                            // the macro it creates allows it)\n-                            allow_internal_unstable: false,\n-                        }\n-                    });\n-                    // DON'T mark before expansion.\n-\n-                    let allow_internal_unstable = attr::contains_name(&attrs,\n-                                                                      \"allow_internal_unstable\");\n-\n-                    let export = attr::contains_name(&attrs, \"macro_export\");\n-                    let def = ast::MacroDef {\n-                        ident: ident,\n-                        attrs: attrs,\n-                        id: ast::DUMMY_NODE_ID,\n-                        span: span,\n-                        imported_from: None,\n-                        export: export,\n-                        use_locally: true,\n-                        allow_internal_unstable: allow_internal_unstable,\n-                        body: tts,\n-                    };\n-                    fld.cx.insert_macro(def);\n-\n-                    // macro_rules! has a side effect but expands to nothing.\n-                    fld.cx.bt_pop();\n-                    return SmallVector::zero();\n-                }\n-                _ => {\n-                    fld.cx.span_err(span,\n-                                    &format!(\"{}! is not legal in item position\",\n-                                            extname));\n-                    return SmallVector::zero();\n-                }\n-            }\n-        };\n-\n-        expanded.make_items()\n-    };\n-\n-    let items = match items {\n-        Some(items) => {\n-            items.into_iter()\n-                .map(|i| mark_item(i, fm))\n-                .flat_map(|i| fld.fold_item(i).into_iter())\n-                .collect()\n-        }\n-        None => {\n-            fld.cx.span_err(path_span,\n-                            &format!(\"non-item macro in item position: {}\",\n-                                    extname));\n-            return SmallVector::zero();\n-        }\n-    };\n-\n-    fld.cx.bt_pop();\n-    items\n-}\n-\n /// Expand a stmt\n fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n     // perform all pending renames\n@@ -516,30 +438,8 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n         _ => return expand_non_macro_stmt(stmt, fld)\n     };\n \n-    if let Some(ref attrs) = attrs {\n-        check_attributes(attrs, fld);\n-    }\n-\n-    // Assert that we drop any macro attributes on the floor here\n-    drop(attrs);\n-\n-    let maybe_new_items =\n-        expand_mac_invoc(mac.unwrap(), stmt.span,\n-                         |r| r.make_stmts(),\n-                         |stmts, mark| stmts.move_map(|m| mark_stmt(m, mark)),\n-                         fld);\n-\n-    let mut fully_expanded = match maybe_new_items {\n-        Some(stmts) => {\n-            // Keep going, outside-in.\n-            let new_items = stmts.into_iter().flat_map(|s| {\n-                fld.fold_stmt(s).into_iter()\n-            }).collect();\n-            fld.cx.bt_pop();\n-            new_items\n-        }\n-        None => SmallVector::zero()\n-    };\n+    let mut fully_expanded: SmallVector<ast::Stmt> =\n+        expand_mac_invoc(mac.unwrap(), None, attrs.into_attr_vec(), stmt.span, fld);\n \n     // If this is a macro invocation with a semicolon, then apply that\n     // semicolon to the final statement produced by expansion.\n@@ -754,76 +654,10 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n         PatKind::Mac(_) => {}\n         _ => return noop_fold_pat(p, fld)\n     }\n-    p.map(|ast::Pat {node, span, ..}| {\n-        let (pth, tts) = match node {\n-            PatKind::Mac(mac) => (mac.node.path, mac.node.tts),\n+    p.and_then(|ast::Pat {node, span, ..}| {\n+        match node {\n+            PatKind::Mac(mac) => expand_mac_invoc(mac, None, Vec::new(), span, fld),\n             _ => unreachable!()\n-        };\n-        if pth.segments.len() > 1 {\n-            fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n-            return DummyResult::raw_pat(span);\n-        }\n-        let extname = pth.segments[0].identifier.name;\n-        let marked_after = match fld.cx.syntax_env.find(extname) {\n-            None => {\n-                fld.cx.span_err(pth.span,\n-                                &format!(\"macro undefined: '{}!'\",\n-                                        extname));\n-                // let compilation continue\n-                return DummyResult::raw_pat(span);\n-            }\n-\n-            Some(rc) => match *rc {\n-                NormalTT(ref expander, tt_span, allow_internal_unstable) => {\n-                    fld.cx.bt_push(ExpnInfo {\n-                        call_site: span,\n-                        callee: NameAndSpan {\n-                            format: MacroBang(extname),\n-                            span: tt_span,\n-                            allow_internal_unstable: allow_internal_unstable,\n-                        }\n-                    });\n-\n-                    let fm = fresh_mark();\n-                    let marked_before = mark_tts(&tts[..], fm);\n-                    let mac_span = fld.cx.original_span();\n-                    let pat = expander.expand(fld.cx,\n-                                              mac_span,\n-                                              &marked_before[..]).make_pat();\n-                    let expanded = match pat {\n-                        Some(e) => e,\n-                        None => {\n-                            fld.cx.span_err(\n-                                pth.span,\n-                                &format!(\n-                                    \"non-pattern macro in pattern position: {}\",\n-                                    extname\n-                                    )\n-                            );\n-                            return DummyResult::raw_pat(span);\n-                        }\n-                    };\n-\n-                    // mark after:\n-                    mark_pat(expanded,fm)\n-                }\n-                _ => {\n-                    fld.cx.span_err(span,\n-                                    &format!(\"{}! is not legal in pattern position\",\n-                                            extname));\n-                    return DummyResult::raw_pat(span);\n-                }\n-            }\n-        };\n-\n-        let fully_expanded =\n-            fld.fold_pat(marked_after).node.clone();\n-        fld.cx.bt_pop();\n-\n-        ast::Pat {\n-            id: ast::DUMMY_NODE_ID,\n-            node: fully_expanded,\n-            span: span\n         }\n     })\n }\n@@ -893,7 +727,13 @@ fn expand_annotatable(a: Annotatable,\n     let mut new_items: SmallVector<Annotatable> = match a {\n         Annotatable::Item(it) => match it.node {\n             ast::ItemKind::Mac(..) => {\n-                expand_item_mac(it, fld).into_iter().map(|i| Annotatable::Item(i)).collect()\n+                let new_items: SmallVector<P<ast::Item>> = it.and_then(|it| match it.node {\n+                    ItemKind::Mac(mac) =>\n+                        expand_mac_invoc(mac, Some(it.ident), it.attrs, it.span, fld),\n+                    _ => unreachable!(),\n+                });\n+\n+                new_items.into_iter().map(|i| Annotatable::Item(i)).collect()\n             }\n             ast::ItemKind::Mod(_) | ast::ItemKind::ForeignMod(_) => {\n                 let valid_ident =\n@@ -1077,25 +917,7 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n             span: fld.new_span(ii.span)\n         }),\n         ast::ImplItemKind::Macro(mac) => {\n-            check_attributes(&ii.attrs, fld);\n-\n-            let maybe_new_items =\n-                expand_mac_invoc(mac, ii.span,\n-                                 |r| r.make_impl_items(),\n-                                 |meths, mark| meths.move_map(|m| mark_impl_item(m, mark)),\n-                                 fld);\n-\n-            match maybe_new_items {\n-                Some(impl_items) => {\n-                    // expand again if necessary\n-                    let new_items = impl_items.into_iter().flat_map(|ii| {\n-                        expand_impl_item(ii, fld).into_iter()\n-                    }).collect();\n-                    fld.cx.bt_pop();\n-                    new_items\n-                }\n-                None => SmallVector::zero()\n-            }\n+            expand_mac_invoc(mac, None, ii.attrs, ii.span, fld)\n         }\n         _ => fold::noop_fold_impl_item(ii, fld)\n     }\n@@ -1139,25 +961,7 @@ pub fn expand_type(t: P<ast::Ty>, fld: &mut MacroExpander) -> P<ast::Ty> {\n     let t = match t.node.clone() {\n         ast::TyKind::Mac(mac) => {\n             if fld.cx.ecfg.features.unwrap().type_macros {\n-                let expanded_ty = match expand_mac_invoc(mac, t.span,\n-                                                         |r| r.make_ty(),\n-                                                         mark_ty,\n-                                                         fld) {\n-                    Some(ty) => ty,\n-                    None => {\n-                        return DummyResult::raw_ty(t.span);\n-                    }\n-                };\n-\n-                // Keep going, outside-in.\n-                let fully_expanded = fld.fold_ty(expanded_ty);\n-                fld.cx.bt_pop();\n-\n-                fully_expanded.map(|t| ast::Ty {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: t.node,\n-                    span: t.span,\n-                    })\n+                expand_mac_invoc(mac, None, Vec::new(), t.span, fld)\n             } else {\n                 feature_gate::emit_feature_err(\n                     &fld.cx.parse_sess.span_diagnostic,\n@@ -1426,38 +1230,6 @@ fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n     noop_fold_tts(tts, &mut Marker{mark:m})\n }\n \n-// apply a given mark to the given expr. Used following the expansion of a macro.\n-fn mark_expr(expr: P<ast::Expr>, m: Mrk) -> P<ast::Expr> {\n-    Marker{mark:m}.fold_expr(expr)\n-}\n-\n-// apply a given mark to the given pattern. Used following the expansion of a macro.\n-fn mark_pat(pat: P<ast::Pat>, m: Mrk) -> P<ast::Pat> {\n-    Marker{mark:m}.fold_pat(pat)\n-}\n-\n-// apply a given mark to the given stmt. Used following the expansion of a macro.\n-fn mark_stmt(stmt: ast::Stmt, m: Mrk) -> ast::Stmt {\n-    Marker{mark:m}.fold_stmt(stmt)\n-        .expect_one(\"marking a stmt didn't return exactly one stmt\")\n-}\n-\n-// apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_item(expr: P<ast::Item>, m: Mrk) -> P<ast::Item> {\n-    Marker{mark:m}.fold_item(expr)\n-        .expect_one(\"marking an item didn't return exactly one item\")\n-}\n-\n-// apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_impl_item(ii: ast::ImplItem, m: Mrk) -> ast::ImplItem {\n-    Marker{mark:m}.fold_impl_item(ii)\n-        .expect_one(\"marking an impl item didn't return exactly one impl item\")\n-}\n-\n-fn mark_ty(ty: P<ast::Ty>, m: Mrk) -> P<ast::Ty> {\n-    Marker { mark: m }.fold_ty(ty)\n-}\n-\n /// Check that there are no macro invocations left in the AST:\n pub fn check_for_macros(sess: &parse::ParseSess, krate: &ast::Crate) {\n     visit::walk_crate(&mut MacroExterminator{sess:sess}, krate);"}, {"sha": "dbef06f7aa495532b360016a2c5e258bb88d8cd3", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc91467db05ba6ee2a2a72c440e8c48008abb7a3/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc91467db05ba6ee2a2a72c440e8c48008abb7a3/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=dc91467db05ba6ee2a2a72c440e8c48008abb7a3", "patch": "@@ -997,6 +997,9 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n             ast::ExprKind::Try(..) => {\n                 gate_feature_post!(&self, question_mark, e.span, \"the `?` operator is not stable\");\n             }\n+            ast::ExprKind::InPlace(..) => {\n+                gate_feature_post!(&self, placement_in_syntax, e.span, EXPLAIN_PLACEMENT_IN);\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);"}, {"sha": "a69188da58d1667686ab896b9d0d005805b76337", "filename": "src/test/compile-fail/macro-error.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dc91467db05ba6ee2a2a72c440e8c48008abb7a3/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc91467db05ba6ee2a2a72c440e8c48008abb7a3/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs?ref=dc91467db05ba6ee2a2a72c440e8c48008abb7a3", "patch": "@@ -8,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Check that we report errors at macro definition, not expansion.\n+#![feature(type_macros)]\n \n macro_rules! foo {\n     ($a:expr) => $a; //~ ERROR macro rhs must be delimited\n }\n \n fn main() {\n-    foo!(0);\n+    foo!(0); // Check that we report errors at macro definition, not expansion.\n+\n+    let _: cfg!(foo) = (); //~ ERROR non-type macro in type position\n+    derive!(); //~ ERROR `derive` can only be used in attributes\n }"}]}