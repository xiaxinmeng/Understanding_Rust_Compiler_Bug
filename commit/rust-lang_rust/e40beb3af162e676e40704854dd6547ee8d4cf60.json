{"sha": "e40beb3af162e676e40704854dd6547ee8d4cf60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MGJlYjNhZjE2MmU2NzZlNDA3MDQ4NTRkZDY1NDdlZThkNGNmNjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-11T16:56:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-11T16:56:17Z"}, "message": "Auto merge of #41913 - nikomatsakis:issue-41849-variance-cycle, r=eddyb\n\ndo not fetch variance for items when equating\n\nFixes #41849. Problem was that evaluating the constant expression\nrequired evaluating a trait, which would equate types, which would\nrequest variance information, which it would then discard. However,\ncomputing the variance information would require determining the type of\na field, which would evaluate the constant expression.\n\n(This problem will potentially arise *later* as we move to more sophisticated\nconstants, however, where we need to check subtyping. We can tackle that\nwhen we come to it.)\n\nr? @eddyb", "tree": {"sha": "ead43ed861f59e71d04e44018e1458506dc366a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ead43ed861f59e71d04e44018e1458506dc366a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e40beb3af162e676e40704854dd6547ee8d4cf60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e40beb3af162e676e40704854dd6547ee8d4cf60", "html_url": "https://github.com/rust-lang/rust/commit/e40beb3af162e676e40704854dd6547ee8d4cf60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e40beb3af162e676e40704854dd6547ee8d4cf60/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cc3358e4f1c4a79685745a461a1be1ce784b88a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cc3358e4f1c4a79685745a461a1be1ce784b88a", "html_url": "https://github.com/rust-lang/rust/commit/2cc3358e4f1c4a79685745a461a1be1ce784b88a"}, {"sha": "d22d1feae19d4709d0031264ab0eddec4b309905", "url": "https://api.github.com/repos/rust-lang/rust/commits/d22d1feae19d4709d0031264ab0eddec4b309905", "html_url": "https://github.com/rust-lang/rust/commit/d22d1feae19d4709d0031264ab0eddec4b309905"}], "stats": {"total": 107, "additions": 84, "deletions": 23}, "files": [{"sha": "f9ffaee81f1573de6c636e685d0418c45f0e9e33", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e40beb3af162e676e40704854dd6547ee8d4cf60/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40beb3af162e676e40704854dd6547ee8d4cf60/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=e40beb3af162e676e40704854dd6547ee8d4cf60", "patch": "@@ -11,9 +11,12 @@\n use super::combine::{CombineFields, RelationDir};\n use super::{Subtype};\n \n+use hir::def_id::DefId;\n+\n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n-use ty::relate::{Relate, RelateResult, TypeRelation};\n+use ty::subst::Substs;\n+use ty::relate::{self, Relate, RelateResult, TypeRelation};\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n pub struct Equate<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n@@ -38,6 +41,22 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n+    fn relate_item_substs(&mut self,\n+                          _item_def_id: DefId,\n+                          a_subst: &'tcx Substs<'tcx>,\n+                          b_subst: &'tcx Substs<'tcx>)\n+                          -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n+    {\n+        // NB: Once we are equating types, we don't care about\n+        // variance, so don't try to lookup the variance here. This\n+        // also avoids some cycles (e.g. #41849) since looking up\n+        // variance requires computing types which can require\n+        // performing trait matching (which then performs equality\n+        // unification).\n+\n+        relate::relate_substs(self, None, a_subst, b_subst)\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n                                              _: ty::Variance,\n                                              a: &T,"}, {"sha": "bbe682e74bc04b6dcfe920808d1faae0df10b883", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e40beb3af162e676e40704854dd6547ee8d4cf60/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40beb3af162e676e40704854dd6547ee8d4cf60/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=e40beb3af162e676e40704854dd6547ee8d4cf60", "patch": "@@ -51,6 +51,24 @@ pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n         Relate::relate(self, a, b)\n     }\n \n+    /// Relate the two substitutions for the given item. The default\n+    /// is to look up the variance for the item and proceed\n+    /// accordingly.\n+    fn relate_item_substs(&mut self,\n+                          item_def_id: DefId,\n+                          a_subst: &'tcx Substs<'tcx>,\n+                          b_subst: &'tcx Substs<'tcx>)\n+                          -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n+    {\n+        debug!(\"relate_item_substs(item_def_id={:?}, a_subst={:?}, b_subst={:?})\",\n+               item_def_id,\n+               a_subst,\n+               b_subst);\n+\n+        let opt_variances = self.tcx().variances_of(item_def_id);\n+        relate_substs(self, Some(&opt_variances), a_subst, b_subst)\n+    }\n+\n     /// Switch variance for the purpose of relating `a` and `b`.\n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n                                              variance: ty::Variance,\n@@ -109,25 +127,6 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n     }\n }\n \n-// substitutions are not themselves relatable without more context,\n-// but they is an important subroutine for things that ARE relatable,\n-// like traits etc.\n-fn relate_item_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n-                                         item_def_id: DefId,\n-                                         a_subst: &'tcx Substs<'tcx>,\n-                                         b_subst: &'tcx Substs<'tcx>)\n-                                         -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n-    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n-{\n-    debug!(\"substs: item_def_id={:?} a_subst={:?} b_subst={:?}\",\n-           item_def_id,\n-           a_subst,\n-           b_subst);\n-\n-    let opt_variances = relation.tcx().variances_of(item_def_id);\n-    relate_substs(relation, Some(&opt_variances), a_subst, b_subst)\n-}\n-\n pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                                         variances: Option<&Vec<ty::Variance>>,\n                                         a_subst: &'tcx Substs<'tcx>,\n@@ -291,7 +290,7 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n         if a.def_id != b.def_id {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n         } else {\n-            let substs = relate_item_substs(relation, a.def_id, a.substs, b.substs)?;\n+            let substs = relation.relate_item_substs(a.def_id, a.substs, b.substs)?;\n             Ok(ty::TraitRef { def_id: a.def_id, substs: substs })\n         }\n     }\n@@ -308,7 +307,7 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n         if a.def_id != b.def_id {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n         } else {\n-            let substs = relate_item_substs(relation, a.def_id, a.substs, b.substs)?;\n+            let substs = relation.relate_item_substs(a.def_id, a.substs, b.substs)?;\n             Ok(ty::ExistentialTraitRef { def_id: a.def_id, substs: substs })\n         }\n     }\n@@ -372,7 +371,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         (&ty::TyAdt(a_def, a_substs), &ty::TyAdt(b_def, b_substs))\n             if a_def == b_def =>\n         {\n-            let substs = relate_item_substs(relation, a_def.did, a_substs, b_substs)?;\n+            let substs = relation.relate_item_substs(a_def.did, a_substs, b_substs)?;\n             Ok(tcx.mk_adt(a_def, substs))\n         }\n "}, {"sha": "0557a6ef376b656a19e04bb0fb8eb9ef2c7d8392", "filename": "src/test/run-pass/issue-41849-variance-req.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e40beb3af162e676e40704854dd6547ee8d4cf60/src%2Ftest%2Frun-pass%2Fissue-41849-variance-req.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40beb3af162e676e40704854dd6547ee8d4cf60/src%2Ftest%2Frun-pass%2Fissue-41849-variance-req.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41849-variance-req.rs?ref=e40beb3af162e676e40704854dd6547ee8d4cf60", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #41849.\n+\n+use std::ops::Mul;\n+\n+const C: usize = 1;\n+const CAPACITY: usize = 1 * C;\n+\n+struct A<X> {\n+    f: [X; CAPACITY],\n+}\n+\n+struct B<T> {\n+    f: T,\n+}\n+\n+impl<T> Mul for B<T> {\n+    type Output = Self;\n+    fn mul(self, _rhs: B<T>) -> Self::Output {\n+        self\n+    }\n+}\n+\n+impl<T> Mul<usize> for B<T> {\n+    type Output = Self;\n+    fn mul(self, _rhs: usize) -> Self::Output {\n+        self\n+    }\n+}\n+\n+fn main() {\n+    let a = A { f: [1] };\n+    let _ = B { f: a };\n+}"}]}