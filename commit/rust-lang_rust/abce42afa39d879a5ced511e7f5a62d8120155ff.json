{"sha": "abce42afa39d879a5ced511e7f5a62d8120155ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiY2U0MmFmYTM5ZDg3OWE1Y2VkNTExZTdmNWE2MmQ4MTIwMTU1ZmY=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-19T18:55:12Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-20T15:41:19Z"}, "message": "Address review comments", "tree": {"sha": "b3fc6ecacf5159db9ecea7ce003da04805d9e8e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3fc6ecacf5159db9ecea7ce003da04805d9e8e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abce42afa39d879a5ced511e7f5a62d8120155ff", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abce42afa39d879a5ced511e7f5a62d8120155ff", "html_url": "https://github.com/rust-lang/rust/commit/abce42afa39d879a5ced511e7f5a62d8120155ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abce42afa39d879a5ced511e7f5a62d8120155ff/comments", "author": null, "committer": null, "parents": [{"sha": "76f7eeef52fac46f74c84f4fc05073745c741cb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/76f7eeef52fac46f74c84f4fc05073745c741cb3", "html_url": "https://github.com/rust-lang/rust/commit/76f7eeef52fac46f74c84f4fc05073745c741cb3"}], "stats": {"total": 219, "additions": 153, "deletions": 66}, "files": [{"sha": "6d8b178ba0014092bd77de97831a92279b43a2c1", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 58, "deletions": 48, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=abce42afa39d879a5ced511e7f5a62d8120155ff", "patch": "@@ -51,13 +51,13 @@ impl Usefulness {\n }\n \n fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n-    ty::with_path(tcx, id, |path| Path {\n+    ty::with_path(tcx, id, |mut path| Path {\n         global: false,\n-        segments: path.map(|elem| PathSegment {\n+        segments: path.last().map(|elem| PathSegment {\n             identifier: Ident::new(elem.name()),\n             lifetimes: vec!(),\n             types: OwnedSlice::empty()\n-        }).collect(),\n+        }).move_iter().collect(),\n         span: DUMMY_SP,\n     })\n }\n@@ -100,10 +100,11 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n                                                 arm.pats.as_slice());\n             }\n \n+            // Second, check for unreachable arms.\n             check_arms(cx, arms.as_slice());\n-            /* Check for exhaustiveness */\n-             // Check for empty enum, because is_useful only works on inhabited\n-             // types.\n+\n+            // Finally, check if the whole match expression is exhaustive.\n+            // Check for empty enum, because is_useful only works on inhabited types.\n             let pat_ty = node_id_to_type(cx.tcx, scrut.id);\n             if (*arms).is_empty() {\n                if !type_is_empty(cx.tcx, pat_ty) {\n@@ -180,11 +181,11 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &Matrix) {\n         }\n         Useful(pats) => {\n             let witness = match pats.as_slice() {\n-                [ref witness] => witness.clone(),\n+                [witness] => witness,\n                 [] => wild(),\n                 _ => unreachable!()\n             };\n-            let msg = format!(\"non-exhaustive patterns: {0} not covered\", pat_to_str(&*witness));\n+            let msg = format!(\"non-exhaustive patterns: `{0}` not covered\", pat_to_str(&*witness));\n             cx.tcx.sess.span_err(sp, msg.as_slice());\n         }\n     }\n@@ -193,7 +194,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &Matrix) {\n #[deriving(Clone, PartialEq)]\n enum ctor {\n     single,\n-    variant(DefId),\n+    variant(DefId /* variant */, bool /* is_structure */),\n     val(const_val),\n     range(const_val, const_val),\n     vec(uint)\n@@ -215,23 +216,23 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &ctor, pats: Vec<Gc<Pat>>, lty:\n     let pat = match ty::get(lty).sty {\n         ty::ty_tup(_) => PatTup(pats),\n \n-        ty::ty_enum(_, _) => {\n-            let vid = match ctor {\n-                &variant(vid) => vid,\n-                _ => unreachable!()\n+        ty::ty_enum(cid, _) | ty::ty_struct(cid, _)  => {\n+            let (vid, is_structure) = match ctor {\n+                &variant(vid, is_structure) => (vid, is_structure),\n+                _ => (cid, true)\n             };\n-            PatEnum(def_to_path(cx.tcx, vid), Some(pats))\n-        },\n-\n-        ty::ty_struct(cid, _) => {\n-            let fields = ty::lookup_struct_fields(cx.tcx, cid);\n-            let field_pats = fields.move_iter()\n-                .zip(pats.iter())\n-                .map(|(field, pat)| FieldPat {\n-                    ident: Ident::new(field.name),\n-                    pat: pat.clone()\n-                }).collect();\n-            PatStruct(def_to_path(cx.tcx, cid), field_pats, false)\n+            if is_structure {\n+                let fields = ty::lookup_struct_fields(cx.tcx, vid);\n+                let field_pats = fields.move_iter()\n+                    .zip(pats.iter())\n+                    .map(|(field, pat)| FieldPat {\n+                        ident: Ident::new(field.name),\n+                        pat: pat.clone()\n+                    }).collect();\n+                PatStruct(def_to_path(cx.tcx, vid), field_pats, false)\n+            } else {\n+                PatEnum(def_to_path(cx.tcx, vid), Some(pats))\n+            }\n         },\n \n         ty::ty_rptr(_, ty::mt { ty: ty, .. }) => {\n@@ -307,7 +308,10 @@ fn all_constructors(cx: &MatchCheckCtxt, m: &Matrix, left_ty: ty::t) -> Vec<ctor\n         },\n \n         ty::ty_enum(eid, _) =>\n-            ty::enum_variants(cx.tcx, eid).iter().map(|va| variant(va.id)).collect(),\n+            ty::enum_variants(cx.tcx, eid)\n+                .iter()\n+                .map(|va| variant(va.id, va.arg_names.is_some()))\n+                .collect(),\n \n         ty::ty_vec(_, None) =>\n             vec_constructors(m),\n@@ -389,8 +393,8 @@ fn is_useful(cx: &MatchCheckCtxt, m: &Matrix, v: &[Gc<Pat>],\n             },\n \n             Some(ctor) => {\n-                let matrix = &m.iter().filter_map(|r| default(cx, r.as_slice())).collect();\n-                match is_useful(cx, matrix, v.tail(), witness) {\n+                let matrix = m.iter().filter_map(|r| default(cx, r.as_slice())).collect();\n+                match is_useful(cx, &matrix, v.tail(), witness) {\n                     Useful(pats) => Useful(match witness {\n                         ConstructWitness => {\n                             let arity = constructor_arity(cx, &ctor, left_ty);\n@@ -424,19 +428,28 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, m: &Matrix, v: &[Gc<Pat>],\n fn pat_ctor_id(cx: &MatchCheckCtxt, left_ty: ty::t, p: Gc<Pat>) -> Option<ctor> {\n     let pat = raw_pat(p);\n     match pat.node {\n-        PatIdent(..) | PatEnum(..) | PatStruct(..) =>\n+        PatIdent(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n                 Some(&DefStatic(did, false)) => {\n                     let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                     Some(val(eval_const_expr(cx.tcx, &*const_expr)))\n                 },\n-                Some(&DefVariant(_, id, _)) =>\n-                    Some(variant(id)),\n-                _ => match pat.node {\n-                    PatEnum(..) | PatStruct(..) => Some(single),\n-                    PatIdent(..) => None,\n-                    _ => unreachable!()\n-                }\n+                Some(&DefVariant(_, id, is_structure)) => Some(variant(id, is_structure)),\n+                _ => None\n+            },\n+        PatEnum(..) =>\n+            match cx.tcx.def_map.borrow().find(&pat.id) {\n+                Some(&DefStatic(did, false)) => {\n+                    let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n+                    Some(val(eval_const_expr(cx.tcx, &*const_expr)))\n+                },\n+                Some(&DefVariant(_, id, is_structure)) => Some(variant(id, is_structure)),\n+                _ => Some(single)\n+            },\n+        PatStruct(..) =>\n+            match cx.tcx.def_map.borrow().find(&pat.id) {\n+                Some(&DefVariant(_, id, is_structure)) => Some(variant(id, is_structure)),\n+                _ => Some(single)\n             },\n         PatLit(expr) =>\n             Some(val(eval_const_expr(cx.tcx, &*expr))),\n@@ -485,7 +498,7 @@ fn constructor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n         },\n         ty::ty_enum(eid, _) => {\n             match *ctor {\n-                variant(id) => enum_variant_with_id(cx.tcx, eid, id).args.len(),\n+                variant(id, _) => enum_variant_with_id(cx.tcx, eid, id).args.len(),\n                 _ => unreachable!()\n             }\n         }\n@@ -532,13 +545,10 @@ fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n         &PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().find_copy(pat_id);\n             match opt_def {\n-                Some(DefVariant(_, id, _)) => {\n-                    if variant(id) == *ctor_id {\n-                        Some(vec!())\n-                    } else {\n-                        None\n-                    }\n-                }\n+                Some(DefVariant(_, id, _)) => match *ctor_id {\n+                    variant(vid, _) if vid == id => Some(vec!()),\n+                    _ => None\n+                },\n                 Some(DefStatic(did, _)) => {\n                     let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                     let e_v = eval_const_expr(cx.tcx, &*const_expr);\n@@ -571,7 +581,7 @@ fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n                         }\n                     }\n                 }\n-                DefVariant(_, id, _) if variant(id) != *ctor_id => None,\n+                DefVariant(_, id, _) if variant(id, false) != *ctor_id => None,\n                 DefVariant(..) | DefFn(..) | DefStruct(..) => {\n                     Some(match args {\n                         &Some(ref args) => args.clone(),\n@@ -586,7 +596,7 @@ fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n             // Is this a struct or an enum variant?\n             let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n             let class_id = match def {\n-                DefVariant(_, variant_id, _) => if variant(variant_id) == *ctor_id {\n+                DefVariant(_, variant_id, _) => if *ctor_id == variant(variant_id, true) {\n                     Some(variant_id)\n                 } else {\n                     None\n@@ -687,7 +697,7 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n     match is_refutable(cx, loc.pat) {\n         Some(pat) => {\n             let msg = format!(\n-                \"refutable pattern in {} binding: {} not covered\",\n+                \"refutable pattern in {} binding: `{}` not covered\",\n                 name, pat_to_str(&*pat)\n             );\n             cx.tcx.sess.span_err(loc.pat.span, msg.as_slice());\n@@ -709,7 +719,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n         match is_refutable(cx, input.pat) {\n             Some(pat) => {\n                 let msg = format!(\n-                    \"refutable pattern in function argument: {} not covered\",\n+                    \"refutable pattern in function argument: `{}` not covered\",\n                     pat_to_str(&*pat)\n                 );\n                 cx.tcx.sess.span_err(input.pat.span, msg.as_slice());"}, {"sha": "e198653165a61a5e1216ae67cd66ee83a7e9e766", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=abce42afa39d879a5ced511e7f5a62d8120155ff", "patch": "@@ -701,10 +701,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                 Some(format!(\"a fixed vector pattern of size {}\", min_len)),\n \n             _ => None\n-        }).and_then(|message| {\n-            check_err(message);\n-            Some(())\n-        });\n+        }).map(check_err);\n \n         for elt in before.iter() {\n             check_pat(pcx, &**elt, elt_type);"}, {"sha": "3d9c7401ded24d92d4acc5c3dc511b086b0c8e51", "filename": "src/test/compile-fail/issue-2111.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs?ref=abce42afa39d879a5ced511e7f5a62d8120155ff", "patch": "@@ -10,7 +10,7 @@\n \n fn foo(a: Option<uint>, b: Option<uint>) {\n   match (a,b) {\n-  //~^ ERROR: non-exhaustive patterns: (core::option::None, core::option::None) not covered\n+  //~^ ERROR: non-exhaustive patterns: `(None, None)` not covered\n     (Some(a), Some(b)) if a == b => { }\n     (Some(_), None) |\n     (None, Some(_)) => { }"}, {"sha": "d589680b0ecdac43dc1aed0f8a0e17fd4caff860", "filename": "src/test/compile-fail/issue-4321.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Ftest%2Fcompile-fail%2Fissue-4321.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Ftest%2Fcompile-fail%2Fissue-4321.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4321.rs?ref=abce42afa39d879a5ced511e7f5a62d8120155ff", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let tup = (true, true);\n-    println!(\"foo {:}\", match tup { //~ ERROR non-exhaustive patterns: (true, false) not covered\n+    println!(\"foo {:}\", match tup { //~ ERROR non-exhaustive patterns: `(true, false)` not covered\n         (false, false) => \"foo\",\n         (false, true) => \"bar\",\n         (true, true) => \"baz\""}, {"sha": "483168bb8bcfa1ed1585feb453b5506a3d2fdad8", "filename": "src/test/compile-fail/non-exhaustive-match-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs?ref=abce42afa39d879a5ced511e7f5a62d8120155ff", "patch": "@@ -13,7 +13,7 @@ enum u { c, d }\n \n fn main() {\n   let x = a(c);\n-  match x { //~ ERROR non-exhaustive patterns: a(c) not covered\n+  match x { //~ ERROR non-exhaustive patterns: `a(c)` not covered\n       a(d) => { fail!(\"hello\"); }\n       b => { fail!(\"goodbye\"); }\n     }"}, {"sha": "cd78419439a96952db491d31ac1cfeb00be9850d", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=abce42afa39d879a5ced511e7f5a62d8120155ff", "patch": "@@ -12,21 +12,21 @@ enum t { a, b, }\n \n fn main() {\n     let x = a;\n-    match x { b => { } } //~ ERROR non-exhaustive patterns: a not covered\n-    match true { //~ ERROR non-exhaustive patterns: false not covered\n+    match x { b => { } } //~ ERROR non-exhaustive patterns: `a` not covered\n+    match true { //~ ERROR non-exhaustive patterns: `false` not covered\n       true => {}\n     }\n-    match Some(10) { //~ ERROR non-exhaustive patterns: core::option::Some(_) not covered\n+    match Some(10) { //~ ERROR non-exhaustive patterns: `Some(_)` not covered\n       None => {}\n     }\n-    match (2, 3, 4) { //~ ERROR non-exhaustive patterns: (_, _, _) not covered\n+    match (2, 3, 4) { //~ ERROR non-exhaustive patterns: `(_, _, _)` not covered\n       (_, _, 4) => {}\n     }\n-    match (a, a) { //~ ERROR non-exhaustive patterns: (a, a) not covered\n+    match (a, a) { //~ ERROR non-exhaustive patterns: `(a, a)` not covered\n       (a, b) => {}\n       (b, a) => {}\n     }\n-    match a { //~ ERROR non-exhaustive patterns: b not covered\n+    match a { //~ ERROR non-exhaustive patterns: `b` not covered\n       a => {}\n     }\n     // This is exhaustive, though the algorithm got it wrong at one point\n@@ -37,7 +37,7 @@ fn main() {\n     }\n     let vec = vec!(Some(42), None, Some(21));\n     let vec: &[Option<int>] = vec.as_slice();\n-    match vec { //~ ERROR non-exhaustive patterns: [] not covered\n+    match vec { //~ ERROR non-exhaustive patterns: `[]` not covered\n         [Some(..), None, ..tail] => {}\n         [Some(..), Some(..), ..tail] => {}\n         [None] => {}\n@@ -50,7 +50,7 @@ fn main() {\n     }\n     let vec = vec!(0.5);\n     let vec: &[f32] = vec.as_slice();\n-    match vec { //~ ERROR non-exhaustive patterns: [_, _, _, _] not covered\n+    match vec { //~ ERROR non-exhaustive patterns: `[_, _, _, _]` not covered\n         [0.1, 0.2, 0.3] => (),\n         [0.1, 0.2] => (),\n         [0.1] => (),"}, {"sha": "22e93d70858e4deb68220fabdfd0f9cc6adbea50", "filename": "src/test/compile-fail/non-exhaustive-pattern-witness.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs?ref=abce42afa39d879a5ced511e7f5a62d8120155ff", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(struct_variant)]\n+\n+struct Foo {\n+    first: bool,\n+    second: Option<[uint, ..4]>\n+}\n+\n+enum Color {\n+    Red,\n+    Green,\n+    CustomRGBA { a: bool, r: u8, g: u8, b: u8 }\n+}\n+\n+fn struct_with_a_nested_enum_and_vector() {\n+    match Foo { first: true, second: None } {\n+    //~^ ERROR non-exhaustive patterns: `Foo{first: false, second: Some([_, _, _, _])}` not covered\n+        Foo { first: true, second: None } => (),\n+        Foo { first: true, second: Some(_) } => (),\n+        Foo { first: false, second: None } => (),\n+        Foo { first: false, second: Some([1u, 2u, 3u, 4u]) } => ()\n+    }\n+}\n+\n+fn enum_with_multiple_missing_variants() {\n+    match Red {\n+    //~^ ERROR non-exhaustive patterns: `Red` not covered\n+        CustomRGBA { .. } => ()\n+    }\n+}\n+\n+fn enum_struct_variant() {\n+    match Red {\n+    //~^ ERROR non-exhaustive patterns: `CustomRGBA{a: true, r: _, g: _, b: _}` not covered\n+        Red => (),\n+        Green => (),\n+        CustomRGBA { a: false, r: _, g: _, b: 0 } => (),\n+        CustomRGBA { a: false, r: _, g: _, b: _ } => ()\n+    }\n+}\n+\n+enum Enum {\n+    First,\n+    Second(bool)\n+}\n+\n+fn vectors_with_nested_enums() {\n+    let x: &'static [Enum] = [First, Second(false)];\n+    match x {\n+    //~^ ERROR non-exhaustive patterns: `[Second(true), Second(false)]` not covered\n+        [] => (),\n+        [_] => (),\n+        [First, _] => (),\n+        [Second(true), First] => (),\n+        [Second(true), Second(true)] => (),\n+        [Second(false), _] => (),\n+        [_, _, ..tail, _] => ()\n+    }\n+}\n+\n+fn main() {\n+    struct_with_a_nested_enum_and_vector();\n+    enum_with_multiple_missing_variants();\n+    enum_struct_variant();\n+}\n\\ No newline at end of file"}, {"sha": "9128ee68e26c5baec9c95c42620f8b62799c2898", "filename": "src/test/compile-fail/refutable-pattern-errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-errors.rs?ref=abce42afa39d879a5ced511e7f5a62d8120155ff", "patch": "@@ -10,9 +10,9 @@\n \n \n fn func((1, (Some(1), 2..3)): (int, (Option<int>, int))) { }\n-//~^ ERROR refutable pattern in function argument: (_, _) not covered\n+//~^ ERROR refutable pattern in function argument: `(_, _)` not covered\n \n fn main() {\n     let (1, (Some(1), 2..3)) = (1, (None, 2));\n-    //~^ ERROR refutable pattern in local binding: (_, _) not covered\n+    //~^ ERROR refutable pattern in local binding: `(_, _)` not covered\n }"}, {"sha": "954d4b23e30faa942734b7a752d885591b0116d4", "filename": "src/test/compile-fail/refutable-pattern-in-fn-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-in-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-in-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-in-fn-arg.rs?ref=abce42afa39d879a5ced511e7f5a62d8120155ff", "patch": "@@ -10,6 +10,6 @@\n \n fn main() {\n     let f = |3: int| println!(\"hello\");\n-    //~^ ERROR refutable pattern in function argument: _ not covered\n+    //~^ ERROR refutable pattern in function argument: `_` not covered\n     f(4);\n }"}, {"sha": "52c2d57753a14abe514a1b60282ce5422dc3b7e3", "filename": "src/test/run-pass/issue-7784.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abce42afa39d879a5ced511e7f5a62d8120155ff/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7784.rs?ref=abce42afa39d879a5ced511e7f5a62d8120155ff", "patch": "@@ -27,4 +27,10 @@ fn main() {\n     let [a, _, _, d] = bar(\"baz\", \"foo\");\n     assert_eq!(a, \"baz\");\n     assert_eq!(d, \"baz\");\n+\n+    let out = bar(\"baz\", \"foo\");\n+    let [a, ..xs, d] = out;\n+    assert_eq!(a, \"baz\");\n+    assert!(xs == [\"foo\", \"foo\"]);\n+    assert_eq!(d, \"baz\");\n }\n\\ No newline at end of file"}]}