{"sha": "090461475102cda8c42a7b4c65e25d0d38b27db8", "node_id": "C_kwDOAAsO6NoAKDA5MDQ2MTQ3NTEwMmNkYThjNDJhN2I0YzY1ZTI1ZDBkMzhiMjdkYjg", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-01-08T20:43:22Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-01-18T19:13:29Z"}, "message": "Render more readable macro matchers in rustdoc", "tree": {"sha": "22a5ee19d7d0874a20a0bd806a095ecafae49e1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22a5ee19d7d0874a20a0bd806a095ecafae49e1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/090461475102cda8c42a7b4c65e25d0d38b27db8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmHnEVkACgkQ+boUO5X/\nbYIilhAAuqlLdz3LH9Jkj+sOROUED0WVKSbY1EgfGjk9KtA9DnILa72LDsIzah9v\n+r87CCoJc2gYX7aA21RYKo9GZuBJAsrLu20S+n5XdCJYM7wB3Od+vRbhhMx8Twue\nQ46hfmwce2ZxuZjSMfuMjj/cm05UlhGAKoAbsbAYcrH5983mfnpIpmPJLlMeTz8x\nFS+h/IrRzahOOhpiTD09fX2ENbqiVDV4S+I5sx0zeZ1LqqU18TUpBVGgYN2frkQn\nTPfjRcz5EK/bt07pYHW8Ft0LMSXyoftdrbpcBcnehpe5BvI+OF6vpF/my+TBAr/4\ns9xsEoQUT1cwphxgvdhl97M4Qb6ZY3zoP7gJgLi+so2DDFNyPbCnGdGOKMEin2MP\nLJq2XZDfBeWqUgGjp9SfJ4cz0CBKbuABNymtM/t/LG4oZcIslh3+360v/oyRgUqb\nSkz0np18owSBhjjo9XcleFKg49j8mijHb4q4ELvE4I8rU62+LResj2c2/E9VQEd6\nDhZJf9gqgMDYHuMz5fLZlNoWoQvnURboL3/rc9402xKBUmtqsLC/L3wbHe83o9RH\ngd2o/i2gKzMLS1QCyanLgEL/uq2PIGAkPMx1rOk626Tcoj7soov1YplstZgykXJd\njhj5pgJ503G+nwHWF2xj4xu9HCnqd9f6r+b9ZF485PvfYoWQqoY=\n=oMkI\n-----END PGP SIGNATURE-----", "payload": "tree 22a5ee19d7d0874a20a0bd806a095ecafae49e1f\nparent d950c1b2000371253e026281cbfac30857b04470\nauthor David Tolnay <dtolnay@gmail.com> 1641674602 -0800\ncommitter David Tolnay <dtolnay@gmail.com> 1642533209 -0800\n\nRender more readable macro matchers in rustdoc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/090461475102cda8c42a7b4c65e25d0d38b27db8", "html_url": "https://github.com/rust-lang/rust/commit/090461475102cda8c42a7b4c65e25d0d38b27db8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/090461475102cda8c42a7b4c65e25d0d38b27db8/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d950c1b2000371253e026281cbfac30857b04470", "url": "https://api.github.com/repos/rust-lang/rust/commits/d950c1b2000371253e026281cbfac30857b04470", "html_url": "https://github.com/rust-lang/rust/commit/d950c1b2000371253e026281cbfac30857b04470"}], "stats": {"total": 161, "additions": 152, "deletions": 9}, "files": [{"sha": "7fba80a98dc69ff7d296385d0fb0fd5179fe1098", "filename": "compiler/rustc_ast_pretty/src/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090461475102cda8c42a7b4c65e25d0d38b27db8/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090461475102cda8c42a7b4c65e25d0d38b27db8/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs?ref=090461475102cda8c42a7b4c65e25d0d38b27db8", "patch": "@@ -599,7 +599,7 @@ impl Printer {\n         self.break_offset(n, 0)\n     }\n \n-    crate fn zerobreak(&mut self) {\n+    pub fn zerobreak(&mut self) {\n         self.spaces(0)\n     }\n "}, {"sha": "a88e11b667af92dadc228f902402958736da7aae", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 139, "deletions": 4, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/090461475102cda8c42a7b4c65e25d0d38b27db8/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090461475102cda8c42a7b4c65e25d0d38b27db8/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=090461475102cda8c42a7b4c65e25d0d38b27db8", "patch": "@@ -9,7 +9,10 @@ use crate::formats::item_type::ItemType;\n use crate::visit_lib::LibEmbargoVisitor;\n \n use rustc_ast as ast;\n-use rustc_ast::tokenstream::TokenTree;\n+use rustc_ast::token::{self, BinOpToken, DelimToken};\n+use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+use rustc_ast_pretty::pprust::state::State as Printer;\n+use rustc_ast_pretty::pprust::PrintState;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -504,10 +507,44 @@ pub(super) fn render_macro_arms<'a>(\n /// as part of an item declaration.\n pub(super) fn render_macro_matcher(tcx: TyCtxt<'_>, matcher: &TokenTree) -> String {\n     if let Some(snippet) = snippet_equal_to_token(tcx, matcher) {\n-        snippet\n-    } else {\n-        rustc_ast_pretty::pprust::tt_to_string(matcher)\n+        // If the original source code is known, we display the matcher exactly\n+        // as present in the source code.\n+        return snippet;\n+    }\n+\n+    // If the matcher is macro-generated or some other reason the source code\n+    // snippet is not available, we attempt to nicely render the token tree.\n+    let mut printer = Printer::new();\n+\n+    // If the inner ibox fits on one line, we get:\n+    //\n+    //     macro_rules! macroname {\n+    //         (the matcher) => {...};\n+    //     }\n+    //\n+    // If the inner ibox gets wrapped, the cbox will break and get indented:\n+    //\n+    //     macro_rules! macroname {\n+    //         (\n+    //             the matcher ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+    //             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!\n+    //         ) => {...};\n+    //     }\n+    printer.cbox(8);\n+    printer.word(\"(\");\n+    printer.zerobreak();\n+    printer.ibox(0);\n+    match matcher {\n+        TokenTree::Delimited(_span, _delim, tts) => print_tts(&mut printer, tts),\n+        // Matcher which is not a Delimited is unexpected and should've failed\n+        // to compile, but we render whatever it is wrapped in parens.\n+        TokenTree::Token(_) => print_tt(&mut printer, matcher),\n     }\n+    printer.end();\n+    printer.break_offset_if_not_bol(0, -4);\n+    printer.word(\")\");\n+    printer.end();\n+    printer.s.eof()\n }\n \n /// Find the source snippet for this token's Span, reparse it, and return the\n@@ -551,6 +588,104 @@ fn snippet_equal_to_token(tcx: TyCtxt<'_>, matcher: &TokenTree) -> Option<String\n     if reparsed_tree.eq_unspanned(matcher) { Some(snippet) } else { None }\n }\n \n+fn print_tt(printer: &mut Printer<'_>, tt: &TokenTree) {\n+    match tt {\n+        TokenTree::Token(token) => {\n+            let token_str = printer.token_to_string(token);\n+            printer.word(token_str);\n+            if let token::DocComment(..) = token.kind {\n+                printer.hardbreak()\n+            }\n+        }\n+        TokenTree::Delimited(_span, delim, tts) => {\n+            let open_delim = printer.token_kind_to_string(&token::OpenDelim(*delim));\n+            printer.word(open_delim);\n+            if !tts.is_empty() {\n+                if *delim == DelimToken::Brace {\n+                    printer.space();\n+                }\n+                print_tts(printer, tts);\n+                if *delim == DelimToken::Brace {\n+                    printer.space();\n+                }\n+            }\n+            let close_delim = printer.token_kind_to_string(&token::CloseDelim(*delim));\n+            printer.word(close_delim);\n+        }\n+    }\n+}\n+\n+fn print_tts(printer: &mut Printer<'_>, tts: &TokenStream) {\n+    #[derive(Copy, Clone, PartialEq)]\n+    enum State {\n+        Start,\n+        Dollar,\n+        DollarIdent,\n+        DollarIdentColon,\n+        DollarParen,\n+        DollarParenSep,\n+        Pound,\n+        PoundBang,\n+        Ident,\n+        Other,\n+    }\n+\n+    use State::*;\n+\n+    let mut state = Start;\n+    for tt in tts.trees() {\n+        let (needs_space, next_state) = match &tt {\n+            TokenTree::Token(tt) => match (state, &tt.kind) {\n+                (Dollar, token::Ident(..)) => (false, DollarIdent),\n+                (DollarIdent, token::Colon) => (false, DollarIdentColon),\n+                (DollarIdentColon, token::Ident(..)) => (false, Other),\n+                (\n+                    DollarParen,\n+                    token::BinOp(BinOpToken::Plus | BinOpToken::Star) | token::Question,\n+                ) => (false, Other),\n+                (DollarParen, _) => (false, DollarParenSep),\n+                (DollarParenSep, token::BinOp(BinOpToken::Plus | BinOpToken::Star)) => {\n+                    (false, Other)\n+                }\n+                (Pound, token::Not) => (false, PoundBang),\n+                (_, token::Ident(symbol, /* is_raw */ false))\n+                    if !usually_needs_space_between_keyword_and_open_delim(*symbol) =>\n+                {\n+                    (true, Ident)\n+                }\n+                (_, token::Comma | token::Semi) => (false, Other),\n+                (_, token::Dollar) => (true, Dollar),\n+                (_, token::Pound) => (true, Pound),\n+                (_, _) => (true, Other),\n+            },\n+            TokenTree::Delimited(_, delim, _) => match (state, delim) {\n+                (Dollar, DelimToken::Paren) => (false, DollarParen),\n+                (Pound | PoundBang, DelimToken::Bracket) => (false, Other),\n+                (Ident, DelimToken::Paren | DelimToken::Bracket) => (false, Other),\n+                (_, _) => (true, Other),\n+            },\n+        };\n+        if state != Start && needs_space {\n+            printer.space();\n+        }\n+        print_tt(printer, &tt);\n+        state = next_state;\n+    }\n+}\n+\n+// This rough subset of keywords is listed here to distinguish tokens resembling\n+// `f(0)` (no space between ident and paren) from tokens resembling `if let (0,\n+// 0) = x` (space between ident and paren).\n+fn usually_needs_space_between_keyword_and_open_delim(symbol: Symbol) -> bool {\n+    match symbol.as_str() {\n+        \"as\" | \"box\" | \"break\" | \"const\" | \"continue\" | \"crate\" | \"else\" | \"enum\" | \"extern\"\n+        | \"for\" | \"if\" | \"impl\" | \"in\" | \"let\" | \"loop\" | \"macro\" | \"match\" | \"mod\" | \"move\"\n+        | \"mut\" | \"ref\" | \"return\" | \"static\" | \"struct\" | \"trait\" | \"type\" | \"unsafe\" | \"use\"\n+        | \"where\" | \"while\" | \"yield\" => true,\n+        _ => false,\n+    }\n+}\n+\n pub(super) fn display_macro_source(\n     cx: &mut DocContext<'_>,\n     name: Symbol,"}, {"sha": "9f155439b7eef2746ddbcba5e9c6dc1a7714d402", "filename": "src/test/rustdoc/macro-generated-macro.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/090461475102cda8c42a7b4c65e25d0d38b27db8/src%2Ftest%2Frustdoc%2Fmacro-generated-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090461475102cda8c42a7b4c65e25d0d38b27db8/src%2Ftest%2Frustdoc%2Fmacro-generated-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacro-generated-macro.rs?ref=090461475102cda8c42a7b4c65e25d0d38b27db8", "patch": "@@ -8,14 +8,22 @@ macro_rules! make_macro {\n }\n \n // @has macro_generated_macro/macro.interpolations.html //pre 'macro_rules! interpolations {'\n-// @has - //pre '(<= type $($i : ident) :: * + $e : expr =>) => { ... };'\n+// @has - //pre '(<= type $($i:ident)::* + $e:expr =>) => { ... };'\n make_macro!(interpolations type $($i:ident)::* + $e:expr);\n interpolations!(<= type foo::bar + x.sort() =>);\n \n // @has macro_generated_macro/macro.attributes.html //pre 'macro_rules! attributes {'\n-// @has - //pre '(<= #! [no_std] #[inline] =>) => { ... };'\n-make_macro!(attributes #![no_std] #[inline]);\n+// @has - //pre '(<= #![no_std] #[cfg(feature = \"alloc\")] =>) => { ... };'\n+make_macro!(attributes #![no_std] #[cfg(feature = \"alloc\")]);\n \n // @has macro_generated_macro/macro.groups.html //pre 'macro_rules! groups {'\n-// @has - //pre '(<= fn {} () { foo [0] } =>) => { ... };'\n+// @has - //pre '(<= fn {} () { foo[0] } =>) => { ... };'\n make_macro!(groups fn {}() {foo[0]});\n+\n+// @has macro_generated_macro/macro.linebreak.html //pre 'macro_rules! linebreak {'\n+// @has - //pre '    ('\n+// @has - //pre '        <= 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25'\n+// @has - //pre '        26 27 28 =>'\n+// @has - //pre '    ) => { ... };'\n+// @has - //pre '};'\n+make_macro!(linebreak 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28);"}]}