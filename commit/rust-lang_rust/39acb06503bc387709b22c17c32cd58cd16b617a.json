{"sha": "39acb06503bc387709b22c17c32cd58cd16b617a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5YWNiMDY1MDNiYzM4NzcwOWIyMmMxN2MzMmNkNThjZDE2YjYxN2E=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-11T04:29:25Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-11T04:29:25Z"}, "message": "Copyedit sections 11-13 of the tutorial. That's all, folks!", "tree": {"sha": "0c304c0b602fd067e46876c5bd7b273f672f1f00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c304c0b602fd067e46876c5bd7b273f672f1f00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39acb06503bc387709b22c17c32cd58cd16b617a", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39acb06503bc387709b22c17c32cd58cd16b617a", "html_url": "https://github.com/rust-lang/rust/commit/39acb06503bc387709b22c17c32cd58cd16b617a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39acb06503bc387709b22c17c32cd58cd16b617a/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d250517edc9823b39f6e239ec03d19a18b577bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d250517edc9823b39f6e239ec03d19a18b577bd", "html_url": "https://github.com/rust-lang/rust/commit/6d250517edc9823b39f6e239ec03d19a18b577bd"}], "stats": {"total": 188, "additions": 103, "deletions": 85}, "files": [{"sha": "ae88cda8d8e91b953f3948e04961cae76be25fb5", "filename": "doc/tutorial.md", "status": "modified", "additions": 103, "deletions": 85, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/39acb06503bc387709b22c17c32cd58cd16b617a/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/39acb06503bc387709b22c17c32cd58cd16b617a/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=39acb06503bc387709b22c17c32cd58cd16b617a", "patch": "@@ -1807,10 +1807,13 @@ fn contains(v: &[int], elt: int) -> bool {\n \n # Generics\n \n-Throughout this tutorial, we've been defining functions that act only on\n-specific data types. With type parameters we can also define functions whose\n-arguments represent generic types, and which can be invoked with a variety\n-of types. Consider a generic `map` function.\n+Throughout this tutorial, we've been defining functions that act only\n+on specific data types. With type parameters we can also define\n+functions whose arguments have generic types, and which can be invoked\n+with a variety of types. Consider a generic `map` function, which\n+takes a function `function` and a vector `vector` and returns a new\n+vector consisting of the result of applying `function` to each element\n+of `vector`:\n \n ~~~~\n fn map<T, U>(vector: &[T], function: fn(v: &T) -> U) -> ~[U] {\n@@ -1824,17 +1827,18 @@ fn map<T, U>(vector: &[T], function: fn(v: &T) -> U) -> ~[U] {\n \n When defined with type parameters, as denoted by `<T, U>`, this\n function can be applied to any type of vector, as long as the type of\n-`function`'s argument and the type of the vector's content agree with\n+`function`'s argument and the type of the vector's contents agree with\n each other.\n \n Inside a generic function, the names of the type parameters\n-(capitalized by convention) stand for opaque types. You can't look\n-inside them, but you can pass them around.  Note that instances of\n-generic types are often passed by pointer.  For example, the\n-parameter `function()` is supplied with a pointer to a value of type\n-`T` and not a value of type `T` itself.  This ensures that the\n-function works with the broadest set of types possible, since some\n-types are expensive or illegal to copy and pass by value.\n+(capitalized by convention) stand for opaque types. All you can do\n+with instances of these types is pass them around: you can't apply any\n+operations to them or pattern-match on them. Note that instances of\n+generic types are often passed by pointer.  For example, the parameter\n+`function()` is supplied with a pointer to a value of type `T` and not\n+a value of type `T` itself.  This ensures that the function works with\n+the broadest set of types possible, since some types are expensive or\n+illegal to copy and pass by value.\n \n Generic `type`, `struct`, and `enum` declarations follow the same pattern:\n \n@@ -1852,15 +1856,16 @@ enum Maybe<T> {\n }\n ~~~~\n \n-These declarations produce valid types like `Set<int>`, `Stack<int>`\n-and `Maybe<int>`.\n+These declarations can be instantiated to valid types like `Set<int>`,\n+`Stack<int>` and `Maybe<int>`.\n \n-Generic functions in Rust are compiled to very efficient runtime code\n-through a process called _monomorphisation_. This is a fancy way of\n-saying that, for each generic function you call, the compiler\n-generates a specialized version that is optimized specifically for the\n-argument types. In this respect Rust's generics have similar\n-performance characteristics to C++ templates.\n+The Rust compiler compiles generic functions very efficiently by\n+*monomorphizing* them. *Monomorphization* is a fancy name for a simple\n+idea: generate a separate copy of each generic function at each call\n+site where it is called, a copy that is specialized to the argument\n+types and can thus be optimized specifically for them. In this\n+respect, Rust's generics have similar performance characteristics to\n+C++ templates.\n \n ## Traits\n \n@@ -1869,15 +1874,19 @@ are very limited. After all, since the function doesn't know what\n types it is operating on, it can't safely modify or query their\n values. This is where _traits_ come into play. Traits are Rust's most\n powerful tool for writing polymorphic code. Java developers will see\n-in them aspects of Java interfaces, and Haskellers will notice their\n-similarities to type classes.\n-\n-As motivation, let us consider copying in Rust. Perhaps surprisingly,\n-the copy operation is not defined for all Rust types. In\n-particular, types with user-defined destructors cannot be copied,\n-either implicitly or explicitly, and neither can types that own other\n-types containing destructors (the actual mechanism for defining\n-destructors will be discussed elsewhere).\n+them as similar to Java interfaces, and Haskellers will notice their\n+similarities to type classes. Rust's traits are a form of *bounded\n+polymorphism*: a trait is a way of limiting the set of possible types\n+that a type parameter could refer to.\n+\n+As motivation, let us consider copying in Rust. The `copy` operation\n+is not defined for all Rust types. One reason is user-defined\n+destructors: copying a type that has a destructor could result in the\n+destructor running multiple times. Therefore, types with user-defined\n+destructors cannot be copied, either implicitly or explicitly, and\n+neither can types that own other types containing destructors (see the\n+section on [structs](#structs) for the actual mechanism for defining\n+destructors).\n \n This complicates handling of generic functions. If you have a type\n parameter `T`, can you copy values of that type? In Rust, you can't,\n@@ -1890,8 +1899,8 @@ fn head_bad<T>(v: &[T]) -> T {\n }\n ~~~~\n \n-We can tell the compiler though that the `head` function is only for\n-copyable types with the `Copy` trait.\n+However, we can tell the compiler that the `head` function is only for\n+copyable types: that is, those that have the `Copy` trait.\n \n ~~~~\n // This does\n@@ -1903,14 +1912,17 @@ fn head<T: Copy>(v: &[T]) -> T {\n This says that we can call `head` on any type `T` as long as that type\n implements the `Copy` trait. When instantiating a generic function,\n you can only instantiate it with types that implement the correct\n-trait, so you could not apply `head` to a type with a destructor.\n+trait, so you could not apply `head` to a type with a\n+destructor. (`Copy` is a special trait that is built in to the\n+compiler, making it possible for the compiler to enforce this\n+restriction.)\n \n While most traits can be defined and implemented by user code, three\n traits are automatically derived and implemented for all applicable\n types by the compiler, and may not be overridden:\n \n-* `Copy` - Types that can be copied, either implicitly, or using the\n-  `copy` expression. All types are copyable unless they are classes\n+* `Copy` - Types that can be copied: either implicitly, or explicitly with the\n+  `copy` operator. All types are copyable unless they are classes\n   with destructors or otherwise contain classes with destructors.\n \n * `Send` - Sendable (owned) types. All types are sendable unless they\n@@ -1957,7 +1969,7 @@ impl ~str: Printable {\n # (~\"foo\").print();\n ~~~~\n \n-Methods defined in an implementation of a trait may be called just as\n+Methods defined in an implementation of a trait may be called just like\n any other method, using dot notation, as in `1.print()`. Traits may\n themselves contain type parameters. A trait for generalized sequence\n types might look like the following:\n@@ -1979,14 +1991,14 @@ impl<T> ~[T]: Seq<T> {\n The implementation has to explicitly declare the type parameter that\n it binds, `T`, before using it to specify its trait type. Rust\n requires this declaration because the `impl` could also, for example,\n-specify an implementation of `Seq<int>`. The trait type -- appearing\n-after the colon in the `impl` -- *refers* to a type, rather than\n+specify an implementation of `Seq<int>`. The trait type (appearing\n+after the colon in the `impl`) *refers* to a type, rather than\n defining one.\n \n The type parameters bound by a trait are in scope in each of the\n method declarations. So, re-declaring the type parameter\n-`T` as an explicit type parameter for `len` -- in either the trait or\n-the impl -- would be a compile-time error.\n+`T` as an explicit type parameter for `len`, in either the trait or\n+the impl, would be a compile-time error.\n \n Within a trait definition, `self` is a special type that you can think\n of as a type parameter. An implementation of the trait for any given\n@@ -2006,16 +2018,17 @@ impl int: Eq {\n }\n ~~~~\n \n-Notice that in the trait definition, `equals` takes a `self` type\n-argument, whereas, in the impl, `equals` takes an `int` type argument,\n-and uses `self` as the name of the receiver (analogous to the `this` pointer\n-in C++).\n+Notice that in the trait definition, `equals` takes a parameter of\n+type `self`. In contrast, in the `impl`, `equals` takes a parameter of\n+type `int`, and uses `self` as the name of the receiver (analogous to\n+the `this` pointer in C++).\n \n ## Bounded type parameters and static method dispatch\n \n-Traits give us a language for talking about the abstract capabilities\n-of types, and we can use this to place _bounds_ on type parameters,\n-so that we can then operate on generic types.\n+Traits give us a language for defining predicates on types, or\n+abstract properties that types can have. We can use this language to\n+define _bounds_ on type parameters, so that we can then operate on\n+generic types.\n \n ~~~~\n # trait Printable { fn print(); }\n@@ -2026,14 +2039,14 @@ fn print_all<T: Printable>(printable_things: ~[T]) {\n }\n ~~~~\n \n-By declaring `T` as conforming to the `Printable` trait (as we earlier\n-did with `Copy`), it becomes possible to call methods from that trait\n-on values of that type inside the function. It will also cause a\n+Declaring `T` as conforming to the `Printable` trait (as we earlier\n+did with `Copy`) makes it possible to call methods from that trait\n+on values of type `T` inside the function. It will also cause a\n compile-time error when anyone tries to call `print_all` on an array\n whose element type does not have a `Printable` implementation.\n \n Type parameters can have multiple bounds by separating them with spaces,\n-as in this version of `print_all` that makes copies of elements.\n+as in this version of `print_all` that copies elements.\n \n ~~~\n # trait Printable { fn print(); }\n@@ -2083,10 +2096,10 @@ fn draw_all(shapes: &[@Drawable]) {\n }\n ~~~~\n \n-In this example there is no type parameter. Instead, the `@Drawable`\n-type is used to refer to any managed box value that implements the\n-`Drawable` trait. To construct such a value, you use the `as` operator\n-to cast a value to a trait type:\n+In this example, there is no type parameter. Instead, the `@Drawable`\n+type denotes any managed box value that implements the `Drawable`\n+trait. To construct such a value, you use the `as` operator to cast a\n+value to a trait type:\n \n ~~~~\n # type Circle = int; type Rectangle = bool;\n@@ -2104,10 +2117,12 @@ let r: @Rectangle = @new_rectangle();\n draw_all(&[c as @Drawable, r as @Drawable]);\n ~~~~\n \n-Note that, like strings and vectors, trait types have dynamic size\n-and may only be used via one of the pointer types. In turn, the\n-`impl` is defined for `@Circle` and `@Rectangle` instead of for\n-just `Circle` and `Rectangle`. Other pointer types work as well.\n+We omit the code for `new_circle` and `new_rectangle`; imagine that\n+these just return `Circle`s and `Rectangle`s with a default size. Note\n+that, like strings and vectors, trait types have dynamic size and may\n+only be referred to via one of the pointer types. That's why the `impl` is\n+defined for `@Circle` and `@Rectangle` instead of for just `Circle`\n+and `Rectangle`. Other pointer types work as well.\n \n ~~~{.xfail-test}\n # type Circle = int; type Rectangle = int;\n@@ -2123,13 +2138,13 @@ let owny: ~Drawable = ~new_circle() as ~Drawable;\n let stacky: &Drawable = &new_circle() as &Drawable;\n ~~~\n \n-> ***Note:*** Other pointer types actually _do not_ work here. This is\n+> ***Note:*** Other pointer types actually _do not_ work here yet. This is\n > an evolving corner of the language.\n \n Method calls to trait types are _dynamically dispatched_. Since the\n compiler doesn't know specifically which functions to call at compile\n-time it uses a lookup table (vtable) to decide at runtime which\n-method to call.\n+time it uses a lookup table (also known as a vtable or dictionary) to\n+select the method to call at runtime.\n \n This usage of traits is similar to Java interfaces.\n \n@@ -2170,17 +2185,18 @@ fn chicken_farmer() {\n ~~~\n \n These farm animal functions have a new keyword, `pub`, attached to\n-them.  This is a visibility modifier that allows item to be accessed\n-outside of the module in which they are declared, using `::`, as in\n-`farm::chicken`. Items, like `fn`, `struct`, etc. are private by\n-default.\n+them.  The `pub` keyword modifies an item's visibility, making it\n+visible outside its containing module. An expression with `::`, like\n+`farm::chicken`, can name an item outside of its containing\n+module. Items, such as those declared with `fn`, `struct`, `enum`,\n+`type`, or `const`, are module-private by default.\n \n Visibility restrictions in Rust exist only at module boundaries. This\n-is quite different from most object-oriented languages that also enforce\n-restrictions on objects themselves. That's not to say that Rust doesn't\n-support encapsulation - both struct fields and methods can be private -\n-but it is at the module level, not the class level. Note that fields\n-and methods are _public_ by default.\n+is quite different from most object-oriented languages that also\n+enforce restrictions on objects themselves. That's not to say that\n+Rust doesn't support encapsulation: both struct fields and methods can\n+be private.  But this encapsulation is at the module level, not the\n+struct level. Note that fields and methods are _public_ by default.\n \n ~~~\n mod farm {\n@@ -2220,7 +2236,7 @@ fn main() {\n \n ## Crates\n \n-The unit of independent compilation in Rust is the crate - rustc\n+The unit of independent compilation in Rust is the crate: rustc\n compiles a single crate at a time, from which it produces either a\n library or executable.\n \n@@ -2294,38 +2310,40 @@ fn main() { bar::baz(); }\n \n ## Using other crates\n \n-Having compiled a crate into a library you can use it in another crate\n-with an `extern mod` directive. `extern mod` can appear at the top of\n-a crate file or at the top of modules. It will cause the compiler to\n-look in the library search path (which you can extend with `-L`\n-switch) for a compiled Rust library with the right name, then add a\n-module with that crate's name into the local scope.\n+The `extern mod` directive lets you use a crate (once it's been\n+compiled into a library) from inside another crate. `extern mod` can\n+appear at the top of a crate file or at the top of modules. It will\n+cause the compiler to look in the library search path (which you can\n+extend with the `-L` switch) for a compiled Rust library with the\n+right name, then add a module with that crate's name into the local\n+scope.\n \n For example, `extern mod std` links the [standard library].\n \n [standard library]: std/index.html\n \n-When a comma-separated list of name/value pairs is given after `extern\n-mod`, these are matched against the attributes provided in the `link`\n-attribute of the crate file, and a crate is only used when the two\n-match. A `name` value can be given to override the name used to search\n-for the crate.\n+When a comma-separated list of name/value pairs appears after `extern\n+mod`, the compiler front-end matches these pairs against the\n+attributes provided in the `link` attribute of the crate file. The\n+front-end will only select this crate for use if the actual pairs\n+match the declared attributes. You can provide a `name` value to\n+override the name used to search for the crate.\n \n Our example crate declared this set of `link` attributes:\n \n ~~~~ {.xfail-test}\n #[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")];\n ~~~~\n \n-Which can then be linked with any (or all) of the following:\n+Which you can then link with any (or all) of the following:\n \n ~~~~ {.xfail-test}\n extern mod farm;\n extern mod my_farm (name = \"farm\", vers = \"2.5\");\n extern mod my_auxiliary_farm (name = \"farm\", author = \"mjh\");\n ~~~~\n \n-If any of the requested metadata does not match then the crate\n+If any of the requested metadata do not match, then the crate\n will not be compiled successfully.\n \n ## A minimal example\n@@ -2361,7 +2379,7 @@ a hash representing the crate metadata.\n \n ## The core library\n \n-The Rust [core] library acts as the language runtime and contains\n+The Rust [core] library is the language runtime and contains\n required memory management and task scheduling code as well as a\n number of modules necessary for effective usage of the primitive\n types. Methods on [vectors] and [strings], implementations of most"}]}