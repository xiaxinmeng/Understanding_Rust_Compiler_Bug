{"sha": "9228d231fc05488647c6d72516b527963310ac2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMjhkMjMxZmMwNTQ4ODY0N2M2ZDcyNTE2YjUyNzk2MzMxMGFjMmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-10T21:18:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-10T21:18:14Z"}, "message": "Auto merge of #43028 - michaelwoerister:dedup-dep-nodes, r=nikomatsakis\n\nincr.comp.: Deduplicate some DepNodes and introduce anonymous DepNodes\n\nThis is a parallel PR to the pending https://github.com/rust-lang/rust/pull/42769. It implements most of what is possible in terms of DepNode re-opening without having anonymous DepNodes yet (https://github.com/rust-lang/rust/issues/42298).\n\nr? @nikomatsakis", "tree": {"sha": "209092426d1cb531e17e0e0d35a18cccc002c927", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/209092426d1cb531e17e0e0d35a18cccc002c927"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9228d231fc05488647c6d72516b527963310ac2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9228d231fc05488647c6d72516b527963310ac2d", "html_url": "https://github.com/rust-lang/rust/commit/9228d231fc05488647c6d72516b527963310ac2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9228d231fc05488647c6d72516b527963310ac2d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf0a9e0b4d3a4dd09717960840798e2933ec7568", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf0a9e0b4d3a4dd09717960840798e2933ec7568", "html_url": "https://github.com/rust-lang/rust/commit/bf0a9e0b4d3a4dd09717960840798e2933ec7568"}, {"sha": "4f1f671f3835319b98e2933fc725cd02de461381", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f1f671f3835319b98e2933fc725cd02de461381", "html_url": "https://github.com/rust-lang/rust/commit/4f1f671f3835319b98e2933fc725cd02de461381"}], "stats": {"total": 1331, "additions": 640, "deletions": 691}, "files": [{"sha": "c8d0362f17c8ed9a4f026a9e95b69bbe48f1319f", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -16,7 +16,7 @@ The nodes of the graph are defined by the enum `DepNode`. They represent\n one of three things:\n \n 1. HIR nodes (like `Hir(DefId)`) represent the HIR input itself.\n-2. Data nodes (like `ItemSignature(DefId)`) represent some computed\n+2. Data nodes (like `TypeOfItem(DefId)`) represent some computed\n    information about a particular item.\n 3. Procedure nodes (like `CoherenceCheckTrait(DefId)`) represent some\n    procedure that is executing. Usually this procedure is\n@@ -289,7 +289,7 @@ to see something like:\n \n     Hir(foo) -> Collect(bar)\n     Collect(bar) -> TypeckTables(bar)\n-    \n+\n That first edge looks suspicious to you. So you set\n `RUST_FORBID_DEP_GRAPH_EDGE` to `Hir&foo -> Collect&bar`, re-run, and\n then observe the backtrace. Voila, bug fixed!"}, {"sha": "c6275e84645843296d34ac08bb6781de4c4b9a82", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 135, "deletions": 88, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -64,7 +64,9 @@ use hir::def_id::{CrateNum, DefId};\n use hir::map::DefPathHash;\n \n use ich::Fingerprint;\n-use ty::TyCtxt;\n+use ty::{TyCtxt, Instance, InstanceDef};\n+use ty::fast_reject::SimplifiedType;\n+use ty::subst::Substs;\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use ich::StableHashingContext;\n use std::fmt;\n@@ -77,8 +79,14 @@ macro_rules! erase {\n     ($x:tt) => ({})\n }\n \n+macro_rules! anon_attr_to_bool {\n+    (anon) => (true)\n+}\n+\n macro_rules! define_dep_nodes {\n-    ($(\n+    (<$tcx:tt>\n+    $(\n+        [$($anon:ident)*]\n         $variant:ident $(( $($tuple_arg:tt),* ))*\n                        $({ $($struct_arg_name:ident : $struct_arg_ty:ty),* })*\n       ,)*\n@@ -92,7 +100,7 @@ macro_rules! define_dep_nodes {\n         impl DepKind {\n             #[allow(unreachable_code)]\n             #[inline]\n-            pub fn can_reconstruct_query_key(&self) -> bool {\n+            pub fn can_reconstruct_query_key<$tcx>(&self) -> bool {\n                 match *self {\n                     $(\n                         DepKind :: $variant => {\n@@ -114,6 +122,19 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n+            #[allow(unreachable_code)]\n+            #[inline]\n+            pub fn is_anon<$tcx>(&self) -> bool {\n+                match *self {\n+                    $(\n+                        DepKind :: $variant => {\n+                            $(return anon_attr_to_bool!($anon);)*\n+                            false\n+                        }\n+                    )*\n+                }\n+            }\n+\n             #[allow(unreachable_code)]\n             #[inline]\n             pub fn has_params(&self) -> bool {\n@@ -139,7 +160,7 @@ macro_rules! define_dep_nodes {\n             }\n         }\n \n-        pub enum DepConstructor {\n+        pub enum DepConstructor<$tcx> {\n             $(\n                 $variant $(( $($tuple_arg),* ))*\n                          $({ $($struct_arg_name : $struct_arg_ty),* })*\n@@ -155,7 +176,12 @@ macro_rules! define_dep_nodes {\n \n         impl DepNode {\n             #[allow(unreachable_code, non_snake_case)]\n-            pub fn new(tcx: TyCtxt, dep: DepConstructor) -> DepNode {\n+            pub fn new<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                       dep: DepConstructor<'gcx>)\n+                                       -> DepNode\n+                where 'gcx: 'a + 'tcx,\n+                      'tcx: 'a\n+            {\n                 match dep {\n                     $(\n                         DepConstructor :: $variant $(( $($tuple_arg),* ))*\n@@ -336,7 +362,7 @@ impl DefId {\n     }\n }\n \n-define_dep_nodes!(\n+define_dep_nodes!( <'tcx>\n     // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n     // distinct from the krate module). This is basically a hash of\n     // the entire krate, so if you read from `Krate` (e.g., by calling\n@@ -348,90 +374,101 @@ define_dep_nodes!(\n     // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n     // access to the krate, but you must remember to add suitable\n     // edges yourself for the individual items that you read.\n-    Krate,\n+    [] Krate,\n \n     // Represents the HIR node with the given node-id\n-    Hir(DefId),\n+    [] Hir(DefId),\n \n     // Represents the body of a function or method. The def-id is that of the\n     // function/method.\n-    HirBody(DefId),\n+    [] HirBody(DefId),\n \n     // Represents the metadata for a given HIR node, typically found\n     // in an extern crate.\n-    MetaData(DefId),\n+    [] MetaData(DefId),\n \n     // Represents some artifact that we save to disk. Note that these\n     // do not have a def-id as part of their identifier.\n-    WorkProduct(WorkProductId),\n+    [] WorkProduct(WorkProductId),\n \n     // Represents different phases in the compiler.\n-    RegionMaps(DefId),\n-    Coherence,\n-    Resolve,\n-    CoherenceCheckTrait(DefId),\n-    PrivacyAccessLevels(CrateNum),\n+    [] RegionMaps(DefId),\n+    [] Coherence,\n+    [] Resolve,\n+    [] CoherenceCheckTrait(DefId),\n+    [] PrivacyAccessLevels(CrateNum),\n \n     // Represents the MIR for a fn; also used as the task node for\n     // things read/modify that MIR.\n-    Mir(DefId),\n-    MirShim(DefIdList),\n-\n-    BorrowCheckKrate,\n-    BorrowCheck(DefId),\n-    RvalueCheck(DefId),\n-    Reachability,\n-    MirKeys,\n-    TransWriteMetadata,\n-    CrateVariances,\n+    [] MirConstQualif(DefId),\n+    [] MirConst(DefId),\n+    [] MirValidated(DefId),\n+    [] MirOptimized(DefId),\n+    [] MirShim { instance_def: InstanceDef<'tcx> },\n+\n+    [] BorrowCheckKrate,\n+    [] BorrowCheck(DefId),\n+    [] RvalueCheck(DefId),\n+    [] Reachability,\n+    [] MirKeys,\n+    [] TransWriteMetadata,\n+    [] CrateVariances,\n \n     // Nodes representing bits of computed IR in the tcx. Each shared\n     // table in the tcx (or elsewhere) maps to one of these\n-    // nodes. Often we map multiple tables to the same node if there\n-    // is no point in distinguishing them (e.g., both the type and\n-    // predicates for an item wind up in `ItemSignature`).\n-    AssociatedItems(DefId),\n-    ItemSignature(DefId),\n-    ItemVarianceConstraints(DefId),\n-    ItemVariances(DefId),\n-    IsConstFn(DefId),\n-    IsForeignItem(DefId),\n-    TypeParamPredicates { item_id: DefId, param_id: DefId },\n-    SizedConstraint(DefId),\n-    DtorckConstraint(DefId),\n-    AdtDestructor(DefId),\n-    AssociatedItemDefIds(DefId),\n-    InherentImpls(DefId),\n-    TypeckBodiesKrate,\n-    TypeckTables(DefId),\n-    ConstEval(DefId),\n-    SymbolName(DefId),\n-    SpecializationGraph(DefId),\n-    ObjectSafety(DefId),\n-    IsCopy(DefId),\n-    IsSized(DefId),\n-    IsFreeze(DefId),\n-    NeedsDrop(DefId),\n-    Layout(DefId),\n-\n-    // The set of impls for a given trait. Ultimately, it would be\n-    // nice to get more fine-grained here (e.g., to include a\n-    // simplified type), but we can't do that until we restructure the\n-    // HIR to distinguish the *header* of an impl from its body.  This\n-    // is because changes to the header may change the self-type of\n-    // the impl and hence would require us to be more conservative\n-    // than changes in the impl body.\n-    TraitImpls(DefId),\n-\n-    AllLocalTraitImpls,\n+    // nodes.\n+    [] AssociatedItems(DefId),\n+    [] TypeOfItem(DefId),\n+    [] GenericsOfItem(DefId),\n+    [] PredicatesOfItem(DefId),\n+    [] SuperPredicatesOfItem(DefId),\n+    [] TraitDefOfItem(DefId),\n+    [] AdtDefOfItem(DefId),\n+    [] IsDefaultImpl(DefId),\n+    [] ImplTraitRef(DefId),\n+    [] ImplPolarity(DefId),\n+    [] ClosureKind(DefId),\n+    [] FnSignature(DefId),\n+    [] CoerceUnsizedInfo(DefId),\n+\n+    [] ItemVarianceConstraints(DefId),\n+    [] ItemVariances(DefId),\n+    [] IsConstFn(DefId),\n+    [] IsForeignItem(DefId),\n+    [] TypeParamPredicates { item_id: DefId, param_id: DefId },\n+    [] SizedConstraint(DefId),\n+    [] DtorckConstraint(DefId),\n+    [] AdtDestructor(DefId),\n+    [] AssociatedItemDefIds(DefId),\n+    [] InherentImpls(DefId),\n+    [] TypeckBodiesKrate,\n+    [] TypeckTables(DefId),\n+    [] HasTypeckTables(DefId),\n+    [] ConstEval { def_id: DefId, substs: &'tcx Substs<'tcx> },\n+    [] SymbolName(DefId),\n+    [] InstanceSymbolName { instance: Instance<'tcx> },\n+    [] SpecializationGraph(DefId),\n+    [] ObjectSafety(DefId),\n+\n+    [anon] IsCopy(DefId),\n+    [anon] IsSized(DefId),\n+    [anon] IsFreeze(DefId),\n+    [anon] NeedsDrop(DefId),\n+    [anon] Layout(DefId),\n+\n+    // The set of impls for a given trait.\n+    [] TraitImpls(DefId),\n+    [] RelevantTraitImpls(DefId, SimplifiedType),\n+\n+    [] AllLocalTraitImpls,\n \n     // Nodes representing caches. To properly handle a true cache, we\n     // don't use a DepTrackingMap, but rather we push a task node.\n     // Otherwise the write into the map would be incorrectly\n     // attributed to the first task that happened to fill the cache,\n     // which would yield an overly conservative dep-graph.\n-    TraitItems(DefId),\n-    ReprHints(DefId),\n+    [] TraitItems(DefId),\n+    [] ReprHints(DefId),\n \n     // Trait selection cache is a little funny. Given a trait\n     // reference like `Foo: SomeTrait<Bar>`, there could be\n@@ -458,35 +495,45 @@ define_dep_nodes!(\n     // imprecision in our dep-graph tracking.  The important thing is\n     // that for any given trait-ref, we always map to the **same**\n     // trait-select node.\n-    TraitSelect { trait_def_id: DefId, input_def_id: DefId },\n+    [] TraitSelect { trait_def_id: DefId, input_def_id: DefId },\n \n     // For proj. cache, we just keep a list of all def-ids, since it is\n     // not a hotspot.\n-    ProjectionCache { def_ids: DefIdList },\n-\n-    ParamEnv(DefId),\n-    DescribeDef(DefId),\n-    DefSpan(DefId),\n-    Stability(DefId),\n-    Deprecation(DefId),\n-    ItemBodyNestedBodies(DefId),\n-    ConstIsRvaluePromotableToStatic(DefId),\n-    ImplParent(DefId),\n-    TraitOfItem(DefId),\n-    IsExportedSymbol(DefId),\n-    IsMirAvailable(DefId),\n-    ItemAttrs(DefId),\n-    FnArgNames(DefId),\n-    DylibDepFormats(DefId),\n-    IsAllocator(DefId),\n-    IsPanicRuntime(DefId),\n-    ExternCrate(DefId),\n+    [] ProjectionCache { def_ids: DefIdList },\n+\n+    [] ParamEnv(DefId),\n+    [] DescribeDef(DefId),\n+    [] DefSpan(DefId),\n+    [] Stability(DefId),\n+    [] Deprecation(DefId),\n+    [] ItemBodyNestedBodies(DefId),\n+    [] ConstIsRvaluePromotableToStatic(DefId),\n+    [] ImplParent(DefId),\n+    [] TraitOfItem(DefId),\n+    [] IsExportedSymbol(DefId),\n+    [] IsMirAvailable(DefId),\n+    [] ItemAttrs(DefId),\n+    [] FnArgNames(DefId),\n+    [] DylibDepFormats(DefId),\n+    [] IsAllocator(DefId),\n+    [] IsPanicRuntime(DefId),\n+    [] ExternCrate(DefId),\n );\n \n-trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> {\n+trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool;\n-    fn to_fingerprint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Fingerprint;\n-    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String;\n+\n+    /// This method turns the parameters of a DepNodeConstructor into an opaque\n+    /// Fingerprint to be used in DepNode.\n+    /// Not all DepNodeParams support being turned into a Fingerprint (they\n+    /// don't need to if the corresponding DepNode is anonymous).\n+    fn to_fingerprint(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> Fingerprint {\n+        panic!(\"Not implemented. Accidentally called on anonymous node?\")\n+    }\n+\n+    fn to_debug_str(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+        format!(\"{:?}\", self)\n+    }\n }\n \n impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T"}, {"sha": "277b69262c92d2e633968a60f7e28ee526f12a6c", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 181, "deletions": 92, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -8,25 +8,35 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use ich::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use super::{DepGraphQuery, DepNode};\n+use rustc_data_structures::stable_hasher::StableHasher;\n+use std::env;\n+use std::hash::Hash;\n+use std::mem;\n+use super::{DepGraphQuery, DepKind, DepNode};\n+use super::debug::EdgeFilter;\n \n pub struct DepGraphEdges {\n     nodes: Vec<DepNode>,\n-    indices: FxHashMap<DepNode, IdIndex>,\n-    edges: FxHashSet<(IdIndex, IdIndex)>,\n-    open_nodes: Vec<OpenNode>,\n+    indices: FxHashMap<DepNode, DepNodeIndex>,\n+    edges: FxHashSet<(DepNodeIndex, DepNodeIndex)>,\n+    task_stack: Vec<OpenTask>,\n+    forbidden_edge: Option<EdgeFilter>,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-struct IdIndex {\n+pub struct DepNodeIndex {\n     index: u32\n }\n \n-impl IdIndex {\n-    fn new(v: usize) -> IdIndex {\n+impl DepNodeIndex {\n+\n+    pub const INVALID: DepNodeIndex = DepNodeIndex { index: ::std::u32::MAX };\n+\n+    fn new(v: usize) -> DepNodeIndex {\n         assert!((v & 0xFFFF_FFFF) == v);\n-        IdIndex { index: v as u32 }\n+        DepNodeIndex { index: v as u32 }\n     }\n \n     fn index(self) -> usize {\n@@ -35,126 +45,179 @@ impl IdIndex {\n }\n \n #[derive(Clone, Debug, PartialEq)]\n-enum OpenNode {\n-    Node(IdIndex),\n+enum OpenTask {\n+    Regular {\n+        node: DepNode,\n+        reads: Vec<DepNode>,\n+        read_set: FxHashSet<DepNode>,\n+    },\n+    Anon {\n+        reads: Vec<DepNode>,\n+        read_set: FxHashSet<DepNode>,\n+    },\n     Ignore,\n }\n \n impl DepGraphEdges {\n     pub fn new() -> DepGraphEdges {\n+        let forbidden_edge = if cfg!(debug_assertions) {\n+            match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n+                Ok(s) => {\n+                    match EdgeFilter::new(&s) {\n+                        Ok(f) => Some(f),\n+                        Err(err) => bug!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n+                    }\n+                }\n+                Err(_) => None,\n+            }\n+        } else {\n+            None\n+        };\n+\n         DepGraphEdges {\n             nodes: vec![],\n             indices: FxHashMap(),\n             edges: FxHashSet(),\n-            open_nodes: Vec::new()\n+            task_stack: Vec::new(),\n+            forbidden_edge,\n         }\n     }\n \n-    fn id(&self, index: IdIndex) -> DepNode {\n-        self.nodes[index.index()].clone()\n-    }\n-\n-    /// Creates a node for `id` in the graph.\n-    fn make_node(&mut self, id: DepNode) -> IdIndex {\n-        if let Some(&i) = self.indices.get(&id) {\n-            return i;\n-        }\n-\n-        let index = IdIndex::new(self.nodes.len());\n-        self.nodes.push(id.clone());\n-        self.indices.insert(id, index);\n-        index\n-    }\n-\n-    /// Top of the stack of open nodes.\n-    fn current_node(&self) -> Option<OpenNode> {\n-        self.open_nodes.last().cloned()\n+    fn id(&self, index: DepNodeIndex) -> DepNode {\n+        self.nodes[index.index()]\n     }\n \n     pub fn push_ignore(&mut self) {\n-        self.open_nodes.push(OpenNode::Ignore);\n+        self.task_stack.push(OpenTask::Ignore);\n     }\n \n     pub fn pop_ignore(&mut self) {\n-        let popped_node = self.open_nodes.pop().unwrap();\n-        assert_eq!(popped_node, OpenNode::Ignore);\n+        let popped_node = self.task_stack.pop().unwrap();\n+        debug_assert_eq!(popped_node, OpenTask::Ignore);\n     }\n \n     pub fn push_task(&mut self, key: DepNode) {\n-        let top_node = self.current_node();\n+        self.task_stack.push(OpenTask::Regular {\n+            node: key,\n+            reads: Vec::new(),\n+            read_set: FxHashSet(),\n+        });\n+    }\n \n-        let new_node = self.make_node(key);\n-        self.open_nodes.push(OpenNode::Node(new_node));\n+    pub fn pop_task(&mut self, key: DepNode) -> DepNodeIndex {\n+        let popped_node = self.task_stack.pop().unwrap();\n \n-        // if we are in the midst of doing task T, then this new task\n-        // N is a subtask of T, so add an edge N -> T.\n-        if let Some(top_node) = top_node {\n-            self.add_edge_from_open_node(top_node, |t| (new_node, t));\n+        if let OpenTask::Regular {\n+            node,\n+            read_set: _,\n+            reads\n+        } = popped_node {\n+            debug_assert_eq!(node, key);\n+\n+            let target_id = self.get_or_create_node(node);\n+\n+            for read in reads.into_iter() {\n+                let source_id = self.get_or_create_node(read);\n+                self.edges.insert((source_id, target_id));\n+            }\n+\n+            target_id\n+        } else {\n+            bug!(\"pop_task() - Expected regular task to be popped\")\n         }\n     }\n \n-    pub fn pop_task(&mut self, key: DepNode) {\n-        let popped_node = self.open_nodes.pop().unwrap();\n-        assert_eq!(OpenNode::Node(self.indices[&key]), popped_node);\n+    pub fn push_anon_task(&mut self) {\n+        self.task_stack.push(OpenTask::Anon {\n+            reads: Vec::new(),\n+            read_set: FxHashSet(),\n+        });\n+    }\n+\n+    pub fn pop_anon_task(&mut self, kind: DepKind) -> DepNodeIndex {\n+        let popped_node = self.task_stack.pop().unwrap();\n+\n+        if let OpenTask::Anon {\n+            read_set: _,\n+            reads\n+        } = popped_node {\n+            let mut fingerprint = Fingerprint::zero();\n+            let mut hasher = StableHasher::new();\n+\n+            for read in reads.iter() {\n+                mem::discriminant(&read.kind).hash(&mut hasher);\n+\n+                // Fingerprint::combine() is faster than sending Fingerprint\n+                // through the StableHasher (at least as long as StableHasher\n+                // is so slow).\n+                fingerprint = fingerprint.combine(read.hash);\n+            }\n+\n+            fingerprint = fingerprint.combine(hasher.finish());\n+\n+            let target_dep_node = DepNode {\n+                kind,\n+                hash: fingerprint,\n+            };\n+\n+            if let Some(&index) = self.indices.get(&target_dep_node) {\n+                return index;\n+            }\n+\n+            let target_id = self.get_or_create_node(target_dep_node);\n+\n+            for read in reads.into_iter() {\n+                let source_id = self.get_or_create_node(read);\n+                self.edges.insert((source_id, target_id));\n+            }\n+\n+            target_id\n+        } else {\n+            bug!(\"pop_anon_task() - Expected anonymous task to be popped\")\n+        }\n     }\n \n     /// Indicates that the current task `C` reads `v` by adding an\n     /// edge from `v` to `C`. If there is no current task, has no\n     /// effect. Note that *reading* from tracked state is harmless if\n     /// you are not in a task; what is bad is *writing* to tracked\n     /// state (and leaking data that you read into a tracked task).\n-    pub fn read(&mut self, v: DepNode) {\n-        if self.current_node().is_some() {\n-            let source = self.make_node(v);\n-            self.add_edge_from_current_node(|current| (source, current))\n-        }\n-    }\n-\n-    /// Indicates that the current task `C` writes `v` by adding an\n-    /// edge from `C` to `v`. If there is no current task, panics. If\n-    /// you want to suppress this edge, use `ignore`.\n-    pub fn write(&mut self, v: DepNode) {\n-        let target = self.make_node(v);\n-        self.add_edge_from_current_node(|current| (current, target))\n-    }\n-\n-    /// Invoke `add_edge_from_open_node` with the top of the stack, or\n-    /// panic if stack is empty.\n-    fn add_edge_from_current_node<OP>(&mut self,\n-                                      op: OP)\n-        where OP: FnOnce(IdIndex) -> (IdIndex, IdIndex)\n-    {\n-        match self.current_node() {\n-            Some(open_node) => self.add_edge_from_open_node(open_node, op),\n-            None => bug!(\"no current node, cannot add edge into dependency graph\")\n+    pub fn read(&mut self, source: DepNode) {\n+        match self.task_stack.last_mut() {\n+            Some(&mut OpenTask::Regular {\n+                node: target,\n+                ref mut reads,\n+                ref mut read_set,\n+            }) => {\n+                if read_set.insert(source) {\n+                    reads.push(source);\n+\n+                    if cfg!(debug_assertions) {\n+                        if let Some(ref forbidden_edge) = self.forbidden_edge {\n+                            if forbidden_edge.test(&source, &target) {\n+                                bug!(\"forbidden edge {:?} -> {:?} created\", source, target)\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            Some(&mut OpenTask::Anon {\n+                ref mut reads,\n+                ref mut read_set,\n+            }) => {\n+                if read_set.insert(source) {\n+                    reads.push(source);\n+                }\n+            }\n+            Some(&mut OpenTask::Ignore) | None => {\n+                // ignore\n+            }\n         }\n     }\n \n-    /// Adds an edge to or from the `open_node`, assuming `open_node`\n-    /// is not `Ignore`. The direction of the edge is determined by\n-    /// the closure `op` --- we pass as argument the open node `n`,\n-    /// and the closure returns a (source, target) tuple, which should\n-    /// include `n` in one spot or another.\n-    fn add_edge_from_open_node<OP>(&mut self,\n-                                   open_node: OpenNode,\n-                                   op: OP)\n-        where OP: FnOnce(IdIndex) -> (IdIndex, IdIndex)\n-    {\n-        let (source, target) = match open_node {\n-            OpenNode::Node(n) => op(n),\n-            OpenNode::Ignore => { return; }\n-        };\n-\n-        // ignore trivial self edges, which are not very interesting\n-        if source == target {\n-            return;\n-        }\n-\n-        if self.edges.insert((source, target)) {\n-            debug!(\"adding edge from {:?} to {:?}\",\n-                   self.id(source),\n-                   self.id(target));\n-        }\n+    pub fn read_index(&mut self, source: DepNodeIndex) {\n+        let dep_node = self.nodes[source.index()];\n+        self.read(dep_node);\n     }\n \n     pub fn query(&self) -> DepGraphQuery {\n@@ -163,4 +226,30 @@ impl DepGraphEdges {\n                                       .collect();\n         DepGraphQuery::new(&self.nodes, &edges)\n     }\n+\n+    #[inline]\n+    pub fn add_edge(&mut self, source: DepNode, target: DepNode) {\n+        let source = self.get_or_create_node(source);\n+        let target = self.get_or_create_node(target);\n+        self.edges.insert((source, target));\n+    }\n+\n+    pub fn add_node(&mut self, node: DepNode) {\n+        self.get_or_create_node(node);\n+    }\n+\n+    #[inline]\n+    fn get_or_create_node(&mut self, dep_node: DepNode) -> DepNodeIndex {\n+        let DepGraphEdges {\n+            ref mut indices,\n+            ref mut nodes,\n+            ..\n+        } = *self;\n+\n+        *indices.entry(dep_node).or_insert_with(|| {\n+            let next_id = nodes.len();\n+            nodes.push(dep_node);\n+            DepNodeIndex::new(next_id)\n+        })\n+     }\n }"}, {"sha": "4ca59132e0ad917d80e40723b45ec3e2ff086351", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 95, "deletions": 36, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -13,21 +13,20 @@ use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n use std::rc::Rc;\n \n-use super::dep_node::{DepNode, WorkProductId};\n+use super::dep_node::{DepNode, DepKind, WorkProductId};\n use super::query::DepGraphQuery;\n use super::raii;\n use super::safe::DepGraphSafe;\n-use super::thread::{DepGraphThreadData, DepMessage};\n+use super::edges::{DepGraphEdges, DepNodeIndex};\n \n #[derive(Clone)]\n pub struct DepGraph {\n-    data: Rc<DepGraphData>\n+    data: Option<Rc<DepGraphData>>\n }\n \n struct DepGraphData {\n-    /// We send messages to the thread to let it build up the dep-graph\n-    /// from the current run.\n-    thread: DepGraphThreadData,\n+    /// The actual graph data.\n+    edges: RefCell<DepGraphEdges>,\n \n     /// When we load, there may be `.o` files, cached mir, or other such\n     /// things available to us. If we find that they are not dirty, we\n@@ -44,31 +43,35 @@ struct DepGraphData {\n impl DepGraph {\n     pub fn new(enabled: bool) -> DepGraph {\n         DepGraph {\n-            data: Rc::new(DepGraphData {\n-                thread: DepGraphThreadData::new(enabled),\n-                previous_work_products: RefCell::new(FxHashMap()),\n-                work_products: RefCell::new(FxHashMap()),\n-                dep_node_debug: RefCell::new(FxHashMap()),\n-            })\n+            data: if enabled {\n+                Some(Rc::new(DepGraphData {\n+                    previous_work_products: RefCell::new(FxHashMap()),\n+                    work_products: RefCell::new(FxHashMap()),\n+                    edges: RefCell::new(DepGraphEdges::new()),\n+                    dep_node_debug: RefCell::new(FxHashMap()),\n+                }))\n+            } else {\n+                None\n+            }\n         }\n     }\n \n     /// True if we are actually building the full dep-graph.\n     #[inline]\n     pub fn is_fully_enabled(&self) -> bool {\n-        self.data.thread.is_fully_enabled()\n+        self.data.is_some()\n     }\n \n     pub fn query(&self) -> DepGraphQuery {\n-        self.data.thread.query()\n+        self.data.as_ref().unwrap().edges.borrow().query()\n     }\n \n     pub fn in_ignore<'graph>(&'graph self) -> Option<raii::IgnoreTask<'graph>> {\n-        raii::IgnoreTask::new(&self.data.thread)\n+        self.data.as_ref().map(|data| raii::IgnoreTask::new(&data.edges))\n     }\n \n     pub fn in_task<'graph>(&'graph self, key: DepNode) -> Option<raii::DepTask<'graph>> {\n-        raii::DepTask::new(&self.data.thread, key)\n+        self.data.as_ref().map(|data| raii::DepTask::new(&data.edges, key))\n     }\n \n     pub fn with_ignore<OP,R>(&self, op: OP) -> R\n@@ -105,71 +108,126 @@ impl DepGraph {\n     ///   `arg` parameter.\n     ///\n     /// [README]: README.md\n-    pub fn with_task<C, A, R>(&self, key: DepNode, cx: C, arg: A, task: fn(C, A) -> R) -> R\n-        where C: DepGraphSafe, A: DepGraphSafe\n+    pub fn with_task<C, A, R>(&self,\n+                              key: DepNode,\n+                              cx: C,\n+                              arg: A,\n+                              task: fn(C, A) -> R)\n+                              -> (R, DepNodeIndex)\n+        where C: DepGraphSafe\n     {\n-        let _task = self.in_task(key);\n-        task(cx, arg)\n+        if let Some(ref data) = self.data {\n+            data.edges.borrow_mut().push_task(key);\n+            let result = task(cx, arg);\n+            let dep_node_index = data.edges.borrow_mut().pop_task(key);\n+            (result, dep_node_index)\n+        } else {\n+            (task(cx, arg), DepNodeIndex::INVALID)\n+        }\n     }\n \n+    /// Execute something within an \"anonymous\" task, that is, a task the\n+    /// DepNode of which is determined by the list of inputs it read from.\n+    pub fn with_anon_task<OP,R>(&self, dep_kind: DepKind, op: OP) -> (R, DepNodeIndex)\n+        where OP: FnOnce() -> R\n+    {\n+        if let Some(ref data) = self.data {\n+            data.edges.borrow_mut().push_anon_task();\n+            let result = op();\n+            let dep_node = data.edges.borrow_mut().pop_anon_task(dep_kind);\n+            (result, dep_node)\n+        } else {\n+            (op(), DepNodeIndex::INVALID)\n+        }\n+    }\n+\n+    #[inline]\n     pub fn read(&self, v: DepNode) {\n-        if self.data.thread.is_enqueue_enabled() {\n-            self.data.thread.enqueue(DepMessage::Read(v));\n+        if let Some(ref data) = self.data {\n+            data.edges.borrow_mut().read(v);\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn read_index(&self, v: DepNodeIndex) {\n+        if let Some(ref data) = self.data {\n+            data.edges.borrow_mut().read_index(v);\n         }\n     }\n \n+    /// Only to be used during graph loading\n+    #[inline]\n+    pub fn add_edge_directly(&self, source: DepNode, target: DepNode) {\n+        self.data.as_ref().unwrap().edges.borrow_mut().add_edge(source, target);\n+    }\n+\n+    /// Only to be used during graph loading\n+    pub fn add_node_directly(&self, node: DepNode) {\n+        self.data.as_ref().unwrap().edges.borrow_mut().add_node(node);\n+    }\n+\n     /// Indicates that a previous work product exists for `v`. This is\n     /// invoked during initial start-up based on what nodes are clean\n     /// (and what files exist in the incr. directory).\n     pub fn insert_previous_work_product(&self, v: &WorkProductId, data: WorkProduct) {\n         debug!(\"insert_previous_work_product({:?}, {:?})\", v, data);\n-        self.data.previous_work_products.borrow_mut()\n-                                        .insert(v.clone(), data);\n+        self.data\n+            .as_ref()\n+            .unwrap()\n+            .previous_work_products\n+            .borrow_mut()\n+            .insert(v.clone(), data);\n     }\n \n     /// Indicates that we created the given work-product in this run\n     /// for `v`. This record will be preserved and loaded in the next\n     /// run.\n     pub fn insert_work_product(&self, v: &WorkProductId, data: WorkProduct) {\n         debug!(\"insert_work_product({:?}, {:?})\", v, data);\n-        self.data.work_products.borrow_mut()\n-                               .insert(v.clone(), data);\n+        self.data\n+            .as_ref()\n+            .unwrap()\n+            .work_products\n+            .borrow_mut()\n+            .insert(v.clone(), data);\n     }\n \n     /// Check whether a previous work product exists for `v` and, if\n     /// so, return the path that leads to it. Used to skip doing work.\n     pub fn previous_work_product(&self, v: &WorkProductId) -> Option<WorkProduct> {\n-        self.data.previous_work_products.borrow()\n-                                        .get(v)\n-                                        .cloned()\n+        self.data\n+            .as_ref()\n+            .and_then(|data| {\n+                data.previous_work_products.borrow().get(v).cloned()\n+            })\n     }\n \n     /// Access the map of work-products created during this run. Only\n     /// used during saving of the dep-graph.\n     pub fn work_products(&self) -> Ref<FxHashMap<WorkProductId, WorkProduct>> {\n-        self.data.work_products.borrow()\n+        self.data.as_ref().unwrap().work_products.borrow()\n     }\n \n     /// Access the map of work-products created during the cached run. Only\n     /// used during saving of the dep-graph.\n     pub fn previous_work_products(&self) -> Ref<FxHashMap<WorkProductId, WorkProduct>> {\n-        self.data.previous_work_products.borrow()\n+        self.data.as_ref().unwrap().previous_work_products.borrow()\n     }\n \n     #[inline(always)]\n-    pub(super) fn register_dep_node_debug_str<F>(&self,\n-                                                 dep_node: DepNode,\n-                                                 debug_str_gen: F)\n+    pub fn register_dep_node_debug_str<F>(&self,\n+                                          dep_node: DepNode,\n+                                          debug_str_gen: F)\n         where F: FnOnce() -> String\n     {\n-        let mut dep_node_debug = self.data.dep_node_debug.borrow_mut();\n+        let mut dep_node_debug = self.data.as_ref().unwrap().dep_node_debug.borrow_mut();\n \n         dep_node_debug.entry(dep_node)\n                       .or_insert_with(debug_str_gen);\n     }\n \n     pub(super) fn dep_node_debug_str(&self, dep_node: DepNode) -> Option<String> {\n-        self.data.dep_node_debug.borrow().get(&dep_node).cloned()\n+        self.data.as_ref().and_then(|t| t.dep_node_debug.borrow().get(&dep_node).cloned())\n     }\n }\n \n@@ -206,6 +264,7 @@ impl DepGraph {\n /// previous hash. If it matches up, we can reuse the object file.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct WorkProduct {\n+    pub cgu_name: String,\n     /// Extra hash used to decide if work-product is still suitable;\n     /// note that this is *not* a hash of the work-product itself.\n     /// See documentation on `WorkProduct` type for an example."}, {"sha": "ac0c88ced93c83962d6b1c46471a29eb2700d477", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -16,14 +16,13 @@ mod graph;\n mod query;\n mod raii;\n mod safe;\n-mod shadow;\n-mod thread;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::DepNode;\n pub use self::dep_node::WorkProductId;\n pub use self::graph::DepGraph;\n pub use self::graph::WorkProduct;\n+pub use self::edges::DepNodeIndex;\n pub use self::query::DepGraphQuery;\n pub use self::safe::AssertDepGraphSafe;\n pub use self::safe::DepGraphSafe;"}, {"sha": "ce261ca68e8a323b3ee719bf0e5e2fba7095c697", "filename": "src/librustc/dep_graph/raii.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -9,53 +9,49 @@\n // except according to those terms.\n \n use super::DepNode;\n-use super::thread::{DepGraphThreadData, DepMessage};\n+use super::edges::DepGraphEdges;\n+\n+use std::cell::RefCell;\n \n pub struct DepTask<'graph> {\n-    data: &'graph DepGraphThreadData,\n-    key: Option<DepNode>,\n+    graph: &'graph RefCell<DepGraphEdges>,\n+    key: DepNode,\n }\n \n impl<'graph> DepTask<'graph> {\n-    pub fn new(data: &'graph DepGraphThreadData, key: DepNode)\n-               -> Option<DepTask<'graph>> {\n-        if data.is_enqueue_enabled() {\n-            data.enqueue(DepMessage::PushTask(key.clone()));\n-            Some(DepTask { data: data, key: Some(key) })\n-        } else {\n-            None\n+    pub fn new(graph: &'graph RefCell<DepGraphEdges>,\n+               key: DepNode)\n+               -> DepTask<'graph> {\n+        graph.borrow_mut().push_task(key);\n+        DepTask {\n+            graph,\n+            key,\n         }\n     }\n }\n \n impl<'graph> Drop for DepTask<'graph> {\n     fn drop(&mut self) {\n-        if self.data.is_enqueue_enabled() {\n-            self.data.enqueue(DepMessage::PopTask(self.key.take().unwrap()));\n-        }\n+        self.graph.borrow_mut().pop_task(self.key);\n     }\n }\n \n pub struct IgnoreTask<'graph> {\n-    data: &'graph DepGraphThreadData\n+    graph: &'graph RefCell<DepGraphEdges>,\n }\n \n impl<'graph> IgnoreTask<'graph> {\n-    pub fn new(data: &'graph DepGraphThreadData) -> Option<IgnoreTask<'graph>> {\n-        if data.is_enqueue_enabled() {\n-            data.enqueue(DepMessage::PushIgnore);\n-            Some(IgnoreTask { data: data })\n-        } else {\n-            None\n+    pub fn new(graph: &'graph RefCell<DepGraphEdges>) -> IgnoreTask<'graph> {\n+        graph.borrow_mut().push_ignore();\n+        IgnoreTask {\n+            graph\n         }\n     }\n }\n \n impl<'graph> Drop for IgnoreTask<'graph> {\n     fn drop(&mut self) {\n-        if self.data.is_enqueue_enabled() {\n-            self.data.enqueue(DepMessage::PopIgnore);\n-        }\n+        self.graph.borrow_mut().pop_ignore();\n     }\n }\n "}, {"sha": "e32acbf4756ca3592dd2fc563ce994f79bbb75b7", "filename": "src/librustc/dep_graph/shadow.rs", "status": "removed", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/bf0a9e0b4d3a4dd09717960840798e2933ec7568/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf0a9e0b4d3a4dd09717960840798e2933ec7568/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fshadow.rs?ref=bf0a9e0b4d3a4dd09717960840798e2933ec7568", "patch": "@@ -1,151 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The \"Shadow Graph\" is maintained on the main thread and which\n-//! tracks each message relating to the dep-graph and applies some\n-//! sanity checks as they go by. If an error results, it means you get\n-//! a nice stack-trace telling you precisely what caused the error.\n-//!\n-//! NOTE: This is a debugging facility which can potentially have non-trivial\n-//! runtime impact. Therefore, it is largely compiled out if\n-//! debug-assertions are not enabled.\n-//!\n-//! The basic sanity check, enabled if you have debug assertions\n-//! enabled, is that there is always a task (or ignore) on the stack\n-//! when you do read/write, and that the tasks are pushed/popped\n-//! according to a proper stack discipline.\n-//!\n-//! Optionally, if you specify RUST_FORBID_DEP_GRAPH_EDGE, you can\n-//! specify an edge filter to be applied to each edge as it is\n-//! created.  See `./README.md` for details.\n-\n-use std::cell::RefCell;\n-use std::env;\n-\n-use super::DepNode;\n-use super::thread::DepMessage;\n-use super::debug::EdgeFilter;\n-\n-pub struct ShadowGraph {\n-    // if you push None onto the stack, that corresponds to an Ignore\n-    stack: RefCell<Vec<Option<DepNode>>>,\n-    forbidden_edge: Option<EdgeFilter>,\n-}\n-\n-const ENABLED: bool = cfg!(debug_assertions);\n-\n-impl ShadowGraph {\n-    pub fn new() -> Self {\n-        let forbidden_edge = if !ENABLED {\n-            None\n-        } else {\n-            match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n-                Ok(s) => {\n-                    match EdgeFilter::new(&s) {\n-                        Ok(f) => Some(f),\n-                        Err(err) => bug!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n-                    }\n-                }\n-                Err(_) => None,\n-            }\n-        };\n-\n-        ShadowGraph {\n-            stack: RefCell::new(vec![]),\n-            forbidden_edge,\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn enabled(&self) -> bool {\n-        ENABLED\n-    }\n-\n-    pub fn enqueue(&self, message: &DepMessage) {\n-        if ENABLED {\n-            if self.stack.try_borrow().is_err() {\n-                // When we apply edge filters, that invokes the Debug trait on\n-                // DefIds, which in turn reads from various bits of state and\n-                // creates reads! Ignore those recursive reads.\n-                return;\n-            }\n-\n-            let mut stack = self.stack.borrow_mut();\n-            match *message {\n-                // It is ok to READ shared state outside of a\n-                // task. That can't do any harm (at least, the only\n-                // way it can do harm is by leaking that data into a\n-                // query or task, which would be a problem\n-                // anyway). What would be bad is WRITING to that\n-                // state.\n-                DepMessage::Read(_) => { }\n-                DepMessage::Write(ref n) => self.check_edge(top(&stack), Some(Some(n))),\n-                DepMessage::PushTask(ref n) => stack.push(Some(n.clone())),\n-                DepMessage::PushIgnore => stack.push(None),\n-                DepMessage::PopTask(ref n) => {\n-                    match stack.pop() {\n-                        Some(Some(m)) => {\n-                            if *n != m {\n-                                bug!(\"stack mismatch: found {:?} expected {:?}\", m, n)\n-                            }\n-                        }\n-                        Some(None) => bug!(\"stack mismatch: found Ignore expected {:?}\", n),\n-                        None => bug!(\"stack mismatch: found empty stack, expected {:?}\", n),\n-                    }\n-                }\n-                DepMessage::PopIgnore => {\n-                    match stack.pop() {\n-                        Some(Some(m)) => bug!(\"stack mismatch: found {:?} expected ignore\", m),\n-                        Some(None) => (),\n-                        None => bug!(\"stack mismatch: found empty stack, expected ignore\"),\n-                    }\n-                }\n-                DepMessage::Query => (),\n-            }\n-        }\n-    }\n-\n-    fn check_edge(&self,\n-                  source: Option<Option<&DepNode>>,\n-                  target: Option<Option<&DepNode>>) {\n-        assert!(ENABLED);\n-        match (source, target) {\n-            // cannot happen, one side is always Some(Some(_))\n-            (None, None) => unreachable!(),\n-\n-            // nothing on top of the stack\n-            (None, Some(n)) | (Some(n), None) => bug!(\"write of {:?} but no current task\", n),\n-\n-            // this corresponds to an Ignore being top of the stack\n-            (Some(None), _) | (_, Some(None)) => (),\n-\n-            // a task is on top of the stack\n-            (Some(Some(source)), Some(Some(target))) => {\n-                if let Some(ref forbidden_edge) = self.forbidden_edge {\n-                    if forbidden_edge.test(source, target) {\n-                        bug!(\"forbidden edge {:?} -> {:?} created\", source, target)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// Do a little juggling: we get back a reference to an option at the\n-// top of the stack, convert it to an optional reference.\n-fn top<'s>(stack: &'s Vec<Option<DepNode>>) -> Option<Option<&'s DepNode>> {\n-    stack.last()\n-        .map(|n: &'s Option<DepNode>| -> Option<&'s DepNode> {\n-            // (*)\n-            // (*) type annotation just there to clarify what would\n-            // otherwise be some *really* obscure code\n-            n.as_ref()\n-        })\n-}"}, {"sha": "f6635fe16f77d14aca0d978bbc7ccaa0cb42fcbc", "filename": "src/librustc/dep_graph/thread.rs", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/bf0a9e0b4d3a4dd09717960840798e2933ec7568/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf0a9e0b4d3a4dd09717960840798e2933ec7568/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=bf0a9e0b4d3a4dd09717960840798e2933ec7568", "patch": "@@ -1,178 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Manages the communication between the compiler's main thread and\n-//! the thread that constructs the dependency graph. The basic idea is\n-//! to use double buffering to lower the cost of producing a message.\n-//! In the compiler thread, we accumulate messages in a vector until\n-//! the vector is full, or until we want to query the graph, and then\n-//! we send that vector over to the depgraph thread. At the same time,\n-//! we receive an empty vector from the depgraph thread that we can use\n-//! to accumulate more messages. This way we only ever have two vectors\n-//! allocated (and both have a fairly large capacity).\n-\n-use rustc_data_structures::veccell::VecCell;\n-use std::sync::mpsc::{self, Sender, Receiver};\n-use std::thread;\n-\n-use super::DepGraphQuery;\n-use super::DepNode;\n-use super::edges::DepGraphEdges;\n-use super::shadow::ShadowGraph;\n-\n-#[derive(Debug)]\n-pub enum DepMessage {\n-    Read(DepNode),\n-    Write(DepNode),\n-    PushTask(DepNode),\n-    PopTask(DepNode),\n-    PushIgnore,\n-    PopIgnore,\n-    Query,\n-}\n-\n-pub struct DepGraphThreadData {\n-    enabled: bool,\n-\n-    // The \"shadow graph\" is a debugging aid. We give it each message\n-    // in real time as it arrives and it checks for various errors\n-    // (for example, a read/write when there is no current task; it\n-    // can also apply user-defined filters; see `shadow` module for\n-    // details). This only occurs if debug-assertions are enabled.\n-    //\n-    // Note that in some cases the same errors will occur when the\n-    // data is processed off the main thread, but that's annoying\n-    // because it lacks precision about the source of the error.\n-    shadow_graph: ShadowGraph,\n-\n-    // current buffer, where we accumulate messages\n-    messages: VecCell<DepMessage>,\n-\n-    // where to receive new buffer when full\n-    swap_in: Receiver<Vec<DepMessage>>,\n-\n-    // where to send buffer when full\n-    swap_out: Sender<Vec<DepMessage>>,\n-\n-    // where to receive query results\n-    query_in: Receiver<DepGraphQuery>,\n-}\n-\n-const INITIAL_CAPACITY: usize = 2048;\n-\n-impl DepGraphThreadData {\n-    pub fn new(enabled: bool) -> DepGraphThreadData {\n-        let (tx1, rx1) = mpsc::channel();\n-        let (tx2, rx2) = mpsc::channel();\n-        let (txq, rxq) = mpsc::channel();\n-\n-        if enabled {\n-            thread::spawn(move || main(rx1, tx2, txq));\n-        }\n-\n-        DepGraphThreadData {\n-            enabled,\n-            shadow_graph: ShadowGraph::new(),\n-            messages: VecCell::with_capacity(INITIAL_CAPACITY),\n-            swap_in: rx2,\n-            swap_out: tx1,\n-            query_in: rxq,\n-        }\n-    }\n-\n-    /// True if we are actually building the full dep-graph.\n-    #[inline]\n-    pub fn is_fully_enabled(&self) -> bool {\n-        self.enabled\n-    }\n-\n-    /// True if (a) we are actually building the full dep-graph, or (b) we are\n-    /// only enqueuing messages in order to sanity-check them (which happens\n-    /// when debug assertions are enabled).\n-    #[inline]\n-    pub fn is_enqueue_enabled(&self) -> bool {\n-        self.is_fully_enabled() || self.shadow_graph.enabled()\n-    }\n-\n-    /// Sends the current batch of messages to the thread. Installs a\n-    /// new vector of messages.\n-    fn swap(&self) {\n-        assert!(self.is_fully_enabled(), \"should never swap if not fully enabled\");\n-\n-        // should be a buffer waiting for us (though of course we may\n-        // have to wait for depgraph thread to finish processing the\n-        // old messages)\n-        let new_messages = self.swap_in.recv().unwrap();\n-        assert!(new_messages.is_empty());\n-\n-        // swap in the empty buffer and extract the full one\n-        let old_messages = self.messages.swap(new_messages);\n-\n-        // send full buffer to depgraph thread to be processed\n-        self.swap_out.send(old_messages).unwrap();\n-    }\n-\n-    pub fn query(&self) -> DepGraphQuery {\n-        assert!(self.is_fully_enabled(), \"should never query if not fully enabled\");\n-        self.enqueue(DepMessage::Query);\n-        self.swap();\n-        self.query_in.recv().unwrap()\n-    }\n-\n-    /// Enqueue a message to be sent when things are next swapped. (If\n-    /// the buffer is full, this may swap.)\n-    #[inline]\n-    pub fn enqueue(&self, message: DepMessage) {\n-        assert!(self.is_enqueue_enabled(), \"should never enqueue if not enqueue-enabled\");\n-        self.shadow_graph.enqueue(&message);\n-        if self.is_fully_enabled() {\n-            self.enqueue_enabled(message);\n-        }\n-    }\n-\n-    // Outline this fn since I expect it may want to be inlined\n-    // separately.\n-    fn enqueue_enabled(&self, message: DepMessage) {\n-        let len = self.messages.push(message);\n-        if len == INITIAL_CAPACITY {\n-            self.swap();\n-        }\n-    }\n-}\n-\n-/// Definition of the depgraph thread.\n-pub fn main(swap_in: Receiver<Vec<DepMessage>>,\n-            swap_out: Sender<Vec<DepMessage>>,\n-            query_out: Sender<DepGraphQuery>) {\n-    let mut edges = DepGraphEdges::new();\n-\n-    // the compiler thread always expects a fresh buffer to be\n-    // waiting, so queue one up\n-    swap_out.send(Vec::with_capacity(INITIAL_CAPACITY)).unwrap();\n-\n-    // process the buffers from compiler thread as we receive them\n-    for mut messages in swap_in {\n-        for msg in messages.drain(..) {\n-            match msg {\n-                DepMessage::Read(node) => edges.read(node),\n-                DepMessage::Write(node) => edges.write(node),\n-                DepMessage::PushTask(node) => edges.push_task(node),\n-                DepMessage::PopTask(node) => edges.pop_task(node),\n-                DepMessage::PushIgnore => edges.push_ignore(),\n-                DepMessage::PopIgnore => edges.pop_ignore(),\n-                DepMessage::Query => query_out.send(edges.query()).unwrap(),\n-            }\n-        }\n-        if let Err(_) = swap_out.send(messages) {\n-            // the receiver must have been dropped already\n-            break;\n-        }\n-    }\n-}"}, {"sha": "a286ce8c7cb19bed7bae81c6f972bf9e7c73a3dd", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -661,3 +661,60 @@ for ty::TypeckTables<'tcx> {\n         })\n     }\n }\n+\n+impl_stable_hash_for!(enum ty::fast_reject::SimplifiedType {\n+    BoolSimplifiedType,\n+    CharSimplifiedType,\n+    IntSimplifiedType(int_ty),\n+    UintSimplifiedType(int_ty),\n+    FloatSimplifiedType(float_ty),\n+    AdtSimplifiedType(def_id),\n+    StrSimplifiedType,\n+    ArraySimplifiedType,\n+    PtrSimplifiedType,\n+    NeverSimplifiedType,\n+    TupleSimplifiedType(size),\n+    TraitSimplifiedType(def_id),\n+    ClosureSimplifiedType(def_id),\n+    AnonSimplifiedType(def_id),\n+    FunctionSimplifiedType(params),\n+    ParameterSimplifiedType\n+});\n+\n+impl_stable_hash_for!(struct ty::Instance<'tcx> {\n+    def,\n+    substs\n+});\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::InstanceDef<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            ty::InstanceDef::Item(def_id) => {\n+                def_id.hash_stable(hcx, hasher);\n+            }\n+            ty::InstanceDef::Intrinsic(def_id) => {\n+                def_id.hash_stable(hcx, hasher);\n+            }\n+            ty::InstanceDef::FnPtrShim(def_id, ty) => {\n+                def_id.hash_stable(hcx, hasher);\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            ty::InstanceDef::Virtual(def_id, n) => {\n+                def_id.hash_stable(hcx, hasher);\n+                n.hash_stable(hcx, hasher);\n+            }\n+            ty::InstanceDef::ClosureOnceShim { call_once } => {\n+                call_once.hash_stable(hcx, hasher);\n+            }\n+            ty::InstanceDef::DropGlue(def_id, t) => {\n+                def_id.hash_stable(hcx, hasher);\n+                t.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "4b41572c1a1049d3353553331e09cd49eb6c554f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -489,6 +489,12 @@ impl Options {\n             self.debugging_opts.query_dep_graph\n     }\n \n+    #[inline(always)]\n+    pub fn enable_dep_node_debug_strs(&self) -> bool {\n+        cfg!(debug_assertions) &&\n+            (self.debugging_opts.query_dep_graph || self.debugging_opts.incremental_info)\n+    }\n+\n     pub fn single_codegen_unit(&self) -> bool {\n         self.incremental.is_none() ||\n         self.cg.codegen_units == 1"}, {"sha": "32063a2dda603f1b7fb742c6806122008e1711a6", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::DepConstructor;\n use hir::def_id::DefId;\n use ty::{self, Ty, TypeFoldable, Substs};\n use util::ppaux;\n@@ -59,27 +58,6 @@ impl<'tcx> InstanceDef<'tcx> {\n     pub fn attrs<'a>(&self, tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> ty::Attributes<'tcx> {\n         tcx.get_attrs(self.def_id())\n     }\n-\n-    pub //(crate)\n-     fn dep_node(&self) -> DepConstructor {\n-        // HACK: def-id binning, project-style; someone replace this with\n-        // real on-demand.\n-        let ty = match self {\n-            &InstanceDef::FnPtrShim(_, ty) => Some(ty),\n-            &InstanceDef::DropGlue(_, ty) => ty,\n-            _ => None\n-        }.into_iter();\n-\n-        DepConstructor::MirShim(\n-            Some(self.def_id()).into_iter().chain(\n-                ty.flat_map(|t| t.walk()).flat_map(|t| match t.sty {\n-                   ty::TyAdt(adt_def, _) => Some(adt_def.did),\n-                   ty::TyProjection(ref proj) => Some(proj.trait_ref.def_id),\n-                   _ => None,\n-               })\n-            ).collect()\n-        )\n-    }\n }\n \n impl<'tcx> fmt::Display for Instance<'tcx> {"}, {"sha": "e94308f351011660bd911f5aa8aafe5118fcbf5e", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 86, "deletions": 58, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::{DepConstructor, DepNode, DepTrackingMapConfig};\n+use dep_graph::{DepConstructor, DepNode, DepNodeIndex};\n use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use hir::def::Def;\n use hir;\n@@ -186,7 +186,7 @@ impl<'tcx> Value<'tcx> for ty::SymbolName {\n \n struct QueryMap<D: QueryDescription> {\n     phantom: PhantomData<D>,\n-    map: FxHashMap<D::Key, D::Value>,\n+    map: FxHashMap<D::Key, (D::Value, DepNodeIndex)>,\n }\n \n impl<M: QueryDescription> QueryMap<M> {\n@@ -261,11 +261,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-trait QueryDescription: DepTrackingMapConfig {\n+pub trait QueryConfig {\n+    type Key: Eq + Hash + Clone;\n+    type Value;\n+}\n+\n+trait QueryDescription: QueryConfig {\n     fn describe(tcx: TyCtxt, key: Self::Key) -> String;\n }\n \n-impl<M: DepTrackingMapConfig<Key=DefId>> QueryDescription for M {\n+impl<M: QueryConfig<Key=DefId>> QueryDescription for M {\n     default fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"processing `{}`\", tcx.item_path_str(def_id))\n     }\n@@ -550,18 +555,19 @@ macro_rules! define_maps {\n             })*\n         }\n \n-        $(impl<$tcx> DepTrackingMapConfig for queries::$name<$tcx> {\n+        $(impl<$tcx> QueryConfig for queries::$name<$tcx> {\n             type Key = $K;\n             type Value = $V;\n+        }\n \n+        impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n             #[allow(unused)]\n-            fn to_dep_node(tcx: TyCtxt, key: &$K) -> DepNode {\n+            fn to_dep_node(tcx: TyCtxt<'a, $tcx, 'lcx>, key: &$K) -> DepNode {\n                 use dep_graph::DepConstructor::*;\n \n                 DepNode::new(tcx, $node(*key))\n             }\n-        }\n-        impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n+\n             fn try_get_with<F, R>(tcx: TyCtxt<'a, $tcx, 'lcx>,\n                                   mut span: Span,\n                                   key: $K,\n@@ -574,7 +580,8 @@ macro_rules! define_maps {\n                        key,\n                        span);\n \n-                if let Some(result) = tcx.maps.$name.borrow().map.get(&key) {\n+                if let Some(&(ref result, dep_node_index)) = tcx.maps.$name.borrow().map.get(&key) {\n+                    tcx.dep_graph.read_index(dep_node_index);\n                     return Ok(f(result));\n                 }\n \n@@ -585,26 +592,46 @@ macro_rules! define_maps {\n                     span = key.default_span(tcx)\n                 }\n \n-                let _task = tcx.dep_graph.in_task(Self::to_dep_node(tcx, &key));\n-\n-                let result = tcx.cycle_check(span, Query::$name(key), || {\n-                    let provider = tcx.maps.providers[key.map_crate()].$name;\n-                    provider(tcx.global_tcx(), key)\n+                let (result, dep_node_index) = tcx.cycle_check(span, Query::$name(key), || {\n+                    let dep_node = Self::to_dep_node(tcx, &key);\n+\n+                    if dep_node.kind.is_anon() {\n+                        tcx.dep_graph.with_anon_task(dep_node.kind, || {\n+                            let provider = tcx.maps.providers[key.map_crate()].$name;\n+                            provider(tcx.global_tcx(), key)\n+                        })\n+                    } else {\n+                        fn run_provider<'a, 'tcx, 'lcx>(tcx: TyCtxt<'a, 'tcx, 'lcx>,\n+                                                        key: $K)\n+                                                        -> $V {\n+                            let provider = tcx.maps.providers[key.map_crate()].$name;\n+                            provider(tcx.global_tcx(), key)\n+                        }\n+\n+                        tcx.dep_graph.with_task(dep_node, tcx, key, run_provider)\n+                    }\n                 })?;\n \n-                Ok(f(tcx.maps.$name.borrow_mut().map.entry(key).or_insert(result)))\n+                tcx.dep_graph.read_index(dep_node_index);\n+\n+                Ok(f(&tcx.maps\n+                         .$name\n+                         .borrow_mut()\n+                         .map\n+                         .entry(key)\n+                         .or_insert((result, dep_node_index))\n+                         .0))\n             }\n \n             pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n                            -> Result<$V, CycleError<'a, $tcx>> {\n-                // We register the `read` here, but not in `force`, since\n-                // `force` does not give access to the value produced (and thus\n-                // we actually don't read it).\n-                tcx.dep_graph.read(Self::to_dep_node(tcx, &key));\n                 Self::try_get_with(tcx, span, key, Clone::clone)\n             }\n \n             pub fn force(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K) {\n+                // Ignore dependencies, since we not reading the computed value\n+                let _task = tcx.dep_graph.in_ignore();\n+\n                 match Self::try_get_with(tcx, span, key, |_| ()) {\n                     Ok(()) => {}\n                     Err(e) => tcx.report_cycle(e)\n@@ -796,28 +823,28 @@ macro_rules! define_provider_struct {\n // the driver creates (using several `rustc_*` crates).\n define_maps! { <'tcx>\n     /// Records the type of every item.\n-    [] type_of: ItemSignature(DefId) -> Ty<'tcx>,\n+    [] type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated generics and predicates.\n-    [] generics_of: ItemSignature(DefId) -> &'tcx ty::Generics,\n-    [] predicates_of: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n+    [] generics_of: GenericsOfItem(DefId) -> &'tcx ty::Generics,\n+    [] predicates_of: PredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n \n     /// Maps from the def-id of a trait to the list of\n     /// super-predicates. This is a subset of the full list of\n     /// predicates. We store these in a separate map because we must\n     /// evaluate them even during type conversion, often before the\n     /// full predicates are available (note that supertraits have\n     /// additional acyclicity requirements).\n-    [] super_predicates_of: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n+    [] super_predicates_of: SuperPredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n \n     /// To avoid cycles within the predicates of a single item we compute\n     /// per-type-parameter predicates for resolving `T::AssocTy`.\n     [] type_param_predicates: type_param_predicates((DefId, DefId))\n         -> ty::GenericPredicates<'tcx>,\n \n-    [] trait_def: ItemSignature(DefId) -> &'tcx ty::TraitDef,\n-    [] adt_def: ItemSignature(DefId) -> &'tcx ty::AdtDef,\n+    [] trait_def: TraitDefOfItem(DefId) -> &'tcx ty::TraitDef,\n+    [] adt_def: AdtDefOfItem(DefId) -> &'tcx ty::AdtDef,\n     [] adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n     [] adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n     [] adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n@@ -829,7 +856,7 @@ define_maps! { <'tcx>\n     [] is_foreign_item: IsForeignItem(DefId) -> bool,\n \n     /// True if this is a default impl (aka impl Foo for ..)\n-    [] is_default_impl: ItemSignature(DefId) -> bool,\n+    [] is_default_impl: IsDefaultImpl(DefId) -> bool,\n \n     /// Get a map with the variance of every item; use `item_variance`\n     /// instead.\n@@ -845,8 +872,8 @@ define_maps! { <'tcx>\n     /// Maps from a trait item to the trait item \"descriptor\"\n     [] associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n \n-    [] impl_trait_ref: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>>,\n-    [] impl_polarity: ItemSignature(DefId) -> hir::ImplPolarity,\n+    [] impl_trait_ref: ImplTraitRef(DefId) -> Option<ty::TraitRef<'tcx>>,\n+    [] impl_polarity: ImplPolarity(DefId) -> hir::ImplPolarity,\n \n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n@@ -861,36 +888,36 @@ define_maps! { <'tcx>\n     /// Maps DefId's that have an associated Mir to the result\n     /// of the MIR qualify_consts pass. The actual meaning of\n     /// the value isn't known except to the pass itself.\n-    [] mir_const_qualif: Mir(DefId) -> u8,\n+    [] mir_const_qualif: MirConstQualif(DefId) -> u8,\n \n     /// Fetch the MIR for a given def-id up till the point where it is\n     /// ready for const evaluation.\n     ///\n     /// See the README for the `mir` module for details.\n-    [] mir_const: Mir(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+    [] mir_const: MirConst(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n-    [] mir_validated: Mir(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+    [] mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n     /// MIR after our optimization passes have run. This is MIR that is ready\n     /// for trans. This is also the only query that can fetch non-local MIR, at present.\n-    [] optimized_mir: Mir(DefId) -> &'tcx mir::Mir<'tcx>,\n+    [] optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n \n     /// Type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n-    [] closure_kind: ItemSignature(DefId) -> ty::ClosureKind,\n+    [] closure_kind: ClosureKind(DefId) -> ty::ClosureKind,\n \n     /// The signature of functions and closures.\n-    [] fn_sig: ItemSignature(DefId) -> ty::PolyFnSig<'tcx>,\n+    [] fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n-    [] coerce_unsized_info: ItemSignature(DefId)\n+    [] coerce_unsized_info: CoerceUnsizedInfo(DefId)\n         -> ty::adjustment::CoerceUnsizedInfo,\n \n     [] typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n \n     [] typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n \n-    [] has_typeck_tables: TypeckTables(DefId) -> bool,\n+    [] has_typeck_tables: HasTypeckTables(DefId) -> bool,\n \n     [] coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n \n@@ -972,80 +999,81 @@ define_maps! { <'tcx>\n     [] extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n }\n \n-fn type_param_predicates((item_id, param_id): (DefId, DefId)) -> DepConstructor {\n+fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n     DepConstructor::TypeParamPredicates {\n         item_id,\n         param_id\n     }\n }\n \n-fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepConstructor {\n+fn coherent_trait_dep_node<'tcx>((_, def_id): (CrateNum, DefId)) -> DepConstructor<'tcx> {\n     DepConstructor::CoherenceCheckTrait(def_id)\n }\n \n-fn crate_inherent_impls_dep_node(_: CrateNum) -> DepConstructor {\n+fn crate_inherent_impls_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::Coherence\n }\n \n-fn reachability_dep_node(_: CrateNum) -> DepConstructor {\n+fn reachability_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::Reachability\n }\n \n-fn mir_shim_dep_node(instance: ty::InstanceDef) -> DepConstructor {\n-    instance.dep_node()\n+fn mir_shim_dep_node<'tcx>(instance_def: ty::InstanceDef<'tcx>) -> DepConstructor<'tcx> {\n+    DepConstructor::MirShim {\n+        instance_def\n+    }\n }\n \n-fn symbol_name_dep_node(instance: ty::Instance) -> DepConstructor {\n-    // symbol_name uses the substs only to traverse them to find the\n-    // hash, and that does not create any new dep-nodes.\n-    DepConstructor::SymbolName(instance.def.def_id())\n+fn symbol_name_dep_node<'tcx>(instance: ty::Instance<'tcx>) -> DepConstructor<'tcx> {\n+    DepConstructor::InstanceSymbolName { instance }\n }\n \n-fn typeck_item_bodies_dep_node(_: CrateNum) -> DepConstructor {\n+fn typeck_item_bodies_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::TypeckBodiesKrate\n }\n \n-fn const_eval_dep_node((def_id, _): (DefId, &Substs)) -> DepConstructor {\n-    DepConstructor::ConstEval(def_id)\n+fn const_eval_dep_node<'tcx>((def_id, substs): (DefId, &'tcx Substs<'tcx>))\n+                             -> DepConstructor<'tcx> {\n+    DepConstructor::ConstEval { def_id, substs }\n }\n \n-fn mir_keys(_: CrateNum) -> DepConstructor {\n+fn mir_keys<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::MirKeys\n }\n \n-fn crate_variances(_: CrateNum) -> DepConstructor {\n+fn crate_variances<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::CrateVariances\n }\n \n-fn relevant_trait_impls_for((def_id, _): (DefId, SimplifiedType)) -> DepConstructor {\n-    DepConstructor::TraitImpls(def_id)\n+fn relevant_trait_impls_for<'tcx>((def_id, t): (DefId, SimplifiedType)) -> DepConstructor<'tcx> {\n+    DepConstructor::RelevantTraitImpls(def_id, t)\n }\n \n-fn is_copy_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor {\n+fn is_copy_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n     let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n         .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n     DepConstructor::IsCopy(def_id)\n }\n \n-fn is_sized_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor {\n+fn is_sized_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n     let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n         .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n     DepConstructor::IsSized(def_id)\n }\n \n-fn is_freeze_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor {\n+fn is_freeze_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n     let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n         .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n     DepConstructor::IsFreeze(def_id)\n }\n \n-fn needs_drop_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor {\n+fn needs_drop_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n     let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n         .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n     DepConstructor::NeedsDrop(def_id)\n }\n \n-fn layout_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor {\n+fn layout_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n     let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n         .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n     DepConstructor::Layout(def_id)"}, {"sha": "2c43896ec73d242d9170957f423373baa109006d", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -189,7 +189,8 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          &serialized_dep_graph.nodes,\n                          &dirty_raw_nodes,\n                          &mut clean_work_products,\n-                         &mut dirty_work_products);\n+                         &mut dirty_work_products,\n+                         &work_products);\n         }\n     }\n \n@@ -201,11 +202,7 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             clean_work_products.insert(wp_id);\n         }\n \n-        tcx.dep_graph.with_task(*bootstrap_output, (), (), create_node);\n-\n-        fn create_node((): (), (): ()) {\n-            // just create the node with no inputs\n-        }\n+        tcx.dep_graph.add_node_directly(*bootstrap_output);\n     }\n \n     // Add in work-products that are still clean, and delete those that are\n@@ -394,7 +391,8 @@ fn process_edge<'a, 'tcx, 'edges>(\n     nodes: &IndexVec<DepNodeIndex, DepNode>,\n     dirty_raw_nodes: &DirtyNodes,\n     clean_work_products: &mut FxHashSet<WorkProductId>,\n-    dirty_work_products: &mut FxHashSet<WorkProductId>)\n+    dirty_work_products: &mut FxHashSet<WorkProductId>,\n+    work_products: &[SerializedWorkProduct])\n {\n     // If the target is dirty, skip the edge. If this is an edge\n     // that targets a work-product, we can print the blame\n@@ -418,9 +416,11 @@ fn process_edge<'a, 'tcx, 'edges>(\n                         format!(\"{:?}\", blame)\n                     };\n \n-                    eprintln!(\"incremental: module {:?} is dirty because {:?} \\\n-                               changed or was removed\",\n-                              wp_id,\n+                    let wp = work_products.iter().find(|swp| swp.id == wp_id).unwrap();\n+\n+                    eprintln!(\"incremental: module {:?} is dirty because \\\n+                              {:?} changed or was removed\",\n+                              wp.work_product.cgu_name,\n                               blame_str);\n                 }\n             }\n@@ -449,13 +449,11 @@ fn process_edge<'a, 'tcx, 'edges>(\n     if !dirty_raw_nodes.contains_key(&target) {\n         let target = nodes[target];\n         let source = nodes[source];\n-        let _task = tcx.dep_graph.in_task(target);\n-        tcx.dep_graph.read(source);\n+        tcx.dep_graph.add_edge_directly(source, target);\n \n         if let DepKind::WorkProduct = target.kind {\n             let wp_id = WorkProductId::from_fingerprint(target.hash);\n             clean_work_products.insert(wp_id);\n         }\n     }\n }\n-"}, {"sha": "8f99ce91a67a985eee1117c8554a4e860ede9f2f", "filename": "src/librustc_incremental/persist/work_product.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -55,6 +55,7 @@ pub fn save_trans_partition(sess: &Session,\n     };\n \n     let work_product = WorkProduct {\n+        cgu_name: cgu_name.to_string(),\n         input_hash: partition_hash,\n         saved_files: saved_files,\n     };"}, {"sha": "4bdfdd51f659aceb323a624bffecdc72d187e89a", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -12,7 +12,7 @@ use cstore;\n use encoder;\n use schema;\n \n-use rustc::dep_graph::DepTrackingMapConfig;\n+use rustc::ty::maps::QueryConfig;\n use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind,\n                             NativeLibrary, MetadataLoader, LinkMeta,\n                             LinkagePreference, LoadedMacro, EncodedMetadata};\n@@ -45,7 +45,7 @@ macro_rules! provide {\n         pub fn provide<$lt>(providers: &mut Providers<$lt>) {\n             $(fn $name<'a, $lt:$lt>($tcx: TyCtxt<'a, $lt, $lt>, $def_id: DefId)\n                                     -> <ty::queries::$name<$lt> as\n-                                        DepTrackingMapConfig>::Value {\n+                                        QueryConfig>::Value {\n                 assert!(!$def_id.is_local());\n \n                 let def_path_hash = $tcx.def_path_hash($def_id);"}, {"sha": "9feccc1337266ab0d0d2fd9852b2b846683cac94", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -1120,7 +1120,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         .into_iter()\n         .map(|cgu| {\n             let dep_node = cgu.work_product_dep_node();\n-            let (stats, module) =\n+            let ((stats, module), _) =\n                 tcx.dep_graph.with_task(dep_node,\n                                         AssertDepGraphSafe(&shared_ccx),\n                                         AssertDepGraphSafe(cgu),"}, {"sha": "68b72087b2e6596229e77702d5f520c70046eb51", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -270,6 +270,14 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n         (&cgu1.name[..]).cmp(&cgu2.name[..])\n     });\n \n+    if scx.sess().opts.enable_dep_node_debug_strs() {\n+        for cgu in &result {\n+            let dep_node = cgu.work_product_dep_node();\n+            scx.tcx().dep_graph.register_dep_node_debug_str(dep_node,\n+                                                            || cgu.name().to_string());\n+        }\n+    }\n+\n     result\n }\n "}, {"sha": "647605ae4383e823623bf7314139624dc798b0bd", "filename": "src/test/compile-fail/dep-graph-struct-signature.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -34,54 +34,64 @@ struct WontChange {\n mod signatures {\n     use WillChange;\n \n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n+    #[rustc_then_this_would_need(TypeOfItem)] //~ ERROR no path\n+    #[rustc_then_this_would_need(AssociatedItems)] //~ ERROR no path\n+    #[rustc_then_this_would_need(TraitDefOfItem)] //~ ERROR no path\n     trait Bar {\n-        #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+        #[rustc_then_this_would_need(FnSignature)] //~ ERROR OK\n         fn do_something(x: WillChange);\n     }\n \n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(FnSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n     fn some_fn(x: WillChange) { }\n \n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(FnSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n     fn new_foo(x: u32, y: u32) -> WillChange {\n         WillChange { x: x, y: y }\n     }\n \n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(TypeOfItem)] //~ ERROR OK\n     impl WillChange {\n+        #[rustc_then_this_would_need(FnSignature)] //~ ERROR OK\n+        #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n         fn new(x: u32, y: u32) -> WillChange { loop { } }\n     }\n \n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(TypeOfItem)] //~ ERROR OK\n     impl WillChange {\n+        #[rustc_then_this_would_need(FnSignature)] //~ ERROR OK\n+        #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n         fn method(&self, x: u32) { }\n     }\n \n     struct WillChanges {\n-        #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+        #[rustc_then_this_would_need(TypeOfItem)] //~ ERROR OK\n         x: WillChange,\n-        #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+        #[rustc_then_this_would_need(TypeOfItem)] //~ ERROR OK\n         y: WillChange\n     }\n \n     // The fields change, not the type itself.\n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n+    #[rustc_then_this_would_need(TypeOfItem)] //~ ERROR no path\n     fn indirect(x: WillChanges) { }\n }\n \n mod invalid_signatures {\n     use WontChange;\n \n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n+    #[rustc_then_this_would_need(TypeOfItem)] //~ ERROR no path\n     trait A {\n+        #[rustc_then_this_would_need(FnSignature)] //~ ERROR no path\n         fn do_something_else_twice(x: WontChange);\n     }\n \n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n+    #[rustc_then_this_would_need(FnSignature)] //~ ERROR no path\n+    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path\n     fn b(x: WontChange) { }\n \n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path from `WillChange`\n+    #[rustc_then_this_would_need(FnSignature)] //~ ERROR no path from `WillChange`\n+    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path from `WillChange`\n     fn c(x: u32) { }\n }\n-"}, {"sha": "dca1fa4d98f95d97226ff11a32a79306e26cdb45", "filename": "src/test/compile-fail/dep-graph-type-alias.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9228d231fc05488647c6d72516b527963310ac2d/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9228d231fc05488647c6d72516b527963310ac2d/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs?ref=9228d231fc05488647c6d72516b527963310ac2d", "patch": "@@ -25,40 +25,42 @@ type TypeAlias = u32;\n \n // The type alias directly affects the type of the field,\n // not the enclosing struct:\n-#[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n+#[rustc_then_this_would_need(TypeOfItem)] //~ ERROR no path\n struct Struct {\n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(TypeOfItem)] //~ ERROR OK\n     x: TypeAlias,\n     y: u32\n }\n \n-#[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n+#[rustc_then_this_would_need(TypeOfItem)] //~ ERROR no path\n enum Enum {\n     Variant1 {\n-        #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+        #[rustc_then_this_would_need(TypeOfItem)] //~ ERROR OK\n         t: TypeAlias\n     },\n     Variant2(i32)\n }\n \n-#[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n+#[rustc_then_this_would_need(TypeOfItem)] //~ ERROR no path\n trait Trait {\n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(FnSignature)] //~ ERROR OK\n     fn method(&self, _: TypeAlias);\n }\n \n struct SomeType;\n \n-#[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n+#[rustc_then_this_would_need(TypeOfItem)] //~ ERROR no path\n impl SomeType {\n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(FnSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n     fn method(&self, _: TypeAlias) {}\n }\n \n-#[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+#[rustc_then_this_would_need(TypeOfItem)] //~ ERROR OK\n type TypeAlias2 = TypeAlias;\n \n-#[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+#[rustc_then_this_would_need(FnSignature)] //~ ERROR OK\n+#[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n fn function(_: TypeAlias) {\n \n }"}]}