{"sha": "234b9301087ac21dd1dec5e6cad59cb76346ee6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNGI5MzAxMDg3YWMyMWRkMWRlYzVlNmNhZDU5Y2I3NjM0NmVlNmM=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2019-12-29T02:02:20Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2020-01-13T01:40:50Z"}, "message": "rename nonlexical_regioncx -> regioncx", "tree": {"sha": "a15917dd10c3cbd0dd6d78f49a8f66c10e2baf8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a15917dd10c3cbd0dd6d78f49a8f66c10e2baf8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/234b9301087ac21dd1dec5e6cad59cb76346ee6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/234b9301087ac21dd1dec5e6cad59cb76346ee6c", "html_url": "https://github.com/rust-lang/rust/commit/234b9301087ac21dd1dec5e6cad59cb76346ee6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/234b9301087ac21dd1dec5e6cad59cb76346ee6c/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66c5d5b70697dd98468a88b455dc99681c810db1", "url": "https://api.github.com/repos/rust-lang/rust/commits/66c5d5b70697dd98468a88b455dc99681c810db1", "html_url": "https://github.com/rust-lang/rust/commit/66c5d5b70697dd98468a88b455dc99681c810db1"}], "stats": {"total": 82, "additions": 34, "deletions": 48}, "files": [{"sha": "ca5cf5bc741a020765a60d00d19184eb28c14f33", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/234b9301087ac21dd1dec5e6cad59cb76346ee6c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/234b9301087ac21dd1dec5e6cad59cb76346ee6c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=234b9301087ac21dd1dec5e6cad59cb76346ee6c", "patch": "@@ -260,17 +260,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n     ) -> (ConstraintCategory, bool, Span, Option<RegionName>) {\n-        let (category, from_closure, span) = self.nonlexical_regioncx.best_blame_constraint(\n+        let (category, from_closure, span) = self.regioncx.best_blame_constraint(\n             &self.body,\n             borrow_region,\n             NLLRegionVariableOrigin::FreeRegion,\n-            |r| {\n-                self.nonlexical_regioncx.provides_universal_region(\n-                    r,\n-                    borrow_region,\n-                    outlived_region,\n-                )\n-            },\n+            |r| self.regioncx.provides_universal_region(r, borrow_region, outlived_region),\n         );\n \n         let mut renctx = RegionErrorNamingCtx::new();\n@@ -303,15 +297,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             location, borrow, kind_place\n         );\n \n-        let regioncx = &self.nonlexical_regioncx;\n+        let regioncx = &self.regioncx;\n         let body: &Body<'_> = &self.body;\n         let tcx = self.infcx.tcx;\n \n         let borrow_region_vid = borrow.region;\n         debug!(\"explain_why_borrow_contains_point: borrow_region_vid={:?}\", borrow_region_vid);\n \n-        let region_sub =\n-            self.nonlexical_regioncx.find_sub_region_live_at(borrow_region_vid, location);\n+        let region_sub = self.regioncx.find_sub_region_live_at(borrow_region_vid, location);\n         debug!(\"explain_why_borrow_contains_point: region_sub={:?}\", region_sub);\n \n         match find_use::find(body, regioncx, tcx, region_sub, location) {"}, {"sha": "f3dc8e72e301635180b86c66c26d321a1e85d007", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/234b9301087ac21dd1dec5e6cad59cb76346ee6c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/234b9301087ac21dd1dec5e6cad59cb76346ee6c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=234b9301087ac21dd1dec5e6cad59cb76346ee6c", "patch": "@@ -112,19 +112,18 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// to find a good name from that. Returns `None` if we can't find\n     /// one (e.g., this is just some random part of the CFG).\n     pub(super) fn to_error_region(&self, r: RegionVid) -> Option<ty::Region<'tcx>> {\n-        self.to_error_region_vid(r)\n-            .and_then(|r| self.nonlexical_regioncx.region_definition(r).external_name)\n+        self.to_error_region_vid(r).and_then(|r| self.regioncx.region_definition(r).external_name)\n     }\n \n     /// Returns the `RegionVid` corresponding to the region returned by\n     /// `to_error_region`.\n     pub(super) fn to_error_region_vid(&self, r: RegionVid) -> Option<RegionVid> {\n-        if self.nonlexical_regioncx.universal_regions().is_universal_region(r) {\n+        if self.regioncx.universal_regions().is_universal_region(r) {\n             Some(r)\n         } else {\n-            let upper_bound = self.nonlexical_regioncx.universal_upper_bound(r);\n+            let upper_bound = self.regioncx.universal_upper_bound(r);\n \n-            if self.nonlexical_regioncx.upper_bound_in_region_scc(r, upper_bound) {\n+            if self.regioncx.upper_bound_in_region_scc(r, upper_bound) {\n                 self.to_error_region_vid(upper_bound)\n             } else {\n                 None\n@@ -137,7 +136,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if let Some(ty::ReFree(free_region)) = self.to_error_region(fr) {\n             if let ty::BoundRegion::BrEnv = free_region.bound_region {\n                 if let DefiningTy::Closure(def_id, substs) =\n-                    self.nonlexical_regioncx.universal_regions().defining_ty\n+                    self.regioncx.universal_regions().defining_ty\n                 {\n                     let closure_kind_ty = substs.as_closure().kind_ty(def_id, self.infcx.tcx);\n                     return Some(ty::ClosureKind::FnMut) == closure_kind_ty.to_opt_closure_kind();\n@@ -219,11 +218,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     fr_origin,\n                     error_element,\n                 } => {\n-                    let error_region =\n-                        self.nonlexical_regioncx.region_from_element(longer_fr, error_element);\n+                    let error_region = self.regioncx.region_from_element(longer_fr, error_element);\n \n                     // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n-                    let (_, span) = self.nonlexical_regioncx.find_outlives_blame_span(\n+                    let (_, span) = self.regioncx.find_outlives_blame_span(\n                         &self.body,\n                         longer_fr,\n                         fr_origin,\n@@ -286,8 +284,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n         let (category, _, span) =\n-            self.nonlexical_regioncx.best_blame_constraint(&self.body, fr, fr_origin, |r| {\n-                self.nonlexical_regioncx.provides_universal_region(r, fr, outlived_fr)\n+            self.regioncx.best_blame_constraint(&self.body, fr, fr_origin, |r| {\n+                self.regioncx.provides_universal_region(r, fr, outlived_fr)\n             });\n \n         debug!(\"report_error: category={:?} {:?}\", category, span);\n@@ -302,8 +300,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         }\n \n         let (fr_is_local, outlived_fr_is_local): (bool, bool) = (\n-            self.nonlexical_regioncx.universal_regions().is_local_free_region(fr),\n-            self.nonlexical_regioncx.universal_regions().is_local_free_region(outlived_fr),\n+            self.regioncx.universal_regions().is_local_free_region(fr),\n+            self.regioncx.universal_regions().is_local_free_region(outlived_fr),\n         );\n \n         debug!(\n@@ -378,7 +376,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         // We should check if the return type of this closure is in fact a closure - in that\n         // case, we can special case the error further.\n         let return_type_is_closure =\n-            self.nonlexical_regioncx.universal_regions().unnormalized_output_ty.is_closure();\n+            self.regioncx.universal_regions().unnormalized_output_ty.is_closure();\n         let message = if return_type_is_closure {\n             \"returns a closure that contains a reference to a captured variable, which then \\\n              escapes the closure body\"\n@@ -430,22 +428,22 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ) -> DiagnosticBuilder<'tcx> {\n         let ErrorConstraintInfo { span, category, .. } = errci;\n \n-        let fr_name_and_span = self.nonlexical_regioncx.get_var_name_and_span_for_region(\n+        let fr_name_and_span = self.regioncx.get_var_name_and_span_for_region(\n             self.infcx.tcx,\n             &self.body,\n             &self.local_names,\n             &self.upvars,\n             errci.fr,\n         );\n-        let outlived_fr_name_and_span = self.nonlexical_regioncx.get_var_name_and_span_for_region(\n+        let outlived_fr_name_and_span = self.regioncx.get_var_name_and_span_for_region(\n             self.infcx.tcx,\n             &self.body,\n             &self.local_names,\n             &self.upvars,\n             errci.outlived_fr,\n         );\n \n-        let escapes_from = match self.nonlexical_regioncx.universal_regions().defining_ty {\n+        let escapes_from = match self.regioncx.universal_regions().defining_ty {\n             DefiningTy::Closure(..) => \"closure\",\n             DefiningTy::Generator(..) => \"generator\",\n             DefiningTy::FnDef(..) => \"function\","}, {"sha": "7ce29713240ce12cdead7ab67257e841433be32b", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/234b9301087ac21dd1dec5e6cad59cb76346ee6c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/234b9301087ac21dd1dec5e6cad59cb76346ee6c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=234b9301087ac21dd1dec5e6cad59cb76346ee6c", "patch": "@@ -191,7 +191,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ) -> Option<RegionName> {\n         debug!(\"give_region_a_name(fr={:?}, counter={:?})\", fr, renctx.counter);\n \n-        assert!(self.nonlexical_regioncx.universal_regions().is_universal_region(fr));\n+        assert!(self.regioncx.universal_regions().is_universal_region(fr));\n \n         if let Some(value) = renctx.get(&fr) {\n             return Some(value.clone());\n@@ -277,7 +277,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                         .hir()\n                         .as_local_hir_id(self.mir_def_id)\n                         .expect(\"non-local mir\");\n-                    let def_ty = self.nonlexical_regioncx.universal_regions().defining_ty;\n+                    let def_ty = self.regioncx.universal_regions().defining_ty;\n \n                     if let DefiningTy::Closure(def_id, substs) = def_ty {\n                         let args_span = if let hir::ExprKind::Closure(_, _, _, span, _) =\n@@ -344,12 +344,10 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         fr: RegionVid,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let implicit_inputs =\n-            self.nonlexical_regioncx.universal_regions().defining_ty.implicit_inputs();\n-        let argument_index =\n-            self.nonlexical_regioncx.get_argument_index_for_region(self.infcx.tcx, fr)?;\n+        let implicit_inputs = self.regioncx.universal_regions().defining_ty.implicit_inputs();\n+        let argument_index = self.regioncx.get_argument_index_for_region(self.infcx.tcx, fr)?;\n \n-        let arg_ty = self.nonlexical_regioncx.universal_regions().unnormalized_input_tys\n+        let arg_ty = self.regioncx.universal_regions().unnormalized_input_tys\n             [implicit_inputs + argument_index];\n         if let Some(region_name) =\n             self.give_name_if_we_can_match_hir_ty_from_argument(fr, arg_ty, argument_index, renctx)\n@@ -415,10 +413,9 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         );\n         let assigned_region_name = if type_name.find(&format!(\"'{}\", counter)).is_some() {\n             // Only add a label if we can confirm that a region was labelled.\n-            let argument_index = self\n-                .nonlexical_regioncx\n-                .get_argument_index_for_region(self.infcx.tcx, needle_fr)?;\n-            let (_, span) = self.nonlexical_regioncx.get_argument_name_and_span_for_region(\n+            let argument_index =\n+                self.regioncx.get_argument_index_for_region(self.infcx.tcx, needle_fr)?;\n+            let (_, span) = self.regioncx.get_argument_name_and_span_for_region(\n                 &self.body,\n                 &self.local_names,\n                 argument_index,\n@@ -658,9 +655,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         fr: RegionVid,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let upvar_index =\n-            self.nonlexical_regioncx.get_upvar_index_for_region(self.infcx.tcx, fr)?;\n-        let (upvar_name, upvar_span) = self.nonlexical_regioncx.get_upvar_name_and_span_for_region(\n+        let upvar_index = self.regioncx.get_upvar_index_for_region(self.infcx.tcx, fr)?;\n+        let (upvar_name, upvar_span) = self.regioncx.get_upvar_name_and_span_for_region(\n             self.infcx.tcx,\n             &self.upvars,\n             upvar_index,\n@@ -684,7 +680,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ) -> Option<RegionName> {\n         let tcx = self.infcx.tcx;\n \n-        let return_ty = self.nonlexical_regioncx.universal_regions().unnormalized_output_ty;\n+        let return_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n         debug!(\"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\", return_ty);\n         if !tcx.any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr) {\n             return None;\n@@ -734,7 +730,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ) -> Option<RegionName> {\n         // Note: generators from `async fn` yield `()`, so we don't have to\n         // worry about them here.\n-        let yield_ty = self.nonlexical_regioncx.universal_regions().yield_ty?;\n+        let yield_ty = self.regioncx.universal_regions().yield_ty?;\n         debug!(\"give_name_if_anonymous_region_appears_in_yield_ty: yield_ty = {:?}\", yield_ty,);\n \n         let tcx = self.infcx.tcx;"}, {"sha": "0ad9d4492b2087eeca4b2b8ad49e31e54213a39a", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/234b9301087ac21dd1dec5e6cad59cb76346ee6c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/234b9301087ac21dd1dec5e6cad59cb76346ee6c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=234b9301087ac21dd1dec5e6cad59cb76346ee6c", "patch": "@@ -283,7 +283,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         move_error_reported: BTreeMap::new(),\n         uninitialized_error_reported: Default::default(),\n         errors_buffer,\n-        nonlexical_regioncx: regioncx,\n+        regioncx,\n         used_mut: Default::default(),\n         used_mut_upvars: SmallVec::new(),\n         borrow_set,\n@@ -474,10 +474,9 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     /// If the function we're checking is a closure, then we'll need to report back the list of\n     /// mutable upvars that have been used. This field keeps track of them.\n     used_mut_upvars: SmallVec<[Field; 8]>,\n-    /// Non-lexical region inference context, if NLL is enabled. This\n-    /// contains the results from region inference and lets us e.g.\n+    /// Region inference context. This contains the results from region inference and lets us e.g.\n     /// find out which CFG points are contained in each borrow region.\n-    nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n+    regioncx: Rc<RegionInferenceContext<'tcx>>,\n \n     /// The set of borrows extracted from the MIR\n     borrow_set: Rc<BorrowSet<'tcx>>,"}]}