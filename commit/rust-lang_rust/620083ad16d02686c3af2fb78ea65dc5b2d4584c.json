{"sha": "620083ad16d02686c3af2fb78ea65dc5b2d4584c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMDA4M2FkMTZkMDI2ODZjM2FmMmZiNzhlYTY1ZGM1YjJkNDU4NGM=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-10-25T09:39:12Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-10-25T09:39:12Z"}, "message": "refactoring: move const_to_pat code into its own submodule.", "tree": {"sha": "277e8dca840abd0090fe8ca13a8f348baf9ef002", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/277e8dca840abd0090fe8ca13a8f348baf9ef002"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/620083ad16d02686c3af2fb78ea65dc5b2d4584c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/620083ad16d02686c3af2fb78ea65dc5b2d4584c", "html_url": "https://github.com/rust-lang/rust/commit/620083ad16d02686c3af2fb78ea65dc5b2d4584c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/620083ad16d02686c3af2fb78ea65dc5b2d4584c/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f7b922afe7cca0ecdd4dd1124935d89122cb904", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f7b922afe7cca0ecdd4dd1124935d89122cb904", "html_url": "https://github.com/rust-lang/rust/commit/4f7b922afe7cca0ecdd4dd1124935d89122cb904"}], "stats": {"total": 422, "additions": 217, "deletions": 205}, "files": [{"sha": "c92bbce98d0997ba4c8ddee36169816732126005", "filename": "src/librustc_mir/hair/pattern/const_to_pat.rs", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/620083ad16d02686c3af2fb78ea65dc5b2d4584c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620083ad16d02686c3af2fb78ea65dc5b2d4584c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=620083ad16d02686c3af2fb78ea65dc5b2d4584c", "patch": "@@ -0,0 +1,216 @@\n+use crate::const_eval::const_variant_index;\n+\n+use rustc::hir;\n+use rustc::lint;\n+use rustc::mir::Field;\n+use rustc::traits::{ObligationCause, PredicateObligation};\n+use rustc::ty;\n+\n+use rustc_index::vec::Idx;\n+\n+use syntax::symbol::sym;\n+use syntax_pos::Span;\n+\n+use super::{FieldPat, Pat, PatCtxt, PatKind};\n+\n+impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n+    /// Converts an evaluated constant to a pattern (if possible).\n+    /// This means aggregate values (like structs and enums) are converted\n+    /// to a pattern that matches the value (as if you'd compared via structural equality).\n+    pub(super) fn const_to_pat(\n+        &self,\n+        instance: ty::Instance<'tcx>,\n+        cv: &'tcx ty::Const<'tcx>,\n+        id: hir::HirId,\n+        span: Span,\n+    ) -> Pat<'tcx> {\n+        // This method is just a warpper handling a validity check; the heavy lifting is\n+        // performed by the recursive const_to_pat_inner method, which is not meant to be\n+        // invoked except by this method.\n+        //\n+        // once indirect_structural_match is a full fledged error, this\n+        // level of indirection can be eliminated\n+\n+        debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n+        debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n+\n+        let mut saw_error = false;\n+        let inlined_const_as_pat = self.const_to_pat_inner(instance, cv, id, span, &mut saw_error);\n+\n+        if self.include_lint_checks && !saw_error {\n+            // If we were able to successfully convert the const to some pat, double-check\n+            // that the type of the const obeys `#[structural_match]` constraint.\n+            if let Some(non_sm_ty) = ty::search_for_structural_match_violation(self.tcx, cv.ty) {\n+                let msg = match non_sm_ty {\n+                    ty::NonStructuralMatchTy::Adt(adt_def) => {\n+                        let path = self.tcx.def_path_str(adt_def.did);\n+                        format!(\n+                            \"to use a constant of type `{}` in a pattern, \\\n+                             `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                            path,\n+                            path,\n+                        )\n+                    }\n+                    ty::NonStructuralMatchTy::Param => {\n+                        bug!(\"use of constant whose type is a parameter inside a pattern\");\n+                    }\n+                };\n+\n+                // before issuing lint, double-check there even *is* a\n+                // semantic PartialEq for us to dispatch to.\n+                //\n+                // (If there isn't, then we can safely issue a hard\n+                // error, because that's never worked, due to compiler\n+                // using PartialEq::eq in this scenario in the past.)\n+\n+                let ty_is_partial_eq: bool = {\n+                    let partial_eq_trait_id = self.tcx.lang_items().eq_trait().unwrap();\n+                    let obligation: PredicateObligation<'_> =\n+                        self.tcx.predicate_for_trait_def(self.param_env,\n+                                                         ObligationCause::misc(span, id),\n+                                                         partial_eq_trait_id,\n+                                                         0,\n+                                                         cv.ty,\n+                                                         &[]);\n+                    self.tcx\n+                        .infer_ctxt()\n+                        .enter(|infcx| infcx.predicate_may_hold(&obligation))\n+                };\n+\n+                if !ty_is_partial_eq {\n+                    // span_fatal avoids ICE from resolution of non-existent method (rare case).\n+                    self.tcx.sess.span_fatal(span, &msg);\n+                } else {\n+                    self.tcx.lint_hir(lint::builtin::INDIRECT_STRUCTURAL_MATCH, id, span, &msg);\n+                }\n+            }\n+        }\n+\n+        inlined_const_as_pat\n+    }\n+\n+    /// Recursive helper for `const_to_pat`; invoke that (instead of calling this directly).\n+    fn const_to_pat_inner(\n+        &self,\n+        instance: ty::Instance<'tcx>,\n+        cv: &'tcx ty::Const<'tcx>,\n+        id: hir::HirId,\n+        span: Span,\n+        // This tracks if we signal some hard error for a given const\n+        // value, so that we will not subsequently issue an irrelevant\n+        // lint for the same const value.\n+        saw_const_match_error: &mut bool,\n+    ) -> Pat<'tcx> {\n+\n+        let mut adt_subpattern = |i, variant_opt| {\n+            let field = Field::new(i);\n+            let val = crate::const_eval::const_field(\n+                self.tcx, self.param_env, variant_opt, field, cv\n+            );\n+            self.const_to_pat_inner(instance, val, id, span, saw_const_match_error)\n+        };\n+        let mut adt_subpatterns = |n, variant_opt| {\n+            (0..n).map(|i| {\n+                let field = Field::new(i);\n+                FieldPat {\n+                    field,\n+                    pattern: adt_subpattern(i, variant_opt),\n+                }\n+            }).collect::<Vec<_>>()\n+        };\n+\n+\n+        let kind = match cv.ty.kind {\n+            ty::Float(_) => {\n+                self.tcx.lint_hir(\n+                    ::rustc::lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+                    id,\n+                    span,\n+                    \"floating-point types cannot be used in patterns\",\n+                );\n+                PatKind::Constant {\n+                    value: cv,\n+                }\n+            }\n+            ty::Adt(adt_def, _) if adt_def.is_union() => {\n+                // Matching on union fields is unsafe, we can't hide it in constants\n+                *saw_const_match_error = true;\n+                self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n+                PatKind::Wild\n+            }\n+            // keep old code until future-compat upgraded to errors.\n+            ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n+                let path = self.tcx.def_path_str(adt_def.did);\n+                let msg = format!(\n+                    \"to use a constant of type `{}` in a pattern, \\\n+                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                    path,\n+                    path,\n+                );\n+                *saw_const_match_error = true;\n+                self.tcx.sess.span_err(span, &msg);\n+                PatKind::Wild\n+            }\n+            // keep old code until future-compat upgraded to errors.\n+            ty::Ref(_, ty::TyS { kind: ty::Adt(adt_def, _), .. }, _)\n+            if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n+                // HACK(estebank): Side-step ICE #53708, but anything other than erroring here\n+                // would be wrong. Returnging `PatKind::Wild` is not technically correct.\n+                let path = self.tcx.def_path_str(adt_def.did);\n+                let msg = format!(\n+                    \"to use a constant of type `{}` in a pattern, \\\n+                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                    path,\n+                    path,\n+                );\n+                *saw_const_match_error = true;\n+                self.tcx.sess.span_err(span, &msg);\n+                PatKind::Wild\n+            }\n+            ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n+                let variant_index = const_variant_index(self.tcx, self.param_env, cv);\n+                let subpatterns = adt_subpatterns(\n+                    adt_def.variants[variant_index].fields.len(),\n+                    Some(variant_index),\n+                );\n+                PatKind::Variant {\n+                    adt_def,\n+                    substs,\n+                    variant_index,\n+                    subpatterns,\n+                }\n+            }\n+            ty::Adt(adt_def, _) => {\n+                let struct_var = adt_def.non_enum_variant();\n+                PatKind::Leaf {\n+                    subpatterns: adt_subpatterns(struct_var.fields.len(), None),\n+                }\n+            }\n+            ty::Tuple(fields) => {\n+                PatKind::Leaf {\n+                    subpatterns: adt_subpatterns(fields.len(), None),\n+                }\n+            }\n+            ty::Array(_, n) => {\n+                PatKind::Array {\n+                    prefix: (0..n.eval_usize(self.tcx, self.param_env))\n+                        .map(|i| adt_subpattern(i as usize, None))\n+                        .collect(),\n+                    slice: None,\n+                    suffix: Vec::new(),\n+                }\n+            }\n+            _ => {\n+                PatKind::Constant {\n+                    value: cv,\n+                }\n+            }\n+        };\n+\n+        Pat {\n+            span,\n+            ty: cv.ty,\n+            kind: Box::new(kind),\n+        }\n+    }\n+}"}, {"sha": "331770003b682a687d50fdd28515d88de73cacd2", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 205, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/620083ad16d02686c3af2fb78ea65dc5b2d4584c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620083ad16d02686c3af2fb78ea65dc5b2d4584c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=620083ad16d02686c3af2fb78ea65dc5b2d4584c", "patch": "@@ -2,19 +2,16 @@\n \n mod _match;\n mod check_match;\n+mod const_to_pat;\n \n pub(crate) use self::check_match::check_match;\n \n-use crate::const_eval::const_variant_index;\n-\n use crate::hair::util::UserAnnotatedTyHelpers;\n use crate::hair::constant::*;\n \n-use rustc::lint;\n use rustc::mir::{Field, BorrowKind, Mutability};\n use rustc::mir::{UserTypeProjection};\n use rustc::mir::interpret::{GlobalId, ConstValue, get_slice_bytes, sign_extend};\n-use rustc::traits::{ObligationCause, PredicateObligation};\n use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, UserType, DefIdTree};\n use rustc::ty::{CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations};\n use rustc::ty::subst::{SubstsRef, GenericArg};\n@@ -29,7 +26,6 @@ use rustc_index::vec::Idx;\n use std::cmp::Ordering;\n use std::fmt;\n use syntax::ast;\n-use syntax::symbol::sym;\n use syntax_pos::Span;\n \n #[derive(Clone, Debug)]\n@@ -972,206 +968,6 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n         }\n     }\n-\n-    /// Converts an evaluated constant to a pattern (if possible).\n-    /// This means aggregate values (like structs and enums) are converted\n-    /// to a pattern that matches the value (as if you'd compared via structural equality).\n-    fn const_to_pat(\n-        &self,\n-        instance: ty::Instance<'tcx>,\n-        cv: &'tcx ty::Const<'tcx>,\n-        id: hir::HirId,\n-        span: Span,\n-    ) -> Pat<'tcx> {\n-        // This method is just a warpper handling a validity check; the heavy lifting is\n-        // performed by the recursive const_to_pat_inner method, which is not meant to be\n-        // invoked except by this method.\n-        //\n-        // once indirect_structural_match is a full fledged error, this\n-        // level of indirection can be eliminated\n-\n-        debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n-        debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n-\n-        let mut saw_error = false;\n-        let inlined_const_as_pat = self.const_to_pat_inner(instance, cv, id, span, &mut saw_error);\n-\n-        if self.include_lint_checks && !saw_error {\n-            // If we were able to successfully convert the const to some pat, double-check\n-            // that the type of the const obeys `#[structural_match]` constraint.\n-            if let Some(non_sm_ty) = ty::search_for_structural_match_violation(self.tcx, cv.ty) {\n-                let msg = match non_sm_ty {\n-                    ty::NonStructuralMatchTy::Adt(adt_def) => {\n-                        let path = self.tcx.def_path_str(adt_def.did);\n-                        format!(\n-                            \"to use a constant of type `{}` in a pattern, \\\n-                             `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                            path,\n-                            path,\n-                        )\n-                    }\n-                    ty::NonStructuralMatchTy::Param => {\n-                        bug!(\"use of constant whose type is a parameter inside a pattern\");\n-                    }\n-                };\n-\n-                // before issuing lint, double-check there even *is* a\n-                // semantic PartialEq for us to dispatch to.\n-                //\n-                // (If there isn't, then we can safely issue a hard\n-                // error, because that's never worked, due to compiler\n-                // using PartialEq::eq in this scenario in the past.)\n-\n-                let ty_is_partial_eq: bool = {\n-                    let partial_eq_trait_id = self.tcx.lang_items().eq_trait().unwrap();\n-                    let obligation: PredicateObligation<'_> =\n-                        self.tcx.predicate_for_trait_def(self.param_env,\n-                                                         ObligationCause::misc(span, id),\n-                                                         partial_eq_trait_id,\n-                                                         0,\n-                                                         cv.ty,\n-                                                         &[]);\n-                    self.tcx\n-                        .infer_ctxt()\n-                        .enter(|infcx| infcx.predicate_may_hold(&obligation))\n-                };\n-\n-                if !ty_is_partial_eq {\n-                    // span_fatal avoids ICE from resolution of non-existent method (rare case).\n-                    self.tcx.sess.span_fatal(span, &msg);\n-                } else {\n-                    self.tcx.lint_hir(lint::builtin::INDIRECT_STRUCTURAL_MATCH, id, span, &msg);\n-                }\n-            }\n-        }\n-\n-        inlined_const_as_pat\n-    }\n-\n-    /// Recursive helper for `const_to_pat`; invoke that (instead of calling this directly).\n-    fn const_to_pat_inner(\n-        &self,\n-        instance: ty::Instance<'tcx>,\n-        cv: &'tcx ty::Const<'tcx>,\n-        id: hir::HirId,\n-        span: Span,\n-        // This tracks if we signal some hard error for a given const\n-        // value, so that we will not subsequently issue an irrelevant\n-        // lint for the same const value.\n-        saw_const_match_error: &mut bool,\n-    ) -> Pat<'tcx> {\n-\n-        let mut adt_subpattern = |i, variant_opt| {\n-            let field = Field::new(i);\n-            let val = crate::const_eval::const_field(\n-                self.tcx, self.param_env, variant_opt, field, cv\n-            );\n-            self.const_to_pat_inner(instance, val, id, span, saw_const_match_error)\n-        };\n-        let mut adt_subpatterns = |n, variant_opt| {\n-            (0..n).map(|i| {\n-                let field = Field::new(i);\n-                FieldPat {\n-                    field,\n-                    pattern: adt_subpattern(i, variant_opt),\n-                }\n-            }).collect::<Vec<_>>()\n-        };\n-\n-\n-        let kind = match cv.ty.kind {\n-            ty::Float(_) => {\n-                self.tcx.lint_hir(\n-                    ::rustc::lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n-                    id,\n-                    span,\n-                    \"floating-point types cannot be used in patterns\",\n-                );\n-                PatKind::Constant {\n-                    value: cv,\n-                }\n-            }\n-            ty::Adt(adt_def, _) if adt_def.is_union() => {\n-                // Matching on union fields is unsafe, we can't hide it in constants\n-                *saw_const_match_error = true;\n-                self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n-                PatKind::Wild\n-            }\n-            // keep old code until future-compat upgraded to errors.\n-            ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n-                let path = self.tcx.def_path_str(adt_def.did);\n-                let msg = format!(\n-                    \"to use a constant of type `{}` in a pattern, \\\n-                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                    path,\n-                    path,\n-                );\n-                *saw_const_match_error = true;\n-                self.tcx.sess.span_err(span, &msg);\n-                PatKind::Wild\n-            }\n-            // keep old code until future-compat upgraded to errors.\n-            ty::Ref(_, ty::TyS { kind: ty::Adt(adt_def, _), .. }, _)\n-            if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n-                // HACK(estebank): Side-step ICE #53708, but anything other than erroring here\n-                // would be wrong. Returnging `PatKind::Wild` is not technically correct.\n-                let path = self.tcx.def_path_str(adt_def.did);\n-                let msg = format!(\n-                    \"to use a constant of type `{}` in a pattern, \\\n-                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                    path,\n-                    path,\n-                );\n-                *saw_const_match_error = true;\n-                self.tcx.sess.span_err(span, &msg);\n-                PatKind::Wild\n-            }\n-            ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n-                let variant_index = const_variant_index(self.tcx, self.param_env, cv);\n-                let subpatterns = adt_subpatterns(\n-                    adt_def.variants[variant_index].fields.len(),\n-                    Some(variant_index),\n-                );\n-                PatKind::Variant {\n-                    adt_def,\n-                    substs,\n-                    variant_index,\n-                    subpatterns,\n-                }\n-            }\n-            ty::Adt(adt_def, _) => {\n-                let struct_var = adt_def.non_enum_variant();\n-                PatKind::Leaf {\n-                    subpatterns: adt_subpatterns(struct_var.fields.len(), None),\n-                }\n-            }\n-            ty::Tuple(fields) => {\n-                PatKind::Leaf {\n-                    subpatterns: adt_subpatterns(fields.len(), None),\n-                }\n-            }\n-            ty::Array(_, n) => {\n-                PatKind::Array {\n-                    prefix: (0..n.eval_usize(self.tcx, self.param_env))\n-                        .map(|i| adt_subpattern(i as usize, None))\n-                        .collect(),\n-                    slice: None,\n-                    suffix: Vec::new(),\n-                }\n-            }\n-            _ => {\n-                PatKind::Constant {\n-                    value: cv,\n-                }\n-            }\n-        };\n-\n-        Pat {\n-            span,\n-            ty: cv.ty,\n-            kind: Box::new(kind),\n-        }\n-    }\n }\n \n impl UserAnnotatedTyHelpers<'tcx> for PatCtxt<'_, 'tcx> {"}]}