{"sha": "91a0600a5c22b9d159e3c57526af83e71d1120f8", "node_id": "C_kwDOAAsO6NoAKDkxYTA2MDBhNWMyMmI5ZDE1OWUzYzU3NTI2YWY4M2U3MWQxMTIwZjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-18T18:08:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-18T18:08:51Z"}, "message": "Auto merge of #92065 - matthiaskrgr:rollup-qmpcsuj, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #91566 (Apply path remapping to DW_AT_GNU_dwo_name when producing split DWARF)\n - #91926 (Remove `in_band_lifetimes` from `rustc_metadata`)\n - #91931 (Remove `in_band_lifetimes` from `rustc_codegen_llvm`)\n - #92024 (rustc_codegen_llvm: Give each codegen unit a unique DWARF name on all platforms, not just Apple ones.)\n - #92037 (Use a const ParamEnv when in default_method_body_is_const)\n - #92047 (Set `RUST_BACKTRACE=0` when running location-detail tests)\n - #92050 (Add a space and 2 grave accents )\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "142be686bed6df375c8d289790e67dd1affd7fd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/142be686bed6df375c8d289790e67dd1affd7fd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91a0600a5c22b9d159e3c57526af83e71d1120f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91a0600a5c22b9d159e3c57526af83e71d1120f8", "html_url": "https://github.com/rust-lang/rust/commit/91a0600a5c22b9d159e3c57526af83e71d1120f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91a0600a5c22b9d159e3c57526af83e71d1120f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3848cb659105d8384c00ba384ec2f6f39c47238", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3848cb659105d8384c00ba384ec2f6f39c47238", "html_url": "https://github.com/rust-lang/rust/commit/d3848cb659105d8384c00ba384ec2f6f39c47238"}, {"sha": "1ac1f24ddd54865f1719eb8c0e48c4858be1b744", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ac1f24ddd54865f1719eb8c0e48c4858be1b744", "html_url": "https://github.com/rust-lang/rust/commit/1ac1f24ddd54865f1719eb8c0e48c4858be1b744"}], "stats": {"total": 972, "additions": 543, "deletions": 429}, "files": [{"sha": "e9b66b54c58b3b6e6cf4291fd49fe7fbff342a13", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -136,11 +136,11 @@ impl ArgAttributesExt for ArgAttributes {\n }\n \n pub trait LlvmType {\n-    fn llvm_type(&self, cx: &CodegenCx<'ll, '_>) -> &'ll Type;\n+    fn llvm_type<'ll>(&self, cx: &CodegenCx<'ll, '_>) -> &'ll Type;\n }\n \n impl LlvmType for Reg {\n-    fn llvm_type(&self, cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    fn llvm_type<'ll>(&self, cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         match self.kind {\n             RegKind::Integer => cx.type_ix(self.size.bits()),\n             RegKind::Float => match self.size.bits() {\n@@ -154,7 +154,7 @@ impl LlvmType for Reg {\n }\n \n impl LlvmType for CastTarget {\n-    fn llvm_type(&self, cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    fn llvm_type<'ll>(&self, cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         let rest_ll_unit = self.rest.unit.llvm_type(cx);\n         let (rest_count, rem_bytes) = if self.rest.unit.size.bytes() == 0 {\n             (0, 0)\n@@ -212,7 +212,7 @@ pub trait ArgAbiExt<'ll, 'tcx> {\n     );\n }\n \n-impl ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n+impl<'ll, 'tcx> ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n     /// Gets the LLVM type for a place of the original Rust type of\n     /// this argument/return, i.e., the result of `type_of::type_of`.\n     fn memory_ty(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n@@ -287,7 +287,7 @@ impl ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n \n     fn store_fn_arg(\n         &self,\n-        bx: &mut Builder<'a, 'll, 'tcx>,\n+        bx: &mut Builder<'_, 'll, 'tcx>,\n         idx: &mut usize,\n         dst: PlaceRef<'tcx, &'ll Value>,\n     ) {\n@@ -314,7 +314,7 @@ impl ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n     }\n }\n \n-impl ArgAbiMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+impl<'ll, 'tcx> ArgAbiMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n     fn store_fn_arg(\n         &mut self,\n         arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n@@ -336,15 +336,15 @@ impl ArgAbiMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n-pub trait FnAbiLlvmExt<'tcx> {\n+pub trait FnAbiLlvmExt<'ll, 'tcx> {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n     fn ptr_to_llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n     fn llvm_cconv(&self) -> llvm::CallConv;\n     fn apply_attrs_llfn(&self, cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value);\n-    fn apply_attrs_callsite(&self, bx: &mut Builder<'a, 'll, 'tcx>, callsite: &'ll Value);\n+    fn apply_attrs_callsite(&self, bx: &mut Builder<'_, 'll, 'tcx>, callsite: &'ll Value);\n }\n \n-impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n+impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n         // Ignore \"extra\" args from the call site for C variadic functions.\n         // Only the \"fixed\" args are part of the LLVM function signature.\n@@ -505,7 +505,7 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn apply_attrs_callsite(&self, bx: &mut Builder<'a, 'll, 'tcx>, callsite: &'ll Value) {\n+    fn apply_attrs_callsite(&self, bx: &mut Builder<'_, 'll, 'tcx>, callsite: &'ll Value) {\n         if self.ret.layout.abi.is_uninhabited() {\n             llvm::Attribute::NoReturn.apply_callsite(llvm::AttributePlace::Function, callsite);\n         }\n@@ -610,7 +610,7 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     }\n }\n \n-impl AbiBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+impl<'tcx> AbiBuilderMethods<'tcx> for Builder<'_, '_, 'tcx> {\n     fn apply_attrs_callsite(&mut self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>, callsite: Self::Value) {\n         fn_abi.apply_attrs_callsite(self, callsite)\n     }"}, {"sha": "caf16c1939df00fc5d94fce08c584ca9ce7df411", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -23,7 +23,7 @@ use rustc_target::asm::*;\n use libc::{c_char, c_uint};\n use tracing::debug;\n \n-impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n     fn codegen_llvm_inline_asm(\n         &mut self,\n         ia: &hir::LlvmInlineAsmInner,\n@@ -399,7 +399,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n-impl AsmMethods for CodegenCx<'ll, 'tcx> {\n+impl AsmMethods for CodegenCx<'_, '_> {\n     fn codegen_global_asm(\n         &self,\n         template: &[InlineAsmTemplatePiece],\n@@ -447,8 +447,8 @@ impl AsmMethods for CodegenCx<'ll, 'tcx> {\n     }\n }\n \n-pub(crate) fn inline_asm_call(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n+pub(crate) fn inline_asm_call<'ll>(\n+    bx: &mut Builder<'_, 'll, '_>,\n     asm: &str,\n     cons: &str,\n     inputs: &[&'ll Value],\n@@ -583,7 +583,7 @@ fn a64_vreg_index(reg: InlineAsmReg) -> Option<u32> {\n }\n \n /// Converts a register class to an LLVM constraint code.\n-fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'tcx>>) -> String {\n+fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'_>>) -> String {\n     match reg {\n         // For vector registers LLVM wants the register name to match the type size.\n         InlineAsmRegOrRegClass::Reg(reg) => {\n@@ -773,7 +773,7 @@ fn modifier_to_llvm(\n \n /// Type to use for outputs that are discarded. It doesn't really matter what\n /// the type is, as long as it is valid for the constraint code.\n-fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll Type {\n+fn dummy_output_type<'ll>(cx: &CodegenCx<'ll, '_>, reg: InlineAsmRegClass) -> &'ll Type {\n     match reg {\n         InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg)\n@@ -841,7 +841,7 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n \n /// Helper function to get the LLVM type for a Scalar. Pointers are returned as\n /// the equivalent integer type.\n-fn llvm_asm_scalar_type(cx: &CodegenCx<'ll, 'tcx>, scalar: Scalar) -> &'ll Type {\n+fn llvm_asm_scalar_type<'ll>(cx: &CodegenCx<'ll, '_>, scalar: Scalar) -> &'ll Type {\n     match scalar.value {\n         Primitive::Int(Integer::I8, _) => cx.type_i8(),\n         Primitive::Int(Integer::I16, _) => cx.type_i16(),\n@@ -855,8 +855,8 @@ fn llvm_asm_scalar_type(cx: &CodegenCx<'ll, 'tcx>, scalar: Scalar) -> &'ll Type\n }\n \n /// Fix up an input value to work around LLVM bugs.\n-fn llvm_fixup_input(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n+fn llvm_fixup_input<'ll, 'tcx>(\n+    bx: &mut Builder<'_, 'll, 'tcx>,\n     mut value: &'ll Value,\n     reg: InlineAsmRegClass,\n     layout: &TyAndLayout<'tcx>,\n@@ -933,8 +933,8 @@ fn llvm_fixup_input(\n }\n \n /// Fix up an output value to work around LLVM bugs.\n-fn llvm_fixup_output(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n+fn llvm_fixup_output<'ll, 'tcx>(\n+    bx: &mut Builder<'_, 'll, 'tcx>,\n     mut value: &'ll Value,\n     reg: InlineAsmRegClass,\n     layout: &TyAndLayout<'tcx>,\n@@ -1009,7 +1009,7 @@ fn llvm_fixup_output(\n }\n \n /// Output type to use for llvm_fixup_output.\n-fn llvm_fixup_output_type(\n+fn llvm_fixup_output_type<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     reg: InlineAsmRegClass,\n     layout: &TyAndLayout<'tcx>,"}, {"sha": "bd25087c08e8c3b8c4937b11a1a88ecc8b4a8a13", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -25,7 +25,7 @@ use crate::value::Value;\n \n /// Mark LLVM function to use provided inline heuristic.\n #[inline]\n-fn inline(cx: &CodegenCx<'ll, '_>, val: &'ll Value, inline: InlineAttr) {\n+fn inline<'ll>(cx: &CodegenCx<'ll, '_>, val: &'ll Value, inline: InlineAttr) {\n     use self::InlineAttr::*;\n     match inline {\n         Hint => Attribute::InlineHint.apply_llfn(Function, val),\n@@ -41,7 +41,7 @@ fn inline(cx: &CodegenCx<'ll, '_>, val: &'ll Value, inline: InlineAttr) {\n \n /// Apply LLVM sanitize attributes.\n #[inline]\n-pub fn sanitize(cx: &CodegenCx<'ll, '_>, no_sanitize: SanitizerSet, llfn: &'ll Value) {\n+pub fn sanitize<'ll>(cx: &CodegenCx<'ll, '_>, no_sanitize: SanitizerSet, llfn: &'ll Value) {\n     let enabled = cx.tcx.sess.opts.debugging_opts.sanitizer - no_sanitize;\n     if enabled.contains(SanitizerSet::ADDRESS) {\n         llvm::Attribute::SanitizeAddress.apply_llfn(Function, llfn);\n@@ -59,17 +59,17 @@ pub fn sanitize(cx: &CodegenCx<'ll, '_>, no_sanitize: SanitizerSet, llfn: &'ll V\n \n /// Tell LLVM to emit or not emit the information necessary to unwind the stack for the function.\n #[inline]\n-pub fn emit_uwtable(val: &'ll Value, emit: bool) {\n+pub fn emit_uwtable(val: &Value, emit: bool) {\n     Attribute::UWTable.toggle_llfn(Function, val, emit);\n }\n \n /// Tell LLVM if this function should be 'naked', i.e., skip the epilogue and prologue.\n #[inline]\n-fn naked(val: &'ll Value, is_naked: bool) {\n+fn naked(val: &Value, is_naked: bool) {\n     Attribute::Naked.toggle_llfn(Function, val, is_naked);\n }\n \n-pub fn set_frame_pointer_type(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+pub fn set_frame_pointer_type<'ll>(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     let mut fp = cx.sess().target.frame_pointer;\n     // \"mcount\" function relies on stack pointer.\n     // See <https://sourceware.org/binutils/docs/gprof/Implementation.html>.\n@@ -92,7 +92,7 @@ pub fn set_frame_pointer_type(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n \n /// Tell LLVM what instrument function to insert.\n #[inline]\n-fn set_instrument_function(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+fn set_instrument_function<'ll>(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     if cx.sess().instrument_mcount() {\n         // Similar to `clang -pg` behavior. Handled by the\n         // `post-inline-ee-instrument` LLVM pass.\n@@ -110,7 +110,7 @@ fn set_instrument_function(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     }\n }\n \n-fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+fn set_probestack<'ll>(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     // Currently stack probes seem somewhat incompatible with the address\n     // sanitizer and thread sanitizer. With asan we're already protected from\n     // stack overflow anyway so we don't really need stack probes regardless.\n@@ -161,7 +161,7 @@ fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     }\n }\n \n-fn set_stackprotector(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+fn set_stackprotector<'ll>(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     let sspattr = match cx.sess().stack_protector() {\n         StackProtector::None => return,\n         StackProtector::All => Attribute::StackProtectReq,\n@@ -172,7 +172,7 @@ fn set_stackprotector(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     sspattr.apply_llfn(Function, llfn)\n }\n \n-pub fn apply_target_cpu_attr(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+pub fn apply_target_cpu_attr<'ll>(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     let target_cpu = SmallCStr::new(llvm_util::target_cpu(cx.tcx.sess));\n     llvm::AddFunctionAttrStringValue(\n         llfn,\n@@ -182,7 +182,7 @@ pub fn apply_target_cpu_attr(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     );\n }\n \n-pub fn apply_tune_cpu_attr(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+pub fn apply_tune_cpu_attr<'ll>(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     if let Some(tune) = llvm_util::tune_cpu(cx.tcx.sess) {\n         let tune_cpu = SmallCStr::new(tune);\n         llvm::AddFunctionAttrStringValue(\n@@ -196,14 +196,14 @@ pub fn apply_tune_cpu_attr(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n \n /// Sets the `NonLazyBind` LLVM attribute on a given function,\n /// assuming the codegen options allow skipping the PLT.\n-pub fn non_lazy_bind(sess: &Session, llfn: &'ll Value) {\n+pub fn non_lazy_bind<'ll>(sess: &Session, llfn: &'ll Value) {\n     // Don't generate calls through PLT if it's not necessary\n     if !sess.needs_plt() {\n         Attribute::NonLazyBind.apply_llfn(Function, llfn);\n     }\n }\n \n-pub(crate) fn default_optimisation_attrs(sess: &Session, llfn: &'ll Value) {\n+pub(crate) fn default_optimisation_attrs<'ll>(sess: &Session, llfn: &'ll Value) {\n     match sess.opts.optimize {\n         OptLevel::Size => {\n             llvm::Attribute::MinSize.unapply_llfn(Function, llfn);\n@@ -226,7 +226,11 @@ pub(crate) fn default_optimisation_attrs(sess: &Session, llfn: &'ll Value) {\n \n /// Composite function which sets LLVM attributes for function depending on its AST (`#[attribute]`)\n /// attributes.\n-pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::Instance<'tcx>) {\n+pub fn from_fn_attrs<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    llfn: &'ll Value,\n+    instance: ty::Instance<'tcx>,\n+) {\n     let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(instance.def_id());\n \n     match codegen_fn_attrs.optimize {"}, {"sha": "4bb1fed2d510d02d56869b383314dda0b15acf88", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -363,7 +363,7 @@ fn fat_lto(\n \n crate struct Linker<'a>(&'a mut llvm::Linker<'a>);\n \n-impl Linker<'a> {\n+impl<'a> Linker<'a> {\n     crate fn new(llmod: &'a llvm::Module) -> Self {\n         unsafe { Linker(llvm::LLVMRustLinkerNew(llmod)) }\n     }\n@@ -383,7 +383,7 @@ impl Linker<'a> {\n     }\n }\n \n-impl Drop for Linker<'a> {\n+impl Drop for Linker<'_> {\n     fn drop(&mut self) {\n         unsafe {\n             llvm::LLVMRustLinkerFree(&mut *(self.0 as *mut _));"}, {"sha": "fb194a98a0de48364eb7c8d330389df51c34b9c7", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -46,7 +46,7 @@ pub fn llvm_err(handler: &rustc_errors::Handler, msg: &str) -> FatalError {\n     }\n }\n \n-pub fn write_output_file(\n+pub fn write_output_file<'ll>(\n     handler: &rustc_errors::Handler,\n     target: &'ll llvm::TargetMachine,\n     pm: &llvm::PassManager<'ll>,\n@@ -205,8 +205,11 @@ pub fn target_machine_factory(\n     let use_init_array =\n         !sess.opts.debugging_opts.use_ctors_section.unwrap_or(sess.target.use_ctors_section);\n \n+    let path_mapping = sess.source_map().path_mapping().clone();\n+\n     Arc::new(move |config: TargetMachineFactoryConfig| {\n-        let split_dwarf_file = config.split_dwarf_file.unwrap_or_default();\n+        let split_dwarf_file =\n+            path_mapping.map_prefix(config.split_dwarf_file.unwrap_or_default()).0;\n         let split_dwarf_file = CString::new(split_dwarf_file.to_str().unwrap()).unwrap();\n \n         let tm = unsafe {"}, {"sha": "483b81d23bc24b36fcf910033a4fe29862ee04e4", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -39,7 +39,7 @@ pub struct ValueIter<'ll> {\n     step: unsafe extern \"C\" fn(&'ll Value) -> Option<&'ll Value>,\n }\n \n-impl Iterator for ValueIter<'ll> {\n+impl<'ll> Iterator for ValueIter<'ll> {\n     type Item = &'ll Value;\n \n     fn next(&mut self) -> Option<&'ll Value> {\n@@ -51,14 +51,11 @@ impl Iterator for ValueIter<'ll> {\n     }\n }\n \n-pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n+pub fn iter_globals(llmod: &llvm::Module) -> ValueIter<'_> {\n     unsafe { ValueIter { cur: llvm::LLVMGetFirstGlobal(llmod), step: llvm::LLVMGetNextGlobal } }\n }\n \n-pub fn compile_codegen_unit(\n-    tcx: TyCtxt<'tcx>,\n-    cgu_name: Symbol,\n-) -> (ModuleCodegen<ModuleLlvm>, u64) {\n+pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol) -> (ModuleCodegen<ModuleLlvm>, u64) {\n     let start_time = Instant::now();\n \n     let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);"}, {"sha": "8c3054b23ff412f9a4da186a5a66a8685a37ba91", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -36,7 +36,7 @@ pub struct Builder<'a, 'll, 'tcx> {\n     pub cx: &'a CodegenCx<'ll, 'tcx>,\n }\n \n-impl Drop for Builder<'a, 'll, 'tcx> {\n+impl Drop for Builder<'_, '_, '_> {\n     fn drop(&mut self) {\n         unsafe {\n             llvm::LLVMDisposeBuilder(&mut *(self.llbuilder as *mut _));\n@@ -52,7 +52,7 @@ const EMPTY_C_STR: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b\"\\0\") }\n // FIXME(eddyb) pass `&CStr` directly to FFI once it's a thin pointer.\n const UNNAMED: *const c_char = EMPTY_C_STR.as_ptr();\n \n-impl BackendTypes for Builder<'_, 'll, 'tcx> {\n+impl<'ll, 'tcx> BackendTypes for Builder<'_, 'll, 'tcx> {\n     type Value = <CodegenCx<'ll, 'tcx> as BackendTypes>::Value;\n     type Function = <CodegenCx<'ll, 'tcx> as BackendTypes>::Function;\n     type BasicBlock = <CodegenCx<'ll, 'tcx> as BackendTypes>::BasicBlock;\n@@ -70,27 +70,27 @@ impl abi::HasDataLayout for Builder<'_, '_, '_> {\n     }\n }\n \n-impl ty::layout::HasTyCtxt<'tcx> for Builder<'_, '_, 'tcx> {\n+impl<'tcx> ty::layout::HasTyCtxt<'tcx> for Builder<'_, '_, 'tcx> {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.cx.tcx\n     }\n }\n \n-impl ty::layout::HasParamEnv<'tcx> for Builder<'_, '_, 'tcx> {\n+impl<'tcx> ty::layout::HasParamEnv<'tcx> for Builder<'_, '_, 'tcx> {\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.cx.param_env()\n     }\n }\n \n-impl HasTargetSpec for Builder<'_, '_, 'tcx> {\n+impl HasTargetSpec for Builder<'_, '_, '_> {\n     #[inline]\n     fn target_spec(&self) -> &Target {\n         self.cx.target_spec()\n     }\n }\n \n-impl LayoutOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n+impl<'tcx> LayoutOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n     type LayoutOfResult = TyAndLayout<'tcx>;\n \n     #[inline]\n@@ -99,7 +99,7 @@ impl LayoutOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n     }\n }\n \n-impl FnAbiOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n+impl<'tcx> FnAbiOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n     type FnAbiOfResult = &'tcx FnAbi<'tcx, Ty<'tcx>>;\n \n     #[inline]\n@@ -113,7 +113,7 @@ impl FnAbiOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n     }\n }\n \n-impl Deref for Builder<'_, 'll, 'tcx> {\n+impl<'ll, 'tcx> Deref for Builder<'_, 'll, 'tcx> {\n     type Target = CodegenCx<'ll, 'tcx>;\n \n     #[inline]\n@@ -122,7 +122,7 @@ impl Deref for Builder<'_, 'll, 'tcx> {\n     }\n }\n \n-impl HasCodegen<'tcx> for Builder<'_, 'll, 'tcx> {\n+impl<'ll, 'tcx> HasCodegen<'tcx> for Builder<'_, 'll, 'tcx> {\n     type CodegenCx = CodegenCx<'ll, 'tcx>;\n }\n \n@@ -136,7 +136,7 @@ macro_rules! builder_methods_for_value_instructions {\n     }\n }\n \n-impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n+impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn build(cx: &'a CodegenCx<'ll, 'tcx>, llbb: &'ll BasicBlock) -> Self {\n         let bx = Builder::with_cx(cx);\n         unsafe {\n@@ -1206,14 +1206,14 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n-impl StaticBuilderMethods for Builder<'a, 'll, 'tcx> {\n+impl<'ll> StaticBuilderMethods for Builder<'_, 'll, '_> {\n     fn get_static(&mut self, def_id: DefId) -> &'ll Value {\n         // Forward to the `get_static` method of `CodegenCx`\n         self.cx().get_static(def_id)\n     }\n }\n \n-impl Builder<'a, 'll, 'tcx> {\n+impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n     fn with_cx(cx: &'a CodegenCx<'ll, 'tcx>) -> Self {\n         // Create a fresh builder from the crate context.\n         let llbuilder = unsafe { llvm::LLVMCreateBuilderInContext(cx.llcx) };"}, {"sha": "ac423a2270320ffc2b54eee4d1fe2070f53a6566", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -22,7 +22,7 @@ use rustc_middle::ty::{self, Instance, TypeFoldable};\n ///\n /// - `cx`: the crate context\n /// - `instance`: the instance to be instantiated\n-pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value {\n+pub fn get_fn<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value {\n     let tcx = cx.tcx();\n \n     debug!(\"get_fn(instance={:?})\", instance);"}, {"sha": "9d34734f4e59ac83845cb0f947c5789f656e4071", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -65,7 +65,7 @@ pub struct Funclet<'ll> {\n     operand: OperandBundleDef<'ll>,\n }\n \n-impl Funclet<'ll> {\n+impl<'ll> Funclet<'ll> {\n     pub fn new(cleanuppad: &'ll Value) -> Self {\n         Funclet { cleanuppad, operand: OperandBundleDef::new(\"funclet\", &[cleanuppad]) }\n     }\n@@ -79,7 +79,7 @@ impl Funclet<'ll> {\n     }\n }\n \n-impl BackendTypes for CodegenCx<'ll, 'tcx> {\n+impl<'ll> BackendTypes for CodegenCx<'ll, '_> {\n     type Value = &'ll Value;\n     // FIXME(eddyb) replace this with a `Function` \"subclass\" of `Value`.\n     type Function = &'ll Value;\n@@ -93,7 +93,7 @@ impl BackendTypes for CodegenCx<'ll, 'tcx> {\n     type DIVariable = &'ll llvm::debuginfo::DIVariable;\n }\n \n-impl CodegenCx<'ll, 'tcx> {\n+impl<'ll> CodegenCx<'ll, '_> {\n     pub fn const_array(&self, ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n         unsafe { llvm::LLVMConstArray(ty, elts.as_ptr(), elts.len() as c_uint) }\n     }\n@@ -145,7 +145,7 @@ impl CodegenCx<'ll, 'tcx> {\n     }\n }\n \n-impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn const_null(&self, t: &'ll Type) -> &'ll Value {\n         unsafe { llvm::LLVMConstNull(t) }\n     }\n@@ -327,14 +327,18 @@ pub fn val_ty(v: &Value) -> &Type {\n     unsafe { llvm::LLVMTypeOf(v) }\n }\n \n-pub fn bytes_in_context(llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n+pub fn bytes_in_context<'ll>(llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n     unsafe {\n         let ptr = bytes.as_ptr() as *const c_char;\n         llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True)\n     }\n }\n \n-pub fn struct_in_context(llcx: &'a llvm::Context, elts: &[&'a Value], packed: bool) -> &'a Value {\n+pub fn struct_in_context<'ll>(\n+    llcx: &'ll llvm::Context,\n+    elts: &[&'ll Value],\n+    packed: bool,\n+) -> &'ll Value {\n     unsafe {\n         llvm::LLVMConstStructInContext(llcx, elts.as_ptr(), elts.len() as c_uint, packed as Bool)\n     }"}, {"sha": "d43c7c606517927c6d84acee195540b0e2fdfdc1", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -24,7 +24,7 @@ use rustc_target::abi::{\n use std::ops::Range;\n use tracing::debug;\n \n-pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n+pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n     let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n     let dl = cx.data_layout();\n     let pointer_size = dl.pointer_size.bytes() as usize;\n@@ -127,15 +127,15 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n     cx.const_struct(&llvals, true)\n }\n \n-pub fn codegen_static_initializer(\n+pub fn codegen_static_initializer<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     def_id: DefId,\n ) -> Result<(&'ll Value, &'tcx Allocation), ErrorHandled> {\n     let alloc = cx.tcx.eval_static_initializer(def_id)?;\n     Ok((const_alloc_to_llvm(cx, alloc), alloc))\n }\n \n-fn set_global_alignment(cx: &CodegenCx<'ll, '_>, gv: &'ll Value, mut align: Align) {\n+fn set_global_alignment<'ll>(cx: &CodegenCx<'ll, '_>, gv: &'ll Value, mut align: Align) {\n     // The target may require greater alignment for globals than the type does.\n     // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n     // which can force it to be smaller.  Rust doesn't support this yet.\n@@ -152,7 +152,7 @@ fn set_global_alignment(cx: &CodegenCx<'ll, '_>, gv: &'ll Value, mut align: Alig\n     }\n }\n \n-fn check_and_apply_linkage(\n+fn check_and_apply_linkage<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     attrs: &CodegenFnAttrs,\n     ty: Ty<'tcx>,\n@@ -206,11 +206,11 @@ fn check_and_apply_linkage(\n     }\n }\n \n-pub fn ptrcast(val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+pub fn ptrcast<'ll>(val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n     unsafe { llvm::LLVMConstPointerCast(val, ty) }\n }\n \n-impl CodegenCx<'ll, 'tcx> {\n+impl<'ll> CodegenCx<'ll, '_> {\n     crate fn const_bitcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n         unsafe { llvm::LLVMConstBitCast(val, ty) }\n     }\n@@ -344,7 +344,7 @@ impl CodegenCx<'ll, 'tcx> {\n     }\n }\n \n-impl StaticMethods for CodegenCx<'ll, 'tcx> {\n+impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n     fn static_addr_of(&self, cv: &'ll Value, align: Align, kind: Option<&str>) -> &'ll Value {\n         if let Some(&gv) = self.const_globals.borrow().get(&cv) {\n             unsafe {"}, {"sha": "fe55bf8686e25dff6fd3e83f1904df9dce7039be", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -124,7 +124,7 @@ fn to_llvm_tls_model(tls_model: TlsModel) -> llvm::ThreadLocalMode {\n     }\n }\n \n-pub unsafe fn create_module(\n+pub unsafe fn create_module<'ll>(\n     tcx: TyCtxt<'_>,\n     llcx: &'ll llvm::Context,\n     mod_name: &str,\n@@ -363,7 +363,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn coverage_context(&'a self) -> Option<&'a coverageinfo::CrateCoverageContext<'ll, 'tcx>> {\n+    pub fn coverage_context(&self) -> Option<&coverageinfo::CrateCoverageContext<'ll, 'tcx>> {\n         self.coverage_cx.as_ref()\n     }\n \n@@ -380,7 +380,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n     }\n }\n \n-impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+impl<'ll, 'tcx> MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn vtables(\n         &self,\n     ) -> &RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), &'ll Value>>\n@@ -504,8 +504,8 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n }\n \n-impl CodegenCx<'b, 'tcx> {\n-    crate fn get_intrinsic(&self, key: &str) -> (&'b Type, &'b Value) {\n+impl<'ll> CodegenCx<'ll, '_> {\n+    crate fn get_intrinsic(&self, key: &str) -> (&'ll Type, &'ll Value) {\n         if let Some(v) = self.intrinsics.borrow().get(key).cloned() {\n             return v;\n         }\n@@ -516,9 +516,9 @@ impl CodegenCx<'b, 'tcx> {\n     fn insert_intrinsic(\n         &self,\n         name: &'static str,\n-        args: Option<&[&'b llvm::Type]>,\n-        ret: &'b llvm::Type,\n-    ) -> (&'b llvm::Type, &'b llvm::Value) {\n+        args: Option<&[&'ll llvm::Type]>,\n+        ret: &'ll llvm::Type,\n+    ) -> (&'ll llvm::Type, &'ll llvm::Value) {\n         let fn_ty = if let Some(args) = args {\n             self.type_func(args, ret)\n         } else {\n@@ -529,7 +529,7 @@ impl CodegenCx<'b, 'tcx> {\n         (fn_ty, f)\n     }\n \n-    fn declare_intrinsic(&self, key: &str) -> Option<(&'b Type, &'b Value)> {\n+    fn declare_intrinsic(&self, key: &str) -> Option<(&'ll Type, &'ll Value)> {\n         macro_rules! ifn {\n             ($name:expr, fn() -> $ret:expr) => (\n                 if key == $name {\n@@ -793,7 +793,7 @@ impl CodegenCx<'b, 'tcx> {\n         None\n     }\n \n-    crate fn eh_catch_typeinfo(&self) -> &'b Value {\n+    crate fn eh_catch_typeinfo(&self) -> &'ll Value {\n         if let Some(eh_catch_typeinfo) = self.eh_catch_typeinfo.get() {\n             return eh_catch_typeinfo;\n         }\n@@ -813,7 +813,7 @@ impl CodegenCx<'b, 'tcx> {\n     }\n }\n \n-impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n+impl CodegenCx<'_, '_> {\n     /// Generates a new symbol name with the given prefix. This symbol name must\n     /// only be used for definitions with `internal` or `private` linkage.\n     pub fn generate_local_symbol_name(&self, prefix: &str) -> String {\n@@ -829,21 +829,21 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n     }\n }\n \n-impl HasDataLayout for CodegenCx<'ll, 'tcx> {\n+impl HasDataLayout for CodegenCx<'_, '_> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl HasTargetSpec for CodegenCx<'ll, 'tcx> {\n+impl HasTargetSpec for CodegenCx<'_, '_> {\n     #[inline]\n     fn target_spec(&self) -> &Target {\n         &self.tcx.sess.target\n     }\n }\n \n-impl ty::layout::HasTyCtxt<'tcx> for CodegenCx<'ll, 'tcx> {\n+impl<'tcx> ty::layout::HasTyCtxt<'tcx> for CodegenCx<'_, 'tcx> {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n@@ -856,7 +856,7 @@ impl<'tcx, 'll> HasParamEnv<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n }\n \n-impl LayoutOfHelpers<'tcx> for CodegenCx<'ll, 'tcx> {\n+impl<'tcx> LayoutOfHelpers<'tcx> for CodegenCx<'_, 'tcx> {\n     type LayoutOfResult = TyAndLayout<'tcx>;\n \n     #[inline]\n@@ -869,7 +869,7 @@ impl LayoutOfHelpers<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n }\n \n-impl FnAbiOfHelpers<'tcx> for CodegenCx<'ll, 'tcx> {\n+impl<'tcx> FnAbiOfHelpers<'tcx> for CodegenCx<'_, 'tcx> {\n     type FnAbiOfResult = &'tcx FnAbi<'tcx, Ty<'tcx>>;\n \n     #[inline]"}, {"sha": "e0af5653753b664e4f946b1f808ab2ba4a916e4a", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -141,7 +141,7 @@ impl CoverageMapGenerator {\n     /// the `mapping_regions` and `virtual_file_mapping`, and capture any new filenames. Then use\n     /// LLVM APIs to encode the `virtual_file_mapping`, `expressions`, and `mapping_regions` into\n     /// the given `coverage_mapping` byte buffer, compliant with the LLVM Coverage Mapping format.\n-    fn write_coverage_mapping(\n+    fn write_coverage_mapping<'a>(\n         &mut self,\n         expressions: Vec<CounterExpression>,\n         counter_regions: impl Iterator<Item = (Counter, &'a CodeRegion)>,\n@@ -200,9 +200,9 @@ impl CoverageMapGenerator {\n     /// Construct coverage map header and the array of function records, and combine them into the\n     /// coverage map. Save the coverage map data into the LLVM IR as a static global using a\n     /// specific, well-known section and name.\n-    fn generate_coverage_map(\n+    fn generate_coverage_map<'ll>(\n         self,\n-        cx: &CodegenCx<'ll, 'tcx>,\n+        cx: &CodegenCx<'ll, '_>,\n         version: u32,\n         filenames_size: usize,\n         filenames_val: &'ll llvm::Value,\n@@ -229,7 +229,7 @@ impl CoverageMapGenerator {\n /// Save the function record into the LLVM IR as a static global using a\n /// specific, well-known section and name.\n fn save_function_record(\n-    cx: &CodegenCx<'ll, 'tcx>,\n+    cx: &CodegenCx<'_, '_>,\n     mangled_function_name: String,\n     source_hash: u64,\n     filenames_ref: u64,"}, {"sha": "b2879ef4aea11af5846388c24f27efee5aa391a3", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -56,7 +56,7 @@ impl<'ll, 'tcx> CrateCoverageContext<'ll, 'tcx> {\n     }\n }\n \n-impl CoverageInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+impl<'ll, 'tcx> CoverageInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn coverageinfo_finalize(&self) {\n         mapgen::finalize(self)\n     }\n@@ -96,7 +96,7 @@ impl CoverageInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n }\n \n-impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+impl<'tcx> CoverageInfoBuilderMethods<'tcx> for Builder<'_, '_, 'tcx> {\n     fn set_function_source_hash(\n         &mut self,\n         instance: Instance<'tcx>,\n@@ -184,7 +184,7 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n-fn declare_unused_fn(cx: &CodegenCx<'ll, 'tcx>, def_id: &DefId) -> Instance<'tcx> {\n+fn declare_unused_fn<'tcx>(cx: &CodegenCx<'_, 'tcx>, def_id: &DefId) -> Instance<'tcx> {\n     let tcx = cx.tcx;\n \n     let instance = Instance::new(\n@@ -220,7 +220,7 @@ fn declare_unused_fn(cx: &CodegenCx<'ll, 'tcx>, def_id: &DefId) -> Instance<'tcx\n     instance\n }\n \n-fn codegen_unused_fn_and_counter(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) {\n+fn codegen_unused_fn_and_counter<'tcx>(cx: &CodegenCx<'_, 'tcx>, instance: Instance<'tcx>) {\n     let llfn = cx.get_fn(instance);\n     let llbb = Builder::append_block(cx, llfn, \"unused_function\");\n     let mut bx = Builder::build(cx, llbb);\n@@ -237,8 +237,8 @@ fn codegen_unused_fn_and_counter(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'\n     bx.ret_void();\n }\n \n-fn add_unused_function_coverage(\n-    cx: &CodegenCx<'ll, 'tcx>,\n+fn add_unused_function_coverage<'tcx>(\n+    cx: &CodegenCx<'_, 'tcx>,\n     instance: Instance<'tcx>,\n     def_id: DefId,\n ) {\n@@ -268,7 +268,7 @@ fn add_unused_function_coverage(\n /// required by LLVM InstrProf source-based coverage instrumentation. Use\n /// `bx.get_pgo_func_name_var()` to ensure the variable is only created once per\n /// `Instance`.\n-fn create_pgo_func_name_var(\n+fn create_pgo_func_name_var<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     instance: Instance<'tcx>,\n ) -> &'ll llvm::Value {"}, {"sha": "39f53235e2c53da95e7c21f2ae3c96dbcd72b6ea", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/create_scope_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -16,7 +16,7 @@ use rustc_index::vec::Idx;\n \n /// Produces DIScope DIEs for each MIR Scope which has variables defined in it.\n // FIXME(eddyb) almost all of this should be in `rustc_codegen_ssa::mir::debuginfo`.\n-pub fn compute_mir_scopes(\n+pub fn compute_mir_scopes<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     instance: Instance<'tcx>,\n     mir: &Body<'tcx>,\n@@ -45,7 +45,7 @@ pub fn compute_mir_scopes(\n     }\n }\n \n-fn make_mir_scope(\n+fn make_mir_scope<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     instance: Instance<'tcx>,\n     mir: &Body<'tcx>,"}, {"sha": "31a09242c5ada2306dc632ca5b3b3c80e98f81f6", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -28,7 +28,7 @@ pub fn insert_reference_to_gdb_debug_scripts_section_global(bx: &mut Builder<'_,\n \n /// Allocates the global variable responsible for the .debug_gdb_scripts binary\n /// section.\n-pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>) -> &'ll Value {\n+pub fn get_or_insert_gdb_debug_scripts_section_global<'ll>(cx: &CodegenCx<'ll, '_>) -> &'ll Value {\n     let c_section_var_name = \"__rustc_debug_gdb_scripts_section__\\0\";\n     let section_var_name = &c_section_var_name[..c_section_var_name.len() - 1];\n "}, {"sha": "960b02bf910e938fa2c688947e35a752249cf991", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 81, "deletions": 54, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -155,7 +155,7 @@ pub struct TypeMap<'ll, 'tcx> {\n     type_to_unique_id: FxHashMap<Ty<'tcx>, UniqueTypeId>,\n }\n \n-impl TypeMap<'ll, 'tcx> {\n+impl<'ll, 'tcx> TypeMap<'ll, 'tcx> {\n     /// Adds a Ty to metadata mapping to the TypeMap. The method will fail if\n     /// the mapping already exists.\n     fn register_type_with_metadata(&mut self, type_: Ty<'tcx>, metadata: &'ll DIType) {\n@@ -291,7 +291,7 @@ enum RecursiveTypeDescription<'ll, 'tcx> {\n     FinalMetadata(&'ll DICompositeType),\n }\n \n-fn create_and_register_recursive_type_forward_declaration(\n+fn create_and_register_recursive_type_forward_declaration<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     unfinished_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n@@ -313,7 +313,7 @@ fn create_and_register_recursive_type_forward_declaration(\n     }\n }\n \n-impl RecursiveTypeDescription<'ll, 'tcx> {\n+impl<'ll, 'tcx> RecursiveTypeDescription<'ll, 'tcx> {\n     /// Finishes up the description of the type in question (mostly by providing\n     /// descriptions of the fields of the given type) and returns the final type\n     /// metadata.\n@@ -375,7 +375,7 @@ macro_rules! return_if_metadata_created_in_meantime {\n     };\n }\n \n-fn fixed_vec_metadata(\n+fn fixed_vec_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     unique_type_id: UniqueTypeId,\n     array_or_slice_type: Ty<'tcx>,\n@@ -410,7 +410,7 @@ fn fixed_vec_metadata(\n     MetadataCreationResult::new(metadata, false)\n }\n \n-fn vec_slice_metadata(\n+fn vec_slice_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     slice_ptr_type: Ty<'tcx>,\n     element_type: Ty<'tcx>,\n@@ -466,7 +466,7 @@ fn vec_slice_metadata(\n     MetadataCreationResult::new(metadata, false)\n }\n \n-fn subroutine_type_metadata(\n+fn subroutine_type_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     unique_type_id: UniqueTypeId,\n     signature: ty::PolyFnSig<'tcx>,\n@@ -507,7 +507,7 @@ fn subroutine_type_metadata(\n // `trait_type` should be the actual trait (e.g., `Trait`). Where the trait is part\n // of a DST struct, there is no `trait_object_type` and the results of this\n // function will be a little bit weird.\n-fn trait_pointer_metadata(\n+fn trait_pointer_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     trait_type: Ty<'tcx>,\n     trait_object_type: Option<Ty<'tcx>>,\n@@ -588,7 +588,11 @@ fn trait_pointer_metadata(\n     )\n }\n \n-pub fn type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>, usage_site_span: Span) -> &'ll DIType {\n+pub fn type_metadata<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    t: Ty<'tcx>,\n+    usage_site_span: Span,\n+) -> &'ll DIType {\n     // Get the unique type ID of this type.\n     let unique_type_id = {\n         let mut type_map = debug_context(cx).type_map.borrow_mut();\n@@ -812,7 +816,7 @@ fn hex_encode(data: &[u8]) -> String {\n     hex_string\n }\n \n-pub fn file_metadata(cx: &CodegenCx<'ll, '_>, source_file: &SourceFile) -> &'ll DIFile {\n+pub fn file_metadata<'ll>(cx: &CodegenCx<'ll, '_>, source_file: &SourceFile) -> &'ll DIFile {\n     debug!(\"file_metadata: file_name: {:?}\", source_file.name);\n \n     let hash = Some(&source_file.src_hash);\n@@ -833,11 +837,11 @@ pub fn file_metadata(cx: &CodegenCx<'ll, '_>, source_file: &SourceFile) -> &'ll\n     file_metadata_raw(cx, file_name, directory, hash)\n }\n \n-pub fn unknown_file_metadata(cx: &CodegenCx<'ll, '_>) -> &'ll DIFile {\n+pub fn unknown_file_metadata<'ll>(cx: &CodegenCx<'ll, '_>) -> &'ll DIFile {\n     file_metadata_raw(cx, None, None, None)\n }\n \n-fn file_metadata_raw(\n+fn file_metadata_raw<'ll>(\n     cx: &CodegenCx<'ll, '_>,\n     file_name: Option<String>,\n     directory: Option<String>,\n@@ -924,7 +928,7 @@ impl MsvcBasicName for ty::FloatTy {\n     }\n }\n \n-fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n+fn basic_type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     debug!(\"basic_type_metadata: {:?}\", t);\n \n     // When targeting MSVC, emit MSVC style type names for compatibility with\n@@ -981,7 +985,7 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     typedef_metadata\n }\n \n-fn foreign_type_metadata(\n+fn foreign_type_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     t: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n@@ -992,7 +996,7 @@ fn foreign_type_metadata(\n     create_struct_stub(cx, t, &name, unique_type_id, NO_SCOPE_METADATA, DIFlags::FlagZero)\n }\n \n-fn pointer_type_metadata(\n+fn pointer_type_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     pointer_type: Ty<'tcx>,\n     pointee_type_metadata: &'ll DIType,\n@@ -1012,7 +1016,7 @@ fn pointer_type_metadata(\n     }\n }\n \n-fn param_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n+fn param_type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     debug!(\"param_type_metadata: {:?}\", t);\n     let name = format!(\"{:?}\", t);\n     unsafe {\n@@ -1026,24 +1030,35 @@ fn param_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     }\n }\n \n-pub fn compile_unit_metadata(\n-    tcx: TyCtxt<'_>,\n+pub fn compile_unit_metadata<'ll, 'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     codegen_unit_name: &str,\n-    debug_context: &CrateDebugContext<'ll, '_>,\n+    debug_context: &CrateDebugContext<'ll, 'tcx>,\n ) -> &'ll DIDescriptor {\n     let mut name_in_debuginfo = match tcx.sess.local_crate_source_file {\n         Some(ref path) => path.clone(),\n         None => PathBuf::from(&*tcx.crate_name(LOCAL_CRATE).as_str()),\n     };\n \n-    // The OSX linker has an idiosyncrasy where it will ignore some debuginfo\n-    // if multiple object files with the same `DW_AT_name` are linked together.\n-    // As a workaround we generate unique names for each object file. Those do\n-    // not correspond to an actual source file but that is harmless.\n-    if tcx.sess.target.is_like_osx {\n-        name_in_debuginfo.push(\"@\");\n-        name_in_debuginfo.push(codegen_unit_name);\n-    }\n+    // To avoid breaking split DWARF, we need to ensure that each codegen unit\n+    // has a unique `DW_AT_name`. This is because there's a remote chance that\n+    // different codegen units for the same module will have entirely\n+    // identical DWARF entries for the purpose of the DWO ID, which would\n+    // violate Appendix F (\"Split Dwarf Object Files\") of the DWARF 5\n+    // specification. LLVM uses the algorithm specified in section 7.32 \"Type\n+    // Signature Computation\" to compute the DWO ID, which does not include\n+    // any fields that would distinguish compilation units. So we must embed\n+    // the codegen unit name into the `DW_AT_name`. (Issue #88521.)\n+    //\n+    // Additionally, the OSX linker has an idiosyncrasy where it will ignore\n+    // some debuginfo if multiple object files with the same `DW_AT_name` are\n+    // linked together.\n+    //\n+    // As a workaround for these two issues, we generate unique names for each\n+    // object file. Those do not correspond to an actual source file but that\n+    // is harmless.\n+    name_in_debuginfo.push(\"@\");\n+    name_in_debuginfo.push(codegen_unit_name);\n \n     debug!(\"compile_unit_metadata: {:?}\", name_in_debuginfo);\n     let rustc_producer =\n@@ -1055,11 +1070,11 @@ pub fn compile_unit_metadata(\n     let work_dir = tcx.sess.opts.working_dir.to_string_lossy(FileNameDisplayPreference::Remapped);\n     let flags = \"\\0\";\n     let output_filenames = tcx.output_filenames(());\n-    let out_dir = &output_filenames.out_directory;\n     let split_name = if tcx.sess.target_can_use_split_dwarf() {\n         output_filenames\n             .split_dwarf_path(tcx.sess.split_debuginfo(), Some(codegen_unit_name))\n-            .map(|f| out_dir.join(f))\n+            // We get a path relative to the working directory from split_dwarf_path\n+            .map(|f| tcx.sess.source_map().path_mapping().map_prefix(f).0)\n     } else {\n         None\n     }\n@@ -1159,7 +1174,7 @@ pub fn compile_unit_metadata(\n         return unit_metadata;\n     };\n \n-    fn path_to_mdstring(llcx: &'ll llvm::Context, path: &Path) -> &'ll Value {\n+    fn path_to_mdstring<'ll>(llcx: &'ll llvm::Context, path: &Path) -> &'ll Value {\n         let path_str = path_to_c_string(path);\n         unsafe {\n             llvm::LLVMMDStringInContext(\n@@ -1176,7 +1191,7 @@ struct MetadataCreationResult<'ll> {\n     already_stored_in_typemap: bool,\n }\n \n-impl MetadataCreationResult<'ll> {\n+impl<'ll> MetadataCreationResult<'ll> {\n     fn new(metadata: &'ll DIType, already_stored_in_typemap: bool) -> Self {\n         MetadataCreationResult { metadata, already_stored_in_typemap }\n     }\n@@ -1243,7 +1258,7 @@ enum MemberDescriptionFactory<'ll, 'tcx> {\n     VariantMDF(VariantMemberDescriptionFactory<'tcx>),\n }\n \n-impl MemberDescriptionFactory<'ll, 'tcx> {\n+impl<'ll, 'tcx> MemberDescriptionFactory<'ll, 'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>) -> Vec<MemberDescription<'ll>> {\n         match *self {\n             StructMDF(ref this) => this.create_member_descriptions(cx),\n@@ -1267,7 +1282,10 @@ struct StructMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>) -> Vec<MemberDescription<'ll>> {\n+    fn create_member_descriptions<'ll>(\n+        &self,\n+        cx: &CodegenCx<'ll, 'tcx>,\n+    ) -> Vec<MemberDescription<'ll>> {\n         let layout = cx.layout_of(self.ty);\n         self.variant\n             .fields\n@@ -1295,7 +1313,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n     }\n }\n \n-fn prepare_struct_metadata(\n+fn prepare_struct_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     struct_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n@@ -1338,7 +1356,7 @@ fn prepare_struct_metadata(\n /// Here are some examples:\n ///  - `name__field1__field2` when the upvar is captured by value.\n ///  - `_ref__name__field` when the upvar is captured by reference.\n-fn closure_saved_names_of_captured_variables(tcx: TyCtxt<'tcx>, def_id: DefId) -> Vec<String> {\n+fn closure_saved_names_of_captured_variables(tcx: TyCtxt<'_>, def_id: DefId) -> Vec<String> {\n     let body = tcx.optimized_mir(def_id);\n \n     body.var_debug_info\n@@ -1366,7 +1384,10 @@ struct TupleMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>) -> Vec<MemberDescription<'ll>> {\n+    fn create_member_descriptions<'ll>(\n+        &self,\n+        cx: &CodegenCx<'ll, 'tcx>,\n+    ) -> Vec<MemberDescription<'ll>> {\n         let mut capture_names = match *self.ty.kind() {\n             ty::Generator(def_id, ..) | ty::Closure(def_id, ..) => {\n                 Some(closure_saved_names_of_captured_variables(cx.tcx, def_id).into_iter())\n@@ -1399,7 +1420,7 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n     }\n }\n \n-fn prepare_tuple_metadata(\n+fn prepare_tuple_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     tuple_type: Ty<'tcx>,\n     component_types: &[Ty<'tcx>],\n@@ -1443,7 +1464,10 @@ struct UnionMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>) -> Vec<MemberDescription<'ll>> {\n+    fn create_member_descriptions<'ll>(\n+        &self,\n+        cx: &CodegenCx<'ll, 'tcx>,\n+    ) -> Vec<MemberDescription<'ll>> {\n         self.variant\n             .fields\n             .iter()\n@@ -1465,7 +1489,7 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n     }\n }\n \n-fn prepare_union_metadata(\n+fn prepare_union_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     union_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n@@ -1506,7 +1530,7 @@ fn use_enum_fallback(cx: &CodegenCx<'_, '_>) -> bool {\n \n // FIXME(eddyb) maybe precompute this? Right now it's computed once\n // per generator monomorphization, but it doesn't depend on substs.\n-fn generator_layout_and_saved_local_names(\n+fn generator_layout_and_saved_local_names<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n ) -> (&'tcx GeneratorLayout<'tcx>, IndexVec<mir::GeneratorSavedLocal, Option<Symbol>>) {\n@@ -1554,7 +1578,7 @@ struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n     span: Span,\n }\n \n-impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n+impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>) -> Vec<MemberDescription<'ll>> {\n         let generator_variant_info_data = match *self.enum_type.kind() {\n             ty::Generator(def_id, ..) => {\n@@ -1886,8 +1910,11 @@ struct VariantMemberDescriptionFactory<'tcx> {\n     span: Span,\n }\n \n-impl VariantMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>) -> Vec<MemberDescription<'ll>> {\n+impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n+    fn create_member_descriptions<'ll>(\n+        &self,\n+        cx: &CodegenCx<'ll, 'tcx>,\n+    ) -> Vec<MemberDescription<'ll>> {\n         self.args\n             .iter()\n             .enumerate()\n@@ -1961,7 +1988,7 @@ impl<'tcx> VariantInfo<'_, 'tcx> {\n         field_name.map(|name| name.to_string()).unwrap_or_else(|| format!(\"__{}\", i))\n     }\n \n-    fn source_info(&self, cx: &CodegenCx<'ll, 'tcx>) -> Option<SourceInfo<'ll>> {\n+    fn source_info<'ll>(&self, cx: &CodegenCx<'ll, 'tcx>) -> Option<SourceInfo<'ll>> {\n         if let VariantInfo::Generator { def_id, variant_index, .. } = self {\n             let span =\n                 cx.tcx.generator_layout(*def_id).unwrap().variant_source_info[*variant_index].span;\n@@ -1978,7 +2005,7 @@ impl<'tcx> VariantInfo<'_, 'tcx> {\n /// `MemberDescriptionFactory` for producing the descriptions of the\n /// fields of the variant. This is a rudimentary version of a full\n /// `RecursiveTypeDescription`.\n-fn describe_enum_variant(\n+fn describe_enum_variant<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     layout: layout::TyAndLayout<'tcx>,\n     variant: VariantInfo<'_, 'tcx>,\n@@ -2011,7 +2038,7 @@ fn describe_enum_variant(\n     (metadata_stub, member_description_factory)\n }\n \n-fn prepare_enum_metadata(\n+fn prepare_enum_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     enum_type: Ty<'tcx>,\n     enum_def_id: DefId,\n@@ -2330,7 +2357,7 @@ fn prepare_enum_metadata(\n /// results in a LLVM struct.\n ///\n /// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n-fn composite_type_metadata(\n+fn composite_type_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     composite_type: Ty<'tcx>,\n     composite_type_name: &str,\n@@ -2364,7 +2391,7 @@ fn composite_type_metadata(\n     composite_type_metadata\n }\n \n-fn set_members_of_composite_type(\n+fn set_members_of_composite_type<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     composite_type: Ty<'tcx>,\n     composite_type_metadata: &'ll DICompositeType,\n@@ -2409,7 +2436,7 @@ fn set_members_of_composite_type(\n }\n \n /// Computes the type parameters for a type, if any, for the given metadata.\n-fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> &'ll DIArray {\n+fn compute_type_parameters<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> &'ll DIArray {\n     if let ty::Adt(def, substs) = *ty.kind() {\n         if substs.types().next().is_some() {\n             let generics = cx.tcx.generics_of(def.did);\n@@ -2454,7 +2481,7 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> &'ll DIAr\n /// A convenience wrapper around `LLVMRustDIBuilderCreateStructType()`. Does not do\n /// any caching, does not add any fields to the struct. This can be done later\n /// with `set_members_of_composite_type()`.\n-fn create_struct_stub(\n+fn create_struct_stub<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     struct_type: Ty<'tcx>,\n     struct_type_name: &str,\n@@ -2495,7 +2522,7 @@ fn create_struct_stub(\n     metadata_stub\n }\n \n-fn create_union_stub(\n+fn create_union_stub<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     union_type: Ty<'tcx>,\n     union_type_name: &str,\n@@ -2536,7 +2563,7 @@ fn create_union_stub(\n /// Creates debug information for the given global variable.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_global_var_metadata(cx: &CodegenCx<'ll, '_>, def_id: DefId, global: &'ll Value) {\n+pub fn create_global_var_metadata<'ll>(cx: &CodegenCx<'ll, '_>, def_id: DefId, global: &'ll Value) {\n     if cx.dbg_cx.is_none() {\n         return;\n     }\n@@ -2591,7 +2618,7 @@ pub fn create_global_var_metadata(cx: &CodegenCx<'ll, '_>, def_id: DefId, global\n }\n \n /// Generates LLVM debuginfo for a vtable.\n-fn vtable_type_metadata(\n+fn vtable_type_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     ty: Ty<'tcx>,\n     poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n@@ -2623,7 +2650,7 @@ fn vtable_type_metadata(\n /// given type.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_vtable_metadata(\n+pub fn create_vtable_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     ty: Ty<'tcx>,\n     poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n@@ -2662,7 +2689,7 @@ pub fn create_vtable_metadata(\n }\n \n /// Creates an \"extension\" of an existing `DIScope` into another file.\n-pub fn extend_scope_to_file(\n+pub fn extend_scope_to_file<'ll>(\n     cx: &CodegenCx<'ll, '_>,\n     scope_metadata: &'ll DIScope,\n     file: &SourceFile,"}, {"sha": "3e7371179cc7270d13d360e0a9ad1cd7896b7dc5", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -71,7 +71,7 @@ pub struct CrateDebugContext<'a, 'tcx> {\n     composite_types_completed: RefCell<FxHashSet<&'a DIType>>,\n }\n \n-impl Drop for CrateDebugContext<'a, 'tcx> {\n+impl Drop for CrateDebugContext<'_, '_> {\n     fn drop(&mut self) {\n         unsafe {\n             llvm::LLVMRustDIBuilderDispose(&mut *(self.builder as *mut _));\n@@ -144,7 +144,7 @@ pub fn finalize(cx: &CodegenCx<'_, '_>) {\n     }\n }\n \n-impl DebugInfoBuilderMethods for Builder<'a, 'll, 'tcx> {\n+impl<'ll> DebugInfoBuilderMethods for Builder<'_, 'll, '_> {\n     // FIXME(eddyb) find a common convention for all of the debuginfo-related\n     // names (choose between `dbg`, `debug`, `debuginfo`, `debug_info` etc.).\n     fn dbg_var_addr(\n@@ -236,7 +236,7 @@ pub struct DebugLoc {\n     pub col: u32,\n }\n \n-impl CodegenCx<'ll, '_> {\n+impl CodegenCx<'_, '_> {\n     /// Looks up debug source information about a `BytePos`.\n     // FIXME(eddyb) rename this to better indicate it's a duplicate of\n     // `lookup_char_pos` rather than `dbg_loc`, perhaps by making\n@@ -266,7 +266,7 @@ impl CodegenCx<'ll, '_> {\n     }\n }\n \n-impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn create_function_debug_context(\n         &self,\n         instance: Instance<'tcx>,"}, {"sha": "d5ea48c311b940d11be468017f93a805fe6aa2f8", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fnamespace.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -17,7 +17,7 @@ pub fn mangled_name_of_instance<'a, 'tcx>(\n     tcx.symbol_name(instance)\n }\n \n-pub fn item_namespace(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll DIScope {\n+pub fn item_namespace<'ll>(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll DIScope {\n     if let Some(&scope) = debug_context(cx).namespace_map.borrow().get(&def_id) {\n         return scope;\n     }"}, {"sha": "953b6765a489490bbed4178ea989b73d8200ac8a", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/utils.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -23,21 +23,26 @@ pub fn is_node_local_to_unit(cx: &CodegenCx<'_, '_>, def_id: DefId) -> bool {\n }\n \n #[allow(non_snake_case)]\n-pub fn create_DIArray(builder: &DIBuilder<'ll>, arr: &[Option<&'ll DIDescriptor>]) -> &'ll DIArray {\n+pub fn create_DIArray<'ll>(\n+    builder: &DIBuilder<'ll>,\n+    arr: &[Option<&'ll DIDescriptor>],\n+) -> &'ll DIArray {\n     unsafe { llvm::LLVMRustDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32) }\n }\n \n #[inline]\n-pub fn debug_context(cx: &'a CodegenCx<'ll, 'tcx>) -> &'a CrateDebugContext<'ll, 'tcx> {\n+pub fn debug_context<'a, 'll, 'tcx>(\n+    cx: &'a CodegenCx<'ll, 'tcx>,\n+) -> &'a CrateDebugContext<'ll, 'tcx> {\n     cx.dbg_cx.as_ref().unwrap()\n }\n \n #[inline]\n #[allow(non_snake_case)]\n-pub fn DIB(cx: &'a CodegenCx<'ll, '_>) -> &'a DIBuilder<'ll> {\n+pub fn DIB<'a, 'll>(cx: &'a CodegenCx<'ll, '_>) -> &'a DIBuilder<'ll> {\n     cx.dbg_cx.as_ref().unwrap().builder\n }\n \n-pub fn get_namespace_for_item(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll DIScope {\n+pub fn get_namespace_for_item<'ll>(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll DIScope {\n     item_namespace(cx, cx.tcx.parent(def_id).expect(\"get_namespace_for_item: missing parent?\"))\n }"}, {"sha": "90d0d5caba1d870c81c7ade48018d25acab5ee0f", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -26,7 +26,7 @@ use tracing::debug;\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing Value instead.\n-fn declare_raw_fn(\n+fn declare_raw_fn<'ll>(\n     cx: &CodegenCx<'ll, '_>,\n     name: &str,\n     callconv: llvm::CallConv,\n@@ -50,7 +50,7 @@ fn declare_raw_fn(\n     llfn\n }\n \n-impl CodegenCx<'ll, 'tcx> {\n+impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n     /// Declare a global value.\n     ///\n     /// If there\u2019s a value with the same name already declared, the function will"}, {"sha": "07d49b6e72996d47f126f89e9fda1f1602e98c57", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -25,7 +25,10 @@ use rustc_target::spec::{HasTargetSpec, PanicStrategy};\n use std::cmp::Ordering;\n use std::iter;\n \n-fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: Symbol) -> Option<(&'ll Type, &'ll Value)> {\n+fn get_simple_intrinsic<'ll>(\n+    cx: &CodegenCx<'ll, '_>,\n+    name: Symbol,\n+) -> Option<(&'ll Type, &'ll Value)> {\n     let llvm_name = match name {\n         sym::sqrtf32 => \"llvm.sqrt.f32\",\n         sym::sqrtf64 => \"llvm.sqrt.f64\",\n@@ -74,7 +77,7 @@ fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: Symbol) -> Option<(&'ll T\n     Some(cx.get_intrinsic(llvm_name))\n }\n \n-impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n     fn codegen_intrinsic_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n@@ -411,8 +414,8 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n-fn try_intrinsic(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n+fn try_intrinsic<'ll>(\n+    bx: &mut Builder<'_, 'll, '_>,\n     try_func: &'ll Value,\n     data: &'ll Value,\n     catch_func: &'ll Value,\n@@ -441,8 +444,8 @@ fn try_intrinsic(\n // instructions are meant to work for all targets, as of the time of this\n // writing, however, LLVM does not recommend the usage of these new instructions\n // as the old ones are still more optimized.\n-fn codegen_msvc_try(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n+fn codegen_msvc_try<'ll>(\n+    bx: &mut Builder<'_, 'll, '_>,\n     try_func: &'ll Value,\n     data: &'ll Value,\n     catch_func: &'ll Value,\n@@ -593,8 +596,8 @@ fn codegen_msvc_try(\n // function calling it, and that function may already have other personality\n // functions in play. By calling a shim we're guaranteed that our shim will have\n // the right personality function.\n-fn codegen_gnu_try(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n+fn codegen_gnu_try<'ll>(\n+    bx: &mut Builder<'_, 'll, '_>,\n     try_func: &'ll Value,\n     data: &'ll Value,\n     catch_func: &'ll Value,\n@@ -649,8 +652,8 @@ fn codegen_gnu_try(\n // Variant of codegen_gnu_try used for emscripten where Rust panics are\n // implemented using C++ exceptions. Here we use exceptions of a specific type\n // (`struct rust_panic`) to represent Rust panics.\n-fn codegen_emcc_try(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n+fn codegen_emcc_try<'ll>(\n+    bx: &mut Builder<'_, 'll, '_>,\n     try_func: &'ll Value,\n     data: &'ll Value,\n     catch_func: &'ll Value,\n@@ -799,8 +802,8 @@ fn get_rust_try_fn<'ll, 'tcx>(\n     rust_try\n }\n \n-fn generic_simd_intrinsic(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n+fn generic_simd_intrinsic<'ll, 'tcx>(\n+    bx: &mut Builder<'_, 'll, 'tcx>,\n     name: Symbol,\n     callee_ty: Ty<'tcx>,\n     args: &[OperandRef<'tcx, &'ll Value>],\n@@ -1129,12 +1132,12 @@ fn generic_simd_intrinsic(\n         }\n     }\n \n-    fn simd_simple_float_intrinsic(\n+    fn simd_simple_float_intrinsic<'ll, 'tcx>(\n         name: Symbol,\n         in_elem: &::rustc_middle::ty::TyS<'_>,\n         in_ty: &::rustc_middle::ty::TyS<'_>,\n         in_len: u64,\n-        bx: &mut Builder<'a, 'll, 'tcx>,\n+        bx: &mut Builder<'_, 'll, 'tcx>,\n         span: Span,\n         args: &[OperandRef<'tcx, &'ll Value>],\n     ) -> Result<&'ll Value, ()> {\n@@ -1232,7 +1235,7 @@ fn generic_simd_intrinsic(\n         elem_ty: Ty<'_>,\n         vec_len: u64,\n         no_pointers: usize,\n-        bx: &Builder<'a, 'll, 'tcx>,\n+        bx: &Builder<'_, '_, '_>,\n     ) -> String {\n         let p0s: String = \"p0\".repeat(no_pointers);\n         match *elem_ty.kind() {\n@@ -1255,7 +1258,7 @@ fn generic_simd_intrinsic(\n         }\n     }\n \n-    fn llvm_vector_ty(\n+    fn llvm_vector_ty<'ll>(\n         cx: &CodegenCx<'ll, '_>,\n         elem_ty: Ty<'_>,\n         vec_len: u64,"}, {"sha": "cea4595fbbfed7edbb5a5d2b3e330ec12fb7be4d", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -8,7 +8,6 @@\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(extern_types)]\n-#![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "e2fa5e488edd04f2b67634f7fa5ee6a72de14304", "filename": "compiler/rustc_codegen_llvm/src/llvm/diagnostic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fdiagnostic.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -43,7 +43,7 @@ pub struct OptimizationDiagnostic<'ll> {\n     pub message: String,\n }\n \n-impl OptimizationDiagnostic<'ll> {\n+impl<'ll> OptimizationDiagnostic<'ll> {\n     unsafe fn unpack(kind: OptimizationDiagnosticKind, di: &'ll DiagnosticInfo) -> Self {\n         let mut function = None;\n         let mut line = 0;\n@@ -142,7 +142,7 @@ pub struct InlineAsmDiagnostic {\n }\n \n impl InlineAsmDiagnostic {\n-    unsafe fn unpackInlineAsm(di: &'ll DiagnosticInfo) -> Self {\n+    unsafe fn unpackInlineAsm(di: &DiagnosticInfo) -> Self {\n         let mut cookie = 0;\n         let mut message = None;\n         let mut level = super::DiagnosticLevel::Error;\n@@ -157,7 +157,7 @@ impl InlineAsmDiagnostic {\n         }\n     }\n \n-    unsafe fn unpackSrcMgr(di: &'ll DiagnosticInfo) -> Self {\n+    unsafe fn unpackSrcMgr(di: &DiagnosticInfo) -> Self {\n         let mut cookie = 0;\n         let smdiag = SrcMgrDiagnostic::unpack(super::LLVMRustGetSMDiagnostic(di, &mut cookie));\n         InlineAsmDiagnostic {\n@@ -180,7 +180,7 @@ pub enum Diagnostic<'ll> {\n     UnknownDiagnostic(&'ll DiagnosticInfo),\n }\n \n-impl Diagnostic<'ll> {\n+impl<'ll> Diagnostic<'ll> {\n     pub unsafe fn unpack(di: &'ll DiagnosticInfo) -> Self {\n         use super::DiagnosticKind as Dk;\n         let kind = super::LLVMRustGetDiagInfoKind(di);"}, {"sha": "6c911938ccc09125e54ad85aa7b690ba3bd99d7e", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 199, "deletions": 190, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -1013,17 +1013,17 @@ extern \"C\" {\n     pub fn LLVMDoubleTypeInContext(C: &Context) -> &Type;\n \n     // Operations on function types\n-    pub fn LLVMFunctionType(\n+    pub fn LLVMFunctionType<'a>(\n         ReturnType: &'a Type,\n         ParamTypes: *const &'a Type,\n         ParamCount: c_uint,\n         IsVarArg: Bool,\n     ) -> &'a Type;\n     pub fn LLVMCountParamTypes(FunctionTy: &Type) -> c_uint;\n-    pub fn LLVMGetParamTypes(FunctionTy: &'a Type, Dest: *mut &'a Type);\n+    pub fn LLVMGetParamTypes<'a>(FunctionTy: &'a Type, Dest: *mut &'a Type);\n \n     // Operations on struct types\n-    pub fn LLVMStructTypeInContext(\n+    pub fn LLVMStructTypeInContext<'a>(\n         C: &'a Context,\n         ElementTypes: *const &'a Type,\n         ElementCount: c_uint,\n@@ -1046,19 +1046,23 @@ extern \"C\" {\n     pub fn LLVMTypeOf(Val: &Value) -> &Type;\n     pub fn LLVMGetValueName2(Val: &Value, Length: *mut size_t) -> *const c_char;\n     pub fn LLVMSetValueName2(Val: &Value, Name: *const c_char, NameLen: size_t);\n-    pub fn LLVMReplaceAllUsesWith(OldVal: &'a Value, NewVal: &'a Value);\n-    pub fn LLVMSetMetadata(Val: &'a Value, KindID: c_uint, Node: &'a Value);\n-    pub fn LLVMGlobalSetMetadata(Val: &'a Value, KindID: c_uint, Metadata: &'a Metadata);\n-    pub fn LLVMValueAsMetadata(Node: &'a Value) -> &Metadata;\n+    pub fn LLVMReplaceAllUsesWith<'a>(OldVal: &'a Value, NewVal: &'a Value);\n+    pub fn LLVMSetMetadata<'a>(Val: &'a Value, KindID: c_uint, Node: &'a Value);\n+    pub fn LLVMGlobalSetMetadata<'a>(Val: &'a Value, KindID: c_uint, Metadata: &'a Metadata);\n+    pub fn LLVMValueAsMetadata(Node: &Value) -> &Metadata;\n \n     // Operations on constants of any type\n     pub fn LLVMConstNull(Ty: &Type) -> &Value;\n     pub fn LLVMGetUndef(Ty: &Type) -> &Value;\n \n     // Operations on metadata\n     pub fn LLVMMDStringInContext(C: &Context, Str: *const c_char, SLen: c_uint) -> &Value;\n-    pub fn LLVMMDNodeInContext(C: &'a Context, Vals: *const &'a Value, Count: c_uint) -> &'a Value;\n-    pub fn LLVMAddNamedMetadataOperand(M: &'a Module, Name: *const c_char, Val: &'a Value);\n+    pub fn LLVMMDNodeInContext<'a>(\n+        C: &'a Context,\n+        Vals: *const &'a Value,\n+        Count: c_uint,\n+    ) -> &'a Value;\n+    pub fn LLVMAddNamedMetadataOperand<'a>(M: &'a Module, Name: *const c_char, Val: &'a Value);\n \n     // Operations on scalar constants\n     pub fn LLVMConstInt(IntTy: &Type, N: c_ulonglong, SignExtend: Bool) -> &Value;\n@@ -1079,32 +1083,32 @@ extern \"C\" {\n         Length: c_uint,\n         DontNullTerminate: Bool,\n     ) -> &Value;\n-    pub fn LLVMConstStructInContext(\n+    pub fn LLVMConstStructInContext<'a>(\n         C: &'a Context,\n         ConstantVals: *const &'a Value,\n         Count: c_uint,\n         Packed: Bool,\n     ) -> &'a Value;\n \n-    pub fn LLVMConstArray(\n+    pub fn LLVMConstArray<'a>(\n         ElementTy: &'a Type,\n         ConstantVals: *const &'a Value,\n         Length: c_uint,\n     ) -> &'a Value;\n     pub fn LLVMConstVector(ScalarConstantVals: *const &Value, Size: c_uint) -> &Value;\n \n     // Constant expressions\n-    pub fn LLVMRustConstInBoundsGEP2(\n+    pub fn LLVMRustConstInBoundsGEP2<'a>(\n         ty: &'a Type,\n         ConstantVal: &'a Value,\n         ConstantIndices: *const &'a Value,\n         NumIndices: c_uint,\n     ) -> &'a Value;\n-    pub fn LLVMConstZExt(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n-    pub fn LLVMConstPtrToInt(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n-    pub fn LLVMConstIntToPtr(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n-    pub fn LLVMConstBitCast(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n-    pub fn LLVMConstPointerCast(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstZExt<'a>(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstPtrToInt<'a>(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstIntToPtr<'a>(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstBitCast<'a>(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstPointerCast<'a>(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n     pub fn LLVMConstExtractValue(\n         AggConstant: &Value,\n         IdxList: *const c_uint,\n@@ -1125,20 +1129,20 @@ extern \"C\" {\n \n     // Operations on global variables\n     pub fn LLVMIsAGlobalVariable(GlobalVar: &Value) -> Option<&Value>;\n-    pub fn LLVMAddGlobal(M: &'a Module, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMAddGlobal<'a>(M: &'a Module, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n     pub fn LLVMGetNamedGlobal(M: &Module, Name: *const c_char) -> Option<&Value>;\n-    pub fn LLVMRustGetOrInsertGlobal(\n+    pub fn LLVMRustGetOrInsertGlobal<'a>(\n         M: &'a Module,\n         Name: *const c_char,\n         NameLen: size_t,\n         T: &'a Type,\n     ) -> &'a Value;\n-    pub fn LLVMRustInsertPrivateGlobal(M: &'a Module, T: &'a Type) -> &'a Value;\n+    pub fn LLVMRustInsertPrivateGlobal<'a>(M: &'a Module, T: &'a Type) -> &'a Value;\n     pub fn LLVMGetFirstGlobal(M: &Module) -> Option<&Value>;\n     pub fn LLVMGetNextGlobal(GlobalVar: &Value) -> Option<&Value>;\n     pub fn LLVMDeleteGlobal(GlobalVar: &Value);\n     pub fn LLVMGetInitializer(GlobalVar: &Value) -> Option<&Value>;\n-    pub fn LLVMSetInitializer(GlobalVar: &'a Value, ConstantVal: &'a Value);\n+    pub fn LLVMSetInitializer<'a>(GlobalVar: &'a Value, ConstantVal: &'a Value);\n     pub fn LLVMIsThreadLocal(GlobalVar: &Value) -> Bool;\n     pub fn LLVMSetThreadLocal(GlobalVar: &Value, IsThreadLocal: Bool);\n     pub fn LLVMSetThreadLocalMode(GlobalVar: &Value, Mode: ThreadLocalMode);\n@@ -1152,7 +1156,7 @@ extern \"C\" {\n     pub fn LLVMSetTailCall(CallInst: &Value, IsTailCall: Bool);\n \n     // Operations on functions\n-    pub fn LLVMRustGetOrInsertFunction(\n+    pub fn LLVMRustGetOrInsertFunction<'a>(\n         M: &'a Module,\n         Name: *const c_char,\n         NameLen: size_t,\n@@ -1180,7 +1184,7 @@ extern \"C\" {\n \n     // Operations on basic blocks\n     pub fn LLVMGetBasicBlockParent(BB: &BasicBlock) -> &Value;\n-    pub fn LLVMAppendBasicBlockInContext(\n+    pub fn LLVMAppendBasicBlockInContext<'a>(\n         C: &'a Context,\n         Fn: &'a Value,\n         Name: *const c_char,\n@@ -1204,39 +1208,39 @@ extern \"C\" {\n     pub fn LLVMSetVolatile(MemoryAccessInst: &Value, volatile: Bool);\n \n     // Operations on phi nodes\n-    pub fn LLVMAddIncoming(\n+    pub fn LLVMAddIncoming<'a>(\n         PhiNode: &'a Value,\n         IncomingValues: *const &'a Value,\n         IncomingBlocks: *const &'a BasicBlock,\n         Count: c_uint,\n     );\n \n     // Instruction builders\n-    pub fn LLVMCreateBuilderInContext(C: &'a Context) -> &'a mut Builder<'a>;\n-    pub fn LLVMPositionBuilderAtEnd(Builder: &Builder<'a>, Block: &'a BasicBlock);\n-    pub fn LLVMGetInsertBlock(Builder: &Builder<'a>) -> &'a BasicBlock;\n-    pub fn LLVMDisposeBuilder(Builder: &'a mut Builder<'a>);\n+    pub fn LLVMCreateBuilderInContext(C: &Context) -> &mut Builder<'_>;\n+    pub fn LLVMPositionBuilderAtEnd<'a>(Builder: &Builder<'a>, Block: &'a BasicBlock);\n+    pub fn LLVMGetInsertBlock<'a>(Builder: &Builder<'a>) -> &'a BasicBlock;\n+    pub fn LLVMDisposeBuilder<'a>(Builder: &'a mut Builder<'a>);\n \n     // Metadata\n-    pub fn LLVMSetCurrentDebugLocation(Builder: &Builder<'a>, L: &'a Value);\n+    pub fn LLVMSetCurrentDebugLocation<'a>(Builder: &Builder<'a>, L: &'a Value);\n \n     // Terminators\n-    pub fn LLVMBuildRetVoid(B: &Builder<'a>) -> &'a Value;\n-    pub fn LLVMBuildRet(B: &Builder<'a>, V: &'a Value) -> &'a Value;\n-    pub fn LLVMBuildBr(B: &Builder<'a>, Dest: &'a BasicBlock) -> &'a Value;\n-    pub fn LLVMBuildCondBr(\n+    pub fn LLVMBuildRetVoid<'a>(B: &Builder<'a>) -> &'a Value;\n+    pub fn LLVMBuildRet<'a>(B: &Builder<'a>, V: &'a Value) -> &'a Value;\n+    pub fn LLVMBuildBr<'a>(B: &Builder<'a>, Dest: &'a BasicBlock) -> &'a Value;\n+    pub fn LLVMBuildCondBr<'a>(\n         B: &Builder<'a>,\n         If: &'a Value,\n         Then: &'a BasicBlock,\n         Else: &'a BasicBlock,\n     ) -> &'a Value;\n-    pub fn LLVMBuildSwitch(\n+    pub fn LLVMBuildSwitch<'a>(\n         B: &Builder<'a>,\n         V: &'a Value,\n         Else: &'a BasicBlock,\n         NumCases: c_uint,\n     ) -> &'a Value;\n-    pub fn LLVMRustBuildInvoke(\n+    pub fn LLVMRustBuildInvoke<'a>(\n         B: &Builder<'a>,\n         Ty: &'a Type,\n         Fn: &'a Value,\n@@ -1247,255 +1251,255 @@ extern \"C\" {\n         Bundle: Option<&OperandBundleDef<'a>>,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildLandingPad(\n+    pub fn LLVMBuildLandingPad<'a>(\n         B: &Builder<'a>,\n         Ty: &'a Type,\n         PersFn: Option<&'a Value>,\n         NumClauses: c_uint,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildResume(B: &Builder<'a>, Exn: &'a Value) -> &'a Value;\n-    pub fn LLVMBuildUnreachable(B: &Builder<'a>) -> &'a Value;\n+    pub fn LLVMBuildResume<'a>(B: &Builder<'a>, Exn: &'a Value) -> &'a Value;\n+    pub fn LLVMBuildUnreachable<'a>(B: &Builder<'a>) -> &'a Value;\n \n-    pub fn LLVMRustBuildCleanupPad(\n+    pub fn LLVMRustBuildCleanupPad<'a>(\n         B: &Builder<'a>,\n         ParentPad: Option<&'a Value>,\n         ArgCnt: c_uint,\n         Args: *const &'a Value,\n         Name: *const c_char,\n     ) -> Option<&'a Value>;\n-    pub fn LLVMRustBuildCleanupRet(\n+    pub fn LLVMRustBuildCleanupRet<'a>(\n         B: &Builder<'a>,\n         CleanupPad: &'a Value,\n         UnwindBB: Option<&'a BasicBlock>,\n     ) -> Option<&'a Value>;\n-    pub fn LLVMRustBuildCatchPad(\n+    pub fn LLVMRustBuildCatchPad<'a>(\n         B: &Builder<'a>,\n         ParentPad: &'a Value,\n         ArgCnt: c_uint,\n         Args: *const &'a Value,\n         Name: *const c_char,\n     ) -> Option<&'a Value>;\n-    pub fn LLVMRustBuildCatchRet(\n+    pub fn LLVMRustBuildCatchRet<'a>(\n         B: &Builder<'a>,\n         Pad: &'a Value,\n         BB: &'a BasicBlock,\n     ) -> Option<&'a Value>;\n-    pub fn LLVMRustBuildCatchSwitch(\n+    pub fn LLVMRustBuildCatchSwitch<'a>(\n         Builder: &Builder<'a>,\n         ParentPad: Option<&'a Value>,\n         BB: Option<&'a BasicBlock>,\n         NumHandlers: c_uint,\n         Name: *const c_char,\n     ) -> Option<&'a Value>;\n-    pub fn LLVMRustAddHandler(CatchSwitch: &'a Value, Handler: &'a BasicBlock);\n-    pub fn LLVMSetPersonalityFn(Func: &'a Value, Pers: &'a Value);\n+    pub fn LLVMRustAddHandler<'a>(CatchSwitch: &'a Value, Handler: &'a BasicBlock);\n+    pub fn LLVMSetPersonalityFn<'a>(Func: &'a Value, Pers: &'a Value);\n \n     // Add a case to the switch instruction\n-    pub fn LLVMAddCase(Switch: &'a Value, OnVal: &'a Value, Dest: &'a BasicBlock);\n+    pub fn LLVMAddCase<'a>(Switch: &'a Value, OnVal: &'a Value, Dest: &'a BasicBlock);\n \n     // Add a clause to the landing pad instruction\n-    pub fn LLVMAddClause(LandingPad: &'a Value, ClauseVal: &'a Value);\n+    pub fn LLVMAddClause<'a>(LandingPad: &'a Value, ClauseVal: &'a Value);\n \n     // Set the cleanup on a landing pad instruction\n     pub fn LLVMSetCleanup(LandingPad: &Value, Val: Bool);\n \n     // Arithmetic\n-    pub fn LLVMBuildAdd(\n+    pub fn LLVMBuildAdd<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildFAdd(\n+    pub fn LLVMBuildFAdd<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildSub(\n+    pub fn LLVMBuildSub<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildFSub(\n+    pub fn LLVMBuildFSub<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildMul(\n+    pub fn LLVMBuildMul<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildFMul(\n+    pub fn LLVMBuildFMul<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildUDiv(\n+    pub fn LLVMBuildUDiv<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildExactUDiv(\n+    pub fn LLVMBuildExactUDiv<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildSDiv(\n+    pub fn LLVMBuildSDiv<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildExactSDiv(\n+    pub fn LLVMBuildExactSDiv<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildFDiv(\n+    pub fn LLVMBuildFDiv<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildURem(\n+    pub fn LLVMBuildURem<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildSRem(\n+    pub fn LLVMBuildSRem<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildFRem(\n+    pub fn LLVMBuildFRem<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildShl(\n+    pub fn LLVMBuildShl<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildLShr(\n+    pub fn LLVMBuildLShr<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildAShr(\n+    pub fn LLVMBuildAShr<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildNSWAdd(\n+    pub fn LLVMBuildNSWAdd<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildNUWAdd(\n+    pub fn LLVMBuildNUWAdd<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildNSWSub(\n+    pub fn LLVMBuildNSWSub<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildNUWSub(\n+    pub fn LLVMBuildNUWSub<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildNSWMul(\n+    pub fn LLVMBuildNSWMul<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildNUWMul(\n+    pub fn LLVMBuildNUWMul<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildAnd(\n+    pub fn LLVMBuildAnd<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildOr(\n+    pub fn LLVMBuildOr<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildXor(\n+    pub fn LLVMBuildXor<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildNeg(B: &Builder<'a>, V: &'a Value, Name: *const c_char) -> &'a Value;\n-    pub fn LLVMBuildFNeg(B: &Builder<'a>, V: &'a Value, Name: *const c_char) -> &'a Value;\n-    pub fn LLVMBuildNot(B: &Builder<'a>, V: &'a Value, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildNeg<'a>(B: &Builder<'a>, V: &'a Value, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildFNeg<'a>(B: &Builder<'a>, V: &'a Value, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildNot<'a>(B: &Builder<'a>, V: &'a Value, Name: *const c_char) -> &'a Value;\n     pub fn LLVMRustSetFastMath(Instr: &Value);\n \n     // Memory\n-    pub fn LLVMBuildAlloca(B: &Builder<'a>, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n-    pub fn LLVMBuildArrayAlloca(\n+    pub fn LLVMBuildAlloca<'a>(B: &Builder<'a>, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildArrayAlloca<'a>(\n         B: &Builder<'a>,\n         Ty: &'a Type,\n         Val: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildLoad2(\n+    pub fn LLVMBuildLoad2<'a>(\n         B: &Builder<'a>,\n         Ty: &'a Type,\n         PointerVal: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n \n-    pub fn LLVMBuildStore(B: &Builder<'a>, Val: &'a Value, Ptr: &'a Value) -> &'a Value;\n+    pub fn LLVMBuildStore<'a>(B: &Builder<'a>, Val: &'a Value, Ptr: &'a Value) -> &'a Value;\n \n-    pub fn LLVMBuildGEP2(\n+    pub fn LLVMBuildGEP2<'a>(\n         B: &Builder<'a>,\n         Ty: &'a Type,\n         Pointer: &'a Value,\n         Indices: *const &'a Value,\n         NumIndices: c_uint,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildInBoundsGEP2(\n+    pub fn LLVMBuildInBoundsGEP2<'a>(\n         B: &Builder<'a>,\n         Ty: &'a Type,\n         Pointer: &'a Value,\n         Indices: *const &'a Value,\n         NumIndices: c_uint,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildStructGEP2(\n+    pub fn LLVMBuildStructGEP2<'a>(\n         B: &Builder<'a>,\n         Ty: &'a Type,\n         Pointer: &'a Value,\n@@ -1504,100 +1508,100 @@ extern \"C\" {\n     ) -> &'a Value;\n \n     // Casts\n-    pub fn LLVMBuildTrunc(\n+    pub fn LLVMBuildTrunc<'a>(\n         B: &Builder<'a>,\n         Val: &'a Value,\n         DestTy: &'a Type,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildZExt(\n+    pub fn LLVMBuildZExt<'a>(\n         B: &Builder<'a>,\n         Val: &'a Value,\n         DestTy: &'a Type,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildSExt(\n+    pub fn LLVMBuildSExt<'a>(\n         B: &Builder<'a>,\n         Val: &'a Value,\n         DestTy: &'a Type,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildFPToUI(\n+    pub fn LLVMBuildFPToUI<'a>(\n         B: &Builder<'a>,\n         Val: &'a Value,\n         DestTy: &'a Type,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildFPToSI(\n+    pub fn LLVMBuildFPToSI<'a>(\n         B: &Builder<'a>,\n         Val: &'a Value,\n         DestTy: &'a Type,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildUIToFP(\n+    pub fn LLVMBuildUIToFP<'a>(\n         B: &Builder<'a>,\n         Val: &'a Value,\n         DestTy: &'a Type,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildSIToFP(\n+    pub fn LLVMBuildSIToFP<'a>(\n         B: &Builder<'a>,\n         Val: &'a Value,\n         DestTy: &'a Type,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildFPTrunc(\n+    pub fn LLVMBuildFPTrunc<'a>(\n         B: &Builder<'a>,\n         Val: &'a Value,\n         DestTy: &'a Type,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildFPExt(\n+    pub fn LLVMBuildFPExt<'a>(\n         B: &Builder<'a>,\n         Val: &'a Value,\n         DestTy: &'a Type,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildPtrToInt(\n+    pub fn LLVMBuildPtrToInt<'a>(\n         B: &Builder<'a>,\n         Val: &'a Value,\n         DestTy: &'a Type,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildIntToPtr(\n+    pub fn LLVMBuildIntToPtr<'a>(\n         B: &Builder<'a>,\n         Val: &'a Value,\n         DestTy: &'a Type,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildBitCast(\n+    pub fn LLVMBuildBitCast<'a>(\n         B: &Builder<'a>,\n         Val: &'a Value,\n         DestTy: &'a Type,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildPointerCast(\n+    pub fn LLVMBuildPointerCast<'a>(\n         B: &Builder<'a>,\n         Val: &'a Value,\n         DestTy: &'a Type,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMRustBuildIntCast(\n+    pub fn LLVMRustBuildIntCast<'a>(\n         B: &Builder<'a>,\n         Val: &'a Value,\n         DestTy: &'a Type,\n         IsSized: bool,\n     ) -> &'a Value;\n \n     // Comparisons\n-    pub fn LLVMBuildICmp(\n+    pub fn LLVMBuildICmp<'a>(\n         B: &Builder<'a>,\n         Op: c_uint,\n         LHS: &'a Value,\n         RHS: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildFCmp(\n+    pub fn LLVMBuildFCmp<'a>(\n         B: &Builder<'a>,\n         Op: c_uint,\n         LHS: &'a Value,\n@@ -1606,17 +1610,17 @@ extern \"C\" {\n     ) -> &'a Value;\n \n     // Miscellaneous instructions\n-    pub fn LLVMBuildPhi(B: &Builder<'a>, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n-    pub fn LLVMRustGetInstrProfIncrementIntrinsic(M: &Module) -> &'a Value;\n-    pub fn LLVMRustBuildCall(\n+    pub fn LLVMBuildPhi<'a>(B: &Builder<'a>, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMRustGetInstrProfIncrementIntrinsic(M: &Module) -> &Value;\n+    pub fn LLVMRustBuildCall<'a>(\n         B: &Builder<'a>,\n         Ty: &'a Type,\n         Fn: &'a Value,\n         Args: *const &'a Value,\n         NumArgs: c_uint,\n         Bundle: Option<&OperandBundleDef<'a>>,\n     ) -> &'a Value;\n-    pub fn LLVMRustBuildMemCpy(\n+    pub fn LLVMRustBuildMemCpy<'a>(\n         B: &Builder<'a>,\n         Dst: &'a Value,\n         DstAlign: c_uint,\n@@ -1625,7 +1629,7 @@ extern \"C\" {\n         Size: &'a Value,\n         IsVolatile: bool,\n     ) -> &'a Value;\n-    pub fn LLVMRustBuildMemMove(\n+    pub fn LLVMRustBuildMemMove<'a>(\n         B: &Builder<'a>,\n         Dst: &'a Value,\n         DstAlign: c_uint,\n@@ -1634,111 +1638,117 @@ extern \"C\" {\n         Size: &'a Value,\n         IsVolatile: bool,\n     ) -> &'a Value;\n-    pub fn LLVMRustBuildMemSet(\n+    pub fn LLVMRustBuildMemSet<'a>(\n         B: &Builder<'a>,\n         Dst: &'a Value,\n         DstAlign: c_uint,\n         Val: &'a Value,\n         Size: &'a Value,\n         IsVolatile: bool,\n     ) -> &'a Value;\n-    pub fn LLVMBuildSelect(\n+    pub fn LLVMBuildSelect<'a>(\n         B: &Builder<'a>,\n         If: &'a Value,\n         Then: &'a Value,\n         Else: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildVAArg(\n+    pub fn LLVMBuildVAArg<'a>(\n         B: &Builder<'a>,\n         list: &'a Value,\n         Ty: &'a Type,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildExtractElement(\n+    pub fn LLVMBuildExtractElement<'a>(\n         B: &Builder<'a>,\n         VecVal: &'a Value,\n         Index: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildInsertElement(\n+    pub fn LLVMBuildInsertElement<'a>(\n         B: &Builder<'a>,\n         VecVal: &'a Value,\n         EltVal: &'a Value,\n         Index: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildShuffleVector(\n+    pub fn LLVMBuildShuffleVector<'a>(\n         B: &Builder<'a>,\n         V1: &'a Value,\n         V2: &'a Value,\n         Mask: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildExtractValue(\n+    pub fn LLVMBuildExtractValue<'a>(\n         B: &Builder<'a>,\n         AggVal: &'a Value,\n         Index: c_uint,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildInsertValue(\n+    pub fn LLVMBuildInsertValue<'a>(\n         B: &Builder<'a>,\n         AggVal: &'a Value,\n         EltVal: &'a Value,\n         Index: c_uint,\n         Name: *const c_char,\n     ) -> &'a Value;\n \n-    pub fn LLVMRustBuildVectorReduceFAdd(\n+    pub fn LLVMRustBuildVectorReduceFAdd<'a>(\n         B: &Builder<'a>,\n         Acc: &'a Value,\n         Src: &'a Value,\n     ) -> &'a Value;\n-    pub fn LLVMRustBuildVectorReduceFMul(\n+    pub fn LLVMRustBuildVectorReduceFMul<'a>(\n         B: &Builder<'a>,\n         Acc: &'a Value,\n         Src: &'a Value,\n     ) -> &'a Value;\n-    pub fn LLVMRustBuildVectorReduceAdd(B: &Builder<'a>, Src: &'a Value) -> &'a Value;\n-    pub fn LLVMRustBuildVectorReduceMul(B: &Builder<'a>, Src: &'a Value) -> &'a Value;\n-    pub fn LLVMRustBuildVectorReduceAnd(B: &Builder<'a>, Src: &'a Value) -> &'a Value;\n-    pub fn LLVMRustBuildVectorReduceOr(B: &Builder<'a>, Src: &'a Value) -> &'a Value;\n-    pub fn LLVMRustBuildVectorReduceXor(B: &Builder<'a>, Src: &'a Value) -> &'a Value;\n-    pub fn LLVMRustBuildVectorReduceMin(\n+    pub fn LLVMRustBuildVectorReduceAdd<'a>(B: &Builder<'a>, Src: &'a Value) -> &'a Value;\n+    pub fn LLVMRustBuildVectorReduceMul<'a>(B: &Builder<'a>, Src: &'a Value) -> &'a Value;\n+    pub fn LLVMRustBuildVectorReduceAnd<'a>(B: &Builder<'a>, Src: &'a Value) -> &'a Value;\n+    pub fn LLVMRustBuildVectorReduceOr<'a>(B: &Builder<'a>, Src: &'a Value) -> &'a Value;\n+    pub fn LLVMRustBuildVectorReduceXor<'a>(B: &Builder<'a>, Src: &'a Value) -> &'a Value;\n+    pub fn LLVMRustBuildVectorReduceMin<'a>(\n         B: &Builder<'a>,\n         Src: &'a Value,\n         IsSigned: bool,\n     ) -> &'a Value;\n-    pub fn LLVMRustBuildVectorReduceMax(\n+    pub fn LLVMRustBuildVectorReduceMax<'a>(\n         B: &Builder<'a>,\n         Src: &'a Value,\n         IsSigned: bool,\n     ) -> &'a Value;\n-    pub fn LLVMRustBuildVectorReduceFMin(B: &Builder<'a>, Src: &'a Value, IsNaN: bool)\n-    -> &'a Value;\n-    pub fn LLVMRustBuildVectorReduceFMax(B: &Builder<'a>, Src: &'a Value, IsNaN: bool)\n-    -> &'a Value;\n+    pub fn LLVMRustBuildVectorReduceFMin<'a>(\n+        B: &Builder<'a>,\n+        Src: &'a Value,\n+        IsNaN: bool,\n+    ) -> &'a Value;\n+    pub fn LLVMRustBuildVectorReduceFMax<'a>(\n+        B: &Builder<'a>,\n+        Src: &'a Value,\n+        IsNaN: bool,\n+    ) -> &'a Value;\n \n-    pub fn LLVMRustBuildMinNum(B: &Builder<'a>, LHS: &'a Value, LHS: &'a Value) -> &'a Value;\n-    pub fn LLVMRustBuildMaxNum(B: &Builder<'a>, LHS: &'a Value, LHS: &'a Value) -> &'a Value;\n+    pub fn LLVMRustBuildMinNum<'a>(B: &Builder<'a>, LHS: &'a Value, LHS: &'a Value) -> &'a Value;\n+    pub fn LLVMRustBuildMaxNum<'a>(B: &Builder<'a>, LHS: &'a Value, LHS: &'a Value) -> &'a Value;\n \n     // Atomic Operations\n-    pub fn LLVMRustBuildAtomicLoad(\n+    pub fn LLVMRustBuildAtomicLoad<'a>(\n         B: &Builder<'a>,\n         ElementType: &'a Type,\n         PointerVal: &'a Value,\n         Name: *const c_char,\n         Order: AtomicOrdering,\n     ) -> &'a Value;\n \n-    pub fn LLVMRustBuildAtomicStore(\n+    pub fn LLVMRustBuildAtomicStore<'a>(\n         B: &Builder<'a>,\n         Val: &'a Value,\n         Ptr: &'a Value,\n         Order: AtomicOrdering,\n     ) -> &'a Value;\n \n-    pub fn LLVMRustBuildAtomicCmpXchg(\n+    pub fn LLVMRustBuildAtomicCmpXchg<'a>(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         CMP: &'a Value,\n@@ -1748,7 +1758,7 @@ extern \"C\" {\n         Weak: Bool,\n     ) -> &'a Value;\n \n-    pub fn LLVMBuildAtomicRMW(\n+    pub fn LLVMBuildAtomicRMW<'a>(\n         B: &Builder<'a>,\n         Op: AtomicRmwBinOp,\n         LHS: &'a Value,\n@@ -1767,16 +1777,16 @@ extern \"C\" {\n     pub fn LLVMWriteBitcodeToFile(M: &Module, Path: *const c_char) -> c_int;\n \n     /// Creates a pass manager.\n-    pub fn LLVMCreatePassManager() -> &'a mut PassManager<'a>;\n+    pub fn LLVMCreatePassManager<'a>() -> &'a mut PassManager<'a>;\n \n     /// Creates a function-by-function pass manager\n-    pub fn LLVMCreateFunctionPassManagerForModule(M: &'a Module) -> &'a mut PassManager<'a>;\n+    pub fn LLVMCreateFunctionPassManagerForModule(M: &Module) -> &mut PassManager<'_>;\n \n     /// Disposes a pass manager.\n-    pub fn LLVMDisposePassManager(PM: &'a mut PassManager<'a>);\n+    pub fn LLVMDisposePassManager<'a>(PM: &'a mut PassManager<'a>);\n \n     /// Runs a pass manager on a module.\n-    pub fn LLVMRunPassManager(PM: &PassManager<'a>, M: &'a Module) -> Bool;\n+    pub fn LLVMRunPassManager<'a>(PM: &PassManager<'a>, M: &'a Module) -> Bool;\n \n     pub fn LLVMInitializePasses();\n \n@@ -1786,7 +1796,7 @@ extern \"C\" {\n \n     pub fn LLVMTimeTraceProfilerFinish(FileName: *const c_char);\n \n-    pub fn LLVMAddAnalysisPasses(T: &'a TargetMachine, PM: &PassManager<'a>);\n+    pub fn LLVMAddAnalysisPasses<'a>(T: &'a TargetMachine, PM: &PassManager<'a>);\n \n     pub fn LLVMPassManagerBuilderCreate() -> &'static mut PassManagerBuilder;\n     pub fn LLVMPassManagerBuilderDispose(PMB: &'static mut PassManagerBuilder);\n@@ -1830,7 +1840,7 @@ extern \"C\" {\n \n     pub fn LLVMStructCreateNamed(C: &Context, Name: *const c_char) -> &Type;\n \n-    pub fn LLVMStructSetBody(\n+    pub fn LLVMStructSetBody<'a>(\n         StructTy: &'a Type,\n         ElementTypes: *const &'a Type,\n         ElementCount: c_uint,\n@@ -1873,8 +1883,7 @@ extern \"C\" {\n         BufferOut: &RustString,\n     );\n \n-    pub fn LLVMRustCoverageCreatePGOFuncNameVar(F: &'a Value, FuncName: *const c_char)\n-    -> &'a Value;\n+    pub fn LLVMRustCoverageCreatePGOFuncNameVar(F: &Value, FuncName: *const c_char) -> &Value;\n     pub fn LLVMRustCoverageHashCString(StrVal: *const c_char) -> u64;\n     pub fn LLVMRustCoverageHashByteArray(Bytes: *const c_char, NumBytes: size_t) -> u64;\n \n@@ -1895,15 +1904,15 @@ extern \"C\" {\n \n     pub fn LLVMRustAddModuleFlag(M: &Module, name: *const c_char, value: u32);\n \n-    pub fn LLVMRustMetadataAsValue(C: &'a Context, MD: &'a Metadata) -> &'a Value;\n+    pub fn LLVMRustMetadataAsValue<'a>(C: &'a Context, MD: &'a Metadata) -> &'a Value;\n \n-    pub fn LLVMRustDIBuilderCreate(M: &'a Module) -> &'a mut DIBuilder<'a>;\n+    pub fn LLVMRustDIBuilderCreate(M: &Module) -> &mut DIBuilder<'_>;\n \n-    pub fn LLVMRustDIBuilderDispose(Builder: &'a mut DIBuilder<'a>);\n+    pub fn LLVMRustDIBuilderDispose<'a>(Builder: &'a mut DIBuilder<'a>);\n \n     pub fn LLVMRustDIBuilderFinalize(Builder: &DIBuilder<'_>);\n \n-    pub fn LLVMRustDIBuilderCreateCompileUnit(\n+    pub fn LLVMRustDIBuilderCreateCompileUnit<'a>(\n         Builder: &DIBuilder<'a>,\n         Lang: c_uint,\n         File: &'a DIFile,\n@@ -1919,7 +1928,7 @@ extern \"C\" {\n         SplitDebugInlining: bool,\n     ) -> &'a DIDescriptor;\n \n-    pub fn LLVMRustDIBuilderCreateFile(\n+    pub fn LLVMRustDIBuilderCreateFile<'a>(\n         Builder: &DIBuilder<'a>,\n         Filename: *const c_char,\n         FilenameLen: size_t,\n@@ -1930,12 +1939,12 @@ extern \"C\" {\n         ChecksumLen: size_t,\n     ) -> &'a DIFile;\n \n-    pub fn LLVMRustDIBuilderCreateSubroutineType(\n+    pub fn LLVMRustDIBuilderCreateSubroutineType<'a>(\n         Builder: &DIBuilder<'a>,\n         ParameterTypes: &'a DIArray,\n     ) -> &'a DICompositeType;\n \n-    pub fn LLVMRustDIBuilderCreateFunction(\n+    pub fn LLVMRustDIBuilderCreateFunction<'a>(\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIDescriptor,\n         Name: *const c_char,\n@@ -1953,15 +1962,15 @@ extern \"C\" {\n         Decl: Option<&'a DIDescriptor>,\n     ) -> &'a DISubprogram;\n \n-    pub fn LLVMRustDIBuilderCreateBasicType(\n+    pub fn LLVMRustDIBuilderCreateBasicType<'a>(\n         Builder: &DIBuilder<'a>,\n         Name: *const c_char,\n         NameLen: size_t,\n         SizeInBits: u64,\n         Encoding: c_uint,\n     ) -> &'a DIBasicType;\n \n-    pub fn LLVMRustDIBuilderCreateTypedef(\n+    pub fn LLVMRustDIBuilderCreateTypedef<'a>(\n         Builder: &DIBuilder<'a>,\n         Type: &'a DIBasicType,\n         Name: *const c_char,\n@@ -1971,7 +1980,7 @@ extern \"C\" {\n         Scope: Option<&'a DIScope>,\n     ) -> &'a DIDerivedType;\n \n-    pub fn LLVMRustDIBuilderCreatePointerType(\n+    pub fn LLVMRustDIBuilderCreatePointerType<'a>(\n         Builder: &DIBuilder<'a>,\n         PointeeTy: &'a DIType,\n         SizeInBits: u64,\n@@ -1981,7 +1990,7 @@ extern \"C\" {\n         NameLen: size_t,\n     ) -> &'a DIDerivedType;\n \n-    pub fn LLVMRustDIBuilderCreateStructType(\n+    pub fn LLVMRustDIBuilderCreateStructType<'a>(\n         Builder: &DIBuilder<'a>,\n         Scope: Option<&'a DIDescriptor>,\n         Name: *const c_char,\n@@ -1999,7 +2008,7 @@ extern \"C\" {\n         UniqueIdLen: size_t,\n     ) -> &'a DICompositeType;\n \n-    pub fn LLVMRustDIBuilderCreateMemberType(\n+    pub fn LLVMRustDIBuilderCreateMemberType<'a>(\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIDescriptor,\n         Name: *const c_char,\n@@ -2013,7 +2022,7 @@ extern \"C\" {\n         Ty: &'a DIType,\n     ) -> &'a DIDerivedType;\n \n-    pub fn LLVMRustDIBuilderCreateVariantMemberType(\n+    pub fn LLVMRustDIBuilderCreateVariantMemberType<'a>(\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIScope,\n         Name: *const c_char,\n@@ -2028,21 +2037,21 @@ extern \"C\" {\n         Ty: &'a DIType,\n     ) -> &'a DIType;\n \n-    pub fn LLVMRustDIBuilderCreateLexicalBlock(\n+    pub fn LLVMRustDIBuilderCreateLexicalBlock<'a>(\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIScope,\n         File: &'a DIFile,\n         Line: c_uint,\n         Col: c_uint,\n     ) -> &'a DILexicalBlock;\n \n-    pub fn LLVMRustDIBuilderCreateLexicalBlockFile(\n+    pub fn LLVMRustDIBuilderCreateLexicalBlockFile<'a>(\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIScope,\n         File: &'a DIFile,\n     ) -> &'a DILexicalBlock;\n \n-    pub fn LLVMRustDIBuilderCreateStaticVariable(\n+    pub fn LLVMRustDIBuilderCreateStaticVariable<'a>(\n         Builder: &DIBuilder<'a>,\n         Context: Option<&'a DIScope>,\n         Name: *const c_char,\n@@ -2058,7 +2067,7 @@ extern \"C\" {\n         AlignInBits: u32,\n     ) -> &'a DIGlobalVariableExpression;\n \n-    pub fn LLVMRustDIBuilderCreateVariable(\n+    pub fn LLVMRustDIBuilderCreateVariable<'a>(\n         Builder: &DIBuilder<'a>,\n         Tag: c_uint,\n         Scope: &'a DIDescriptor,\n@@ -2073,27 +2082,27 @@ extern \"C\" {\n         AlignInBits: u32,\n     ) -> &'a DIVariable;\n \n-    pub fn LLVMRustDIBuilderCreateArrayType(\n+    pub fn LLVMRustDIBuilderCreateArrayType<'a>(\n         Builder: &DIBuilder<'a>,\n         Size: u64,\n         AlignInBits: u32,\n         Ty: &'a DIType,\n         Subscripts: &'a DIArray,\n     ) -> &'a DIType;\n \n-    pub fn LLVMRustDIBuilderGetOrCreateSubrange(\n+    pub fn LLVMRustDIBuilderGetOrCreateSubrange<'a>(\n         Builder: &DIBuilder<'a>,\n         Lo: i64,\n         Count: i64,\n     ) -> &'a DISubrange;\n \n-    pub fn LLVMRustDIBuilderGetOrCreateArray(\n+    pub fn LLVMRustDIBuilderGetOrCreateArray<'a>(\n         Builder: &DIBuilder<'a>,\n         Ptr: *const Option<&'a DIDescriptor>,\n         Count: c_uint,\n     ) -> &'a DIArray;\n \n-    pub fn LLVMRustDIBuilderInsertDeclareAtEnd(\n+    pub fn LLVMRustDIBuilderInsertDeclareAtEnd<'a>(\n         Builder: &DIBuilder<'a>,\n         Val: &'a Value,\n         VarInfo: &'a DIVariable,\n@@ -2103,15 +2112,15 @@ extern \"C\" {\n         InsertAtEnd: &'a BasicBlock,\n     ) -> &'a Value;\n \n-    pub fn LLVMRustDIBuilderCreateEnumerator(\n+    pub fn LLVMRustDIBuilderCreateEnumerator<'a>(\n         Builder: &DIBuilder<'a>,\n         Name: *const c_char,\n         NameLen: size_t,\n         Value: i64,\n         IsUnsigned: bool,\n     ) -> &'a DIEnumerator;\n \n-    pub fn LLVMRustDIBuilderCreateEnumerationType(\n+    pub fn LLVMRustDIBuilderCreateEnumerationType<'a>(\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIScope,\n         Name: *const c_char,\n@@ -2125,7 +2134,7 @@ extern \"C\" {\n         IsScoped: bool,\n     ) -> &'a DIType;\n \n-    pub fn LLVMRustDIBuilderCreateUnionType(\n+    pub fn LLVMRustDIBuilderCreateUnionType<'a>(\n         Builder: &DIBuilder<'a>,\n         Scope: Option<&'a DIScope>,\n         Name: *const c_char,\n@@ -2141,7 +2150,7 @@ extern \"C\" {\n         UniqueIdLen: size_t,\n     ) -> &'a DIType;\n \n-    pub fn LLVMRustDIBuilderCreateVariantPart(\n+    pub fn LLVMRustDIBuilderCreateVariantPart<'a>(\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIScope,\n         Name: *const c_char,\n@@ -2159,30 +2168,30 @@ extern \"C\" {\n \n     pub fn LLVMSetUnnamedAddress(Global: &Value, UnnamedAddr: UnnamedAddr);\n \n-    pub fn LLVMRustDIBuilderCreateTemplateTypeParameter(\n+    pub fn LLVMRustDIBuilderCreateTemplateTypeParameter<'a>(\n         Builder: &DIBuilder<'a>,\n         Scope: Option<&'a DIScope>,\n         Name: *const c_char,\n         NameLen: size_t,\n         Ty: &'a DIType,\n     ) -> &'a DITemplateTypeParameter;\n \n-    pub fn LLVMRustDIBuilderCreateNameSpace(\n+    pub fn LLVMRustDIBuilderCreateNameSpace<'a>(\n         Builder: &DIBuilder<'a>,\n         Scope: Option<&'a DIScope>,\n         Name: *const c_char,\n         NameLen: size_t,\n         ExportSymbols: bool,\n     ) -> &'a DINameSpace;\n \n-    pub fn LLVMRustDICompositeTypeReplaceArrays(\n+    pub fn LLVMRustDICompositeTypeReplaceArrays<'a>(\n         Builder: &DIBuilder<'a>,\n         CompositeType: &'a DIType,\n         Elements: Option<&'a DIArray>,\n         Params: Option<&'a DIArray>,\n     );\n \n-    pub fn LLVMRustDIBuilderCreateDebugLocation(\n+    pub fn LLVMRustDIBuilderCreateDebugLocation<'a>(\n         Line: c_uint,\n         Column: c_uint,\n         Scope: &'a DIScope,\n@@ -2248,7 +2257,7 @@ extern \"C\" {\n         SplitDwarfFile: *const c_char,\n     ) -> Option<&'static mut TargetMachine>;\n     pub fn LLVMRustDisposeTargetMachine(T: &'static mut TargetMachine);\n-    pub fn LLVMRustAddBuilderLibraryInfo(\n+    pub fn LLVMRustAddBuilderLibraryInfo<'a>(\n         PMB: &'a PassManagerBuilder,\n         M: &'a Module,\n         DisableSimplifyLibCalls: bool,\n@@ -2264,21 +2273,21 @@ extern \"C\" {\n         PGOUsePath: *const c_char,\n         PGOSampleUsePath: *const c_char,\n     );\n-    pub fn LLVMRustAddLibraryInfo(\n+    pub fn LLVMRustAddLibraryInfo<'a>(\n         PM: &PassManager<'a>,\n         M: &'a Module,\n         DisableSimplifyLibCalls: bool,\n     );\n-    pub fn LLVMRustRunFunctionPassManager(PM: &PassManager<'a>, M: &'a Module);\n-    pub fn LLVMRustWriteOutputFile(\n+    pub fn LLVMRustRunFunctionPassManager<'a>(PM: &PassManager<'a>, M: &'a Module);\n+    pub fn LLVMRustWriteOutputFile<'a>(\n         T: &'a TargetMachine,\n         PM: &PassManager<'a>,\n         M: &'a Module,\n         Output: *const c_char,\n         DwoOutput: *const c_char,\n         FileType: FileType,\n     ) -> LLVMRustResult;\n-    pub fn LLVMRustOptimizeWithNewPassManager(\n+    pub fn LLVMRustOptimizeWithNewPassManager<'a>(\n         M: &'a Module,\n         TM: &'a TargetMachine,\n         OptLevel: PassBuilderOptLevel,\n@@ -2306,7 +2315,7 @@ extern \"C\" {\n         ExtraPassesLen: size_t,\n     ) -> LLVMRustResult;\n     pub fn LLVMRustPrintModule(\n-        M: &'a Module,\n+        M: &Module,\n         Output: *const c_char,\n         Demangle: extern \"C\" fn(*const c_char, size_t, *mut c_char, size_t) -> size_t,\n     ) -> LLVMRustResult;\n@@ -2319,21 +2328,21 @@ extern \"C\" {\n     pub fn LLVMRustMarkAllFunctionsNounwind(M: &Module);\n \n     pub fn LLVMRustOpenArchive(path: *const c_char) -> Option<&'static mut Archive>;\n-    pub fn LLVMRustArchiveIteratorNew(AR: &'a Archive) -> &'a mut ArchiveIterator<'a>;\n-    pub fn LLVMRustArchiveIteratorNext(\n+    pub fn LLVMRustArchiveIteratorNew(AR: &Archive) -> &mut ArchiveIterator<'_>;\n+    pub fn LLVMRustArchiveIteratorNext<'a>(\n         AIR: &ArchiveIterator<'a>,\n     ) -> Option<&'a mut ArchiveChild<'a>>;\n     pub fn LLVMRustArchiveChildName(ACR: &ArchiveChild<'_>, size: &mut size_t) -> *const c_char;\n     pub fn LLVMRustArchiveChildData(ACR: &ArchiveChild<'_>, size: &mut size_t) -> *const c_char;\n-    pub fn LLVMRustArchiveChildFree(ACR: &'a mut ArchiveChild<'a>);\n-    pub fn LLVMRustArchiveIteratorFree(AIR: &'a mut ArchiveIterator<'a>);\n+    pub fn LLVMRustArchiveChildFree<'a>(ACR: &'a mut ArchiveChild<'a>);\n+    pub fn LLVMRustArchiveIteratorFree<'a>(AIR: &'a mut ArchiveIterator<'a>);\n     pub fn LLVMRustDestroyArchive(AR: &'static mut Archive);\n \n     #[allow(improper_ctypes)]\n     pub fn LLVMRustWriteTwineToString(T: &Twine, s: &RustString);\n \n     #[allow(improper_ctypes)]\n-    pub fn LLVMRustUnpackOptimizationDiagnostic(\n+    pub fn LLVMRustUnpackOptimizationDiagnostic<'a>(\n         DI: &'a DiagnosticInfo,\n         pass_name_out: &RustString,\n         function_out: &mut Option<&'a Value>,\n@@ -2343,7 +2352,7 @@ extern \"C\" {\n         message_out: &RustString,\n     );\n \n-    pub fn LLVMRustUnpackInlineAsmDiagnostic(\n+    pub fn LLVMRustUnpackInlineAsmDiagnostic<'a>(\n         DI: &'a DiagnosticInfo,\n         level_out: &mut DiagnosticLevel,\n         cookie_out: &mut c_uint,\n@@ -2354,7 +2363,7 @@ extern \"C\" {\n     pub fn LLVMRustWriteDiagnosticInfoToString(DI: &DiagnosticInfo, s: &RustString);\n     pub fn LLVMRustGetDiagInfoKind(DI: &DiagnosticInfo) -> DiagnosticKind;\n \n-    pub fn LLVMRustGetSMDiagnostic(\n+    pub fn LLVMRustGetSMDiagnostic<'a>(\n         DI: &'a DiagnosticInfo,\n         cookie_out: &mut c_uint,\n     ) -> &'a SMDiagnostic;\n@@ -2383,12 +2392,12 @@ extern \"C\" {\n         WriteSymbtab: bool,\n         Kind: ArchiveKind,\n     ) -> LLVMRustResult;\n-    pub fn LLVMRustArchiveMemberNew(\n+    pub fn LLVMRustArchiveMemberNew<'a>(\n         Filename: *const c_char,\n         Name: *const c_char,\n         Child: Option<&ArchiveChild<'a>>,\n     ) -> &'a mut RustArchiveMember<'a>;\n-    pub fn LLVMRustArchiveMemberFree(Member: &'a mut RustArchiveMember<'a>);\n+    pub fn LLVMRustArchiveMemberFree<'a>(Member: &'a mut RustArchiveMember<'a>);\n \n     pub fn LLVMRustWriteImportLibrary(\n         ImportName: *const c_char,\n@@ -2399,18 +2408,18 @@ extern \"C\" {\n         MinGW: bool,\n     ) -> LLVMRustResult;\n \n-    pub fn LLVMRustSetDataLayoutFromTargetMachine(M: &'a Module, TM: &'a TargetMachine);\n+    pub fn LLVMRustSetDataLayoutFromTargetMachine<'a>(M: &'a Module, TM: &'a TargetMachine);\n \n-    pub fn LLVMRustBuildOperandBundleDef(\n+    pub fn LLVMRustBuildOperandBundleDef<'a>(\n         Name: *const c_char,\n         Inputs: *const &'a Value,\n         NumInputs: c_uint,\n     ) -> &'a mut OperandBundleDef<'a>;\n-    pub fn LLVMRustFreeOperandBundleDef(Bundle: &'a mut OperandBundleDef<'a>);\n+    pub fn LLVMRustFreeOperandBundleDef<'a>(Bundle: &'a mut OperandBundleDef<'a>);\n \n-    pub fn LLVMRustPositionBuilderAtStart(B: &Builder<'a>, BB: &'a BasicBlock);\n+    pub fn LLVMRustPositionBuilderAtStart<'a>(B: &Builder<'a>, BB: &'a BasicBlock);\n \n-    pub fn LLVMRustSetComdat(M: &'a Module, V: &'a Value, Name: *const c_char, NameLen: size_t);\n+    pub fn LLVMRustSetComdat<'a>(M: &'a Module, V: &'a Value, Name: *const c_char, NameLen: size_t);\n     pub fn LLVMRustUnsetComdat(V: &Value);\n     pub fn LLVMRustSetModulePICLevel(M: &Module);\n     pub fn LLVMRustSetModulePIELevel(M: &Module);\n@@ -2463,13 +2472,13 @@ extern \"C\" {\n     pub fn LLVMRustLTOGetDICompileUnit(M: &Module, CU1: &mut *mut c_void, CU2: &mut *mut c_void);\n     pub fn LLVMRustLTOPatchDICompileUnit(M: &Module, CU: *mut c_void);\n \n-    pub fn LLVMRustLinkerNew(M: &'a Module) -> &'a mut Linker<'a>;\n+    pub fn LLVMRustLinkerNew(M: &Module) -> &mut Linker<'_>;\n     pub fn LLVMRustLinkerAdd(\n         linker: &Linker<'_>,\n         bytecode: *const c_char,\n         bytecode_len: usize,\n     ) -> bool;\n-    pub fn LLVMRustLinkerFree(linker: &'a mut Linker<'a>);\n+    pub fn LLVMRustLinkerFree<'a>(linker: &'a mut Linker<'a>);\n     #[allow(improper_ctypes)]\n     pub fn LLVMRustComputeLTOCacheKey(\n         key_out: &RustString,"}, {"sha": "a1117a11fc7cea9d69d82b89ef9b9b410488b909", "filename": "compiler/rustc_codegen_llvm/src/llvm/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -31,13 +31,13 @@ impl LLVMRustResult {\n     }\n }\n \n-pub fn AddFunctionAttrStringValue(llfn: &'a Value, idx: AttributePlace, attr: &CStr, value: &CStr) {\n+pub fn AddFunctionAttrStringValue(llfn: &Value, idx: AttributePlace, attr: &CStr, value: &CStr) {\n     unsafe {\n         LLVMRustAddFunctionAttrStringValue(llfn, idx.as_uint(), attr.as_ptr(), value.as_ptr())\n     }\n }\n \n-pub fn AddFunctionAttrString(llfn: &'a Value, idx: AttributePlace, attr: &CStr) {\n+pub fn AddFunctionAttrString(llfn: &Value, idx: AttributePlace, attr: &CStr) {\n     unsafe {\n         LLVMRustAddFunctionAttrStringValue(llfn, idx.as_uint(), attr.as_ptr(), std::ptr::null())\n     }\n@@ -86,12 +86,12 @@ impl FromStr for ArchiveKind {\n     }\n }\n \n-pub fn SetInstructionCallConv(instr: &'a Value, cc: CallConv) {\n+pub fn SetInstructionCallConv(instr: &Value, cc: CallConv) {\n     unsafe {\n         LLVMSetInstructionCallConv(instr, cc as c_uint);\n     }\n }\n-pub fn SetFunctionCallConv(fn_: &'a Value, cc: CallConv) {\n+pub fn SetFunctionCallConv(fn_: &Value, cc: CallConv) {\n     unsafe {\n         LLVMSetFunctionCallConv(fn_, cc as c_uint);\n     }\n@@ -103,26 +103,26 @@ pub fn SetFunctionCallConv(fn_: &'a Value, cc: CallConv) {\n // value's name as the comdat value to make sure that it is in a 1-to-1 relationship to the\n // function.\n // For more details on COMDAT sections see e.g., https://www.airs.com/blog/archives/52\n-pub fn SetUniqueComdat(llmod: &Module, val: &'a Value) {\n+pub fn SetUniqueComdat(llmod: &Module, val: &Value) {\n     unsafe {\n         let name = get_value_name(val);\n         LLVMRustSetComdat(llmod, val, name.as_ptr().cast(), name.len());\n     }\n }\n \n-pub fn UnsetComdat(val: &'a Value) {\n+pub fn UnsetComdat(val: &Value) {\n     unsafe {\n         LLVMRustUnsetComdat(val);\n     }\n }\n \n-pub fn SetUnnamedAddress(global: &'a Value, unnamed: UnnamedAddr) {\n+pub fn SetUnnamedAddress(global: &Value, unnamed: UnnamedAddr) {\n     unsafe {\n         LLVMSetUnnamedAddress(global, unnamed);\n     }\n }\n \n-pub fn set_thread_local_mode(global: &'a Value, mode: ThreadLocalMode) {\n+pub fn set_thread_local_mode(global: &Value, mode: ThreadLocalMode) {\n     unsafe {\n         LLVMSetThreadLocalMode(global, mode);\n     }\n@@ -264,7 +264,7 @@ pub struct OperandBundleDef<'a> {\n     pub raw: &'a mut ffi::OperandBundleDef<'a>,\n }\n \n-impl OperandBundleDef<'a> {\n+impl<'a> OperandBundleDef<'a> {\n     pub fn new(name: &str, vals: &[&'a Value]) -> Self {\n         let name = SmallCStr::new(name);\n         let def = unsafe {\n@@ -274,7 +274,7 @@ impl OperandBundleDef<'a> {\n     }\n }\n \n-impl Drop for OperandBundleDef<'a> {\n+impl Drop for OperandBundleDef<'_> {\n     fn drop(&mut self) {\n         unsafe {\n             LLVMRustFreeOperandBundleDef(&mut *(self.raw as *mut _));"}, {"sha": "a3053742aad997447d564a5daafd93c63b80f3f9", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -13,7 +13,7 @@ use rustc_session::config::CrateType;\n use rustc_target::spec::RelocModel;\n use tracing::debug;\n \n-impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+impl<'tcx> PreDefineMethods<'tcx> for CodegenCx<'_, 'tcx> {\n     fn predefine_static(\n         &self,\n         def_id: DefId,\n@@ -92,7 +92,7 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n }\n \n-impl CodegenCx<'ll, 'tcx> {\n+impl CodegenCx<'_, '_> {\n     /// Whether a definition or declaration can be assumed to be local to a group of\n     /// libraries that form a single DSO or executable.\n     pub(crate) unsafe fn should_assume_dso_local("}, {"sha": "21b77f7dea6fbe439c8bf5cecada6f0a7c500320", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -38,7 +38,7 @@ impl fmt::Debug for Type {\n     }\n }\n \n-impl CodegenCx<'ll, 'tcx> {\n+impl<'ll> CodegenCx<'ll, '_> {\n     crate fn type_named_struct(&self, name: &str) -> &'ll Type {\n         let name = SmallCStr::new(name);\n         unsafe { llvm::LLVMStructCreateNamed(self.llcx, name.as_ptr()) }\n@@ -133,7 +133,7 @@ impl CodegenCx<'ll, 'tcx> {\n     }\n }\n \n-impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+impl<'ll, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn type_i1(&self) -> &'ll Type {\n         unsafe { llvm::LLVMInt1TypeInContext(self.llcx) }\n     }\n@@ -252,7 +252,7 @@ impl Type {\n     }\n }\n \n-impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+impl<'ll, 'tcx> LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn backend_type(&self, layout: TyAndLayout<'tcx>) -> &'ll Type {\n         layout.llvm_type(self)\n     }"}, {"sha": "f090ae6ecb46e4e3aec43112ecc3a68e04020dd4", "filename": "compiler/rustc_codegen_llvm/src/va_arg.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -11,8 +11,8 @@ use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_middle::ty::Ty;\n use rustc_target::abi::{Align, Endian, HasDataLayout, Size};\n \n-fn round_pointer_up_to_alignment(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n+fn round_pointer_up_to_alignment<'ll>(\n+    bx: &mut Builder<'_, 'll, '_>,\n     addr: &'ll Value,\n     align: Align,\n     ptr_ty: &'ll Type,\n@@ -23,8 +23,8 @@ fn round_pointer_up_to_alignment(\n     bx.inttoptr(ptr_as_int, ptr_ty)\n }\n \n-fn emit_direct_ptr_va_arg(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n+fn emit_direct_ptr_va_arg<'ll, 'tcx>(\n+    bx: &mut Builder<'_, 'll, 'tcx>,\n     list: OperandRef<'tcx, &'ll Value>,\n     llty: &'ll Type,\n     size: Size,\n@@ -62,8 +62,8 @@ fn emit_direct_ptr_va_arg(\n     }\n }\n \n-fn emit_ptr_va_arg(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n+fn emit_ptr_va_arg<'ll, 'tcx>(\n+    bx: &mut Builder<'_, 'll, 'tcx>,\n     list: OperandRef<'tcx, &'ll Value>,\n     target_ty: Ty<'tcx>,\n     indirect: bool,\n@@ -90,8 +90,8 @@ fn emit_ptr_va_arg(\n     }\n }\n \n-fn emit_aapcs_va_arg(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n+fn emit_aapcs_va_arg<'ll, 'tcx>(\n+    bx: &mut Builder<'_, 'll, 'tcx>,\n     list: OperandRef<'tcx, &'ll Value>,\n     target_ty: Ty<'tcx>,\n ) -> &'ll Value {\n@@ -175,8 +175,8 @@ fn emit_aapcs_va_arg(\n     val\n }\n \n-pub(super) fn emit_va_arg(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n+pub(super) fn emit_va_arg<'ll, 'tcx>(\n+    bx: &mut Builder<'_, 'll, 'tcx>,\n     addr: OperandRef<'tcx, &'ll Value>,\n     target_ty: Ty<'tcx>,\n ) -> &'ll Value {"}, {"sha": "6271d75e635e2762a93201663294cf7dc8ad2247", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -32,7 +32,7 @@ use cc::windows_registry;\n use regex::Regex;\n use tempfile::Builder as TempFileBuilder;\n \n-use std::ffi::OsString;\n+use std::ffi::{OsStr, OsString};\n use std::lazy::OnceCell;\n use std::path::{Path, PathBuf};\n use std::process::{ExitStatus, Output, Stdio};\n@@ -504,17 +504,19 @@ fn escape_stdout_stderr_string(s: &[u8]) -> String {\n \n const LLVM_DWP_EXECUTABLE: &'static str = \"rust-llvm-dwp\";\n \n-/// Invoke `llvm-dwp` (shipped alongside rustc) to link `dwo` files from Split DWARF into a `dwp`\n+/// Invoke `llvm-dwp` (shipped alongside rustc) to link debuginfo in object files into a `dwp`\n /// file.\n-fn link_dwarf_object<'a>(sess: &'a Session, executable_out_filename: &Path) {\n+fn link_dwarf_object<'a, I>(sess: &'a Session, executable_out_filename: &Path, object_files: I)\n+where\n+    I: IntoIterator<Item: AsRef<OsStr>>,\n+{\n     info!(\"preparing dwp to {}.dwp\", executable_out_filename.to_str().unwrap());\n \n     let dwp_out_filename = executable_out_filename.with_extension(\"dwp\");\n     let mut cmd = Command::new(LLVM_DWP_EXECUTABLE);\n-    cmd.arg(\"-e\");\n-    cmd.arg(executable_out_filename);\n     cmd.arg(\"-o\");\n     cmd.arg(&dwp_out_filename);\n+    cmd.args(object_files);\n \n     let mut new_path = sess.get_tools_search_paths(false);\n     if let Some(path) = env::var_os(\"PATH\") {\n@@ -898,7 +900,14 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n         SplitDebuginfo::Packed if sess.target.is_like_msvc => {}\n \n         // ... and otherwise we're processing a `*.dwp` packed dwarf file.\n-        SplitDebuginfo::Packed => link_dwarf_object(sess, &out_filename),\n+        // We cannot rely on the .o paths in the exectuable because they may have been\n+        // remapped by --remap-path-prefix and therefore invalid. So we need to provide\n+        // the .o paths explicitly\n+        SplitDebuginfo::Packed => link_dwarf_object(\n+            sess,\n+            &out_filename,\n+            codegen_results.modules.iter().filter_map(|m| m.object.as_ref()),\n+        ),\n     }\n \n     let strip = strip_value(sess);"}, {"sha": "c70a6914520183fbdc21dc031499a5f601467b32", "filename": "compiler/rustc_metadata/src/foreign_modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -13,7 +13,7 @@ struct Collector {\n     modules: Vec<ForeignModule>,\n }\n \n-impl ItemLikeVisitor<'tcx> for Collector {\n+impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n     fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n         let items = match it.kind {\n             hir::ItemKind::ForeignMod { items, .. } => items,"}, {"sha": "918c3b9daf1075bb6e6b9b9d5c520eb67536c8a8", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -1,7 +1,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n-#![feature(in_band_lifetimes)]\n #![feature(let_else)]\n #![feature(nll)]\n #![feature(once_cell)]"}, {"sha": "2893ceb5bf54362327baf5325ed797bbc44b8dc9", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -734,7 +734,7 @@ impl<'a> CrateLocator<'a> {\n     }\n }\n \n-fn get_metadata_section(\n+fn get_metadata_section<'p>(\n     target: &Target,\n     flavor: CrateFlavor,\n     filename: &'p Path,"}, {"sha": "808151089df85d0d7271a4b70509884575daaee8", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -31,7 +31,7 @@ struct Collector<'tcx> {\n     libs: Vec<NativeLib>,\n }\n \n-impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n+impl<'tcx> ItemLikeVisitor<'tcx> for Collector<'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n         let (abi, foreign_mod_items) = match it.kind {\n             hir::ItemKind::ForeignMod { abi, items } => (abi, items),\n@@ -223,7 +223,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n     fn visit_foreign_item(&mut self, _it: &'tcx hir::ForeignItem<'tcx>) {}\n }\n \n-impl Collector<'tcx> {\n+impl Collector<'_> {\n     fn register_native_lib(&mut self, span: Option<Span>, lib: NativeLib) {\n         if lib.name.as_ref().map_or(false, |&s| s == kw::Empty) {\n             match span {"}, {"sha": "09c6cb010b04dc7b3693c3b5056e476405423b2e", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -628,7 +628,7 @@ where\n \n implement_ty_decoder!(DecodeContext<'a, 'tcx>);\n \n-impl MetadataBlob {\n+impl<'tcx> MetadataBlob {\n     crate fn new(metadata_ref: MetadataRef) -> MetadataBlob {\n         MetadataBlob(Lrc::new(metadata_ref))\n     }\n@@ -697,7 +697,7 @@ impl CrateRoot<'_> {\n         &self.triple\n     }\n \n-    crate fn decode_crate_deps(\n+    crate fn decode_crate_deps<'a>(\n         &self,\n         metadata: &'a MetadataBlob,\n     ) -> impl ExactSizeIterator<Item = CrateDep> + Captures<'a> {"}, {"sha": "5ba7efc37f8bd238f9e95148a3b1a8b65f7a78b9", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -83,7 +83,7 @@ impl IntoArgs for (CrateNum, DefId) {\n     }\n }\n \n-impl IntoArgs for ty::InstanceDef<'tcx> {\n+impl<'tcx> IntoArgs for ty::InstanceDef<'tcx> {\n     fn into_args(self) -> (DefId, DefId) {\n         (self.def_id(), self.def_id())\n     }"}, {"sha": "054431169a26cb342ed5d8d7f15539c9f84a48e8", "filename": "compiler/rustc_metadata/src/rmeta/def_path_hash_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -11,7 +11,7 @@ crate enum DefPathHashMapRef<'tcx> {\n     BorrowedFromTcx(&'tcx DefPathHashMap),\n }\n \n-impl DefPathHashMapRef<'tcx> {\n+impl DefPathHashMapRef<'_> {\n     #[inline]\n     pub fn def_path_hash_to_def_index(&self, def_path_hash: &DefPathHash) -> DefIndex {\n         match *self {"}, {"sha": "a6828e103dc5f80d06575ebd6ad00fa394dc7f33", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -964,7 +964,7 @@ fn should_encode_generics(def_kind: DefKind) -> bool {\n     }\n }\n \n-impl EncodeContext<'a, 'tcx> {\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_def_ids(&mut self) {\n         if self.is_proc_macro {\n             return;\n@@ -1894,7 +1894,7 @@ impl EncodeContext<'a, 'tcx> {\n }\n \n // FIXME(eddyb) make metadata encoding walk over all definitions, instead of HIR.\n-impl Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n@@ -1927,7 +1927,7 @@ impl Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl EncodeContext<'a, 'tcx> {\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_fields(&mut self, adt_def: &ty::AdtDef) {\n         for (variant_index, variant) in adt_def.variants.iter_enumerated() {\n             for (field_index, _field) in variant.fields.iter().enumerate() {"}, {"sha": "5ce239ac704269f781c4401b7c81ccb3fc64e1d0", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -275,7 +275,7 @@ macro_rules! define_tables {\n             $($name: TableBuilder<$IDX, $T>),+\n         }\n \n-        impl TableBuilders<'tcx> {\n+        impl<'tcx> TableBuilders<'tcx> {\n             fn encode(&self, buf: &mut Encoder) -> LazyTables<'tcx> {\n                 LazyTables {\n                     $($name: self.$name.encode(buf)),+"}, {"sha": "6c2657bd64bdbe47de19dafaa50545a05425063a", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -3,7 +3,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Binder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n use rustc_trait_selection::traits;\n \n fn sized_constraint_for_ty<'tcx>(\n@@ -285,6 +285,12 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n \n     let constness = match hir_id {\n         Some(hir_id) => match tcx.hir().get(hir_id) {\n+            hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. })\n+                if tcx.has_attr(def_id, sym::default_method_body_is_const) =>\n+            {\n+                hir::Constness::Const\n+            }\n+\n             hir::Node::Item(hir::Item { kind: hir::ItemKind::Const(..), .. })\n             | hir::Node::Item(hir::Item { kind: hir::ItemKind::Static(..), .. })\n             | hir::Node::TraitItem(hir::TraitItem {"}, {"sha": "3b0e4a31db1c8ce894f05b0fb770915efc23dd0d", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -972,8 +972,8 @@ impl<T> MaybeUninit<T> {\n     #[rustc_const_unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n     #[inline(always)]\n     pub const unsafe fn slice_assume_init_ref(slice: &[Self]) -> &[T] {\n-        // SAFETY: casting slice to a `*const [T]` is safe since the caller guarantees that\n-        // `slice` is initialized, and`MaybeUninit` is guaranteed to have the same layout as `T`.\n+        // SAFETY: casting `slice` to a `*const [T]` is safe since the caller guarantees that\n+        // `slice` is initialized, and `MaybeUninit` is guaranteed to have the same layout as `T`.\n         // The pointer obtained is valid since it refers to memory owned by `slice` which is a\n         // reference and thus guaranteed to be valid for reads.\n         unsafe { &*(slice as *const [Self] as *const [T]) }"}, {"sha": "eef04c767fb7c6bf7871b6997e3f67c274701b9d", "filename": "src/test/run-make-fulldeps/split-dwarf/Makefile", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2FMakefile?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -2,7 +2,16 @@\n \n # only-linux\n \n-all:\n+all: packed remapped\n+\n+remapped:\n+\t$(RUSTC) -Z unstable-options -C split-debuginfo=packed -C debuginfo=2 --remap-path-prefix $(TMPDIR)=/a foo.rs -g\n+\tobjdump -Wi $(TMPDIR)/foo | grep DW_AT_GNU_dwo_name | (! grep $(TMPDIR)) || exit 1\n+\n+\t$(RUSTC) -Z unstable-options -C split-debuginfo=unpacked -C debuginfo=2 --remap-path-prefix $(TMPDIR)=/a foo.rs -g\n+\tobjdump -Wi $(TMPDIR)/foo | grep DW_AT_GNU_dwo_name | (! grep $(TMPDIR)) || exit 1\n+\n+packed:\n \t$(RUSTC) -Z unstable-options -C split-debuginfo=packed -C debuginfo=2 foo.rs -g\n \trm $(TMPDIR)/foo.dwp\n \trm $(TMPDIR)/$(call BIN,foo)"}, {"sha": "7cf1bb09c92f7a1190cffd40a3c038e13e9c5eac", "filename": "src/test/ui/panics/location-detail-panic-no-column.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-column.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-column.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-column.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -1,6 +1,7 @@\n // run-fail\n // check-run-results\n // compile-flags: -Zlocation-detail=line,file\n+// exec-env:RUST_BACKTRACE=0\n \n fn main() {\n     panic!(\"column-redacted\");"}, {"sha": "46c9b8448d7e444306bb3b1f63a9b153b7831216", "filename": "src/test/ui/panics/location-detail-panic-no-column.run.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-column.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-column.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-column.run.stderr?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -1,2 +1,2 @@\n-thread 'main' panicked at 'column-redacted', $DIR/location-detail-panic-no-column.rs:6:0\n+thread 'main' panicked at 'column-redacted', $DIR/location-detail-panic-no-column.rs:7:0\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace"}, {"sha": "9bcbf01d1c6f6987c87dc62356e7ee81751fc043", "filename": "src/test/ui/panics/location-detail-panic-no-file.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-file.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -1,6 +1,7 @@\n // run-fail\n // check-run-results\n // compile-flags: -Zlocation-detail=line,column\n+// exec-env:RUST_BACKTRACE=0\n \n fn main() {\n     panic!(\"file-redacted\");"}, {"sha": "811f93bf3085f272b5991c952e68e075a85a790a", "filename": "src/test/ui/panics/location-detail-panic-no-file.run.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-file.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-file.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-file.run.stderr?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -1,2 +1,2 @@\n-thread 'main' panicked at 'file-redacted', <redacted>:6:5\n+thread 'main' panicked at 'file-redacted', <redacted>:7:5\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace"}, {"sha": "25df092e1fb9c76c870b799dfddb9b2b0ea05ce5", "filename": "src/test/ui/panics/location-detail-panic-no-line.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-line.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -1,6 +1,7 @@\n // run-fail\n // check-run-results\n // compile-flags: -Zlocation-detail=file,column\n+// exec-env:RUST_BACKTRACE=0\n \n fn main() {\n     panic!(\"line-redacted\");"}, {"sha": "16cf8a17ff190f70dd52be32213b70d0942fa022", "filename": "src/test/ui/panics/location-detail-unwrap-no-file.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-unwrap-no-file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-unwrap-no-file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-unwrap-no-file.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -1,6 +1,7 @@\n // run-fail\n // check-run-results\n // compile-flags: -Zlocation-detail=line,column\n+// exec-env:RUST_BACKTRACE=0\n \n fn main() {\n     let opt: Option<u32> = None;"}, {"sha": "7d8e1d93038a3f37166a1a66d68512e0249a483d", "filename": "src/test/ui/panics/location-detail-unwrap-no-file.run.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-unwrap-no-file.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-unwrap-no-file.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-unwrap-no-file.run.stderr?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -1,2 +1,2 @@\n-thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', <redacted>:7:9\n+thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', <redacted>:8:9\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace"}, {"sha": "7db04fe1ac3f13646867dfd513993bd037b942bf", "filename": "src/test/ui/rfc-2632-const-trait-impl/default-method-body-is-const-body-checking.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.rs?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -0,0 +1,17 @@\n+#![feature(const_fn_trait_bound)]\n+#![feature(const_trait_impl)]\n+\n+trait Tr {}\n+impl Tr for () {}\n+\n+const fn foo<T>() where T: ~const Tr {}\n+\n+pub trait Foo {\n+    #[default_method_body_is_const]\n+    fn foo() {\n+        foo::<()>();\n+        //~^ ERROR the trait bound `(): Tr` is not satisfied\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6e7e4b3a472d6b715940a315429141225259d5f1", "filename": "src/test/ui/rfc-2632-const-trait-impl/default-method-body-is-const-body-checking.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91a0600a5c22b9d159e3c57526af83e71d1120f8/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.stderr?ref=91a0600a5c22b9d159e3c57526af83e71d1120f8", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `(): Tr` is not satisfied\n+  --> $DIR/default-method-body-is-const-body-checking.rs:12:15\n+   |\n+LL |         foo::<()>();\n+   |               ^^ the trait `Tr` is not implemented for `()`\n+   |\n+note: required by a bound in `foo`\n+  --> $DIR/default-method-body-is-const-body-checking.rs:7:28\n+   |\n+LL | const fn foo<T>() where T: ~const Tr {}\n+   |                            ^^^^^^^^^ required by this bound in `foo`\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+   |\n+LL | pub trait Foo where (): Tr {\n+   |               ++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}