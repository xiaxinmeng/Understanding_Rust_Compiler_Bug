{"sha": "9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljOTZhNzlhNzRmMTBiZWQxOGIwMzFjZTBhYzQxMjZjNTZkNmNmYjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-18T01:02:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-18T01:02:19Z"}, "message": "auto merge of #19049 : jakub-/rust/roll-up, r=alexcrichton\n\nr? @alexcrichton", "tree": {"sha": "42a980b8b8b145b37aae79c28c7540f8a7eec8d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42a980b8b8b145b37aae79c28c7540f8a7eec8d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "html_url": "https://github.com/rust-lang/rust/commit/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "336349c93207d792587eb0b5258b29da6ec0db8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/336349c93207d792587eb0b5258b29da6ec0db8a", "html_url": "https://github.com/rust-lang/rust/commit/336349c93207d792587eb0b5258b29da6ec0db8a"}, {"sha": "330a1afae84c7bea583907e5b1f02448a4c7bc20", "url": "https://api.github.com/repos/rust-lang/rust/commits/330a1afae84c7bea583907e5b1f02448a4c7bc20", "html_url": "https://github.com/rust-lang/rust/commit/330a1afae84c7bea583907e5b1f02448a4c7bc20"}], "stats": {"total": 1111, "additions": 744, "deletions": 367}, "files": [{"sha": "d1f1ee6f3bdb42b88b0248baeb86319180f055f0", "filename": "mk/cfg/arm-apple-ios", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Farm-apple-ios", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Farm-apple-ios", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-apple-ios?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -13,7 +13,7 @@ CFG_LIB_NAME_arm-apple-ios = lib$(1).a\n CFG_LIB_GLOB_arm-apple-ios = lib$(1)-*.a\n CFG_STATIC_LIB_NAME_arm-apple-ios=lib$(1).a\n CFG_LIB_DSYM_GLOB_arm-apple-ios = lib$(1)-*.a.dSYM\n-CFG_CFLAGS_arm-apple-ios := -arch armv7 -mfpu=vfp3 $(CFG_IOS_FLAGS)\n+CFG_JEMALLOC_CFLAGS_arm-apple-ios := -arch armv7 -mfpu=vfp3 $(CFG_IOS_FLAGS)\n CFG_GCCISH_CFLAGS_arm-apple-ios := -Wall -Werror -g -fPIC $(CFG_IOS_FLAGS) -mfpu=vfp3 -arch armv7\n CFG_GCCISH_CXXFLAGS_arm-apple-ios := -fno-rtti $(CFG_IOS_FLAGS) -I$(CFG_IOS_SDK)/usr/include/c++/4.2.1\n CFG_GCCISH_LINK_FLAGS_arm-apple-ios := -lpthread -syslibroot $(CFG_IOS_SDK) -Wl,-no_compact_unwind"}, {"sha": "471220e2b6618ae08bb6726c0489b39ed3b5c358", "filename": "mk/cfg/arm-linux-androideabi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Farm-linux-androideabi", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Farm-linux-androideabi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-linux-androideabi?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -7,7 +7,7 @@ CFG_LIB_NAME_arm-linux-androideabi=lib$(1).so\n CFG_STATIC_LIB_NAME_arm-linux-androideabi=lib$(1).a\n CFG_LIB_GLOB_arm-linux-androideabi=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_arm-linux-androideabi=lib$(1)-*.dylib.dSYM\n-CFG_CFLAGS_arm-linux-androideabi := -D__arm__ -DANDROID -D__ANDROID__ $(CFLAGS)\n+CFG_JEMALLOC_CFLAGS_arm-linux-androideabi := -D__arm__ -DANDROID -D__ANDROID__ $(CFLAGS)\n CFG_GCCISH_CFLAGS_arm-linux-androideabi := -Wall -g -fPIC -D__arm__ -DANDROID -D__ANDROID__ $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_arm-linux-androideabi := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_arm-linux-androideabi := -shared -fPIC -ldl -g -lm -lsupc++"}, {"sha": "b4c604b26bae04eda24ecf4b801c37fc55489e67", "filename": "mk/cfg/arm-unknown-linux-gnueabi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Farm-unknown-linux-gnueabi", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Farm-unknown-linux-gnueabi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-unknown-linux-gnueabi?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -8,7 +8,7 @@ CFG_LIB_NAME_arm-unknown-linux-gnueabi=lib$(1).so\n CFG_STATIC_LIB_NAME_arm-unknown-linux-gnueabi=lib$(1).a\n CFG_LIB_GLOB_arm-unknown-linux-gnueabi=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_arm-unknown-linux-gnueabi=lib$(1)-*.dylib.dSYM\n-CFG_CFLAGS_arm-unknown-linux-gnueabi := -D__arm__ -mfpu=vfp $(CFLAGS)\n+CFG_JEMALLOC_CFLAGS_arm-unknown-linux-gnueabi := -D__arm__ -mfpu=vfp $(CFLAGS)\n CFG_GCCISH_CFLAGS_arm-unknown-linux-gnueabi := -Wall -g -fPIC -D__arm__ -mfpu=vfp $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_arm-unknown-linux-gnueabi := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_arm-unknown-linux-gnueabi := -shared -fPIC -g"}, {"sha": "4f02de0f6b5e67893d589ffea47831a22b6a3d38", "filename": "mk/cfg/arm-unknown-linux-gnueabihf", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Farm-unknown-linux-gnueabihf", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Farm-unknown-linux-gnueabihf", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-unknown-linux-gnueabihf?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -8,7 +8,7 @@ CFG_LIB_NAME_arm-unknown-linux-gnueabihf=lib$(1).so\n CFG_STATIC_LIB_NAME_arm-unknown-linux-gnueabihf=lib$(1).a\n CFG_LIB_GLOB_arm-unknown-linux-gnueabihf=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_arm-unknown-linux-gnueabihf=lib$(1)-*.dylib.dSYM\n-CFG_CFLAGS_arm-unknown-linux-gnueabihf := -D__arm__ $(CFLAGS)\n+CFG_JEMALLOC_CFLAGS_arm-unknown-linux-gnueabihf := -D__arm__ $(CFLAGS)\n CFG_GCCISH_CFLAGS_arm-unknown-linux-gnueabihf := -Wall -g -fPIC -D__arm__ $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_arm-unknown-linux-gnueabihf := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_arm-unknown-linux-gnueabihf := -shared -fPIC -g"}, {"sha": "63eb590c6e4f6962a8f67487c9554acfbe728992", "filename": "mk/cfg/i386-apple-ios", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fi386-apple-ios", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fi386-apple-ios", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi386-apple-ios?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -13,7 +13,6 @@ CFG_LIB_NAME_i386-apple-ios = lib$(1).a\n CFG_LIB_GLOB_i386-apple-ios = lib$(1)-*.dylib\n CFG_STATIC_LIB_NAME_i386-apple-ios=lib$(1).a\n CFG_LIB_DSYM_GLOB_i386-apple-ios = lib$(1)-*.dylib.dSYM\n-CFG_CFLAGS_i386-apple-ios = $(CFG_IOSSIM_FLAGS)\n CFG_GCCISH_CFLAGS_i386-apple-ios = -Wall -Werror -g -fPIC -m32 $(CFG_IOSSIM_FLAGS)\n CFG_GCCISH_CXXFLAGS_i386-apple-ios = -fno-rtti $(CFG_IOSSIM_FLAGS) -I$(CFG_IOSSIM_SDK)/usr/include/c++/4.2.1\n CFG_GCCISH_LINK_FLAGS_i386-apple-ios = -lpthread -Wl,-no_compact_unwind -m32 -Wl,-syslibroot $(CFG_IOSSIM_SDK)\n@@ -30,5 +29,5 @@ CFG_PATH_MUNGE_i386-apple-ios = true\n CFG_LDPATH_i386-apple-ios =\n CFG_RUN_i386-apple-ios = $(2)\n CFG_RUN_TARG_i386-apple-ios = $(call CFG_RUN_i386-apple-ios,,$(2))\n-CFG_JEMALLOC_CFLAGS_i386-apple-ios = -target i386-apple-ios -Wl,-syslibroot $(CFG_IOSSIM_SDK) -Wl,-no_compact_unwind\n+CFG_JEMALLOC_CFLAGS_i386-apple-ios = $(CFG_IOSSIM_FLAGS) -target i386-apple-ios -Wl,-syslibroot $(CFG_IOSSIM_SDK) -Wl,-no_compact_unwind\n CFG_GNU_TRIPLE_i386-apple-ios := i386-apple-ios"}, {"sha": "e935ce053e02aa273b0423522cd427446d89a326", "filename": "mk/cfg/i686-apple-darwin", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fi686-apple-darwin", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fi686-apple-darwin", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-apple-darwin?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -7,7 +7,7 @@ CFG_LIB_NAME_i686-apple-darwin=lib$(1).dylib\n CFG_STATIC_LIB_NAME_i686-apple-darwin=lib$(1).a\n CFG_LIB_GLOB_i686-apple-darwin=lib$(1)-*.dylib\n CFG_LIB_DSYM_GLOB_i686-apple-darwin=lib$(1)-*.dylib.dSYM\n-CFG_CFLAGS_i686-apple-darwin := -m32 -arch i386 $(CFLAGS)\n+CFG_JEMALLOC_CFLAGS_i686-apple-darwin := -m32 -arch i386 $(CFLAGS)\n CFG_GCCISH_CFLAGS_i686-apple-darwin := -Wall -Werror -g -fPIC -m32 -arch i386 $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_i686-apple-darwin := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_i686-apple-darwin := -dynamiclib -pthread  -framework CoreServices -m32"}, {"sha": "ecb405b76f0109634d007b91eff1ced4596ac964", "filename": "mk/cfg/i686-pc-windows-gnu", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fi686-pc-windows-gnu", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fi686-pc-windows-gnu", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-pc-windows-gnu?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -8,7 +8,7 @@ CFG_LIB_NAME_i686-pc-windows-gnu=$(1).dll\n CFG_STATIC_LIB_NAME_i686-pc-windows-gnu=$(1).lib\n CFG_LIB_GLOB_i686-pc-windows-gnu=$(1)-*.dll\n CFG_LIB_DSYM_GLOB_i686-pc-windows-gnu=$(1)-*.dylib.dSYM\n-CFG_CFLAGS_i686-pc-windows-gnu := -march=i686 -m32 -D_WIN32_WINNT=0x0600 $(CFLAGS)\n+CFG_JEMALLOC_CFLAGS_i686-pc-windows-gnu := -march=i686 -m32 -D_WIN32_WINNT=0x0600 $(CFLAGS)\n CFG_GCCISH_CFLAGS_i686-pc-windows-gnu := -Wall -Werror -g -m32 -D_WIN32_WINNT=0x0600 $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_i686-pc-windows-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_i686-pc-windows-gnu := -shared -g -m32"}, {"sha": "1cc9c143e8d470860a269334b94929f10bcfc934", "filename": "mk/cfg/i686-unknown-linux-gnu", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fi686-unknown-linux-gnu", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fi686-unknown-linux-gnu", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-unknown-linux-gnu?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -7,7 +7,7 @@ CFG_LIB_NAME_i686-unknown-linux-gnu=lib$(1).so\n CFG_STATIC_LIB_NAME_i686-unknown-linux-gnu=lib$(1).a\n CFG_LIB_GLOB_i686-unknown-linux-gnu=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_i686-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n-CFG_CFLAGS_i686-unknown-linux-gnu := -m32 $(CFLAGS)\n+CFG_JEMALLOC_CFLAGS_i686-unknown-linux-gnu := -m32 $(CFLAGS)\n CFG_GCCISH_CFLAGS_i686-unknown-linux-gnu := -Wall -Werror -g -fPIC -m32 $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_i686-unknown-linux-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_i686-unknown-linux-gnu := -shared -fPIC -ldl -pthread  -lrt -g -m32"}, {"sha": "c5d84966f8526f332b2a19b3d3ab3c00e1eb88b7", "filename": "mk/cfg/mips-unknown-linux-gnu", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fmips-unknown-linux-gnu", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fmips-unknown-linux-gnu", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fmips-unknown-linux-gnu?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -7,7 +7,7 @@ CFG_LIB_NAME_mips-unknown-linux-gnu=lib$(1).so\n CFG_STATIC_LIB_NAME_mips-unknown-linux-gnu=lib$(1).a\n CFG_LIB_GLOB_mips-unknown-linux-gnu=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_mips-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n-CFG_CFLAGS_mips-unknown-linux-gnu := -mips32r2 -msoft-float -mabi=32 -mno-compact-eh $(CFLAGS)\n+CFG_JEMALLOC_CFLAGS_mips-unknown-linux-gnu := -mips32r2 -msoft-float -mabi=32 -mno-compact-eh $(CFLAGS)\n CFG_GCCISH_CFLAGS_mips-unknown-linux-gnu := -Wall -g -fPIC -mips32r2 -msoft-float -mabi=32 -mno-compact-eh $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_mips-unknown-linux-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_mips-unknown-linux-gnu := -shared -fPIC -g -mips32r2 -msoft-float -mabi=32"}, {"sha": "eb2f300abffd8072665fab3d8c68ac8a527ee6e9", "filename": "mk/cfg/mipsel-unknown-linux-gnu", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fmipsel-unknown-linux-gnu", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fmipsel-unknown-linux-gnu", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fmipsel-unknown-linux-gnu?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -7,7 +7,7 @@ CFG_LIB_NAME_mipsel-unknown-linux-gnu=lib$(1).so\n CFG_STATIC_LIB_NAME_mipsel-unknown-linux-gnu=lib$(1).a\n CFG_LIB_GLOB_mipsel-unknown-linux-gnu=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_mipsel-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n-CFG_CFLAGS_mipsel-unknown-linux-gnu := -mips32 -mabi=32 $(CFLAGS)\n+CFG_JEMALLOC_CFLAGS_mipsel-unknown-linux-gnu := -mips32 -mabi=32 $(CFLAGS)\n CFG_GCCISH_CFLAGS_mipsel-unknown-linux-gnu := -Wall -g -fPIC -mips32 -mabi=32 $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_mipsel-unknown-linux-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_mipsel-unknown-linux-gnu := -shared -fPIC -g -mips32"}, {"sha": "dbd67542ab75a08c994c27454a6189ba8297ef3c", "filename": "mk/cfg/x86_64-apple-darwin", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fx86_64-apple-darwin", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fx86_64-apple-darwin", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-apple-darwin?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -7,7 +7,7 @@ CFG_LIB_NAME_x86_64-apple-darwin=lib$(1).dylib\n CFG_STATIC_LIB_NAME_x86_64-apple-darwin=lib$(1).a\n CFG_LIB_GLOB_x86_64-apple-darwin=lib$(1)-*.dylib\n CFG_LIB_DSYM_GLOB_x86_64-apple-darwin=lib$(1)-*.dylib.dSYM\n-CFG_CFLAGS_x86_64-apple-darwin := -m64 -arch x86_64 $(CFLAGS)\n+CFG_JEMALLOC_CFLAGS_x86_64-apple-darwin := -m64 -arch x86_64 $(CFLAGS)\n CFG_GCCISH_CFLAGS_x86_64-apple-darwin := -Wall -Werror -g -fPIC -m64 -arch x86_64 $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_x86_64-apple-darwin := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-apple-darwin := -dynamiclib -pthread  -framework CoreServices -m64"}, {"sha": "a23e292c7bd5d8cd255ee34c8760b6972a1dc453", "filename": "mk/cfg/x86_64-pc-windows-gnu", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fx86_64-pc-windows-gnu", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fx86_64-pc-windows-gnu", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-pc-windows-gnu?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -8,7 +8,7 @@ CFG_LIB_NAME_x86_64-pc-windows-gnu=$(1).dll\n CFG_STATIC_LIB_NAME_x86_64-pc-windows-gnu=$(1).lib\n CFG_LIB_GLOB_x86_64-pc-windows-gnu=$(1)-*.dll\n CFG_LIB_DSYM_GLOB_x86_64-pc-windows-gnu=$(1)-*.dylib.dSYM\n-CFG_CFLAGS_x86_64-pc-windows-gnu := -m64 -D_WIN32_WINNT=0x0600 $(CFLAGS)\n+CFG_JEMALLOC_CFLAGS_x86_64-pc-windows-gnu := -m64 -D_WIN32_WINNT=0x0600 $(CFLAGS)\n CFG_GCCISH_CFLAGS_x86_64-pc-windows-gnu := -Wall -Werror -g -m64 -D_WIN32_WINNT=0x0600 $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_x86_64-pc-windows-gnu := -fno-rtti $(CXXFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-pc-windows-gnu := -shared -g -m64"}, {"sha": "05414c79dd78e80be17d814240ee210c60fa33ab", "filename": "mk/cfg/x86_64-unknown-dragonfly", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fx86_64-unknown-dragonfly", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fx86_64-unknown-dragonfly", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-dragonfly?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -7,7 +7,7 @@ CFG_LIB_NAME_x86_64-unknown-dragonfly=lib$(1).so\n CFG_STATIC_LIB_NAME_x86_64-unknown-dragonfly=lib$(1).a\n CFG_LIB_GLOB_x86_64-unknown-dragonfly=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_x86_64-unknown-dragonfly=$(1)-*.dylib.dSYM\n-CFG_CFLAGS_x86_64-unknown-dragonfly := -I/usr/include -I/usr/local/include $(CFLAGS)\n+CFG_JEMALLOC_CFLAGS_x86_64-unknown-dragonfly := -I/usr/include -I/usr/local/include $(CFLAGS)\n CFG_GCCISH_CFLAGS_x86_64-unknown-dragonfly := -Wall -Werror -g -fPIC -I/usr/include -I/usr/local/include $(CFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-dragonfly := -shared -fPIC -g -pthread  -lrt\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-dragonfly := -Wl,--export-dynamic,--dynamic-list="}, {"sha": "4e847ea78a717e13f258003aa3b56447a837cc29", "filename": "mk/cfg/x86_64-unknown-freebsd", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fx86_64-unknown-freebsd", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fx86_64-unknown-freebsd", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-freebsd?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -7,7 +7,7 @@ CFG_LIB_NAME_x86_64-unknown-freebsd=lib$(1).so\n CFG_STATIC_LIB_NAME_x86_64-unknown-freebsd=lib$(1).a\n CFG_LIB_GLOB_x86_64-unknown-freebsd=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_x86_64-unknown-freebsd=$(1)-*.dylib.dSYM\n-CFG_CFLAGS_x86_64-unknown-freebsd := -I/usr/local/include $(CFLAGS)\n+CFG_JEMALLOC_CFLAGS_x86_64-unknown-freebsd := -I/usr/local/include $(CFLAGS)\n CFG_GCCISH_CFLAGS_x86_64-unknown-freebsd := -Wall -Werror -g -fPIC -I/usr/local/include $(CFLAGS)\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-freebsd := -shared -fPIC -g -pthread  -lrt\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-freebsd := -Wl,--export-dynamic,--dynamic-list="}, {"sha": "845f9c1c52d19fedb6aeef1c3bb362bfad9ce342", "filename": "mk/cfg/x86_64-unknown-linux-gnu", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fx86_64-unknown-linux-gnu", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Fcfg%2Fx86_64-unknown-linux-gnu", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-linux-gnu?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -7,7 +7,7 @@ CFG_LIB_NAME_x86_64-unknown-linux-gnu=lib$(1).so\n CFG_STATIC_LIB_NAME_x86_64-unknown-linux-gnu=lib$(1).a\n CFG_LIB_GLOB_x86_64-unknown-linux-gnu=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_x86_64-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n-CFG_CFLAGS_x86_64-unknown-linux-gnu := -m64\n+CFG_JEMALLOC_CFLAGS_x86_64-unknown-linux-gnu := -m64\n CFG_GCCISH_CFLAGS_x86_64-unknown-linux-gnu := -Wall -Werror -g -fPIC -m64\n CFG_GCCISH_CXXFLAGS_x86_64-unknown-linux-gnu := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-linux-gnu := -shared -fPIC -ldl -pthread  -lrt -g -m64"}, {"sha": "a7d6a6e825fbcbecce194926fec3c4960a111d01", "filename": "mk/rt.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -177,11 +177,11 @@ $$(JEMALLOC_LOCAL_$(1)): $$(JEMALLOC_DEPS) $$(MKFILE_DEPS)\n \tcd \"$$(JEMALLOC_BUILD_DIR_$(1))\"; \"$(S)src/jemalloc/configure\" \\\n \t\t$$(JEMALLOC_ARGS_$(1)) --with-jemalloc-prefix=je_ $(CFG_JEMALLOC_FLAGS) \\\n \t\t--build=$$(CFG_GNU_TRIPLE_$(CFG_BUILD)) --host=$$(CFG_GNU_TRIPLE_$(1)) \\\n-\t\tCC=\"$$(CC_$(1))\" \\\n+\t\tCC=\"$$(CC_$(1)) $$(CFG_JEMALLOC_CFLAGS_$(1))\" \\\n \t\tAR=\"$$(AR_$(1))\" \\\n \t\tRANLIB=\"$$(AR_$(1)) s\" \\\n \t\tCPPFLAGS=\"-I $(S)src/rt/\" \\\n-\t\tEXTRA_CFLAGS=\"$$(CFG_CFLAGS_$(1)) $$(CFG_JEMALLOC_CFLAGS_$(1)) -g1\"\n+\t\tEXTRA_CFLAGS=\"-g1\"\n \t$$(Q)$$(MAKE) -C \"$$(JEMALLOC_BUILD_DIR_$(1))\" build_lib_static\n \n ifeq ($$(CFG_DISABLE_JEMALLOC),)"}, {"sha": "171c39a4cbc3937ed276a90eb183186b9717af54", "filename": "src/doc/reference.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -304,8 +304,8 @@ r##\"foo #\"# bar\"##;                // foo #\"# bar\n #### Byte and byte string literals\n \n ```{.ebnf .gram}\n-byte_lit : 'b' '\\x27' byte_body '\\x27' ;\n-byte_string_lit : 'b' '\"' string_body * '\"' | 'b' 'r' raw_byte_string ;\n+byte_lit : \"b\\x27\" byte_body '\\x27' ;\n+byte_string_lit : \"b\\x22\" string_body * '\\x22' | \"br\" raw_byte_string ;\n \n byte_body : ascii_non_single_quote\n           | '\\x5c' [ '\\x27' | common_escape ] ;\n@@ -381,10 +381,10 @@ num_suffix : int_suffix | float_suffix ;\n \n int_suffix : 'u' int_suffix_size ?\n            | 'i' int_suffix_size ? ;\n-int_suffix_size : [ '8' | '1' '6' | '3' '2' | '6' '4' ] ;\n+int_suffix_size : [ '8' | \"16\" | \"32\" | \"64\" ] ;\n \n float_suffix : [ exponent | '.' dec_lit exponent ? ] ? float_suffix_ty ? ;\n-float_suffix_ty : 'f' [ '3' '2' | '6' '4' ] ;\n+float_suffix_ty : 'f' [ \"32\" | \"64\" ] ;\n exponent : ['E' | 'e'] ['-' | '+' ] ? dec_lit ;\n dec_lit : [ dec_digit | '_' ] + ;\n ```\n@@ -1862,7 +1862,7 @@ the namespace hierarchy as it normally would.\n ## Attributes\n \n ```{.ebnf .gram}\n-attribute : '#' '!' ? '[' meta_item ']' ;\n+attribute : \"#!\" ? '[' meta_item ']' ;\n meta_item : ident [ '=' literal\n                   | '(' meta_seq ')' ] ? ;\n meta_seq : meta_item [ ',' meta_seq ] ? ;"}, {"sha": "159a62f01107206b1a4f0e92be71fae111a37c92", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -178,7 +178,7 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, Token>) -> TokenAndSpan {\n     let toknum = m.name(\"toknum\");\n     let content = m.name(\"content\");\n \n-    let proto_tok = tokens.find_equiv(&toknum).expect(format!(\"didn't find token {} in the map\",\n+    let proto_tok = tokens.get(&toknum).expect(format!(\"didn't find token {} in the map\",\n                                                               toknum).as_slice());\n \n     let nm = parse::token::intern(content);"}, {"sha": "0529bb8904ab9b3011be246271bfe4c37912fe98", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -283,7 +283,7 @@ impl Bitv {\n         x != 0\n     }\n \n-    /// Sets the value of a bit at a index `i`.\n+    /// Sets the value of a bit at an index `i`.\n     ///\n     /// # Panics\n     ///\n@@ -582,7 +582,7 @@ impl Bitv {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the the `Bitv` and slice are of different length.\n+    /// Panics if the `Bitv` and slice are of different length.\n     ///\n     /// # Example\n     ///"}, {"sha": "adb9a9ae5bd3dc442f5e5de6e6fca86fa69b923a", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -21,6 +21,7 @@ use core::prelude::*;\n \n use self::StackOp::*;\n use super::node::*;\n+use core::borrow::BorrowFrom;\n use std::hash::{Writer, Hash};\n use core::default::Default;\n use core::{iter, fmt, mem};\n@@ -56,7 +57,7 @@ use ring_buf::RingBuf;\n /// and possibly other factors. Using linear search, searching for a random element is expected\n /// to take O(B log<sub>B</sub>n) comparisons, which is generally worse than a BST. In practice,\n /// however, performance is excellent. `BTreeMap` is able to readily outperform `TreeMap` under\n-/// many workloads, and is competetive where it doesn't. BTreeMap also generally *scales* better\n+/// many workloads, and is competitive where it doesn't. BTreeMap also generally *scales* better\n /// than TreeMap, making it more appropriate for large datasets.\n ///\n /// However, `TreeMap` may still be more appropriate to use in many contexts. If elements are very\n@@ -184,6 +185,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     /// Returns a reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -195,7 +199,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get(&self, key: &K) -> Option<&V> {\n+    pub fn get<Sized? Q>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n         let mut cur_node = &self.root;\n         loop {\n             match cur_node.search(key) {\n@@ -213,6 +217,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     /// Returns true if the map contains a value for the specified key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -224,7 +231,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains_key(&self, key: &K) -> bool {\n+    pub fn contains_key<Sized? Q>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord {\n         self.get(key).is_some()\n     }\n \n@@ -236,6 +243,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     /// Returns a mutable reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -251,7 +261,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {\n+    pub fn get_mut<Sized? Q>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n         loop {\n@@ -410,6 +420,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -421,7 +434,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, key: &K) -> Option<V> {\n+    pub fn remove<Sized? Q>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n@@ -790,14 +803,18 @@ impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n     }\n }\n \n-impl<K: Ord, V> Index<K, V> for BTreeMap<K, V> {\n-    fn index(&self, key: &K) -> &V {\n+impl<K: Ord, Sized? Q, V> Index<Q, V> for BTreeMap<K, V>\n+    where Q: BorrowFrom<K> + Ord\n+{\n+    fn index(&self, key: &Q) -> &V {\n         self.get(key).expect(\"no entry found for key\")\n     }\n }\n \n-impl<K: Ord, V> IndexMut<K, V> for BTreeMap<K, V> {\n-    fn index_mut(&mut self, key: &K) -> &mut V {\n+impl<K: Ord, Sized? Q, V> IndexMut<Q, V> for BTreeMap<K, V>\n+    where Q: BorrowFrom<K> + Ord\n+{\n+    fn index_mut(&mut self, key: &Q) -> &mut V {\n         self.get_mut(key).expect(\"no entry found for key\")\n     }\n }"}, {"sha": "b40ff35cca1c62707a69374a76ea79f95d0bdc2c", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -19,6 +19,7 @@ use core::prelude::*;\n \n use core::{slice, mem, ptr};\n use core::iter::Zip;\n+use core::borrow::BorrowFrom;\n \n use vec;\n use vec::Vec;\n@@ -47,7 +48,7 @@ pub struct Node<K, V> {\n     // theory, if we take full control of allocation like HashMap's RawTable does,\n     // and restrict leaves to max size 256 (not unreasonable for a btree node) we can cut\n     // this down to just (ptr, cap: u8, size: u8, is_leaf: bool). With generic\n-    // integer arguments, cap can even move into the the type, reducing this just to\n+    // integer arguments, cap can even move into the type, reducing this just to\n     // (ptr, size, is_leaf). This could also have cache benefits for very small nodes, as keys\n     // could bleed into edges and vals.\n     //\n@@ -73,19 +74,19 @@ impl<K: Ord, V> Node<K, V> {\n     /// Searches for the given key in the node. If it finds an exact match,\n     /// `Found` will be yielded with the matching index. If it doesn't find an exact match,\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n-    pub fn search(&self, key: &K) -> SearchResult {\n+    pub fn search<Sized? Q>(&self, key: &Q) -> SearchResult where Q: BorrowFrom<K> + Ord {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n         // worse for uints.\n         self.search_linear(key)\n     }\n \n-    fn search_linear(&self, key: &K) -> SearchResult {\n+    fn search_linear<Sized? Q>(&self, key: &Q) -> SearchResult where Q: BorrowFrom<K> + Ord {\n         for (i, k) in self.keys.iter().enumerate() {\n-            match k.cmp(key) {\n-                Less => {},\n+            match key.cmp(BorrowFrom::borrow_from(k)) {\n+                Greater => {},\n                 Equal => return Found(i),\n-                Greater => return GoDown(i),\n+                Less => return GoDown(i),\n             }\n         }\n         GoDown(self.len())"}, {"sha": "64ae4f6a508677828aacbdf71b9f83125ca740b0", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -15,6 +15,7 @@ use core::prelude::*;\n \n use btree_map::{BTreeMap, Keys, MoveEntries};\n use std::hash::Hash;\n+use core::borrow::BorrowFrom;\n use core::default::Default;\n use core::{iter, fmt};\n use core::iter::Peekable;\n@@ -167,6 +168,10 @@ impl<T: Ord> BTreeSet<T> {\n \n     /// Returns `true` if the set contains a value.\n     ///\n+    /// The value may be any borrowed form of the set's value type,\n+    /// but the ordering on the borrowed form *must* match the\n+    /// ordering on the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -177,7 +182,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains(&self, value: &T) -> bool {\n+    pub fn contains<Sized? Q>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.contains_key(value)\n     }\n \n@@ -291,6 +296,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n     ///\n+    /// The value may be any borrowed form of the set's value type,\n+    /// but the ordering on the borrowed form *must* match the\n+    /// ordering on the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -303,7 +312,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, value: &T) -> bool {\n+    pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.remove(value).is_some()\n     }\n }"}, {"sha": "132a07af6b67b5d758095e5edf36866387277525", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -89,6 +89,7 @@\n \n use self::Direction::*;\n use alloc::boxed::Box;\n+use core::borrow::{BorrowFrom, BorrowFromMut};\n use core::cmp;\n use core::kinds::Sized;\n use core::mem::size_of;\n@@ -647,6 +648,16 @@ impl<T> SliceAllocPrelude<T> for [T] {\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n+impl<T> BorrowFrom<Vec<T>> for [T] {\n+    fn borrow_from(owned: &Vec<T>) -> &[T] { owned[] }\n+}\n+\n+#[unstable = \"trait is unstable\"]\n+impl<T> BorrowFromMut<Vec<T>> for [T] {\n+    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned[mut] }\n+}\n+\n /// Unsafe operations\n pub mod raw {\n     pub use core::slice::raw::{buf_as_slice, mut_buf_as_slice};"}, {"sha": "aaa7da312f29a2f37420b04eedb9cedff69165af", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -54,7 +54,7 @@\n pub use self::MaybeOwned::*;\n use self::RecompositionState::*;\n use self::DecompositionType::*;\n-\n+use core::borrow::BorrowFrom;\n use core::default::Default;\n use core::fmt;\n use core::cmp;\n@@ -604,6 +604,11 @@ impl<'a> fmt::Show for MaybeOwned<'a> {\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n+impl BorrowFrom<String> for str {\n+    fn borrow_from(owned: &String) -> &str { owned[] }\n+}\n+\n /// Unsafe string operations.\n pub mod raw {\n     pub use core::str::raw::{from_utf8, c_str_to_static_slice, slice_bytes};\n@@ -1258,13 +1263,13 @@ mod tests {\n     #[test]\n     fn test_slice_shift_char() {\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n-        assert_eq!(data.slice_shift_char(), (Some('\u0e1b'), \"\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\"));\n+        assert_eq!(data.slice_shift_char(), Some(('\u0e1b', \"\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\")));\n     }\n \n     #[test]\n     fn test_slice_shift_char_2() {\n         let empty = \"\";\n-        assert_eq!(empty.slice_shift_char(), (None, \"\"));\n+        assert_eq!(empty.slice_shift_char(), None);\n     }\n \n     #[test]"}, {"sha": "e6698542df238b3db38f274fd9cbab0392013b10", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -549,7 +549,7 @@ impl String {\n     ///\n     /// # Warning\n     ///\n-    /// This is a O(n) operation as it requires copying every element in the\n+    /// This is an O(n) operation as it requires copying every element in the\n     /// buffer.\n     ///\n     /// # Panics\n@@ -586,7 +586,7 @@ impl String {\n     ///\n     /// # Warning\n     ///\n-    /// This is a O(n) operation as it requires copying every element in the\n+    /// This is an O(n) operation as it requires copying every element in the\n     /// buffer.\n     ///\n     /// # Panics"}, {"sha": "119268c27eeac9814637396c4481a2af7240c269", "filename": "src/libcollections/tree/map.rs", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Ftree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Ftree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmap.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -11,6 +11,8 @@\n use core::prelude::*;\n \n use alloc::boxed::Box;\n+\n+use core::borrow::BorrowFrom;\n use core::default::Default;\n use core::fmt;\n use core::fmt::Show;\n@@ -188,16 +190,16 @@ impl<K: Ord, V> Default for TreeMap<K,V> {\n     fn default() -> TreeMap<K, V> { TreeMap::new() }\n }\n \n-impl<K: Ord, V> Index<K, V> for TreeMap<K, V> {\n+impl<K: Ord, Sized? Q, V> Index<Q, V> for TreeMap<K, V> where Q: BorrowFrom<K> + Ord {\n     #[inline]\n-    fn index<'a>(&'a self, i: &K) -> &'a V {\n+    fn index<'a>(&'a self, i: &Q) -> &'a V {\n         self.get(i).expect(\"no entry found for key\")\n     }\n }\n \n-impl<K: Ord, V> IndexMut<K, V> for TreeMap<K, V> {\n+impl<K: Ord, Sized? Q, V> IndexMut<Q, V> for TreeMap<K, V> where Q: BorrowFrom<K> + Ord {\n     #[inline]\n-    fn index_mut<'a>(&'a mut self, i: &K) -> &'a mut V {\n+    fn index_mut<'a>(&'a mut self, i: &Q) -> &'a mut V {\n         self.get_mut(i).expect(\"no entry found for key\")\n     }\n }\n@@ -446,6 +448,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n \n     /// Returns a reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -458,12 +463,17 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get(&self, key: &K) -> Option<&V> {\n-        tree_find_with(&self.root, |k2| key.cmp(k2))\n+    pub fn get<Sized? Q>(&self, key: &Q) -> Option<&V>\n+        where Q: BorrowFrom<K> + Ord\n+    {\n+        tree_find_with(&self.root, |k2| key.cmp(BorrowFrom::borrow_from(k2)))\n     }\n \n     /// Returns true if the map contains a value for the specified key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -476,7 +486,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains_key(&self, key: &K) -> bool {\n+    pub fn contains_key<Sized? Q>(&self, key: &Q) -> bool\n+        where Q: BorrowFrom<K> + Ord\n+    {\n         self.get(key).is_some()\n     }\n \n@@ -488,6 +500,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n \n     /// Returns a mutable reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -503,8 +518,10 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {\n-        tree_find_with_mut(&mut self.root, |x| key.cmp(x))\n+    pub fn get_mut<Sized? Q>(&mut self, key: &Q) -> Option<&mut V>\n+        where Q: BorrowFrom<K> + Ord\n+    {\n+        tree_find_with_mut(&mut self.root, |x| key.cmp(BorrowFrom::borrow_from(x)))\n     }\n \n     /// Deprecated: Renamed to `insert`.\n@@ -545,6 +562,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -556,7 +576,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, key: &K) -> Option<V> {\n+    pub fn remove<Sized? Q>(&mut self, key: &Q) -> Option<V>\n+        where Q: BorrowFrom<K> + Ord\n+    {\n         let ret = remove(&mut self.root, key);\n         if ret.is_some() { self.length -= 1 }\n         ret\n@@ -589,6 +611,7 @@ impl<K, V> TreeMap<K, V> {\n     /// assert_eq!((*ua.unwrap()).as_slice(), \"Curl-Rust/0.1\");\n     /// ```\n     #[inline]\n+    #[experimental = \"likely to be renamed, may be removed\"]\n     pub fn find_with(&self, f:|&K| -> Ordering) -> Option<&V> {\n         tree_find_with(&self.root, f)\n     }\n@@ -613,6 +636,7 @@ impl<K, V> TreeMap<K, V> {\n     /// assert_eq!(t.get(&\"User-Agent\"), Some(&new_ua));\n     /// ```\n     #[inline]\n+    #[experimental = \"likely to be renamed, may be removed\"]\n     pub fn find_with_mut<'a>(&'a mut self, f:|&K| -> Ordering) -> Option<&'a mut V> {\n         tree_find_with_mut(&mut self.root, f)\n     }\n@@ -1168,10 +1192,11 @@ fn insert<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n     }\n }\n \n-fn remove<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n-                          key: &K) -> Option<V> {\n+fn remove<K, Sized? Q, V>(node: &mut Option<Box<TreeNode<K, V>>>, key: &Q) -> Option<V>\n+    where K: Ord, Q: BorrowFrom<K> + Ord\n+{\n     fn heir_swap<K: Ord, V>(node: &mut Box<TreeNode<K, V>>,\n-                                 child: &mut Option<Box<TreeNode<K, V>>>) {\n+                            child: &mut Option<Box<TreeNode<K, V>>>) {\n         // *could* be done without recursion, but it won't borrow check\n         for x in child.iter_mut() {\n             if x.right.is_some() {\n@@ -1188,7 +1213,7 @@ fn remove<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n         return None; // bottom of tree\n       }\n       Some(ref mut save) => {\n-        let (ret, rebalance) = match key.cmp(&save.key) {\n+        let (ret, rebalance) = match key.cmp(BorrowFrom::borrow_from(&save.key)) {\n           Less => (remove(&mut save.left, key), true),\n           Greater => (remove(&mut save.right, key), true),\n           Equal => {\n@@ -1918,4 +1943,3 @@ mod bench {\n         bench_iter(b, 100000);\n     }\n }\n-"}, {"sha": "20823a2affc7f5d73fd887a23bf81b9b932089d2", "filename": "src/libcollections/tree/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Ftree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Ftree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmod.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -33,4 +33,4 @@\n //! ```\n \n pub mod map;\n-pub mod set;\n\\ No newline at end of file\n+pub mod set;"}, {"sha": "6988b929df689ef3b1d259ab5c7fe22bda90f574", "filename": "src/libcollections/tree/set.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Ftree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Ftree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fset.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use core::borrow::BorrowFrom;\n use core::default::Default;\n use core::fmt;\n use core::fmt::Show;\n@@ -396,6 +397,10 @@ impl<T: Ord> TreeSet<T> {\n \n     /// Returns `true` if the set contains a value.\n     ///\n+    /// The value may be any borrowed form of the set's value type,\n+    /// but the ordering on the borrowed form *must* match the\n+    /// ordering on the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -407,7 +412,9 @@ impl<T: Ord> TreeSet<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains(&self, value: &T) -> bool {\n+    pub fn contains<Sized? Q>(&self, value: &Q) -> bool\n+        where Q: Ord + BorrowFrom<T>\n+    {\n         self.map.contains_key(value)\n     }\n \n@@ -519,6 +526,10 @@ impl<T: Ord> TreeSet<T> {\n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n     ///\n+    /// The value may be any borrowed form of the set's value type,\n+    /// but the ordering on the borrowed form *must* match the\n+    /// ordering on the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -532,7 +543,11 @@ impl<T: Ord> TreeSet<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value).is_some() }\n+    pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool\n+        where Q: Ord + BorrowFrom<T>\n+    {\n+        self.map.remove(value).is_some()\n+    }\n }\n \n /// A lazy forward iterator over a set."}, {"sha": "672ddab4d87e097c875c5723d44388b58f282ecb", "filename": "src/libcollections/trie/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Ftrie%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Ftrie%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmap.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -1057,7 +1057,7 @@ impl<'a, T> VacantEntry<'a, T> {\n             search_stack.map.root.count = temp;\n             value_ref\n         }\n-        // Otherwise, find the predeccessor of the last stack node, and insert as normal.\n+        // Otherwise, find the predecessor of the last stack node, and insert as normal.\n         else {\n             match *search_stack.get_ref(old_length - 2) {\n                 Internal(box ref mut parent) => {\n@@ -1741,7 +1741,7 @@ mod test {\n                     // Update it to i^3 using the returned mutable reference.\n                     *inserted_val = i * i * i;\n                 },\n-                _ => panic!(\"Non-existant key found.\")\n+                _ => panic!(\"Non-existent key found.\")\n             }\n             assert_eq!(map.get(&i).unwrap(), &(i * i * i));\n         }"}, {"sha": "9dcb182cd267570b259926cb1993bfbdc0f27527", "filename": "src/libcollections/trie/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Ftrie%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcollections%2Ftrie%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmod.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -17,4 +17,4 @@\n //! `TrieMap` is ordered.\n \n pub mod map;\n-pub mod set;\n\\ No newline at end of file\n+pub mod set;"}, {"sha": "60765e82cb476bfdb0f7d9b57b89154c2b57d91f", "filename": "src/libcore/array.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -8,22 +8,36 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n- * Implementations of things like `Eq` for fixed-length arrays\n- * up to a certain length. Eventually we should able to generalize\n- * to all lengths.\n- */\n+//! Implementations of things like `Eq` for fixed-length arrays\n+//! up to a certain length. Eventually we should able to generalize\n+//! to all lengths.\n \n-#![stable]\n #![experimental] // not yet reviewed\n \n-use cmp::*;\n-use option::{Option};\n+use clone::Clone;\n+use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n+use fmt;\n+use kinds::Copy;\n+use option::Option;\n \n // macro for implementing n-ary tuple functions and operations\n macro_rules! array_impls {\n     ($($N:expr)+) => {\n         $(\n+            #[unstable = \"waiting for Clone to stabilize\"]\n+            impl<T:Copy> Clone for [T, ..$N] {\n+                fn clone(&self) -> [T, ..$N] {\n+                    *self\n+                }\n+            }\n+\n+            #[unstable = \"waiting for Show to stabilize\"]\n+            impl<T:fmt::Show> fmt::Show for [T, ..$N] {\n+                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                    fmt::Show::fmt(&self[], f)\n+                }\n+            }\n+\n             #[unstable = \"waiting for PartialEq to stabilize\"]\n             impl<T:PartialEq> PartialEq for [T, ..$N] {\n                 #[inline]"}, {"sha": "f0a14c02382ee9af3f18a347a638875b1d40f583", "filename": "src/libcore/borrow.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -0,0 +1,127 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A module for working with borrowed data.\n+//!\n+//! # The `BorrowFrom` traits\n+//!\n+//! In general, there may be several ways to \"borrow\" a piece of data.  The\n+//! typical ways of borrowing a type `T` are `&T` (a shared borrow) and `&mut T`\n+//! (a mutable borrow). But types like `Vec<T>` provide additional kinds of\n+//! borrows: the borrowed slices `&[T]` and `&mut [T]`.\n+//!\n+//! When writing generic code, it is often desirable to abstract over all ways\n+//! of borrowing data from a given type. That is the role of the `BorrowFrom`\n+//! trait: if `T: BorrowFrom<U>`, then `&T` can be borrowed from `&U`.  A given\n+//! type can be borrowed as multiple different types. In particular, `Vec<T>:\n+//! BorrowFrom<Vec<T>>` and `[T]: BorrowFrom<Vec<T>>`.\n+//!\n+//! # The `ToOwned` trait\n+//!\n+//! Some types make it possible to go from borrowed to owned, usually by\n+//! implementing the `Clone` trait. But `Clone` works only for going from `&T`\n+//! to `T`. The `ToOwned` trait generalizes `Clone` to construct owned data\n+//! from any borrow of a given type.\n+//!\n+//! # The `Cow` (clone-on-write) type\n+//!\n+//! The type `Cow` is a smart pointer providing clone-on-write functionality: it\n+//! can enclose and provide immutable access to borrowed data, and clone the\n+//! data lazily when mutation or ownership is required. The type is designed to\n+//! work with general borrowed data via the `BorrowFrom` trait.\n+//!\n+//! `Cow` implements both `Deref` and `DerefMut`, which means that you can call\n+//! methods directly on the data it encloses. The first time a mutable reference\n+//! is required, the data will be cloned (via `to_owned`) if it is not\n+//! already owned.\n+\n+#![unstable = \"recently added as part of collections reform\"]\n+\n+use clone::Clone;\n+use kinds::Sized;\n+use ops::Deref;\n+use self::Cow::*;\n+\n+/// A trait for borrowing data.\n+pub trait BorrowFrom<Sized? Owned> for Sized? {\n+    /// Immutably borrow from an owned value.\n+    fn borrow_from(owned: &Owned) -> &Self;\n+}\n+\n+/// A trait for mutably borrowing data.\n+pub trait BorrowFromMut<Sized? Owned> for Sized? : BorrowFrom<Owned> {\n+    /// Mutably borrow from an owned value.\n+    fn borrow_from_mut(owned: &mut Owned) -> &mut Self;\n+}\n+\n+impl<Sized? T> BorrowFrom<T> for T {\n+    fn borrow_from(owned: &T) -> &T { owned }\n+}\n+\n+impl<Sized? T> BorrowFromMut<T> for T {\n+    fn borrow_from_mut(owned: &mut T) -> &mut T { owned }\n+}\n+\n+impl BorrowFrom<&'static str> for str {\n+    fn borrow_from<'a>(owned: &'a &'static str) -> &'a str { &**owned }\n+}\n+\n+/// A generalization of Clone to borrowed data.\n+pub trait ToOwned<Owned> for Sized?: BorrowFrom<Owned> {\n+    /// Create owned data from borrowed data, usually by copying.\n+    fn to_owned(&self) -> Owned;\n+}\n+\n+impl<T> ToOwned<T> for T where T: Clone {\n+    fn to_owned(&self) -> T { self.clone() }\n+}\n+\n+/// A clone-on-write smart pointer.\n+pub enum Cow<'a, T, B: 'a> where B: ToOwned<T> {\n+    /// Borrowed data.\n+    Borrowed(&'a B),\n+\n+    /// Owned data.\n+    Owned(T)\n+}\n+\n+impl<'a, T, B> Cow<'a, T, B> where B: ToOwned<T> {\n+    /// Acquire a mutable reference to the owned form of the data.\n+    ///\n+    /// Copies the data if it is not already owned.\n+    pub fn to_mut(&mut self) -> &mut T {\n+        match *self {\n+            Borrowed(borrowed) => {\n+                *self = Owned(borrowed.to_owned());\n+                self.to_mut()\n+            }\n+            Owned(ref mut owned) => owned\n+        }\n+    }\n+\n+    /// Extract the owned data.\n+    ///\n+    /// Copies the data if it is not already owned.\n+    pub fn into_owned(self) -> T {\n+        match self {\n+            Borrowed(borrowed) => borrowed.to_owned(),\n+            Owned(owned) => owned\n+        }\n+    }\n+}\n+\n+impl<'a, T, B> Deref<B> for Cow<'a, T, B> where B: ToOwned<T>  {\n+    fn deref(&self) -> &B {\n+        match *self {\n+            Borrowed(borrowed) => borrowed,\n+            Owned(ref owned) => BorrowFrom::borrow_from(owned)\n+        }\n+    }\n+}"}, {"sha": "d13daf0964a1aeb0ce74132ffa308372243485c5", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -23,6 +23,8 @@ the `clone` method.\n \n #![unstable]\n \n+use kinds::Sized;\n+\n /// A common trait for cloning an object.\n pub trait Clone {\n     /// Returns a copy of the value.\n@@ -40,24 +42,12 @@ pub trait Clone {\n     }\n }\n \n-impl<'a, T> Clone for &'a T {\n+impl<'a, Sized? T> Clone for &'a T {\n     /// Return a shallow copy of the reference.\n     #[inline]\n     fn clone(&self) -> &'a T { *self }\n }\n \n-impl<'a, T> Clone for &'a [T] {\n-    /// Return a shallow copy of the slice.\n-    #[inline]\n-    fn clone(&self) -> &'a [T] { *self }\n-}\n-\n-impl<'a> Clone for &'a str {\n-    /// Return a shallow copy of the slice.\n-    #[inline]\n-    fn clone(&self) -> &'a str { *self }\n-}\n-\n macro_rules! clone_impl(\n     ($t:ty) => {\n         impl Clone for $t {"}, {"sha": "5e3c74477d15c6ba723f283a0f4b1b7defe92601", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -108,6 +108,7 @@ pub mod default;\n pub mod any;\n pub mod atomic;\n pub mod bool;\n+pub mod borrow;\n pub mod cell;\n pub mod char;\n pub mod panicking;"}, {"sha": "937f73a326271491145514785d04afbeda07e00f", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -88,7 +88,7 @@ pub fn align_of_val<T>(_val: &T) -> uint {\n \n /// Create a value initialized to zero.\n ///\n-/// This function is similar to allocating space for a a local variable and\n+/// This function is similar to allocating space for a local variable and\n /// zeroing it out (an unsafe operation).\n ///\n /// Care must be taken when using this function, if the type `T` has a"}, {"sha": "a794897ce6bc8dca662f5e6ecd88e40c6889bc17", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -198,7 +198,7 @@ pub trait Int\n     /// ```\n     fn swap_bytes(self) -> Self;\n \n-    /// Convert a integer from big endian to the target's endianness.\n+    /// Convert an integer from big endian to the target's endianness.\n     ///\n     /// On big endian this is a no-op. On little endian the bytes are swapped.\n     ///\n@@ -220,7 +220,7 @@ pub trait Int\n         if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n     }\n \n-    /// Convert a integer from little endian to the target's endianness.\n+    /// Convert an integer from little endian to the target's endianness.\n     ///\n     /// On little endian this is a no-op. On big endian the bytes are swapped.\n     ///\n@@ -1457,10 +1457,10 @@ macro_rules! from_str_radix_float_impl {\n                 }\n \n                 let (is_positive, src) =  match src.slice_shift_char() {\n-                    (None, _)        => return None,\n-                    (Some('-'), \"\")  => return None,\n-                    (Some('-'), src) => (false, src),\n-                    (Some(_), _)     => (true,  src),\n+                    None             => return None,\n+                    Some(('-', \"\"))  => return None,\n+                    Some(('-', src)) => (false, src),\n+                    Some((_, _))     => (true,  src),\n                 };\n \n                 // The significand to accumulate\n@@ -1563,10 +1563,10 @@ macro_rules! from_str_radix_float_impl {\n                         // Parse the exponent as decimal integer\n                         let src = src[offset..];\n                         let (is_positive, exp) = match src.slice_shift_char() {\n-                            (Some('-'), src) => (false, from_str::<uint>(src)),\n-                            (Some('+'), src) => (true,  from_str::<uint>(src)),\n-                            (Some(_), _)     => (true,  from_str::<uint>(src)),\n-                            (None, _)        => return None,\n+                            Some(('-', src)) => (false, from_str::<uint>(src)),\n+                            Some(('+', src)) => (true,  from_str::<uint>(src)),\n+                            Some((_, _))     => (true,  from_str::<uint>(src)),\n+                            None             => return None,\n                         };\n \n                         match (is_positive, exp) {\n@@ -1606,7 +1606,7 @@ macro_rules! from_str_radix_int_impl {\n                 let is_signed_ty = (0 as $T) > Int::min_value();\n \n                 match src.slice_shift_char() {\n-                    (Some('-'), src) if is_signed_ty => {\n+                    Some(('-', src)) if is_signed_ty => {\n                         // The number is negative\n                         let mut result = 0;\n                         for c in src.chars() {\n@@ -1625,7 +1625,7 @@ macro_rules! from_str_radix_int_impl {\n                         }\n                         Some(result)\n                     },\n-                    (Some(_), _) => {\n+                    Some((_, _)) => {\n                         // The number is signed\n                         let mut result = 0;\n                         for c in src.chars() {\n@@ -1644,7 +1644,7 @@ macro_rules! from_str_radix_int_impl {\n                         }\n                         Some(result)\n                     },\n-                    (None, _) => None,\n+                    None => None,\n                 }\n             }\n         }"}, {"sha": "b4bf5351e597bad17d9ef1aea5960d23d82c51cc", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -638,7 +638,7 @@ shr_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n  * ```\n  */\n #[lang=\"index\"]\n-pub trait Index<Index, Sized? Result> for Sized? {\n+pub trait Index<Sized? Index, Sized? Result> for Sized? {\n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index<'a>(&'a self, index: &Index) -> &'a Result;\n }\n@@ -669,7 +669,7 @@ pub trait Index<Index, Sized? Result> for Sized? {\n  * ```\n  */\n #[lang=\"index_mut\"]\n-pub trait IndexMut<Index, Result> for Sized? {\n+pub trait IndexMut<Sized? Index, Result> for Sized? {\n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Result;\n }"}, {"sha": "24f26b15f27ac97d4ee9c6b1b2c09034c9234902", "filename": "src/libcore/str.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -1811,21 +1811,21 @@ pub trait StrPrelude for Sized? {\n     /// it. This does not allocate a new string; instead, it returns a\n     /// slice that point one character beyond the character that was\n     /// shifted. If the string does not contain any characters,\n-    /// a tuple of None and an empty string is returned instead.\n+    /// None is returned instead.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let (c, s1) = s.slice_shift_char();\n-    /// assert_eq!(c, Some('L'));\n+    /// let (c, s1) = s.slice_shift_char().unwrap();\n+    /// assert_eq!(c, 'L');\n     /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n     ///\n-    /// let (c, s2) = s1.slice_shift_char();\n-    /// assert_eq!(c, Some('\u00f6'));\n+    /// let (c, s2) = s1.slice_shift_char().unwrap();\n+    /// assert_eq!(c, '\u00f6');\n     /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n     /// ```\n-    fn slice_shift_char<'a>(&'a self) -> (Option<char>, &'a str);\n+    fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;\n \n     /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n     ///\n@@ -2197,13 +2197,13 @@ impl StrPrelude for str {\n     }\n \n     #[inline]\n-    fn slice_shift_char(&self) -> (Option<char>, &str) {\n+    fn slice_shift_char(&self) -> Option<(char, &str)> {\n         if self.is_empty() {\n-            return (None, self);\n+            None\n         } else {\n             let CharRange {ch, next} = self.char_range_at(0u);\n             let next_s = unsafe { raw::slice_bytes(self, next, self.len()) };\n-            return (Some(ch), next_s);\n+            Some((ch, next_s))\n         }\n     }\n "}, {"sha": "447869436762161c11be24b1e0d2fe1fc00b627f", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -60,10 +60,10 @@ pub fn render_to<W:Writer>(output: &mut W) {\n }\n \n impl<'a> dot::Labeller<'a, Nd, Ed> for Edges {\n-    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(\"example1\") }\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(\"example1\").unwrap() }\n \n     fn node_id(&'a self, n: &Nd) -> dot::Id<'a> {\n-        dot::Id::new(format!(\"N{}\", *n))\n+        dot::Id::new(format!(\"N{}\", *n)).unwrap()\n     }\n }\n \n@@ -163,9 +163,9 @@ pub fn render_to<W:Writer>(output: &mut W) {\n }\n \n impl<'a> dot::Labeller<'a, Nd, Ed<'a>> for Graph {\n-    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(\"example2\") }\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(\"example2\").unwrap() }\n     fn node_id(&'a self, n: &Nd) -> dot::Id<'a> {\n-        dot::Id::new(format!(\"N{}\", n))\n+        dot::Id::new(format!(\"N{}\", n)).unwrap()\n     }\n     fn node_label<'a>(&'a self, n: &Nd) -> dot::LabelText<'a> {\n         dot::LabelStr(str::Slice(self.nodes[*n].as_slice()))\n@@ -219,9 +219,9 @@ pub fn render_to<W:Writer>(output: &mut W) {\n }\n \n impl<'a> dot::Labeller<'a, Nd<'a>, Ed<'a>> for Graph {\n-    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(\"example3\") }\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(\"example3\").unwrap() }\n     fn node_id(&'a self, n: &Nd<'a>) -> dot::Id<'a> {\n-        dot::Id::new(format!(\"N{:u}\", n.val0()))\n+        dot::Id::new(format!(\"N{:u}\", n.val0())).unwrap()\n     }\n     fn node_label<'a>(&'a self, n: &Nd<'a>) -> dot::LabelText<'a> {\n         let &(i, _) = n;\n@@ -354,14 +354,22 @@ impl<'a> Id<'a> {\n     /// defined by the DOT language.  This function may change in the\n     /// future to accept a broader subset, or the entirety, of DOT's\n     /// `ID` format.)\n-    pub fn new<Name:str::IntoMaybeOwned<'a>>(name: Name) -> Id<'a> {\n+    ///\n+    /// Passing an invalid string (containing spaces, brackets,\n+    /// quotes, ...) will return an empty `Err` value.\n+    pub fn new<Name:str::IntoMaybeOwned<'a>>(name: Name) -> Result<Id<'a>, ()> {\n         let name = name.into_maybe_owned();\n         {\n             let mut chars = name.as_slice().chars();\n-            assert!(is_letter_or_underscore(chars.next().unwrap()));\n-            assert!(chars.all(is_constituent));\n+            match chars.next() {\n+                Some(c) if is_letter_or_underscore(c) => { ; },\n+                _ => return Err(())\n+            }\n+            if !chars.all(is_constituent) {\n+                return Err(());\n+            }\n         }\n-        return Id{ name: name };\n+        return Ok(Id{ name: name });\n \n         fn is_letter_or_underscore(c: char) -> bool {\n             in_range('a', c, 'z') || in_range('A', c, 'Z') || c == '_'\n@@ -627,12 +635,12 @@ mod tests {\n     }\n \n     fn id_name<'a>(n: &Node) -> Id<'a> {\n-        Id::new(format!(\"N{:u}\", *n))\n+        Id::new(format!(\"N{:u}\", *n)).unwrap()\n     }\n \n     impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraph {\n         fn graph_id(&'a self) -> Id<'a> {\n-            Id::new(self.name.as_slice())\n+            Id::new(self.name.as_slice()).unwrap()\n         }\n         fn node_id(&'a self, n: &Node) -> Id<'a> {\n             id_name(n)\n@@ -825,4 +833,22 @@ r#\"digraph syntax_tree {\n }\n \"#);\n     }\n+\n+    #[test]\n+    fn simple_id_construction() {\n+        let id1 = Id::new(\"hello\");\n+        match id1 {\n+            Ok(_) => {;},\n+            Err(_) => panic!(\"'hello' is not a valid value for id anymore\")\n+        }\n+    }\n+\n+    #[test]\n+    fn badly_formatted_id() {\n+        let id2 = Id::new(\"Weird { struct : ure } !!!\");\n+        match id2 {\n+            Ok(_) => panic!(\"graphviz id suddenly allows spaces, brackets and stuff\"),\n+            Err(_) => {;}\n+        }\n+    }\n }"}, {"sha": "2e60ce31d5e5e7bc0b2ca24d0e2440ac1b5e54da", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -137,7 +137,7 @@\n //! includes 'foo'.\n //! * `info/f.o` turns on all info logging where the log message includes 'foo',\n //! 'f1o', 'fao', etc.\n-//! * `hello=debug/foo*foo` turns on debug logging for 'hello' where the the log\n+//! * `hello=debug/foo*foo` turns on debug logging for 'hello' where the log\n //! message includes 'foofoo' or 'fofoo' or 'fooooooofoo', etc.\n //! * `error,hello=warn/[0-9] scopes` turn on global error logging and also warn for\n //!  hello. In both cases the log message must include a single digit number"}, {"sha": "e70491a785c370b27ecb643153559eb1a3ece86b", "filename": "src/libregex/re.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -561,7 +561,7 @@ pub struct NoExpand<'t>(pub &'t str);\n /// Replacer describes types that can be used to replace matches in a string.\n pub trait Replacer {\n     /// Returns a possibly owned string that is used to replace the match\n-    /// corresponding the the `caps` capture group.\n+    /// corresponding to the `caps` capture group.\n     ///\n     /// The `'a` lifetime refers to the lifetime of a borrowed string when\n     /// a new owned string isn't needed (e.g., for `NoExpand`).\n@@ -726,7 +726,7 @@ impl<'t> Captures<'t> {\n         match self.named {\n             None => \"\",\n             Some(ref h) => {\n-                match h.find_equiv(name) {\n+                match h.get(name) {\n                     None => \"\",\n                     Some(i) => self.at(*i),\n                 }"}, {"sha": "766715ff25167d558e61916262fd9bf549ec54a4", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -728,7 +728,9 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n     if sess.target.target.options.morestack {\n         ab.add_native_library(\"morestack\").unwrap();\n     }\n-    ab.add_native_library(\"compiler-rt\").unwrap();\n+    if !sess.target.target.options.no_compiler_rt {\n+        ab.add_native_library(\"compiler-rt\").unwrap();\n+    }\n \n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n     let mut all_native_libs = vec![];"}, {"sha": "b5dafdb18076680efdd3e313b32e957555f59cb4", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -143,5 +143,6 @@ register_diagnostics!(\n     E0164,\n     E0165,\n     E0166,\n-    E0167\n+    E0167,\n+    E0168\n )"}, {"sha": "df014eb1206aa59e64ce2d7519a4576483ec3ae0", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -623,6 +623,7 @@ impl LintPass for UnusedAttributes {\n             \"link\",\n             \"link_name\",\n             \"link_section\",\n+            \"linkage\",\n             \"no_builtins\",\n             \"no_mangle\",\n             \"no_split_stack\","}, {"sha": "aa6a021a210ef60580a7bac46a41c5c902cbf910", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -165,7 +165,7 @@ impl LintStore {\n     }\n \n     fn register_renamed(&mut self, old_name: &str, new_name: &str) {\n-        let target = match self.by_name.find_equiv(new_name) {\n+        let target = match self.by_name.get(new_name) {\n             Some(&Id(lint_id)) => lint_id.clone(),\n             _ => panic!(\"invalid lint renaming of {} to {}\", old_name, new_name)\n         };\n@@ -259,7 +259,7 @@ impl LintStore {\n     fn find_lint(&self, lint_name: &str, sess: &Session, span: Option<Span>)\n                  -> Option<LintId>\n     {\n-        match self.by_name.find_equiv(lint_name) {\n+        match self.by_name.get(lint_name) {\n             Some(&Id(lint_id)) => Some(lint_id),\n             Some(&Renamed(ref new_name, lint_id)) => {\n                 let warning = format!(\"lint {} has been renamed to {}\",\n@@ -282,7 +282,7 @@ impl LintStore {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.ref0().clone()))\n                                                  .collect::<FnvHashMap<&'static str,\n                                                                        Vec<LintId>>>()\n-                                                 .find_equiv(lint_name.as_slice()) {\n+                                                 .get(lint_name.as_slice()) {\n                         Some(v) => {\n                             v.iter()\n                              .map(|lint_id: &LintId|\n@@ -489,7 +489,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                     match self.lints.find_lint(lint_name.get(), &self.tcx.sess, Some(span)) {\n                         Some(lint_id) => vec![(lint_id, level, span)],\n                         None => {\n-                            match self.lints.lint_groups.find_equiv(lint_name.get()) {\n+                            match self.lints.lint_groups.get(lint_name.get()) {\n                                 Some(&(ref v, _)) => v.iter()\n                                                       .map(|lint_id: &LintId|\n                                                            (*lint_id, level, span))"}, {"sha": "d9e7437216e80c045fe3bfccd7e59a43030e137b", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -242,6 +242,8 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                                     cstore::NativeFramework\n                                 } else if k.equiv(&(\"framework\")) {\n                                     cstore::NativeFramework\n+                                } else if k.equiv(&(\"dylib\")) {\n+                                    cstore::NativeUnknown\n                                 } else {\n                                     e.sess.span_err(m.span,\n                                         format!(\"unknown kind: `{}`\",\n@@ -321,7 +323,7 @@ fn existing_match(e: &Env, name: &str,\n         // `source` stores paths which are normalized which may be different\n         // from the strings on the command line.\n         let source = e.sess.cstore.get_used_crate_source(cnum).unwrap();\n-        match e.sess.opts.externs.find_equiv(name) {\n+        match e.sess.opts.externs.get(name) {\n             Some(locs) => {\n                 let found = locs.iter().any(|l| {\n                     let l = fs::realpath(&Path::new(l.as_slice())).ok();"}, {"sha": "e0110a81c179f0d6e3fe03086151634b9f01fe60", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -298,7 +298,7 @@ fn item_path(item_doc: rbml::Doc) -> Vec<ast_map::PathElem> {\n fn item_name(intr: &IdentInterner, item: rbml::Doc) -> ast::Name {\n     let name = reader::get_doc(item, tag_paths_data_name);\n     let string = name.as_str_slice();\n-    match intr.find_equiv(string) {\n+    match intr.find(string) {\n         None => token::intern(string),\n         Some(val) => val,\n     }\n@@ -1449,4 +1449,3 @@ pub fn is_associated_type(cdata: Cmd, id: ast::NodeId) -> bool {\n         Some(item) => item_sort(item) == 't',\n     }\n }\n-"}, {"sha": "f7d666e48150d97bc39bf5f5c6e5a6fba2a5f909", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -54,7 +54,7 @@ impl<'a> FileSearch<'a> {\n         debug!(\"filesearch: searching lib path\");\n         let tlib_path = make_target_lib_path(self.sysroot,\n                                     self.triple);\n-        if !visited_dirs.contains_equiv(tlib_path.as_vec()) {\n+        if !visited_dirs.contains(tlib_path.as_vec()) {\n             match f(&tlib_path) {\n                 FileMatches => found = true,\n                 FileDoesntMatch => ()\n@@ -69,9 +69,9 @@ impl<'a> FileSearch<'a> {\n                 let tlib_path = make_rustpkg_lib_path(\n                     self.sysroot, path, self.triple);\n                 debug!(\"is {} in visited_dirs? {}\", tlib_path.display(),\n-                        visited_dirs.contains_equiv(&tlib_path.as_vec().to_vec()));\n+                        visited_dirs.contains(&tlib_path.as_vec().to_vec()));\n \n-                if !visited_dirs.contains_equiv(tlib_path.as_vec()) {\n+                if !visited_dirs.contains(tlib_path.as_vec()) {\n                     visited_dirs.insert(tlib_path.as_vec().to_vec());\n                     // Don't keep searching the RUST_PATH if one match turns up --\n                     // if we did, we'd get a \"multiple matching crates\" error"}, {"sha": "30bef248b4738c6a8afe52380d1c55f25bdcb45e", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -596,7 +596,7 @@ impl<'a> Context<'a> {\n     }\n \n     fn find_commandline_library(&mut self) -> Option<Library> {\n-        let locs = match self.sess.opts.externs.find_equiv(self.crate_name) {\n+        let locs = match self.sess.opts.externs.get(self.crate_name) {\n             Some(s) => s,\n             None => return None,\n         };"}, {"sha": "78b3a1179ca59283f99e9a407b0575a874b629cb", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -50,10 +50,10 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n }\n \n impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n-    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(self.name.as_slice()) }\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(self.name.as_slice()).unwrap() }\n \n     fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n-        dot::Id::new(format!(\"N{:u}\", i.node_id()))\n+        dot::Id::new(format!(\"N{:u}\", i.node_id())).unwrap()\n     }\n \n     fn node_label(&'a self, &(i, n): &Node<'a>) -> dot::LabelText<'a> {"}, {"sha": "ffc8a83e42edad9fd8704502e2df1488f6daf8c1", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -132,7 +132,7 @@ impl<'a, 'v> Visitor<'v> for LanguageItemCollector<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         match extract(item.attrs.as_slice()) {\n             Some(value) => {\n-                let item_index = self.item_refs.find_equiv(&value).map(|x| *x);\n+                let item_index = self.item_refs.get(value.get()).map(|x| *x);\n \n                 match item_index {\n                     Some(item_index) => {"}, {"sha": "4d0474b68da85914c2a703c93fdeae48de7b4bf9", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -79,14 +79,17 @@ impl<'v> Visitor<'v> for Annotator {\n         }\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                b: &'v Block, s: Span, _: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, _: &'v FnDecl,\n+                _: &'v Block, _: Span, _: NodeId) {\n         match fk {\n             FkMethod(_, _, meth) => {\n-                self.annotate(meth.id, &meth.attrs, |v| visit::walk_fn(v, fk, fd, b, s));\n+                // Methods are not already annotated, so we annotate it\n+                self.annotate(meth.id, &meth.attrs, |_| {});\n             }\n-            _ => visit::walk_fn(self, fk, fd, b, s)\n+            _ => {}\n         }\n+        // Items defined in a function body have no reason to have\n+        // a stability attribute, so we don't recurse.\n     }\n \n     fn visit_trait_item(&mut self, t: &TraitItem) {"}, {"sha": "bb0db874b675f9f27258282c321ade7ebf4fd8a3", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -353,7 +353,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // matches this obligation, then we can assume that the\n         // obligation is satisfied for now (still all other conditions\n         // must be met of course). One obvious case this comes up is\n-        // marker traits like `Send`. Think of a a linked list:\n+        // marker traits like `Send`. Think of a linked list:\n         //\n         //    struct List<T> { data: T, next: Option<Box<List<T>>> {\n         //"}, {"sha": "c05e61023ed67de6f6d0c1c5d288110a1b6dd1af", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -36,7 +36,7 @@ use driver::config::{NoDebugInfo, FullDebugInfo};\n use driver::driver::{CrateAnalysis, CrateTranslation, ModuleTranslation};\n use driver::session::Session;\n use lint;\n-use llvm::{BasicBlockRef, ValueRef, Vector, get_param};\n+use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n use llvm;\n use metadata::{csearch, encoder, loader};\n use middle::astencode;\n@@ -216,7 +216,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n                      ty: Type,\n                      output: ty::t)\n                      -> ValueRef {\n-    match externs.find_equiv(name) {\n+    match externs.get(name) {\n         Some(n) => return *n,\n         None => {}\n     }\n@@ -226,7 +226,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n }\n \n fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::DefId) -> ValueRef {\n-    match ccx.externs().borrow().find_equiv(name) {\n+    match ccx.externs().borrow().get(name) {\n         Some(n) => return *n,\n         None => ()\n     }\n@@ -2137,6 +2137,32 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TransItemVisitor<'a, 'tcx> {\n     }\n }\n \n+pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n+    // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n+    // applicable to variable declarations and may not really make sense for\n+    // Rust code in the first place but whitelist them anyway and trust that\n+    // the user knows what s/he's doing. Who knows, unanticipated use cases\n+    // may pop up in the future.\n+    //\n+    // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n+    // and don't have to be, LLVM treats them as no-ops.\n+    match name {\n+        \"appending\" => Some(llvm::AppendingLinkage),\n+        \"available_externally\" => Some(llvm::AvailableExternallyLinkage),\n+        \"common\" => Some(llvm::CommonLinkage),\n+        \"extern_weak\" => Some(llvm::ExternalWeakLinkage),\n+        \"external\" => Some(llvm::ExternalLinkage),\n+        \"internal\" => Some(llvm::InternalLinkage),\n+        \"linkonce\" => Some(llvm::LinkOnceAnyLinkage),\n+        \"linkonce_odr\" => Some(llvm::LinkOnceODRLinkage),\n+        \"private\" => Some(llvm::PrivateLinkage),\n+        \"weak\" => Some(llvm::WeakAnyLinkage),\n+        \"weak_odr\" => Some(llvm::WeakODRLinkage),\n+        _ => None,\n+    }\n+}\n+\n+\n /// Enum describing the origin of an LLVM `Value`, for linkage purposes.\n pub enum ValueOrigin {\n     /// The LLVM `Value` is in this context because the corresponding item was\n@@ -2174,6 +2200,23 @@ pub fn update_linkage(ccx: &CrateContext,\n         OriginalTranslation => {},\n     }\n \n+    match id {\n+        Some(id) => {\n+            let item = ccx.tcx().map.get(id);\n+            if let ast_map::NodeItem(i) = item {\n+                if let Some(name) =  attr::first_attr_value_str_by_name(i.attrs[], \"linkage\") {\n+                    if let Some(linkage) = llvm_linkage_by_name(name.get()) {\n+                        llvm::SetLinkage(llval, linkage);\n+                    } else {\n+                        ccx.sess().span_fatal(i.span, \"invalid linkage specified\");\n+                    }\n+                    return;\n+                }\n+            }\n+        }\n+        _ => {}\n+    }\n+\n     match id {\n         Some(id) if ccx.reachable().contains(&id) => {\n             llvm::SetLinkage(llval, llvm::ExternalLinkage);\n@@ -2983,7 +3026,7 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n \n                 let name = CString::new(llvm::LLVMGetValueName(val), false);\n                 if !declared.contains(&name) &&\n-                   !reachable.contains_equiv(name.as_str().unwrap()) {\n+                   !reachable.contains(name.as_str().unwrap()) {\n                     llvm::SetLinkage(val, llvm::InternalLinkage);\n                 }\n             }"}, {"sha": "de8e80b02757b6b21bc217c3560271aabca9e410", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -1677,7 +1677,7 @@ fn declare_local(bcx: Block,\n }\n \n fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n-    match debug_context(cx).created_files.borrow().find_equiv(full_path) {\n+    match debug_context(cx).created_files.borrow().get(full_path) {\n         Some(file_metadata) => return *file_metadata,\n         None => ()\n     }"}, {"sha": "940319d050beafa0901422f1830f3c639f3f4636", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -10,10 +10,10 @@\n \n \n use back::{link};\n-use llvm::{ValueRef, CallConv, Linkage, get_param};\n+use llvm::{ValueRef, CallConv, get_param};\n use llvm;\n use middle::weak_lang_items;\n-use middle::trans::base::push_ctxt;\n+use middle::trans::base::{llvm_linkage_by_name, push_ctxt};\n use middle::trans::base;\n use middle::trans::build::*;\n use middle::trans::cabi;\n@@ -101,31 +101,6 @@ pub fn llvm_calling_convention(ccx: &CrateContext,\n     }\n }\n \n-pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n-    // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n-    // applicable to variable declarations and may not really make sense for\n-    // Rust code in the first place but whitelist them anyway and trust that\n-    // the user knows what s/he's doing. Who knows, unanticipated use cases\n-    // may pop up in the future.\n-    //\n-    // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n-    // and don't have to be, LLVM treats them as no-ops.\n-    match name {\n-        \"appending\" => Some(llvm::AppendingLinkage),\n-        \"available_externally\" => Some(llvm::AvailableExternallyLinkage),\n-        \"common\" => Some(llvm::CommonLinkage),\n-        \"extern_weak\" => Some(llvm::ExternalWeakLinkage),\n-        \"external\" => Some(llvm::ExternalLinkage),\n-        \"internal\" => Some(llvm::InternalLinkage),\n-        \"linkonce\" => Some(llvm::LinkOnceAnyLinkage),\n-        \"linkonce_odr\" => Some(llvm::LinkOnceODRLinkage),\n-        \"private\" => Some(llvm::PrivateLinkage),\n-        \"weak\" => Some(llvm::WeakAnyLinkage),\n-        \"weak_odr\" => Some(llvm::WeakODRLinkage),\n-        _ => None,\n-    }\n-}\n-\n pub fn register_static(ccx: &CrateContext,\n                        foreign_item: &ast::ForeignItem) -> ValueRef {\n     let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);"}, {"sha": "69861290b8d0d16f47d8d7d5b7e061b27f6533f2", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -336,7 +336,7 @@ impl TypeNames {\n     }\n \n     pub fn find_type(&self, s: &str) -> Option<Type> {\n-        self.named_types.borrow().find_equiv(s).map(|x| Type::from_ref(*x))\n+        self.named_types.borrow().get(s).map(|x| Type::from_ref(*x))\n     }\n \n     pub fn type_to_string(&self, ty: Type) -> String {"}, {"sha": "a79edf28b3617583204be72b0aab22993f1fcdb1", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -297,22 +297,38 @@ pub fn check_pat_struct(pcx: &pat_ctxt, pat: &ast::Pat,\n     let tcx = pcx.fcx.ccx.tcx;\n \n     let def = tcx.def_map.borrow()[pat.id].clone();\n-    let def_type = ty::lookup_item_type(tcx, def.def_id());\n-    let (enum_def_id, variant_def_id) = match ty::get(def_type.ty).sty {\n-        ty::ty_struct(struct_def_id, _) =>\n-            (struct_def_id, struct_def_id),\n-        ty::ty_enum(enum_def_id, _) if def == def::DefVariant(enum_def_id, def.def_id(), true) =>\n-            (enum_def_id, def.def_id()),\n-        _ => {\n+    let (enum_def_id, variant_def_id) = match def {\n+        def::DefTrait(_) => {\n             let name = pprust::path_to_string(path);\n-            span_err!(tcx.sess, pat.span, E0163,\n-                \"`{}` does not name a struct or a struct variant\", name);\n+            span_err!(tcx.sess, pat.span, E0168,\n+                \"use of trait `{}` in a struct pattern\", name);\n             fcx.write_error(pat.id);\n \n             for field in fields.iter() {\n                 check_pat(pcx, &*field.node.pat, ty::mk_err());\n             }\n             return;\n+        },\n+        _ => {\n+            let def_type = ty::lookup_item_type(tcx, def.def_id());\n+            match ty::get(def_type.ty).sty {\n+                ty::ty_struct(struct_def_id, _) =>\n+                    (struct_def_id, struct_def_id),\n+                ty::ty_enum(enum_def_id, _)\n+                    if def == def::DefVariant(enum_def_id, def.def_id(), true) =>\n+                    (enum_def_id, def.def_id()),\n+                _ => {\n+                    let name = pprust::path_to_string(path);\n+                    span_err!(tcx.sess, pat.span, E0163,\n+                        \"`{}` does not name a struct or a struct variant\", name);\n+                    fcx.write_error(pat.id);\n+\n+                    for field in fields.iter() {\n+                        check_pat(pcx, &*field.node.pat, ty::mk_err());\n+                    }\n+                    return;\n+                }\n+            }\n         }\n     };\n "}, {"sha": "8e9ac7095dae1bde2d1a85089b11a6719638d20a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -2122,7 +2122,7 @@ impl<'a> fmt::Show for Sidebar<'a> {\n \n         fn block(w: &mut fmt::Formatter, short: &str, longty: &str,\n                  cur: &clean::Item, cx: &Context) -> fmt::Result {\n-            let items = match cx.sidebar.find_equiv(short) {\n+            let items = match cx.sidebar.get(short) {\n                 Some(items) => items.as_slice(),\n                 None => return Ok(())\n             };"}, {"sha": "03e0452a4158d5a02d601cc3910ee7ebbd0a3d1c", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -901,7 +901,7 @@ impl Json {\n     /// Otherwise, returns None.\n     pub fn find<'a>(&'a self, key: &str) -> Option<&'a Json>{\n         match self {\n-            &Object(ref map) => map.find_with(|s| key.cmp(s.as_slice())),\n+            &Object(ref map) => map.get(key),\n             _ => None\n         }\n     }\n@@ -926,7 +926,7 @@ impl Json {\n     pub fn search<'a>(&'a self, key: &str) -> Option<&'a Json> {\n         match self {\n             &Object(ref map) => {\n-                match map.find_with(|s| key.cmp(s.as_slice())) {\n+                match map.get(key) {\n                     Some(json_value) => Some(json_value),\n                     None => {\n                         for (_, v) in map.iter() {"}, {"sha": "69375e8d4f84e131d5044185422b130c96589472", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 66, "deletions": 84, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -14,6 +14,7 @@ pub use self::Entry::*;\n use self::SearchResult::*;\n use self::VacantEntryState::*;\n \n+use borrow::BorrowFrom;\n use clone::Clone;\n use cmp::{max, Eq, Equiv, PartialEq};\n use default::Default;\n@@ -142,7 +143,7 @@ impl DefaultResizePolicy {\n // about the size of rust executables.\n //\n // Annotate exceedingly likely branches in `table::make_hash`\n-// and `search_hashed_generic` to reduce instruction cache pressure\n+// and `search_hashed` to reduce instruction cache pressure\n // and mispredictions once it becomes possible (blocked on issue #11092).\n //\n // Shrinking the table could simply reallocate in place after moving buckets\n@@ -286,10 +287,10 @@ pub struct HashMap<K, V, H = RandomSipHasher> {\n }\n \n /// Search for a pre-hashed key.\n-fn search_hashed_generic<K, V, M: Deref<RawTable<K, V>>>(table: M,\n-                                                         hash: &SafeHash,\n-                                                         is_match: |&K| -> bool)\n-                                                         -> SearchResult<K, V, M> {\n+fn search_hashed<K, V, M: Deref<RawTable<K, V>>>(table: M,\n+                                                 hash: &SafeHash,\n+                                                 is_match: |&K| -> bool)\n+                                                 -> SearchResult<K, V, M> {\n     let size = table.size();\n     let mut probe = Bucket::new(table, hash);\n     let ib = probe.index();\n@@ -325,11 +326,6 @@ fn search_hashed_generic<K, V, M: Deref<RawTable<K, V>>>(table: M,\n     TableRef(probe.into_table())\n }\n \n-fn search_hashed<K: Eq, V, M: Deref<RawTable<K, V>>>(table: M, hash: &SafeHash, k: &K)\n-                                                     -> SearchResult<K, V, M> {\n-    search_hashed_generic(table, hash, |k_| *k == *k_)\n-}\n-\n fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n     let (empty, retkey, retval) = starting_bucket.take();\n     let mut gap = match empty.gap_peek() {\n@@ -432,26 +428,32 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     fn search_equiv<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a self, q: &Q)\n                     -> Option<FullBucketImm<'a, K, V>> {\n         let hash = self.make_hash(q);\n-        search_hashed_generic(&self.table, &hash, |k| q.equiv(k)).into_option()\n+        search_hashed(&self.table, &hash, |k| q.equiv(k)).into_option()\n     }\n \n     fn search_equiv_mut<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a mut self, q: &Q)\n                     -> Option<FullBucketMut<'a, K, V>> {\n         let hash = self.make_hash(q);\n-        search_hashed_generic(&mut self.table, &hash, |k| q.equiv(k)).into_option()\n+        search_hashed(&mut self.table, &hash, |k| q.equiv(k)).into_option()\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n     /// If you already have the hash for the key lying around, use\n     /// search_hashed.\n-    fn search<'a>(&'a self, k: &K) -> Option<FullBucketImm<'a, K, V>> {\n-        let hash = self.make_hash(k);\n-        search_hashed(&self.table, &hash, k).into_option()\n+    fn search<'a, Sized? Q>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n+        where Q: BorrowFrom<K> + Eq + Hash<S>\n+    {\n+        let hash = self.make_hash(q);\n+        search_hashed(&self.table, &hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+            .into_option()\n     }\n \n-    fn search_mut<'a>(&'a mut self, k: &K) -> Option<FullBucketMut<'a, K, V>> {\n-        let hash = self.make_hash(k);\n-        search_hashed(&mut self.table, &hash, k).into_option()\n+    fn search_mut<'a, Sized? Q>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n+        where Q: BorrowFrom<K> + Eq + Hash<S>\n+    {\n+        let hash = self.make_hash(q);\n+        search_hashed(&mut self.table, &hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+            .into_option()\n     }\n \n     // The caller should ensure that invariants by Robin Hood Hashing hold.\n@@ -748,18 +750,14 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Return true if the map contains a value for the specified key,\n-    /// using equivalence.\n-    ///\n-    /// See [pop_equiv](#method.pop_equiv) for an extended example.\n+    /// Deprecated: use `contains_key` and `BorrowFrom` instead.\n+    #[deprecated = \"use contains_key and BorrowFrom instead\"]\n     pub fn contains_key_equiv<Sized? Q: Hash<S> + Equiv<K>>(&self, key: &Q) -> bool {\n         self.search_equiv(key).is_some()\n     }\n \n-    /// Return the value corresponding to the key in the map, using\n-    /// equivalence.\n-    ///\n-    /// See [pop_equiv](#method.pop_equiv) for an extended example.\n+    /// Deprecated: use `get` and `BorrowFrom` instead.\n+    #[deprecated = \"use get and BorrowFrom instead\"]\n     pub fn find_equiv<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n         match self.search_equiv(k) {\n             None      => None,\n@@ -770,52 +768,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Remove an equivalent key from the map, returning the value at the\n-    /// key if the key was previously in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// This is a slightly silly example where we define the number's\n-    /// parity as the equivalence class. It is important that the\n-    /// values hash the same, which is why we implement `Hash`.\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::hash::Hash;\n-    /// use std::hash::sip::SipState;\n-    ///\n-    /// #[deriving(Eq, PartialEq)]\n-    /// struct EvenOrOdd {\n-    ///     num: uint\n-    /// };\n-    ///\n-    /// impl Hash for EvenOrOdd {\n-    ///     fn hash(&self, state: &mut SipState) {\n-    ///         let parity = self.num % 2;\n-    ///         parity.hash(state);\n-    ///     }\n-    /// }\n-    ///\n-    /// impl Equiv<EvenOrOdd> for EvenOrOdd {\n-    ///     fn equiv(&self, other: &EvenOrOdd) -> bool {\n-    ///         self.num % 2 == other.num % 2\n-    ///     }\n-    /// }\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(EvenOrOdd { num: 3 }, \"foo\");\n-    ///\n-    /// assert!(map.contains_key_equiv(&EvenOrOdd { num: 1 }));\n-    /// assert!(!map.contains_key_equiv(&EvenOrOdd { num: 4 }));\n-    ///\n-    /// assert_eq!(map.find_equiv(&EvenOrOdd { num: 5 }), Some(&\"foo\"));\n-    /// assert_eq!(map.find_equiv(&EvenOrOdd { num: 2 }), None);\n-    ///\n-    /// assert_eq!(map.pop_equiv(&EvenOrOdd { num: 1 }), Some(\"foo\"));\n-    /// assert_eq!(map.pop_equiv(&EvenOrOdd { num: 2 }), None);\n-    ///\n-    /// ```\n-    #[experimental]\n+    /// Deprecated: use `remove` and `BorrowFrom` instead.\n+    #[deprecated = \"use remove and BorrowFrom instead\"]\n     pub fn pop_equiv<Sized? Q:Hash<S> + Equiv<K>>(&mut self, k: &Q) -> Option<V> {\n         if self.table.size() == 0 {\n             return None\n@@ -1036,6 +990,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n     /// Returns a reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -1047,7 +1005,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get(&self, k: &K) -> Option<&V> {\n+    pub fn get<Sized? Q>(&self, k: &Q) -> Option<&V>\n+        where Q: Hash<S> + Eq + BorrowFrom<K>\n+    {\n         self.search(k).map(|bucket| {\n             let (_, v) = bucket.into_refs();\n             v\n@@ -1056,6 +1016,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n     /// Returns true if the map contains a value for the specified key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -1067,7 +1031,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains_key(&self, k: &K) -> bool {\n+    pub fn contains_key<Sized? Q>(&self, k: &Q) -> bool\n+        where Q: Hash<S> + Eq + BorrowFrom<K>\n+    {\n         self.search(k).is_some()\n     }\n \n@@ -1079,6 +1045,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n     /// Returns a mutable reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -1093,7 +1063,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get_mut(&mut self, k: &K) -> Option<&mut V> {\n+    pub fn get_mut<Sized? Q>(&mut self, k: &Q) -> Option<&mut V>\n+        where Q: Hash<S> + Eq + BorrowFrom<K>\n+    {\n         match self.search_mut(k) {\n             Some(bucket) => {\n                 let (_, v) = bucket.into_mut_refs();\n@@ -1147,6 +1119,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -1158,7 +1134,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, k: &K) -> Option<V> {\n+    pub fn remove<Sized? Q>(&mut self, k: &Q) -> Option<V>\n+        where Q: Hash<S> + Eq + BorrowFrom<K>\n+    {\n         if self.table.size() == 0 {\n             return None\n         }\n@@ -1271,16 +1249,20 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H>\n     }\n }\n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Index<K, V> for HashMap<K, V, H> {\n+impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> Index<Q, V> for HashMap<K, V, H>\n+    where Q: BorrowFrom<K> + Hash<S> + Eq\n+{\n     #[inline]\n-    fn index<'a>(&'a self, index: &K) -> &'a V {\n+    fn index<'a>(&'a self, index: &Q) -> &'a V {\n         self.get(index).expect(\"no entry found for key\")\n     }\n }\n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> IndexMut<K, V> for HashMap<K, V, H> {\n+impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> IndexMut<Q, V> for HashMap<K, V, H>\n+    where Q: BorrowFrom<K> + Hash<S> + Eq\n+{\n     #[inline]\n-    fn index_mut<'a>(&'a mut self, index: &K) -> &'a mut V {\n+    fn index_mut<'a>(&'a mut self, index: &Q) -> &'a mut V {\n         match self.get_mut(index) {\n             Some(v) => v,\n             None => panic!(\"no entry found for key\")\n@@ -1962,11 +1944,11 @@ mod test_map {\n         m.insert(\"baz\".to_string(), baz);\n \n \n-        assert_eq!(m.find_equiv(\"foo\"), Some(&foo));\n-        assert_eq!(m.find_equiv(\"bar\"), Some(&bar));\n-        assert_eq!(m.find_equiv(\"baz\"), Some(&baz));\n+        assert_eq!(m.get(\"foo\"), Some(&foo));\n+        assert_eq!(m.get(\"bar\"), Some(&bar));\n+        assert_eq!(m.get(\"baz\"), Some(&baz));\n \n-        assert_eq!(m.find_equiv(\"qux\"), None);\n+        assert_eq!(m.get(\"qux\"), None);\n     }\n \n     #[test]"}, {"sha": "2fbcb464358b3c76170609de03524e5d5b40caab", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 22, "deletions": 43, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -10,6 +10,7 @@\n //\n // ignore-lexer-test FIXME #15883\n \n+use borrow::BorrowFrom;\n use cmp::{Eq, Equiv, PartialEq};\n use core::kinds::Sized;\n use default::Default;\n@@ -184,47 +185,9 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n         self.map.reserve(n)\n     }\n \n-    /// Returns true if the hash set contains a value equivalent to the\n-    /// given query value.\n-    ///\n-    /// # Example\n-    ///\n-    /// This is a slightly silly example where we define the number's\n-    /// parity as the equivalance class. It is important that the\n-    /// values hash the same, which is why we implement `Hash`.\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// use std::hash::Hash;\n-    /// use std::hash::sip::SipState;\n-    ///\n-    /// #[deriving(Eq, PartialEq)]\n-    /// struct EvenOrOdd {\n-    ///     num: uint\n-    /// };\n-    ///\n-    /// impl Hash for EvenOrOdd {\n-    ///     fn hash(&self, state: &mut SipState) {\n-    ///         let parity = self.num % 2;\n-    ///         parity.hash(state);\n-    ///     }\n-    /// }\n-    ///\n-    /// impl Equiv<EvenOrOdd> for EvenOrOdd {\n-    ///     fn equiv(&self, other: &EvenOrOdd) -> bool {\n-    ///         self.num % 2 == other.num % 2\n-    ///     }\n-    /// }\n-    ///\n-    /// let mut set = HashSet::new();\n-    /// set.insert(EvenOrOdd { num: 3u });\n-    ///\n-    /// assert!(set.contains_equiv(&EvenOrOdd { num: 3u }));\n-    /// assert!(set.contains_equiv(&EvenOrOdd { num: 5u }));\n-    /// assert!(!set.contains_equiv(&EvenOrOdd { num: 4u }));\n-    /// assert!(!set.contains_equiv(&EvenOrOdd { num: 2u }));\n-    ///\n-    /// ```\n+    /// Deprecated: use `contains` and `BorrowFrom`.\n+    #[deprecated = \"use contains and BorrowFrom\"]\n+    #[allow(deprecated)]\n     pub fn contains_equiv<Sized? Q: Hash<S> + Equiv<T>>(&self, value: &Q) -> bool {\n       self.map.contains_key_equiv(value)\n     }\n@@ -427,6 +390,10 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n \n     /// Returns `true` if the set contains a value.\n     ///\n+    /// The value may be any borrowed form of the set's value type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -437,7 +404,11 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n+    pub fn contains<Sized? Q>(&self, value: &Q) -> bool\n+        where Q: BorrowFrom<T> + Hash<S> + Eq\n+    {\n+        self.map.contains_key(value)\n+    }\n \n     /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n@@ -527,6 +498,10 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n     ///\n+    /// The value may be any borrowed form of the set's value type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -539,7 +514,11 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value).is_some() }\n+    pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool\n+        where Q: BorrowFrom<T> + Hash<S> + Eq\n+    {\n+        self.map.remove(value).is_some()\n+    }\n }\n \n impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {"}, {"sha": "f41ccea0aaf0370dff35ceb188edaa58b01f0893", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -718,7 +718,7 @@ impl<'a, K, V> Iterator<RawBucket<K, V>> for RawBuckets<'a, K, V> {\n }\n \n /// An iterator that moves out buckets in reverse order. It leaves the table\n-/// in an an inconsistent state and should only be used for dropping\n+/// in an inconsistent state and should only be used for dropping\n /// the table's remaining entries. It's used in the implementation of Drop.\n struct RevMoveBuckets<'a, K, V> {\n     raw: RawBucket<K, V>,"}, {"sha": "cd4141e045cb5dc8b5c0d4be0c415549099162ca", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -381,16 +381,8 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n \n     let mut reader = try!(File::open(from));\n     let mut writer = try!(File::create(to));\n-    let mut buf = [0, ..io::DEFAULT_BUF_SIZE];\n \n-    loop {\n-        let amt = match reader.read(&mut buf) {\n-            Ok(n) => n,\n-            Err(ref e) if e.kind == io::EndOfFile => { break }\n-            Err(e) => return update_err(Err(e), from, to)\n-        };\n-        try!(writer.write(buf[..amt]));\n-    }\n+    try!(update_err(super::util::copy(&mut reader, &mut writer), from, to));\n \n     chmod(to, try!(update_err(from.stat(), from, to)).perm)\n }"}, {"sha": "7f2a4c7e36569f4881c56d1e680db9ded0c5c9f0", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -141,6 +141,7 @@ extern crate rustrt;\n \n pub use core::any;\n pub use core::bool;\n+pub use core::borrow;\n pub use core::cell;\n pub use core::clone;\n #[cfg(not(test))] pub use core::cmp;"}, {"sha": "be8e4695fa9433f396ae87b7e218c60a110161ad", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -81,7 +81,7 @@ const BUF_BYTES : uint = 2048u;\n /// # Failure\n ///\n /// Fails if the current working directory value is invalid:\n-/// Possibles cases:\n+/// Possible cases:\n ///\n /// * Current directory does not exist.\n /// * There are insufficient permissions to access the current directory."}, {"sha": "39ca3128ccb2babc7d94eafd1b2b55749cacd9b7", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -554,11 +554,4 @@ mod tests {\n         assert_eq!(format!(\"{:30}\", Duration::days(1) + Duration::milliseconds(2345)),\n                    \"P1DT2.345S\".to_string());\n     }\n-\n-    #[test]\n-    fn span() {\n-        use io::timer::sleep;\n-        let dur = Duration::span(|| sleep(Duration::milliseconds(5)));\n-        assert!(dur > Duration::milliseconds(1));\n-    }\n }"}, {"sha": "4caef247aebc26f601318c8d4de23ec70cfdfe02", "filename": "src/libsyntax/diagnostics/registry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -20,6 +20,6 @@ impl Registry {\n     }\n \n     pub fn find_description(&self, code: &str) -> Option<&'static str> {\n-        self.descriptions.find_equiv(code).map(|desc| *desc)\n+        self.descriptions.get(code).map(|desc| *desc)\n     }\n }"}, {"sha": "d04144ef26e596c121cbd9602eacad23128680ae", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -97,8 +97,8 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     // cannot be shared with any other operand (usually when\n                     // a register is clobbered early.)\n                     let output = match constraint.get().slice_shift_char() {\n-                        (Some('='), _) => None,\n-                        (Some('+'), operand) => {\n+                        Some(('=', _)) => None,\n+                        Some(('+', operand)) => {\n                             Some(token::intern_and_get_ident(format!(\n                                         \"={}\",\n                                         operand).as_slice()))"}, {"sha": "f1b92b4d6bc1d7406bcac881eb0c1f09a79a1889", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -144,7 +144,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n             let name = interned_name.get();\n             p.expect(&token::Eq);\n             let e = p.parse_expr();\n-            match names.find_equiv(name) {\n+            match names.get(name) {\n                 None => {}\n                 Some(prev) => {\n                     ecx.span_err(e.span,\n@@ -366,7 +366,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 self.ecx.expr_path(path)\n             }\n             parse::CountIsName(n) => {\n-                let i = match self.name_positions.find_equiv(n) {\n+                let i = match self.name_positions.get(n) {\n                     Some(&i) => i,\n                     None => 0, // error already emitted elsewhere\n                 };\n@@ -410,7 +410,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     // Named arguments are converted to positional arguments at\n                     // the end of the list of arguments\n                     parse::ArgumentNamed(n) => {\n-                        let i = match self.name_positions.find_equiv(n) {\n+                        let i = match self.name_positions.get(n) {\n                             Some(&i) => i,\n                             None => 0, // error already emitted elsewhere\n                         };"}, {"sha": "0c31e9ae01d757ef9d3eaade708c9574d7817dcd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -182,6 +182,10 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n                                   \"`#[thread_local]` is an experimental feature, and does not \\\n                                   currently handle destructors. There is no corresponding \\\n                                   `#[task_local]` mapping to the task model\");\n+            } else if attr.name().equiv(&(\"linkage\")) {\n+                self.gate_feature(\"linkage\", i.span,\n+                                  \"the `linkage` attribute is experimental \\\n+                                   and not portable across platforms\")\n             }\n         }\n         match i.node {"}, {"sha": "98479d65cbb2fb0579e5a352b2208311047f2ff9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -1232,7 +1232,8 @@ impl<'a> Parser<'a> {\n     {\n         if self.eat(&token::Lt) {\n             if lifetime_defs.is_empty() {\n-                self.warn(\"deprecated syntax, use `for` keyword now\");\n+                self.warn(\"deprecated syntax; use the `for` keyword now \\\n+                            (e.g. change `fn<'a>` to `for<'a> fn`)\");\n                 let lifetime_defs = self.parse_lifetime_defs();\n                 self.expect_gt();\n                 lifetime_defs\n@@ -5178,7 +5179,15 @@ impl<'a> Parser<'a> {\n             if self.eat(&token::OpenDelim(token::Brace)) {\n                 // Parse a struct variant.\n                 all_nullary = false;\n-                kind = StructVariantKind(self.parse_struct_def());\n+                let start_span = self.span;\n+                let struct_def = self.parse_struct_def();\n+                if struct_def.fields.len() == 0 {\n+                    self.span_err(start_span,\n+                        format!(\"unit-like struct variant should be written \\\n+                                 without braces, as `{},`\",\n+                                token::get_ident(ident)).as_slice());\n+                }\n+                kind = StructVariantKind(struct_def);\n             } else if self.token == token::OpenDelim(token::Paren) {\n                 all_nullary = false;\n                 let arg_tys = self.parse_enum_variant_seq("}, {"sha": "81f3d977e13ff7da3085929c7abd65e231db6152", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -1855,7 +1855,7 @@ impl<'a> State<'a> {\n                 try!(self.commasep(Inconsistent, a.outputs.as_slice(),\n                                    |s, &(ref co, ref o, is_rw)| {\n                     match co.get().slice_shift_char() {\n-                        (Some('='), operand) if is_rw => {\n+                        Some(('=', operand)) if is_rw => {\n                             try!(s.print_string(format!(\"+{}\", operand).as_slice(),\n                                                 ast::CookedStr))\n                         }"}, {"sha": "ede967bba25cd20bad2a12dd2d56ae77148f3179", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -14,9 +14,9 @@\n \n use ast::Name;\n \n+use std::borrow::BorrowFrom;\n use std::collections::HashMap;\n use std::cell::RefCell;\n-use std::cmp::Equiv;\n use std::fmt;\n use std::hash::Hash;\n use std::rc::Rc;\n@@ -75,9 +75,10 @@ impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n         (*vect).len()\n     }\n \n-    pub fn find_equiv<Sized? Q: Hash + Equiv<T>>(&self, val: &Q) -> Option<Name> {\n+    pub fn find<Sized? Q>(&self, val: &Q) -> Option<Name>\n+    where Q: BorrowFrom<T> + Eq + Hash {\n         let map = self.map.borrow();\n-        match (*map).find_equiv(val) {\n+        match (*map).get(val) {\n             Some(v) => Some(*v),\n             None => None,\n         }\n@@ -117,6 +118,12 @@ impl fmt::Show for RcStr {\n     }\n }\n \n+impl BorrowFrom<RcStr> for str {\n+    fn borrow_from(owned: &RcStr) -> &str {\n+        owned.string.as_slice()\n+    }\n+}\n+\n impl RcStr {\n     pub fn new(string: &str) -> RcStr {\n         RcStr {\n@@ -149,7 +156,7 @@ impl StrInterner {\n \n     pub fn intern(&self, val: &str) -> Name {\n         let mut map = self.map.borrow_mut();\n-        match map.find_equiv(val) {\n+        match map.get(val) {\n             Some(&idx) => return idx,\n             None => (),\n         }\n@@ -195,8 +202,9 @@ impl StrInterner {\n         self.vect.borrow().len()\n     }\n \n-    pub fn find_equiv<Sized? Q:Hash + Equiv<RcStr>>(&self, val: &Q) -> Option<Name> {\n-        match (*self.map.borrow()).find_equiv(val) {\n+    pub fn find<Sized? Q>(&self, val: &Q) -> Option<Name>\n+    where Q: BorrowFrom<RcStr> + Eq + Hash {\n+        match (*self.map.borrow()).get(val) {\n             Some(v) => Some(*v),\n             None => None,\n         }"}, {"sha": "c1393767c8adcaf62af86f86b2f1e70452e9c64a", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -78,7 +78,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n         if self.num_colors > color {\n             let s = expand(self.ti\n                                .strings\n-                               .find_equiv(\"setaf\")\n+                               .get(\"setaf\")\n                                .unwrap()\n                                .as_slice(),\n                            &[Number(color as int)], &mut Variables::new());\n@@ -95,7 +95,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n         if self.num_colors > color {\n             let s = expand(self.ti\n                                .strings\n-                               .find_equiv(\"setab\")\n+                               .get(\"setab\")\n                                .unwrap()\n                                .as_slice(),\n                            &[Number(color as int)], &mut Variables::new());\n@@ -113,7 +113,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n             attr::BackgroundColor(c) => self.bg(c),\n             _ => {\n                 let cap = cap_for_attr(attr);\n-                let parm = self.ti.strings.find_equiv(cap);\n+                let parm = self.ti.strings.get(cap);\n                 if parm.is_some() {\n                     let s = expand(parm.unwrap().as_slice(),\n                                    &[],\n@@ -135,19 +135,19 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n             }\n             _ => {\n                 let cap = cap_for_attr(attr);\n-                self.ti.strings.find_equiv(cap).is_some()\n+                self.ti.strings.get(cap).is_some()\n             }\n         }\n     }\n \n     fn reset(&mut self) -> IoResult<()> {\n-        let mut cap = self.ti.strings.find_equiv(\"sgr0\");\n+        let mut cap = self.ti.strings.get(\"sgr0\");\n         if cap.is_none() {\n             // are there any terminals that have color/attrs and not sgr0?\n             // Try falling back to sgr, then op\n-            cap = self.ti.strings.find_equiv(\"sgr\");\n+            cap = self.ti.strings.get(\"sgr\");\n             if cap.is_none() {\n-                cap = self.ti.strings.find_equiv(\"op\");\n+                cap = self.ti.strings.get(\"op\");\n             }\n         }\n         let s = cap.map_or(Err(\"can't find terminfo capability `sgr0`\".to_string()), |op| {\n@@ -202,9 +202,9 @@ impl<T: Writer+Send> TerminfoTerminal<T> {\n         }\n \n         let inf = ti.unwrap();\n-        let nc = if inf.strings.find_equiv(\"setaf\").is_some()\n-                 && inf.strings.find_equiv(\"setab\").is_some() {\n-                     inf.numbers.find_equiv(\"colors\").map_or(0, |&n| n)\n+        let nc = if inf.strings.get(\"setaf\").is_some()\n+                 && inf.strings.get(\"setab\").is_some() {\n+                     inf.numbers.get(\"colors\").map_or(0, |&n| n)\n                  } else { 0 };\n \n         return Some(box TerminfoTerminal {out: out,"}, {"sha": "e39cd743ad55ac75d921912f1a419eac21df1cb3", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -76,7 +76,7 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> String {\n // given a map, search for the frequency of a pattern\n fn find(mm: &HashMap<Vec<u8> , uint>, key: String) -> uint {\n    let key = key.into_ascii().as_slice().to_lowercase().into_string();\n-   match mm.find_equiv(key.as_bytes()) {\n+   match mm.get(key.as_bytes()) {\n       option::None      => { return 0u; }\n       option::Some(&num) => { return num; }\n    }"}, {"sha": "25d78c273e77a33537c7161df5faf4c467c5626c", "filename": "src/test/compile-fail-fulldeps/issue-18986.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:use_from_trait_xc.rs\n+\n+extern crate use_from_trait_xc;\n+pub use use_from_trait_xc::Trait;\n+\n+fn main() {\n+    match () {\n+        Trait { x: 42u } => () //~ ERROR use of trait `Trait` in a struct pattern\n+    }\n+}"}, {"sha": "8f68f3e553cd7ce9638e36d0bd95cf725be4b906", "filename": "src/test/compile-fail/linkage4.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Fcompile-fail%2Flinkage4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Fcompile-fail%2Flinkage4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flinkage4.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[linkage = \"external\"]\n+static foo: int = 0;\n+//~^ ERROR: the `linkage` attribute is experimental and not portable\n+\n+fn main() {}"}, {"sha": "8e1723ddab24cc8848e76f84c57ca5a3e25599a8", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -459,6 +459,20 @@ mod this_crate {\n         foo.trait_stable();\n     }\n \n+    #[deprecated]\n+    fn test_fn_body() {\n+        fn fn_in_body() {}\n+        fn_in_body();\n+    }\n+\n+    impl MethodTester {\n+        #[deprecated]\n+        fn test_method_body(&self) {\n+            fn fn_in_body() {}\n+            fn_in_body();\n+        }\n+    }\n+\n     #[deprecated]\n     pub trait DeprecatedTrait {}\n "}, {"sha": "41dbbeefc0a60f87a5d2bad5dc3d57285d58d290", "filename": "src/test/compile-fail/struct-variant-no-fields.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Fcompile-fail%2Fstruct-variant-no-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Fcompile-fail%2Fstruct-variant-no-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-variant-no-fields.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Foo {\n+    Bar {} //~ ERROR unit-like struct variant should be written without braces, as `Bar,`\n+}"}, {"sha": "6bcde96335cff07c99a7d09ae824112095e389c7", "filename": "src/test/run-make/linkage-attr-on-static/Makefile", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Frun-make%2Flinkage-attr-on-static%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Frun-make%2Flinkage-attr-on-static%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flinkage-attr-on-static%2FMakefile?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -0,0 +1,8 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(CC) foo.c -c -o $(TMPDIR)/foo.o\n+\t$(AR) rcs $(TMPDIR)/libfoo.a $(TMPDIR)/foo.o\n+\t$(RUSTC) bar.rs -lfoo -L $(TMPDIR)\n+\t$(call RUN,bar) || exit 1\n+"}, {"sha": "6125421bdeb6c91bbba5fe91863dde5b95f451ff", "filename": "src/test/run-make/linkage-attr-on-static/bar.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Frun-make%2Flinkage-attr-on-static%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Frun-make%2Flinkage-attr-on-static%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flinkage-attr-on-static%2Fbar.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(linkage)]\n+\n+#[no_mangle]\n+#[linkage = \"external\"]\n+static BAZ: i32 = 21;\n+\n+extern {\n+    fn what() -> i32;\n+}\n+\n+fn main() {\n+    unsafe {\n+        assert_eq!(what(), BAZ);\n+    }\n+}"}, {"sha": "78a6934f57f76766182836819f92e94c3d513a4c", "filename": "src/test/run-make/linkage-attr-on-static/foo.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Frun-make%2Flinkage-attr-on-static%2Ffoo.c", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Frun-make%2Flinkage-attr-on-static%2Ffoo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flinkage-attr-on-static%2Ffoo.c?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -0,0 +1,7 @@\n+#include <stdint.h>\n+\n+extern int32_t BAZ;\n+\n+int32_t what() {\n+    return BAZ;\n+}"}, {"sha": "a6b5f4b8744667d1d9bba86a3b40692938c8b590", "filename": "src/test/run-pass/issue-19037.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Frun-pass%2Fissue-19037.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c96a79a74f10bed18b031ce0ac4126c56d6cfb3/src%2Ftest%2Frun-pass%2Fissue-19037.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19037.rs?ref=9c96a79a74f10bed18b031ce0ac4126c56d6cfb3", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Str([u8]);\n+\n+#[deriving(Clone)]\n+struct CharSplits<'a, Sep> {\n+    string: &'a Str,\n+    sep: Sep,\n+    allow_trailing_empty: bool,\n+    only_ascii: bool,\n+    finished: bool,\n+}\n+\n+fn clone(s: &Str) -> &Str {\n+    Clone::clone(&s)\n+}\n+\n+fn main() {}"}]}