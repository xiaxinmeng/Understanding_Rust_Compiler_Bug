{"sha": "117d21d6c25813a8894bd18170bb75a61e927acc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExN2QyMWQ2YzI1ODEzYTg4OTRiZDE4MTcwYmI3NWE2MWU5MjdhY2M=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-18T02:11:01Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-18T02:18:44Z"}, "message": "rustc: Stub stack map generation machinery", "tree": {"sha": "cee4d1f8cd93981c887083b6236e784f710b94d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cee4d1f8cd93981c887083b6236e784f710b94d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/117d21d6c25813a8894bd18170bb75a61e927acc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/117d21d6c25813a8894bd18170bb75a61e927acc", "html_url": "https://github.com/rust-lang/rust/commit/117d21d6c25813a8894bd18170bb75a61e927acc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/117d21d6c25813a8894bd18170bb75a61e927acc/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51af43f192407c4920134638e910c85f8ee6ee36", "url": "https://api.github.com/repos/rust-lang/rust/commits/51af43f192407c4920134638e910c85f8ee6ee36", "html_url": "https://github.com/rust-lang/rust/commit/51af43f192407c4920134638e910c85f8ee6ee36"}], "stats": {"total": 170, "additions": 124, "deletions": 46}, "files": [{"sha": "c0f797773e99df5c6d8eb789a5cc4e0986b6ea7c", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 75, "deletions": 13, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/117d21d6c25813a8894bd18170bb75a61e927acc/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117d21d6c25813a8894bd18170bb75a61e927acc/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=117d21d6c25813a8894bd18170bb75a61e927acc", "patch": "@@ -1,32 +1,96 @@\n // Routines useful for garbage collection.\n \n+import lib::llvm::False;\n+import lib::llvm::True;\n import lib::llvm::llvm::ValueRef;\n import middle::trans::get_tydesc;\n import middle::trans_common::*;\n import middle::ty;\n import std::option::none;\n+import std::option::some;\n import std::ptr;\n import std::str;\n import std::unsafe;\n+import std::vec;\n \n import lll = lib::llvm::llvm;\n \n+type ctxt = @{ mutable next_tydesc_num: uint };\n+\n+fn mk_ctxt() -> ctxt {\n+    ret @{ mutable next_tydesc_num: 0u };\n+}\n+\n+fn add_global(ccx: &@crate_ctxt, llval: ValueRef, name: str) -> ValueRef {\n+    let llglobal = lll::LLVMAddGlobal(ccx.llmod, val_ty(llval),\n+                                      str::buf(name));\n+    lll::LLVMSetInitializer(llglobal, llval);\n+    lll::LLVMSetGlobalConstant(llglobal, True);\n+    ret llglobal;\n+}\n+\n fn add_gc_root(cx: &@block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n     let bcx = cx;\n-    if !type_is_gc_relevant(bcx_tcx(cx), ty) { ret bcx; }\n+    if !type_is_gc_relevant(bcx_tcx(cx), ty) ||\n+            ty::type_has_dynamic_size(bcx_tcx(cx), ty) {\n+        ret bcx;\n+    }\n \n-    let md_kind_name = \"rusttydesc\";\n-    let md_kind = lll::LLVMGetMDKindID(str::buf(md_kind_name),\n-                                       str::byte_len(md_kind_name));\n+    let gc_cx = bcx_ccx(cx).gc_cx;\n \n     let ti = none;\n-    let r = get_tydesc(bcx, ty, false, ti);\n-    bcx = r.bcx;\n-    let lltydesc = r.val;\n+    let td_r = get_tydesc(bcx, ty, false, ti);\n+    bcx = td_r.result.bcx;\n+    let lltydesc = td_r.result.val;\n+\n+    let gcroot = bcx_ccx(bcx).intrinsics.get(\"llvm.gcroot\");\n+    let llvalptr = bcx.build.PointerCast(llval, T_ptr(T_ptr(T_i8())));\n+\n+    alt td_r.kind {\n+        tk_derived. {\n+            // It's a derived type descriptor. First, spill it.\n+            let lltydescptr = trans::alloca(bcx, val_ty(lltydesc));\n+            bcx.build.Store(lltydesc, lltydescptr);\n+\n+            let number = gc_cx.next_tydesc_num;\n+            gc_cx.next_tydesc_num += 1u;\n+\n+            let lldestindex = add_global(bcx_ccx(bcx),\n+                                         C_struct(~[C_int(0),\n+                                                    C_uint(number)]),\n+                                         \"rust_gc_tydesc_dest_index\");\n+            let llsrcindex = add_global(bcx_ccx(bcx),\n+                                        C_struct(~[C_int(1), C_uint(number)]),\n+                                        \"rust_gc_tydesc_src_index\");\n+\n+            lldestindex = lll::LLVMConstPointerCast(lldestindex,\n+                                                    T_ptr(T_i8()));\n+            llsrcindex = lll::LLVMConstPointerCast(llsrcindex,\n+                                                   T_ptr(T_i8()));\n+\n+            lltydescptr = bcx.build.PointerCast(lltydescptr,\n+                                                T_ptr(T_ptr(T_i8())));\n+\n+            bcx.build.Call(gcroot, ~[ lltydescptr, lldestindex ]);\n+            bcx.build.Call(gcroot, ~[ llvalptr, llsrcindex ]);\n+        }\n+        tk_param. {\n+            bcx_tcx(cx).sess.bug(\"we should never be trying to root values \" +\n+                \"of a type parameter\");\n+        }\n+        tk_static. {\n+            // Static type descriptor.\n+\n+            let llstaticgcmeta = add_global(bcx_ccx(bcx),\n+                                            C_struct(~[C_int(2), lltydesc]),\n+                                            \"rust_gc_tydesc_static_gc_meta\");\n+            let llstaticgcmetaptr = lll::LLVMConstPointerCast(llstaticgcmeta,\n+                                                              T_ptr(T_i8()));\n+\n+            bcx.build.Call(gcroot, ~[ llvalptr, llstaticgcmetaptr ]);\n+        }\n+    }\n \n-    let llmdnode =\n-        lll::LLVMMDNode(unsafe::reinterpret_cast(ptr::addr_of(lltydesc)), 1u);\n-    lll::LLVMSetMetadata(llval, md_kind, llmdnode);\n     ret bcx;\n }\n \n@@ -57,9 +121,7 @@ fn type_is_gc_relevant(cx: &ty::ctxt, ty: &ty::t) -> bool {\n             for variant in variants {\n                 for aty in variant.args {\n                     let arg_ty = ty::substitute_type_params(cx, tps, aty);\n-                    if type_is_gc_relevant(cx, arg_ty) {\n-                        ret true;\n-                    }\n+                    if type_is_gc_relevant(cx, arg_ty) { ret true; }\n                 }\n             }\n             ret false;"}, {"sha": "3f5bea87bdcabd3e73e1a14a09fbc1b05dcfe1aa", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/117d21d6c25813a8894bd18170bb75a61e927acc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117d21d6c25813a8894bd18170bb75a61e927acc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=117d21d6c25813a8894bd18170bb75a61e927acc", "patch": "@@ -23,6 +23,7 @@ import std::option::some;\n import std::option::none;\n import std::fs;\n import std::time;\n+import std::vec;\n import syntax::ast;\n import driver::session;\n import middle::ty;\n@@ -901,7 +902,7 @@ fn trans_malloc_boxed(cx: &@block_ctxt, t: ty::t) ->\n fn field_of_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool, field: int) ->\n    result {\n     let ti = none::<@tydesc_info>;\n-    let tydesc = get_tydesc(cx, t, escapes, ti);\n+    let tydesc = get_tydesc(cx, t, escapes, ti).result;\n     ret rslt(tydesc.bcx,\n              tydesc.bcx.build.GEP(tydesc.val, ~[C_int(0), C_int(field)]));\n }\n@@ -1028,16 +1029,19 @@ fn get_derived_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool,\n     ret rslt(cx, v);\n }\n \n+type get_tydesc_result = { kind: tydesc_kind, result: result };\n+\n fn get_tydesc(cx: &@block_ctxt, orig_t: &ty::t, escapes: bool,\n-              static_ti: &mutable option::t<@tydesc_info>) -> result {\n+              static_ti: &mutable option::t<@tydesc_info>)\n+        -> get_tydesc_result {\n \n     let t = ty::strip_cname(bcx_tcx(cx), orig_t);\n \n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n     alt ty::type_param(bcx_tcx(cx), t) {\n       some(id) {\n-        if id < std::vec::len(cx.fcx.lltydescs) {\n-            ret rslt(cx, cx.fcx.lltydescs.(id));\n+        if id < vec::len(cx.fcx.lltydescs) {\n+            ret { kind: tk_param, result: rslt(cx, cx.fcx.lltydescs.(id)) };\n         }\n         else {\n             bcx_tcx(cx).sess.span_bug(cx.sp, \"Unbound typaram in get_tydesc: \"\n@@ -1050,13 +1054,16 @@ fn get_tydesc(cx: &@block_ctxt, orig_t: &ty::t, escapes: bool,\n \n     // Does it contain a type param? If so, generate a derived tydesc.\n     if ty::type_contains_params(bcx_tcx(cx), t) {\n-        ret get_derived_tydesc(cx, t, escapes, static_ti);\n+        ret {\n+            kind: tk_derived,\n+            result: get_derived_tydesc(cx, t, escapes, static_ti)\n+        };\n     }\n \n     // Otherwise, generate a tydesc if necessary, and return it.\n     let info = get_static_tydesc(cx, t, ~[]);\n     static_ti = some::<@tydesc_info>(info);\n-    ret rslt(cx, info.tydesc);\n+    ret { kind: tk_static, result: rslt(cx, info.tydesc) };\n }\n \n fn get_static_tydesc(cx: &@block_ctxt, orig_t: &ty::t, ty_params: &[uint]) ->\n@@ -1484,9 +1491,9 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n         cx.build.Load(cx.build.GEP(dtor_pair,\n                                    ~[C_int(0), C_int(abi::fn_field_box)]));\n     let args = ~[cx.fcx.llretptr, cx.fcx.lltaskptr, dtor_env];\n-    for tp: ty::t in tps {\n+    for tp: ty::t  in tps {\n         let ti: option::t<@tydesc_info> = none;\n-        let td = get_tydesc(cx, tp, false, ti);\n+        let td = get_tydesc(cx, tp, false, ti).result;\n         args += ~[td.val];\n         cx = td.bcx;\n     }\n@@ -2130,7 +2137,7 @@ fn call_tydesc_glue_full(cx: &@block_ctxt, v: ValueRef, tydesc: ValueRef,\n fn call_tydesc_glue(cx: &@block_ctxt, v: ValueRef, t: &ty::t, field: int) ->\n    result {\n     let ti: option::t<@tydesc_info> = none::<@tydesc_info>;\n-    let td = get_tydesc(cx, t, false, ti);\n+    let td = get_tydesc(cx, t, false, ti).result;\n     call_tydesc_glue_full(td.bcx, spill_if_immediate(td.bcx, v, t), td.val,\n                           field, ti);\n     ret rslt(td.bcx, C_nil());\n@@ -2146,7 +2153,7 @@ fn call_cmp_glue(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: &ty::t,\n     let llrawlhsptr = cx.build.BitCast(lllhs, T_ptr(T_i8()));\n     let llrawrhsptr = cx.build.BitCast(llrhs, T_ptr(T_i8()));\n     let ti = none::<@tydesc_info>;\n-    let r = get_tydesc(cx, t, false, ti);\n+    let r = get_tydesc(cx, t, false, ti).result;\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_cmp_glue, ti);\n     let lltydesc = r.val;\n     let lltydescs =\n@@ -2561,10 +2568,10 @@ fn trans_vec_append(cx: &@block_ctxt, t: &ty::t, lhs: ValueRef, rhs: ValueRef)\n     }\n     let bcx = cx;\n     let ti = none::<@tydesc_info>;\n-    let llvec_tydesc = get_tydesc(bcx, t, false, ti);\n+    let llvec_tydesc = get_tydesc(bcx, t, false, ti).result;\n     bcx = llvec_tydesc.bcx;\n     ti = none::<@tydesc_info>;\n-    let llelt_tydesc = get_tydesc(bcx, elt_ty, false, ti);\n+    let llelt_tydesc = get_tydesc(bcx, elt_ty, false, ti).result;\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_copy_glue, ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_drop_glue, ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_free_glue, ti);\n@@ -2819,9 +2826,9 @@ mod ivec {\n         // FIXME (issue #511): This is needed to prevent a leak.\n         let no_tydesc_info = none;\n \n-        rs = get_tydesc(bcx, t, false, no_tydesc_info);\n+        rs = get_tydesc(bcx, t, false, no_tydesc_info).result;\n         bcx = rs.bcx;\n-        rs = get_tydesc(bcx, unit_ty, false, no_tydesc_info);\n+        rs = get_tydesc(bcx, unit_ty, false, no_tydesc_info).result;\n         bcx = rs.bcx;\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_copy_glue, none);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, none);\n@@ -3527,7 +3534,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n     if copying {\n         let bound_tydesc = GEPi(bcx, closure, ~[0, abi::closure_elt_tydesc]);\n         let ti = none;\n-        let bindings_tydesc = get_tydesc(bcx, bindings_ty, true, ti);\n+        let bindings_tydesc = get_tydesc(bcx, bindings_ty, true, ti).result;\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n         bcx = bindings_tydesc.bcx;\n@@ -3848,7 +3855,7 @@ fn lval_generic_fn(cx: &@block_ctxt, tpt: &ty::ty_param_kinds_and_ty,\n             // TODO: Doesn't always escape.\n \n             let ti = none::<@tydesc_info>;\n-            let td = get_tydesc(bcx, t, true, ti);\n+            let td = get_tydesc(bcx, t, true, ti).result;\n             tis += ~[ti];\n             bcx = td.bcx;\n             tydescs += ~[td.val];\n@@ -5254,7 +5261,7 @@ fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n     let log_bcx = sub.bcx;\n \n     let ti = none::<@tydesc_info>;\n-    let r = get_tydesc(log_bcx, e_ty, false, ti);\n+    let r = get_tydesc(log_bcx, e_ty, false, ti).result;\n     log_bcx = r.bcx;\n \n     // Call the polymorphic log function.\n@@ -6926,6 +6933,9 @@ fn declare_intrinsics(llmod: ModuleRef) -> hashmap<str, ValueRef> {\n     let T_memset64_args: [TypeRef] =\n         ~[T_ptr(T_i8()), T_i8(), T_i64(), T_i32(), T_i1()];\n     let T_trap_args: [TypeRef] = ~[];\n+    let gcroot =\n+        decl_cdecl_fn(llmod, \"llvm.gcroot\",\n+                      T_fn(~[T_ptr(T_ptr(T_i8())), T_ptr(T_i8())], T_void()));\n     let gcread =\n         decl_cdecl_fn(llmod, \"llvm.gcread\",\n                       T_fn(~[T_ptr(T_i8()), T_ptr(T_ptr(T_i8()))], T_void()));\n@@ -6943,6 +6953,7 @@ fn declare_intrinsics(llmod: ModuleRef) -> hashmap<str, ValueRef> {\n                       T_fn(T_memset64_args, T_void()));\n     let trap = decl_cdecl_fn(llmod, \"llvm.trap\", T_fn(T_trap_args, T_void()));\n     let intrinsics = new_str_hash::<ValueRef>();\n+    intrinsics.insert(\"llvm.gcroot\", gcroot);\n     intrinsics.insert(\"llvm.gcread\", gcread);\n     intrinsics.insert(\"llvm.memmove.p0i8.p0i8.i32\", memmove32);\n     intrinsics.insert(\"llvm.memmove.p0i8.p0i8.i64\", memmove64);\n@@ -7142,7 +7153,8 @@ fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n           rust_object_type: T_rust_object(),\n           tydesc_type: tydesc_type,\n           task_type: task_type,\n-          shape_cx: shape::mk_ctxt(llmod)};\n+          shape_cx: shape::mk_ctxt(llmod),\n+          gc_cx: gc::mk_ctxt()};\n     let cx = new_local_ctxt(ccx);\n     collect_items(ccx, crate);\n     collect_tag_ctors(ccx, crate);"}, {"sha": "cf87d56424ade070d76628925ef6bc97f18b2c6c", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/117d21d6c25813a8894bd18170bb75a61e927acc/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117d21d6c25813a8894bd18170bb75a61e927acc/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=117d21d6c25813a8894bd18170bb75a61e927acc", "patch": "@@ -70,6 +70,12 @@ type derived_tydesc_info = {lltydesc: ValueRef, escapes: bool};\n \n type glue_fns = {no_op_type_glue: ValueRef};\n \n+tag tydesc_kind {\n+    tk_static;      // Static (monomorphic) type descriptor.\n+    tk_param;       // Type parameter.\n+    tk_derived;     // Derived from a typaram or another derived tydesc.\n+}\n+\n type tydesc_info =\n     {ty: ty::t,\n      tydesc: ValueRef,\n@@ -142,7 +148,8 @@ type crate_ctxt = {\n     rust_object_type: TypeRef,\n     tydesc_type: TypeRef,\n     task_type: TypeRef,\n-    shape_cx: shape::ctxt\n+    shape_cx: shape::ctxt,\n+    gc_cx: gc::ctxt\n };\n \n type local_ctxt ="}, {"sha": "6f1b7f1447820521008bfe2c94905db155172cbd", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/117d21d6c25813a8894bd18170bb75a61e927acc/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117d21d6c25813a8894bd18170bb75a61e927acc/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=117d21d6c25813a8894bd18170bb75a61e927acc", "patch": "@@ -133,7 +133,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n                          ~[0, abi::obj_body_elt_tydesc]);\n         bcx = body_tydesc.bcx;\n         let ti = none::<@tydesc_info>;\n-        let body_td = get_tydesc(bcx, body_ty, true, ti);\n+        let body_td = get_tydesc(bcx, body_ty, true, ti).result;\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n         bcx = body_td.bcx;\n@@ -327,7 +327,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n                          ~[0, abi::obj_body_elt_tydesc]);\n         bcx = body_tydesc.bcx;\n         let ti = none::<@tydesc_info>;\n-        let body_td = get_tydesc(bcx, body_ty, true, ti);\n+        let body_td = get_tydesc(bcx, body_ty, true, ti).result;\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n         bcx = body_td.bcx;"}, {"sha": "4949760072557d98e2459dcf2c3a75e6fe7e801e", "filename": "src/rustllvm/RustGCStrategy.cpp", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/117d21d6c25813a8894bd18170bb75a61e927acc/src%2Frustllvm%2FRustGCStrategy.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/117d21d6c25813a8894bd18170bb75a61e927acc/src%2Frustllvm%2FRustGCStrategy.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustGCStrategy.cpp?ref=117d21d6c25813a8894bd18170bb75a61e927acc", "patch": "@@ -16,19 +16,16 @@\n \n using namespace llvm;\n \n-namespace {\n-  class RustGCStrategy : public GCStrategy {\n-  public:\n-    RustGCStrategy();\n-  };\n-}\n+class RustGCStrategy : public GCStrategy {\n+public:\n+  RustGCStrategy() {\n+    NeededSafePoints = 1 << GC::PostCall;\n+    UsesMetadata = true;\n+    InitRoots = false;  // LLVM crashes with this on due to bitcasts.\n+  }\n+};\n \n static GCRegistry::Add<RustGCStrategy>\n-X(\"rust\", \"Rust GC\");\n-\n-RustGCStrategy::RustGCStrategy() {\n-  NeededSafePoints = 1 << GC::PostCall;\n-  UsesMetadata = true;\n-}\n+RustGCStrategyRegistration(\"rust\", \"Rust GC\");\n \n "}]}