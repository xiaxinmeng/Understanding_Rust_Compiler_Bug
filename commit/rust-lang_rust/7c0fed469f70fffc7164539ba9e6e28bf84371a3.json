{"sha": "7c0fed469f70fffc7164539ba9e6e28bf84371a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjMGZlZDQ2OWY3MGZmZmM3MTY0NTM5YmE5ZTZlMjhiZjg0MzcxYTM=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-04-02T16:12:43Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-06T22:35:50Z"}, "message": "rename uv::direct:: to uv::ll:: and put into its own crate", "tree": {"sha": "b835b879ba04906fbc9e718f5caa272eb88ba15f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b835b879ba04906fbc9e718f5caa272eb88ba15f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c0fed469f70fffc7164539ba9e6e28bf84371a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c0fed469f70fffc7164539ba9e6e28bf84371a3", "html_url": "https://github.com/rust-lang/rust/commit/7c0fed469f70fffc7164539ba9e6e28bf84371a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c0fed469f70fffc7164539ba9e6e28bf84371a3/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f18991d90093f4c34cadb418c432bdcf414c5b63", "url": "https://api.github.com/repos/rust-lang/rust/commits/f18991d90093f4c34cadb418c432bdcf414c5b63", "html_url": "https://github.com/rust-lang/rust/commit/f18991d90093f4c34cadb418c432bdcf414c5b63"}], "stats": {"total": 1266, "additions": 669, "deletions": 597}, "files": [{"sha": "7469e3183228ce95a3ed8d3a7e41e6ec14e05cca", "filename": "src/libstd/std.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c0fed469f70fffc7164539ba9e6e28bf84371a3/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/7c0fed469f70fffc7164539ba9e6e28bf84371a3/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=7c0fed469f70fffc7164539ba9e6e28bf84371a3", "patch": "@@ -23,7 +23,10 @@ export test, tempfile, serialization;\n // General io and system-services modules\n \n mod net;\n+\n+// libuv modules\n mod uv;\n+mod uv_ll;\n \n \n // Utility modules"}, {"sha": "f5ee758a368bcd41e879e153c05f093c33c8851f", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 140, "deletions": 597, "changes": 737, "blob_url": "https://github.com/rust-lang/rust/blob/7c0fed469f70fffc7164539ba9e6e28bf84371a3/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c0fed469f70fffc7164539ba9e6e28bf84371a3/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=7c0fed469f70fffc7164539ba9e6e28bf84371a3", "patch": "@@ -24,321 +24,9 @@ import map::hashmap;\n export loop_new, loop_delete, run, close, run_in_bg;\n export async_init, async_send;\n export timer_init, timer_start, timer_stop;\n-export uv_ip4_addr, uv_ip6_addr;\n-export direct;\n \n-// these are processed solely in the\n-// process_operation() crust fn below\n-enum uv_operation {\n-    op_async_init([u8]),\n-    op_close(uv_handle, *libc::c_void),\n-    op_timer_init([u8]),\n-    op_timer_start([u8], *libc::c_void, u32, u32),\n-    op_timer_stop([u8], *libc::c_void, fn~(uv_handle)),\n-    op_teardown(*libc::c_void)\n-}\n-\n-enum uv_handle {\n-    uv_async([u8], uv_loop),\n-    uv_timer([u8], uv_loop),\n-}\n-\n-enum uv_msg {\n-    // requests from library users\n-    msg_run(comm::chan<bool>),\n-    msg_run_in_bg(),\n-    msg_async_init(fn~(uv_handle), fn~(uv_handle)),\n-    msg_async_send([u8]),\n-    msg_close(uv_handle, fn~()),\n-    msg_timer_init(fn~(uv_handle)),\n-    msg_timer_start([u8], u32, u32, fn~(uv_handle)),\n-    msg_timer_stop([u8], fn~(uv_handle)),\n-\n-    // dispatches from libuv\n-    uv_async_init([u8], *libc::c_void),\n-    uv_async_send([u8]),\n-    uv_close([u8]),\n-    uv_timer_init([u8], *libc::c_void),\n-    uv_timer_call([u8]),\n-    uv_timer_stop([u8], fn~(uv_handle)),\n-    uv_end(),\n-    uv_teardown_check()\n-}\n-\n-type uv_loop_data = {\n-    operation_port: comm::port<uv_operation>,\n-    rust_loop_chan: comm::chan<uv_msg>\n-};\n-\n-enum uv_loop {\n-    uv_loop_new(comm::chan<uv_msg>, *libc::c_void)\n-}\n-\n-// libuv struct mappings\n-type uv_ip4_addr = {\n-    ip: [u8],\n-    port: int\n-};\n-type uv_ip6_addr = uv_ip4_addr;\n-\n-enum uv_handle_type {\n-    UNKNOWN_HANDLE = 0,\n-    UV_TCP,\n-    UV_UDP,\n-    UV_NAMED_PIPE,\n-    UV_TTY,\n-    UV_FILE,\n-    UV_TIMER,\n-    UV_PREPARE,\n-    UV_CHECK,\n-    UV_IDLE,\n-    UV_ASYNC,\n-    UV_ARES_TASK,\n-    UV_ARES_EVENT,\n-    UV_PROCESS,\n-    UV_FS_EVENT\n-}\n-\n-type handle_type = libc::c_uint;\n-\n-type uv_handle_fields = {\n-   loop_handle: *libc::c_void,\n-   type_: handle_type,\n-   close_cb: *u8,\n-   mut data: *libc::c_void,\n-};\n-\n-// unix size: 8\n-type uv_err_t = {\n-    code: libc::c_int,\n-    sys_errno_: libc::c_int\n-};\n-\n-// don't create one of these directly. instead,\n-// count on it appearing in libuv callbacks or embedded\n-// in other types as a pointer to be used in other\n-// operations (so mostly treat it as opaque, once you\n-// have it in this form..)\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-#[cfg(target_os = \"win32\")]\n-type uv_stream_t = {\n-    fields: uv_handle_fields\n-};\n-\n-// unix size: 272\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-type uv_tcp_t = {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8, a13: *u8, a14: *u8, a15: *u8,\n-    a16: *u8, a17: *u8, a18: *u8, a19: *u8,\n-    a20: *u8, a21: *u8, a22: *u8, a23: *u8,\n-    a24: *u8, a25: *u8, a26: *u8, a27: *u8,\n-    a28: *u8, a29: *u8\n-};\n-// win32 size: 240 (120)\n-#[cfg(target_os = \"win32\")]\n-type uv_tcp_t = {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8, a13: *u8, a14: *u8, a15: *u8,\n-    a16: *u8, a17: *u8, a18: *u8, a19: *u8,\n-    a20: *u8, a21: *u8, a22: *u8, a23: *u8,\n-    a24: *u8, a25: *u8\n-};\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-fn gen_stub_uv_tcp_t() -> uv_tcp_t {\n-    ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    mut data: ptr::null() },\n-        a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n-        a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n-        a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8, a11: 0 as *u8,\n-        a12: 0 as *u8, a13: 0 as *u8, a14: 0 as *u8, a15: 0 as *u8,\n-        a16: 0 as *u8, a17: 0 as *u8, a18: 0 as *u8, a19: 0 as *u8,\n-        a20: 0 as *u8, a21: 0 as *u8, a22: 0 as *u8, a23: 0 as *u8,\n-        a24: 0 as *u8, a25: 0 as *u8, a26: 0 as *u8, a27: 0 as *u8,\n-        a28: 0 as *u8, a29: 0 as *u8\n-    };\n-}\n-#[cfg(target_os = \"win32\")]\n-fn gen_stub_uv_tcp_t() -> uv_tcp_t {\n-    ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    mut data: ptr::null() },\n-        a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n-        a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n-        a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8, a11: 0 as *u8,\n-        a12: 0 as *u8, a13: 0 as *u8, a14: 0 as *u8, a15: 0 as *u8,\n-        a16: 0 as *u8, a17: 0 as *u8, a18: 0 as *u8, a19: 0 as *u8,\n-        a20: 0 as *u8, a21: 0 as *u8, a22: 0 as *u8, a23: 0 as *u8,\n-        a24: 0 as *u8, a25: 0 as *u8\n-    };\n-}\n-\n-// unix size: 48\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-type uv_connect_t = {\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8\n-};\n-// win32 size: 88 (44)\n-#[cfg(target_os = \"win32\")]\n-type uv_connect_t = {\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8\n-};\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-fn gen_stub_uv_connect_t() -> uv_connect_t {\n-    ret {\n-        a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n-        a04: 0 as *u8, a05: 0 as *u8\n-    };\n-}\n-#[cfg(target_os = \"win32\")]\n-fn gen_stub_uv_connect_t() -> uv_connect_t {\n-    ret {\n-        a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n-        a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n-        a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8\n-    };\n-}\n-\n-// unix size: 16\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-#[cfg(target_os = \"win32\")]\n-type uv_buf_t = {\n-    base: *u8,\n-    len: libc::size_t\n-};\n-// no gen stub method.. should create\n-// it via uv::direct::buf_init()\n-\n-// unix size: 144\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-type uv_write_t = {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8, a13: *u8\n-};\n-// win32 size: 136 (68)\n-#[cfg(target_os = \"win32\")]\n-type uv_write_t = {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8\n-};\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-fn gen_stub_uv_write_t() -> uv_write_t {\n-    ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    mut data: ptr::null() },\n-        a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n-        a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n-        a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8, a11: 0 as *u8,\n-        a12: 0 as *u8, a13: 0 as *u8\n-    };\n-}\n-#[cfg(target_os = \"win32\")]\n-fn gen_stub_uv_write_t() -> uv_write_t {\n-    ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    mut data: ptr::null() },\n-        a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n-        a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n-        a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8, a11: 0 as *u8,\n-        a12: 0 as *u8\n-    };\n-}\n-// unix size: 120\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-type uv_async_t = {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8\n-};\n-// win32 size 132 (68)\n-#[cfg(target_os = \"win32\")]\n-type uv_async_t = {\n-    fields: uv_handle_fields,\n-    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8\n-};\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-fn gen_stub_uv_async_t() -> uv_async_t {\n-    ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    mut data: ptr::null() },\n-        a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n-        a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n-        a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8\n-    };\n-}\n-#[cfg(target_os = \"win32\")]\n-fn gen_stub_uv_async_t() -> uv_async_t {\n-    ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                    close_cb: ptr::null(),\n-                    mut data: ptr::null() },\n-        a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n-        a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n-        a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8, a11: 0 as *u8,\n-        a12: 0 as *u8\n-    };\n-}\n-\n-// unix size: 16\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-#[cfg(target_os = \"win32\")]\n-type sockaddr_in = {\n-    mut sin_family: u16,\n-    mut sin_port: u16,\n-    mut sin_addr: u32, // in_addr: this is an opaque, per-platform struct\n-    mut sin_zero: (u8, u8, u8, u8, u8, u8, u8, u8)\n-};\n-\n-// unix size: 28 .. make due w/ 32\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-#[cfg(target_os = \"win32\")]\n-type sockaddr_in6 = {\n-    a0: *u8, a1: *u8,\n-    a2: *u8, a3: *u8\n-};\n+import ll = uv_ll;\n+export ll;\n \n #[nolink]\n native mod rustrt {\n@@ -351,14 +39,10 @@ native mod rustrt {\n         -> *libc::c_void;\n     fn rust_uv_stop_op_cb(handle: *libc::c_void);\n     fn rust_uv_run(loop_handle: *libc::c_void);\n-    fn rust_uv_close(handle: *libc::c_void, cb: *u8);\n     fn rust_uv_hilvl_close(handle: *libc::c_void, cb: *u8);\n     fn rust_uv_hilvl_close_async(handle: *libc::c_void);\n     fn rust_uv_hilvl_close_timer(handle: *libc::c_void);\n-    fn rust_uv_async_send(handle: *uv_async_t);\n-    fn rust_uv_async_init(loop_handle: *libc::c_void,\n-                          async_handle: *uv_async_t,\n-                          cb: *u8) -> libc::c_int;\n+    fn rust_uv_async_send(handle: *ll::uv_async_t);\n     fn rust_uv_hilvl_async_init(\n         loop_handle: *libc::c_void,\n         cb: *u8,\n@@ -414,198 +98,54 @@ native mod rustrt {\n     fn rust_uv_helper_uv_err_t_size() -> libc::c_uint;\n     fn rust_uv_helper_sockaddr_in_size() -> libc::c_uint;\n     fn rust_uv_helper_uv_async_t_size() -> libc::c_uint;\n-\n-    // data accessors for rust-mapped uv structs\n-    fn rust_uv_get_stream_handle_from_connect_req(\n-        connect_req: *uv_connect_t)\n-        -> *uv_stream_t;\n-    fn rust_uv_get_stream_handle_from_write_req(\n-        write_req: *uv_write_t)\n-        -> *uv_stream_t;\n-    fn rust_uv_get_loop_for_uv_handle(handle: *libc::c_void)\n-        -> *libc::c_void;\n-    fn rust_uv_get_data_for_uv_handle(handle: *libc::c_void)\n-        -> *libc::c_void;\n-    fn rust_uv_set_data_for_uv_handle(handle: *libc::c_void,\n-                                      data: *libc::c_void);\n-    fn rust_uv_get_data_for_req(req: *libc::c_void) -> *libc::c_void;\n-    fn rust_uv_set_data_for_req(req: *libc::c_void,\n-                                data: *libc::c_void);\n-    fn rust_uv_get_base_from_buf(++buf: uv_buf_t) -> *u8;\n-    fn rust_uv_get_len_from_buf(++buf: uv_buf_t) -> libc::size_t;\n }\n \n-// this module is structured around functions that directly\n-// expose libuv functionality and data structures. for use\n-// in higher level mappings\n-mod direct {\n-    unsafe fn loop_new() -> *libc::c_void {\n-        ret rustrt::rust_uv_loop_new();\n-    }\n-\n-    unsafe fn loop_delete(loop_handle: *libc::c_void) {\n-        rustrt::rust_uv_loop_delete(loop_handle);\n-    }\n-\n-    unsafe fn run(loop_handle: *libc::c_void) {\n-        rustrt::rust_uv_run(loop_handle);\n-    }\n-\n-    unsafe fn close(handle: *libc::c_void, cb: *u8) {\n-        rustrt::rust_uv_close(handle, cb);\n-    }\n \n-    unsafe fn tcp_init(loop_handle: *libc::c_void, handle: *uv_tcp_t)\n-        -> libc::c_int {\n-        ret rustrt::rust_uv_tcp_init(loop_handle, handle);\n-    }\n-    // FIXME ref #2064\n-    unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n-                          tcp_handle_ptr: *uv_tcp_t,\n-                          addr_ptr: *sockaddr_in,\n-                          ++after_connect_cb: *u8)\n-    -> libc::c_int {\n-        let address = *addr_ptr;\n-        io::println(#fmt(\"b4 native tcp_connect--addr port: %u cb: %u\",\n-                         address.sin_port as uint, after_connect_cb as uint));\n-        ret rustrt::rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n-                                    after_connect_cb, addr_ptr);\n-    }\n-    // FIXME ref #2064\n-    unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t,\n-                       addr_ptr: *sockaddr_in) -> libc::c_int {\n-        ret rustrt::rust_uv_tcp_bind(tcp_server_ptr,\n-                                     addr_ptr);\n-    }\n-\n-    unsafe fn listen(stream: *libc::c_void, backlog: libc::c_int,\n-                     cb: *u8) -> libc::c_int {\n-        ret rustrt::rust_uv_listen(stream, backlog, cb);\n-    }\n-\n-    unsafe fn accept(server: *libc::c_void, client: *libc::c_void)\n-        -> libc::c_int {\n-        ret rustrt::rust_uv_accept(server, client);\n-    }\n-\n-    unsafe fn write(req: *libc::c_void, stream: *libc::c_void,\n-             buf_in: *[uv_buf_t], cb: *u8) -> libc::c_int {\n-        let buf_ptr = vec::unsafe::to_ptr(*buf_in);\n-        let buf_cnt = vec::len(*buf_in) as i32;\n-        ret rustrt::rust_uv_write(req, stream, buf_ptr, buf_cnt, cb);\n-    }\n-    unsafe fn read_start(stream: *uv_stream_t, on_alloc: *u8,\n-                         on_read: *u8) -> libc::c_int {\n-        ret rustrt::rust_uv_read_start(stream as *libc::c_void,\n-                                       on_alloc, on_read);\n-    }\n-\n-    unsafe fn read_stop(stream: *uv_stream_t) -> libc::c_int {\n-        ret rustrt::rust_uv_read_stop(stream as *libc::c_void);\n-    }\n-\n-    unsafe fn last_error(loop_handle: *libc::c_void) -> uv_err_t {\n-        ret rustrt::rust_uv_last_error(loop_handle);\n-    }\n-\n-    unsafe fn strerror(err: *uv_err_t) -> *libc::c_char {\n-        ret rustrt::rust_uv_strerror(err);\n-    }\n-    unsafe fn err_name(err: *uv_err_t) -> *libc::c_char {\n-        ret rustrt::rust_uv_err_name(err);\n-    }\n+// these are processed solely in the\n+// process_operation() crust fn below\n+enum uv_operation {\n+    op_async_init([u8]),\n+    op_close(uv_handle, *libc::c_void),\n+    op_timer_init([u8]),\n+    op_timer_start([u8], *libc::c_void, u32, u32),\n+    op_timer_stop([u8], *libc::c_void, fn~(uv_handle)),\n+    op_teardown(*libc::c_void)\n+}\n \n-    unsafe fn async_init(loop_handle: *libc::c_void,\n-                         async_handle: *uv_async_t,\n-                         cb: *u8) -> libc::c_int {\n-        ret rustrt::rust_uv_async_init(loop_handle,\n-                                       async_handle,\n-                                       cb);\n-    }\n+enum uv_handle {\n+    uv_async([u8], uv_loop),\n+    uv_timer([u8], uv_loop),\n+}\n \n-    unsafe fn async_send(async_handle: *uv_async_t) {\n-        ret rustrt::rust_uv_async_send(async_handle);\n-    }\n+enum uv_msg {\n+    // requests from library users\n+    msg_run(comm::chan<bool>),\n+    msg_run_in_bg(),\n+    msg_async_init(fn~(uv_handle), fn~(uv_handle)),\n+    msg_async_send([u8]),\n+    msg_close(uv_handle, fn~()),\n+    msg_timer_init(fn~(uv_handle)),\n+    msg_timer_start([u8], u32, u32, fn~(uv_handle)),\n+    msg_timer_stop([u8], fn~(uv_handle)),\n \n-    // libuv struct initializers\n-    unsafe fn tcp_t() -> uv_tcp_t {\n-        ret gen_stub_uv_tcp_t();\n-    }\n-    unsafe fn connect_t() -> uv_connect_t {\n-        ret gen_stub_uv_connect_t();\n-    }\n-    unsafe fn write_t() -> uv_write_t {\n-        ret gen_stub_uv_write_t();\n-    }\n-    unsafe fn async_t() -> uv_async_t {\n-        ret gen_stub_uv_async_t();\n-    }\n-    unsafe fn get_loop_for_uv_handle(handle: *libc::c_void)\n-        -> *libc::c_void {\n-        ret rustrt::rust_uv_get_loop_for_uv_handle(handle);\n-    }\n-    unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t)\n-        -> *uv_stream_t {\n-        ret rustrt::rust_uv_get_stream_handle_from_connect_req(\n-            connect);\n-    }\n-    unsafe fn get_stream_handle_from_write_req(\n-        write_req: *uv_write_t)\n-        -> *uv_stream_t {\n-        ret rustrt::rust_uv_get_stream_handle_from_write_req(\n-            write_req);\n-    }\n+    // dispatches from libuv\n+    uv_async_init([u8], *libc::c_void),\n+    uv_async_send([u8]),\n+    uv_close([u8]),\n+    uv_timer_init([u8], *libc::c_void),\n+    uv_timer_call([u8]),\n+    uv_timer_stop([u8], fn~(uv_handle)),\n+    uv_end(),\n+    uv_teardown_check()\n+}\n \n-    unsafe fn get_data_for_uv_handle(handle: *libc::c_void) -> *libc::c_void {\n-        ret rustrt::rust_uv_get_data_for_uv_handle(handle);\n-    }\n-    unsafe fn set_data_for_uv_handle(handle: *libc::c_void,\n-                        data: *libc::c_void) {\n-        rustrt::rust_uv_set_data_for_uv_handle(handle, data);\n-    }\n-    unsafe fn get_data_for_req(req: *libc::c_void) -> *libc::c_void {\n-        ret rustrt::rust_uv_get_data_for_req(req);\n-    }\n-    unsafe fn set_data_for_req(req: *libc::c_void,\n-                        data: *libc::c_void) {\n-        rustrt::rust_uv_set_data_for_req(req, data);\n-    }\n-    unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n-        ret rustrt::rust_uv_get_base_from_buf(buf);\n-    }\n-    unsafe fn get_len_from_buf(buf: uv_buf_t) -> libc::size_t {\n-        ret rustrt::rust_uv_get_len_from_buf(buf);\n-    }\n-    unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n-        ret rustrt::rust_uv_buf_init(input, len);\n-    }\n-    unsafe fn ip4_addr(ip: str, port: int)\n-    -> sockaddr_in {\n-        let mut addr_vec = str::bytes(ip);\n-        addr_vec += [0u8]; // add null terminator\n-        let addr_vec_ptr = vec::unsafe::to_ptr(addr_vec);\n-        let ip_back = str::from_bytes(addr_vec);\n-        io::println(#fmt(\"vec val: '%s' length: %u\",\n-                         ip_back, vec::len(addr_vec)));\n-        ret rustrt::rust_uv_ip4_addr(addr_vec_ptr,\n-                                     port as libc::c_int);\n-    }\n-    unsafe fn malloc_buf_base_of(suggested_size: libc::size_t)\n-        -> *u8 {\n-        ret rustrt::rust_uv_malloc_buf_base_of(suggested_size);\n-    }\n-    unsafe fn free_base_of_buf(buf: uv_buf_t) {\n-        rustrt::rust_uv_free_base_of_buf(buf);\n-    }\n+type uv_loop_data = {\n+    operation_port: comm::port<uv_operation>,\n+    rust_loop_chan: comm::chan<uv_msg>\n+};\n \n-    unsafe fn print_last_err_info(uv_loop: *libc::c_void) {\n-        let err = direct::last_error(uv_loop);\n-        let err_ptr = ptr::addr_of(err);\n-        let err_name = str::unsafe::from_c_str(direct::err_name(err_ptr));\n-        let err_msg = str::unsafe::from_c_str(direct::strerror(err_ptr));\n-        io::println(#fmt(\"LIBUV ERROR: name: %s msg: %s\",\n-                        err_name, err_msg));\n-    }\n+enum uv_loop {\n+    uv_loop_new(comm::chan<uv_msg>, *libc::c_void)\n }\n \n // public functions\n@@ -934,7 +474,7 @@ fn pass_to_libuv(\n     do_send(op_handle);\n }\n fn do_send(h: *libc::c_void) {\n-    rustrt::rust_uv_async_send(h as *uv_async_t);\n+    rustrt::rust_uv_async_send(h as *ll::uv_async_t);\n }\n fn gen_handle_id() -> [u8] {\n     ret rand::rng().gen_bytes(16u);\n@@ -1162,8 +702,8 @@ enum tcp_read_data {\n }\n \n type request_wrapper = {\n-    write_req: *uv_write_t,\n-    req_buf: *[uv_buf_t],\n+    write_req: *ll::uv_write_t,\n+    req_buf: *[ll::uv_buf_t],\n     read_chan: *comm::chan<str>\n };\n \n@@ -1172,30 +712,31 @@ crust fn after_close_cb(handle: *libc::c_void) {\n }\n \n crust fn on_alloc_cb(handle: *libc::c_void,\n-                     suggested_size: libc::size_t) -> uv_buf_t\n-    unsafe {\n+                     suggested_size: libc::size_t)\n+    -> ll::uv_buf_t unsafe {\n     io::println(\"on_alloc_cb!\");\n-    let char_ptr = direct::malloc_buf_base_of(suggested_size);\n-    ret direct::buf_init(char_ptr, suggested_size);\n+    let char_ptr = ll::malloc_buf_base_of(suggested_size);\n+    ret ll::buf_init(char_ptr, suggested_size);\n }\n \n-crust fn on_read_cb(stream: *uv_stream_t, nread: libc::ssize_t,\n-                    ++buf: uv_buf_t) unsafe {\n+crust fn on_read_cb(stream: *ll::uv_stream_t,\n+                    nread: libc::ssize_t,\n+                    ++buf: ll::uv_buf_t) unsafe {\n     io::println(#fmt(\"CLIENT entering on_read_cb nred: %d\", nread));\n     if (nread > 0) {\n         // we have data\n         io::println(#fmt(\"CLIENT read: data! nread: %d\", nread));\n-        direct::read_stop(stream);\n-        let client_data = direct::\n+        ll::read_stop(stream);\n+        let client_data = ll::\n             get_data_for_uv_handle(stream as *libc::c_void)\n               as *request_wrapper;\n-        let buf_base = direct::get_base_from_buf(buf);\n-        let buf_len = direct::get_len_from_buf(buf);\n+        let buf_base = ll::get_base_from_buf(buf);\n+        let buf_len = ll::get_len_from_buf(buf);\n         let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n         let read_chan = *((*client_data).read_chan);\n         let msg_from_server = str::from_bytes(bytes);\n         comm::send(read_chan, msg_from_server);\n-        direct::close(stream as *libc::c_void, after_close_cb)\n+        ll::close(stream as *libc::c_void, after_close_cb)\n     }\n     else if (nread == -1) {\n         // err .. possibly EOF\n@@ -1206,58 +747,59 @@ crust fn on_read_cb(stream: *uv_stream_t, nread: libc::ssize_t,\n         io::println(\"read: do nothing!\");\n     }\n     // when we're done\n-    direct::free_base_of_buf(buf);\n+    ll::free_base_of_buf(buf);\n     io::println(\"CLIENT exiting on_read_cb\");\n }\n \n-crust fn on_write_complete_cb(write_req: *uv_write_t,\n+crust fn on_write_complete_cb(write_req: *ll::uv_write_t,\n                               status: libc::c_int) unsafe {\n     io::println(#fmt(\"CLIENT beginning on_write_complete_cb status: %d\",\n                      status as int));\n-    let stream = direct::get_stream_handle_from_write_req(write_req);\n+    let stream = ll::get_stream_handle_from_write_req(write_req);\n     io::println(#fmt(\"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n         stream as int, write_req as int));\n-    let result = direct::read_start(stream, on_alloc_cb, on_read_cb);\n+    let result = ll::read_start(stream, on_alloc_cb, on_read_cb);\n     io::println(#fmt(\"CLIENT ending on_write_complete_cb .. status: %d\",\n                      result as int));\n }\n \n-crust fn on_connect_cb(connect_req_ptr: *uv_connect_t,\n+crust fn on_connect_cb(connect_req_ptr: *ll::uv_connect_t,\n                              status: libc::c_int) unsafe {\n     io::println(#fmt(\"beginning on_connect_cb .. status: %d\",\n                      status as int));\n     let stream =\n-        direct::get_stream_handle_from_connect_req(connect_req_ptr);\n+        ll::get_stream_handle_from_connect_req(connect_req_ptr);\n     if (status == 0i32) {\n         io::println(\"on_connect_cb: in status=0 if..\");\n-        let client_data = direct::get_data_for_req(\n+        let client_data = ll::get_data_for_req(\n             connect_req_ptr as *libc::c_void)\n             as *request_wrapper;\n         let write_handle = (*client_data).write_req as *libc::c_void;\n         io::println(#fmt(\"on_connect_cb: tcp stream: %d write_handle addr %d\",\n                         stream as int, write_handle as int));\n-        let write_result = direct::write(write_handle,\n+        let write_result = ll::write(write_handle,\n                           stream as *libc::c_void,\n                           (*client_data).req_buf,\n                           on_write_complete_cb);\n-        io::println(#fmt(\"on_connect_cb: direct::write() status: %d\",\n+        io::println(#fmt(\"on_connect_cb: ll::write() status: %d\",\n                          write_result as int));\n     }\n     else {\n-        let test_loop = direct::get_loop_for_uv_handle(\n+        let test_loop = ll::get_loop_for_uv_handle(\n             stream as *libc::c_void);\n-        direct::print_last_err_info(test_loop);\n+        let err_msg = ll::get_last_err_info(test_loop);\n+        io::println(err_msg);\n         assert false;\n     }\n     io::println(\"finishing on_connect_cb\");\n }\n \n fn impl_uv_tcp_request(ip: str, port: int, req_str: str,\n                       client_chan: *comm::chan<str>) unsafe {\n-    let test_loop = direct::loop_new();\n-    let tcp_handle = direct::tcp_t();\n+    let test_loop = ll::loop_new();\n+    let tcp_handle = ll::tcp_t();\n     let tcp_handle_ptr = ptr::addr_of(tcp_handle);\n-    let connect_handle = direct::connect_t();\n+    let connect_handle = ll::connect_t();\n     let connect_req_ptr = ptr::addr_of(connect_handle);\n \n     // this is the persistent payload of data that we\n@@ -1268,11 +810,11 @@ fn impl_uv_tcp_request(ip: str, port: int, req_str: str,\n     let req_str_bytes = str::bytes(req_str);\n     let req_msg_ptr: *u8 = vec::unsafe::to_ptr(req_str_bytes);\n     let req_msg = [\n-        direct::buf_init(req_msg_ptr, vec::len(req_str_bytes))\n+        ll::buf_init(req_msg_ptr, vec::len(req_str_bytes))\n     ];\n     // this is the enclosing record, we'll pass a ptr to\n     // this to C..\n-    let write_handle = direct::write_t();\n+    let write_handle = ll::write_t();\n     let write_handle_ptr = ptr::addr_of(write_handle);\n     io::println(#fmt(\"tcp req: tcp stream: %d write_handle: %d\",\n                      tcp_handle_ptr as int,\n@@ -1281,13 +823,13 @@ fn impl_uv_tcp_request(ip: str, port: int, req_str: str,\n                 req_buf: ptr::addr_of(req_msg),\n                 read_chan: client_chan };\n \n-    let tcp_init_result = direct::tcp_init(\n+    let tcp_init_result = ll::tcp_init(\n         test_loop as *libc::c_void, tcp_handle_ptr);\n     if (tcp_init_result == 0i32) {\n         io::println(\"sucessful tcp_init_result\");\n \n         io::println(\"building addr...\");\n-        let addr = direct::ip4_addr(ip, port);\n+        let addr = ll::ip4_addr(ip, port);\n         // FIXME ref #2064\n         let addr_ptr = ptr::addr_of(addr);\n         io::println(#fmt(\"after build addr in rust. port: %u\",\n@@ -1296,32 +838,32 @@ fn impl_uv_tcp_request(ip: str, port: int, req_str: str,\n         // this should set up the connection request..\n         io::println(#fmt(\"before calling tcp_connect .. connect cb ptr: %u \",\n                         on_connect_cb as uint));\n-        let tcp_connect_result = direct::tcp_connect(\n+        let tcp_connect_result = ll::tcp_connect(\n             connect_req_ptr, tcp_handle_ptr,\n             addr_ptr, on_connect_cb);\n         if (tcp_connect_result == 0i32) {\n             // not set the data on the connect_req\n             // until its initialized\n-            direct::set_data_for_req(\n+            ll::set_data_for_req(\n                 connect_req_ptr as *libc::c_void,\n                 ptr::addr_of(client_data) as *libc::c_void);\n-            direct::set_data_for_uv_handle(\n+            ll::set_data_for_uv_handle(\n                 tcp_handle_ptr as *libc::c_void,\n                 ptr::addr_of(client_data) as *libc::c_void);\n             io::println(\"before run tcp req loop\");\n-            direct::run(test_loop);\n+            ll::run(test_loop);\n             io::println(\"after run tcp req loop\");\n         }\n         else {\n-           io::println(\"direct::tcp_connect() failure\");\n+           io::println(\"ll::tcp_connect() failure\");\n            assert false;\n         }\n     }\n     else {\n-        io::println(\"direct::tcp_init() failure\");\n+        io::println(\"ll::tcp_init() failure\");\n         assert false;\n     }\n-    direct::loop_delete(test_loop);\n+    ll::loop_delete(test_loop);\n \n }\n \n@@ -1332,60 +874,60 @@ crust fn server_after_close_cb(handle: *libc::c_void) unsafe {\n crust fn client_stream_after_close_cb(handle: *libc::c_void)\n     unsafe {\n     io::println(\"SERVER: closed client stream, now closing server stream\");\n-    let client_data = direct::get_data_for_uv_handle(\n+    let client_data = ll::get_data_for_uv_handle(\n         handle) as\n         *tcp_server_data;\n-    direct::close((*client_data).server as *libc::c_void,\n+    ll::close((*client_data).server as *libc::c_void,\n                   server_after_close_cb);\n }\n \n-crust fn after_server_resp_write(req: *uv_write_t) unsafe {\n+crust fn after_server_resp_write(req: *ll::uv_write_t) unsafe {\n     let client_stream_ptr =\n-        direct::get_stream_handle_from_write_req(req);\n-    let client_data = direct::get_data_for_uv_handle(\n+        ll::get_stream_handle_from_write_req(req);\n+    let client_data = ll::get_data_for_uv_handle(\n         client_stream_ptr as *libc::c_void) as\n         *tcp_server_data;\n     io::println(\"SERVER: resp sent... closing client stream\");\n-    direct::close(client_stream_ptr as *libc::c_void,\n+    ll::close(client_stream_ptr as *libc::c_void,\n                   client_stream_after_close_cb)\n }\n \n-crust fn on_server_read_cb(client_stream_ptr: *uv_stream_t,\n+crust fn on_server_read_cb(client_stream_ptr: *ll::uv_stream_t,\n                            nread: libc::ssize_t,\n-                           ++buf: uv_buf_t) unsafe {\n+                           ++buf: ll::uv_buf_t) unsafe {\n     if (nread > 0) {\n         // we have data\n         io::println(#fmt(\"SERVER read: data! nread: %d\", nread));\n \n         // pull out the contents of the write from the client\n-        let buf_base = direct::get_base_from_buf(buf);\n-        let buf_len = direct::get_len_from_buf(buf);\n+        let buf_base = ll::get_base_from_buf(buf);\n+        let buf_len = ll::get_len_from_buf(buf);\n         let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n         let request_str = str::from_bytes(bytes);\n \n-        let client_data = direct::get_data_for_uv_handle(\n+        let client_data = ll::get_data_for_uv_handle(\n             client_stream_ptr as *libc::c_void) as *tcp_server_data;\n \n         let server_kill_msg = (*client_data).server_kill_msg;\n         let write_req = (*client_data).server_write_req;\n         if (str::contains(request_str, server_kill_msg)) {\n             io::println(\"SERVER: client request contains server_kill_msg!\");\n             io::println(\"SERVER: sending response to client\");\n-            direct::read_stop(client_stream_ptr);\n+            ll::read_stop(client_stream_ptr);\n             let server_chan = *((*client_data).server_chan);\n             comm::send(server_chan, request_str);\n-            let write_result = direct::write(\n+            let write_result = ll::write(\n                 write_req as *libc::c_void,\n                 client_stream_ptr as *libc::c_void,\n                 (*client_data).server_resp_buf,\n                 after_server_resp_write);\n             io::println(#fmt(\"SERVER: resp write result: %d\",\n                         write_result as int));\n             if (write_result != 0i32) {\n-                io::println(\"bad result for server resp direct::write()\");\n-                direct::print_last_err_info(\n-                    direct::get_loop_for_uv_handle(client_stream_ptr\n-                        as *libc::c_void));\n+                io::println(\"bad result for server resp ll::write()\");\n+                io::println(ll::get_last_err_info(\n+                    ll::get_loop_for_uv_handle(client_stream_ptr\n+                        as *libc::c_void)));\n                 assert false;\n             }\n         }\n@@ -1402,33 +944,34 @@ crust fn on_server_read_cb(client_stream_ptr: *uv_stream_t,\n         io::println(\"read: do nothing!\");\n     }\n     // when we're done\n-    direct::free_base_of_buf(buf);\n+    ll::free_base_of_buf(buf);\n     io::println(\"SERVER exiting on_read_cb\");\n }\n \n-crust fn server_connection_cb(server_stream_ptr: *uv_stream_t,\n+crust fn server_connection_cb(server_stream_ptr:\n+                                *ll::uv_stream_t,\n                               status: libc::c_int) unsafe {\n     io::println(\"client connecting!\");\n-    let test_loop = direct::get_loop_for_uv_handle(\n+    let test_loop = ll::get_loop_for_uv_handle(\n                            server_stream_ptr as *libc::c_void);\n-    let server_data = direct::get_data_for_uv_handle(\n+    let server_data = ll::get_data_for_uv_handle(\n         server_stream_ptr as *libc::c_void) as *tcp_server_data;\n     let client_stream_ptr = (*server_data).client;\n-    let client_init_result = direct::tcp_init(test_loop,\n+    let client_init_result = ll::tcp_init(test_loop,\n                                               client_stream_ptr);\n-    direct::set_data_for_uv_handle(\n+    ll::set_data_for_uv_handle(\n         client_stream_ptr as *libc::c_void,\n         server_data as *libc::c_void);\n     if (client_init_result == 0i32) {\n         io::println(\"successfully initialized client stream\");\n-        let accept_result = direct::accept(server_stream_ptr as\n+        let accept_result = ll::accept(server_stream_ptr as\n                                              *libc::c_void,\n                                            client_stream_ptr as\n                                              *libc::c_void);\n         if (accept_result == 0i32) {\n             // start reading\n-            let read_result = direct::read_start(client_stream_ptr\n-                                                   as *uv_stream_t,\n+            let read_result = ll::read_start(\n+                client_stream_ptr as *ll::uv_stream_t,\n                                                  on_alloc_cb,\n                                                  on_server_read_cb);\n             if (read_result == 0i32) {\n@@ -1454,12 +997,12 @@ crust fn server_connection_cb(server_stream_ptr: *uv_stream_t,\n }\n \n type tcp_server_data = {\n-    client: *uv_tcp_t,\n-    server: *uv_tcp_t,\n+    client: *ll::uv_tcp_t,\n+    server: *ll::uv_tcp_t,\n     server_kill_msg: str,\n-    server_resp_buf: *[uv_buf_t],\n+    server_resp_buf: *[ll::uv_buf_t],\n     server_chan: *comm::chan<str>,\n-    server_write_req: *uv_write_t\n+    server_write_req: *ll::uv_write_t\n };\n \n type async_handle_data = {\n@@ -1470,17 +1013,17 @@ crust fn async_close_cb(handle: *libc::c_void) {\n     io::println(\"SERVER: closing async cb...\");\n }\n \n-crust fn continue_async_cb(async_handle: *uv_async_t,\n+crust fn continue_async_cb(async_handle: *ll::uv_async_t,\n                            status: libc::c_int) unsafe {\n     // once we're in the body of this callback,\n     // the tcp server's loop is set up, so we\n     // can continue on to let the tcp client\n     // do its thang\n-    let data = direct::get_data_for_uv_handle(\n+    let data = ll::get_data_for_uv_handle(\n         async_handle as *libc::c_void) as *async_handle_data;\n     let continue_chan = *((*data).continue_chan);\n     comm::send(continue_chan, true);\n-    direct::close(async_handle as *libc::c_void, async_close_cb);\n+    ll::close(async_handle as *libc::c_void, async_close_cb);\n }\n \n fn impl_uv_tcp_server(server_ip: str,\n@@ -1489,23 +1032,23 @@ fn impl_uv_tcp_server(server_ip: str,\n                       server_resp_msg: str,\n                       server_chan: *comm::chan<str>,\n                       continue_chan: *comm::chan<bool>) unsafe {\n-    let test_loop = direct::loop_new();\n-    let tcp_server = direct::tcp_t();\n+    let test_loop = ll::loop_new();\n+    let tcp_server = ll::tcp_t();\n     let tcp_server_ptr = ptr::addr_of(tcp_server);\n \n-    let tcp_client = direct::tcp_t();\n+    let tcp_client = ll::tcp_t();\n     let tcp_client_ptr = ptr::addr_of(tcp_client);\n \n-    let server_write_req = direct::write_t();\n+    let server_write_req = ll::write_t();\n     let server_write_req_ptr = ptr::addr_of(server_write_req);\n \n     let resp_str_bytes = str::bytes(server_resp_msg);\n     let resp_msg_ptr: *u8 = vec::unsafe::to_ptr(resp_str_bytes);\n     let resp_msg = [\n-        direct::buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n+        ll::buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n     ];\n \n-    let continue_async_handle = direct::async_t();\n+    let continue_async_handle = ll::async_t();\n     let continue_async_handle_ptr =\n         ptr::addr_of(continue_async_handle);\n     let async_data =\n@@ -1521,41 +1064,41 @@ fn impl_uv_tcp_server(server_ip: str,\n         server_write_req: server_write_req_ptr\n     };\n     let server_data_ptr = ptr::addr_of(server_data);\n-    direct::set_data_for_uv_handle(tcp_server_ptr as *libc::c_void,\n+    ll::set_data_for_uv_handle(tcp_server_ptr as *libc::c_void,\n                                    server_data_ptr as *libc::c_void);\n \n     // uv_tcp_init()\n-    let tcp_init_result = direct::tcp_init(\n+    let tcp_init_result = ll::tcp_init(\n         test_loop as *libc::c_void, tcp_server_ptr);\n     if (tcp_init_result == 0i32) {\n-        let server_addr = direct::ip4_addr(server_ip, server_port);\n+        let server_addr = ll::ip4_addr(server_ip, server_port);\n         // FIXME ref #2064\n         let server_addr_ptr = ptr::addr_of(server_addr);\n \n         // uv_tcp_bind()\n-        let bind_result = direct::tcp_bind(tcp_server_ptr,\n+        let bind_result = ll::tcp_bind(tcp_server_ptr,\n                                            server_addr_ptr);\n         if (bind_result == 0i32) {\n             io::println(\"successful uv_tcp_bind, listening\");\n \n             // uv_listen()\n-            let listen_result = direct::listen(tcp_server_ptr as\n+            let listen_result = ll::listen(tcp_server_ptr as\n                                                  *libc::c_void,\n                                                128i32,\n                                                server_connection_cb);\n             if (listen_result == 0i32) {\n                 // let the test know it can set up the tcp server,\n                 // now.. this may still present a race, not sure..\n-                let async_result = direct::async_init(test_loop,\n+                let async_result = ll::async_init(test_loop,\n                                    continue_async_handle_ptr,\n                                    continue_async_cb);\n                 if (async_result == 0i32) {\n-                    direct::set_data_for_uv_handle(\n+                    ll::set_data_for_uv_handle(\n                         continue_async_handle_ptr as *libc::c_void,\n                         async_data_ptr as *libc::c_void);\n-                    direct::async_send(continue_async_handle_ptr);\n+                    ll::async_send(continue_async_handle_ptr);\n                     // uv_run()\n-                    direct::run(test_loop);\n+                    ll::run(test_loop);\n                     io::println(\"server uv::run() has returned\");\n                 }\n                 else {\n@@ -1581,7 +1124,7 @@ fn impl_uv_tcp_server(server_ip: str,\n                     tcp_init_result as int));\n         assert false;\n     }\n-    direct::loop_delete(test_loop);\n+    ll::loop_delete(test_loop);\n }\n \n #[test]\n@@ -1632,7 +1175,7 @@ fn test_uv_tcp_server_and_request() unsafe {\n #[ignore(cfg(target_os = \"freebsd\"))]\n fn test_uv_struct_size_uv_tcp_t() {\n     let native_handle_size = rustrt::rust_uv_helper_uv_tcp_t_size();\n-    let rust_handle_size = sys::size_of::<uv_tcp_t>();\n+    let rust_handle_size = sys::size_of::<ll::uv_tcp_t>();\n     let output = #fmt(\"uv_tcp_t -- native: %u rust: %u\",\n                       native_handle_size as uint, rust_handle_size);\n     io::println(output);\n@@ -1643,7 +1186,7 @@ fn test_uv_struct_size_uv_tcp_t() {\n fn test_uv_struct_size_uv_connect_t() {\n     let native_handle_size =\n         rustrt::rust_uv_helper_uv_connect_t_size();\n-    let rust_handle_size = sys::size_of::<uv_connect_t>();\n+    let rust_handle_size = sys::size_of::<ll::uv_connect_t>();\n     let output = #fmt(\"uv_connect_t -- native: %u rust: %u\",\n                       native_handle_size as uint, rust_handle_size);\n     io::println(output);\n@@ -1654,7 +1197,7 @@ fn test_uv_struct_size_uv_connect_t() {\n fn test_uv_struct_size_uv_buf_t() {\n     let native_handle_size =\n         rustrt::rust_uv_helper_uv_buf_t_size();\n-    let rust_handle_size = sys::size_of::<uv_buf_t>();\n+    let rust_handle_size = sys::size_of::<ll::uv_buf_t>();\n     let output = #fmt(\"uv_buf_t -- native: %u rust: %u\",\n                       native_handle_size as uint, rust_handle_size);\n     io::println(output);\n@@ -1665,7 +1208,7 @@ fn test_uv_struct_size_uv_buf_t() {\n fn test_uv_struct_size_uv_write_t() {\n     let native_handle_size =\n         rustrt::rust_uv_helper_uv_write_t_size();\n-    let rust_handle_size = sys::size_of::<uv_write_t>();\n+    let rust_handle_size = sys::size_of::<ll::uv_write_t>();\n     let output = #fmt(\"uv_write_t -- native: %u rust: %u\",\n                       native_handle_size as uint, rust_handle_size);\n     io::println(output);\n@@ -1677,7 +1220,7 @@ fn test_uv_struct_size_uv_write_t() {\n fn test_uv_struct_size_sockaddr_in() {\n     let native_handle_size =\n         rustrt::rust_uv_helper_sockaddr_in_size();\n-    let rust_handle_size = sys::size_of::<sockaddr_in>();\n+    let rust_handle_size = sys::size_of::<ll::sockaddr_in>();\n     let output = #fmt(\"sockaddr_in -- native: %u rust: %u\",\n                       native_handle_size as uint, rust_handle_size);\n     io::println(output);\n@@ -1689,7 +1232,7 @@ fn test_uv_struct_size_sockaddr_in() {\n fn test_uv_struct_size_uv_async_t() {\n     let native_handle_size =\n         rustrt::rust_uv_helper_uv_async_t_size();\n-    let rust_handle_size = sys::size_of::<uv_async_t>();\n+    let rust_handle_size = sys::size_of::<ll::uv_async_t>();\n     let output = #fmt(\"uv_async_t -- native: %u rust: %u\",\n                       native_handle_size as uint, rust_handle_size);\n     io::println(output);"}, {"sha": "520298ca5c0d2ea42e1a832a026804eff94d3c90", "filename": "src/libstd/uv_ll.rs", "status": "added", "additions": 526, "deletions": 0, "changes": 526, "blob_url": "https://github.com/rust-lang/rust/blob/7c0fed469f70fffc7164539ba9e6e28bf84371a3/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c0fed469f70fffc7164539ba9e6e28bf84371a3/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=7c0fed469f70fffc7164539ba9e6e28bf84371a3", "patch": "@@ -0,0 +1,526 @@\n+// libuv struct mappings\n+type uv_ip4_addr = {\n+    ip: [u8],\n+    port: int\n+};\n+type uv_ip6_addr = uv_ip4_addr;\n+\n+enum uv_handle_type {\n+    UNKNOWN_HANDLE = 0,\n+    UV_TCP,\n+    UV_UDP,\n+    UV_NAMED_PIPE,\n+    UV_TTY,\n+    UV_FILE,\n+    UV_TIMER,\n+    UV_PREPARE,\n+    UV_CHECK,\n+    UV_IDLE,\n+    UV_ASYNC,\n+    UV_ARES_TASK,\n+    UV_ARES_EVENT,\n+    UV_PROCESS,\n+    UV_FS_EVENT\n+}\n+\n+type handle_type = libc::c_uint;\n+\n+type uv_handle_fields = {\n+   loop_handle: *libc::c_void,\n+   type_: handle_type,\n+   close_cb: *u8,\n+   mut data: *libc::c_void,\n+};\n+\n+// unix size: 8\n+type uv_err_t = {\n+    code: libc::c_int,\n+    sys_errno_: libc::c_int\n+};\n+\n+// don't create one of these directly. instead,\n+// count on it appearing in libuv callbacks or embedded\n+// in other types as a pointer to be used in other\n+// operations (so mostly treat it as opaque, once you\n+// have it in this form..)\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"win32\")]\n+type uv_stream_t = {\n+    fields: uv_handle_fields\n+};\n+\n+// unix size: 272\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+type uv_tcp_t = {\n+    fields: uv_handle_fields,\n+    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n+    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n+    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n+    a12: *u8, a13: *u8, a14: *u8, a15: *u8,\n+    a16: *u8, a17: *u8, a18: *u8, a19: *u8,\n+    a20: *u8, a21: *u8, a22: *u8, a23: *u8,\n+    a24: *u8, a25: *u8, a26: *u8, a27: *u8,\n+    a28: *u8, a29: *u8\n+};\n+// win32 size: 240 (120)\n+#[cfg(target_os = \"win32\")]\n+type uv_tcp_t = {\n+    fields: uv_handle_fields,\n+    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n+    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n+    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n+    a12: *u8, a13: *u8, a14: *u8, a15: *u8,\n+    a16: *u8, a17: *u8, a18: *u8, a19: *u8,\n+    a20: *u8, a21: *u8, a22: *u8, a23: *u8,\n+    a24: *u8, a25: *u8\n+};\n+\n+// unix size: 48\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+type uv_connect_t = {\n+    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n+    a04: *u8, a05: *u8\n+};\n+// win32 size: 88 (44)\n+#[cfg(target_os = \"win32\")]\n+type uv_connect_t = {\n+    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n+    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n+    a08: *u8, a09: *u8, a10: *u8\n+};\n+\n+// unix size: 16\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"win32\")]\n+type uv_buf_t = {\n+    base: *u8,\n+    len: libc::size_t\n+};\n+// no gen stub method.. should create\n+// it via uv::direct::buf_init()\n+\n+// unix size: 144\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+type uv_write_t = {\n+    fields: uv_handle_fields,\n+    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n+    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n+    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n+    a12: *u8, a13: *u8\n+};\n+// win32 size: 136 (68)\n+#[cfg(target_os = \"win32\")]\n+type uv_write_t = {\n+    fields: uv_handle_fields,\n+    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n+    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n+    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n+    a12: *u8\n+};\n+// unix size: 120\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+type uv_async_t = {\n+    fields: uv_handle_fields,\n+    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n+    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n+    a08: *u8, a09: *u8, a10: *u8\n+};\n+// win32 size 132 (68)\n+#[cfg(target_os = \"win32\")]\n+type uv_async_t = {\n+    fields: uv_handle_fields,\n+    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n+    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n+    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n+    a12: *u8\n+};\n+\n+// unix size: 16\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"win32\")]\n+type sockaddr_in = {\n+    mut sin_family: u16,\n+    mut sin_port: u16,\n+    mut sin_addr: u32, // in_addr: this is an opaque, per-platform struct\n+    mut sin_zero: (u8, u8, u8, u8, u8, u8, u8, u8)\n+};\n+\n+// unix size: 28 .. make due w/ 32\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"win32\")]\n+type sockaddr_in6 = {\n+    a0: *u8, a1: *u8,\n+    a2: *u8, a3: *u8\n+};\n+\n+mod uv_ll_struct_stubgen {\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn gen_stub_uv_tcp_t() -> uv_tcp_t {\n+        ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+                        close_cb: ptr::null(),\n+                        mut data: ptr::null() },\n+            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n+            a03: 0 as *u8,\n+            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n+            a07: 0 as *u8,\n+            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n+            a11: 0 as *u8,\n+            a12: 0 as *u8, a13: 0 as *u8, a14: 0 as *u8,\n+            a15: 0 as *u8,\n+            a16: 0 as *u8, a17: 0 as *u8, a18: 0 as *u8,\n+            a19: 0 as *u8,\n+            a20: 0 as *u8, a21: 0 as *u8, a22: 0 as *u8,\n+            a23: 0 as *u8,\n+            a24: 0 as *u8, a25: 0 as *u8, a26: 0 as *u8,\n+            a27: 0 as *u8,\n+            a28: 0 as *u8, a29: 0 as *u8\n+        };\n+    }\n+    #[cfg(target_os = \"win32\")]\n+    fn gen_stub_uv_tcp_t() -> uv_tcp_t {\n+        ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+                        close_cb: ptr::null(),\n+                        mut data: ptr::null() },\n+            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n+            a03: 0 as *u8,\n+            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n+            a07: 0 as *u8,\n+            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n+            a11: 0 as *u8,\n+            a12: 0 as *u8, a13: 0 as *u8, a14: 0 as *u8,\n+            a15: 0 as *u8,\n+            a16: 0 as *u8, a17: 0 as *u8, a18: 0 as *u8,\n+            a19: 0 as *u8,\n+            a20: 0 as *u8, a21: 0 as *u8, a22: 0 as *u8,\n+            a23: 0 as *u8,\n+            a24: 0 as *u8, a25: 0 as *u8\n+        };\n+    }\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn gen_stub_uv_connect_t() -> uv_connect_t {\n+        ret {\n+            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n+            a03: 0 as *u8,\n+            a04: 0 as *u8, a05: 0 as *u8\n+        };\n+    }\n+    #[cfg(target_os = \"win32\")]\n+    fn gen_stub_uv_connect_t() -> uv_connect_t {\n+        ret {\n+            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n+            a03: 0 as *u8,\n+            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n+            a07: 0 as *u8,\n+            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8\n+        };\n+    }\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn gen_stub_uv_async_t() -> uv_async_t {\n+        ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+                        close_cb: ptr::null(),\n+                        mut data: ptr::null() },\n+            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n+            a03: 0 as *u8,\n+            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n+            a07: 0 as *u8,\n+            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8\n+        };\n+    }\n+    #[cfg(target_os = \"win32\")]\n+    fn gen_stub_uv_async_t() -> uv_async_t {\n+        ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+                        close_cb: ptr::null(),\n+                        mut data: ptr::null() },\n+            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n+            a03: 0 as *u8,\n+            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n+            a07: 0 as *u8,\n+            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n+            a11: 0 as *u8,\n+            a12: 0 as *u8\n+        };\n+    }\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn gen_stub_uv_write_t() -> uv_write_t {\n+        ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+                        close_cb: ptr::null(),\n+                        mut data: ptr::null() },\n+            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n+            a03: 0 as *u8,\n+            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n+            a07: 0 as *u8,\n+            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n+            a11: 0 as *u8,\n+            a12: 0 as *u8, a13: 0 as *u8\n+        };\n+    }\n+    #[cfg(target_os = \"win32\")]\n+    fn gen_stub_uv_write_t() -> uv_write_t {\n+        ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+                        close_cb: ptr::null(),\n+                        mut data: ptr::null() },\n+            a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n+            a03: 0 as *u8,\n+            a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n+            a07: 0 as *u8,\n+            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n+            a11: 0 as *u8,\n+            a12: 0 as *u8\n+        };\n+    }\n+}\n+\n+#[nolink]\n+native mod rustrt {\n+    fn rust_uv_loop_new() -> *libc::c_void;\n+    fn rust_uv_loop_delete(lp: *libc::c_void);\n+    fn rust_uv_run(loop_handle: *libc::c_void);\n+    fn rust_uv_close(handle: *libc::c_void, cb: *u8);\n+    fn rust_uv_async_send(handle: *uv_async_t);\n+    fn rust_uv_async_init(loop_handle: *libc::c_void,\n+                          async_handle: *uv_async_t,\n+                          cb: *u8) -> libc::c_int;\n+    fn rust_uv_tcp_init(\n+        loop_handle: *libc::c_void,\n+        handle_ptr: *uv_tcp_t) -> libc::c_int;\n+    fn rust_uv_buf_init(base: *u8, len: libc::size_t)\n+        -> uv_buf_t;\n+    fn rust_uv_last_error(loop_handle: *libc::c_void) -> uv_err_t;\n+    // FIXME ref #2064\n+    fn rust_uv_strerror(err: *uv_err_t) -> *libc::c_char;\n+    // FIXME ref #2064\n+    fn rust_uv_err_name(err: *uv_err_t) -> *libc::c_char;\n+    fn rust_uv_ip4_addr(ip: *u8, port: libc::c_int)\n+        -> sockaddr_in;\n+    // FIXME ref #2064\n+    fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n+                           tcp_handle_ptr: *uv_tcp_t,\n+                           ++after_cb: *u8,\n+                           ++addr: *sockaddr_in) -> libc::c_int;\n+    // FIXME ref 2064\n+    fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t,\n+                        ++addr: *sockaddr_in) -> libc::c_int;\n+    fn rust_uv_listen(stream: *libc::c_void, backlog: libc::c_int,\n+                      cb: *u8) -> libc::c_int;\n+    fn rust_uv_accept(server: *libc::c_void, client: *libc::c_void)\n+        -> libc::c_int;\n+    fn rust_uv_write(req: *libc::c_void, stream: *libc::c_void,\n+             ++buf_in: *uv_buf_t, buf_cnt: libc::c_int,\n+             cb: *u8) -> libc::c_int;\n+    fn rust_uv_read_start(stream: *libc::c_void, on_alloc: *u8,\n+                          on_read: *u8) -> libc::c_int;\n+    fn rust_uv_read_stop(stream: *libc::c_void) -> libc::c_int;\n+    fn rust_uv_malloc_buf_base_of(sug_size: libc::size_t) -> *u8;\n+    fn rust_uv_free_base_of_buf(++buf: uv_buf_t);\n+\n+    // data accessors for rust-mapped uv structs\n+    fn rust_uv_get_stream_handle_from_connect_req(\n+        connect_req: *uv_connect_t)\n+        -> *uv_stream_t;\n+    fn rust_uv_get_stream_handle_from_write_req(\n+        write_req: *uv_write_t)\n+        -> *uv_stream_t;\n+    fn rust_uv_get_loop_for_uv_handle(handle: *libc::c_void)\n+        -> *libc::c_void;\n+    fn rust_uv_get_data_for_uv_handle(handle: *libc::c_void)\n+        -> *libc::c_void;\n+    fn rust_uv_set_data_for_uv_handle(handle: *libc::c_void,\n+                                      data: *libc::c_void);\n+    fn rust_uv_get_data_for_req(req: *libc::c_void) -> *libc::c_void;\n+    fn rust_uv_set_data_for_req(req: *libc::c_void,\n+                                data: *libc::c_void);\n+    fn rust_uv_get_base_from_buf(++buf: uv_buf_t) -> *u8;\n+    fn rust_uv_get_len_from_buf(++buf: uv_buf_t) -> libc::size_t;\n+}\n+\n+unsafe fn loop_new() -> *libc::c_void {\n+    ret rustrt::rust_uv_loop_new();\n+}\n+\n+unsafe fn loop_delete(loop_handle: *libc::c_void) {\n+    rustrt::rust_uv_loop_delete(loop_handle);\n+}\n+\n+unsafe fn run(loop_handle: *libc::c_void) {\n+    rustrt::rust_uv_run(loop_handle);\n+}\n+\n+unsafe fn close(handle: *libc::c_void, cb: *u8) {\n+    rustrt::rust_uv_close(handle, cb);\n+}\n+\n+unsafe fn tcp_init(loop_handle: *libc::c_void, handle: *uv_tcp_t)\n+    -> libc::c_int {\n+    ret rustrt::rust_uv_tcp_init(loop_handle, handle);\n+}\n+// FIXME ref #2064\n+unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n+                      tcp_handle_ptr: *uv_tcp_t,\n+                      addr_ptr: *sockaddr_in,\n+                      ++after_connect_cb: *u8)\n+-> libc::c_int {\n+    let address = *addr_ptr;\n+    io::println(#fmt(\"b4 native tcp_connect--addr port: %u cb: %u\",\n+                     address.sin_port as uint, after_connect_cb as uint));\n+    ret rustrt::rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n+                                after_connect_cb, addr_ptr);\n+}\n+// FIXME ref #2064\n+unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t,\n+                   addr_ptr: *sockaddr_in) -> libc::c_int {\n+    ret rustrt::rust_uv_tcp_bind(tcp_server_ptr,\n+                                 addr_ptr);\n+}\n+\n+unsafe fn listen(stream: *libc::c_void, backlog: libc::c_int,\n+                 cb: *u8) -> libc::c_int {\n+    ret rustrt::rust_uv_listen(stream, backlog, cb);\n+}\n+\n+unsafe fn accept(server: *libc::c_void, client: *libc::c_void)\n+    -> libc::c_int {\n+    ret rustrt::rust_uv_accept(server, client);\n+}\n+\n+unsafe fn write(req: *libc::c_void, stream: *libc::c_void,\n+         buf_in: *[uv_buf_t], cb: *u8) -> libc::c_int {\n+    let buf_ptr = vec::unsafe::to_ptr(*buf_in);\n+    let buf_cnt = vec::len(*buf_in) as i32;\n+    ret rustrt::rust_uv_write(req, stream, buf_ptr, buf_cnt, cb);\n+}\n+unsafe fn read_start(stream: *uv_stream_t, on_alloc: *u8,\n+                     on_read: *u8) -> libc::c_int {\n+    ret rustrt::rust_uv_read_start(stream as *libc::c_void,\n+                                   on_alloc, on_read);\n+}\n+\n+unsafe fn read_stop(stream: *uv_stream_t) -> libc::c_int {\n+    ret rustrt::rust_uv_read_stop(stream as *libc::c_void);\n+}\n+\n+unsafe fn last_error(loop_handle: *libc::c_void) -> uv_err_t {\n+    ret rustrt::rust_uv_last_error(loop_handle);\n+}\n+\n+unsafe fn strerror(err: *uv_err_t) -> *libc::c_char {\n+    ret rustrt::rust_uv_strerror(err);\n+}\n+unsafe fn err_name(err: *uv_err_t) -> *libc::c_char {\n+    ret rustrt::rust_uv_err_name(err);\n+}\n+\n+unsafe fn async_init(loop_handle: *libc::c_void,\n+                     async_handle: *uv_async_t,\n+                     cb: *u8) -> libc::c_int {\n+    ret rustrt::rust_uv_async_init(loop_handle,\n+                                   async_handle,\n+                                   cb);\n+}\n+\n+unsafe fn async_send(async_handle: *uv_async_t) {\n+    ret rustrt::rust_uv_async_send(async_handle);\n+}\n+\n+// libuv struct initializers\n+unsafe fn tcp_t() -> uv_tcp_t {\n+    ret uv_ll_struct_stubgen::gen_stub_uv_tcp_t();\n+}\n+unsafe fn connect_t() -> uv_connect_t {\n+    ret uv_ll_struct_stubgen::gen_stub_uv_connect_t();\n+}\n+unsafe fn write_t() -> uv_write_t {\n+    ret uv_ll_struct_stubgen::gen_stub_uv_write_t();\n+}\n+unsafe fn async_t() -> uv_async_t {\n+    ret uv_ll_struct_stubgen::gen_stub_uv_async_t();\n+}\n+unsafe fn get_loop_for_uv_handle(handle: *libc::c_void)\n+    -> *libc::c_void {\n+    ret rustrt::rust_uv_get_loop_for_uv_handle(handle);\n+}\n+unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t)\n+    -> *uv_stream_t {\n+    ret rustrt::rust_uv_get_stream_handle_from_connect_req(\n+        connect);\n+}\n+unsafe fn get_stream_handle_from_write_req(\n+    write_req: *uv_write_t)\n+    -> *uv_stream_t {\n+    ret rustrt::rust_uv_get_stream_handle_from_write_req(\n+        write_req);\n+}\n+\n+unsafe fn get_data_for_uv_handle(handle: *libc::c_void) -> *libc::c_void {\n+    ret rustrt::rust_uv_get_data_for_uv_handle(handle);\n+}\n+unsafe fn set_data_for_uv_handle(handle: *libc::c_void,\n+                    data: *libc::c_void) {\n+    rustrt::rust_uv_set_data_for_uv_handle(handle, data);\n+}\n+unsafe fn get_data_for_req(req: *libc::c_void) -> *libc::c_void {\n+    ret rustrt::rust_uv_get_data_for_req(req);\n+}\n+unsafe fn set_data_for_req(req: *libc::c_void,\n+                    data: *libc::c_void) {\n+    rustrt::rust_uv_set_data_for_req(req, data);\n+}\n+unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n+    ret rustrt::rust_uv_get_base_from_buf(buf);\n+}\n+unsafe fn get_len_from_buf(buf: uv_buf_t) -> libc::size_t {\n+    ret rustrt::rust_uv_get_len_from_buf(buf);\n+}\n+unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n+    ret rustrt::rust_uv_buf_init(input, len);\n+}\n+unsafe fn ip4_addr(ip: str, port: int)\n+-> sockaddr_in {\n+    let mut addr_vec = str::bytes(ip);\n+    addr_vec += [0u8]; // add null terminator\n+    let addr_vec_ptr = vec::unsafe::to_ptr(addr_vec);\n+    let ip_back = str::from_bytes(addr_vec);\n+    io::println(#fmt(\"vec val: '%s' length: %u\",\n+                     ip_back, vec::len(addr_vec)));\n+    ret rustrt::rust_uv_ip4_addr(addr_vec_ptr,\n+                                 port as libc::c_int);\n+}\n+unsafe fn malloc_buf_base_of(suggested_size: libc::size_t)\n+    -> *u8 {\n+    ret rustrt::rust_uv_malloc_buf_base_of(suggested_size);\n+}\n+unsafe fn free_base_of_buf(buf: uv_buf_t) {\n+    rustrt::rust_uv_free_base_of_buf(buf);\n+}\n+\n+unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> str {\n+    let err = last_error(uv_loop);\n+    let err_ptr = ptr::addr_of(err);\n+    let err_name = str::unsafe::from_c_str(err_name(err_ptr));\n+    let err_msg = str::unsafe::from_c_str(strerror(err_ptr));\n+    ret #fmt(\"LIBUV ERROR: name: %s msg: %s\",\n+                    err_name, err_msg);\n+}\n\\ No newline at end of file"}]}