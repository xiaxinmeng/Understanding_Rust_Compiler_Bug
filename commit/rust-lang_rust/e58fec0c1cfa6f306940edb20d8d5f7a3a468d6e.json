{"sha": "e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1OGZlYzBjMWNmYTZmMzA2OTQwZWRiMjBkOGQ1ZjdhM2E0NjhkNmU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-03-22T14:48:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-22T14:48:35Z"}, "message": "Rollup merge of #70229 - matthiaskrgr:cl3ppy, r=Mark-Simulacrum\n\nmore clippy fixes\n\n* remove unused unit values (clippy::unused_unit)\n* make some let-if-bindings more idiomatic (clippy::useless_let_if_seq)\n* clarify when we pass () to functions (clippy::unit_arg)\n* don't redundantly repeat field names (clippy::redundant_field_names)\n* remove redundant returns (clippy::needless_return)\n* use let instead of match for matches with single bindings (clippy::match_single_binding)\n* don't convert results to options just for matching (clippy::if_let_some_result)", "tree": {"sha": "b4f2cd7e4685a986232f478b843ba90b6891638c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4f2cd7e4685a986232f478b843ba90b6891638c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJed3rDCRBK7hj4Ov3rIwAAdHIIAD6HXIN71/sLwAyk4MPmPxJ8\nRq+0nMFg48GFRdta0rktM8BqNxFVr6TXrohz4mvNL/wiA5zPNqK9D5pfFFeA2x1P\nx2SzTROznAd4z9JdAzgeTJWgpPfC9cBPIBvQtMz2o1DOdcbhqdN18yWHjv+P3dkY\n9kabV8Qhufk8Bm8uDQ7tN3GKjfRm3gbU63F5W/iw+tgevowBnPxcInEH0UGeTZNR\n/go/0KChPmAqImu/FcjYMt6SLJIyFO+mf7WM4f2XTOQLf2uxhIkY7hBECedlhLsi\npJgWX7VdQfzTvk2MC+qtFVRK9R5UWh2NyvRFTa6af9H4FMP8EafkSjXgvTTPYqQ=\n=Cx22\n-----END PGP SIGNATURE-----\n", "payload": "tree b4f2cd7e4685a986232f478b843ba90b6891638c\nparent 3c8f8b6304e6d8ec735f32a8286a1461f36feeb0\nparent e45fdcfa9a611e4b29b727fb1c70ea60423f1c24\nauthor Dylan DPC <dylan.dpc@gmail.com> 1584888515 +0100\ncommitter GitHub <noreply@github.com> 1584888515 +0100\n\nRollup merge of #70229 - matthiaskrgr:cl3ppy, r=Mark-Simulacrum\n\nmore clippy fixes\n\n* remove unused unit values (clippy::unused_unit)\n* make some let-if-bindings more idiomatic (clippy::useless_let_if_seq)\n* clarify when we pass () to functions (clippy::unit_arg)\n* don't redundantly repeat field names (clippy::redundant_field_names)\n* remove redundant returns (clippy::needless_return)\n* use let instead of match for matches with single bindings (clippy::match_single_binding)\n* don't convert results to options just for matching (clippy::if_let_some_result)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "html_url": "https://github.com/rust-lang/rust/commit/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c8f8b6304e6d8ec735f32a8286a1461f36feeb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c8f8b6304e6d8ec735f32a8286a1461f36feeb0", "html_url": "https://github.com/rust-lang/rust/commit/3c8f8b6304e6d8ec735f32a8286a1461f36feeb0"}, {"sha": "e45fdcfa9a611e4b29b727fb1c70ea60423f1c24", "url": "https://api.github.com/repos/rust-lang/rust/commits/e45fdcfa9a611e4b29b727fb1c70ea60423f1c24", "html_url": "https://github.com/rust-lang/rust/commit/e45fdcfa9a611e4b29b727fb1c70ea60423f1c24"}], "stats": {"total": 207, "additions": 92, "deletions": 115}, "files": [{"sha": "d66fcd3a20db92017521bde7569f5340244cd8dc", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -381,12 +381,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // Field 5 would be the first element, so memory_index is i:\n         // Note: if we didn't optimize, it's already right.\n \n-        let memory_index;\n-        if optimize {\n-            memory_index = invert_mapping(&inverse_memory_index);\n-        } else {\n-            memory_index = inverse_memory_index;\n-        }\n+        let memory_index =\n+            if optimize { invert_mapping(&inverse_memory_index) } else { inverse_memory_index };\n \n         let size = min_size.align_to(align.abi);\n         let mut abi = Abi::Aggregate { sized };\n@@ -944,33 +940,33 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             let offset = st[i].fields.offset(field_index) + niche.offset;\n                             let size = st[i].size;\n \n-                            let mut abi = match st[i].abi {\n-                                Abi::Scalar(_) => Abi::Scalar(niche_scalar.clone()),\n-                                Abi::ScalarPair(ref first, ref second) => {\n-                                    // We need to use scalar_unit to reset the\n-                                    // valid range to the maximal one for that\n-                                    // primitive, because only the niche is\n-                                    // guaranteed to be initialised, not the\n-                                    // other primitive.\n-                                    if offset.bytes() == 0 {\n-                                        Abi::ScalarPair(\n-                                            niche_scalar.clone(),\n-                                            scalar_unit(second.value),\n-                                        )\n-                                    } else {\n-                                        Abi::ScalarPair(\n-                                            scalar_unit(first.value),\n-                                            niche_scalar.clone(),\n-                                        )\n+                            let abi = if st.iter().all(|v| v.abi.is_uninhabited()) {\n+                                Abi::Uninhabited\n+                            } else {\n+                                match st[i].abi {\n+                                    Abi::Scalar(_) => Abi::Scalar(niche_scalar.clone()),\n+                                    Abi::ScalarPair(ref first, ref second) => {\n+                                        // We need to use scalar_unit to reset the\n+                                        // valid range to the maximal one for that\n+                                        // primitive, because only the niche is\n+                                        // guaranteed to be initialised, not the\n+                                        // other primitive.\n+                                        if offset.bytes() == 0 {\n+                                            Abi::ScalarPair(\n+                                                niche_scalar.clone(),\n+                                                scalar_unit(second.value),\n+                                            )\n+                                        } else {\n+                                            Abi::ScalarPair(\n+                                                scalar_unit(first.value),\n+                                                niche_scalar.clone(),\n+                                            )\n+                                        }\n                                     }\n+                                    _ => Abi::Aggregate { sized: true },\n                                 }\n-                                _ => Abi::Aggregate { sized: true },\n                             };\n \n-                            if st.iter().all(|v| v.abi.is_uninhabited()) {\n-                                abi = Abi::Uninhabited;\n-                            }\n-\n                             let largest_niche =\n                                 Niche::from_scalar(dl, offset, niche_scalar.clone());\n "}, {"sha": "80a4e552f02d6101cd7fbd413d30b29aa8951497", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -746,7 +746,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// side-effects -- e.g., in order to report errors for erroneous programs.\n     ///\n     /// Note: The optimization is only available during incr. comp.\n-    pub(super) fn ensure_query<Q: QueryDescription<'tcx> + 'tcx>(self, key: Q::Key) -> () {\n+    pub(super) fn ensure_query<Q: QueryDescription<'tcx> + 'tcx>(self, key: Q::Key) {\n         if Q::EVAL_ALWAYS {\n             let _ = self.get_query::<Q>(DUMMY_SP, key);\n             return;"}, {"sha": "9338f9afbbb3193d8ec906054c910695bb601581", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -1056,8 +1056,9 @@ impl<'a> MethodDef<'a> {\n                     self_: field,\n                     other: other_fields\n                         .iter_mut()\n-                        .map(|l| match l.next().unwrap() {\n-                            (.., ex, _) => ex,\n+                        .map(|l| {\n+                            let (.., ex, _) = l.next().unwrap();\n+                            ex\n                         })\n                         .collect(),\n                     attrs,"}, {"sha": "06870ccc7dd5eca4503951203b34859f20d9756d", "filename": "src/librustc_infer/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fproject.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -23,7 +23,7 @@ pub type NormalizedTy<'tcx> = Normalized<'tcx, Ty<'tcx>>;\n \n impl<'tcx, T> Normalized<'tcx, T> {\n     pub fn with<U>(self, value: U) -> Normalized<'tcx, U> {\n-        Normalized { value: value, obligations: self.obligations }\n+        Normalized { value, obligations: self.obligations }\n     }\n }\n "}, {"sha": "90f3cb1d24cccd68cb6d871493d035093bad20a7", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -47,7 +47,7 @@ struct PredicateSet<'tcx> {\n \n impl PredicateSet<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> Self {\n-        Self { tcx: tcx, set: Default::default() }\n+        Self { tcx, set: Default::default() }\n     }\n \n     fn insert(&mut self, pred: &ty::Predicate<'tcx>) -> bool {"}, {"sha": "7b65a5a10986ab22f7591ee5e9ebacbabfda1ac3", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -490,17 +490,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 {\n                     if pat_snippet.starts_with('&') {\n                         let pat_snippet = pat_snippet[1..].trim_start();\n-                        let suggestion;\n-                        let to_remove;\n-                        if pat_snippet.starts_with(\"mut\")\n+                        let (suggestion, to_remove) = if pat_snippet.starts_with(\"mut\")\n                             && pat_snippet[\"mut\".len()..].starts_with(rustc_lexer::is_whitespace)\n                         {\n-                            suggestion = pat_snippet[\"mut\".len()..].trim_start();\n-                            to_remove = \"&mut\";\n+                            (pat_snippet[\"mut\".len()..].trim_start(), \"&mut\")\n                         } else {\n-                            suggestion = pat_snippet;\n-                            to_remove = \"&\";\n-                        }\n+                            (pat_snippet, \"&\")\n+                        };\n                         suggestions.push((pat_span, to_remove, suggestion.to_owned()));\n                     }\n                 }"}, {"sha": "87d0424ece9443df86a7ae72be757cd41e631c80", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -335,9 +335,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     #[inline(always)]\n-    fn tag_static_base_pointer(_memory_extra: &MemoryExtra, _id: AllocId) -> Self::PointerTag {\n-        ()\n-    }\n+    fn tag_static_base_pointer(_memory_extra: &MemoryExtra, _id: AllocId) -> Self::PointerTag {}\n \n     fn box_alloc(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,"}, {"sha": "ac593d0845a7df52051836a3379cc1181d84f888", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -581,7 +581,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// If `target` is `None`, that indicates the function cannot return, so we raise UB.\n     pub fn return_to_block(&mut self, target: Option<mir::BasicBlock>) -> InterpResult<'tcx> {\n         if let Some(target) = target {\n-            Ok(self.go_to_block(target))\n+            self.go_to_block(target);\n+            Ok(())\n         } else {\n             throw_ub!(Unreachable)\n         }"}, {"sha": "162387308040dd493dee00132bd3f3e74a96220e", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -192,7 +192,8 @@ impl PrettyPrinter<'tcx> for AbsolutePathPrinter<'tcx> {\n \n impl Write for AbsolutePathPrinter<'_> {\n     fn write_str(&mut self, s: &str) -> std::fmt::Result {\n-        Ok(self.path.push_str(s))\n+        self.path.push_str(s);\n+        Ok(())\n     }\n }\n "}, {"sha": "6b0bbe4f6e0bbd64c15ee09246cca772f6dd65e3", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -370,7 +370,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         self.stack.pop();\n                         Err(err)\n                     }\n-                    Ok(v) => Ok(v),\n+                    Ok(()) => Ok(()),\n                 }\n             }\n             // cannot use the shim here, because that will only result in infinite recursion"}, {"sha": "ba29b187b226efc4f5d653ce864c41d255728a68", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -232,9 +232,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n     }\n \n     #[inline(always)]\n-    fn tag_static_base_pointer(_memory_extra: &(), _id: AllocId) -> Self::PointerTag {\n-        ()\n-    }\n+    fn tag_static_base_pointer(_memory_extra: &(), _id: AllocId) -> Self::PointerTag {}\n \n     fn box_alloc(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,"}, {"sha": "82183e6c96e9f5c6c48799e476386a36a8c97c4f", "filename": "src/librustc_mir_build/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -73,10 +73,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // they are never assigned.\n             ExprKind::Break { .. } | ExprKind::Continue { .. } | ExprKind::Return { .. } => (),\n             ExprKind::Block { body: hir::Block { expr: None, targeted_by_break: false, .. } }\n-                if expr_ty.is_never() =>\n-            {\n-                ()\n-            }\n+                if expr_ty.is_never() => {}\n             _ => {\n                 this.cfg\n                     .push(block, Statement { source_info, kind: StatementKind::StorageLive(temp) });"}, {"sha": "d66650329313b907e2fd390073a91c364d942ebf", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -637,11 +637,12 @@ where\n     );\n     assert_eq!(block, builder.return_block());\n \n-    let mut spread_arg = None;\n-    if abi == Abi::RustCall {\n+    let spread_arg = if abi == Abi::RustCall {\n         // RustCall pseudo-ABI untuples the last argument.\n-        spread_arg = Some(Local::new(arguments.len()));\n-    }\n+        Some(Local::new(arguments.len()))\n+    } else {\n+        None\n+    };\n     debug!(\"fn_id {:?} has attrs {:?}\", fn_def_id, tcx.get_attrs(fn_def_id));\n \n     let mut body = builder.finish();"}, {"sha": "77d6e4560ab9374960233e5dc814a713cfa92476", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -750,14 +750,16 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n                 if let Some(ctor_node_id) = vdata.ctor_id() {\n-                    let mut ctor_vis = vis;\n                     // If the structure is marked as non_exhaustive then lower the visibility\n                     // to within the crate.\n-                    if vis == ty::Visibility::Public\n+                    let mut ctor_vis = if vis == ty::Visibility::Public\n                         && attr::contains_name(&item.attrs, sym::non_exhaustive)\n                     {\n-                        ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-                    }\n+                        ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n+                    } else {\n+                        vis\n+                    };\n+\n                     for field in vdata.fields() {\n                         // NOTE: The field may be an expansion placeholder, but expansion sets\n                         // correct visibilities for unnamed field placeholders specifically, so the\n@@ -1166,7 +1168,7 @@ macro_rules! method {\n                 visit::$walk(self, node);\n             }\n         }\n-    }\n+    };\n }\n \n impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {"}, {"sha": "8f806909f004731b527bc3d53a4460ff6e0f8b71", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -370,11 +370,11 @@ impl SourceMap {\n     pub fn doctest_offset_line(&self, file: &FileName, orig: usize) -> usize {\n         match file {\n             FileName::DocTest(_, offset) => {\n-                return if *offset >= 0 {\n-                    orig + *offset as usize\n-                } else {\n+                if *offset < 0 {\n                     orig - (-(*offset)) as usize\n-                };\n+                } else {\n+                    orig + *offset as usize\n+                }\n             }\n             _ => orig,\n         }"}, {"sha": "4ad65569e6a8a9ce93a0dd135c5aaf2b202848ba", "filename": "src/librustc_target/spec/apple_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_target%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_target%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fapple_base.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -57,7 +57,7 @@ pub fn macos_link_env_remove() -> Vec<String> {\n     let mut env_remove = Vec::with_capacity(2);\n     // Remove the `SDKROOT` environment variable if it's clearly set for the wrong platform, which\n     // may occur when we're linking a custom build script while targeting iOS for example.\n-    if let Some(sdkroot) = env::var(\"SDKROOT\").ok() {\n+    if let Ok(sdkroot) = env::var(\"SDKROOT\") {\n         if sdkroot.contains(\"iPhoneOS.platform\") || sdkroot.contains(\"iPhoneSimulator.platform\") {\n             env_remove.push(\"SDKROOT\".to_string())\n         }"}, {"sha": "c7cff17b1544c8614e83da29150dec827137880e", "filename": "src/librustc_target/spec/apple_sdk_base.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_target%2Fspec%2Fapple_sdk_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_target%2Fspec%2Fapple_sdk_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fapple_sdk_base.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -43,40 +43,26 @@ pub fn get_sdk_root(sdk_name: &str) -> Result<String, String> {\n     // to allow the SDK path to be set. (For clang, xcrun sets\n     // SDKROOT; for rustc, the user or build system can set it, or we\n     // can fall back to checking for xcrun on PATH.)\n-    if let Some(sdkroot) = env::var(\"SDKROOT\").ok() {\n+    if let Ok(sdkroot) = env::var(\"SDKROOT\") {\n         let p = Path::new(&sdkroot);\n         match sdk_name {\n             // Ignore `SDKROOT` if it's clearly set for the wrong platform.\n             \"appletvos\"\n                 if sdkroot.contains(\"TVSimulator.platform\")\n-                    || sdkroot.contains(\"MacOSX.platform\") =>\n-            {\n-                ()\n-            }\n+                    || sdkroot.contains(\"MacOSX.platform\") => {}\n             \"appletvsimulator\"\n-                if sdkroot.contains(\"TVOS.platform\") || sdkroot.contains(\"MacOSX.platform\") =>\n-            {\n-                ()\n-            }\n+                if sdkroot.contains(\"TVOS.platform\") || sdkroot.contains(\"MacOSX.platform\") => {}\n             \"iphoneos\"\n                 if sdkroot.contains(\"iPhoneSimulator.platform\")\n-                    || sdkroot.contains(\"MacOSX.platform\") =>\n-            {\n-                ()\n-            }\n+                    || sdkroot.contains(\"MacOSX.platform\") => {}\n             \"iphonesimulator\"\n-                if sdkroot.contains(\"iPhoneOS.platform\") || sdkroot.contains(\"MacOSX.platform\") =>\n-            {\n-                ()\n+                if sdkroot.contains(\"iPhoneOS.platform\") || sdkroot.contains(\"MacOSX.platform\") => {\n             }\n             \"macosx10.15\"\n                 if sdkroot.contains(\"iPhoneOS.platform\")\n-                    || sdkroot.contains(\"iPhoneSimulator.platform\") =>\n-            {\n-                ()\n-            }\n+                    || sdkroot.contains(\"iPhoneSimulator.platform\") => {}\n             // Ignore `SDKROOT` if it's not a valid path.\n-            _ if !p.is_absolute() || p == Path::new(\"/\") || !p.exists() => (),\n+            _ if !p.is_absolute() || p == Path::new(\"/\") || !p.exists() => {}\n             _ => return Ok(sdkroot),\n         }\n     }"}, {"sha": "ca169d550e782031ba24a1179db596f8243b54ce", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -2792,7 +2792,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 trait_def_id, trait_obligations\n             );\n \n-            VtableTraitAliasData { alias_def_id, substs: substs, nested: trait_obligations }\n+            VtableTraitAliasData { alias_def_id, substs, nested: trait_obligations }\n         })\n     }\n "}, {"sha": "7ed828c91679cc98c3222fbdd271e3e3f5376ac7", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -80,11 +80,11 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        Ok(self\n-            .infcx\n+        self.infcx\n             .at(&ObligationCause::dummy(), self.param_env)\n             .relate(a, variance, b)?\n-            .into_value_registering_obligations(self.infcx, self.fulfill_cx))\n+            .into_value_registering_obligations(self.infcx, self.fulfill_cx);\n+        Ok(())\n     }\n \n     fn prove_predicate(&mut self, predicate: Predicate<'tcx>) {\n@@ -165,10 +165,11 @@ fn type_op_eq<'tcx>(\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n         let (param_env, Eq { a, b }) = key.into_parts();\n-        Ok(infcx\n+        infcx\n             .at(&ObligationCause::dummy(), param_env)\n             .eq(a, b)?\n-            .into_value_registering_obligations(infcx, fulfill_cx))\n+            .into_value_registering_obligations(infcx, fulfill_cx);\n+        Ok(())\n     })\n }\n \n@@ -221,10 +222,11 @@ fn type_op_subtype<'tcx>(\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n         let (param_env, Subtype { sub, sup }) = key.into_parts();\n-        Ok(infcx\n+        infcx\n             .at(&ObligationCause::dummy(), param_env)\n             .sup(sup, sub)?\n-            .into_value_registering_obligations(infcx, fulfill_cx))\n+            .into_value_registering_obligations(infcx, fulfill_cx);\n+        Ok(())\n     })\n }\n "}, {"sha": "7068e3c521c81797695c0bd8e08ca36920b364b1", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -368,11 +368,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let fn_sig = tcx.fn_sig(def_id);\n         let fn_sig = self.replace_bound_vars_with_fresh_vars(span, infer::FnCall, &fn_sig).0;\n         let fn_sig = fn_sig.subst(self.tcx, substs);\n-        let fn_sig = match self.normalize_associated_types_in_as_infer_ok(span, &fn_sig) {\n-            InferOk { value, obligations: o } => {\n-                obligations.extend(o);\n-                value\n-            }\n+\n+        let InferOk { value, obligations: o } =\n+            self.normalize_associated_types_in_as_infer_ok(span, &fn_sig);\n+        let fn_sig = {\n+            obligations.extend(o);\n+            value\n         };\n \n         // Register obligations for the parameters. This will include the\n@@ -384,12 +385,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Note that as the method comes from a trait, it should not have\n         // any late-bound regions appearing in its bounds.\n         let bounds = self.tcx.predicates_of(def_id).instantiate(self.tcx, substs);\n-        let bounds = match self.normalize_associated_types_in_as_infer_ok(span, &bounds) {\n-            InferOk { value, obligations: o } => {\n-                obligations.extend(o);\n-                value\n-            }\n+\n+        let InferOk { value, obligations: o } =\n+            self.normalize_associated_types_in_as_infer_ok(span, &bounds);\n+        let bounds = {\n+            obligations.extend(o);\n+            value\n         };\n+\n         assert!(!bounds.has_escaping_bound_vars());\n \n         let cause = traits::ObligationCause::misc(span, self.body_id);"}, {"sha": "d0a87e240da8936179ac47ed2e86a0ba3fcfa2ab", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -178,10 +178,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: DefId) {\n             use ty::TyKind::*;\n             match (&source.kind, &target.kind) {\n                 (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n-                    if infcx.at(&cause, param_env).eq(r_a, r_b).is_ok() && mutbl_a == *mutbl_b =>\n-                {\n-                    ()\n-                }\n+                    if infcx.at(&cause, param_env).eq(r_a, r_b).is_ok() && mutbl_a == *mutbl_b => {}\n                 (&RawPtr(tm_a), &RawPtr(tm_b)) if tm_a.mutbl == tm_b.mutbl => (),\n                 (&Adt(def_a, substs_a), &Adt(def_b, substs_b))\n                     if def_a.is_struct() && def_b.is_struct() =>"}, {"sha": "9dd1d3706ffbd61347d58b304fb598ba916fe003", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=e58fec0c1cfa6f306940edb20d8d5f7a3a468d6e", "patch": "@@ -234,9 +234,7 @@ pub fn load_css_paths(v: &[u8]) -> CssPath {\n }\n \n pub fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>) {\n-    if against.name != other.name {\n-        return;\n-    } else {\n+    if against.name == other.name {\n         for child in &against.children {\n             let mut found = false;\n             let mut found_working = false;"}]}