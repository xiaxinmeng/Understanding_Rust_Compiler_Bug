{"sha": "43dc48c7ffb45c714b33b1e47f23f6d711c89596", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZGM0OGM3ZmZiNDVjNzE0YjMzYjFlNDdmMjNmNmQ3MTFjODk1OTY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-05T13:40:33Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-05T13:40:33Z"}, "message": "apply rustfmt to librustc_data_structures, correcting rust-lang-nursery/rustfmt#836", "tree": {"sha": "71b3bd76dcc944734a35cc80af461f0eedd75546", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71b3bd76dcc944734a35cc80af461f0eedd75546"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43dc48c7ffb45c714b33b1e47f23f6d711c89596", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43dc48c7ffb45c714b33b1e47f23f6d711c89596", "html_url": "https://github.com/rust-lang/rust/commit/43dc48c7ffb45c714b33b1e47f23f6d711c89596", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43dc48c7ffb45c714b33b1e47f23f6d711c89596/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d31d8a9a919b705fb8d22ba99a693d9f96b8bdd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d31d8a9a919b705fb8d22ba99a693d9f96b8bdd5", "html_url": "https://github.com/rust-lang/rust/commit/d31d8a9a919b705fb8d22ba99a693d9f96b8bdd5"}], "stats": {"total": 799, "additions": 444, "deletions": 355}, "files": [{"sha": "3677c8c5e593ddad8884a8f3bf13fc41cd858367", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=43dc48c7ffb45c714b33b1e47f23f6d711c89596", "patch": "@@ -10,7 +10,7 @@\n \n /// A very simple BitVector type.\n pub struct BitVector {\n-    data: Vec<u64>\n+    data: Vec<u64>,\n }\n \n impl BitVector {\n@@ -40,7 +40,9 @@ impl BitVector {\n         for (i, j) in self.data.iter_mut().zip(&all.data) {\n             let value = *i;\n             *i = value | *j;\n-            if value != *i { changed = true; }\n+            if value != *i {\n+                changed = true;\n+            }\n         }\n         changed\n     }\n@@ -56,15 +58,15 @@ impl BitVector {\n         BitVectorIter {\n             iter: self.data.iter(),\n             current: 0,\n-            idx: 0\n+            idx: 0,\n         }\n     }\n }\n \n pub struct BitVectorIter<'a> {\n     iter: ::std::slice::Iter<'a, u64>,\n     current: u64,\n-    idx: usize\n+    idx: usize,\n }\n \n impl<'a> Iterator for BitVectorIter<'a> {\n@@ -108,7 +110,7 @@ impl BitMatrix {\n         let u64s_per_elem = u64s(elements);\n         BitMatrix {\n             elements: elements,\n-            vector: vec![0; elements * u64s_per_elem]\n+            vector: vec![0; elements * u64s_per_elem],\n         }\n     }\n \n@@ -123,9 +125,9 @@ impl BitMatrix {\n         let (start, _) = self.range(source);\n         let (word, mask) = word_mask(target);\n         let mut vector = &mut self.vector[..];\n-        let v1 = vector[start+word];\n+        let v1 = vector[start + word];\n         let v2 = v1 | mask;\n-        vector[start+word] = v2;\n+        vector[start + word] = v2;\n         v1 != v2\n     }\n \n@@ -136,7 +138,7 @@ impl BitMatrix {\n     pub fn contains(&self, source: usize, target: usize) -> bool {\n         let (start, _) = self.range(source);\n         let (word, mask) = word_mask(target);\n-        (self.vector[start+word] & mask) != 0\n+        (self.vector[start + word] & mask) != 0\n     }\n \n     /// Returns those indices that are reachable from both `a` and\n@@ -150,8 +152,12 @@ impl BitMatrix {\n         for (base, (i, j)) in (a_start..a_end).zip(b_start..b_end).enumerate() {\n             let mut v = self.vector[i] & self.vector[j];\n             for bit in 0..64 {\n-                if v == 0 { break; }\n-                if v & 0x1 != 0 { result.push(base*64 + bit); }\n+                if v == 0 {\n+                    break;\n+                }\n+                if v & 0x1 != 0 {\n+                    result.push(base * 64 + bit);\n+                }\n                 v >>= 1;\n             }\n         }\n@@ -170,9 +176,7 @@ impl BitMatrix {\n         let (write_start, write_end) = self.range(write);\n         let vector = &mut self.vector[..];\n         let mut changed = false;\n-        for (read_index, write_index) in\n-            (read_start..read_end).zip(write_start..write_end)\n-        {\n+        for (read_index, write_index) in (read_start..read_end).zip(write_start..write_end) {\n             let v1 = vector[write_index];\n             let v2 = v1 | vector[read_index];\n             vector[write_index] = v2;\n@@ -204,7 +208,8 @@ fn bitvec_iter_works() {\n     bitvec.insert(65);\n     bitvec.insert(66);\n     bitvec.insert(99);\n-    assert_eq!(bitvec.iter().collect::<Vec<_>>(), [1, 10, 19, 62, 63, 64, 65, 66, 99]);\n+    assert_eq!(bitvec.iter().collect::<Vec<_>>(),\n+               [1, 10, 19, 62, 63, 64, 65, 66, 99]);\n }\n \n #[test]\n@@ -217,7 +222,8 @@ fn bitvec_iter_works_2() {\n     bitvec.insert(66);\n     bitvec.insert(99);\n     bitvec.insert(299);\n-    assert_eq!(bitvec.iter().collect::<Vec<_>>(), [1, 10, 19, 62, 66, 99, 299]);\n+    assert_eq!(bitvec.iter().collect::<Vec<_>>(),\n+               [1, 10, 19, 62, 66, 99, 299]);\n \n }\n "}, {"sha": "0000c283a7a00245bac358a5253ebf57c1d2c154", "filename": "src/librustc_data_structures/fnv.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Ffnv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Ffnv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffnv.rs?ref=43dc48c7ffb45c714b33b1e47f23f6d711c89596", "patch": "@@ -36,7 +36,9 @@ pub struct FnvHasher(u64);\n \n impl Default for FnvHasher {\n     #[inline]\n-    fn default() -> FnvHasher { FnvHasher(0xcbf29ce484222325) }\n+    fn default() -> FnvHasher {\n+        FnvHasher(0xcbf29ce484222325)\n+    }\n }\n \n impl Hasher for FnvHasher {\n@@ -51,5 +53,7 @@ impl Hasher for FnvHasher {\n     }\n \n     #[inline]\n-    fn finish(&self) -> u64 { self.0 }\n+    fn finish(&self) -> u64 {\n+        self.0\n+    }\n }"}, {"sha": "f33769f39e83ada45d20475128c469d0adc38a0c", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 65, "deletions": 53, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=43dc48c7ffb45c714b33b1e47f23f6d711c89596", "patch": "@@ -38,9 +38,9 @@ use snapshot_vec::{SnapshotVec, SnapshotVecDelegate};\n #[cfg(test)]\n mod tests;\n \n-pub struct Graph<N,E> {\n-    nodes: SnapshotVec<Node<N>> ,\n-    edges: SnapshotVec<Edge<E>> ,\n+pub struct Graph<N, E> {\n+    nodes: SnapshotVec<Node<N>>,\n+    edges: SnapshotVec<Edge<E>>,\n }\n \n pub struct Node<N> {\n@@ -71,9 +71,13 @@ impl<N> SnapshotVecDelegate for Edge<N> {\n \n impl<E: Debug> Debug for Edge<E> {\n     fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n-        write!(f, \"Edge {{ next_edge: [{:?}, {:?}], source: {:?}, target: {:?}, data: {:?} }}\",\n-               self.next_edge[0], self.next_edge[1], self.source,\n-               self.target, self.data)\n+        write!(f,\n+               \"Edge {{ next_edge: [{:?}, {:?}], source: {:?}, target: {:?}, data: {:?} }}\",\n+               self.next_edge[0],\n+               self.next_edge[1],\n+               self.source,\n+               self.target,\n+               self.data)\n     }\n }\n \n@@ -87,24 +91,30 @@ pub const INVALID_EDGE_INDEX: EdgeIndex = EdgeIndex(usize::MAX);\n \n // Use a private field here to guarantee no more instances are created:\n #[derive(Copy, Clone, Debug, PartialEq)]\n-pub struct Direction { repr: usize }\n+pub struct Direction {\n+    repr: usize,\n+}\n \n pub const OUTGOING: Direction = Direction { repr: 0 };\n \n pub const INCOMING: Direction = Direction { repr: 1 };\n \n impl NodeIndex {\n     /// Returns unique id (unique with respect to the graph holding associated node).\n-    pub fn node_id(&self) -> usize { self.0 }\n+    pub fn node_id(&self) -> usize {\n+        self.0\n+    }\n }\n \n impl EdgeIndex {\n     /// Returns unique id (unique with respect to the graph holding associated edge).\n-    pub fn edge_id(&self) -> usize { self.0 }\n+    pub fn edge_id(&self) -> usize {\n+        self.0\n+    }\n }\n \n-impl<N:Debug,E:Debug> Graph<N,E> {\n-    pub fn new() -> Graph<N,E> {\n+impl<N: Debug, E: Debug> Graph<N, E> {\n+    pub fn new() -> Graph<N, E> {\n         Graph {\n             nodes: SnapshotVec::new(),\n             edges: SnapshotVec::new(),\n@@ -145,7 +155,7 @@ impl<N:Debug,E:Debug> Graph<N,E> {\n         let idx = self.next_node_index();\n         self.nodes.push(Node {\n             first_edge: [INVALID_EDGE_INDEX, INVALID_EDGE_INDEX],\n-            data: data\n+            data: data,\n         });\n         idx\n     }\n@@ -169,27 +179,22 @@ impl<N:Debug,E:Debug> Graph<N,E> {\n         EdgeIndex(self.edges.len())\n     }\n \n-    pub fn add_edge(&mut self,\n-                    source: NodeIndex,\n-                    target: NodeIndex,\n-                    data: E) -> EdgeIndex {\n+    pub fn add_edge(&mut self, source: NodeIndex, target: NodeIndex, data: E) -> EdgeIndex {\n         debug!(\"graph: add_edge({:?}, {:?}, {:?})\", source, target, data);\n \n         let idx = self.next_edge_index();\n \n         // read current first of the list of edges from each node\n-        let source_first = self.nodes[source.0]\n-                                     .first_edge[OUTGOING.repr];\n-        let target_first = self.nodes[target.0]\n-                                     .first_edge[INCOMING.repr];\n+        let source_first = self.nodes[source.0].first_edge[OUTGOING.repr];\n+        let target_first = self.nodes[target.0].first_edge[INCOMING.repr];\n \n         // create the new edge, with the previous firsts from each node\n         // as the next pointers\n         self.edges.push(Edge {\n             next_edge: [source_first, target_first],\n             source: source,\n             target: target,\n-            data: data\n+            data: data,\n         });\n \n         // adjust the firsts for each node target be the next object.\n@@ -230,38 +235,42 @@ impl<N:Debug,E:Debug> Graph<N,E> {\n     ///////////////////////////////////////////////////////////////////////////\n     // Iterating over nodes, edges\n \n-    pub fn each_node<'a, F>(&'a self, mut f: F) -> bool where\n-        F: FnMut(NodeIndex, &'a Node<N>) -> bool,\n+    pub fn each_node<'a, F>(&'a self, mut f: F) -> bool\n+        where F: FnMut(NodeIndex, &'a Node<N>) -> bool\n     {\n         //! Iterates over all edges defined in the graph.\n         self.nodes.iter().enumerate().all(|(i, node)| f(NodeIndex(i), node))\n     }\n \n-    pub fn each_edge<'a, F>(&'a self, mut f: F) -> bool where\n-        F: FnMut(EdgeIndex, &'a Edge<E>) -> bool,\n+    pub fn each_edge<'a, F>(&'a self, mut f: F) -> bool\n+        where F: FnMut(EdgeIndex, &'a Edge<E>) -> bool\n     {\n         //! Iterates over all edges defined in the graph\n         self.edges.iter().enumerate().all(|(i, edge)| f(EdgeIndex(i), edge))\n     }\n \n-    pub fn outgoing_edges(&self, source: NodeIndex) -> AdjacentEdges<N,E> {\n+    pub fn outgoing_edges(&self, source: NodeIndex) -> AdjacentEdges<N, E> {\n         self.adjacent_edges(source, OUTGOING)\n     }\n \n-    pub fn incoming_edges(&self, source: NodeIndex) -> AdjacentEdges<N,E> {\n+    pub fn incoming_edges(&self, source: NodeIndex) -> AdjacentEdges<N, E> {\n         self.adjacent_edges(source, INCOMING)\n     }\n \n-    pub fn adjacent_edges(&self, source: NodeIndex, direction: Direction) -> AdjacentEdges<N,E> {\n+    pub fn adjacent_edges(&self, source: NodeIndex, direction: Direction) -> AdjacentEdges<N, E> {\n         let first_edge = self.node(source).first_edge[direction.repr];\n-        AdjacentEdges { graph: self, direction: direction, next: first_edge }\n+        AdjacentEdges {\n+            graph: self,\n+            direction: direction,\n+            next: first_edge,\n+        }\n     }\n \n-    pub fn successor_nodes(&self, source: NodeIndex) -> AdjacentTargets<N,E> {\n+    pub fn successor_nodes(&self, source: NodeIndex) -> AdjacentTargets<N, E> {\n         self.outgoing_edges(source).targets()\n     }\n \n-    pub fn predecessor_nodes(&self, target: NodeIndex) -> AdjacentSources<N,E> {\n+    pub fn predecessor_nodes(&self, target: NodeIndex) -> AdjacentSources<N, E> {\n         self.incoming_edges(target).sources()\n     }\n \n@@ -274,8 +283,8 @@ impl<N:Debug,E:Debug> Graph<N,E> {\n     // variables or other bitsets. This method facilitates such a\n     // computation.\n \n-    pub fn iterate_until_fixed_point<'a, F>(&'a self, mut op: F) where\n-        F: FnMut(usize, EdgeIndex, &'a Edge<E>) -> bool,\n+    pub fn iterate_until_fixed_point<'a, F>(&'a self, mut op: F)\n+        where F: FnMut(usize, EdgeIndex, &'a Edge<E>) -> bool\n     {\n         let mut iteration = 0;\n         let mut changed = true;\n@@ -288,7 +297,7 @@ impl<N:Debug,E:Debug> Graph<N,E> {\n         }\n     }\n \n-    pub fn depth_traverse<'a>(&'a self, start: NodeIndex) -> DepthFirstTraversal<'a, N, E>  {\n+    pub fn depth_traverse<'a>(&'a self, start: NodeIndex) -> DepthFirstTraversal<'a, N, E> {\n         DepthFirstTraversal {\n             graph: self,\n             stack: vec![start],\n@@ -300,25 +309,26 @@ impl<N:Debug,E:Debug> Graph<N,E> {\n ///////////////////////////////////////////////////////////////////////////\n // Iterators\n \n-pub struct AdjacentEdges<'g,N,E>\n-    where N:'g, E:'g\n+pub struct AdjacentEdges<'g, N, E>\n+    where N: 'g,\n+          E: 'g\n {\n     graph: &'g Graph<N, E>,\n     direction: Direction,\n     next: EdgeIndex,\n }\n \n-impl<'g,N,E> AdjacentEdges<'g,N,E> {\n-    fn targets(self) -> AdjacentTargets<'g,N,E> {\n+impl<'g, N, E> AdjacentEdges<'g, N, E> {\n+    fn targets(self) -> AdjacentTargets<'g, N, E> {\n         AdjacentTargets { edges: self }\n     }\n \n-    fn sources(self) -> AdjacentSources<'g,N,E> {\n+    fn sources(self) -> AdjacentSources<'g, N, E> {\n         AdjacentSources { edges: self }\n     }\n }\n \n-impl<'g, N:Debug, E:Debug> Iterator for AdjacentEdges<'g, N, E> {\n+impl<'g, N: Debug, E: Debug> Iterator for AdjacentEdges<'g, N, E> {\n     type Item = (EdgeIndex, &'g Edge<E>);\n \n     fn next(&mut self) -> Option<(EdgeIndex, &'g Edge<E>)> {\n@@ -333,41 +343,43 @@ impl<'g, N:Debug, E:Debug> Iterator for AdjacentEdges<'g, N, E> {\n     }\n }\n \n-pub struct AdjacentTargets<'g,N:'g,E:'g>\n-    where N:'g, E:'g\n+pub struct AdjacentTargets<'g, N: 'g, E: 'g>\n+    where N: 'g,\n+          E: 'g\n {\n-    edges: AdjacentEdges<'g,N,E>,\n+    edges: AdjacentEdges<'g, N, E>,\n }\n \n-impl<'g, N:Debug, E:Debug> Iterator for AdjacentTargets<'g, N, E> {\n+impl<'g, N: Debug, E: Debug> Iterator for AdjacentTargets<'g, N, E> {\n     type Item = NodeIndex;\n \n     fn next(&mut self) -> Option<NodeIndex> {\n         self.edges.next().map(|(_, edge)| edge.target)\n     }\n }\n \n-pub struct AdjacentSources<'g,N:'g,E:'g>\n-    where N:'g, E:'g\n+pub struct AdjacentSources<'g, N: 'g, E: 'g>\n+    where N: 'g,\n+          E: 'g\n {\n-    edges: AdjacentEdges<'g,N,E>,\n+    edges: AdjacentEdges<'g, N, E>,\n }\n \n-impl<'g, N:Debug, E:Debug> Iterator for AdjacentSources<'g, N, E> {\n+impl<'g, N: Debug, E: Debug> Iterator for AdjacentSources<'g, N, E> {\n     type Item = NodeIndex;\n \n     fn next(&mut self) -> Option<NodeIndex> {\n         self.edges.next().map(|(_, edge)| edge.source)\n     }\n }\n \n-pub struct DepthFirstTraversal<'g, N:'g, E:'g> {\n+pub struct DepthFirstTraversal<'g, N: 'g, E: 'g> {\n     graph: &'g Graph<N, E>,\n     stack: Vec<NodeIndex>,\n-    visited: BitVector\n+    visited: BitVector,\n }\n \n-impl<'g, N:Debug, E:Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n+impl<'g, N: Debug, E: Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n     type Item = NodeIndex;\n \n     fn next(&mut self) -> Option<NodeIndex> {\n@@ -389,8 +401,8 @@ impl<'g, N:Debug, E:Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n     }\n }\n \n-pub fn each_edge_index<F>(max_edge_index: EdgeIndex, mut f: F) where\n-    F: FnMut(EdgeIndex) -> bool,\n+pub fn each_edge_index<F>(max_edge_index: EdgeIndex, mut f: F)\n+    where F: FnMut(EdgeIndex) -> bool\n {\n     let mut i = 0;\n     let n = max_edge_index.0;"}, {"sha": "be7f48d27e0416a5c34b7c557e1ce8654dfa1b70", "filename": "src/librustc_data_structures/graph/tests.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs?ref=43dc48c7ffb45c714b33b1e47f23f6d711c89596", "patch": "@@ -64,19 +64,22 @@ fn each_edge() {\n     });\n }\n \n-fn test_adjacent_edges<N:PartialEq+Debug,E:PartialEq+Debug>(graph: &Graph<N,E>,\n-                                                            start_index: NodeIndex,\n-                                                            start_data: N,\n-                                                            expected_incoming: &[(E,N)],\n-                                                            expected_outgoing: &[(E,N)]) {\n+fn test_adjacent_edges<N: PartialEq + Debug, E: PartialEq + Debug>(graph: &Graph<N, E>,\n+                                                                   start_index: NodeIndex,\n+                                                                   start_data: N,\n+                                                                   expected_incoming: &[(E, N)],\n+                                                                   expected_outgoing: &[(E, N)]) {\n     assert!(graph.node_data(start_index) == &start_data);\n \n     let mut counter = 0;\n     for (edge_index, edge) in graph.incoming_edges(start_index) {\n         assert!(graph.edge_data(edge_index) == &edge.data);\n         assert!(counter < expected_incoming.len());\n         debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n-               counter, expected_incoming[counter], edge_index, edge);\n+               counter,\n+               expected_incoming[counter],\n+               edge_index,\n+               edge);\n         match expected_incoming[counter] {\n             (ref e, ref n) => {\n                 assert!(e == &edge.data);\n@@ -93,7 +96,10 @@ fn test_adjacent_edges<N:PartialEq+Debug,E:PartialEq+Debug>(graph: &Graph<N,E>,\n         assert!(graph.edge_data(edge_index) == &edge.data);\n         assert!(counter < expected_outgoing.len());\n         debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n-               counter, expected_outgoing[counter], edge_index, edge);\n+               counter,\n+               expected_outgoing[counter],\n+               edge_index,\n+               edge);\n         match expected_outgoing[counter] {\n             (ref e, ref n) => {\n                 assert!(e == &edge.data);\n@@ -109,31 +115,27 @@ fn test_adjacent_edges<N:PartialEq+Debug,E:PartialEq+Debug>(graph: &Graph<N,E>,\n #[test]\n fn each_adjacent_from_a() {\n     let graph = create_graph();\n-    test_adjacent_edges(&graph, NodeIndex(0), \"A\",\n-                        &[],\n-                        &[(\"AB\", \"B\")]);\n+    test_adjacent_edges(&graph, NodeIndex(0), \"A\", &[], &[(\"AB\", \"B\")]);\n }\n \n #[test]\n fn each_adjacent_from_b() {\n     let graph = create_graph();\n-    test_adjacent_edges(&graph, NodeIndex(1), \"B\",\n-                        &[(\"FB\", \"F\"), (\"AB\", \"A\"),],\n-                        &[(\"BD\", \"D\"), (\"BC\", \"C\"),]);\n+    test_adjacent_edges(&graph,\n+                        NodeIndex(1),\n+                        \"B\",\n+                        &[(\"FB\", \"F\"), (\"AB\", \"A\")],\n+                        &[(\"BD\", \"D\"), (\"BC\", \"C\")]);\n }\n \n #[test]\n fn each_adjacent_from_c() {\n     let graph = create_graph();\n-    test_adjacent_edges(&graph, NodeIndex(2), \"C\",\n-                        &[(\"EC\", \"E\"), (\"BC\", \"B\")],\n-                        &[]);\n+    test_adjacent_edges(&graph, NodeIndex(2), \"C\", &[(\"EC\", \"E\"), (\"BC\", \"B\")], &[]);\n }\n \n #[test]\n fn each_adjacent_from_d() {\n     let graph = create_graph();\n-    test_adjacent_edges(&graph, NodeIndex(3), \"D\",\n-                        &[(\"BD\", \"B\")],\n-                        &[(\"DE\", \"E\")]);\n+    test_adjacent_edges(&graph, NodeIndex(3), \"D\", &[(\"BD\", \"B\")], &[(\"DE\", \"E\")]);\n }"}, {"sha": "f842f4a41a118b36d9b7d4bc1162dc0d5afda1c5", "filename": "src/librustc_data_structures/ivar.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fivar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fivar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fivar.rs?ref=43dc48c7ffb45c714b33b1e47f23f6d711c89596", "patch": "@@ -26,23 +26,20 @@ use std::cell::Cell;\n /// suffices for the current purposes.\n #[derive(PartialEq)]\n pub struct Ivar<T: Copy> {\n-    data: Cell<Option<T>>\n+    data: Cell<Option<T>>,\n }\n \n impl<T: Copy> Ivar<T> {\n     pub fn new() -> Ivar<T> {\n-        Ivar {\n-            data: Cell::new(None)\n-        }\n+        Ivar { data: Cell::new(None) }\n     }\n \n     pub fn get(&self) -> Option<T> {\n         self.data.get()\n     }\n \n     pub fn fulfill(&self, value: T) {\n-        assert!(self.data.get().is_none(),\n-                \"Value already set!\");\n+        assert!(self.data.get().is_none(), \"Value already set!\");\n         self.data.set(Some(value));\n     }\n \n@@ -55,11 +52,11 @@ impl<T: Copy> Ivar<T> {\n     }\n }\n \n-impl<T: Copy+fmt::Debug> fmt::Debug for Ivar<T> {\n+impl<T: Copy + fmt::Debug> fmt::Debug for Ivar<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.get() {\n             Some(val) => write!(f, \"Ivar({:?})\", val),\n-            None => f.write_str(\"Ivar(<unfulfilled>)\")\n+            None => f.write_str(\"Ivar(<unfulfilled>)\"),\n         }\n     }\n }\n@@ -68,7 +65,7 @@ impl<T: Copy> Clone for Ivar<T> {\n     fn clone(&self) -> Ivar<T> {\n         match self.get() {\n             Some(val) => Ivar { data: Cell::new(Some(val)) },\n-            None => Ivar::new()\n+            None => Ivar::new(),\n         }\n     }\n }"}, {"sha": "2234325aa013bb8c4c428b4ebd07f3c706a8dd74", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=43dc48c7ffb45c714b33b1e47f23f6d711c89596", "patch": "@@ -32,7 +32,8 @@\n #![cfg_attr(test, feature(test))]\n \n extern crate core;\n-#[macro_use] extern crate log;\n+#[macro_use]\n+extern crate log;\n extern crate serialize as rustc_serialize; // used by deriving\n \n pub mod bitvec;"}, {"sha": "4f6d0d7e40562e4f302d05e1fb2c2bea01ab58d6", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 92, "deletions": 60, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=43dc48c7ffb45c714b33b1e47f23f6d711c89596", "patch": "@@ -28,7 +28,7 @@ use self::tree_index::TreeIndex;\n #[cfg(test)]\n mod test;\n \n-pub struct ObligationForest<O,T> {\n+pub struct ObligationForest<O, T> {\n     /// The list of obligations. In between calls to\n     /// `process_obligations`, this list only contains nodes in the\n     /// `Pending` or `Success` state (with a non-zero number of\n@@ -43,7 +43,7 @@ pub struct ObligationForest<O,T> {\n     /// backtrace iterator (which uses `split_at`).\n     nodes: Vec<Node<O>>,\n     trees: Vec<Tree<T>>,\n-    snapshots: Vec<usize>\n+    snapshots: Vec<usize>,\n }\n \n pub struct Snapshot {\n@@ -67,7 +67,9 @@ struct Node<O> {\n #[derive(Debug)]\n enum NodeState<O> {\n     /// Obligation not yet resolved to success or error.\n-    Pending { obligation: O },\n+    Pending {\n+        obligation: O,\n+    },\n \n     /// Obligation resolved to success; `num_incomplete_children`\n     /// indicates the number of children still in an \"incomplete\"\n@@ -77,21 +79,24 @@ enum NodeState<O> {\n     ///\n     /// Once all children have completed, success nodes are removed\n     /// from the vector by the compression step.\n-    Success { obligation: O, num_incomplete_children: usize },\n+    Success {\n+        obligation: O,\n+        num_incomplete_children: usize,\n+    },\n \n     /// This obligation was resolved to an error. Error nodes are\n     /// removed from the vector by the compression step.\n     Error,\n }\n \n #[derive(Debug)]\n-pub struct Outcome<O,E> {\n+pub struct Outcome<O, E> {\n     /// Obligations that were completely evaluated, including all\n     /// (transitive) subobligations.\n     pub completed: Vec<O>,\n \n     /// Backtrace of obligations that were found to be in error.\n-    pub errors: Vec<Error<O,E>>,\n+    pub errors: Vec<Error<O, E>>,\n \n     /// If true, then we saw no successful obligations, which means\n     /// there is no point in further iteration. This is based on the\n@@ -103,7 +108,7 @@ pub struct Outcome<O,E> {\n }\n \n #[derive(Debug, PartialEq, Eq)]\n-pub struct Error<O,E> {\n+pub struct Error<O, E> {\n     pub error: E,\n     pub backtrace: Vec<O>,\n }\n@@ -113,7 +118,7 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n         ObligationForest {\n             trees: vec![],\n             nodes: vec![],\n-            snapshots: vec![]\n+            snapshots: vec![],\n         }\n     }\n \n@@ -148,11 +153,12 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n         // snapshot but pushing trees, all nodes after that should be\n         // roots of other trees as well\n         let first_root_index = self.trees[trees_len].root.get();\n-        debug_assert!(\n-            self.nodes[first_root_index..]\n-                .iter()\n-                .zip(first_root_index..)\n-                .all(|(root, root_index)| self.trees[root.tree.get()].root.get() == root_index));\n+        debug_assert!(self.nodes[first_root_index..]\n+                          .iter()\n+                          .zip(first_root_index..)\n+                          .all(|(root, root_index)| {\n+                              self.trees[root.tree.get()].root.get() == root_index\n+                          }));\n \n         // Pop off tree/root pairs pushed during snapshot.\n         self.trees.truncate(trees_len);\n@@ -169,22 +175,28 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n     pub fn push_tree(&mut self, obligation: O, tree_state: T) {\n         let index = NodeIndex::new(self.nodes.len());\n         let tree = TreeIndex::new(self.trees.len());\n-        self.trees.push(Tree { root: index, state: tree_state });\n+        self.trees.push(Tree {\n+            root: index,\n+            state: tree_state,\n+        });\n         self.nodes.push(Node::new(tree, None, obligation));\n     }\n \n     /// Convert all remaining obligations to the given error.\n     ///\n     /// This cannot be done during a snapshot.\n-    pub fn to_errors<E:Clone>(&mut self, error: E) -> Vec<Error<O,E>> {\n+    pub fn to_errors<E: Clone>(&mut self, error: E) -> Vec<Error<O, E>> {\n         assert!(!self.in_snapshot());\n         let mut errors = vec![];\n         for index in 0..self.nodes.len() {\n             debug_assert!(!self.nodes[index].is_popped());\n             self.inherit_error(index);\n             if let NodeState::Pending { .. } = self.nodes[index].state {\n                 let backtrace = self.backtrace(index);\n-                errors.push(Error { error: error.clone(), backtrace: backtrace });\n+                errors.push(Error {\n+                    error: error.clone(),\n+                    backtrace: backtrace,\n+                });\n             }\n         }\n         let successful_obligations = self.compress();\n@@ -193,21 +205,27 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n     }\n \n     /// Returns the set of obligations that are in a pending state.\n-    pub fn pending_obligations(&self) -> Vec<O> where O: Clone {\n-        self.nodes.iter()\n-                  .filter_map(|n| match n.state {\n-                      NodeState::Pending { ref obligation } => Some(obligation),\n-                      _ => None,\n-                  })\n-                  .cloned()\n-                  .collect()\n+    pub fn pending_obligations(&self) -> Vec<O>\n+        where O: Clone\n+    {\n+        self.nodes\n+            .iter()\n+            .filter_map(|n| {\n+                match n.state {\n+                    NodeState::Pending { ref obligation } => Some(obligation),\n+                    _ => None,\n+                }\n+            })\n+            .cloned()\n+            .collect()\n     }\n \n     /// Process the obligations.\n     ///\n     /// This CANNOT be unrolled (presently, at least).\n-    pub fn process_obligations<E,F>(&mut self, mut action: F) -> Outcome<O,E>\n-        where E: Debug, F: FnMut(&mut O, &mut T, Backtrace<O>) -> Result<Option<Vec<O>>, E>\n+    pub fn process_obligations<E, F>(&mut self, mut action: F) -> Outcome<O, E>\n+        where E: Debug,\n+              F: FnMut(&mut O, &mut T, Backtrace<O>) -> Result<Option<Vec<O>>, E>\n     {\n         debug!(\"process_obligations(len={})\", self.nodes.len());\n         assert!(!self.in_snapshot()); // cannot unroll this action\n@@ -228,22 +246,25 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n             self.inherit_error(index);\n \n             debug!(\"process_obligations: node {} == {:?}\",\n-                   index, self.nodes[index].state);\n+                   index,\n+                   self.nodes[index].state);\n \n             let result = {\n                 let Node { tree, parent, .. } = self.nodes[index];\n                 let (prefix, suffix) = self.nodes.split_at_mut(index);\n                 let backtrace = Backtrace::new(prefix, parent);\n                 match suffix[0].state {\n                     NodeState::Error |\n-                    NodeState::Success { .. } =>\n-                        continue,\n-                    NodeState::Pending { ref mut obligation } =>\n-                        action(obligation, &mut self.trees[tree.get()].state, backtrace),\n+                    NodeState::Success { .. } => continue,\n+                    NodeState::Pending { ref mut obligation } => {\n+                        action(obligation, &mut self.trees[tree.get()].state, backtrace)\n+                    }\n                 }\n             };\n \n-            debug!(\"process_obligations: node {} got result {:?}\", index, result);\n+            debug!(\"process_obligations: node {} got result {:?}\",\n+                   index,\n+                   result);\n \n             match result {\n                 Ok(None) => {\n@@ -256,7 +277,10 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n                 }\n                 Err(err) => {\n                     let backtrace = self.backtrace(index);\n-                    errors.push(Error { error: err, backtrace: backtrace });\n+                    errors.push(Error {\n+                        error: err,\n+                        backtrace: backtrace,\n+                    });\n                 }\n             }\n         }\n@@ -291,20 +315,21 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n             // create child work\n             let tree_index = self.nodes[index].tree;\n             let node_index = NodeIndex::new(index);\n-            self.nodes.extend(\n-                children.into_iter()\n-                        .map(|o| Node::new(tree_index, Some(node_index), o)));\n+            self.nodes.extend(children.into_iter()\n+                                      .map(|o| Node::new(tree_index, Some(node_index), o)));\n         }\n \n         // change state from `Pending` to `Success`, temporarily swapping in `Error`\n         let state = mem::replace(&mut self.nodes[index].state, NodeState::Error);\n         self.nodes[index].state = match state {\n-            NodeState::Pending { obligation } =>\n-                NodeState::Success { obligation: obligation,\n-                                     num_incomplete_children: num_incomplete_children },\n+            NodeState::Pending { obligation } => {\n+                NodeState::Success {\n+                    obligation: obligation,\n+                    num_incomplete_children: num_incomplete_children,\n+                }\n+            }\n             NodeState::Success { .. } |\n-            NodeState::Error =>\n-                unreachable!()\n+            NodeState::Error => unreachable!(),\n         };\n     }\n \n@@ -358,14 +383,19 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n                     // there was an error in the ancestors, it should\n                     // have been propagated down and we should never\n                     // have tried to process this obligation\n-                    panic!(\"encountered error in node {:?} when collecting stack trace\", p);\n+                    panic!(\"encountered error in node {:?} when collecting stack trace\",\n+                           p);\n                 }\n             }\n \n             // loop to the parent\n             match self.nodes[p].parent {\n-                Some(q) => { p = q.get(); }\n-                None => { return trace; }\n+                Some(q) => {\n+                    p = q.get();\n+                }\n+                None => {\n+                    return trace;\n+                }\n             }\n         }\n     }\n@@ -427,18 +457,19 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n \n         // Pop off all the nodes we killed and extract the success\n         // stories.\n-        let successful =\n-            (0 .. dead_nodes)\n-            .map(|_| self.nodes.pop().unwrap())\n-            .flat_map(|node| match node.state {\n-                NodeState::Error => None,\n-                NodeState::Pending { .. } => unreachable!(),\n-                NodeState::Success { obligation, num_incomplete_children } => {\n-                    assert_eq!(num_incomplete_children, 0);\n-                    Some(obligation)\n-                }\n-            })\n-            .collect();\n+        let successful = (0..dead_nodes)\n+                             .map(|_| self.nodes.pop().unwrap())\n+                             .flat_map(|node| {\n+                                 match node.state {\n+                                     NodeState::Error => None,\n+                                     NodeState::Pending { .. } => unreachable!(),\n+                                     NodeState::Success { obligation, num_incomplete_children } => {\n+                                         assert_eq!(num_incomplete_children, 0);\n+                                         Some(obligation)\n+                                     }\n+                                 }\n+                             })\n+                             .collect();\n \n         // Adjust the various indices, since we compressed things.\n         for tree in &mut self.trees {\n@@ -484,7 +515,10 @@ pub struct Backtrace<'b, O: 'b> {\n \n impl<'b, O> Backtrace<'b, O> {\n     fn new(nodes: &'b [Node<O>], pointer: Option<NodeIndex>) -> Backtrace<'b, O> {\n-        Backtrace { nodes: nodes, pointer: pointer }\n+        Backtrace {\n+            nodes: nodes,\n+            pointer: pointer,\n+        }\n     }\n }\n \n@@ -497,9 +531,7 @@ impl<'b, O> Iterator for Backtrace<'b, O> {\n             self.pointer = self.nodes[p.get()].parent;\n             match self.nodes[p.get()].state {\n                 NodeState::Pending { ref obligation } |\n-                NodeState::Success { ref obligation, .. } => {\n-                    Some(obligation)\n-                }\n+                NodeState::Success { ref obligation, .. } => Some(obligation),\n                 NodeState::Error => {\n                     panic!(\"Backtrace encountered an error.\");\n                 }"}, {"sha": "1063bb3611ef3b3140a5ab277ce4a7cd1485a819", "filename": "src/librustc_data_structures/obligation_forest/node_index.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs?ref=43dc48c7ffb45c714b33b1e47f23f6d711c89596", "patch": "@@ -13,19 +13,16 @@ use std::u32;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct NodeIndex {\n-    index: NonZero<u32>\n+    index: NonZero<u32>,\n }\n \n impl NodeIndex {\n     pub fn new(value: usize) -> NodeIndex {\n         assert!(value < (u32::MAX as usize));\n-        unsafe {\n-            NodeIndex { index: NonZero::new((value as u32) + 1) }\n-        }\n+        unsafe { NodeIndex { index: NonZero::new((value as u32) + 1) } }\n     }\n \n     pub fn get(self) -> usize {\n         (*self.index - 1) as usize\n     }\n }\n-"}, {"sha": "a8c24270217bdc5828539c78d43edad826eba81e", "filename": "src/librustc_data_structures/obligation_forest/test.rs", "status": "modified", "additions": 60, "deletions": 45, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs?ref=43dc48c7ffb45c714b33b1e47f23f6d711c89596", "patch": "@@ -21,19 +21,23 @@ fn push_pop() {\n     //      A |-> A.1\n     //        |-> A.2\n     //        |-> A.3\n-    let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations(|obligation, tree, _| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n-            match *obligation {\n-                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n-                \"B\" => Err(\"B is for broken\"),\n-                \"C\" => Ok(Some(vec![])),\n-                _ => unreachable!(),\n-            }\n-        });\n+    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation,\n+                                                                                 tree,\n+                                                                                 _| {\n+        assert_eq!(obligation.chars().next(), tree.chars().next());\n+        match *obligation {\n+            \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n+            \"B\" => Err(\"B is for broken\"),\n+            \"C\" => Ok(Some(vec![])),\n+            _ => unreachable!(),\n+        }\n+    });\n     assert_eq!(ok, vec![\"C\"]);\n-    assert_eq!(err, vec![Error {error: \"B is for broken\",\n-                                backtrace: vec![\"B\"]}]);\n+    assert_eq!(err,\n+               vec![Error {\n+                        error: \"B is for broken\",\n+                        backtrace: vec![\"B\"],\n+                    }]);\n \n     // second round: two delays, one success, creating an uneven set of subtasks:\n     //      A |-> A.1\n@@ -61,33 +65,41 @@ fn push_pop() {\n     // propagates to A.3.i, but not D.1 or D.2.\n     //      D |-> D.1 |-> D.1.i\n     //        |-> D.2 |-> D.2.i\n-    let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations(|obligation, tree, _| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n-            match *obligation {\n-                \"A.1\" => Ok(Some(vec![])),\n-                \"A.2\" => Err(\"A is for apple\"),\n-                \"D.1\" => Ok(Some(vec![\"D.1.i\"])),\n-                \"D.2\" => Ok(Some(vec![\"D.2.i\"])),\n-                _ => unreachable!(),\n-            }\n-        });\n+    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation,\n+                                                                                 tree,\n+                                                                                 _| {\n+        assert_eq!(obligation.chars().next(), tree.chars().next());\n+        match *obligation {\n+            \"A.1\" => Ok(Some(vec![])),\n+            \"A.2\" => Err(\"A is for apple\"),\n+            \"D.1\" => Ok(Some(vec![\"D.1.i\"])),\n+            \"D.2\" => Ok(Some(vec![\"D.2.i\"])),\n+            _ => unreachable!(),\n+        }\n+    });\n     assert_eq!(ok, vec![\"A.1\"]);\n-    assert_eq!(err, vec![Error { error: \"A is for apple\",\n-                                 backtrace: vec![\"A.2\", \"A\"] }]);\n+    assert_eq!(err,\n+               vec![Error {\n+                        error: \"A is for apple\",\n+                        backtrace: vec![\"A.2\", \"A\"],\n+                    }]);\n \n     // fourth round: error in D.1.i that should propagate to D.2.i\n-    let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations(|obligation, tree, _| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n-            match *obligation {\n-                \"D.1.i\" => Err(\"D is for dumb\"),\n-                _ => panic!(\"unexpected obligation {:?}\", obligation),\n-            }\n-        });\n+    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation,\n+                                                                                 tree,\n+                                                                                 _| {\n+        assert_eq!(obligation.chars().next(), tree.chars().next());\n+        match *obligation {\n+            \"D.1.i\" => Err(\"D is for dumb\"),\n+            _ => panic!(\"unexpected obligation {:?}\", obligation),\n+        }\n+    });\n     assert_eq!(ok, Vec::<&'static str>::new());\n-    assert_eq!(err, vec![Error { error: \"D is for dumb\",\n-                                 backtrace: vec![\"D.1.i\", \"D.1\", \"D\"] }]);\n+    assert_eq!(err,\n+               vec![Error {\n+                        error: \"D is for dumb\",\n+                        backtrace: vec![\"D.1.i\", \"D.1\", \"D\"],\n+                    }]);\n }\n \n // Test that if a tree with grandchildren succeeds, everything is\n@@ -104,7 +116,7 @@ fn success_in_grandchildren() {\n     forest.push_tree(\"A\", \"A\");\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, tree, _| {\n+        forest.process_obligations::<(), _>(|obligation, tree, _| {\n             assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n@@ -115,7 +127,7 @@ fn success_in_grandchildren() {\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, tree, _| {\n+        forest.process_obligations::<(), _>(|obligation, tree, _| {\n             assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A.1\" => Ok(Some(vec![])),\n@@ -128,7 +140,7 @@ fn success_in_grandchildren() {\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, tree, _| {\n+        forest.process_obligations::<(), _>(|obligation, tree, _| {\n             assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A.2.i\" => Ok(Some(vec![\"A.2.i.a\"])),\n@@ -140,7 +152,7 @@ fn success_in_grandchildren() {\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, tree, _| {\n+        forest.process_obligations::<(), _>(|obligation, tree, _| {\n             assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A.2.i.a\" => Ok(Some(vec![])),\n@@ -150,8 +162,11 @@ fn success_in_grandchildren() {\n     assert_eq!(ok, vec![\"A.2.i.a\", \"A.2.i\", \"A.2\", \"A\"]);\n     assert!(err.is_empty());\n \n-    let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|_, _, _| unreachable!());\n+    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations::<(), _>(|_,\n+                                                                                          _,\n+                                                                                          _| {\n+        unreachable!()\n+    });\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n }\n@@ -163,7 +178,7 @@ fn to_errors_no_throw() {\n     let mut forest = ObligationForest::new();\n     forest.push_tree(\"A\", \"A\");\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, tree, _| {\n+        forest.process_obligations::<(), _>(|obligation, tree, _| {\n             assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n@@ -183,7 +198,7 @@ fn backtrace() {\n     let mut forest = ObligationForest::new();\n     forest.push_tree(\"A\", \"A\");\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, tree, mut backtrace| {\n+        forest.process_obligations::<(), _>(|obligation, tree, mut backtrace| {\n             assert_eq!(obligation.chars().next(), tree.chars().next());\n             assert!(backtrace.next().is_none());\n             match *obligation {\n@@ -194,7 +209,7 @@ fn backtrace() {\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, tree, mut backtrace| {\n+        forest.process_obligations::<(), _>(|obligation, tree, mut backtrace| {\n             assert_eq!(obligation.chars().next(), tree.chars().next());\n             assert!(backtrace.next().unwrap() == &\"A\");\n             assert!(backtrace.next().is_none());\n@@ -206,7 +221,7 @@ fn backtrace() {\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, tree, mut backtrace| {\n+        forest.process_obligations::<(), _>(|obligation, tree, mut backtrace| {\n             assert_eq!(obligation.chars().next(), tree.chars().next());\n             assert!(backtrace.next().unwrap() == &\"A.1\");\n             assert!(backtrace.next().unwrap() == &\"A\");"}, {"sha": "499448634acbdbeeea90e6ee39bfdec6371dd5ff", "filename": "src/librustc_data_structures/obligation_forest/tree_index.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftree_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftree_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftree_index.rs?ref=43dc48c7ffb45c714b33b1e47f23f6d711c89596", "patch": "@@ -12,7 +12,7 @@ use std::u32;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct TreeIndex {\n-    index: u32\n+    index: u32,\n }\n \n impl TreeIndex {\n@@ -25,4 +25,3 @@ impl TreeIndex {\n         self.index as usize\n     }\n }\n-"}, {"sha": "614e7aae74bbc9bd590c38a0377e2bda142e8cc5", "filename": "src/librustc_data_structures/snapshot_vec.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs?ref=43dc48c7ffb45c714b33b1e47f23f6d711c89596", "patch": "@@ -23,7 +23,7 @@ use self::UndoLog::*;\n use std::mem;\n use std::ops;\n \n-pub enum UndoLog<D:SnapshotVecDelegate> {\n+pub enum UndoLog<D: SnapshotVecDelegate> {\n     /// Indicates where a snapshot started.\n     OpenSnapshot,\n \n@@ -37,10 +37,10 @@ pub enum UndoLog<D:SnapshotVecDelegate> {\n     SetElem(usize, D::Value),\n \n     /// Extensible set of actions\n-    Other(D::Undo)\n+    Other(D::Undo),\n }\n \n-pub struct SnapshotVec<D:SnapshotVecDelegate> {\n+pub struct SnapshotVec<D: SnapshotVecDelegate> {\n     values: Vec<D::Value>,\n     undo_log: Vec<UndoLog<D>>,\n }\n@@ -58,7 +58,7 @@ pub trait SnapshotVecDelegate {\n     fn reverse(values: &mut Vec<Self::Value>, action: Self::Undo);\n }\n \n-impl<D:SnapshotVecDelegate> SnapshotVec<D> {\n+impl<D: SnapshotVecDelegate> SnapshotVec<D> {\n     pub fn new() -> SnapshotVec<D> {\n         SnapshotVec {\n             values: Vec::new(),\n@@ -117,9 +117,7 @@ impl<D:SnapshotVecDelegate> SnapshotVec<D> {\n         Snapshot { length: length }\n     }\n \n-    pub fn actions_since_snapshot(&self,\n-                                  snapshot: &Snapshot)\n-                                  -> &[UndoLog<D>] {\n+    pub fn actions_since_snapshot(&self, snapshot: &Snapshot) -> &[UndoLog<D>] {\n         &self.undo_log[snapshot.length..]\n     }\n \n@@ -128,11 +126,10 @@ impl<D:SnapshotVecDelegate> SnapshotVec<D> {\n         assert!(self.undo_log.len() > snapshot.length);\n \n         // Invariant established by start_snapshot():\n-        assert!(\n-            match self.undo_log[snapshot.length] {\n-                OpenSnapshot => true,\n-                _ => false\n-            });\n+        assert!(match self.undo_log[snapshot.length] {\n+            OpenSnapshot => true,\n+            _ => false,\n+        });\n     }\n \n     pub fn rollback_to(&mut self, snapshot: Snapshot) {\n@@ -168,7 +165,10 @@ impl<D:SnapshotVecDelegate> SnapshotVec<D> {\n         }\n \n         let v = self.undo_log.pop().unwrap();\n-        assert!(match v { OpenSnapshot => true, _ => false });\n+        assert!(match v {\n+            OpenSnapshot => true,\n+            _ => false,\n+        });\n         assert!(self.undo_log.len() == snapshot.length);\n     }\n \n@@ -188,20 +188,28 @@ impl<D:SnapshotVecDelegate> SnapshotVec<D> {\n     }\n }\n \n-impl<D:SnapshotVecDelegate> ops::Deref for SnapshotVec<D> {\n+impl<D: SnapshotVecDelegate> ops::Deref for SnapshotVec<D> {\n     type Target = [D::Value];\n-    fn deref(&self) -> &[D::Value] { &*self.values }\n+    fn deref(&self) -> &[D::Value] {\n+        &*self.values\n+    }\n }\n \n-impl<D:SnapshotVecDelegate> ops::DerefMut for SnapshotVec<D> {\n-    fn deref_mut(&mut self) -> &mut [D::Value] { &mut *self.values }\n+impl<D: SnapshotVecDelegate> ops::DerefMut for SnapshotVec<D> {\n+    fn deref_mut(&mut self) -> &mut [D::Value] {\n+        &mut *self.values\n+    }\n }\n \n-impl<D:SnapshotVecDelegate> ops::Index<usize> for SnapshotVec<D> {\n+impl<D: SnapshotVecDelegate> ops::Index<usize> for SnapshotVec<D> {\n     type Output = D::Value;\n-    fn index(&self, index: usize) -> &D::Value { self.get(index) }\n+    fn index(&self, index: usize) -> &D::Value {\n+        self.get(index)\n+    }\n }\n \n-impl<D:SnapshotVecDelegate> ops::IndexMut<usize> for SnapshotVec<D> {\n-    fn index_mut(&mut self, index: usize) -> &mut D::Value { self.get_mut(index) }\n+impl<D: SnapshotVecDelegate> ops::IndexMut<usize> for SnapshotVec<D> {\n+    fn index_mut(&mut self, index: usize) -> &mut D::Value {\n+        self.get_mut(index)\n+    }\n }"}, {"sha": "c3a2f978e1a8a4945f39ed8c091edbe5857ef762", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 63, "deletions": 55, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=43dc48c7ffb45c714b33b1e47f23f6d711c89596", "patch": "@@ -14,7 +14,7 @@ use std::fmt::Debug;\n use std::mem;\n \n #[derive(Clone)]\n-pub struct TransitiveRelation<T:Debug+PartialEq> {\n+pub struct TransitiveRelation<T: Debug + PartialEq> {\n     // List of elements. This is used to map from a T to a usize.  We\n     // expect domain to be small so just use a linear list versus a\n     // hashmap or something.\n@@ -33,7 +33,7 @@ pub struct TransitiveRelation<T:Debug+PartialEq> {\n     // are added with new elements. Perhaps better would be to ask the\n     // user for a batch of edges to minimize this effect, but I\n     // already wrote the code this way. :P -nmatsakis\n-    closure: RefCell<Option<BitMatrix>>\n+    closure: RefCell<Option<BitMatrix>>,\n }\n \n #[derive(Clone, PartialEq, PartialOrd)]\n@@ -45,11 +45,13 @@ struct Edge {\n     target: Index,\n }\n \n-impl<T:Debug+PartialEq> TransitiveRelation<T> {\n+impl<T: Debug + PartialEq> TransitiveRelation<T> {\n     pub fn new() -> TransitiveRelation<T> {\n-        TransitiveRelation { elements: vec![],\n-                             edges: vec![],\n-                             closure: RefCell::new(None) }\n+        TransitiveRelation {\n+            elements: vec![],\n+            edges: vec![],\n+            closure: RefCell::new(None),\n+        }\n     }\n \n     fn index(&self, a: &T) -> Option<Index> {\n@@ -74,7 +76,10 @@ impl<T:Debug+PartialEq> TransitiveRelation<T> {\n     pub fn add(&mut self, a: T, b: T) {\n         let a = self.add_index(a);\n         let b = self.add_index(b);\n-        let edge = Edge { source: a, target: b };\n+        let edge = Edge {\n+            source: a,\n+            target: b,\n+        };\n         if !self.edges.contains(&edge) {\n             self.edges.push(edge);\n \n@@ -86,10 +91,8 @@ impl<T:Debug+PartialEq> TransitiveRelation<T> {\n     /// Check whether `a < target` (transitively)\n     pub fn contains(&self, a: &T, b: &T) -> bool {\n         match (self.index(a), self.index(b)) {\n-            (Some(a), Some(b)) =>\n-                self.with_closure(|closure| closure.contains(a.0, b.0)),\n-            (None, _) | (_, None) =>\n-                false,\n+            (Some(a), Some(b)) => self.with_closure(|closure| closure.contains(a.0, b.0)),\n+            (None, _) | (_, None) => false,\n         }\n     }\n \n@@ -156,7 +159,9 @@ impl<T:Debug+PartialEq> TransitiveRelation<T> {\n     pub fn minimal_upper_bounds(&self, a: &T, b: &T) -> Vec<&T> {\n         let (mut a, mut b) = match (self.index(a), self.index(b)) {\n             (Some(a), Some(b)) => (a, b),\n-            (None, _) | (_, None) => { return vec![]; }\n+            (None, _) | (_, None) => {\n+                return vec![];\n+            }\n         };\n \n         // in some cases, there are some arbitrary choices to be made;\n@@ -233,7 +238,7 @@ impl<T:Debug+PartialEq> TransitiveRelation<T> {\n                    .collect()\n     }\n \n-    fn with_closure<OP,R>(&self, op: OP) -> R\n+    fn with_closure<OP, R>(&self, op: OP) -> R\n         where OP: FnOnce(&BitMatrix) -> R\n     {\n         let mut closure_cell = self.closure.borrow_mut();\n@@ -431,14 +436,15 @@ fn pdub_crisscross() {\n     // b -> b1 ---+\n \n     let mut relation = TransitiveRelation::new();\n-    relation.add(\"a\",  \"a1\");\n-    relation.add(\"a\",  \"b1\");\n-    relation.add(\"b\",  \"a1\");\n-    relation.add(\"b\",  \"b1\");\n+    relation.add(\"a\", \"a1\");\n+    relation.add(\"a\", \"b1\");\n+    relation.add(\"b\", \"a1\");\n+    relation.add(\"b\", \"b1\");\n     relation.add(\"a1\", \"x\");\n     relation.add(\"b1\", \"x\");\n \n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"a1\", &\"b1\"]);\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"),\n+               vec![&\"a1\", &\"b1\"]);\n     assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n }\n \n@@ -451,23 +457,25 @@ fn pdub_crisscross_more() {\n     // b -> b1 -> b2 ---------+\n \n     let mut relation = TransitiveRelation::new();\n-    relation.add(\"a\",  \"a1\");\n-    relation.add(\"a\",  \"b1\");\n-    relation.add(\"b\",  \"a1\");\n-    relation.add(\"b\",  \"b1\");\n+    relation.add(\"a\", \"a1\");\n+    relation.add(\"a\", \"b1\");\n+    relation.add(\"b\", \"a1\");\n+    relation.add(\"b\", \"b1\");\n \n-    relation.add(\"a1\",  \"a2\");\n-    relation.add(\"a1\",  \"b2\");\n-    relation.add(\"b1\",  \"a2\");\n-    relation.add(\"b1\",  \"b2\");\n+    relation.add(\"a1\", \"a2\");\n+    relation.add(\"a1\", \"b2\");\n+    relation.add(\"b1\", \"a2\");\n+    relation.add(\"b1\", \"b2\");\n \n     relation.add(\"a2\", \"a3\");\n \n     relation.add(\"a3\", \"x\");\n     relation.add(\"b2\", \"x\");\n \n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"a1\", &\"b1\"]);\n-    assert_eq!(relation.minimal_upper_bounds(&\"a1\", &\"b1\"), vec![&\"a2\", &\"b2\"]);\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"),\n+               vec![&\"a1\", &\"b1\"]);\n+    assert_eq!(relation.minimal_upper_bounds(&\"a1\", &\"b1\"),\n+               vec![&\"a2\", &\"b2\"]);\n     assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n }\n \n@@ -479,8 +487,8 @@ fn pdub_lub() {\n     // b -> b1 ---+\n \n     let mut relation = TransitiveRelation::new();\n-    relation.add(\"a\",  \"a1\");\n-    relation.add(\"b\",  \"b1\");\n+    relation.add(\"a\", \"a1\");\n+    relation.add(\"b\", \"b1\");\n     relation.add(\"a1\", \"x\");\n     relation.add(\"b1\", \"x\");\n \n@@ -497,9 +505,9 @@ fn mubs_intermediate_node_on_one_side_only() {\n \n     // \"digraph { a -> c -> d; b -> d; }\",\n     let mut relation = TransitiveRelation::new();\n-    relation.add(\"a\",  \"c\");\n-    relation.add(\"c\",  \"d\");\n-    relation.add(\"b\",  \"d\");\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"c\", \"d\");\n+    relation.add(\"b\", \"d\");\n \n     assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"d\"]);\n }\n@@ -516,11 +524,11 @@ fn mubs_scc_1() {\n \n     // \"digraph { a -> c -> d; d -> c; a -> d; b -> d; }\",\n     let mut relation = TransitiveRelation::new();\n-    relation.add(\"a\",  \"c\");\n-    relation.add(\"c\",  \"d\");\n-    relation.add(\"d\",  \"c\");\n-    relation.add(\"a\",  \"d\");\n-    relation.add(\"b\",  \"d\");\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"c\", \"d\");\n+    relation.add(\"d\", \"c\");\n+    relation.add(\"a\", \"d\");\n+    relation.add(\"b\", \"d\");\n \n     assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n }\n@@ -536,11 +544,11 @@ fn mubs_scc_2() {\n \n     // \"digraph { a -> c -> d; d -> c; b -> d; b -> c; }\",\n     let mut relation = TransitiveRelation::new();\n-    relation.add(\"a\",  \"c\");\n-    relation.add(\"c\",  \"d\");\n-    relation.add(\"d\",  \"c\");\n-    relation.add(\"b\",  \"d\");\n-    relation.add(\"b\",  \"c\");\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"c\", \"d\");\n+    relation.add(\"d\", \"c\");\n+    relation.add(\"b\", \"d\");\n+    relation.add(\"b\", \"c\");\n \n     assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n }\n@@ -556,12 +564,12 @@ fn mubs_scc_3() {\n \n     // \"digraph { a -> c -> d -> e -> c; b -> d; b -> e; }\",\n     let mut relation = TransitiveRelation::new();\n-    relation.add(\"a\",  \"c\");\n-    relation.add(\"c\",  \"d\");\n-    relation.add(\"d\",  \"e\");\n-    relation.add(\"e\",  \"c\");\n-    relation.add(\"b\",  \"d\");\n-    relation.add(\"b\",  \"e\");\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"c\", \"d\");\n+    relation.add(\"d\", \"e\");\n+    relation.add(\"e\", \"c\");\n+    relation.add(\"b\", \"d\");\n+    relation.add(\"b\", \"e\");\n \n     assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n }\n@@ -578,12 +586,12 @@ fn mubs_scc_4() {\n \n     // \"digraph { a -> c -> d -> e -> c; a -> d; b -> e; }\"\n     let mut relation = TransitiveRelation::new();\n-    relation.add(\"a\",  \"c\");\n-    relation.add(\"c\",  \"d\");\n-    relation.add(\"d\",  \"e\");\n-    relation.add(\"e\",  \"c\");\n-    relation.add(\"a\",  \"d\");\n-    relation.add(\"b\",  \"e\");\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"c\", \"d\");\n+    relation.add(\"d\", \"e\");\n+    relation.add(\"e\", \"c\");\n+    relation.add(\"a\", \"d\");\n+    relation.add(\"b\", \"e\");\n \n     assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n }"}, {"sha": "9a90ab8c09d44c58499da17b571a5388886980ac", "filename": "src/librustc_data_structures/tuple_slice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Ftuple_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Ftuple_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftuple_slice.rs?ref=43dc48c7ffb45c714b33b1e47f23f6d711c89596", "patch": "@@ -36,13 +36,13 @@ macro_rules! impl_tuple_slice {\n     }\n }\n \n-impl_tuple_slice!((T,T), 2);\n-impl_tuple_slice!((T,T,T), 3);\n-impl_tuple_slice!((T,T,T,T), 4);\n-impl_tuple_slice!((T,T,T,T,T), 5);\n-impl_tuple_slice!((T,T,T,T,T,T), 6);\n-impl_tuple_slice!((T,T,T,T,T,T,T), 7);\n-impl_tuple_slice!((T,T,T,T,T,T,T,T), 8);\n+impl_tuple_slice!((T, T), 2);\n+impl_tuple_slice!((T, T, T), 3);\n+impl_tuple_slice!((T, T, T, T), 4);\n+impl_tuple_slice!((T, T, T, T, T), 5);\n+impl_tuple_slice!((T, T, T, T, T, T), 6);\n+impl_tuple_slice!((T, T, T, T, T, T, T), 7);\n+impl_tuple_slice!((T, T, T, T, T, T, T, T), 8);\n \n #[test]\n fn test_sliced_tuples() {"}, {"sha": "fe7fa06c9622b88b4cc80272c6447324af478b46", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "modified", "additions": 44, "deletions": 47, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=43dc48c7ffb45c714b33b1e47f23f6d711c89596", "patch": "@@ -56,21 +56,21 @@ impl Combine for () {\n /// time of the algorithm under control. For more information, see\n /// <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n #[derive(PartialEq,Clone,Debug)]\n-pub struct VarValue<K:UnifyKey> {\n-    parent: K,       // if equal to self, this is a root\n+pub struct VarValue<K: UnifyKey> {\n+    parent: K, // if equal to self, this is a root\n     value: K::Value, // value assigned (only relevant to root)\n-    rank: u32,       // max depth (only relevant to root)\n+    rank: u32, // max depth (only relevant to root)\n }\n \n /// Table of unification keys and their values.\n-pub struct UnificationTable<K:UnifyKey> {\n+pub struct UnificationTable<K: UnifyKey> {\n     /// Indicates the current value of each key.\n     values: sv::SnapshotVec<Delegate<K>>,\n }\n \n /// At any time, users may snapshot a unification table.  The changes\n /// made during the snapshot may either be *committed* or *rolled back*.\n-pub struct Snapshot<K:UnifyKey> {\n+pub struct Snapshot<K: UnifyKey> {\n     // Link snapshot to the key type `K` of the table.\n     marker: marker::PhantomData<K>,\n     snapshot: sv::Snapshot,\n@@ -79,23 +79,29 @@ pub struct Snapshot<K:UnifyKey> {\n #[derive(Copy, Clone)]\n struct Delegate<K>(PhantomData<K>);\n \n-impl<K:UnifyKey> VarValue<K> {\n+impl<K: UnifyKey> VarValue<K> {\n     fn new_var(key: K, value: K::Value) -> VarValue<K> {\n         VarValue::new(key, value, 0)\n     }\n \n     fn new(parent: K, value: K::Value, rank: u32) -> VarValue<K> {\n-        VarValue { parent: parent, // this is a root\n-                   value: value,\n-                   rank: rank }\n+        VarValue {\n+            parent: parent, // this is a root\n+            value: value,\n+            rank: rank,\n+        }\n     }\n \n     fn redirect(self, to: K) -> VarValue<K> {\n         VarValue { parent: to, ..self }\n     }\n \n     fn root(self, rank: u32, value: K::Value) -> VarValue<K> {\n-        VarValue { rank: rank, value: value, ..self }\n+        VarValue {\n+            rank: rank,\n+            value: value,\n+            ..self\n+        }\n     }\n \n     /// Returns the key of this node. Only valid if this is a root\n@@ -122,18 +128,18 @@ impl<K:UnifyKey> VarValue<K> {\n // other type parameter U, and we have no way to say\n // Option<U>:LatticeValue.\n \n-impl<K:UnifyKey> UnificationTable<K> {\n+impl<K: UnifyKey> UnificationTable<K> {\n     pub fn new() -> UnificationTable<K> {\n-        UnificationTable {\n-            values: sv::SnapshotVec::new()\n-        }\n+        UnificationTable { values: sv::SnapshotVec::new() }\n     }\n \n     /// Starts a new snapshot. Each snapshot must be either\n     /// rolled back or committed in a \"LIFO\" (stack) order.\n     pub fn snapshot(&mut self) -> Snapshot<K> {\n-        Snapshot { marker: marker::PhantomData::<K>,\n-                   snapshot: self.values.start_snapshot() }\n+        Snapshot {\n+            marker: marker::PhantomData::<K>,\n+            snapshot: self.values.start_snapshot(),\n+        }\n     }\n \n     /// Reverses all changes since the last snapshot. Also\n@@ -154,9 +160,7 @@ impl<K:UnifyKey> UnificationTable<K> {\n         let len = self.values.len();\n         let key: K = UnifyKey::from_index(len as u32);\n         self.values.push(VarValue::new_var(key, value));\n-        debug!(\"{}: created new key: {:?}\",\n-               UnifyKey::tag(None::<K>),\n-               key);\n+        debug!(\"{}: created new key: {:?}\", UnifyKey::tag(None::<K>), key);\n         key\n     }\n \n@@ -179,9 +183,7 @@ impl<K:UnifyKey> UnificationTable<K> {\n                 }\n                 root\n             }\n-            None => {\n-                value\n-            }\n+            None => value,\n         }\n     }\n \n@@ -195,8 +197,7 @@ impl<K:UnifyKey> UnificationTable<K> {\n     fn set(&mut self, key: K, new_value: VarValue<K>) {\n         assert!(self.is_root(key));\n \n-        debug!(\"Updating variable {:?} to {:?}\",\n-               key, new_value);\n+        debug!(\"Updating variable {:?} to {:?}\", key, new_value);\n \n         let index = key.index() as usize;\n         self.values.set(index, new_value);\n@@ -243,7 +244,7 @@ impl<K:UnifyKey> UnificationTable<K> {\n     }\n }\n \n-impl<K:UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n+impl<K: UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n     type Value = VarValue<K>;\n     type Undo = ();\n \n@@ -253,7 +254,7 @@ impl<K:UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n ///////////////////////////////////////////////////////////////////////////\n // Base union-find algorithm, where we are just making sets\n \n-impl<'tcx,K:UnifyKey> UnificationTable<K>\n+impl<'tcx, K: UnifyKey> UnificationTable<K>\n     where K::Value: Combine\n {\n     pub fn union(&mut self, a_id: K, b_id: K) {\n@@ -285,30 +286,24 @@ impl<'tcx,K:UnifyKey> UnificationTable<K>\n // floats---anything that doesn't have a subtyping relationship we\n // need to worry about.\n \n-impl<'tcx,K,V> UnificationTable<K>\n-    where K: UnifyKey<Value=Option<V>>,\n-          V: Clone+PartialEq+Debug,\n+impl<'tcx, K, V> UnificationTable<K>\n+    where K: UnifyKey<Value = Option<V>>,\n+          V: Clone + PartialEq + Debug\n {\n-    pub fn unify_var_var(&mut self,\n-                         a_id: K,\n-                         b_id: K)\n-                         -> Result<(),(V,V)>\n-    {\n+    pub fn unify_var_var(&mut self, a_id: K, b_id: K) -> Result<(), (V, V)> {\n         let node_a = self.get(a_id);\n         let node_b = self.get(b_id);\n         let a_id = node_a.key();\n         let b_id = node_b.key();\n \n-        if a_id == b_id { return Ok(()); }\n+        if a_id == b_id {\n+            return Ok(());\n+        }\n \n         let combined = {\n             match (&node_a.value, &node_b.value) {\n-                (&None, &None) => {\n-                    None\n-                }\n-                (&Some(ref v), &None) | (&None, &Some(ref v)) => {\n-                    Some(v.clone())\n-                }\n+                (&None, &None) => None,\n+                (&Some(ref v), &None) | (&None, &Some(ref v)) => Some(v.clone()),\n                 (&Some(ref v1), &Some(ref v2)) => {\n                     if *v1 != *v2 {\n                         return Err((v1.clone(), v2.clone()));\n@@ -323,11 +318,7 @@ impl<'tcx,K,V> UnificationTable<K>\n \n     /// Sets the value of the key `a_id` to `b`. Because simple keys do not have any subtyping\n     /// relationships, if `a_id` already has a value, it must be the same as `b`.\n-    pub fn unify_var_value(&mut self,\n-                           a_id: K,\n-                           b: V)\n-                           -> Result<(),(V,V)>\n-    {\n+    pub fn unify_var_value(&mut self, a_id: K, b: V) -> Result<(), (V, V)> {\n         let mut node_a = self.get(a_id);\n \n         match node_a.value {\n@@ -358,7 +349,13 @@ impl<'tcx,K,V> UnificationTable<K>\n     pub fn unsolved_variables(&mut self) -> Vec<K> {\n         self.values\n             .iter()\n-            .filter_map(|vv| if vv.value.is_some() { None } else { Some(vv.key()) })\n+            .filter_map(|vv| {\n+                if vv.value.is_some() {\n+                    None\n+                } else {\n+                    Some(vv.key())\n+                }\n+            })\n             .collect()\n     }\n }"}, {"sha": "f29a7132e831b3f0e926968ce0d4fc6d843200fe", "filename": "src/librustc_data_structures/unify/tests.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Funify%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Funify%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Ftests.rs?ref=43dc48c7ffb45c714b33b1e47f23f6d711c89596", "patch": "@@ -19,9 +19,15 @@ struct UnitKey(u32);\n \n impl UnifyKey for UnitKey {\n     type Value = ();\n-    fn index(&self) -> u32 { self.0 }\n-    fn from_index(u: u32) -> UnitKey { UnitKey(u) }\n-    fn tag(_: Option<UnitKey>) -> &'static str { \"UnitKey\" }\n+    fn index(&self) -> u32 {\n+        self.0\n+    }\n+    fn from_index(u: u32) -> UnitKey {\n+        UnitKey(u)\n+    }\n+    fn tag(_: Option<UnitKey>) -> &'static str {\n+        \"UnitKey\"\n+    }\n }\n \n #[test]\n@@ -45,7 +51,7 @@ fn big_array() {\n     }\n \n     for i in 1..MAX {\n-        let l = keys[i-1];\n+        let l = keys[i - 1];\n         let r = keys[i];\n         ut.union(l, r);\n     }\n@@ -68,7 +74,7 @@ fn big_array_bench(b: &mut Bencher) {\n \n     b.iter(|| {\n         for i in 1..MAX {\n-            let l = keys[i-1];\n+            let l = keys[i - 1];\n             let r = keys[i];\n             ut.union(l, r);\n         }\n@@ -90,16 +96,16 @@ fn even_odd() {\n         keys.push(key);\n \n         if i >= 2 {\n-            ut.union(key, keys[i-2]);\n+            ut.union(key, keys[i - 2]);\n         }\n     }\n \n     for i in 1..MAX {\n-        assert!(!ut.unioned(keys[i-1], keys[i]));\n+        assert!(!ut.unioned(keys[i - 1], keys[i]));\n     }\n \n     for i in 2..MAX {\n-        assert!(ut.unioned(keys[i-2], keys[i]));\n+        assert!(ut.unioned(keys[i - 2], keys[i]));\n     }\n }\n \n@@ -108,9 +114,15 @@ struct IntKey(u32);\n \n impl UnifyKey for IntKey {\n     type Value = Option<i32>;\n-    fn index(&self) -> u32 { self.0 }\n-    fn from_index(u: u32) -> IntKey { IntKey(u) }\n-    fn tag(_: Option<IntKey>) -> &'static str { \"IntKey\" }\n+    fn index(&self) -> u32 {\n+        self.0\n+    }\n+    fn from_index(u: u32) -> IntKey {\n+        IntKey(u)\n+    }\n+    fn tag(_: Option<IntKey>) -> &'static str {\n+        \"IntKey\"\n+    }\n }\n \n /// Test unifying a key whose value is `Some(_)`  with a key whose value is `None`.\n@@ -191,4 +203,3 @@ fn unify_key_Some_x_val_x() {\n     assert!(ut.unify_var_value(k1, 22).is_ok());\n     assert_eq!(ut.probe(k1), Some(22));\n }\n-"}, {"sha": "054eee8829a4a73e0b38599ba2b3b058359b0b63", "filename": "src/librustc_data_structures/veccell/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fveccell%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dc48c7ffb45c714b33b1e47f23f6d711c89596/src%2Flibrustc_data_structures%2Fveccell%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fveccell%2Fmod.rs?ref=43dc48c7ffb45c714b33b1e47f23f6d711c89596", "patch": "@@ -12,11 +12,11 @@ use std::cell::UnsafeCell;\n use std::mem;\n \n pub struct VecCell<T> {\n-    data: UnsafeCell<Vec<T>>\n+    data: UnsafeCell<Vec<T>>,\n }\n \n impl<T> VecCell<T> {\n-    pub fn with_capacity(capacity: usize) -> VecCell<T>{\n+    pub fn with_capacity(capacity: usize) -> VecCell<T> {\n         VecCell { data: UnsafeCell::new(Vec::with_capacity(capacity)) }\n     }\n "}]}