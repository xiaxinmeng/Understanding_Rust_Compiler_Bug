{"sha": "84a343d1b5f4064863a1a4a83782454cf6c2ab37", "node_id": "C_kwDOAAsO6NoAKDg0YTM0M2QxYjVmNDA2NDg2M2ExYTRhODM3ODI0NTRjZjZjMmFiMzc", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-04-03T19:29:19Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-04-03T19:31:25Z"}, "message": "tweak some function names", "tree": {"sha": "a4e2d7c7ab37f4214a7700426d2a8e4120ae12cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4e2d7c7ab37f4214a7700426d2a8e4120ae12cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84a343d1b5f4064863a1a4a83782454cf6c2ab37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84a343d1b5f4064863a1a4a83782454cf6c2ab37", "html_url": "https://github.com/rust-lang/rust/commit/84a343d1b5f4064863a1a4a83782454cf6c2ab37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84a343d1b5f4064863a1a4a83782454cf6c2ab37/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0ec783bf94a4950f6b55cb91b043ec6ff0a4b03", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0ec783bf94a4950f6b55cb91b043ec6ff0a4b03", "html_url": "https://github.com/rust-lang/rust/commit/f0ec783bf94a4950f6b55cb91b043ec6ff0a4b03"}], "stats": {"total": 28, "additions": 14, "deletions": 14}, "files": [{"sha": "5aae4a90960048f7f15796378ee03d29ae39f530", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84a343d1b5f4064863a1a4a83782454cf6c2ab37/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a343d1b5f4064863a1a4a83782454cf6c2ab37/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=84a343d1b5f4064863a1a4a83782454cf6c2ab37", "patch": "@@ -364,7 +364,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n                 // If an allocation is created in an another const,\n                 // we don't deallocate it.\n-                let (alloc_id, _, _) = ecx.ptr_get_alloc(ptr)?;\n+                let (alloc_id, _, _) = ecx.ptr_get_alloc_id(ptr)?;\n                 let is_allocated_in_another_const = matches!(\n                     ecx.tcx.get_global_alloc(alloc_id),\n                     Some(interpret::GlobalAlloc::Memory(_))"}, {"sha": "a956a478cef9ee63e6240694d5c2c701f8bfb230", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84a343d1b5f4064863a1a4a83782454cf6c2ab37/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a343d1b5f4064863a1a4a83782454cf6c2ab37/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=84a343d1b5f4064863a1a4a83782454cf6c2ab37", "patch": "@@ -318,7 +318,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // exception from the exception.)\n                 // This is the dual to the special exception for offset-by-0\n                 // in the inbounds pointer offset operation (see `ptr_offset_inbounds` below).\n-                match (self.ptr_try_get_alloc(a), self.ptr_try_get_alloc(b)) {\n+                match (self.ptr_try_get_alloc_id(a), self.ptr_try_get_alloc_id(b)) {\n                     (Err(a), Err(b)) if a == b && a != 0 => {\n                         // Both are the same non-null integer.\n                         self.write_scalar(Scalar::from_machine_isize(0, self), dest)?;"}, {"sha": "fcfcd5d8989f5706523c81cc750b25f2412d57d9", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/84a343d1b5f4064863a1a4a83782454cf6c2ab37/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a343d1b5f4064863a1a4a83782454cf6c2ab37/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=84a343d1b5f4064863a1a4a83782454cf6c2ab37", "patch": "@@ -200,7 +200,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'static, Pointer<M::PointerTag>> {\n         let alloc = Allocation::uninit(size, align, M::PANIC_ON_ALLOC_FAIL)?;\n-        Ok(self.allocate_with_ptr(alloc, kind))\n+        Ok(self.allocate_raw_ptr(alloc, kind))\n     }\n \n     pub fn allocate_bytes_ptr(\n@@ -211,10 +211,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         mutability: Mutability,\n     ) -> Pointer<M::PointerTag> {\n         let alloc = Allocation::from_bytes(bytes, align, mutability);\n-        self.allocate_with_ptr(alloc, kind)\n+        self.allocate_raw_ptr(alloc, kind)\n     }\n \n-    pub fn allocate_with_ptr(\n+    pub fn allocate_raw_ptr(\n         &mut self,\n         alloc: Allocation,\n         kind: MemoryKind<M::MemoryKind>,\n@@ -238,7 +238,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        let (alloc_id, offset, ptr) = self.ptr_get_alloc(ptr)?;\n+        let (alloc_id, offset, ptr) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub_format!(\n                 \"reallocating {:?} which does not point to the beginning of an object\",\n@@ -274,7 +274,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         old_size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx> {\n-        let (alloc_id, offset, ptr) = self.ptr_get_alloc(ptr)?;\n+        let (alloc_id, offset, ptr) = self.ptr_get_alloc_id(ptr)?;\n         trace!(\"deallocating: {}\", alloc_id);\n \n         if offset.bytes() != 0 {\n@@ -419,7 +419,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         }\n \n-        Ok(match self.ptr_try_get_alloc(ptr) {\n+        Ok(match self.ptr_try_get_alloc_id(ptr) {\n             Err(addr) => {\n                 // We couldn't get a proper allocation. This is only okay if the access size is 0,\n                 // and the address is not null.\n@@ -731,7 +731,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         trace!(\"get_fn({:?})\", ptr);\n-        let (alloc_id, offset, _ptr) = self.ptr_get_alloc(ptr)?;\n+        let (alloc_id, offset, _ptr) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset)))\n         }\n@@ -1125,7 +1125,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Err(_) => {\n                 // Can only happen during CTFE.\n                 let ptr = self.scalar_to_ptr(scalar);\n-                match self.ptr_try_get_alloc(ptr) {\n+                match self.ptr_try_get_alloc_id(ptr) {\n                     Ok((alloc_id, offset, _)) => {\n                         let (size, _align) = self\n                             .get_alloc_size_and_align(alloc_id, AllocCheck::MaybeDead)\n@@ -1142,7 +1142,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     /// Turning a \"maybe pointer\" into a proper pointer (and some information\n     /// about where it points), or an absolute address.\n-    pub fn ptr_try_get_alloc(\n+    pub fn ptr_try_get_alloc_id(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> Result<(AllocId, Size, Pointer<M::PointerTag>), u64> {\n@@ -1157,11 +1157,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     /// Turning a \"maybe pointer\" into a proper pointer (and some information about where it points).\n     #[inline(always)]\n-    pub fn ptr_get_alloc(\n+    pub fn ptr_get_alloc_id(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> InterpResult<'tcx, (AllocId, Size, Pointer<M::PointerTag>)> {\n-        self.ptr_try_get_alloc(ptr).map_err(|offset| {\n+        self.ptr_try_get_alloc_id(ptr).map_err(|offset| {\n             err_ub!(DanglingIntPointer(offset, CheckInAllocMsg::InboundsTest)).into()\n         })\n     }"}, {"sha": "42ff7b1945918280878019cc1133c30e5ee5a360", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84a343d1b5f4064863a1a4a83782454cf6c2ab37/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a343d1b5f4064863a1a4a83782454cf6c2ab37/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=84a343d1b5f4064863a1a4a83782454cf6c2ab37", "patch": "@@ -432,7 +432,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         if let Some(ref mut ref_tracking) = self.ref_tracking {\n             // Proceed recursively even for ZST, no reason to skip them!\n             // `!` is a ZST and we want to validate it.\n-            if let Ok((alloc_id, _offset, _ptr)) = self.ecx.ptr_try_get_alloc(place.ptr) {\n+            if let Ok((alloc_id, _offset, _ptr)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {\n                 // Special handling for pointers to statics (irrespective of their type).\n                 let alloc_kind = self.ecx.tcx.get_global_alloc(alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {"}]}