{"sha": "c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46", "node_id": "C_kwDOAAsO6NoAKGMwN2NiYjllYTY1YmI0ZWQ0Yzc4ZmE0YjY2NDQ3NGVhMjM0YmJjNDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-14T08:59:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-14T08:59:40Z"}, "message": "Auto merge of #8901 - Jarcho:sharing_code, r=dswij\n\nRework `branches_sharing_code`\n\nfixes #7378\n\nThis changes the lint from checking pairs of blocks, to checking all the blocks at the same time. As such there's almost none of the original code left.\n\nchangelog: Don't lint `branches_sharing_code` when using different binding names", "tree": {"sha": "7c8f2f3206d3f48b446daea2b5c46e45d7caa6c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c8f2f3206d3f48b446daea2b5c46e45d7caa6c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46", "html_url": "https://github.com/rust-lang/rust/commit/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c80ca2c1d6c798334807b610a58d0dbfd95c6a75", "url": "https://api.github.com/repos/rust-lang/rust/commits/c80ca2c1d6c798334807b610a58d0dbfd95c6a75", "html_url": "https://github.com/rust-lang/rust/commit/c80ca2c1d6c798334807b610a58d0dbfd95c6a75"}, {"sha": "7975d41a915b7e2c0b5ce2e2ca47ab31b96d978a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7975d41a915b7e2c0b5ce2e2ca47ab31b96d978a", "html_url": "https://github.com/rust-lang/rust/commit/7975d41a915b7e2c0b5ce2e2ca47ab31b96d978a"}], "stats": {"total": 802, "additions": 355, "deletions": 447}, "files": [{"sha": "1deff9684a140abedbe5d1da5facb0f7bba1486f", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 278, "deletions": 397, "changes": 675, "blob_url": "https://github.com/rust-lang/rust/blob/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46", "patch": "@@ -1,18 +1,18 @@\n use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_then};\n use clippy_utils::source::{first_line_of_span, indent_of, reindent_multiline, snippet, snippet_opt};\n use clippy_utils::{\n-    both, count_eq, eq_expr_value, get_enclosing_block, get_parent_expr, if_sequence, is_else_clause, is_lint_allowed,\n-    search_same, ContainsName, SpanlessEq, SpanlessHash,\n+    eq_expr_value, get_enclosing_block, hash_expr, hash_stmt, if_sequence, is_else_clause, is_lint_allowed,\n+    search_same, ContainsName, HirEqInterExpr, SpanlessEq,\n };\n-use if_chain::if_chain;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Applicability, Diagnostic};\n-use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, HirId};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::hir::nested_filter;\n+use core::iter;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit;\n+use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{source_map::Span, symbol::Symbol, BytePos};\n+use rustc_span::hygiene::walk_chain;\n+use rustc_span::source_map::SourceMap;\n+use rustc_span::{BytePos, Span, Symbol};\n use std::borrow::Cow;\n \n declare_clippy_lint! {\n@@ -165,243 +165,315 @@ declare_lint_pass!(CopyAndPaste => [\n \n impl<'tcx> LateLintPass<'tcx> for CopyAndPaste {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if !expr.span.from_expansion() {\n-            if let ExprKind::If(_, _, _) = expr.kind {\n-                // skip ifs directly in else, it will be checked in the parent if\n-                if let Some(&Expr {\n-                    kind: ExprKind::If(_, _, Some(else_expr)),\n-                    ..\n-                }) = get_parent_expr(cx, expr)\n-                {\n-                    if else_expr.hir_id == expr.hir_id {\n-                        return;\n-                    }\n-                }\n-\n-                let (conds, blocks) = if_sequence(expr);\n-                // Conditions\n-                lint_same_cond(cx, &conds);\n-                lint_same_fns_in_if_cond(cx, &conds);\n-                // Block duplication\n-                lint_same_then_else(cx, &conds, &blocks, conds.len() == blocks.len(), expr);\n+        if !expr.span.from_expansion() && matches!(expr.kind, ExprKind::If(..)) && !is_else_clause(cx.tcx, expr) {\n+            let (conds, blocks) = if_sequence(expr);\n+            lint_same_cond(cx, &conds);\n+            lint_same_fns_in_if_cond(cx, &conds);\n+            let all_same =\n+                !is_lint_allowed(cx, IF_SAME_THEN_ELSE, expr.hir_id) && lint_if_same_then_else(cx, &conds, &blocks);\n+            if !all_same && conds.len() != blocks.len() {\n+                lint_branches_sharing_code(cx, &conds, &blocks, expr);\n             }\n         }\n     }\n }\n \n-/// Implementation of `BRANCHES_SHARING_CODE` and `IF_SAME_THEN_ELSE` if the blocks are equal.\n-fn lint_same_then_else<'tcx>(\n+/// Checks if the given expression is a let chain.\n+fn contains_let(e: &Expr<'_>) -> bool {\n+    match e.kind {\n+        ExprKind::Let(..) => true,\n+        ExprKind::Binary(op, lhs, rhs) if op.node == BinOpKind::And => {\n+            matches!(lhs.kind, ExprKind::Let(..)) || contains_let(rhs)\n+        },\n+        _ => false,\n+    }\n+}\n+\n+fn lint_if_same_then_else(cx: &LateContext<'_>, conds: &[&Expr<'_>], blocks: &[&Block<'_>]) -> bool {\n+    let mut eq = SpanlessEq::new(cx);\n+    blocks\n+        .array_windows::<2>()\n+        .enumerate()\n+        .fold(true, |all_eq, (i, &[lhs, rhs])| {\n+            if eq.eq_block(lhs, rhs) && !contains_let(conds[i]) && conds.get(i + 1).map_or(true, |e| !contains_let(e)) {\n+                span_lint_and_note(\n+                    cx,\n+                    IF_SAME_THEN_ELSE,\n+                    lhs.span,\n+                    \"this `if` has identical blocks\",\n+                    Some(rhs.span),\n+                    \"same as this\",\n+                );\n+                all_eq\n+            } else {\n+                false\n+            }\n+        })\n+}\n+\n+fn lint_branches_sharing_code<'tcx>(\n     cx: &LateContext<'tcx>,\n     conds: &[&'tcx Expr<'_>],\n     blocks: &[&Block<'tcx>],\n-    has_conditional_else: bool,\n     expr: &'tcx Expr<'_>,\n ) {\n     // We only lint ifs with multiple blocks\n-    if blocks.len() < 2 || is_else_clause(cx.tcx, expr) {\n-        return;\n-    }\n-\n-    // Check if each block has shared code\n-    let has_expr = blocks[0].expr.is_some();\n-\n-    let (start_eq, mut end_eq, expr_eq) = if let Some(block_eq) = scan_block_for_eq(cx, conds, blocks) {\n-        (block_eq.start_eq, block_eq.end_eq, block_eq.expr_eq)\n-    } else {\n+    let &[first_block, ref blocks @ ..] = blocks else {\n         return;\n     };\n-\n-    // BRANCHES_SHARING_CODE prerequisites\n-    if has_conditional_else || (start_eq == 0 && end_eq == 0 && (has_expr && !expr_eq)) {\n+    let &[.., last_block] = blocks else {\n         return;\n-    }\n-\n-    // Only the start is the same\n-    if start_eq != 0 && end_eq == 0 && (!has_expr || !expr_eq) {\n-        let block = blocks[0];\n-        let start_stmts = block.stmts.split_at(start_eq).0;\n-\n-        let mut start_walker = UsedValueFinderVisitor::new(cx);\n-        for stmt in start_stmts {\n-            intravisit::walk_stmt(&mut start_walker, stmt);\n-        }\n+    };\n \n-        emit_branches_sharing_code_lint(\n-            cx,\n-            start_eq,\n-            0,\n-            false,\n-            check_for_warn_of_moved_symbol(cx, &start_walker.def_symbols, expr),\n-            blocks,\n-            expr,\n-        );\n-    } else if end_eq != 0 || (has_expr && expr_eq) {\n-        let block = blocks[blocks.len() - 1];\n-        let (start_stmts, block_stmts) = block.stmts.split_at(start_eq);\n-        let (block_stmts, end_stmts) = block_stmts.split_at(block_stmts.len() - end_eq);\n+    let res = scan_block_for_eq(cx, conds, first_block, blocks);\n+    let sm = cx.tcx.sess.source_map();\n+    let start_suggestion = res.start_span(first_block, sm).map(|span| {\n+        let first_line_span = first_line_of_span(cx, expr.span);\n+        let replace_span = first_line_span.with_hi(span.hi());\n+        let cond_span = first_line_span.until(first_block.span);\n+        let cond_snippet = reindent_multiline(snippet(cx, cond_span, \"_\"), false, None);\n+        let cond_indent = indent_of(cx, cond_span);\n+        let moved_snippet = reindent_multiline(snippet(cx, span, \"_\"), true, None);\n+        let suggestion = moved_snippet.to_string() + \"\\n\" + &cond_snippet + \"{\";\n+        let suggestion = reindent_multiline(Cow::Borrowed(&suggestion), true, cond_indent);\n+        (replace_span, suggestion.to_string())\n+    });\n+    let end_suggestion = res.end_span(last_block, sm).map(|span| {\n+        let moved_snipped = reindent_multiline(snippet(cx, span, \"_\"), true, None);\n+        let indent = indent_of(cx, expr.span.shrink_to_hi());\n+        let suggestion = \"}\\n\".to_string() + &moved_snipped;\n+        let suggestion = reindent_multiline(Cow::Borrowed(&suggestion), true, indent);\n \n-        // Scan start\n-        let mut start_walker = UsedValueFinderVisitor::new(cx);\n-        for stmt in start_stmts {\n-            intravisit::walk_stmt(&mut start_walker, stmt);\n+        let span = span.with_hi(last_block.span.hi());\n+        // Improve formatting if the inner block has indention (i.e. normal Rust formatting)\n+        let test_span = Span::new(span.lo() - BytePos(4), span.lo(), span.ctxt(), span.parent());\n+        let span = if snippet_opt(cx, test_span).map_or(false, |snip| snip == \"    \") {\n+            span.with_lo(test_span.lo())\n+        } else {\n+            span\n+        };\n+        (span, suggestion.to_string())\n+    });\n+\n+    let (span, msg, end_span) = match (&start_suggestion, &end_suggestion) {\n+        (&Some((span, _)), &Some((end_span, _))) => (\n+            span,\n+            \"all if blocks contain the same code at both the start and the end\",\n+            Some(end_span),\n+        ),\n+        (&Some((span, _)), None) => (span, \"all if blocks contain the same code at the start\", None),\n+        (None, &Some((span, _))) => (span, \"all if blocks contain the same code at the end\", None),\n+        (None, None) => return,\n+    };\n+    span_lint_and_then(cx, BRANCHES_SHARING_CODE, span, msg, |diag| {\n+        if let Some(span) = end_span {\n+            diag.span_note(span, \"this code is shared at the end\");\n         }\n-        let mut moved_syms = start_walker.def_symbols;\n-\n-        // Scan block\n-        let mut block_walker = UsedValueFinderVisitor::new(cx);\n-        for stmt in block_stmts {\n-            intravisit::walk_stmt(&mut block_walker, stmt);\n+        if let Some((span, sugg)) = start_suggestion {\n+            diag.span_suggestion(\n+                span,\n+                \"consider moving these statements before the if\",\n+                sugg,\n+                Applicability::Unspecified,\n+            );\n         }\n-        let mut block_defs = block_walker.defs;\n-\n-        // Scan moved stmts\n-        let mut moved_start: Option<usize> = None;\n-        let mut end_walker = UsedValueFinderVisitor::new(cx);\n-        for (index, stmt) in end_stmts.iter().enumerate() {\n-            intravisit::walk_stmt(&mut end_walker, stmt);\n-\n-            for value in &end_walker.uses {\n-                // Well we can't move this and all prev statements. So reset\n-                if block_defs.contains(value) {\n-                    moved_start = Some(index + 1);\n-                    end_walker.defs.drain().for_each(|x| {\n-                        block_defs.insert(x);\n-                    });\n-\n-                    end_walker.def_symbols.clear();\n-                }\n+        if let Some((span, sugg)) = end_suggestion {\n+            diag.span_suggestion(\n+                span,\n+                \"consider moving these statements after the if\",\n+                sugg,\n+                Applicability::Unspecified,\n+            );\n+            if !cx.typeck_results().expr_ty(expr).is_unit() {\n+                diag.note(\"the end suggestion probably needs some adjustments to use the expression result correctly\");\n             }\n-\n-            end_walker.uses.clear();\n         }\n-\n-        if let Some(moved_start) = moved_start {\n-            end_eq -= moved_start;\n+        if check_for_warn_of_moved_symbol(cx, &res.moved_locals, expr) {\n+            diag.warn(\"some moved values might need to be renamed to avoid wrong references\");\n         }\n+    });\n+}\n \n-        let end_linable = block.expr.map_or_else(\n-            || end_eq != 0,\n-            |expr| {\n-                intravisit::walk_expr(&mut end_walker, expr);\n-                end_walker.uses.iter().any(|x| !block_defs.contains(x))\n-            },\n-        );\n-\n-        if end_linable {\n-            end_walker.def_symbols.drain().for_each(|x| {\n-                moved_syms.insert(x);\n-            });\n+struct BlockEq {\n+    /// The end of the range of equal stmts at the start.\n+    start_end_eq: usize,\n+    /// The start of the range of equal stmts at the end.\n+    end_begin_eq: Option<usize>,\n+    /// The name and id of every local which can be moved at the beginning and the end.\n+    moved_locals: Vec<(HirId, Symbol)>,\n+}\n+impl BlockEq {\n+    fn start_span(&self, b: &Block<'_>, sm: &SourceMap) -> Option<Span> {\n+        match &b.stmts[..self.start_end_eq] {\n+            [first, .., last] => Some(sm.stmt_span(first.span, b.span).to(sm.stmt_span(last.span, b.span))),\n+            [s] => Some(sm.stmt_span(s.span, b.span)),\n+            [] => None,\n         }\n+    }\n \n-        emit_branches_sharing_code_lint(\n-            cx,\n-            start_eq,\n-            end_eq,\n-            end_linable,\n-            check_for_warn_of_moved_symbol(cx, &moved_syms, expr),\n-            blocks,\n-            expr,\n-        );\n+    fn end_span(&self, b: &Block<'_>, sm: &SourceMap) -> Option<Span> {\n+        match (&b.stmts[b.stmts.len() - self.end_begin_eq?..], b.expr) {\n+            ([first, .., last], None) => Some(sm.stmt_span(first.span, b.span).to(sm.stmt_span(last.span, b.span))),\n+            ([first, ..], Some(last)) => Some(sm.stmt_span(first.span, b.span).to(sm.stmt_span(last.span, b.span))),\n+            ([s], None) => Some(sm.stmt_span(s.span, b.span)),\n+            ([], Some(e)) => Some(walk_chain(e.span, b.span.ctxt())),\n+            ([], None) => None,\n+        }\n     }\n }\n \n-struct BlockEqual {\n-    /// The amount statements that are equal from the start\n-    start_eq: usize,\n-    /// The amount statements that are equal from the end\n-    end_eq: usize,\n-    ///  An indication if the block expressions are the same. This will also be true if both are\n-    /// `None`\n-    expr_eq: bool,\n+/// If the statement is a local, checks if the bound names match the expected list of names.\n+fn eq_binding_names(s: &Stmt<'_>, names: &[(HirId, Symbol)]) -> bool {\n+    if let StmtKind::Local(l) = s.kind {\n+        let mut i = 0usize;\n+        let mut res = true;\n+        l.pat.each_binding_or_first(&mut |_, _, _, name| {\n+            if names.get(i).map_or(false, |&(_, n)| n == name.name) {\n+                i += 1;\n+            } else {\n+                res = false;\n+            }\n+        });\n+        res && i == names.len()\n+    } else {\n+        false\n+    }\n }\n \n-/// This function can also trigger the `IF_SAME_THEN_ELSE` in which case it'll return `None` to\n-/// abort any further processing and avoid duplicate lint triggers.\n-fn scan_block_for_eq(cx: &LateContext<'_>, conds: &[&Expr<'_>], blocks: &[&Block<'_>]) -> Option<BlockEqual> {\n-    let mut start_eq = usize::MAX;\n-    let mut end_eq = usize::MAX;\n-    let mut expr_eq = true;\n-    let mut iter = blocks.windows(2).enumerate();\n-    while let Some((i, &[block0, block1])) = iter.next() {\n-        let l_stmts = block0.stmts;\n-        let r_stmts = block1.stmts;\n-\n-        // `SpanlessEq` now keeps track of the locals and is therefore context sensitive clippy#6752.\n-        // The comparison therefore needs to be done in a way that builds the correct context.\n-        let mut evaluator = SpanlessEq::new(cx);\n-        let mut evaluator = evaluator.inter_expr();\n-\n-        let current_start_eq = count_eq(&mut l_stmts.iter(), &mut r_stmts.iter(), |l, r| evaluator.eq_stmt(l, r));\n+/// Checks if the given statement should be considered equal to the statement in the same position\n+/// for each block.\n+fn eq_stmts(\n+    stmt: &Stmt<'_>,\n+    blocks: &[&Block<'_>],\n+    get_stmt: impl for<'a> Fn(&'a Block<'a>) -> Option<&'a Stmt<'a>>,\n+    eq: &mut HirEqInterExpr<'_, '_, '_>,\n+    moved_bindings: &mut Vec<(HirId, Symbol)>,\n+) -> bool {\n+    (if let StmtKind::Local(l) = stmt.kind {\n+        let old_count = moved_bindings.len();\n+        l.pat.each_binding_or_first(&mut |_, id, _, name| {\n+            moved_bindings.push((id, name.name));\n+        });\n+        let new_bindings = &moved_bindings[old_count..];\n+        blocks\n+            .iter()\n+            .all(|b| get_stmt(b).map_or(false, |s| eq_binding_names(s, new_bindings)))\n+    } else {\n+        true\n+    }) && blocks\n+        .iter()\n+        .all(|b| get_stmt(b).map_or(false, |s| eq.eq_stmt(s, stmt)))\n+}\n \n-        let current_end_eq = {\n-            // We skip the middle statements which can't be equal\n-            let end_comparison_count = l_stmts.len().min(r_stmts.len()) - current_start_eq;\n-            let it1 = l_stmts.iter().skip(l_stmts.len() - end_comparison_count);\n-            let it2 = r_stmts.iter().skip(r_stmts.len() - end_comparison_count);\n-            it1.zip(it2)\n-                .fold(0, |acc, (l, r)| if evaluator.eq_stmt(l, r) { acc + 1 } else { 0 })\n+fn scan_block_for_eq(cx: &LateContext<'_>, _conds: &[&Expr<'_>], block: &Block<'_>, blocks: &[&Block<'_>]) -> BlockEq {\n+    let mut eq = SpanlessEq::new(cx);\n+    let mut eq = eq.inter_expr();\n+    let mut moved_locals = Vec::new();\n+\n+    let start_end_eq = block\n+        .stmts\n+        .iter()\n+        .enumerate()\n+        .find(|&(i, stmt)| !eq_stmts(stmt, blocks, |b| b.stmts.get(i), &mut eq, &mut moved_locals))\n+        .map_or(block.stmts.len(), |(i, _)| i);\n+\n+    // Walk backwards through the final expression/statements so long as their hashes are equal. Note\n+    // `SpanlessHash` treats all local references as equal allowing locals declared earlier in the block\n+    // to match those in other blocks. e.g. If each block ends with the following the hash value will be\n+    // the same even though each `x` binding will have a different `HirId`:\n+    //     let x = foo();\n+    //     x + 50\n+    let expr_hash_eq = if let Some(e) = block.expr {\n+        let hash = hash_expr(cx, e);\n+        blocks\n+            .iter()\n+            .all(|b| b.expr.map_or(false, |e| hash_expr(cx, e) == hash))\n+    } else {\n+        blocks.iter().all(|b| b.expr.is_none())\n+    };\n+    if !expr_hash_eq {\n+        return BlockEq {\n+            start_end_eq,\n+            end_begin_eq: None,\n+            moved_locals,\n         };\n-        let block_expr_eq = both(&block0.expr, &block1.expr, |l, r| evaluator.eq_expr(l, r));\n-\n-        // IF_SAME_THEN_ELSE\n-        if_chain! {\n-            if block_expr_eq;\n-            if l_stmts.len() == r_stmts.len();\n-            if l_stmts.len() == current_start_eq;\n-            // `conds` may have one last item than `blocks`.\n-            // Any `i` from `blocks.windows(2)` will exist in `conds`, but `i+1` may not exist on the last iteration.\n-            if !matches!(conds[i].kind, ExprKind::Let(..));\n-            if !matches!(conds.get(i + 1).map(|e| &e.kind), Some(ExprKind::Let(..)));\n-            if !is_lint_allowed(cx, IF_SAME_THEN_ELSE, block0.hir_id);\n-            if !is_lint_allowed(cx, IF_SAME_THEN_ELSE, block1.hir_id);\n-            then {\n-                span_lint_and_note(\n-                    cx,\n-                    IF_SAME_THEN_ELSE,\n-                    block0.span,\n-                    \"this `if` has identical blocks\",\n-                    Some(block1.span),\n-                    \"same as this\",\n-                );\n-\n-                return None;\n+    }\n+    let end_search_start = block.stmts[start_end_eq..]\n+        .iter()\n+        .rev()\n+        .enumerate()\n+        .find(|&(offset, stmt)| {\n+            let hash = hash_stmt(cx, stmt);\n+            blocks.iter().any(|b| {\n+                b.stmts\n+                    // the bounds check will catch the underflow\n+                    .get(b.stmts.len().wrapping_sub(offset + 1))\n+                    .map_or(true, |s| hash != hash_stmt(cx, s))\n+            })\n+        })\n+        .map_or(block.stmts.len() - start_end_eq, |(i, _)| i);\n+\n+    let moved_locals_at_start = moved_locals.len();\n+    let mut i = end_search_start;\n+    let end_begin_eq = block.stmts[block.stmts.len() - end_search_start..]\n+        .iter()\n+        .zip(iter::repeat_with(move || {\n+            let x = i;\n+            i -= 1;\n+            x\n+        }))\n+        .fold(end_search_start, |init, (stmt, offset)| {\n+            if eq_stmts(\n+                stmt,\n+                blocks,\n+                |b| b.stmts.get(b.stmts.len() - offset),\n+                &mut eq,\n+                &mut moved_locals,\n+            ) {\n+                init\n+            } else {\n+                // Clear out all locals seen at the end so far. None of them can be moved.\n+                let stmts = &blocks[0].stmts;\n+                for stmt in &stmts[stmts.len() - init..=stmts.len() - offset] {\n+                    if let StmtKind::Local(l) = stmt.kind {\n+                        l.pat.each_binding_or_first(&mut |_, id, _, _| {\n+                            eq.locals.remove(&id);\n+                        });\n+                    }\n+                }\n+                moved_locals.truncate(moved_locals_at_start);\n+                offset - 1\n+            }\n+        });\n+    if let Some(e) = block.expr {\n+        for block in blocks {\n+            if block.expr.map_or(false, |expr| !eq.eq_expr(expr, e)) {\n+                moved_locals.truncate(moved_locals_at_start);\n+                return BlockEq {\n+                    start_end_eq,\n+                    end_begin_eq: None,\n+                    moved_locals,\n+                };\n             }\n         }\n-\n-        start_eq = start_eq.min(current_start_eq);\n-        end_eq = end_eq.min(current_end_eq);\n-        expr_eq &= block_expr_eq;\n-    }\n-\n-    if !expr_eq {\n-        end_eq = 0;\n     }\n \n-    // Check if the regions are overlapping. Set `end_eq` to prevent the overlap\n-    let min_block_size = blocks.iter().map(|x| x.stmts.len()).min().unwrap();\n-    if (start_eq + end_eq) > min_block_size {\n-        end_eq = min_block_size - start_eq;\n+    BlockEq {\n+        start_end_eq,\n+        end_begin_eq: Some(end_begin_eq),\n+        moved_locals,\n     }\n-\n-    Some(BlockEqual {\n-        start_eq,\n-        end_eq,\n-        expr_eq,\n-    })\n }\n \n-fn check_for_warn_of_moved_symbol(cx: &LateContext<'_>, symbols: &FxHashSet<Symbol>, if_expr: &Expr<'_>) -> bool {\n+fn check_for_warn_of_moved_symbol(cx: &LateContext<'_>, symbols: &[(HirId, Symbol)], if_expr: &Expr<'_>) -> bool {\n     get_enclosing_block(cx, if_expr.hir_id).map_or(false, |block| {\n         let ignore_span = block.span.shrink_to_lo().to(if_expr.span);\n \n         symbols\n             .iter()\n-            .filter(|sym| !sym.as_str().starts_with('_'))\n-            .any(move |sym| {\n-                let mut walker = ContainsName {\n-                    name: *sym,\n-                    result: false,\n-                };\n+            .filter(|&&(_, name)| !name.as_str().starts_with('_'))\n+            .any(|&(_, name)| {\n+                let mut walker = ContainsName { name, result: false };\n \n                 // Scan block\n                 block\n@@ -419,194 +491,9 @@ fn check_for_warn_of_moved_symbol(cx: &LateContext<'_>, symbols: &FxHashSet<Symb\n     })\n }\n \n-fn emit_branches_sharing_code_lint(\n-    cx: &LateContext<'_>,\n-    start_stmts: usize,\n-    end_stmts: usize,\n-    lint_end: bool,\n-    warn_about_moved_symbol: bool,\n-    blocks: &[&Block<'_>],\n-    if_expr: &Expr<'_>,\n-) {\n-    if start_stmts == 0 && !lint_end {\n-        return;\n-    }\n-\n-    // (help, span, suggestion)\n-    let mut suggestions: Vec<(&str, Span, String)> = vec![];\n-    let mut add_expr_note = false;\n-\n-    // Construct suggestions\n-    let sm = cx.sess().source_map();\n-    if start_stmts > 0 {\n-        let block = blocks[0];\n-        let span_start = first_line_of_span(cx, if_expr.span).shrink_to_lo();\n-        let span_end = sm.stmt_span(block.stmts[start_stmts - 1].span, block.span);\n-\n-        let cond_span = first_line_of_span(cx, if_expr.span).until(block.span);\n-        let cond_snippet = reindent_multiline(snippet(cx, cond_span, \"_\"), false, None);\n-        let cond_indent = indent_of(cx, cond_span);\n-        let moved_span = block.stmts[0].span.source_callsite().to(span_end);\n-        let moved_snippet = reindent_multiline(snippet(cx, moved_span, \"_\"), true, None);\n-        let suggestion = moved_snippet.to_string() + \"\\n\" + &cond_snippet + \"{\";\n-        let suggestion = reindent_multiline(Cow::Borrowed(&suggestion), true, cond_indent);\n-\n-        let span = span_start.to(span_end);\n-        suggestions.push((\"start\", span, suggestion.to_string()));\n-    }\n-\n-    if lint_end {\n-        let block = blocks[blocks.len() - 1];\n-        let span_end = block.span.shrink_to_hi();\n-\n-        let moved_start = if end_stmts == 0 && block.expr.is_some() {\n-            block.expr.unwrap().span.source_callsite()\n-        } else {\n-            sm.stmt_span(block.stmts[block.stmts.len() - end_stmts].span, block.span)\n-        };\n-        let moved_end = block.expr.map_or_else(\n-            || sm.stmt_span(block.stmts[block.stmts.len() - 1].span, block.span),\n-            |expr| expr.span.source_callsite(),\n-        );\n-\n-        let moved_span = moved_start.to(moved_end);\n-        let moved_snipped = reindent_multiline(snippet(cx, moved_span, \"_\"), true, None);\n-        let indent = indent_of(cx, if_expr.span.shrink_to_hi());\n-        let suggestion = \"}\\n\".to_string() + &moved_snipped;\n-        let suggestion = reindent_multiline(Cow::Borrowed(&suggestion), true, indent);\n-\n-        let mut span = moved_start.to(span_end);\n-        // Improve formatting if the inner block has indention (i.e. normal Rust formatting)\n-        let test_span = Span::new(span.lo() - BytePos(4), span.lo(), span.ctxt(), span.parent());\n-        if snippet_opt(cx, test_span)\n-            .map(|snip| snip == \"    \")\n-            .unwrap_or_default()\n-        {\n-            span = span.with_lo(test_span.lo());\n-        }\n-\n-        suggestions.push((\"end\", span, suggestion.to_string()));\n-        add_expr_note = !cx.typeck_results().expr_ty(if_expr).is_unit();\n-    }\n-\n-    let add_optional_msgs = |diag: &mut Diagnostic| {\n-        if add_expr_note {\n-            diag.note(\"The end suggestion probably needs some adjustments to use the expression result correctly\");\n-        }\n-\n-        if warn_about_moved_symbol {\n-            diag.warn(\"Some moved values might need to be renamed to avoid wrong references\");\n-        }\n-    };\n-\n-    // Emit lint\n-    if suggestions.len() == 1 {\n-        let (place_str, span, sugg) = suggestions.pop().unwrap();\n-        let msg = format!(\"all if blocks contain the same code at the {}\", place_str);\n-        let help = format!(\"consider moving the {} statements out like this\", place_str);\n-        span_lint_and_then(cx, BRANCHES_SHARING_CODE, span, msg.as_str(), |diag| {\n-            diag.span_suggestion(span, help.as_str(), sugg, Applicability::Unspecified);\n-\n-            add_optional_msgs(diag);\n-        });\n-    } else if suggestions.len() == 2 {\n-        let (_, end_span, end_sugg) = suggestions.pop().unwrap();\n-        let (_, start_span, start_sugg) = suggestions.pop().unwrap();\n-        span_lint_and_then(\n-            cx,\n-            BRANCHES_SHARING_CODE,\n-            start_span,\n-            \"all if blocks contain the same code at the start and the end. Here at the start\",\n-            move |diag| {\n-                diag.span_note(end_span, \"and here at the end\");\n-\n-                diag.span_suggestion(\n-                    start_span,\n-                    \"consider moving the start statements out like this\",\n-                    start_sugg,\n-                    Applicability::Unspecified,\n-                );\n-\n-                diag.span_suggestion(\n-                    end_span,\n-                    \"and consider moving the end statements out like this\",\n-                    end_sugg,\n-                    Applicability::Unspecified,\n-                );\n-\n-                add_optional_msgs(diag);\n-            },\n-        );\n-    }\n-}\n-\n-/// This visitor collects `HirId`s and Symbols of defined symbols and `HirId`s of used values.\n-struct UsedValueFinderVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-\n-    /// The `HirId`s of defined values in the scanned statements\n-    defs: FxHashSet<HirId>,\n-\n-    /// The Symbols of the defined symbols in the scanned statements\n-    def_symbols: FxHashSet<Symbol>,\n-\n-    /// The `HirId`s of the used values\n-    uses: FxHashSet<HirId>,\n-}\n-\n-impl<'a, 'tcx> UsedValueFinderVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'tcx>) -> Self {\n-        UsedValueFinderVisitor {\n-            cx,\n-            defs: FxHashSet::default(),\n-            def_symbols: FxHashSet::default(),\n-            uses: FxHashSet::default(),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for UsedValueFinderVisitor<'a, 'tcx> {\n-    type NestedFilter = nested_filter::All;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.cx.tcx.hir()\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx rustc_hir::Local<'tcx>) {\n-        let local_id = l.pat.hir_id;\n-        self.defs.insert(local_id);\n-\n-        if let Some(sym) = l.pat.simple_ident() {\n-            self.def_symbols.insert(sym.name);\n-        }\n-\n-        if let Some(expr) = l.init {\n-            intravisit::walk_expr(self, expr);\n-        }\n-    }\n-\n-    fn visit_qpath(&mut self, qpath: &'tcx rustc_hir::QPath<'tcx>, id: HirId, _span: rustc_span::Span) {\n-        if let rustc_hir::QPath::Resolved(_, path) = *qpath {\n-            if path.segments.len() == 1 {\n-                if let rustc_hir::def::Res::Local(var) = self.cx.qpath_res(qpath, id) {\n-                    self.uses.insert(var);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n /// Implementation of `IFS_SAME_COND`.\n fn lint_same_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n-    let hash: &dyn Fn(&&Expr<'_>) -> u64 = &|expr| -> u64 {\n-        let mut h = SpanlessHash::new(cx);\n-        h.hash_expr(expr);\n-        h.finish()\n-    };\n-\n-    let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool = &|&lhs, &rhs| -> bool { eq_expr_value(cx, lhs, rhs) };\n-\n-    for (i, j) in search_same(conds, hash, eq) {\n+    for (i, j) in search_same(conds, |e| hash_expr(cx, e), |lhs, rhs| eq_expr_value(cx, lhs, rhs)) {\n         span_lint_and_note(\n             cx,\n             IFS_SAME_COND,\n@@ -620,12 +507,6 @@ fn lint_same_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n \n /// Implementation of `SAME_FUNCTIONS_IN_IF_CONDITION`.\n fn lint_same_fns_in_if_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n-    let hash: &dyn Fn(&&Expr<'_>) -> u64 = &|expr| -> u64 {\n-        let mut h = SpanlessHash::new(cx);\n-        h.hash_expr(expr);\n-        h.finish()\n-    };\n-\n     let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool = &|&lhs, &rhs| -> bool {\n         // Do not lint if any expr originates from a macro\n         if lhs.span.from_expansion() || rhs.span.from_expansion() {\n@@ -638,7 +519,7 @@ fn lint_same_fns_in_if_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n         SpanlessEq::new(cx).eq_expr(lhs, rhs)\n     };\n \n-    for (i, j) in search_same(conds, hash, eq) {\n+    for (i, j) in search_same(conds, |e| hash_expr(cx, e), eq) {\n         span_lint_and_note(\n             cx,\n             SAME_FUNCTIONS_IN_IF_CONDITION,"}, {"sha": "39f970dc4205223ada5cd13532530a4555b06db0", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46", "patch": "@@ -91,7 +91,7 @@ pub struct HirEqInterExpr<'a, 'b, 'tcx> {\n     // When binding are declared, the binding ID in the left expression is mapped to the one on the\n     // right. For example, when comparing `{ let x = 1; x + 2 }` and `{ let y = 1; y + 2 }`,\n     // these blocks are considered equal since `x` is mapped to `y`.\n-    locals: HirIdMap<HirId>,\n+    pub locals: HirIdMap<HirId>,\n }\n \n impl HirEqInterExpr<'_, '_, '_> {\n@@ -996,3 +996,15 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         }\n     }\n }\n+\n+pub fn hash_stmt(cx: &LateContext<'_>, s: &Stmt<'_>) -> u64 {\n+    let mut h = SpanlessHash::new(cx);\n+    h.hash_stmt(s);\n+    h.finish()\n+}\n+\n+pub fn hash_expr(cx: &LateContext<'_>, e: &Expr<'_>) -> u64 {\n+    let mut h = SpanlessHash::new(cx);\n+    h.hash_expr(e);\n+    h.finish()\n+}"}, {"sha": "0a95809381bb2855df2a9aebe96547709304f780", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46", "patch": "@@ -58,7 +58,9 @@ pub mod usage;\n pub mod visitors;\n \n pub use self::attrs::*;\n-pub use self::hir_utils::{both, count_eq, eq_expr_value, over, SpanlessEq, SpanlessHash};\n+pub use self::hir_utils::{\n+    both, count_eq, eq_expr_value, hash_expr, hash_stmt, over, HirEqInterExpr, SpanlessEq, SpanlessHash,\n+};\n \n use std::collections::hash_map::Entry;\n use std::hash::BuildHasherDefault;"}, {"sha": "064482009517a600b68be2592ac5de70e0161c8a", "filename": "tests/ui/branches_sharing_code/false_positives.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46/tests%2Fui%2Fbranches_sharing_code%2Ffalse_positives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46/tests%2Fui%2Fbranches_sharing_code%2Ffalse_positives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Ffalse_positives.rs?ref=c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46", "patch": "@@ -25,4 +25,17 @@ impl FooBar {\n     fn baz(&mut self) {}\n }\n \n-fn main() {}\n+fn foo(x: u32, y: u32) -> u32 {\n+    x / y\n+}\n+\n+fn main() {\n+    let x = (1, 2);\n+    let _ = if true {\n+        let (x, y) = x;\n+        foo(x, y)\n+    } else {\n+        let (y, x) = x;\n+        foo(x, y)\n+    };\n+}"}, {"sha": "5e1a68d216ea8bf22fb2ba9a17d0bf90bf1982f2", "filename": "tests/ui/branches_sharing_code/shared_at_bottom.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_bottom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_bottom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_bottom.stderr?ref=c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46", "patch": "@@ -12,8 +12,8 @@ note: the lint level is defined here\n    |\n LL | #![deny(clippy::if_same_then_else, clippy::branches_sharing_code)]\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: The end suggestion probably needs some adjustments to use the expression result correctly\n-help: consider moving the end statements out like this\n+   = note: the end suggestion probably needs some adjustments to use the expression result correctly\n+help: consider moving these statements after the if\n    |\n LL ~     }\n LL +     let result = false;\n@@ -28,7 +28,7 @@ LL | /         println!(\"Same end of block\");\n LL | |     }\n    | |_____^\n    |\n-help: consider moving the end statements out like this\n+help: consider moving these statements after the if\n    |\n LL ~     }\n LL +     println!(\"Same end of block\");\n@@ -44,7 +44,7 @@ LL | |         );\n LL | |     }\n    | |_____^\n    |\n-help: consider moving the end statements out like this\n+help: consider moving these statements after the if\n    |\n LL ~     }\n LL +     println!(\n@@ -60,7 +60,7 @@ LL | /             println!(\"Hello World\");\n LL | |         }\n    | |_________^\n    |\n-help: consider moving the end statements out like this\n+help: consider moving these statements after the if\n    |\n LL ~         }\n LL +         println!(\"Hello World\");\n@@ -75,8 +75,8 @@ LL | |         // I'm expecting a note about this\n LL | |     }\n    | |_____^\n    |\n-   = warning: Some moved values might need to be renamed to avoid wrong references\n-help: consider moving the end statements out like this\n+   = warning: some moved values might need to be renamed to avoid wrong references\n+help: consider moving these statements after the if\n    |\n LL ~     }\n LL +     let later_used_value = \"A string value\";\n@@ -91,8 +91,8 @@ LL | |         println!(\"This is the new simple_example: {}\", simple_examples);\n LL | |     }\n    | |_____^\n    |\n-   = warning: Some moved values might need to be renamed to avoid wrong references\n-help: consider moving the end statements out like this\n+   = warning: some moved values might need to be renamed to avoid wrong references\n+help: consider moving these statements after the if\n    |\n LL ~     }\n LL +     let simple_examples = \"I now identify as a &str :)\";\n@@ -106,8 +106,8 @@ LL | /         x << 2\n LL | |     };\n    | |_____^\n    |\n-   = note: The end suggestion probably needs some adjustments to use the expression result correctly\n-help: consider moving the end statements out like this\n+   = note: the end suggestion probably needs some adjustments to use the expression result correctly\n+help: consider moving these statements after the if\n    |\n LL ~     }\n LL ~     x << 2;\n@@ -120,8 +120,8 @@ LL | /         x * 4\n LL | |     }\n    | |_____^\n    |\n-   = note: The end suggestion probably needs some adjustments to use the expression result correctly\n-help: consider moving the end statements out like this\n+   = note: the end suggestion probably needs some adjustments to use the expression result correctly\n+help: consider moving these statements after the if\n    |\n LL ~     }\n LL +     x * 4\n@@ -133,7 +133,7 @@ error: all if blocks contain the same code at the end\n LL |     if x == 17 { b = 1; a = 0x99; } else { a = 0x99; }\n    |                                            ^^^^^^^^^^^\n    |\n-help: consider moving the end statements out like this\n+help: consider moving these statements after the if\n    |\n LL ~     if x == 17 { b = 1; a = 0x99; } else { }\n LL +     a = 0x99;"}, {"sha": "d890b12ecbb4c6d0b532ecb97e0254ce3bf1bebe", "filename": "tests/ui/branches_sharing_code/shared_at_top.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top.stderr?ref=c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46", "patch": "@@ -10,7 +10,7 @@ note: the lint level is defined here\n    |\n LL | #![deny(clippy::if_same_then_else, clippy::branches_sharing_code)]\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: consider moving the start statements out like this\n+help: consider moving these statements before the if\n    |\n LL ~     println!(\"Hello World!\");\n LL +     if true {\n@@ -25,8 +25,8 @@ LL | |         println!(\"The value y was set to: `{}`\", y);\n LL | |         let _z = y;\n    | |___________________^\n    |\n-   = warning: Some moved values might need to be renamed to avoid wrong references\n-help: consider moving the start statements out like this\n+   = warning: some moved values might need to be renamed to avoid wrong references\n+help: consider moving these statements before the if\n    |\n LL ~     let y = 9;\n LL +     println!(\"The value y was set to: `{}`\", y);\n@@ -41,7 +41,7 @@ LL | /     let _ = if x == 7 {\n LL | |         let y = 16;\n    | |___________________^\n    |\n-help: consider moving the start statements out like this\n+help: consider moving these statements before the if\n    |\n LL ~     let y = 16;\n LL +     let _ = if x == 7 {\n@@ -55,8 +55,8 @@ LL | |         let used_value_name = \"Different type\";\n LL | |         println!(\"Str: {}\", used_value_name);\n    | |_____________________________________________^\n    |\n-   = warning: Some moved values might need to be renamed to avoid wrong references\n-help: consider moving the start statements out like this\n+   = warning: some moved values might need to be renamed to avoid wrong references\n+help: consider moving these statements before the if\n    |\n LL ~     let used_value_name = \"Different type\";\n LL +     println!(\"Str: {}\", used_value_name);\n@@ -71,8 +71,8 @@ LL | |         let can_be_overridden = \"Move me\";\n LL | |         println!(\"I'm also moveable\");\n    | |______________________________________^\n    |\n-   = warning: Some moved values might need to be renamed to avoid wrong references\n-help: consider moving the start statements out like this\n+   = warning: some moved values might need to be renamed to avoid wrong references\n+help: consider moving these statements before the if\n    |\n LL ~     let can_be_overridden = \"Move me\";\n LL +     println!(\"I'm also moveable\");\n@@ -87,7 +87,7 @@ LL | |         println!(\"This should trigger the `SHARED_CODE_IN_IF_BLOCKS` lint\n LL | |         println!(\"Because `IF_SAME_THEN_ELSE` is allowed here\");\n    | |________________________________________________________________^\n    |\n-help: consider moving the start statements out like this\n+help: consider moving these statements before the if\n    |\n LL ~     println!(\"This should trigger the `SHARED_CODE_IN_IF_BLOCKS` lint.\");\n LL +     println!(\"Because `IF_SAME_THEN_ELSE` is allowed here\");"}, {"sha": "11843cc03d8d119bac71a277a5a9507dde193777", "filename": "tests/ui/branches_sharing_code/shared_at_top_and_bottom.stderr", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top_and_bottom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top_and_bottom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top_and_bottom.stderr?ref=c07cbb9ea65bb4ed4c78fa4b664474ea234bbc46", "patch": "@@ -1,4 +1,4 @@\n-error: all if blocks contain the same code at the start and the end. Here at the start\n+error: all if blocks contain the same code at both the start and the end\n   --> $DIR/shared_at_top_and_bottom.rs:16:5\n    |\n LL | /     if x == 7 {\n@@ -12,26 +12,26 @@ note: the lint level is defined here\n    |\n LL | #![deny(clippy::if_same_then_else, clippy::branches_sharing_code)]\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: and here at the end\n+note: this code is shared at the end\n   --> $DIR/shared_at_top_and_bottom.rs:28:5\n    |\n LL | /         let _u = 9;\n LL | |     }\n    | |_____^\n-help: consider moving the start statements out like this\n+help: consider moving these statements before the if\n    |\n LL ~     let t = 7;\n LL +     let _overlap_start = t * 2;\n LL +     let _overlap_end = 2 * t;\n LL +     if x == 7 {\n    |\n-help: and consider moving the end statements out like this\n+help: consider moving these statements after the if\n    |\n LL ~     }\n LL +     let _u = 9;\n    |\n \n-error: all if blocks contain the same code at the start and the end. Here at the start\n+error: all if blocks contain the same code at both the start and the end\n   --> $DIR/shared_at_top_and_bottom.rs:32:5\n    |\n LL | /     if x == 99 {\n@@ -40,29 +40,29 @@ LL | |         let _overlap_start = r;\n LL | |         let _overlap_middle = r * r;\n    | |____________________________________^\n    |\n-note: and here at the end\n+note: this code is shared at the end\n   --> $DIR/shared_at_top_and_bottom.rs:43:5\n    |\n LL | /         let _overlap_end = r * r * r;\n LL | |         let z = \"end\";\n LL | |     }\n    | |_____^\n-   = warning: Some moved values might need to be renamed to avoid wrong references\n-help: consider moving the start statements out like this\n+   = warning: some moved values might need to be renamed to avoid wrong references\n+help: consider moving these statements before the if\n    |\n LL ~     let r = 7;\n LL +     let _overlap_start = r;\n LL +     let _overlap_middle = r * r;\n LL +     if x == 99 {\n    |\n-help: and consider moving the end statements out like this\n+help: consider moving these statements after the if\n    |\n LL ~     }\n LL +     let _overlap_end = r * r * r;\n LL +     let z = \"end\";\n    |\n \n-error: all if blocks contain the same code at the start and the end. Here at the start\n+error: all if blocks contain the same code at both the start and the end\n   --> $DIR/shared_at_top_and_bottom.rs:61:5\n    |\n LL | /     if (x > 7 && y < 13) || (x + y) % 2 == 1 {\n@@ -71,7 +71,7 @@ LL | |         let b = 0xffff00ff;\n LL | |         let e_id = gen_id(a, b);\n    | |________________________________^\n    |\n-note: and here at the end\n+note: this code is shared at the end\n   --> $DIR/shared_at_top_and_bottom.rs:81:5\n    |\n LL | /         let pack = DataPack {\n@@ -82,15 +82,15 @@ LL | |         };\n LL | |         process_data(pack);\n LL | |     }\n    | |_____^\n-   = warning: Some moved values might need to be renamed to avoid wrong references\n-help: consider moving the start statements out like this\n+   = warning: some moved values might need to be renamed to avoid wrong references\n+help: consider moving these statements before the if\n    |\n LL ~     let a = 0xcafe;\n LL +     let b = 0xffff00ff;\n LL +     let e_id = gen_id(a, b);\n LL +     if (x > 7 && y < 13) || (x + y) % 2 == 1 {\n    |\n-help: and consider moving the end statements out like this\n+help: consider moving these statements after the if\n    |\n LL ~     }\n LL +     let pack = DataPack {\n@@ -100,51 +100,51 @@ LL +         some_data: vec![0x12, 0x34, 0x56, 0x78, 0x90],\n LL +     };\n  ...\n \n-error: all if blocks contain the same code at the start and the end. Here at the start\n+error: all if blocks contain the same code at both the start and the end\n   --> $DIR/shared_at_top_and_bottom.rs:94:5\n    |\n LL | /     let _ = if x == 7 {\n LL | |         let _ = 19;\n    | |___________________^\n    |\n-note: and here at the end\n+note: this code is shared at the end\n   --> $DIR/shared_at_top_and_bottom.rs:103:5\n    |\n LL | /         x << 2\n LL | |     };\n    | |_____^\n-   = note: The end suggestion probably needs some adjustments to use the expression result correctly\n-help: consider moving the start statements out like this\n+   = note: the end suggestion probably needs some adjustments to use the expression result correctly\n+help: consider moving these statements before the if\n    |\n LL ~     let _ = 19;\n LL +     let _ = if x == 7 {\n    |\n-help: and consider moving the end statements out like this\n+help: consider moving these statements after the if\n    |\n LL ~     }\n LL ~     x << 2;\n    |\n \n-error: all if blocks contain the same code at the start and the end. Here at the start\n+error: all if blocks contain the same code at both the start and the end\n   --> $DIR/shared_at_top_and_bottom.rs:106:5\n    |\n LL | /     if x == 9 {\n LL | |         let _ = 17;\n    | |___________________^\n    |\n-note: and here at the end\n+note: this code is shared at the end\n   --> $DIR/shared_at_top_and_bottom.rs:115:5\n    |\n LL | /         x * 4\n LL | |     }\n    | |_____^\n-   = note: The end suggestion probably needs some adjustments to use the expression result correctly\n-help: consider moving the start statements out like this\n+   = note: the end suggestion probably needs some adjustments to use the expression result correctly\n+help: consider moving these statements before the if\n    |\n LL ~     let _ = 17;\n LL +     if x == 9 {\n    |\n-help: and consider moving the end statements out like this\n+help: consider moving these statements after the if\n    |\n LL ~     }\n LL +     x * 4"}]}