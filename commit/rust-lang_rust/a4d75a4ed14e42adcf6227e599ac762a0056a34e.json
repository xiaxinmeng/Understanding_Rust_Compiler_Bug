{"sha": "a4d75a4ed14e42adcf6227e599ac762a0056a34e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZDc1YTRlZDE0ZTQyYWRjZjYyMjdlNTk5YWM3NjJhMDA1NmEzNGU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-12T08:26:54Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-15T14:08:31Z"}, "message": "Remove GEP_tup_like", "tree": {"sha": "9b3e5ef09891f0ce354f2a6eebed19624d8a23b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b3e5ef09891f0ce354f2a6eebed19624d8a23b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4d75a4ed14e42adcf6227e599ac762a0056a34e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4d75a4ed14e42adcf6227e599ac762a0056a34e", "html_url": "https://github.com/rust-lang/rust/commit/a4d75a4ed14e42adcf6227e599ac762a0056a34e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4d75a4ed14e42adcf6227e599ac762a0056a34e/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3a93ecd3fb58a7041c192adc8e1235a2f793ff5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3a93ecd3fb58a7041c192adc8e1235a2f793ff5", "html_url": "https://github.com/rust-lang/rust/commit/c3a93ecd3fb58a7041c192adc8e1235a2f793ff5"}], "stats": {"total": 243, "additions": 62, "deletions": 181}, "files": [{"sha": "c8f10f214ef5b873051404ff77100ec9bc5a86ff", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a4d75a4ed14e42adcf6227e599ac762a0056a34e/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d75a4ed14e42adcf6227e599ac762a0056a34e/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=a4d75a4ed14e42adcf6227e599ac762a0056a34e", "patch": "@@ -404,14 +404,11 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n     let rec_fields = collect_record_fields(m, col);\n     // Separate path for extracting and binding record fields\n     if rec_fields.len() > 0u {\n-        let rec_ty = node_id_type(bcx, pat_id);\n-        let fields = ty::get_fields(rec_ty);\n+        let fields = ty::get_fields(node_id_type(bcx, pat_id));\n         let rec_vals = [];\n         for field_name: ast::ident in rec_fields {\n             let ix = option::get(ty::field_idx(field_name, fields));\n-            let r = GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n-            rec_vals += [r.val];\n-            bcx = r.bcx;\n+            rec_vals += [GEPi(bcx, val, [0, ix as int])];\n         }\n         compile_submatch(bcx, enter_rec(dm, m, col, rec_fields, val),\n                          rec_vals + vals_left, chk, exits);\n@@ -426,9 +423,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n         };\n         let tup_vals = [], i = 0u;\n         while i < n_tup_elts {\n-            let r = GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n-            tup_vals += [r.val];\n-            bcx = r.bcx;\n+            tup_vals += [GEPi(bcx, val, [0, i as int])];\n             i += 1u;\n         }\n         compile_submatch(bcx, enter_tup(dm, m, col, val, n_tup_elts),\n@@ -706,21 +701,19 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n         }\n       }\n       ast::pat_rec(fields, _) {\n-        let rec_ty = node_id_type(bcx, pat.id);\n-        let rec_fields = ty::get_fields(rec_ty);\n+        let rec_fields = ty::get_fields(node_id_type(bcx, pat.id));\n         for f: ast::field_pat in fields {\n             let ix = option::get(ty::field_idx(f.ident, rec_fields));\n             // how to get rid of this check?\n-            let r = GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n-            bcx = bind_irrefutable_pat(r.bcx, f.pat, r.val, make_copy);\n+            let fldptr = GEPi(bcx, val, [0, ix as int]);\n+            bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, make_copy);\n         }\n       }\n       ast::pat_tup(elems) {\n-        let tup_ty = node_id_type(bcx, pat.id);\n         let i = 0u;\n         for elem in elems {\n-            let r = GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n-            bcx = bind_irrefutable_pat(r.bcx, elem, r.val, make_copy);\n+            let fldptr = GEPi(bcx, val, [0, i as int]);\n+            bcx = bind_irrefutable_pat(bcx, elem, fldptr, make_copy);\n             i += 1u;\n         }\n       }"}, {"sha": "ab1bb80692843121bd29aa9b0c9f29323a4e3b9e", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 41, "deletions": 140, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/a4d75a4ed14e42adcf6227e599ac762a0056a34e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d75a4ed14e42adcf6227e599ac762a0056a34e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a4d75a4ed14e42adcf6227e599ac762a0056a34e", "patch": "@@ -273,113 +273,22 @@ fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n     } else { bumped }\n }\n \n-// Replacement for the LLVM 'GEP' instruction when field-indexing into a\n-// tuple-like structure (tup, rec) with a static index. This one is driven off\n-// ty::struct and knows what to do when it runs into a ty_param stuck in the\n-// middle of the thing it's GEP'ing into. Much like size_of and align_of,\n-// above.\n-fn GEP_tup_like(bcx: block, t: ty::t, base: ValueRef, ixs: [int])\n-    -> result {\n-    fn compute_off(bcx: block,\n-                   off: ValueRef,\n-                   t: ty::t,\n-                   ixs: [int],\n-                   n: uint) -> (block, ValueRef, ty::t) {\n-        if n == ixs.len() {\n-            ret (bcx, off, t);\n-        }\n-\n-        let ix = ixs[n];\n-        let bcx = bcx, off = off;\n-        int::range(0, ix) {|i|\n-            let comp_t = ty::get_element_type(t, i as uint);\n-            let align = align_of(bcx, comp_t);\n-            bcx = align.bcx;\n-            off = align_to(bcx, off, align.val);\n-            let sz = size_of(bcx, comp_t);\n-            bcx = sz.bcx;\n-            off = Add(bcx, off, sz.val);\n-        }\n-\n-        let comp_t = ty::get_element_type(t, ix as uint);\n-        let align = align_of(bcx, comp_t);\n-        bcx = align.bcx;\n-        off = align_to(bcx, off, align.val);\n-\n-        be compute_off(bcx, off, comp_t, ixs, n+1u);\n-    }\n-\n-    if !ty::type_has_dynamic_size(bcx.tcx(), t) {\n-        ret rslt(bcx, GEPi(bcx, base, ixs));\n-    }\n-\n-    #debug[\"GEP_tup_like(t=%s,base=%s,ixs=%?)\",\n-           ty_to_str(bcx.tcx(), t),\n-           val_str(bcx.ccx().tn, base),\n-           ixs];\n-\n-    // We require that ixs start with 0 and we expect the input to be a\n-    // pointer to an instance of type t, so we can safely ignore ixs[0],\n-    // basically.\n-    assert ixs[0] == 0;\n-\n-    let (bcx, off, tar_t) = {\n-        compute_off(bcx, C_int(bcx.ccx(), 0), t, ixs, 1u)\n-    };\n-    ret rslt(bcx, bump_ptr(bcx, tar_t, base, off));\n-}\n-\n-\n // Replacement for the LLVM 'GEP' instruction when field indexing into a enum.\n-// This function uses GEP_tup_like() above and automatically performs casts as\n-// appropriate. @llblobptr is the data part of a enum value; its actual type\n+// @llblobptr is the data part of a enum value; its actual type\n // is meaningless, as it will be cast away.\n-fn GEP_enum(cx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n-           variant_id: ast::def_id, ty_substs: [ty::t],\n-           ix: uint) -> result {\n-    let variant = ty::enum_variant_with_id(cx.tcx(), enum_id, variant_id);\n+fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n+            variant_id: ast::def_id, ty_substs: [ty::t],\n+            ix: uint) -> result {\n+    let ccx = bcx.ccx();\n+    let variant = ty::enum_variant_with_id(ccx.tcx, enum_id, variant_id);\n     assert ix < variant.args.len();\n \n-    // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n-    // Separately, store the type of the element we're interested in.\n-\n-    let arg_tys = variant.args;\n-\n-    let true_arg_tys: [ty::t] = [];\n-    for aty: ty::t in arg_tys {\n-            // Would be nice to have a way of stating the invariant\n-            // that ty_substs is valid for aty\n-        let arg_ty = ty::substitute_type_params(cx.tcx(), ty_substs, aty);\n-        true_arg_tys += [arg_ty];\n-    }\n-\n-    // We know that ix < len(variant.args) -- so\n-    // it's safe to do this. (Would be nice to have\n-    // typestate guarantee that a dynamic bounds check\n-    // error can't happen here, but that's in the future.)\n-    let elem_ty = true_arg_tys[ix];\n-\n-    let tup_ty = ty::mk_tup(cx.tcx(), true_arg_tys);\n-    // Cast the blob pointer to the appropriate type, if we need to (i.e. if\n-    // the blob pointer isn't dynamically sized).\n-\n-    let llunionptr: ValueRef;\n-    let ccx = cx.ccx();\n-    if check type_has_static_size(ccx, tup_ty) {\n-        let llty = type_of(ccx, tup_ty);\n-        llunionptr = TruncOrBitCast(cx, llblobptr, T_ptr(llty));\n-    } else { llunionptr = llblobptr; }\n-\n-    // Do the GEP_tup_like().\n-    let rs = GEP_tup_like(cx, tup_ty, llunionptr, [0, ix as int]);\n-    // Cast the result to the appropriate type, if necessary.\n-\n-    let val = if check type_has_static_size(ccx, elem_ty) {\n-        let llelemty = type_of(ccx, elem_ty);\n-        PointerCast(rs.bcx, rs.val, T_ptr(llelemty))\n-    } else { rs.val };\n-\n-    ret rslt(rs.bcx, val);\n+    let arg_lltys = vec::map(variant.args, {|aty|\n+        type_of(ccx, ty::substitute_type_params(ccx.tcx, ty_substs, aty))\n+    });\n+    let typed_blobptr = PointerCast(bcx, llblobptr,\n+                                    T_ptr(T_struct(arg_lltys)));\n+    rslt(bcx, GEPi(bcx, typed_blobptr, [0, ix as int]))\n }\n \n // trans_shared_malloc: expects a type indicating which pointer type we want\n@@ -823,11 +732,10 @@ fn trans_res_drop(bcx: block, rs: ValueRef, did: ast::def_id,\n                   inner_t: ty::t, tps: [ty::t]) -> block {\n     let ccx = bcx.ccx();\n     let inner_t_s = ty::substitute_type_params(ccx.tcx, tps, inner_t);\n-    let tup_ty = ty::mk_tup(ccx.tcx, [ty::mk_int(ccx.tcx), inner_t_s]);\n \n-    let {bcx, val: drop_flag} = GEP_tup_like(bcx, tup_ty, rs, [0, 0]);\n+    let drop_flag = GEPi(bcx, rs, [0, 0]);\n     with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) {|bcx|\n-        let {bcx, val: valptr} = GEP_tup_like(bcx, tup_ty, rs, [0, 1]);\n+        let valptr = GEPi(bcx, rs, [0, 1]);\n         // Find and call the actual destructor.\n         let dtor_addr = get_res_dtor(ccx, did, tps);\n         let args = [bcx.fcx.llretptr, null_env_ptr(bcx)];\n@@ -840,7 +748,7 @@ fn trans_res_drop(bcx: block, rs: ValueRef, did: ast::def_id,\n         let val_cast = BitCast(bcx, valptr, val_llty);\n         Call(bcx, dtor_addr, args + [val_cast]);\n \n-        bcx = drop_ty(bcx, valptr, inner_t_s);\n+        let bcx = drop_ty(bcx, valptr, inner_t_s);\n         Store(bcx, C_u8(0u), drop_flag);\n         bcx\n     }\n@@ -1014,26 +922,24 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       ty::ty_rec(fields) {\n         let i: int = 0;\n         for fld: ty::field in fields {\n-            let {bcx: bcx, val: llfld_a} = GEP_tup_like(cx, t, av, [0, i]);\n-            cx = f(bcx, llfld_a, fld.mt.ty);\n+            let llfld_a = GEPi(cx, av, [0, i]);\n+            cx = f(cx, llfld_a, fld.mt.ty);\n             i += 1;\n         }\n       }\n       ty::ty_tup(args) {\n         let i = 0;\n         for arg in args {\n-            let {bcx: bcx, val: llfld_a} = GEP_tup_like(cx, t, av, [0, i]);\n-            cx = f(bcx, llfld_a, arg);\n+            let llfld_a = GEPi(cx, av, [0, i]);\n+            cx = f(cx, llfld_a, arg);\n             i += 1;\n         }\n       }\n       ty::ty_res(_, inner, tps) {\n         let tcx = cx.tcx();\n         let inner1 = ty::substitute_type_params(tcx, tps, inner);\n-        let inner_t_s = ty::substitute_type_params(tcx, tps, inner);\n-        let tup_t = ty::mk_tup(tcx, [ty::mk_int(tcx), inner_t_s]);\n-        let {bcx: bcx, val: llfld_a} = GEP_tup_like(cx, tup_t, av, [0, 1]);\n-        ret f(bcx, llfld_a, inner1);\n+        let llfld_a = GEPi(cx, av, [0, 1]);\n+        ret f(cx, llfld_a, inner1);\n       }\n       ty::ty_enum(tid, tps) {\n         let variants = ty::enum_variants(cx.tcx(), tid);\n@@ -1074,8 +980,8 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n           // a class is like a record type\n         let i: int = 0;\n         for fld: ty::field in ty::class_items_as_fields(cx.tcx(), did) {\n-            let {bcx: bcx, val: llfld_a} = GEP_tup_like(cx, t, av, [0, i]);\n-            cx = f(bcx, llfld_a, fld.mt.ty);\n+            let llfld_a = GEPi(cx, av, [0, i]);\n+            cx = f(cx, llfld_a, fld.mt.ty);\n             i += 1;\n         }\n       }\n@@ -2305,7 +2211,7 @@ fn trans_rec_field(bcx: block, base: @ast::expr,\n                  base expr has non-record type\"); }\n         };\n     let ix = option::get(ty::field_idx(field, fields));\n-    let {bcx, val} = GEP_tup_like(bcx, ty, val, [0, ix as int]);\n+    let val = GEPi(bcx, val, [0, ix as int]);\n     ret {bcx: bcx, val: val, kind: owned};\n }\n \n@@ -2837,9 +2743,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     ret pad_bcx.llbb;\n }\n \n-fn trans_tup(bcx: block, elts: [@ast::expr], id: ast::node_id,\n-             dest: dest) -> block {\n-    let t = node_id_type(bcx, id);\n+fn trans_tup(bcx: block, elts: [@ast::expr], dest: dest) -> block {\n     let bcx = bcx;\n     let addr = alt dest {\n       ignore {\n@@ -2851,11 +2755,11 @@ fn trans_tup(bcx: block, elts: [@ast::expr], id: ast::node_id,\n     };\n     let temp_cleanups = [], i = 0;\n     for e in elts {\n-        let dst = GEP_tup_like(bcx, t, addr, [0, i]);\n+        let dst = GEPi(bcx, addr, [0, i]);\n         let e_ty = expr_ty(bcx, e);\n-        bcx = trans_expr_save_in(dst.bcx, e, dst.val);\n-        add_clean_temp_mem(bcx, dst.val, e_ty);\n-        temp_cleanups += [dst.val];\n+        bcx = trans_expr_save_in(bcx, e, dst);\n+        add_clean_temp_mem(bcx, dst, e_ty);\n+        temp_cleanups += [dst];\n         i += 1;\n     }\n     for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n@@ -2887,10 +2791,10 @@ fn trans_rec(bcx: block, fields: [ast::field],\n         let ix = option::get(vec::position(ty_fields, {|ft|\n             str::eq(fld.node.ident, ft.ident)\n         }));\n-        let dst = GEP_tup_like(bcx, t, addr, [0, ix as int]);\n-        bcx = trans_expr_save_in(dst.bcx, fld.node.expr, dst.val);\n-        add_clean_temp_mem(bcx, dst.val, ty_fields[ix].mt.ty);\n-        temp_cleanups += [dst.val];\n+        let dst = GEPi(bcx, addr, [0, ix as int]);\n+        bcx = trans_expr_save_in(bcx, fld.node.expr, dst);\n+        add_clean_temp_mem(bcx, dst, ty_fields[ix].mt.ty);\n+        temp_cleanups += [dst];\n     }\n     alt base {\n       some(bexp) {\n@@ -2899,10 +2803,10 @@ fn trans_rec(bcx: block, fields: [ast::field],\n         // Copy over inherited fields\n         for tf in ty_fields {\n             if !vec::any(fields, {|f| str::eq(f.node.ident, tf.ident)}) {\n-                let dst = GEP_tup_like(bcx, t, addr, [0, i]);\n-                let base = GEP_tup_like(bcx, t, base_val, [0, i]);\n-                let val = load_if_immediate(base.bcx, base.val, tf.mt.ty);\n-                bcx = copy_val(base.bcx, INIT, dst.val, val, tf.mt.ty);\n+                let dst = GEPi(bcx, addr, [0, i]);\n+                let base = GEPi(bcx, base_val, [0, i]);\n+                let val = load_if_immediate(bcx, base, tf.mt.ty);\n+                bcx = copy_val(bcx, INIT, dst, val, tf.mt.ty);\n             }\n             i += 1;\n         }\n@@ -2997,7 +2901,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n       ast::expr_rec(args, base) {\n         ret trans_rec(bcx, args, base, e.id, dest);\n       }\n-      ast::expr_tup(args) { ret trans_tup(bcx, args, e.id, dest); }\n+      ast::expr_tup(args) { ret trans_tup(bcx, args, dest); }\n       ast::expr_lit(lit) { ret trans_lit(bcx, *lit, dest); }\n       ast::expr_vec(args, _) { ret tvec::trans_vec(bcx, args, e.id, dest); }\n       ast::expr_binary(op, lhs, rhs) {\n@@ -3974,8 +3878,6 @@ fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n     let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n     let fty = node_id_type(bcx, ctor_id);\n     let arg_t = ty::ty_fn_args(fty)[0].ty;\n-    let tup_t = ty::mk_tup(ccx.tcx, [ty::mk_mach_uint(ccx.tcx, ast::ty_u8),\n-                                     arg_t]);\n     let arg = alt fcx.llargs.find(dtor.inputs[0].id) {\n       some(local_mem(x)) { x }\n       _ { ccx.sess.bug(\"Someone forgot to document an invariant \\\n@@ -3987,12 +3889,11 @@ fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n         llretptr = BitCast(bcx, llretptr, llret_t);\n     }\n \n-    let {bcx, val: dst} = GEP_tup_like(bcx, tup_t, llretptr, [0, 1]);\n+    let dst = GEPi(bcx, llretptr, [0, 1]);\n     bcx = memmove_ty(bcx, dst, arg, arg_t);\n-    let flag = GEP_tup_like(bcx, tup_t, llretptr, [0, 0]);\n-    bcx = flag.bcx;\n+    let flag = GEPi(bcx, llretptr, [0, 0]);\n     let one = C_u8(1u);\n-    Store(bcx, one, flag.val);\n+    Store(bcx, one, flag);\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n }"}, {"sha": "7044cc8dbe46cb055b359c27781adde43832147b", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a4d75a4ed14e42adcf6227e599ac762a0056a34e/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d75a4ed14e42adcf6227e599ac762a0056a34e/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=a4d75a4ed14e42adcf6227e599ac762a0056a34e", "patch": "@@ -273,11 +273,9 @@ fn store_environment(bcx: block,\n                                   ev_to_str(ccx, bv)));\n         }\n \n-        let bound_data = GEP_tup_like(bcx, cbox_ty, llbox,\n-                                      [0, abi::box_field_body,\n-                                       abi::closure_body_bindings, i as int]);\n-        bcx = bound_data.bcx;\n-        let bound_data = bound_data.val;\n+        let bound_data = GEPi(bcx, llbox,\n+                              [0, abi::box_field_body,\n+                               abi::closure_body_bindings, i as int]);\n         alt bv {\n           env_expr(e, _) {\n             bcx = base::trans_expr_save_in(bcx, e, bound_data);\n@@ -377,16 +375,13 @@ fn load_environment(fcx: fn_ctxt,\n           capture::cap_drop { /* ignore */ }\n           _ {\n             let upvarptr =\n-                GEP_tup_like(bcx, cdata_ty, llcdata,\n-                             [0, abi::closure_body_bindings, i as int]);\n-            bcx = upvarptr.bcx;\n-            let llupvarptr = upvarptr.val;\n+                GEPi(bcx, llcdata, [0, abi::closure_body_bindings, i as int]);\n             alt ck {\n-              ty::ck_block { llupvarptr = Load(bcx, llupvarptr); }\n+              ty::ck_block { upvarptr = Load(bcx, upvarptr); }\n               ty::ck_uniq | ty::ck_box { }\n             }\n             let def_id = ast_util::def_id_of_def(cap_var.def);\n-            fcx.llupvars.insert(def_id.node, llupvarptr);\n+            fcx.llupvars.insert(def_id.node, upvarptr);\n             i += 1u;\n           }\n         }\n@@ -706,21 +701,16 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n         (fptr, llvm::LLVMGetUndef(T_opaque_cbox_ptr(ccx)), 0)\n       }\n       target_closure {\n-        let {bcx: cx, val: pair} =\n-            GEP_tup_like(bcx, cdata_ty, llcdata,\n-                         [0, abi::closure_body_bindings, 0]);\n+        let pair = GEPi(bcx, llcdata, [0, abi::closure_body_bindings, 0]);\n         let lltargetenv =\n-            Load(cx, GEPi(cx, pair, [0, abi::fn_field_box]));\n+            Load(bcx, GEPi(bcx, pair, [0, abi::fn_field_box]));\n         let lltargetfn = Load\n-            (cx, GEPi(cx, pair, [0, abi::fn_field_code]));\n-        bcx = cx;\n+            (bcx, GEPi(bcx, pair, [0, abi::fn_field_code]));\n         (lltargetfn, lltargetenv, 1)\n       }\n       target_self(fptr) {\n-        let rs = GEP_tup_like(bcx, cdata_ty, llcdata,\n-                              [0, abi::closure_body_bindings, 0]);\n-        bcx = rs.bcx;\n-        (fptr, PointerCast(bcx, rs.val, T_opaque_cbox_ptr(ccx)), 1)\n+        let slfptr = GEPi(bcx, llcdata, [0, abi::closure_body_bindings, 0]);\n+        (fptr, PointerCast(bcx, slfptr, T_opaque_cbox_ptr(ccx)), 1)\n       }\n     };\n \n@@ -757,11 +747,8 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n           // Arg provided at binding time; thunk copies it from\n           // closure.\n           some(e) {\n-            let bound_arg =\n-                GEP_tup_like(bcx, cdata_ty, llcdata,\n-                             [0, abi::closure_body_bindings, b]);\n-            bcx = bound_arg.bcx;\n-            let val = bound_arg.val;\n+            let val =\n+                GEPi(bcx, llcdata, [0, abi::closure_body_bindings, b]);\n \n             alt ty::resolved_mode(tcx, out_arg.mode) {\n               ast::by_val {"}]}