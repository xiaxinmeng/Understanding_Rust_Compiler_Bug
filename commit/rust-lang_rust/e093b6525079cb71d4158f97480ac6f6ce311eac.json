{"sha": "e093b6525079cb71d4158f97480ac6f6ce311eac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwOTNiNjUyNTA3OWNiNzFkNDE1OGY5NzQ4MGFjNmY2Y2UzMTFlYWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-26T02:16:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-26T02:16:07Z"}, "message": "Auto merge of #73746 - Manishearth:rollup-80jnynm, r=Manishearth\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #72617 (Add a fast path for `std::thread::panicking`.)\n - #72738 (Self contained linking option)\n - #72770 (Implement mixed script confusable lint.)\n - #73418 (Add unstable `core::mem::variant_count` intrinsic)\n - #73460 (Emit line info for generator variants)\n - #73534 (Provide suggestions for some moved value errors)\n - #73538 (make commented examples use valid syntax, and be more consistent )\n - #73581 (Create 0766 error code)\n - #73619 (Document the mod keyword)\n - #73621 (Document the mut keyword)\n - #73648 (Document the return keyword)\n - #73673 (Fix ptr doc warnings.)\n - #73674 (Tweak binop errors)\n - #73687 (Clean up E0701 explanation)\n\nFailed merges:\n\n - #73708 (Explain move errors that occur due to method calls involving `self` (take two))\n\nr? @ghost", "tree": {"sha": "f1618a71293bdae9e6c11b1ba74883920a9bcbcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1618a71293bdae9e6c11b1ba74883920a9bcbcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e093b6525079cb71d4158f97480ac6f6ce311eac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e093b6525079cb71d4158f97480ac6f6ce311eac", "html_url": "https://github.com/rust-lang/rust/commit/e093b6525079cb71d4158f97480ac6f6ce311eac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e093b6525079cb71d4158f97480ac6f6ce311eac/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1033351a51dd3ca342a83d4be13f7554f0b4fb1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1033351a51dd3ca342a83d4be13f7554f0b4fb1e", "html_url": "https://github.com/rust-lang/rust/commit/1033351a51dd3ca342a83d4be13f7554f0b4fb1e"}, {"sha": "8c5d794b52db22fdc1a4ba678a5876a98f9d9531", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c5d794b52db22fdc1a4ba678a5876a98f9d9531", "html_url": "https://github.com/rust-lang/rust/commit/8c5d794b52db22fdc1a4ba678a5876a98f9d9531"}], "stats": {"total": 2401, "additions": 1846, "deletions": 555}, "files": [{"sha": "8a0991059d5b26cd53ff61f393173976114c19dd", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -5405,15 +5405,15 @@ dependencies = [\n \n [[package]]\n name = \"unicode-script\"\n-version = \"0.4.0\"\n+version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5b2c5c29e805da6817f5af6a627d65adb045cebf05cccd5a3493d6109454391c\"\n+checksum = \"58b33414ea8db4b7ea0343548dbdc31d27aef06beacf7044a87e564d9b0feb7d\"\n \n [[package]]\n name = \"unicode-security\"\n-version = \"0.0.3\"\n+version = \"0.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a5f9011bbed9c13372bc8df618b55a38138445199caf3b61d432c6859c36dee0\"\n+checksum = \"5d87c28edc5b263377e448d6cdcb935c06b95413d8013ba6fae470558ccab18f\"\n dependencies = [\n  \"unicode-normalization\",\n  \"unicode-script\","}, {"sha": "c0be7dded17bc10d82059fc1da54f0b9df2505ab", "filename": "config.toml.example", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -118,18 +118,24 @@\n # nightlies are already produced for. The current platform must be able to run\n # binaries of this build triple and the nightly will be used to bootstrap the\n # first compiler.\n-#build = \"x86_64-unknown-linux-gnu\"    # defaults to your host platform\n+#\n+# Defaults to host platform\n+#build = \"x86_64-unknown-linux-gnu\"\n \n # In addition to the build triple, other triples to produce full compiler\n # toolchains for. Each of these triples will be bootstrapped from the build\n # triple and then will continue to bootstrap themselves. This platform must\n # currently be able to run all of the triples provided here.\n-#host = [\"x86_64-unknown-linux-gnu\"]   # defaults to just the build triple\n+#\n+# Defaults to just the build triple\n+#host = [\"x86_64-unknown-linux-gnu\"]\n \n # In addition to all host triples, other triples to produce the standard library\n # for. Each host triple will be used to produce a copy of the standard library\n # for each target triple.\n-#target = [\"x86_64-unknown-linux-gnu\"] # defaults to just the build triple\n+#\n+# Defaults to just the build triple\n+#target = [\"x86_64-unknown-linux-gnu\"]\n \n # Use this directory to store build artifacts.\n # You can use \"$ROOT\" to indicate the root of the git repository.\n@@ -174,7 +180,7 @@\n # Python interpreter to use for various tasks throughout the build, notably\n # rustdoc tests, the lldb python interpreter, and some dist bits and pieces.\n #\n-# Defaults to the Python interpreter used to execute x.py.\n+# Defaults to the Python interpreter used to execute x.py\n #python = \"python\"\n \n # Force Cargo to check that Cargo.lock describes the precise dependency\n@@ -313,11 +319,15 @@\n \n # Whether or not debug assertions are enabled for the compiler and standard\n # library.\n-#debug-assertions = debug\n+#\n+# Defaults to rust.debug value\n+#debug-assertions = false\n \n # Whether or not debug assertions are enabled for the standard library.\n # Overrides the `debug-assertions` option, if defined.\n-#debug-assertions-std = debug-assertions\n+#\n+# Defaults to rust.debug-assertions value\n+#debug-assertions-std = false\n \n # Debuginfo level for most of Rust code, corresponds to the `-C debuginfo=N` option of `rustc`.\n # `0` - no debug info\n@@ -326,16 +336,24 @@\n # Can be overridden for specific subsets of Rust code (rustc, std or tools).\n # Debuginfo for tests run with compiletest is not controlled by this option\n # and needs to be enabled separately with `debuginfo-level-tests`.\n-#debuginfo-level = if debug { 2 } else { 0 }\n+#\n+# Defaults to 2 if debug is true\n+#debuginfo-level = 0\n \n # Debuginfo level for the compiler.\n-#debuginfo-level-rustc = debuginfo-level\n+#\n+# Defaults to rust.debuginfo-level value\n+#debuginfo-level-rustc = 0\n \n # Debuginfo level for the standard library.\n-#debuginfo-level-std = debuginfo-level\n+#\n+# Defaults to rust.debuginfo-level value\n+#debuginfo-level-std = 0\n \n # Debuginfo level for the tools.\n-#debuginfo-level-tools = debuginfo-level\n+#\n+# Defaults to rust.debuginfo-level value\n+#debuginfo-level-tools = 0\n \n # Debuginfo level for the test suites run with compiletest.\n # FIXME(#61117): Some tests fail when this option is enabled."}, {"sha": "5d09018759191806f8d157385aa68763a4cd94ca", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -1917,6 +1917,15 @@ extern \"rust-intrinsic\" {\n     #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n     pub fn discriminant_value<T>(v: &T) -> <T as DiscriminantKind>::Discriminant;\n \n+    /// Returns the number of variants of the type `T` cast to a `usize`;\n+    /// if `T` has no variants, returns 0. Uninhabited variants will be counted.\n+    ///\n+    /// The to-be-stabilized version of this intrinsic is\n+    /// [`std::mem::variant_count`](../../std/mem/fn.variant_count.html)\n+    #[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n+    #[cfg(not(bootstrap))]\n+    pub fn variant_count<T>() -> usize;\n+\n     /// Rust's \"try catch\" construct which invokes the function pointer `try_fn`\n     /// with the data pointer `data`.\n     ///\n@@ -1960,6 +1969,12 @@ extern \"rust-intrinsic\" {\n     pub fn ptr_guaranteed_ne<T>(ptr: *const T, other: *const T) -> bool;\n }\n \n+#[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n+#[cfg(bootstrap)]\n+pub const fn variant_count<T>() -> usize {\n+    0\n+}\n+\n // Some functions are defined here because they accidentally got made\n // available in this module on stable. See <https://github.com/rust-lang/rust/issues/15702>.\n // (`transmute` also falls into this category, but it cannot be wrapped due to the"}, {"sha": "2b26e5303a89cee5d67838452fb04d3cd3444b04", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -124,6 +124,7 @@\n #![feature(unsized_locals)]\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n+#![feature(variant_count)]\n #![feature(doc_alias)]\n #![feature(mmx_target_feature)]\n #![feature(tbm_target_feature)]"}, {"sha": "1bd7ae3a34ebbcf9f6eb876aab3374ab065d08b9", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -999,3 +999,33 @@ impl<T> fmt::Debug for Discriminant<T> {\n pub const fn discriminant<T>(v: &T) -> Discriminant<T> {\n     Discriminant(intrinsics::discriminant_value(v))\n }\n+\n+/// Returns the number of variants in the enum type `T`.\n+///\n+/// If `T` is not an enum, calling this function will not result in undefined behavior, but the\n+/// return value is unspecified. Equally, if `T` is an enum with more variants than `usize::MAX`\n+/// the return value is unspecified. Uninhabited variants will be counted.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #![feature(never_type)]\n+/// # #![feature(variant_count)]\n+///\n+/// use std::mem;\n+///\n+/// enum Void {}\n+/// enum Foo { A(&'static str), B(i32), C(i32) }\n+///\n+/// assert_eq!(mem::variant_count::<Void>(), 0);\n+/// assert_eq!(mem::variant_count::<Foo>(), 3);\n+///\n+/// assert_eq!(mem::variant_count::<Option<!>>(), 2);\n+/// assert_eq!(mem::variant_count::<Result<!, !>>(), 2);\n+/// ```\n+#[inline(always)]\n+#[unstable(feature = \"variant_count\", issue = \"73662\")]\n+#[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n+pub const fn variant_count<T>() -> usize {\n+    intrinsics::variant_count::<T>()\n+}"}, {"sha": "64a506a6377f2790a473b826fe1babc56c0e12c2", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -316,7 +316,6 @@ impl<T: ?Sized> *const T {\n     /// differently have not been explored. This method should not be used to introduce such\n     /// differences, and it should also not be stabilized before we have a better understanding\n     /// of this issue.\n-    /// ```\n     #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[inline]\n@@ -349,7 +348,6 @@ impl<T: ?Sized> *const T {\n     /// differently have not been explored. This method should not be used to introduce such\n     /// differences, and it should also not be stabilized before we have a better understanding\n     /// of this issue.\n-    /// ```\n     #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[inline]"}, {"sha": "6b5cd9fdb854d550186c8f70c895eac52eeaef20", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -294,7 +294,6 @@ impl<T: ?Sized> *mut T {\n     /// differently have not been explored. This method should not be used to introduce such\n     /// differences, and it should also not be stabilized before we have a better understanding\n     /// of this issue.\n-    /// ```\n     #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[inline]\n@@ -327,7 +326,6 @@ impl<T: ?Sized> *mut T {\n     /// differently have not been explored. This method should not be used to introduce such\n     /// differences, and it should also not be stabilized before we have a better understanding\n     /// of this issue.\n-    /// ```\n     #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[inline]"}, {"sha": "33351c06d27ee0cb253ed9f57d7c6820c5802ef3", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 124, "deletions": 39, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -33,9 +33,9 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::truncate;\n use rustc_middle::mir::{self, Field, GeneratorLayout};\n use rustc_middle::ty::layout::{self, IntegerExt, PrimitiveExt, TyAndLayout};\n-use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::Instance;\n-use rustc_middle::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n+use rustc_middle::ty::{self, AdtKind, GeneratorSubsts, ParamEnv, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug};\n use rustc_session::config::{self, DebugInfo};\n use rustc_span::symbol::{Interner, Symbol};\n@@ -392,6 +392,7 @@ fn vec_slice_metadata(\n             align: pointer_align,\n             flags: DIFlags::FlagZero,\n             discriminant: None,\n+            source_info: None,\n         },\n         MemberDescription {\n             name: \"length\".to_owned(),\n@@ -401,6 +402,7 @@ fn vec_slice_metadata(\n             align: usize_align,\n             flags: DIFlags::FlagZero,\n             discriminant: None,\n+            source_info: None,\n         },\n     ];\n \n@@ -508,6 +510,7 @@ fn trait_pointer_metadata(\n             align: data_ptr_field.align.abi,\n             flags: DIFlags::FlagArtificial,\n             discriminant: None,\n+            source_info: None,\n         },\n         MemberDescription {\n             name: \"vtable\".to_owned(),\n@@ -517,6 +520,7 @@ fn trait_pointer_metadata(\n             align: vtable_field.align.abi,\n             flags: DIFlags::FlagArtificial,\n             discriminant: None,\n+            source_info: None,\n         },\n     ];\n \n@@ -859,7 +863,7 @@ fn foreign_type_metadata(\n     debug!(\"foreign_type_metadata: {:?}\", t);\n \n     let name = compute_debuginfo_type_name(cx.tcx, t, false);\n-    create_struct_stub(cx, t, &name, unique_type_id, NO_SCOPE_METADATA)\n+    create_struct_stub(cx, t, &name, unique_type_id, NO_SCOPE_METADATA, DIFlags::FlagZero)\n }\n \n fn pointer_type_metadata(\n@@ -1026,6 +1030,12 @@ impl MetadataCreationResult<'ll> {\n     }\n }\n \n+#[derive(Debug)]\n+struct SourceInfo<'ll> {\n+    file: &'ll DIFile,\n+    line: u32,\n+}\n+\n /// Description of a type member, which can either be a regular field (as in\n /// structs or tuples) or an enum variant.\n #[derive(Debug)]\n@@ -1037,6 +1047,7 @@ struct MemberDescription<'ll> {\n     align: Align,\n     flags: DIFlags,\n     discriminant: Option<u64>,\n+    source_info: Option<SourceInfo<'ll>>,\n }\n \n impl<'ll> MemberDescription<'ll> {\n@@ -1045,14 +1056,18 @@ impl<'ll> MemberDescription<'ll> {\n         cx: &CodegenCx<'ll, '_>,\n         composite_type_metadata: &'ll DIScope,\n     ) -> &'ll DIType {\n+        let (file, line) = self\n+            .source_info\n+            .map(|info| (info.file, info.line))\n+            .unwrap_or_else(|| (unknown_file_metadata(cx), UNKNOWN_LINE_NUMBER));\n         unsafe {\n             llvm::LLVMRustDIBuilderCreateVariantMemberType(\n                 DIB(cx),\n                 composite_type_metadata,\n                 self.name.as_ptr().cast(),\n                 self.name.len(),\n-                unknown_file_metadata(cx),\n-                UNKNOWN_LINE_NUMBER,\n+                file,\n+                line,\n                 self.size.bits(),\n                 self.align.bits() as u32,\n                 self.offset.bits(),\n@@ -1124,6 +1139,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n                     align: field.align.abi,\n                     flags: DIFlags::FlagZero,\n                     discriminant: None,\n+                    source_info: None,\n                 }\n             })\n             .collect()\n@@ -1145,8 +1161,14 @@ fn prepare_struct_metadata(\n \n     let containing_scope = get_namespace_for_item(cx, struct_def_id);\n \n-    let struct_metadata_stub =\n-        create_struct_stub(cx, struct_type, &struct_name, unique_type_id, Some(containing_scope));\n+    let struct_metadata_stub = create_struct_stub(\n+        cx,\n+        struct_type,\n+        &struct_name,\n+        unique_type_id,\n+        Some(containing_scope),\n+        DIFlags::FlagZero,\n+    );\n \n     create_and_register_recursive_type_forward_declaration(\n         cx,\n@@ -1185,6 +1207,7 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n                     align,\n                     flags: DIFlags::FlagZero,\n                     discriminant: None,\n+                    source_info: None,\n                 }\n             })\n             .collect()\n@@ -1201,8 +1224,14 @@ fn prepare_tuple_metadata(\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let tuple_name = compute_debuginfo_type_name(cx.tcx, tuple_type, false);\n \n-    let struct_stub =\n-        create_struct_stub(cx, tuple_type, &tuple_name[..], unique_type_id, containing_scope);\n+    let struct_stub = create_struct_stub(\n+        cx,\n+        tuple_type,\n+        &tuple_name[..],\n+        unique_type_id,\n+        containing_scope,\n+        DIFlags::FlagZero,\n+    );\n \n     create_and_register_recursive_type_forward_declaration(\n         cx,\n@@ -1244,6 +1273,7 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n                     align: field.align.abi,\n                     flags: DIFlags::FlagZero,\n                     discriminant: None,\n+                    source_info: None,\n                 }\n             })\n             .collect()\n@@ -1351,11 +1381,11 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n \n         let variant_info_for = |index: VariantIdx| match self.enum_type.kind {\n             ty::Adt(adt, _) => VariantInfo::Adt(&adt.variants[index]),\n-            ty::Generator(_, substs, _) => {\n+            ty::Generator(def_id, _, _) => {\n                 let (generator_layout, generator_saved_local_names) =\n                     generator_variant_info_data.as_ref().unwrap();\n                 VariantInfo::Generator {\n-                    substs,\n+                    def_id,\n                     generator_layout: *generator_layout,\n                     generator_saved_local_names,\n                     variant_index: index,\n@@ -1371,6 +1401,10 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n         } else {\n             type_metadata(cx, self.enum_type, self.span)\n         };\n+        let flags = match self.enum_type.kind {\n+            ty::Generator(..) => DIFlags::FlagArtificial,\n+            _ => DIFlags::FlagZero,\n+        };\n \n         match self.layout.variants {\n             Variants::Single { index } => {\n@@ -1404,8 +1438,9 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     offset: Size::ZERO,\n                     size: self.layout.size,\n                     align: self.layout.align.abi,\n-                    flags: DIFlags::FlagZero,\n+                    flags,\n                     discriminant: None,\n+                    source_info: variant_info.source_info(cx),\n                 }]\n             }\n             Variants::Multiple {\n@@ -1457,11 +1492,12 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                             offset: Size::ZERO,\n                             size: self.layout.size,\n                             align: self.layout.align.abi,\n-                            flags: DIFlags::FlagZero,\n+                            flags,\n                             discriminant: Some(\n                                 self.layout.ty.discriminant_for_variant(cx.tcx, i).unwrap().val\n                                     as u64,\n                             ),\n+                            source_info: variant_info.source_info(cx),\n                         }\n                     })\n                     .collect()\n@@ -1527,7 +1563,8 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         self.layout.fields.offset(tag_field),\n                         self.layout.field(cx, tag_field).size,\n                     );\n-                    variant_info_for(*niche_variants.start()).map_struct_name(|variant_name| {\n+                    let variant_info = variant_info_for(*niche_variants.start());\n+                    variant_info.map_struct_name(|variant_name| {\n                         name.push_str(variant_name);\n                     });\n \n@@ -1538,8 +1575,9 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         offset: Size::ZERO,\n                         size: variant.size,\n                         align: variant.align.abi,\n-                        flags: DIFlags::FlagZero,\n+                        flags,\n                         discriminant: None,\n+                        source_info: variant_info.source_info(cx),\n                     }]\n                 } else {\n                     variants\n@@ -1587,8 +1625,9 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                 offset: Size::ZERO,\n                                 size: self.layout.size,\n                                 align: self.layout.align.abi,\n-                                flags: DIFlags::FlagZero,\n+                                flags,\n                                 discriminant: niche_value,\n+                                source_info: variant_info.source_info(cx),\n                             }\n                         })\n                         .collect()\n@@ -1613,24 +1652,27 @@ impl VariantMemberDescriptionFactory<'ll, 'tcx> {\n             .iter()\n             .enumerate()\n             .map(|(i, &(ref name, ty))| {\n+                // Discriminant is always the first field of our variant\n+                // when using the enum fallback.\n+                let is_artificial_discr = use_enum_fallback(cx) && i == 0;\n                 let (size, align) = cx.size_and_align_of(ty);\n                 MemberDescription {\n                     name: name.to_string(),\n-                    type_metadata: if use_enum_fallback(cx) {\n-                        match self.tag_type_metadata {\n-                            // Discriminant is always the first field of our variant\n-                            // when using the enum fallback.\n-                            Some(metadata) if i == 0 => metadata,\n-                            _ => type_metadata(cx, ty, self.span),\n-                        }\n+                    type_metadata: if is_artificial_discr {\n+                        self.tag_type_metadata.unwrap_or_else(|| type_metadata(cx, ty, self.span))\n                     } else {\n                         type_metadata(cx, ty, self.span)\n                     },\n                     offset: self.offsets[i],\n                     size,\n                     align,\n-                    flags: DIFlags::FlagZero,\n+                    flags: if is_artificial_discr {\n+                        DIFlags::FlagArtificial\n+                    } else {\n+                        DIFlags::FlagZero\n+                    },\n                     discriminant: None,\n+                    source_info: None,\n                 }\n             })\n             .collect()\n@@ -1651,7 +1693,7 @@ enum EnumTagInfo<'ll> {\n enum VariantInfo<'a, 'tcx> {\n     Adt(&'tcx ty::VariantDef),\n     Generator {\n-        substs: SubstsRef<'tcx>,\n+        def_id: DefId,\n         generator_layout: &'tcx GeneratorLayout<'tcx>,\n         generator_saved_local_names: &'a IndexVec<mir::GeneratorSavedLocal, Option<Symbol>>,\n         variant_index: VariantIdx,\n@@ -1662,8 +1704,8 @@ impl<'tcx> VariantInfo<'_, 'tcx> {\n     fn map_struct_name<R>(&self, f: impl FnOnce(&str) -> R) -> R {\n         match self {\n             VariantInfo::Adt(variant) => f(&variant.ident.as_str()),\n-            VariantInfo::Generator { substs, variant_index, .. } => {\n-                f(&substs.as_generator().variant_name(*variant_index))\n+            VariantInfo::Generator { variant_index, .. } => {\n+                f(&GeneratorSubsts::variant_name(*variant_index))\n             }\n         }\n     }\n@@ -1699,6 +1741,32 @@ impl<'tcx> VariantInfo<'_, 'tcx> {\n         };\n         field_name.map(|name| name.to_string()).unwrap_or_else(|| format!(\"__{}\", i))\n     }\n+\n+    fn source_info(&self, cx: &CodegenCx<'ll, 'tcx>) -> Option<SourceInfo<'ll>> {\n+        match self {\n+            VariantInfo::Generator { def_id, variant_index, .. } => {\n+                let span =\n+                    cx.tcx.generator_layout(*def_id).variant_source_info[*variant_index].span;\n+                if !span.is_dummy() {\n+                    let loc = cx.lookup_debug_loc(span.lo());\n+                    return Some(SourceInfo {\n+                        file: file_metadata(cx, &loc.file, def_id.krate),\n+                        line: loc.line.unwrap_or(UNKNOWN_LINE_NUMBER),\n+                    });\n+                }\n+            }\n+            _ => {}\n+        }\n+        None\n+    }\n+\n+    #[allow(dead_code)]\n+    fn is_artificial(&self) -> bool {\n+        match self {\n+            VariantInfo::Generator { .. } => true,\n+            VariantInfo::Adt(..) => false,\n+        }\n+    }\n }\n \n /// Returns a tuple of (1) `type_metadata_stub` of the variant, (2) a\n@@ -1718,7 +1786,15 @@ fn describe_enum_variant(\n             .type_map\n             .borrow_mut()\n             .get_unique_type_id_of_enum_variant(cx, layout.ty, &variant_name);\n-        create_struct_stub(cx, layout.ty, &variant_name, unique_type_id, Some(containing_scope))\n+        create_struct_stub(\n+            cx,\n+            layout.ty,\n+            &variant_name,\n+            unique_type_id,\n+            Some(containing_scope),\n+            // FIXME(tmandry): This doesn't seem to have any effect.\n+            if variant.is_artificial() { DIFlags::FlagArtificial } else { DIFlags::FlagZero },\n+        )\n     });\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n@@ -1778,7 +1854,13 @@ fn prepare_enum_metadata(\n     span: Span,\n     outer_field_tys: Vec<Ty<'tcx>>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n-    let enum_name = compute_debuginfo_type_name(cx.tcx, enum_type, false);\n+    let tcx = cx.tcx;\n+    let enum_name = compute_debuginfo_type_name(tcx, enum_type, false);\n+    // FIXME(tmandry): This doesn't seem to have any effect.\n+    let enum_flags = match enum_type.kind {\n+        ty::Generator(..) => DIFlags::FlagArtificial,\n+        _ => DIFlags::FlagZero,\n+    };\n \n     let containing_scope = get_namespace_for_item(cx, enum_def_id);\n     // FIXME: This should emit actual file metadata for the enum, but we\n@@ -1792,7 +1874,7 @@ fn prepare_enum_metadata(\n     let discriminant_type_metadata = |discr: Primitive| {\n         let enumerators_metadata: Vec<_> = match enum_type.kind {\n             ty::Adt(def, _) => def\n-                .discriminants(cx.tcx)\n+                .discriminants(tcx)\n                 .zip(&def.variants)\n                 .map(|((_, discr), v)| {\n                     let name = v.ident.as_str();\n@@ -1815,15 +1897,16 @@ fn prepare_enum_metadata(\n                 .collect(),\n             ty::Generator(_, substs, _) => substs\n                 .as_generator()\n-                .variant_range(enum_def_id, cx.tcx)\n+                .variant_range(enum_def_id, tcx)\n                 .map(|variant_index| {\n-                    let name = substs.as_generator().variant_name(variant_index);\n+                    debug_assert_eq!(tcx.types.u32, substs.as_generator().discr_ty(tcx));\n+                    let name = GeneratorSubsts::variant_name(variant_index);\n                     unsafe {\n                         Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n                             DIB(cx),\n                             name.as_ptr().cast(),\n                             name.len(),\n-                            // Generators use u32 as discriminant type.\n+                            // Generators use u32 as discriminant type, verified above.\n                             variant_index.as_u32().into(),\n                             true, // IsUnsigned\n                         ))\n@@ -1841,12 +1924,12 @@ fn prepare_enum_metadata(\n             None => {\n                 let (discriminant_size, discriminant_align) = (discr.size(cx), discr.align(cx));\n                 let discriminant_base_type_metadata =\n-                    type_metadata(cx, discr.to_ty(cx.tcx), rustc_span::DUMMY_SP);\n+                    type_metadata(cx, discr.to_ty(tcx), rustc_span::DUMMY_SP);\n \n                 let item_name;\n                 let discriminant_name = match enum_type.kind {\n                     ty::Adt(..) => {\n-                        item_name = cx.tcx.item_name(enum_def_id).as_str();\n+                        item_name = tcx.item_name(enum_def_id).as_str();\n                         &*item_name\n                     }\n                     ty::Generator(..) => enum_name.as_str(),\n@@ -1912,7 +1995,7 @@ fn prepare_enum_metadata(\n                     UNKNOWN_LINE_NUMBER,\n                     layout.size.bits(),\n                     layout.align.abi.bits() as u32,\n-                    DIFlags::FlagZero,\n+                    enum_flags,\n                     None,\n                     0, // RuntimeLang\n                     unique_type_id_str.as_ptr().cast(),\n@@ -2033,7 +2116,7 @@ fn prepare_enum_metadata(\n             UNKNOWN_LINE_NUMBER,\n             layout.size.bits(),\n             layout.align.abi.bits() as u32,\n-            DIFlags::FlagZero,\n+            enum_flags,\n             discriminator_metadata,\n             empty_array,\n             variant_part_unique_type_id_str.as_ptr().cast(),\n@@ -2059,7 +2142,7 @@ fn prepare_enum_metadata(\n                 UNKNOWN_LINE_NUMBER,\n                 layout.size.bits(),\n                 layout.align.abi.bits() as u32,\n-                DIFlags::FlagZero,\n+                enum_flags,\n                 None,\n                 type_array,\n                 0,\n@@ -2110,6 +2193,7 @@ fn composite_type_metadata(\n         composite_type_name,\n         composite_type_unique_id,\n         containing_scope,\n+        DIFlags::FlagZero,\n     );\n     // ... and immediately create and add the member descriptions.\n     set_members_of_composite_type(cx, composite_type, composite_type_metadata, member_descriptions);\n@@ -2211,6 +2295,7 @@ fn create_struct_stub(\n     struct_type_name: &str,\n     unique_type_id: UniqueTypeId,\n     containing_scope: Option<&'ll DIScope>,\n+    flags: DIFlags,\n ) -> &'ll DICompositeType {\n     let (struct_size, struct_align) = cx.size_and_align_of(struct_type);\n \n@@ -2232,7 +2317,7 @@ fn create_struct_stub(\n             UNKNOWN_LINE_NUMBER,\n             struct_size.bits(),\n             struct_align.bits() as u32,\n-            DIFlags::FlagZero,\n+            flags,\n             None,\n             empty_array,\n             0,"}, {"sha": "130c0cf1877c667c02a0258961eb1b6bb1e63e82", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -206,7 +206,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 }\n             }\n             \"size_of\" | \"pref_align_of\" | \"min_align_of\" | \"needs_drop\" | \"type_id\"\n-            | \"type_name\" => {\n+            | \"type_name\" | \"variant_count\" => {\n                 let value = self\n                     .tcx\n                     .const_eval_instance(ty::ParamEnv::reveal_all(), instance, None)"}, {"sha": "5a0da6be5980ed8d1192e63bf7eae7d189df5762", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -70,10 +70,10 @@ fn uncached_llvm_type<'a, 'tcx>(\n                     write!(&mut name, \"::{}\", def.variants[index].ident).unwrap();\n                 }\n             }\n-            if let (&ty::Generator(_, substs, _), &Variants::Single { index })\n+            if let (&ty::Generator(_, _, _), &Variants::Single { index })\n                  = (&layout.ty.kind, &layout.variants)\n             {\n-                write!(&mut name, \"::{}\", substs.as_generator().variant_name(index)).unwrap();\n+                write!(&mut name, \"::{}\", ty::GeneratorSubsts::variant_name(index)).unwrap();\n             }\n             Some(name)\n         }"}, {"sha": "a34029410784ac33efd70849d843fe2cb6984bcc", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 54, "deletions": 26, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -140,7 +140,12 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n // toolchain\n-fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> Command {\n+fn get_linker(\n+    sess: &Session,\n+    linker: &Path,\n+    flavor: LinkerFlavor,\n+    self_contained: bool,\n+) -> Command {\n     let msvc_tool = windows_registry::find_tool(&sess.opts.target_triple.triple(), \"link.exe\");\n \n     // If our linker looks like a batch script on Windows then to execute this\n@@ -199,7 +204,7 @@ fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> Command {\n \n     // The compiler's sysroot often has some bundled tools, so add it to the\n     // PATH for the child.\n-    let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths();\n+    let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths(self_contained);\n     let mut msvc_changed_path = false;\n     if sess.target.target.options.is_like_msvc {\n         if let Some(ref tool) = msvc_tool {\n@@ -551,19 +556,25 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n                 \"Linker does not support -static-pie command line option. Retrying with -static instead.\"\n             );\n             // Mirror `add_(pre,post)_link_objects` to replace CRT objects.\n-            let fallback = crt_objects_fallback(sess, crate_type);\n+            let self_contained = crt_objects_fallback(sess, crate_type);\n             let opts = &sess.target.target.options;\n-            let pre_objects =\n-                if fallback { &opts.pre_link_objects_fallback } else { &opts.pre_link_objects };\n-            let post_objects =\n-                if fallback { &opts.post_link_objects_fallback } else { &opts.post_link_objects };\n+            let pre_objects = if self_contained {\n+                &opts.pre_link_objects_fallback\n+            } else {\n+                &opts.pre_link_objects\n+            };\n+            let post_objects = if self_contained {\n+                &opts.post_link_objects_fallback\n+            } else {\n+                &opts.post_link_objects\n+            };\n             let get_objects = |objects: &CrtObjects, kind| {\n                 objects\n                     .get(&kind)\n                     .iter()\n                     .copied()\n                     .flatten()\n-                    .map(|obj| get_object_file_path(sess, obj).into_os_string())\n+                    .map(|obj| get_object_file_path(sess, obj, self_contained).into_os_string())\n                     .collect::<Vec<_>>()\n             };\n             let pre_objects_static_pie = get_objects(pre_objects, LinkOutputKind::StaticPicExe);\n@@ -1066,9 +1077,11 @@ fn get_crt_libs_path(sess: &Session) -> Option<PathBuf> {\n     }\n }\n \n-fn get_object_file_path(sess: &Session, name: &str) -> PathBuf {\n+fn get_object_file_path(sess: &Session, name: &str, self_contained: bool) -> PathBuf {\n     // prefer system {,dll}crt2.o libs, see get_crt_libs_path comment for more details\n-    if sess.target.target.llvm_target.contains(\"windows-gnu\") {\n+    if sess.opts.debugging_opts.link_self_contained.is_none()\n+        && sess.target.target.llvm_target.contains(\"windows-gnu\")\n+    {\n         if let Some(compiler_libs_path) = get_crt_libs_path(sess) {\n             let file_path = compiler_libs_path.join(name);\n             if file_path.exists() {\n@@ -1081,9 +1094,12 @@ fn get_object_file_path(sess: &Session, name: &str) -> PathBuf {\n     if file_path.exists() {\n         return file_path;\n     }\n-    let file_path = fs.get_selfcontained_lib_path().join(name);\n-    if file_path.exists() {\n-        return file_path;\n+    // Special directory with objects used only in self-contained linkage mode\n+    if self_contained {\n+        let file_path = fs.get_self_contained_lib_path().join(name);\n+        if file_path.exists() {\n+            return file_path;\n+        }\n     }\n     for search_path in fs.search_paths() {\n         let file_path = search_path.dir.join(name);\n@@ -1268,6 +1284,10 @@ fn link_output_kind(sess: &Session, crate_type: CrateType) -> LinkOutputKind {\n /// Whether we link to our own CRT objects instead of relying on gcc to pull them.\n /// We only provide such support for a very limited number of targets.\n fn crt_objects_fallback(sess: &Session, crate_type: CrateType) -> bool {\n+    if let Some(self_contained) = sess.opts.debugging_opts.link_self_contained {\n+        return self_contained;\n+    }\n+\n     match sess.target.target.options.crt_objects_fallback {\n         // FIXME: Find a better heuristic for \"native musl toolchain is available\",\n         // based on host and linker path, for example.\n@@ -1287,12 +1307,13 @@ fn add_pre_link_objects(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     link_output_kind: LinkOutputKind,\n-    fallback: bool,\n+    self_contained: bool,\n ) {\n     let opts = &sess.target.target.options;\n-    let objects = if fallback { &opts.pre_link_objects_fallback } else { &opts.pre_link_objects };\n+    let objects =\n+        if self_contained { &opts.pre_link_objects_fallback } else { &opts.pre_link_objects };\n     for obj in objects.get(&link_output_kind).iter().copied().flatten() {\n-        cmd.add_object(&get_object_file_path(sess, obj));\n+        cmd.add_object(&get_object_file_path(sess, obj, self_contained));\n     }\n }\n \n@@ -1301,12 +1322,13 @@ fn add_post_link_objects(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     link_output_kind: LinkOutputKind,\n-    fallback: bool,\n+    self_contained: bool,\n ) {\n     let opts = &sess.target.target.options;\n-    let objects = if fallback { &opts.post_link_objects_fallback } else { &opts.post_link_objects };\n+    let objects =\n+        if self_contained { &opts.post_link_objects_fallback } else { &opts.post_link_objects };\n     for obj in objects.get(&link_output_kind).iter().copied().flatten() {\n-        cmd.add_object(&get_object_file_path(sess, obj));\n+        cmd.add_object(&get_object_file_path(sess, obj, self_contained));\n     }\n }\n \n@@ -1468,9 +1490,12 @@ fn link_local_crate_native_libs_and_dependent_crate_libs<'a, B: ArchiveBuilder<'\n }\n \n /// Add sysroot and other globally set directories to the directory search list.\n-fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session) {\n+fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session, self_contained: bool) {\n     // Prefer system mingw-w64 libs, see get_crt_libs_path comment for more details.\n-    if cfg!(windows) && sess.target.target.llvm_target.contains(\"windows-gnu\") {\n+    if sess.opts.debugging_opts.link_self_contained.is_none()\n+        && cfg!(windows)\n+        && sess.target.target.llvm_target.contains(\"windows-gnu\")\n+    {\n         if let Some(compiler_libs_path) = get_crt_libs_path(sess) {\n             cmd.include_path(&compiler_libs_path);\n         }\n@@ -1481,8 +1506,11 @@ fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session) {\n     let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n     cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n \n-    let lib_path = sess.target_filesearch(PathKind::All).get_selfcontained_lib_path();\n-    cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n+    // Special directory with libraries used only in self-contained linkage mode\n+    if self_contained {\n+        let lib_path = sess.target_filesearch(PathKind::All).get_self_contained_lib_path();\n+        cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n+    }\n }\n \n /// Add options making relocation sections in the produced ELF files read-only\n@@ -1545,13 +1573,13 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     codegen_results: &CodegenResults,\n     target_cpu: &str,\n ) -> Command {\n-    let base_cmd = get_linker(sess, path, flavor);\n+    let crt_objects_fallback = crt_objects_fallback(sess, crate_type);\n+    let base_cmd = get_linker(sess, path, flavor, crt_objects_fallback);\n     // FIXME: Move `/LIBPATH` addition for uwp targets from the linker construction\n     // to the linker args construction.\n     assert!(base_cmd.get_args().is_empty() || sess.target.target.target_vendor == \"uwp\");\n     let cmd = &mut *codegen_results.linker_info.to_linker(base_cmd, &sess, flavor, target_cpu);\n     let link_output_kind = link_output_kind(sess, crate_type);\n-    let crt_objects_fallback = crt_objects_fallback(sess, crate_type);\n \n     // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n     add_pre_link_args(cmd, sess, flavor);\n@@ -1597,7 +1625,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n     // FIXME: Order-dependent, at least relatively to other args adding searh directories.\n-    add_library_search_dirs(cmd, sess);\n+    add_library_search_dirs(cmd, sess, crt_objects_fallback);\n \n     // OBJECT-FILES-YES\n     add_local_crate_regular_objects(cmd, codegen_results);"}, {"sha": "162585360fbda823b2853314af66a460ae46a4d8", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -446,6 +446,7 @@ E0762: include_str!(\"./error_codes/E0762.md\"),\n E0763: include_str!(\"./error_codes/E0763.md\"),\n E0764: include_str!(\"./error_codes/E0764.md\"),\n E0765: include_str!(\"./error_codes/E0765.md\"),\n+E0766: include_str!(\"./error_codes/E0766.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "4965e64310591f332beaeff4a8643434b07a88d4", "filename": "src/librustc_error_codes/error_codes/E0701.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_error_codes%2Ferror_codes%2FE0701.md", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_error_codes%2Ferror_codes%2FE0701.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0701.md?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -1,7 +1,7 @@\n This error indicates that a `#[non_exhaustive]` attribute was incorrectly placed\n on something other than a struct or enum.\n \n-Examples of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0701\n #[non_exhaustive]"}, {"sha": "4e775df2cac4d14fa5be6e44f31fa49c98261344", "filename": "src/librustc_error_codes/error_codes/E0766.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_error_codes%2Ferror_codes%2FE0766.md", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_error_codes%2Ferror_codes%2FE0766.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0766.md?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,13 @@\n+A double quote byte string (`b\"`) was not terminated.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0766\n+let s = b\"; // error!\n+```\n+\n+To fix this error, add the missing double quote at the end of the string:\n+\n+```\n+let s = b\"\"; // ok!\n+```"}, {"sha": "cb8b30830c5dec905b7b672804bf1d6837a9b043", "filename": "src/librustc_index/bit_set.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_index%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_index%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fbit_set.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -700,7 +700,7 @@ impl<T: Idx> GrowableBitSet<T> {\n ///\n /// All operations that involve a row and/or column index will panic if the\n /// index exceeds the relevant bound.\n-#[derive(Clone, Debug, Eq, PartialEq, RustcDecodable, RustcEncodable)]\n+#[derive(Clone, Eq, PartialEq, RustcDecodable, RustcEncodable)]\n pub struct BitMatrix<R: Idx, C: Idx> {\n     num_rows: usize,\n     num_columns: usize,\n@@ -876,6 +876,22 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     }\n }\n \n+impl<R: Idx, C: Idx> fmt::Debug for BitMatrix<R, C> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        /// Forces its contents to print in regular mode instead of alternate mode.\n+        struct OneLinePrinter<T>(T);\n+        impl<T: fmt::Debug> fmt::Debug for OneLinePrinter<T> {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                write!(fmt, \"{:?}\", self.0)\n+            }\n+        }\n+\n+        write!(fmt, \"BitMatrix({}x{}) \", self.num_rows, self.num_columns)?;\n+        let items = self.rows().flat_map(|r| self.iter(r).map(move |c| (r, c)));\n+        fmt.debug_set().entries(items.map(OneLinePrinter)).finish()\n+    }\n+}\n+\n /// A fixed-column-size, variable-row-size 2D bit matrix with a moderately\n /// sparse representation.\n ///"}, {"sha": "58c15257326aeb20481869f3a161972b448d5e42", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n \n [dependencies]\n log = \"0.4\"\n-unicode-security = \"0.0.3\"\n+unicode-security = \"0.0.5\"\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_attr = { path = \"../librustc_attr\" }"}, {"sha": "30dbd069c29bd2d847050b2955c477997040fdc0", "filename": "src/librustc_lint/non_ascii_idents.rs", "status": "modified", "additions": 225, "deletions": 129, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnon_ascii_idents.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -1,9 +1,7 @@\n use crate::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_ast::ast;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_span::symbol::{Ident, SymbolStr};\n-use std::hash::{Hash, Hasher};\n-use std::ops::Deref;\n+use rustc_span::symbol::SymbolStr;\n \n declare_lint! {\n     pub NON_ASCII_IDENTS,\n@@ -19,158 +17,256 @@ declare_lint! {\n     crate_level_only\n }\n \n-// FIXME: Change this to warn.\n declare_lint! {\n     pub CONFUSABLE_IDENTS,\n-    Allow,\n+    Warn,\n     \"detects visually confusable pairs between identifiers\",\n     crate_level_only\n }\n \n-declare_lint_pass!(NonAsciiIdents => [NON_ASCII_IDENTS, UNCOMMON_CODEPOINTS, CONFUSABLE_IDENTS]);\n-\n-enum CowBoxSymStr {\n-    Interned(SymbolStr),\n-    Owned(Box<str>),\n-}\n-\n-impl Deref for CowBoxSymStr {\n-    type Target = str;\n-\n-    fn deref(&self) -> &str {\n-        match self {\n-            CowBoxSymStr::Interned(interned) => interned,\n-            CowBoxSymStr::Owned(ref owned) => owned,\n-        }\n-    }\n-}\n-\n-impl Hash for CowBoxSymStr {\n-    #[inline]\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        Hash::hash(&**self, state)\n-    }\n-}\n-\n-impl PartialEq<CowBoxSymStr> for CowBoxSymStr {\n-    #[inline]\n-    fn eq(&self, other: &CowBoxSymStr) -> bool {\n-        PartialEq::eq(&**self, &**other)\n-    }\n-}\n-\n-impl Eq for CowBoxSymStr {}\n-\n-fn calc_skeleton(symbol_str: SymbolStr, buffer: &'_ mut String) -> CowBoxSymStr {\n-    use std::mem::swap;\n-    use unicode_security::confusable_detection::skeleton;\n-    buffer.clear();\n-    buffer.extend(skeleton(&symbol_str));\n-    if symbol_str == *buffer {\n-        CowBoxSymStr::Interned(symbol_str)\n-    } else {\n-        let mut owned = String::new();\n-        swap(buffer, &mut owned);\n-        CowBoxSymStr::Owned(owned.into_boxed_str())\n-    }\n-}\n-\n-fn is_in_ascii_confusable_closure(c: char) -> bool {\n-    // FIXME: move this table to `unicode_security` crate.\n-    // data here corresponds to Unicode 13.\n-    const ASCII_CONFUSABLE_CLOSURE: &[(u64, u64)] = &[(0x00, 0x7f), (0xba, 0xba), (0x2080, 0x2080)];\n-    let c = c as u64;\n-    for &(range_start, range_end) in ASCII_CONFUSABLE_CLOSURE {\n-        if c >= range_start && c <= range_end {\n-            return true;\n-        }\n-    }\n-    false\n+declare_lint! {\n+    pub MIXED_SCRIPT_CONFUSABLES,\n+    Warn,\n+    \"detects Unicode scripts whose mixed script confusables codepoints are solely used\",\n+    crate_level_only\n }\n \n-fn is_in_ascii_confusable_closure_relevant_list(c: char) -> bool {\n-    // FIXME: move this table to `unicode_security` crate.\n-    // data here corresponds to Unicode 13.\n-    const ASCII_CONFUSABLE_CLOSURE_RELEVANT_LIST: &[u64] = &[\n-        0x22, 0x25, 0x27, 0x2f, 0x30, 0x31, 0x49, 0x4f, 0x60, 0x6c, 0x6d, 0x6e, 0x72, 0x7c, 0xba,\n-        0x2080,\n-    ];\n-    let c = c as u64;\n-    for &item in ASCII_CONFUSABLE_CLOSURE_RELEVANT_LIST {\n-        if c == item {\n-            return true;\n-        }\n-    }\n-    false\n-}\n+declare_lint_pass!(NonAsciiIdents => [NON_ASCII_IDENTS, UNCOMMON_CODEPOINTS, CONFUSABLE_IDENTS, MIXED_SCRIPT_CONFUSABLES]);\n \n impl EarlyLintPass for NonAsciiIdents {\n     fn check_crate(&mut self, cx: &EarlyContext<'_>, _: &ast::Crate) {\n         use rustc_session::lint::Level;\n-        if cx.builder.lint_level(CONFUSABLE_IDENTS).0 == Level::Allow {\n+        use rustc_span::Span;\n+        use std::collections::BTreeMap;\n+        use unicode_security::GeneralSecurityProfile;\n+        use utils::CowBoxSymStr;\n+\n+        let check_non_ascii_idents = cx.builder.lint_level(NON_ASCII_IDENTS).0 != Level::Allow;\n+        let check_uncommon_codepoints =\n+            cx.builder.lint_level(UNCOMMON_CODEPOINTS).0 != Level::Allow;\n+        let check_confusable_idents = cx.builder.lint_level(CONFUSABLE_IDENTS).0 != Level::Allow;\n+        let check_mixed_script_confusables =\n+            cx.builder.lint_level(MIXED_SCRIPT_CONFUSABLES).0 != Level::Allow;\n+\n+        if !check_non_ascii_idents\n+            && !check_uncommon_codepoints\n+            && !check_confusable_idents\n+            && !check_mixed_script_confusables\n+        {\n             return;\n         }\n+\n+        let mut has_non_ascii_idents = false;\n         let symbols = cx.sess.parse_sess.symbol_gallery.symbols.lock();\n-        let mut symbol_strs_and_spans = Vec::with_capacity(symbols.len());\n-        let mut in_fast_path = true;\n-        for (symbol, sp) in symbols.iter() {\n-            // fast path\n+        for (symbol, &sp) in symbols.iter() {\n             let symbol_str = symbol.as_str();\n-            if !symbol_str.chars().all(is_in_ascii_confusable_closure) {\n-                // fallback to slow path.\n-                symbol_strs_and_spans.clear();\n-                in_fast_path = false;\n-                break;\n+            if symbol_str.is_ascii() {\n+                continue;\n             }\n-            if symbol_str.chars().any(is_in_ascii_confusable_closure_relevant_list) {\n-                symbol_strs_and_spans.push((symbol_str, *sp));\n+            has_non_ascii_idents = true;\n+            cx.struct_span_lint(NON_ASCII_IDENTS, sp, |lint| {\n+                lint.build(\"identifier contains non-ASCII characters\").emit()\n+            });\n+            if check_uncommon_codepoints\n+                && !symbol_str.chars().all(GeneralSecurityProfile::identifier_allowed)\n+            {\n+                cx.struct_span_lint(UNCOMMON_CODEPOINTS, sp, |lint| {\n+                    lint.build(\"identifier contains uncommon Unicode codepoints\").emit()\n+                })\n             }\n         }\n-        if !in_fast_path {\n-            // slow path\n-            for (symbol, sp) in symbols.iter() {\n+\n+        if has_non_ascii_idents && check_confusable_idents {\n+            let mut skeleton_map: FxHashMap<CowBoxSymStr, (SymbolStr, Span, bool)> =\n+                FxHashMap::with_capacity_and_hasher(symbols.len(), Default::default());\n+            let mut str_buf = String::new();\n+            for (symbol, &sp) in symbols.iter() {\n+                fn calc_skeleton(symbol_str: &SymbolStr, buffer: &mut String) -> CowBoxSymStr {\n+                    use std::mem::replace;\n+                    use unicode_security::confusable_detection::skeleton;\n+                    buffer.clear();\n+                    buffer.extend(skeleton(symbol_str));\n+                    if *symbol_str == *buffer {\n+                        CowBoxSymStr::Interned(symbol_str.clone())\n+                    } else {\n+                        let owned = replace(buffer, String::new());\n+                        CowBoxSymStr::Owned(owned.into_boxed_str())\n+                    }\n+                }\n                 let symbol_str = symbol.as_str();\n-                symbol_strs_and_spans.push((symbol_str, *sp));\n+                let is_ascii = symbol_str.is_ascii();\n+                let skeleton = calc_skeleton(&symbol_str, &mut str_buf);\n+                skeleton_map\n+                    .entry(skeleton)\n+                    .and_modify(|(existing_symbolstr, existing_span, existing_is_ascii)| {\n+                        if !*existing_is_ascii || !is_ascii {\n+                            cx.struct_span_lint(CONFUSABLE_IDENTS, sp, |lint| {\n+                                lint.build(&format!(\n+                                    \"identifier pair considered confusable between `{}` and `{}`\",\n+                                    existing_symbolstr, symbol_str\n+                                ))\n+                                .span_label(\n+                                    *existing_span,\n+                                    \"this is where the previous identifier occurred\",\n+                                )\n+                                .emit();\n+                            });\n+                        }\n+                        if *existing_is_ascii && !is_ascii {\n+                            *existing_symbolstr = symbol_str.clone();\n+                            *existing_span = sp;\n+                            *existing_is_ascii = is_ascii;\n+                        }\n+                    })\n+                    .or_insert((symbol_str, sp, is_ascii));\n             }\n         }\n-        drop(symbols);\n-        symbol_strs_and_spans.sort_by_key(|x| x.0.clone());\n-        let mut skeleton_map =\n-            FxHashMap::with_capacity_and_hasher(symbol_strs_and_spans.len(), Default::default());\n-        let mut str_buf = String::new();\n-        for (symbol_str, sp) in symbol_strs_and_spans {\n-            let skeleton = calc_skeleton(symbol_str.clone(), &mut str_buf);\n-            skeleton_map\n-                .entry(skeleton)\n-                .and_modify(|(existing_symbolstr, existing_span)| {\n-                    cx.struct_span_lint(CONFUSABLE_IDENTS, sp, |lint| {\n-                        lint.build(&format!(\n-                            \"identifier pair considered confusable between `{}` and `{}`\",\n-                            existing_symbolstr, symbol_str\n-                        ))\n-                        .span_label(\n-                            *existing_span,\n-                            \"this is where the previous identifier occurred\",\n-                        )\n-                        .emit();\n+\n+        if has_non_ascii_idents && check_mixed_script_confusables {\n+            use unicode_security::is_potential_mixed_script_confusable_char;\n+            use unicode_security::mixed_script::AugmentedScriptSet;\n+\n+            #[derive(Clone)]\n+            enum ScriptSetUsage {\n+                Suspicious(Vec<char>, Span),\n+                Verified,\n+            }\n+\n+            let mut script_states: FxHashMap<AugmentedScriptSet, ScriptSetUsage> =\n+                FxHashMap::default();\n+            let latin_augmented_script_set = AugmentedScriptSet::for_char('A');\n+            script_states.insert(latin_augmented_script_set, ScriptSetUsage::Verified);\n+\n+            let mut has_suspicous = false;\n+            for (symbol, &sp) in symbols.iter() {\n+                let symbol_str = symbol.as_str();\n+                for ch in symbol_str.chars() {\n+                    if ch.is_ascii() {\n+                        // all ascii characters are covered by exception.\n+                        continue;\n+                    }\n+                    if !GeneralSecurityProfile::identifier_allowed(ch) {\n+                        // this character is covered by `uncommon_codepoints` lint.\n+                        continue;\n+                    }\n+                    let augmented_script_set = AugmentedScriptSet::for_char(ch);\n+                    script_states\n+                        .entry(augmented_script_set)\n+                        .and_modify(|existing_state| {\n+                            if let ScriptSetUsage::Suspicious(ch_list, _) = existing_state {\n+                                if is_potential_mixed_script_confusable_char(ch) {\n+                                    ch_list.push(ch);\n+                                } else {\n+                                    *existing_state = ScriptSetUsage::Verified;\n+                                }\n+                            }\n+                        })\n+                        .or_insert_with(|| {\n+                            if !is_potential_mixed_script_confusable_char(ch) {\n+                                ScriptSetUsage::Verified\n+                            } else {\n+                                has_suspicous = true;\n+                                ScriptSetUsage::Suspicious(vec![ch], sp)\n+                            }\n+                        });\n+                }\n+            }\n+\n+            if has_suspicous {\n+                let verified_augmented_script_sets = script_states\n+                    .iter()\n+                    .flat_map(|(k, v)| match v {\n+                        ScriptSetUsage::Verified => Some(*k),\n+                        _ => None,\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                // we're sorting the output here.\n+                let mut lint_reports: BTreeMap<(Span, Vec<char>), AugmentedScriptSet> =\n+                    BTreeMap::new();\n+\n+                'outerloop: for (augment_script_set, usage) in script_states {\n+                    let (mut ch_list, sp) = match usage {\n+                        ScriptSetUsage::Verified => continue,\n+                        ScriptSetUsage::Suspicious(ch_list, sp) => (ch_list, sp),\n+                    };\n+\n+                    if augment_script_set.is_all() {\n+                        continue;\n+                    }\n+\n+                    for existing in verified_augmented_script_sets.iter() {\n+                        if existing.is_all() {\n+                            continue;\n+                        }\n+                        let mut intersect = *existing;\n+                        intersect.intersect_with(augment_script_set);\n+                        if !intersect.is_empty() && !intersect.is_all() {\n+                            continue 'outerloop;\n+                        }\n+                    }\n+\n+                    ch_list.sort();\n+                    ch_list.dedup();\n+                    lint_reports.insert((sp, ch_list), augment_script_set);\n+                }\n+\n+                for ((sp, ch_list), script_set) in lint_reports {\n+                    cx.struct_span_lint(MIXED_SCRIPT_CONFUSABLES, sp, |lint| {\n+                        let message = format!(\n+                            \"The usage of Script Group `{}` in this crate consists solely of mixed script confusables\",\n+                            script_set);\n+                        let mut note = \"The usage includes \".to_string();\n+                        for (idx, ch) in ch_list.into_iter().enumerate() {\n+                            if idx != 0 {\n+                                note += \", \";\n+                            }\n+                            let char_info = format!(\"'{}' (U+{:04X})\", ch, ch as u32);\n+                            note += &char_info;\n+                        }\n+                        note += \".\";\n+                        lint.build(&message).note(&note).note(\"Please recheck to make sure their usages are indeed what you want.\").emit()\n                     });\n-                })\n-                .or_insert((symbol_str, sp));\n+                }\n+            }\n         }\n     }\n-    fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: Ident) {\n-        use unicode_security::GeneralSecurityProfile;\n-        let name_str = ident.name.as_str();\n-        if name_str.is_ascii() {\n-            return;\n+}\n+\n+mod utils {\n+    use rustc_span::symbol::SymbolStr;\n+    use std::hash::{Hash, Hasher};\n+    use std::ops::Deref;\n+\n+    pub(super) enum CowBoxSymStr {\n+        Interned(SymbolStr),\n+        Owned(Box<str>),\n+    }\n+\n+    impl Deref for CowBoxSymStr {\n+        type Target = str;\n+\n+        fn deref(&self) -> &str {\n+            match self {\n+                CowBoxSymStr::Interned(interned) => interned,\n+                CowBoxSymStr::Owned(ref owned) => owned,\n+            }\n+        }\n+    }\n+\n+    impl Hash for CowBoxSymStr {\n+        #[inline]\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            Hash::hash(&**self, state)\n         }\n-        cx.struct_span_lint(NON_ASCII_IDENTS, ident.span, |lint| {\n-            lint.build(\"identifier contains non-ASCII characters\").emit()\n-        });\n-        if !name_str.chars().all(GeneralSecurityProfile::identifier_allowed) {\n-            cx.struct_span_lint(UNCOMMON_CODEPOINTS, ident.span, |lint| {\n-                lint.build(\"identifier contains uncommon Unicode codepoints\").emit()\n-            })\n+    }\n+\n+    impl PartialEq<CowBoxSymStr> for CowBoxSymStr {\n+        #[inline]\n+        fn eq(&self, other: &CowBoxSymStr) -> bool {\n+            PartialEq::eq(&**self, &**other)\n         }\n     }\n+\n+    impl Eq for CowBoxSymStr {}\n }"}, {"sha": "9ad79230a4f6d73851be217cd7ac4f9d87f054ad", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -10,6 +10,8 @@ use rustc_index::vec::IndexVec;\n use rustc_span::{Span, Symbol};\n use rustc_target::abi::VariantIdx;\n use smallvec::SmallVec;\n+use std::cell::Cell;\n+use std::fmt::{self, Debug};\n \n use super::{Field, SourceInfo};\n \n@@ -58,7 +60,7 @@ rustc_index::newtype_index! {\n }\n \n /// The layout of generator state.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n pub struct GeneratorLayout<'tcx> {\n     /// The type of every local stored inside the generator.\n     pub field_tys: IndexVec<GeneratorSavedLocal, Ty<'tcx>>,\n@@ -67,12 +69,72 @@ pub struct GeneratorLayout<'tcx> {\n     /// be stored in multiple variants.\n     pub variant_fields: IndexVec<VariantIdx, IndexVec<Field, GeneratorSavedLocal>>,\n \n+    /// The source that led to each variant being created (usually, a yield or\n+    /// await).\n+    pub variant_source_info: IndexVec<VariantIdx, SourceInfo>,\n+\n     /// Which saved locals are storage-live at the same time. Locals that do not\n     /// have conflicts with each other are allowed to overlap in the computed\n     /// layout.\n     pub storage_conflicts: BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n }\n \n+impl Debug for GeneratorLayout<'_> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        /// Prints an iterator of (key, value) tuples as a map.\n+        struct MapPrinter<'a, K, V>(Cell<Option<Box<dyn Iterator<Item = (K, V)> + 'a>>>);\n+        impl<'a, K, V> MapPrinter<'a, K, V> {\n+            fn new(iter: impl Iterator<Item = (K, V)> + 'a) -> Self {\n+                Self(Cell::new(Some(Box::new(iter))))\n+            }\n+        }\n+        impl<'a, K: Debug, V: Debug> Debug for MapPrinter<'a, K, V> {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_map().entries(self.0.take().unwrap()).finish()\n+            }\n+        }\n+\n+        /// Prints the generator variant name.\n+        struct GenVariantPrinter(VariantIdx);\n+        impl From<VariantIdx> for GenVariantPrinter {\n+            fn from(idx: VariantIdx) -> Self {\n+                GenVariantPrinter(idx)\n+            }\n+        }\n+        impl Debug for GenVariantPrinter {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                let variant_name = ty::GeneratorSubsts::variant_name(self.0);\n+                if fmt.alternate() {\n+                    write!(fmt, \"{:9}({:?})\", variant_name, self.0)\n+                } else {\n+                    write!(fmt, \"{}\", variant_name)\n+                }\n+            }\n+        }\n+\n+        /// Forces its contents to print in regular mode instead of alternate mode.\n+        struct OneLinePrinter<T>(T);\n+        impl<T: Debug> Debug for OneLinePrinter<T> {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                write!(fmt, \"{:?}\", self.0)\n+            }\n+        }\n+\n+        fmt.debug_struct(\"GeneratorLayout\")\n+            .field(\"field_tys\", &MapPrinter::new(self.field_tys.iter_enumerated()))\n+            .field(\n+                \"variant_fields\",\n+                &MapPrinter::new(\n+                    self.variant_fields\n+                        .iter_enumerated()\n+                        .map(|(k, v)| (GenVariantPrinter(k), OneLinePrinter(v))),\n+                ),\n+            )\n+            .field(\"storage_conflicts\", &self.storage_conflicts)\n+            .finish()\n+    }\n+}\n+\n #[derive(Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct BorrowCheckResult<'tcx> {\n     /// All the opaque types that are restricted to concrete types"}, {"sha": "8f86d2ef522d33a82b4fed5511578e03799a289a", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -522,8 +522,7 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n \n     /// Calls `f` with a reference to the name of the enumerator for the given\n     /// variant `v`.\n-    #[inline]\n-    pub fn variant_name(self, v: VariantIdx) -> Cow<'static, str> {\n+    pub fn variant_name(v: VariantIdx) -> Cow<'static, str> {\n         match v.as_usize() {\n             Self::UNRESUMED => Cow::from(Self::UNRESUMED_NAME),\n             Self::RETURNED => Cow::from(Self::RETURNED_NAME),"}, {"sha": "60a1fe0b19870deb3d9ebd390eba5d0af204a52a", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -156,6 +156,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         format!(\"variable moved due to use{}\", move_spans.describe()),\n                     );\n                 }\n+                if let UseSpans::PatUse(span) = move_spans {\n+                    err.span_suggestion_verbose(\n+                        span.shrink_to_lo(),\n+                        &format!(\n+                            \"borrow this field in the pattern to avoid moving {}\",\n+                            self.describe_place(moved_place.as_ref())\n+                                .map(|n| format!(\"`{}`\", n))\n+                                .unwrap_or_else(|| \"the value\".to_string())\n+                        ),\n+                        \"ref \".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+\n                 if Some(DesugaringKind::ForLoop) == move_span.desugaring_kind() {\n                     let sess = self.infcx.tcx.sess;\n                     if let Ok(snippet) = sess.source_map().span_to_snippet(move_span) {\n@@ -198,11 +212,28 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 _ => true,\n             };\n \n-            if needs_note {\n-                let mpi = self.move_data.moves[move_out_indices[0]].path;\n-                let place = &self.move_data.move_paths[mpi].place;\n+            let mpi = self.move_data.moves[move_out_indices[0]].path;\n+            let place = &self.move_data.move_paths[mpi].place;\n+            let ty = place.ty(self.body, self.infcx.tcx).ty;\n+\n+            if is_loop_move {\n+                if let ty::Ref(_, _, hir::Mutability::Mut) = ty.kind {\n+                    // We have a `&mut` ref, we need to reborrow on each iteration (#62112).\n+                    err.span_suggestion_verbose(\n+                        span.shrink_to_lo(),\n+                        &format!(\n+                            \"consider creating a fresh reborrow of {} here\",\n+                            self.describe_place(moved_place)\n+                                .map(|n| format!(\"`{}`\", n))\n+                                .unwrap_or_else(|| \"the mutable reference\".to_string()),\n+                        ),\n+                        \"&mut *\".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n \n-                let ty = place.ty(self.body, self.infcx.tcx).ty;\n+            if needs_note {\n                 let opt_name =\n                     self.describe_place_with_options(place.as_ref(), IncludingDowncast(true));\n                 let note_msg = match opt_name {"}, {"sha": "849fd63998db49a9bfc42e594dde51712c6b4b64", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -509,7 +509,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // Used in a closure.\n                 (LaterUseKind::ClosureCapture, var_span)\n             }\n-            UseSpans::OtherUse(span) => {\n+            UseSpans::PatUse(span) | UseSpans::OtherUse(span) => {\n                 let block = &self.body.basic_blocks()[location.block];\n \n                 let kind = if let Some(&Statement {"}, {"sha": "388076a9d60afb77ba09af01bf74a40f8b0c6cd5", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -542,20 +542,26 @@ pub(super) enum UseSpans {\n         // The span of the first use of the captured variable inside the closure.\n         var_span: Span,\n     },\n-    // This access has a single span associated to it: common case.\n+    /// This access is caused by a `match` or `if let` pattern.\n+    PatUse(Span),\n+    /// This access has a single span associated to it: common case.\n     OtherUse(Span),\n }\n \n impl UseSpans {\n     pub(super) fn args_or_use(self) -> Span {\n         match self {\n-            UseSpans::ClosureUse { args_span: span, .. } | UseSpans::OtherUse(span) => span,\n+            UseSpans::ClosureUse { args_span: span, .. }\n+            | UseSpans::PatUse(span)\n+            | UseSpans::OtherUse(span) => span,\n         }\n     }\n \n     pub(super) fn var_or_use(self) -> Span {\n         match self {\n-            UseSpans::ClosureUse { var_span: span, .. } | UseSpans::OtherUse(span) => span,\n+            UseSpans::ClosureUse { var_span: span, .. }\n+            | UseSpans::PatUse(span)\n+            | UseSpans::OtherUse(span) => span,\n         }\n     }\n \n@@ -624,7 +630,7 @@ impl UseSpans {\n     {\n         match self {\n             closure @ UseSpans::ClosureUse { .. } => closure,\n-            UseSpans::OtherUse(_) => if_other(),\n+            UseSpans::PatUse(_) | UseSpans::OtherUse(_) => if_other(),\n         }\n     }\n }\n@@ -741,7 +747,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n         }\n \n-        OtherUse(stmt.source_info.span)\n+        if moved_place.projection.iter().any(|p| matches!(p, ProjectionElem::Downcast(..))) {\n+            PatUse(stmt.source_info.span)\n+        } else {\n+            OtherUse(stmt.source_info.span)\n+        }\n     }\n \n     /// Finds the span of arguments of a closure (within `maybe_closure_span`)"}, {"sha": "88ba28dab82e18081ea8ce1756a62b212081916b", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -69,6 +69,13 @@ crate fn eval_nullary_intrinsic<'tcx>(\n             ConstValue::from_machine_usize(n, &tcx)\n         }\n         sym::type_id => ConstValue::from_u64(tcx.type_id_hash(tp_ty)),\n+        sym::variant_count => {\n+            if let ty::Adt(ref adt, _) = tp_ty.kind {\n+                ConstValue::from_machine_usize(adt.variants.len() as u64, &tcx)\n+            } else {\n+                ConstValue::from_machine_usize(0u64, &tcx)\n+            }\n+        }\n         other => bug!(\"`{}` is not a zero arg intrinsic\", other),\n     })\n }\n@@ -109,10 +116,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | sym::needs_drop\n             | sym::size_of\n             | sym::type_id\n-            | sym::type_name => {\n+            | sym::type_name\n+            | sym::variant_count => {\n                 let gid = GlobalId { instance, promoted: None };\n                 let ty = match intrinsic_name {\n-                    sym::min_align_of | sym::pref_align_of | sym::size_of => self.tcx.types.usize,\n+                    sym::min_align_of | sym::pref_align_of | sym::size_of | sym::variant_count => {\n+                        self.tcx.types.usize\n+                    }\n                     sym::needs_drop => self.tcx.types.bool,\n                     sym::type_id => self.tcx.types.u64,\n                     sym::type_name => self.tcx.mk_static_str(),"}, {"sha": "523d3c9af3f68c0dfde4f15e4272545618479c9d", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -422,6 +422,9 @@ struct LivenessInfo {\n     /// The set of saved locals live at each suspension point.\n     live_locals_at_suspension_points: Vec<BitSet<GeneratorSavedLocal>>,\n \n+    /// Parallel vec to the above with SourceInfo for each yield terminator.\n+    source_info_at_suspension_points: Vec<SourceInfo>,\n+\n     /// For every saved local, the set of other saved locals that are\n     /// storage-live at the same time as this local. We cannot overlap locals in\n     /// the layout which have conflicting storage.\n@@ -473,6 +476,7 @@ fn locals_live_across_suspend_points(\n \n     let mut storage_liveness_map = IndexVec::from_elem(None, body.basic_blocks());\n     let mut live_locals_at_suspension_points = Vec::new();\n+    let mut source_info_at_suspension_points = Vec::new();\n     let mut live_locals_at_any_suspension_point = BitSet::new_empty(body.local_decls.len());\n \n     for (block, data) in body.basic_blocks().iter_enumerated() {\n@@ -518,6 +522,7 @@ fn locals_live_across_suspend_points(\n             live_locals_at_any_suspension_point.union(&live_locals);\n \n             live_locals_at_suspension_points.push(live_locals);\n+            source_info_at_suspension_points.push(data.terminator().source_info);\n         }\n     }\n \n@@ -541,6 +546,7 @@ fn locals_live_across_suspend_points(\n     LivenessInfo {\n         saved_locals,\n         live_locals_at_suspension_points,\n+        source_info_at_suspension_points,\n         storage_conflicts,\n         storage_liveness: storage_liveness_map,\n     }\n@@ -754,6 +760,7 @@ fn compute_layout<'tcx>(\n     let LivenessInfo {\n         saved_locals,\n         live_locals_at_suspension_points,\n+        source_info_at_suspension_points,\n         storage_conflicts,\n         storage_liveness,\n     } = liveness;\n@@ -768,7 +775,18 @@ fn compute_layout<'tcx>(\n     }\n \n     // Leave empty variants for the UNRESUMED, RETURNED, and POISONED states.\n+    // In debuginfo, these will correspond to the beginning (UNRESUMED) or end\n+    // (RETURNED, POISONED) of the function.\n     const RESERVED_VARIANTS: usize = 3;\n+    let body_span = body.source_scopes[OUTERMOST_SOURCE_SCOPE].span;\n+    let mut variant_source_info: IndexVec<VariantIdx, SourceInfo> = [\n+        SourceInfo::outermost(body_span.shrink_to_lo()),\n+        SourceInfo::outermost(body_span.shrink_to_hi()),\n+        SourceInfo::outermost(body_span.shrink_to_hi()),\n+    ]\n+    .iter()\n+    .copied()\n+    .collect();\n \n     // Build the generator variant field list.\n     // Create a map from local indices to generator struct indices.\n@@ -787,11 +805,13 @@ fn compute_layout<'tcx>(\n             remap.entry(locals[saved_local]).or_insert((tys[saved_local], variant_index, idx));\n         }\n         variant_fields.push(fields);\n+        variant_source_info.push(source_info_at_suspension_points[suspension_point_idx]);\n     }\n     debug!(\"generator variant_fields = {:?}\", variant_fields);\n     debug!(\"generator storage_conflicts = {:#?}\", storage_conflicts);\n \n-    let layout = GeneratorLayout { field_tys: tys, variant_fields, storage_conflicts };\n+    let layout =\n+        GeneratorLayout { field_tys: tys, variant_fields, variant_source_info, storage_conflicts };\n \n     (remap, layout, storage_liveness)\n }"}, {"sha": "db45481e4fd259acbd6114f6fb9768aba7727d7f", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -131,7 +131,7 @@ fn dump_matched_mir_node<'tcx, F>(\n         }\n         writeln!(file, \" {} {}\", disambiguator, pass_name)?;\n         if let Some(ref layout) = body.generator_layout {\n-            writeln!(file, \"// generator_layout = {:?}\", layout)?;\n+            writeln!(file, \"/* generator_layout = {:#?} */\", layout)?;\n         }\n         writeln!(file)?;\n         extra_data(PassWhere::BeforeCFG, &mut file)?;"}, {"sha": "5050f03bea9b2244a4224571e8e024b16b3109f1", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -367,12 +367,15 @@ impl<'a> StringReader<'a> {\n             }\n             rustc_lexer::LiteralKind::ByteStr { terminated } => {\n                 if !terminated {\n-                    self.fatal_span_(\n-                        start + BytePos(1),\n-                        suffix_start,\n-                        \"unterminated double quote byte string\",\n-                    )\n-                    .raise()\n+                    self.sess\n+                        .span_diagnostic\n+                        .struct_span_fatal_with_code(\n+                            self.mk_sp(start + BytePos(1), suffix_start),\n+                            \"unterminated double quote byte string\",\n+                            error_code!(E0766),\n+                        )\n+                        .emit();\n+                    FatalError.raise();\n                 }\n                 (token::ByteStr, Mode::ByteStr, 2, 1) // b\" \"\n             }"}, {"sha": "27396c524f4e6f4134dfeee763fd2f77a7cf283f", "filename": "src/librustc_session/filesearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_session%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_session%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Ffilesearch.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -41,7 +41,7 @@ impl<'a> FileSearch<'a> {\n         make_target_lib_path(self.sysroot, self.triple)\n     }\n \n-    pub fn get_selfcontained_lib_path(&self) -> PathBuf {\n+    pub fn get_self_contained_lib_path(&self) -> PathBuf {\n         self.get_lib_path().join(\"self-contained\")\n     }\n \n@@ -92,13 +92,13 @@ impl<'a> FileSearch<'a> {\n     }\n \n     // Returns a list of directories where target-specific tool binaries are located.\n-    pub fn get_tools_search_paths(&self) -> Vec<PathBuf> {\n+    pub fn get_tools_search_paths(&self, self_contained: bool) -> Vec<PathBuf> {\n         let mut p = PathBuf::from(self.sysroot);\n         p.push(find_libdir(self.sysroot).as_ref());\n         p.push(RUST_LIB_DIR);\n         p.push(&self.triple);\n         p.push(\"bin\");\n-        vec![p.clone(), p.join(\"self-contained\")]\n+        if self_contained { vec![p.clone(), p.join(\"self-contained\")] } else { vec![p.clone()] }\n     }\n }\n "}, {"sha": "9337f241d7022fd322a2a708cba2fde5271ee716", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -889,6 +889,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"keep hygiene data after analysis (default: no)\"),\n     link_native_libraries: bool = (true, parse_bool, [UNTRACKED],\n         \"link native libraries in the linker invocation (default: yes)\"),\n+    link_self_contained: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"control whether to link Rust provided C objects/libraries or rely\n+         on C toolchain installed in the system\"),\n     link_only: bool = (false, parse_bool, [TRACKED],\n         \"link the `.rlink` file generated by `-Z no-link` (default: no)\"),\n     llvm_time_trace: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "b428315b3cdf395c76ca03f1f8556b6e13775ab9", "filename": "src/librustc_session/parse.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_session%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_session%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fparse.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -13,6 +13,7 @@ use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{FilePathMapping, SourceMap};\n use rustc_span::{MultiSpan, Span, Symbol};\n \n+use std::collections::BTreeMap;\n use std::path::PathBuf;\n use std::str;\n \n@@ -63,7 +64,7 @@ impl GatedSpans {\n #[derive(Default)]\n pub struct SymbolGallery {\n     /// All symbols occurred and their first occurrance span.\n-    pub symbols: Lock<FxHashMap<Symbol, Span>>,\n+    pub symbols: Lock<BTreeMap<Symbol, Span>>,\n }\n \n impl SymbolGallery {"}, {"sha": "857734037afe7c588dfa6b07d30be60234b94852", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -832,6 +832,7 @@ symbols! {\n         v1,\n         val,\n         var,\n+        variant_count,\n         vec,\n         Vec,\n         version,"}, {"sha": "1c0b22ca7370bd5da2bdad633619a2abe85058c4", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -75,7 +75,7 @@ pub fn intrinsic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n         | \"saturating_sub\" | \"rotate_left\" | \"rotate_right\" | \"ctpop\" | \"ctlz\" | \"cttz\"\n         | \"bswap\" | \"bitreverse\" | \"discriminant_value\" | \"type_id\" | \"likely\" | \"unlikely\"\n         | \"ptr_guaranteed_eq\" | \"ptr_guaranteed_ne\" | \"minnumf32\" | \"minnumf64\" | \"maxnumf32\"\n-        | \"maxnumf64\" | \"type_name\" => hir::Unsafety::Normal,\n+        | \"maxnumf64\" | \"type_name\" | \"variant_count\" => hir::Unsafety::Normal,\n         _ => hir::Unsafety::Unsafe,\n     }\n }\n@@ -137,7 +137,9 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n         let unsafety = intrinsic_operation_unsafety(&name[..]);\n         let (n_tps, inputs, output) = match &name[..] {\n             \"breakpoint\" => (0, Vec::new(), tcx.mk_unit()),\n-            \"size_of\" | \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), tcx.types.usize),\n+            \"size_of\" | \"pref_align_of\" | \"min_align_of\" | \"variant_count\" => {\n+                (1, Vec::new(), tcx.types.usize)\n+            }\n             \"size_of_val\" | \"min_align_of_val\" => {\n                 (1, vec![tcx.mk_imm_ptr(param(0))], tcx.types.usize)\n             }"}, {"sha": "7bdf137f116c858f0284b31764aef60105280f54", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -295,8 +295,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         opt_input_types: Option<&[Ty<'tcx>]>,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         debug!(\n-            \"lookup_in_trait_adjusted(self_ty={:?}, \\\n-                m_name={}, trait_def_id={:?})\",\n+            \"lookup_in_trait_adjusted(self_ty={:?}, m_name={}, trait_def_id={:?})\",\n             self_ty, m_name, trait_def_id\n         );\n "}, {"sha": "8842ca877268a00bcb3aa98ec78f2a214cab2860", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -380,8 +380,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         self.tcx.sess,\n                         span,\n                         E0699,\n-                        \"the type of this value must be known \\\n-                               to call a method on a raw pointer on it\"\n+                        \"the type of this value must be known to call a method on a raw pointer on \\\n+                         it\"\n                     )\n                     .emit();\n                 } else {"}, {"sha": "94a5685a992feaeec414e9f43c4cf34a57bff810", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 248, "deletions": 246, "changes": 494, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -8,8 +8,11 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n+use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::TyKind::{Adt, Array, Char, FnDef, Never, Ref, Str, Tuple, Uint};\n-use rustc_middle::ty::{self, suggest_constraining_type_param, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{\n+    self, suggest_constraining_type_param, Ty, TyCtxt, TypeFoldable, TypeVisitor,\n+};\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n@@ -249,254 +252,229 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 method.sig.output()\n             }\n+            // error types are considered \"builtin\"\n+            Err(()) if lhs_ty.references_error() || rhs_ty.references_error() => {\n+                self.tcx.ty_error()\n+            }\n             Err(()) => {\n-                // error types are considered \"builtin\"\n-                if !lhs_ty.references_error() && !rhs_ty.references_error() {\n-                    let source_map = self.tcx.sess.source_map();\n-\n-                    match is_assign {\n-                        IsAssign::Yes => {\n-                            let mut err = struct_span_err!(\n-                                self.tcx.sess,\n-                                expr.span,\n-                                E0368,\n-                                \"binary assignment operation `{}=` cannot be applied to type `{}`\",\n-                                op.node.as_str(),\n+                let source_map = self.tcx.sess.source_map();\n+                let (mut err, missing_trait, use_output, involves_fn) = match is_assign {\n+                    IsAssign::Yes => {\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            expr.span,\n+                            E0368,\n+                            \"binary assignment operation `{}=` cannot be applied to type `{}`\",\n+                            op.node.as_str(),\n+                            lhs_ty,\n+                        );\n+                        err.span_label(\n+                            lhs_expr.span,\n+                            format!(\"cannot use `{}=` on type `{}`\", op.node.as_str(), lhs_ty),\n+                        );\n+                        let missing_trait = match op.node {\n+                            hir::BinOpKind::Add => Some(\"std::ops::AddAssign\"),\n+                            hir::BinOpKind::Sub => Some(\"std::ops::SubAssign\"),\n+                            hir::BinOpKind::Mul => Some(\"std::ops::MulAssign\"),\n+                            hir::BinOpKind::Div => Some(\"std::ops::DivAssign\"),\n+                            hir::BinOpKind::Rem => Some(\"std::ops::RemAssign\"),\n+                            hir::BinOpKind::BitAnd => Some(\"std::ops::BitAndAssign\"),\n+                            hir::BinOpKind::BitXor => Some(\"std::ops::BitXorAssign\"),\n+                            hir::BinOpKind::BitOr => Some(\"std::ops::BitOrAssign\"),\n+                            hir::BinOpKind::Shl => Some(\"std::ops::ShlAssign\"),\n+                            hir::BinOpKind::Shr => Some(\"std::ops::ShrAssign\"),\n+                            _ => None,\n+                        };\n+                        (err, missing_trait, false, false)\n+                    }\n+                    IsAssign::No => {\n+                        let (message, missing_trait, use_output) = match op.node {\n+                            hir::BinOpKind::Add => (\n+                                format!(\"cannot add `{}` to `{}`\", rhs_ty, lhs_ty),\n+                                Some(\"std::ops::Add\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Sub => (\n+                                format!(\"cannot subtract `{}` from `{}`\", rhs_ty, lhs_ty),\n+                                Some(\"std::ops::Sub\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Mul => (\n+                                format!(\"cannot multiply `{}` to `{}`\", rhs_ty, lhs_ty),\n+                                Some(\"std::ops::Mul\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Div => (\n+                                format!(\"cannot divide `{}` by `{}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::Div\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Rem => (\n+                                format!(\"cannot mod `{}` by `{}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::Rem\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::BitAnd => (\n+                                format!(\"no implementation for `{} & {}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::BitAnd\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::BitXor => (\n+                                format!(\"no implementation for `{} ^ {}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::BitXor\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::BitOr => (\n+                                format!(\"no implementation for `{} | {}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::BitOr\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Shl => (\n+                                format!(\"no implementation for `{} << {}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::Shl\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Shr => (\n+                                format!(\"no implementation for `{} >> {}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::Shr\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Eq | hir::BinOpKind::Ne => (\n+                                format!(\n+                                    \"binary operation `{}` cannot be applied to type `{}`\",\n+                                    op.node.as_str(),\n+                                    lhs_ty\n+                                ),\n+                                Some(\"std::cmp::PartialEq\"),\n+                                false,\n+                            ),\n+                            hir::BinOpKind::Lt\n+                            | hir::BinOpKind::Le\n+                            | hir::BinOpKind::Gt\n+                            | hir::BinOpKind::Ge => (\n+                                format!(\n+                                    \"binary operation `{}` cannot be applied to type `{}`\",\n+                                    op.node.as_str(),\n+                                    lhs_ty\n+                                ),\n+                                Some(\"std::cmp::PartialOrd\"),\n+                                false,\n+                            ),\n+                            _ => (\n+                                format!(\n+                                    \"binary operation `{}` cannot be applied to type `{}`\",\n+                                    op.node.as_str(),\n+                                    lhs_ty\n+                                ),\n+                                None,\n+                                false,\n+                            ),\n+                        };\n+                        let mut err =\n+                            struct_span_err!(self.tcx.sess, op.span, E0369, \"{}\", message.as_str());\n+                        let mut involves_fn = false;\n+                        if !lhs_expr.span.eq(&rhs_expr.span) {\n+                            involves_fn |= self.add_type_neq_err_label(\n+                                &mut err,\n+                                lhs_expr.span,\n                                 lhs_ty,\n+                                rhs_ty,\n+                                op,\n+                                is_assign,\n                             );\n-                            err.span_label(\n-                                lhs_expr.span,\n-                                format!(\"cannot use `{}=` on type `{}`\", op.node.as_str(), lhs_ty),\n+                            involves_fn |= self.add_type_neq_err_label(\n+                                &mut err,\n+                                rhs_expr.span,\n+                                rhs_ty,\n+                                lhs_ty,\n+                                op,\n+                                is_assign,\n                             );\n-                            let mut suggested_deref = false;\n-                            if let Ref(_, rty, _) = lhs_ty.kind {\n-                                if {\n-                                    self.infcx.type_is_copy_modulo_regions(\n-                                        self.param_env,\n-                                        rty,\n-                                        lhs_expr.span,\n-                                    ) && self\n-                                        .lookup_op_method(rty, &[rhs_ty], Op::Binary(op, is_assign))\n-                                        .is_ok()\n-                                } {\n-                                    if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n-                                        let msg = &format!(\n-                                            \"`{}=` can be used on '{}', you can dereference `{}`\",\n-                                            op.node.as_str(),\n-                                            rty.peel_refs(),\n-                                            lstring,\n-                                        );\n-                                        err.span_suggestion(\n-                                            lhs_expr.span,\n-                                            msg,\n-                                            format!(\"*{}\", lstring),\n-                                            rustc_errors::Applicability::MachineApplicable,\n-                                        );\n-                                        suggested_deref = true;\n-                                    }\n-                                }\n-                            }\n-                            let missing_trait = match op.node {\n-                                hir::BinOpKind::Add => Some(\"std::ops::AddAssign\"),\n-                                hir::BinOpKind::Sub => Some(\"std::ops::SubAssign\"),\n-                                hir::BinOpKind::Mul => Some(\"std::ops::MulAssign\"),\n-                                hir::BinOpKind::Div => Some(\"std::ops::DivAssign\"),\n-                                hir::BinOpKind::Rem => Some(\"std::ops::RemAssign\"),\n-                                hir::BinOpKind::BitAnd => Some(\"std::ops::BitAndAssign\"),\n-                                hir::BinOpKind::BitXor => Some(\"std::ops::BitXorAssign\"),\n-                                hir::BinOpKind::BitOr => Some(\"std::ops::BitOrAssign\"),\n-                                hir::BinOpKind::Shl => Some(\"std::ops::ShlAssign\"),\n-                                hir::BinOpKind::Shr => Some(\"std::ops::ShrAssign\"),\n-                                _ => None,\n-                            };\n-                            if let Some(missing_trait) = missing_trait {\n-                                if op.node == hir::BinOpKind::Add\n-                                    && self.check_str_addition(\n-                                        lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, true, op,\n-                                    )\n-                                {\n-                                    // This has nothing here because it means we did string\n-                                    // concatenation (e.g., \"Hello \" += \"World!\"). This means\n-                                    // we don't want the note in the else clause to be emitted\n-                                } else if let ty::Param(p) = lhs_ty.kind {\n-                                    suggest_constraining_param(\n-                                        self.tcx,\n-                                        self.body_id,\n-                                        &mut err,\n-                                        lhs_ty,\n-                                        rhs_ty,\n-                                        missing_trait,\n-                                        p,\n-                                        false,\n-                                    );\n-                                } else if !suggested_deref {\n-                                    suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n-                                }\n-                            }\n-                            err.emit();\n                         }\n-                        IsAssign::No => {\n-                            let (message, missing_trait, use_output) = match op.node {\n-                                hir::BinOpKind::Add => (\n-                                    format!(\"cannot add `{}` to `{}`\", rhs_ty, lhs_ty),\n-                                    Some(\"std::ops::Add\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Sub => (\n-                                    format!(\"cannot subtract `{}` from `{}`\", rhs_ty, lhs_ty),\n-                                    Some(\"std::ops::Sub\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Mul => (\n-                                    format!(\"cannot multiply `{}` to `{}`\", rhs_ty, lhs_ty),\n-                                    Some(\"std::ops::Mul\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Div => (\n-                                    format!(\"cannot divide `{}` by `{}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::Div\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Rem => (\n-                                    format!(\"cannot mod `{}` by `{}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::Rem\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::BitAnd => (\n-                                    format!(\"no implementation for `{} & {}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::BitAnd\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::BitXor => (\n-                                    format!(\"no implementation for `{} ^ {}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::BitXor\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::BitOr => (\n-                                    format!(\"no implementation for `{} | {}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::BitOr\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Shl => (\n-                                    format!(\"no implementation for `{} << {}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::Shl\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Shr => (\n-                                    format!(\"no implementation for `{} >> {}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::Shr\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Eq | hir::BinOpKind::Ne => (\n-                                    format!(\n-                                        \"binary operation `{}` cannot be applied to type `{}`\",\n-                                        op.node.as_str(),\n-                                        lhs_ty\n-                                    ),\n-                                    Some(\"std::cmp::PartialEq\"),\n-                                    false,\n-                                ),\n-                                hir::BinOpKind::Lt\n-                                | hir::BinOpKind::Le\n-                                | hir::BinOpKind::Gt\n-                                | hir::BinOpKind::Ge => (\n-                                    format!(\n-                                        \"binary operation `{}` cannot be applied to type `{}`\",\n-                                        op.node.as_str(),\n-                                        lhs_ty\n-                                    ),\n-                                    Some(\"std::cmp::PartialOrd\"),\n-                                    false,\n-                                ),\n-                                _ => (\n-                                    format!(\n-                                        \"binary operation `{}` cannot be applied to type `{}`\",\n-                                        op.node.as_str(),\n-                                        lhs_ty\n-                                    ),\n-                                    None,\n-                                    false,\n-                                ),\n-                            };\n-                            let mut err = struct_span_err!(\n-                                self.tcx.sess,\n-                                op.span,\n-                                E0369,\n-                                \"{}\",\n-                                message.as_str()\n+                        (err, missing_trait, use_output, involves_fn)\n+                    }\n+                };\n+                let mut suggested_deref = false;\n+                if let Ref(_, rty, _) = lhs_ty.kind {\n+                    if {\n+                        self.infcx.type_is_copy_modulo_regions(self.param_env, rty, lhs_expr.span)\n+                            && self\n+                                .lookup_op_method(rty, &[rhs_ty], Op::Binary(op, is_assign))\n+                                .is_ok()\n+                    } {\n+                        if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n+                            let msg = &format!(\n+                                \"`{}{}` can be used on `{}`, you can dereference `{}`\",\n+                                op.node.as_str(),\n+                                match is_assign {\n+                                    IsAssign::Yes => \"=\",\n+                                    IsAssign::No => \"\",\n+                                },\n+                                rty.peel_refs(),\n+                                lstring,\n                             );\n-\n-                            let mut involves_fn = false;\n-                            if !lhs_expr.span.eq(&rhs_expr.span) {\n-                                involves_fn |= self.add_type_neq_err_label(\n-                                    &mut err,\n-                                    lhs_expr.span,\n-                                    lhs_ty,\n-                                    rhs_ty,\n-                                    op,\n-                                    is_assign,\n-                                );\n-                                involves_fn |= self.add_type_neq_err_label(\n+                            err.span_suggestion_verbose(\n+                                lhs_expr.span.shrink_to_lo(),\n+                                msg,\n+                                \"*\".to_string(),\n+                                rustc_errors::Applicability::MachineApplicable,\n+                            );\n+                            suggested_deref = true;\n+                        }\n+                    }\n+                }\n+                if let Some(missing_trait) = missing_trait {\n+                    let mut visitor = TypeParamVisitor(vec![]);\n+                    visitor.visit_ty(lhs_ty);\n+\n+                    if op.node == hir::BinOpKind::Add\n+                        && self.check_str_addition(\n+                            lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, is_assign, op,\n+                        )\n+                    {\n+                        // This has nothing here because it means we did string\n+                        // concatenation (e.g., \"Hello \" + \"World!\"). This means\n+                        // we don't want the note in the else clause to be emitted\n+                    } else if let [ty] = &visitor.0[..] {\n+                        if let ty::Param(p) = ty.kind {\n+                            // Check if the method would be found if the type param wasn't\n+                            // involved. If so, it means that adding a trait bound to the param is\n+                            // enough. Otherwise we do not give the suggestion.\n+                            let mut eraser = TypeParamEraser(&self, expr.span);\n+                            let needs_bound = self\n+                                .lookup_op_method(\n+                                    eraser.fold_ty(lhs_ty),\n+                                    &[eraser.fold_ty(rhs_ty)],\n+                                    Op::Binary(op, is_assign),\n+                                )\n+                                .is_ok();\n+                            if needs_bound {\n+                                suggest_constraining_param(\n+                                    self.tcx,\n+                                    self.body_id,\n                                     &mut err,\n-                                    rhs_expr.span,\n+                                    ty,\n                                     rhs_ty,\n-                                    lhs_ty,\n-                                    op,\n-                                    is_assign,\n+                                    missing_trait,\n+                                    p,\n+                                    use_output,\n                                 );\n+                            } else if *ty != lhs_ty {\n+                                // When we know that a missing bound is responsible, we don't show\n+                                // this note as it is redundant.\n+                                err.note(&format!(\n+                                    \"the trait `{}` is not implemented for `{}`\",\n+                                    missing_trait, lhs_ty\n+                                ));\n                             }\n-\n-                            let mut suggested_deref = false;\n-                            if let Ref(_, rty, _) = lhs_ty.kind {\n-                                if {\n-                                    self.infcx.type_is_copy_modulo_regions(\n-                                        self.param_env,\n-                                        rty,\n-                                        lhs_expr.span,\n-                                    ) && self\n-                                        .lookup_op_method(rty, &[rhs_ty], Op::Binary(op, is_assign))\n-                                        .is_ok()\n-                                } {\n-                                    if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n-                                        err.help(&format!(\n-                                            \"`{}` can be used on '{}', you can \\\n-                                            dereference `{2}`: `*{2}`\",\n-                                            op.node.as_str(),\n-                                            rty.peel_refs(),\n-                                            lstring\n-                                        ));\n-                                        suggested_deref = true;\n-                                    }\n-                                }\n-                            }\n-                            if let Some(missing_trait) = missing_trait {\n-                                if op.node == hir::BinOpKind::Add\n-                                    && self.check_str_addition(\n-                                        lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, false, op,\n-                                    )\n-                                {\n-                                    // This has nothing here because it means we did string\n-                                    // concatenation (e.g., \"Hello \" + \"World!\"). This means\n-                                    // we don't want the note in the else clause to be emitted\n-                                } else if let ty::Param(p) = lhs_ty.kind {\n-                                    suggest_constraining_param(\n-                                        self.tcx,\n-                                        self.body_id,\n-                                        &mut err,\n-                                        lhs_ty,\n-                                        rhs_ty,\n-                                        missing_trait,\n-                                        p,\n-                                        use_output,\n-                                    );\n-                                } else if !suggested_deref && !involves_fn {\n-                                    suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n-                                }\n-                            }\n-                            err.emit();\n+                        } else {\n+                            bug!(\"type param visitor stored a non type param: {:?}\", ty.kind);\n                         }\n+                    } else if !suggested_deref && !involves_fn {\n+                        suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n                     }\n                 }\n+                err.emit();\n                 self.tcx.ty_error()\n             }\n         };\n@@ -570,7 +548,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         lhs_ty: Ty<'tcx>,\n         rhs_ty: Ty<'tcx>,\n         err: &mut rustc_errors::DiagnosticBuilder<'_>,\n-        is_assign: bool,\n+        is_assign: IsAssign,\n         op: hir::BinOp,\n     ) -> bool {\n         let source_map = self.tcx.sess.source_map();\n@@ -593,7 +571,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         &format!(\"{:?}\", rhs_ty) == \"&&str\"\n                     ) =>\n             {\n-                if !is_assign { // Do not supply this message if `&str += &str`\n+                if let IsAssign::No = is_assign { // Do not supply this message if `&str += &str`\n                     err.span_label(\n                         op.span,\n                         \"`+` cannot be used to concatenate two `&str` strings\",\n@@ -634,7 +612,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     source_map.span_to_snippet(rhs_expr.span),\n                     is_assign,\n                 ) {\n-                    (Ok(l), Ok(r), false) => {\n+                    (Ok(l), Ok(r), IsAssign::No) => {\n                         let to_string = if l.starts_with('&') {\n                             // let a = String::new(); let b = String::new();\n                             // let _ = &a + b;\n@@ -686,11 +664,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                     err.span_label(\n                         ex.span,\n-                        format!(\n-                            \"cannot apply unary \\\n-                                                    operator `{}`\",\n-                            op.as_str()\n-                        ),\n+                        format!(\"cannot apply unary operator `{}`\", op.as_str()),\n                     );\n                     match actual.kind {\n                         Uint(_) if op == hir::UnOp::UnNeg => {\n@@ -928,8 +902,7 @@ fn suggest_impl_missing(err: &mut DiagnosticBuilder<'_>, ty: Ty<'_>, missing_tra\n     if let Adt(def, _) = ty.peel_refs().kind {\n         if def.did.is_local() {\n             err.note(&format!(\n-                \"an implementation of `{}` might \\\n-                be missing for `{}`\",\n+                \"an implementation of `{}` might be missing for `{}`\",\n                 missing_trait, ty\n             ));\n         }\n@@ -975,3 +948,32 @@ fn suggest_constraining_param(\n         err.span_label(span, msg);\n     }\n }\n+\n+struct TypeParamVisitor<'tcx>(Vec<Ty<'tcx>>);\n+\n+impl<'tcx> TypeVisitor<'tcx> for TypeParamVisitor<'tcx> {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        if let ty::Param(_) = ty.kind {\n+            self.0.push(ty);\n+        }\n+        ty.super_visit_with(self)\n+    }\n+}\n+\n+struct TypeParamEraser<'a, 'tcx>(&'a FnCtxt<'a, 'tcx>, Span);\n+\n+impl TypeFolder<'tcx> for TypeParamEraser<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.0.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match ty.kind {\n+            ty::Param(_) => self.0.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::MiscVariable,\n+                span: self.1,\n+            }),\n+            _ => ty.super_fold_with(self),\n+        }\n+    }\n+}"}, {"sha": "f987eb67ea5f29b52f69d6bbd4cb55d6ddc63919", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 121, "deletions": 7, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -913,10 +913,28 @@ mod match_keyword {}\n //\n /// Organize code into [modules].\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// Use `mod` to create new [modules] to encapsulate code, including other\n+/// modules:\n+///\n+/// ```\n+/// mod foo {\n+///     mod bar {\n+///         type MyType = (u8, u8);\n+///         fn baz() {}\n+///     }\n+/// }\n+/// ```\n+///\n+/// Like [`struct`]s and [`enum`]s, a module and its content are private by\n+/// default, unaccessible to code outside of the module.\n ///\n+/// To learn more about allowing access, see the documentation for the [`pub`]\n+/// keyword.\n+///\n+/// [`enum`]: keyword.enum.html\n+/// [`pub`]: keyword.pub.html\n+/// [`struct`]: keyword.struct.html\n /// [modules]: ../reference/items/modules.html\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n mod mod_keyword {}\n \n #[doc(keyword = \"move\")]\n@@ -965,11 +983,61 @@ mod move_keyword {}\n \n #[doc(keyword = \"mut\")]\n //\n-/// A mutable binding, reference, or pointer.\n+/// A mutable variable, reference, or pointer.\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// `mut` can be used in several situations. The first is mutable variables,\n+/// which can be used anywhere you can bind a value to a variable name. Some\n+/// examples:\n ///\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+/// ```rust\n+/// // A mutable variable in the parameter list of a function.\n+/// fn foo(mut x: u8, y: u8) -> u8 {\n+///     x += y;\n+///     x\n+/// }\n+///\n+/// // Modifying a mutable variable.\n+/// # #[allow(unused_assignments)]\n+/// let mut a = 5;\n+/// a = 6;\n+///\n+/// assert_eq!(foo(3, 4), 7);\n+/// assert_eq!(a, 6);\n+/// ```\n+///\n+/// The second is mutable references. They can be created from `mut` variables\n+/// and must be unique: no other variables can have a mutable reference, nor a\n+/// shared reference.\n+///\n+/// ```rust\n+/// // Taking a mutable reference.\n+/// fn push_two(v: &mut Vec<u8>) {\n+///     v.push(2);\n+/// }\n+///\n+/// // A mutable reference cannot be taken to a non-mutable variable.\n+/// let mut v = vec![0, 1];\n+/// // Passing a mutable reference.\n+/// push_two(&mut v);\n+///\n+/// assert_eq!(v, vec![0, 1, 2]);\n+/// ```\n+///\n+/// ```rust,compile_fail,E0502\n+/// let mut v = vec![0, 1];\n+/// let mut_ref_v = &mut v;\n+/// ##[allow(unused)]\n+/// let ref_v = &v;\n+/// mut_ref_v.push(2);\n+/// ```\n+///\n+/// Mutable raw pointers work much like mutable references, with the added\n+/// possibility of not pointing to a valid object. The syntax is `*mut Type`.\n+///\n+/// More information on mutable references and pointers can be found in```\n+/// [Reference].\n+///\n+/// [Reference]: ../reference/types/pointer.html#mutable-references-mut\n mod mut_keyword {}\n \n #[doc(keyword = \"pub\")]\n@@ -1000,9 +1068,55 @@ mod ref_keyword {}\n //\n /// Return a value from a function.\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// A `return` marks the end of an execution path in a function:\n ///\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+/// ```\n+/// fn foo() -> i32 {\n+///     return 3;\n+/// }\n+/// assert_eq!(foo(), 3);\n+/// ```\n+///\n+/// `return` is not needed when the returned value is the last expression in the\n+/// function. In this case the `;` is omitted:\n+///\n+/// ```\n+/// fn foo() -> i32 {\n+///     3\n+/// }\n+/// assert_eq!(foo(), 3);\n+/// ```\n+///\n+/// `return` returns from the function immediately (an \"early return\"):\n+///\n+/// ```no_run\n+/// use std::fs::File;\n+/// use std::io::{Error, ErrorKind, Read, Result};\n+///\n+/// fn main() -> Result<()> {\n+///     let mut file = match File::open(\"foo.txt\") {\n+///         Ok(f) => f,\n+///         Err(e) => return Err(e),\n+///     };\n+///\n+///     let mut contents = String::new();\n+///     let size = match file.read_to_string(&mut contents) {\n+///         Ok(s) => s,\n+///         Err(e) => return Err(e),\n+///     };\n+///\n+///     if contents.contains(\"impossible!\") {\n+///         return Err(Error::new(ErrorKind::Other, \"oh no!\"));\n+///     }\n+///\n+///     if size > 9000 {\n+///         return Err(Error::new(ErrorKind::Other, \"over 9000!\"));\n+///     }\n+///\n+///     assert_eq!(contents, \"Hello, world!\");\n+///     Ok(())\n+/// }\n+/// ```\n mod return_keyword {}\n \n #[doc(keyword = \"self\")]"}, {"sha": "97d62d958ca4f873462378bac4a8d7b0ec3add64", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 60, "deletions": 13, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -170,7 +170,7 @@ pub fn take_hook() -> Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send> {\n fn default_hook(info: &PanicInfo<'_>) {\n     // If this is a double panic, make sure that we print a backtrace\n     // for this panic. Otherwise only print it if logging is enabled.\n-    let backtrace_env = if update_panic_count(0) >= 2 {\n+    let backtrace_env = if panic_count::get() >= 2 {\n         RustBacktrace::Print(backtrace_rs::PrintFmt::Full)\n     } else {\n         backtrace::rust_backtrace_env()\n@@ -221,19 +221,65 @@ fn default_hook(info: &PanicInfo<'_>) {\n #[cfg(not(test))]\n #[doc(hidden)]\n #[unstable(feature = \"update_panic_count\", issue = \"none\")]\n-pub fn update_panic_count(amt: isize) -> usize {\n+pub mod panic_count {\n     use crate::cell::Cell;\n-    thread_local! { static PANIC_COUNT: Cell<usize> = Cell::new(0) }\n+    use crate::sync::atomic::{AtomicUsize, Ordering};\n+\n+    // Panic count for the current thread.\n+    thread_local! { static LOCAL_PANIC_COUNT: Cell<usize> = Cell::new(0) }\n+\n+    // Sum of panic counts from all threads. The purpose of this is to have\n+    // a fast path in `is_zero` (which is used by `panicking`). Access to\n+    // this variable can be always be done with relaxed ordering because\n+    // it is always guaranteed that, if `GLOBAL_PANIC_COUNT` is zero,\n+    // `LOCAL_PANIC_COUNT` will be zero.\n+    static GLOBAL_PANIC_COUNT: AtomicUsize = AtomicUsize::new(0);\n+\n+    pub fn increase() -> usize {\n+        GLOBAL_PANIC_COUNT.fetch_add(1, Ordering::Relaxed);\n+        LOCAL_PANIC_COUNT.with(|c| {\n+            let next = c.get() + 1;\n+            c.set(next);\n+            next\n+        })\n+    }\n+\n+    pub fn decrease() -> usize {\n+        GLOBAL_PANIC_COUNT.fetch_sub(1, Ordering::Relaxed);\n+        LOCAL_PANIC_COUNT.with(|c| {\n+            let next = c.get() - 1;\n+            c.set(next);\n+            next\n+        })\n+    }\n \n-    PANIC_COUNT.with(|c| {\n-        let next = (c.get() as isize + amt) as usize;\n-        c.set(next);\n-        next\n-    })\n+    pub fn get() -> usize {\n+        LOCAL_PANIC_COUNT.with(|c| c.get())\n+    }\n+\n+    #[inline]\n+    pub fn is_zero() -> bool {\n+        if GLOBAL_PANIC_COUNT.load(Ordering::Relaxed) == 0 {\n+            // Fast path: if `GLOBAL_PANIC_COUNT` is zero, all threads\n+            // (including the current one) will have `LOCAL_PANIC_COUNT`\n+            // equal to zero, so TLS access can be avoided.\n+            true\n+        } else {\n+            is_zero_slow_path()\n+        }\n+    }\n+\n+    // Slow path is in a separate function to reduce the amount of code\n+    // inlined from `is_zero`.\n+    #[inline(never)]\n+    #[cold]\n+    fn is_zero_slow_path() -> bool {\n+        LOCAL_PANIC_COUNT.with(|c| c.get() == 0)\n+    }\n }\n \n #[cfg(test)]\n-pub use realstd::rt::update_panic_count;\n+pub use realstd::rt::panic_count;\n \n /// Invoke a closure, capturing the cause of an unwinding panic if one occurs.\n pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>> {\n@@ -283,7 +329,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     #[cold]\n     unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send + 'static> {\n         let obj = Box::from_raw(__rust_panic_cleanup(payload));\n-        update_panic_count(-1);\n+        panic_count::decrease();\n         obj\n     }\n \n@@ -312,8 +358,9 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n }\n \n /// Determines whether the current thread is unwinding because of panic.\n+#[inline]\n pub fn panicking() -> bool {\n-    update_panic_count(0) != 0\n+    !panic_count::is_zero()\n }\n \n /// The entry point for panicking with a formatted message.\n@@ -445,7 +492,7 @@ fn rust_panic_with_hook(\n     message: Option<&fmt::Arguments<'_>>,\n     location: &Location<'_>,\n ) -> ! {\n-    let panics = update_panic_count(1);\n+    let panics = panic_count::increase();\n \n     // If this is the third nested call (e.g., panics == 2, this is 0-indexed),\n     // the panic hook probably triggered the last panic, otherwise the\n@@ -495,7 +542,7 @@ fn rust_panic_with_hook(\n /// This is the entry point for `resume_unwind`.\n /// It just forwards the payload to the panic runtime.\n pub fn rust_panic_without_hook(payload: Box<dyn Any + Send>) -> ! {\n-    update_panic_count(1);\n+    panic_count::increase();\n \n     struct RewrapBox(Box<dyn Any + Send>);\n "}, {"sha": "fb825ab16ebd7ef8d1dc114bd8d0a36b86a461fe", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -15,7 +15,7 @@\n #![doc(hidden)]\n \n // Re-export some of our utilities which are expected by other crates.\n-pub use crate::panicking::{begin_panic, begin_panic_fmt, update_panic_count};\n+pub use crate::panicking::{begin_panic, begin_panic_fmt, panic_count};\n \n // To reduce the generated code of the new `lang_start`, this function is doing\n // the real work."}, {"sha": "4e145b81ecbf73c5ad8bbf33a66064ee328ed034", "filename": "src/test/codegen/async-fn-debug-msvc.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,48 @@\n+// Verify debuginfo for generators:\n+//  - Each variant points to the file and line of its yield point\n+//  - The generator types and variants are marked artificial\n+//  - Captured vars from the source are not marked artificial\n+//\n+// ignore-tidy-linelength\n+// compile-flags: -C debuginfo=2 --edition=2018\n+// only-msvc\n+\n+async fn foo() {}\n+async fn async_fn_test() {\n+    foo().await;\n+    let s = String::from(\"foo\");\n+    foo().await;\n+}\n+\n+// FIXME: No way to reliably check the filename.\n+\n+// CHECK-DAG:  [[ASYNC_FN:!.*]] = !DINamespace(name: \"async_fn_test\"\n+// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"generator-0\", scope: [[ASYNC_FN]], {{.*}}flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// For brevity, we only check the struct name and members of the last variant.\n+// CHECK-SAME: file: [[FILE:![0-9]*]], line: 11,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK-SAME: file: [[FILE]], line: 15,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK-SAME: file: [[FILE]], line: 15,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK-SAME: file: [[FILE]], line: 12,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK-SAME: file: [[FILE]], line: 14,\n+// CHECK-SAME: baseType: [[VARIANT:![0-9]*]]\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      [[S1:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[ASYNC_FN]],\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"RUST$ENUM$DISR\", scope: [[S1]],\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[S1]]\n+// CHECK-NOT:  flags: DIFlagArtificial\n+// CHECK-SAME: )\n+\n+fn main() {\n+    let _dummy = async_fn_test();\n+}"}, {"sha": "8fa4be1ae86d8dc81850ea3ee2853150ca12b0be", "filename": "src/test/codegen/async-fn-debug.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fcodegen%2Fasync-fn-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fcodegen%2Fasync-fn-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasync-fn-debug.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,51 @@\n+// Verify debuginfo for async fn:\n+//  - Each variant points to the file and line of its yield point\n+//  - The generator types and variants are marked artificial\n+//  - Captured vars from the source are not marked artificial\n+//\n+// ignore-tidy-linelength\n+// compile-flags: -C debuginfo=2 --edition=2018\n+// ignore-msvc\n+\n+async fn foo() {}\n+async fn async_fn_test() {\n+    foo().await;\n+    let s = String::from(\"foo\");\n+    foo().await;\n+}\n+\n+// FIXME: No way to reliably check the filename.\n+\n+// CHECK-DAG:  [[ASYNC_FN:!.*]] = !DINamespace(name: \"async_fn_test\"\n+// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"generator-0\", scope: [[ASYNC_FN]], {{.*}}flags: DIFlagArtificial\n+// CHECK:      [[VARIANT:!.*]] = !DICompositeType(tag: DW_TAG_variant_part, scope: [[ASYNC_FN]],\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK-SAME: discriminator: [[DISC:![0-9]*]]\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"0\", scope: [[VARIANT]],\n+// CHECK-SAME: file: [[FILE:![0-9]*]], line: 11,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DICompositeType(tag: DW_TAG_structure_type, name: \"Unresumed\", scope: [[GEN]],\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"1\", scope: [[VARIANT]],\n+// CHECK-SAME: file: [[FILE]], line: 15,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"2\", scope: [[VARIANT]],\n+// CHECK-SAME: file: [[FILE]], line: 15,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"3\", scope: [[VARIANT]],\n+// CHECK-SAME: file: [[FILE]], line: 12,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"4\", scope: [[VARIANT]],\n+// CHECK-SAME: file: [[FILE]], line: 14,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      [[S1:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[GEN]],\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[S1]]\n+// CHECK-NOT:  flags: DIFlagArtificial\n+// CHECK-SAME: )\n+// CHECK:      [[DISC]] = !DIDerivedType(tag: DW_TAG_member, name: \"__state\", scope: [[ASYNC_FN]],\n+// CHECK-SAME: flags: DIFlagArtificial\n+\n+fn main() {\n+    let _dummy = async_fn_test();\n+}"}, {"sha": "82a1568ea95849deb6cb1958c3d72e42f74223af", "filename": "src/test/codegen/generator-debug-msvc.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fcodegen%2Fgenerator-debug-msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fcodegen%2Fgenerator-debug-msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fgenerator-debug-msvc.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,52 @@\n+// Verify debuginfo for generators:\n+//  - Each variant points to the file and line of its yield point\n+//  - The generator types and variants are marked artificial\n+//  - Captured vars from the source are not marked artificial\n+//\n+// ignore-tidy-linelength\n+// compile-flags: -C debuginfo=2\n+// only-msvc\n+\n+#![feature(generators, generator_trait)]\n+use std::ops::Generator;\n+\n+fn generator_test() -> impl Generator<Yield = i32, Return = ()> {\n+    || {\n+        yield 0;\n+        let s = String::from(\"foo\");\n+        yield 1;\n+    }\n+}\n+\n+// FIXME: No way to reliably check the filename.\n+\n+// CHECK-DAG:  [[GEN_FN:!.*]] = !DINamespace(name: \"generator_test\"\n+// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"generator-0\", scope: [[GEN_FN]], {{.*}}flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// For brevity, we only check the struct name and members of the last variant.\n+// CHECK-SAME: file: [[FILE:![0-9]*]], line: 14,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK-SAME: file: [[FILE]], line: 18,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK-SAME: file: [[FILE]], line: 18,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK-SAME: file: [[FILE]], line: 15,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK-SAME: file: [[FILE]], line: 17,\n+// CHECK-SAME: baseType: [[VARIANT:![0-9]*]]\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      [[S1:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[GEN_FN]],\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"RUST$ENUM$DISR\", scope: [[S1]],\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[S1]]\n+// CHECK-NOT:  flags: DIFlagArtificial\n+// CHECK-SAME: )\n+\n+fn main() {\n+    let _dummy = generator_test();\n+}"}, {"sha": "5c7c64148189a7ffa1f53f19463ed561d34524eb", "filename": "src/test/codegen/generator-debug.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fcodegen%2Fgenerator-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fcodegen%2Fgenerator-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fgenerator-debug.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,55 @@\n+// Verify debuginfo for generators:\n+//  - Each variant points to the file and line of its yield point\n+//  - The generator types and variants are marked artificial\n+//  - Captured vars from the source are not marked artificial\n+//\n+// ignore-tidy-linelength\n+// compile-flags: -C debuginfo=2 --edition=2018\n+// ignore-msvc\n+\n+#![feature(generators, generator_trait)]\n+use std::ops::Generator;\n+\n+fn generator_test() -> impl Generator<Yield = i32, Return = ()> {\n+    || {\n+        yield 0;\n+        let s = String::from(\"foo\");\n+        yield 1;\n+    }\n+}\n+\n+// FIXME: No way to reliably check the filename.\n+\n+// CHECK-DAG:  [[GEN_FN:!.*]] = !DINamespace(name: \"generator_test\"\n+// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"generator-0\", scope: [[GEN_FN]], {{.*}}flags: DIFlagArtificial\n+// CHECK:      [[VARIANT:!.*]] = !DICompositeType(tag: DW_TAG_variant_part, scope: [[GEN_FN]],\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK-SAME: discriminator: [[DISC:![0-9]*]]\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"0\", scope: [[VARIANT]],\n+// CHECK-SAME: file: [[FILE:![0-9]*]], line: 14,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DICompositeType(tag: DW_TAG_structure_type, name: \"Unresumed\", scope: [[GEN]],\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"1\", scope: [[VARIANT]],\n+// CHECK-SAME: file: [[FILE]], line: 18,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"2\", scope: [[VARIANT]],\n+// CHECK-SAME: file: [[FILE]], line: 18,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"3\", scope: [[VARIANT]],\n+// CHECK-SAME: file: [[FILE]], line: 15,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"4\", scope: [[VARIANT]],\n+// CHECK-SAME: file: [[FILE]], line: 17,\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      [[S1:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[GEN]],\n+// CHECK-SAME: flags: DIFlagArtificial\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[S1]]\n+// CHECK-NOT:  flags: DIFlagArtificial\n+// CHECK-SAME: )\n+// CHECK:      [[DISC]] = !DIDerivedType(tag: DW_TAG_member, name: \"__state\", scope: [[GEN_FN]],\n+// CHECK-SAME: flags: DIFlagArtificial\n+\n+fn main() {\n+    let _dummy = generator_test();\n+}"}, {"sha": "3c77995eea8931f5040eab4e5a14b575609c56d1", "filename": "src/test/mir-opt/generator-drop-cleanup/rustc.main-{{closure}}.generator_drop.0.mir", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup%2Frustc.main-%7B%7Bclosure%7D%7D.generator_drop.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup%2Frustc.main-%7B%7Bclosure%7D%7D.generator_drop.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup%2Frustc.main-%7B%7Bclosure%7D%7D.generator_drop.0.mir?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -1,5 +1,18 @@\n // MIR for `main::{{closure}}#0` 0 generator_drop\n-// generator_layout = GeneratorLayout { field_tys: [std::string::String], variant_fields: [[], [], [], [_0]], storage_conflicts: BitMatrix { num_rows: 1, num_columns: 1, words: [1], marker: PhantomData } }\n+/* generator_layout = GeneratorLayout {\n+    field_tys: {\n+        _0: std::string::String,\n+    },\n+    variant_fields: {\n+        Unresumed(0): [],\n+        Returned (1): [],\n+        Panicked (2): [],\n+        Suspend0 (3): [_0],\n+    },\n+    storage_conflicts: BitMatrix(1x1) {\n+        (_0, _0),\n+    },\n+} */\n \n fn main::{{closure}}#0(_1: *mut [generator@$DIR/generator-drop-cleanup.rs:10:15: 13:6 {std::string::String, ()}]) -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/generator-drop-cleanup.rs:10:15: 13:6"}, {"sha": "bd6db11a7e73e2e84213c422507d88d8d7b23d10", "filename": "src/test/mir-opt/generator-tiny/rustc.main-{{closure}}.generator_resume.0.mir", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fmir-opt%2Fgenerator-tiny%2Frustc.main-%7B%7Bclosure%7D%7D.generator_resume.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fmir-opt%2Fgenerator-tiny%2Frustc.main-%7B%7Bclosure%7D%7D.generator_resume.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator-tiny%2Frustc.main-%7B%7Bclosure%7D%7D.generator_resume.0.mir?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -1,5 +1,18 @@\n // MIR for `main::{{closure}}#0` 0 generator_resume\n-// generator_layout = GeneratorLayout { field_tys: [HasDrop], variant_fields: [[], [], [], [_0]], storage_conflicts: BitMatrix { num_rows: 1, num_columns: 1, words: [1], marker: PhantomData } }\n+/* generator_layout = GeneratorLayout {\n+    field_tys: {\n+        _0: HasDrop,\n+    },\n+    variant_fields: {\n+        Unresumed(0): [],\n+        Returned (1): [],\n+        Panicked (2): [],\n+        Suspend0 (3): [_0],\n+    },\n+    storage_conflicts: BitMatrix(1x1) {\n+        (_0, _0),\n+    },\n+} */\n \n fn main::{{closure}}#0(_1: std::pin::Pin<&mut [generator@$DIR/generator-tiny.rs:19:16: 25:6 {u8, HasDrop, ()}]>, _2: u8) -> std::ops::GeneratorState<(), ()> {\n     debug _x => _10;                     // in scope 0 at $DIR/generator-tiny.rs:19:17: 19:19"}, {"sha": "de9dc19af29beeb4b10fee7cfd4032fbb0cada71", "filename": "src/test/ui/binary-op-on-double-ref.fixed", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.fixed?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,9 @@\n+// run-rustfix\n+fn main() {\n+    let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let vr = v.iter().filter(|x| {\n+        *x % 2 == 0\n+        //~^ ERROR cannot mod `&&{integer}` by `{integer}`\n+    });\n+    println!(\"{:?}\", vr);\n+}"}, {"sha": "2616c560cbefb6c320808d9086976a0b65ac570e", "filename": "src/test/ui/binary-op-on-double-ref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n fn main() {\n     let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n     let vr = v.iter().filter(|x| {"}, {"sha": "02b0488488c555154537ef7829870465590c6071", "filename": "src/test/ui/binary-op-on-double-ref.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -1,12 +1,15 @@\n error[E0369]: cannot mod `&&{integer}` by `{integer}`\n-  --> $DIR/binary-op-on-double-ref.rs:4:11\n+  --> $DIR/binary-op-on-double-ref.rs:5:11\n    |\n LL |         x % 2 == 0\n    |         - ^ - {integer}\n    |         |\n    |         &&{integer}\n    |\n-   = help: `%` can be used on '{integer}', you can dereference `x`: `*x`\n+help: `%` can be used on `{integer}`, you can dereference `x`\n+   |\n+LL |         *x % 2 == 0\n+   |         ^\n \n error: aborting due to previous error\n "}, {"sha": "604143b4e7efd232c94267b0e8f410e22a6f7d22", "filename": "src/test/ui/borrowck/issue-41962.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -5,6 +5,10 @@ LL |         if let Some(thing) = maybe {\n    |                     ^^^^^ value moved here, in previous iteration of loop\n    |\n    = note: move occurs because value has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n+help: borrow this field in the pattern to avoid moving `maybe.0`\n+   |\n+LL |         if let Some(ref thing) = maybe {\n+   |                     ^^^\n \n error: aborting due to previous error\n "}, {"sha": "175eb3b7a04d1168237ec991cbbd658f9abfb48b", "filename": "src/test/ui/borrowck/move-in-pattern-mut.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,23 @@\n+// Issue #63988\n+#[derive(Debug)]\n+struct S;\n+fn foo(_: Option<S>) {}\n+\n+enum E {\n+    V {\n+        s: S,\n+    }\n+}\n+fn bar(_: E) {}\n+\n+fn main() {\n+    let s = Some(S);\n+    if let Some(mut x) = s {\n+        x = S;\n+    }\n+    foo(s); //~ ERROR use of moved value: `s`\n+    let mut e = E::V { s: S };\n+    let E::V { s: mut x } = e;\n+    x = S;\n+    bar(e); //~ ERROR use of moved value: `e`\n+}"}, {"sha": "391638444c3bdcf06791fddc991dcb2960801a5b", "filename": "src/test/ui/borrowck/move-in-pattern-mut.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,33 @@\n+error[E0382]: use of moved value: `s`\n+  --> $DIR/move-in-pattern-mut.rs:18:9\n+   |\n+LL |     if let Some(mut x) = s {\n+   |                 ----- value moved here\n+...\n+LL |     foo(s);\n+   |         ^ value used here after partial move\n+   |\n+   = note: move occurs because value has type `S`, which does not implement the `Copy` trait\n+help: borrow this field in the pattern to avoid moving `s.0`\n+   |\n+LL |     if let Some(ref mut x) = s {\n+   |                 ^^^\n+\n+error[E0382]: use of moved value: `e`\n+  --> $DIR/move-in-pattern-mut.rs:22:9\n+   |\n+LL |     let E::V { s: mut x } = e;\n+   |                   ----- value moved here\n+LL |     x = S;\n+LL |     bar(e);\n+   |         ^ value used here after partial move\n+   |\n+   = note: move occurs because value has type `S`, which does not implement the `Copy` trait\n+help: borrow this field in the pattern to avoid moving `e.s`\n+   |\n+LL |     let E::V { s: ref mut x } = e;\n+   |                   ^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "f55fdcc5f90e80f1dcca0613b180131d1af9b194", "filename": "src/test/ui/borrowck/move-in-pattern.fixed", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern.fixed?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,24 @@\n+// run-rustfix\n+// Issue #63988\n+#[derive(Debug)]\n+struct S;\n+fn foo(_: Option<S>) {}\n+\n+enum E {\n+    V {\n+        s: S,\n+    }\n+}\n+fn bar(_: E) {}\n+\n+fn main() {\n+    let s = Some(S);\n+    if let Some(ref x) = s {\n+        let _ = x;\n+    }\n+    foo(s); //~ ERROR use of moved value: `s`\n+    let e = E::V { s: S };\n+    let E::V { s: ref x } = e;\n+    let _ = x;\n+    bar(e); //~ ERROR use of moved value: `e`\n+}"}, {"sha": "7ad04b9490c25167f83569d050585933fa11b008", "filename": "src/test/ui/borrowck/move-in-pattern.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,24 @@\n+// run-rustfix\n+// Issue #63988\n+#[derive(Debug)]\n+struct S;\n+fn foo(_: Option<S>) {}\n+\n+enum E {\n+    V {\n+        s: S,\n+    }\n+}\n+fn bar(_: E) {}\n+\n+fn main() {\n+    let s = Some(S);\n+    if let Some(x) = s {\n+        let _ = x;\n+    }\n+    foo(s); //~ ERROR use of moved value: `s`\n+    let e = E::V { s: S };\n+    let E::V { s: x } = e;\n+    let _ = x;\n+    bar(e); //~ ERROR use of moved value: `e`\n+}"}, {"sha": "c5cb24455eb61ee5c83fd7b05b6c904a21073eaa", "filename": "src/test/ui/borrowck/move-in-pattern.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,33 @@\n+error[E0382]: use of moved value: `s`\n+  --> $DIR/move-in-pattern.rs:19:9\n+   |\n+LL |     if let Some(x) = s {\n+   |                 - value moved here\n+...\n+LL |     foo(s);\n+   |         ^ value used here after partial move\n+   |\n+   = note: move occurs because value has type `S`, which does not implement the `Copy` trait\n+help: borrow this field in the pattern to avoid moving `s.0`\n+   |\n+LL |     if let Some(ref x) = s {\n+   |                 ^^^\n+\n+error[E0382]: use of moved value: `e`\n+  --> $DIR/move-in-pattern.rs:23:9\n+   |\n+LL |     let E::V { s: x } = e;\n+   |                   - value moved here\n+LL |     let _ = x;\n+LL |     bar(e);\n+   |         ^ value used here after partial move\n+   |\n+   = note: move occurs because value has type `S`, which does not implement the `Copy` trait\n+help: borrow this field in the pattern to avoid moving `e.s`\n+   |\n+LL |     let E::V { s: ref x } = e;\n+   |                   ^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "ceeba30a90f2939716a726279fca7e7490bfecc2", "filename": "src/test/ui/borrowck/mut-borrow-in-loop-2.fixed", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop-2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop-2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop-2.fixed?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,35 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+struct Events<R>(R);\n+\n+struct Other;\n+\n+pub trait Trait<T> {\n+    fn handle(value: T) -> Self;\n+}\n+\n+// Blanket impl. (If you comment this out, compiler figures out that it\n+// is passing an `&mut` to a method that must be expecting an `&mut`,\n+// and injects an auto-reborrow.)\n+impl<T, U> Trait<U> for T where T: From<U> {\n+    fn handle(_: U) -> Self { unimplemented!() }\n+}\n+\n+impl<'a, R> Trait<&'a mut Events<R>> for Other {\n+    fn handle(_: &'a mut Events<R>) -> Self { unimplemented!() }\n+}\n+\n+fn this_compiles<'a, R>(value: &'a mut Events<R>) {\n+    for _ in 0..3 {\n+        Other::handle(&mut *value);\n+    }\n+}\n+\n+fn this_does_not<'a, R>(value: &'a mut Events<R>) {\n+    for _ in 0..3 {\n+        Other::handle(&mut *value); //~ ERROR use of moved value: `value`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d13fb7e5679395b53d8b0d136c68a5e3c8dfb625", "filename": "src/test/ui/borrowck/mut-borrow-in-loop-2.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop-2.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,35 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+struct Events<R>(R);\n+\n+struct Other;\n+\n+pub trait Trait<T> {\n+    fn handle(value: T) -> Self;\n+}\n+\n+// Blanket impl. (If you comment this out, compiler figures out that it\n+// is passing an `&mut` to a method that must be expecting an `&mut`,\n+// and injects an auto-reborrow.)\n+impl<T, U> Trait<U> for T where T: From<U> {\n+    fn handle(_: U) -> Self { unimplemented!() }\n+}\n+\n+impl<'a, R> Trait<&'a mut Events<R>> for Other {\n+    fn handle(_: &'a mut Events<R>) -> Self { unimplemented!() }\n+}\n+\n+fn this_compiles<'a, R>(value: &'a mut Events<R>) {\n+    for _ in 0..3 {\n+        Other::handle(&mut *value);\n+    }\n+}\n+\n+fn this_does_not<'a, R>(value: &'a mut Events<R>) {\n+    for _ in 0..3 {\n+        Other::handle(value); //~ ERROR use of moved value: `value`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "fa1b741394acb55b1a2fff931bcf2506698e7496", "filename": "src/test/ui/borrowck/mut-borrow-in-loop-2.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop-2.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,17 @@\n+error[E0382]: use of moved value: `value`\n+  --> $DIR/mut-borrow-in-loop-2.rs:31:23\n+   |\n+LL | fn this_does_not<'a, R>(value: &'a mut Events<R>) {\n+   |                         ----- move occurs because `value` has type `&mut Events<R>`, which does not implement the `Copy` trait\n+LL |     for _ in 0..3 {\n+LL |         Other::handle(value);\n+   |                       ^^^^^ value moved here, in previous iteration of loop\n+   |\n+help: consider creating a fresh reborrow of `value` here\n+   |\n+LL |         Other::handle(&mut *value);\n+   |                       ^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "455419d2c7f1d4a1b7e55a758a2967e2ab641986", "filename": "src/test/ui/consts/const-variant-count.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fconsts%2Fconst-variant-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fconsts%2Fconst-variant-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-variant-count.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,47 @@\n+// run-pass\n+#![allow(dead_code)]\n+#![feature(variant_count)]\n+#![feature(never_type)]\n+\n+use std::mem::variant_count;\n+\n+enum Void {}\n+\n+enum Foo {\n+    A,\n+    B,\n+    C,\n+}\n+\n+enum Bar {\n+    A,\n+    B,\n+    C,\n+    D(usize),\n+    E { field_1: usize, field_2: Foo },\n+}\n+\n+struct Baz {\n+    a: u32,\n+    b: *const u8,\n+}\n+\n+const TEST_VOID: usize = variant_count::<Void>();\n+const TEST_FOO: usize = variant_count::<Foo>();\n+const TEST_BAR: usize = variant_count::<Bar>();\n+\n+const NO_ICE_STRUCT: usize = variant_count::<Baz>();\n+const NO_ICE_BOOL: usize = variant_count::<bool>();\n+const NO_ICE_PRIM: usize = variant_count::<*const u8>();\n+\n+fn main() {\n+    assert_eq!(TEST_VOID, 0);\n+    assert_eq!(TEST_FOO, 3);\n+    assert_eq!(TEST_BAR, 5);\n+    assert_eq!(variant_count::<Void>(), 0);\n+    assert_eq!(variant_count::<Foo>(), 3);\n+    assert_eq!(variant_count::<Bar>(), 5);\n+    assert_eq!(variant_count::<Option<char>>(), 2);\n+    assert_eq!(variant_count::<Option<!>>(), 2);\n+    assert_eq!(variant_count::<Result<!, !>>(), 2);\n+}"}, {"sha": "600cacc23aef5d1f24a51fba65c278f40722c621", "filename": "src/test/ui/issues/issue-35668.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -5,6 +5,11 @@ LL |     a.iter().map(|a| a*a)\n    |                      -^- &T\n    |                      |\n    |                      &T\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn func<'a, T: std::ops::Mul<Output = &T>>(a: &'a [T]) -> impl Iterator<Item=&'a T> {\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "078a7ef2173bd349961bca1d9f8ff5eca58e788e", "filename": "src/test/ui/issues/issue-5239-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -6,10 +6,10 @@ LL |     let x = |ref x: isize| { x += 1; };\n    |                              |\n    |                              cannot use `+=` on type `&isize`\n    |\n-help: `+=` can be used on 'isize', you can dereference `x`\n+help: `+=` can be used on `isize`, you can dereference `x`\n    |\n LL |     let x = |ref x: isize| { *x += 1; };\n-   |                              ^^\n+   |                              ^\n \n error: aborting due to previous error\n "}, {"sha": "e15ed2e70b896fa2b497e2c0cdef2ef34dd7889d", "filename": "src/test/ui/lint/rfc-2457-non-ascii-idents/lint-confusable-idents.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-confusable-idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-confusable-idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-confusable-idents.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -2,8 +2,14 @@\n #![deny(confusable_idents)]\n #![allow(uncommon_codepoints, non_upper_case_globals)]\n \n-const \uff53: usize = 42; //~ ERROR identifier pair considered confusable\n+const \uff53: usize = 42;\n \n fn main() {\n-    let s = \"rust\";\n+    let s = \"rust\"; //~ ERROR identifier pair considered confusable\n+    not_affected();\n+}\n+\n+fn not_affected() {\n+    let s1 = 1;\n+    let sl = 'l';\n }"}, {"sha": "218f94f7b5829483beb10155f6a0fbc223693043", "filename": "src/test/ui/lint/rfc-2457-non-ascii-idents/lint-confusable-idents.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-confusable-idents.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-confusable-idents.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-confusable-idents.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -1,11 +1,11 @@\n-error: identifier pair considered confusable between `s` and `\uff53`\n-  --> $DIR/lint-confusable-idents.rs:5:7\n+error: identifier pair considered confusable between `\uff53` and `s`\n+  --> $DIR/lint-confusable-idents.rs:8:9\n    |\n LL | const \uff53: usize = 42;\n-   |       ^^\n+   |       -- this is where the previous identifier occurred\n ...\n LL |     let s = \"rust\";\n-   |         - this is where the previous identifier occurred\n+   |         ^\n    |\n note: the lint level is defined here\n   --> $DIR/lint-confusable-idents.rs:2:9"}, {"sha": "a5b45466da5ca5c12ca970d1bc7d6258ae6bff1d", "filename": "src/test/ui/lint/rfc-2457-non-ascii-idents/lint-mixed-script-confusables-2.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-mixed-script-confusables-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-mixed-script-confusables-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-mixed-script-confusables-2.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+#![feature(non_ascii_idents)]\n+#![deny(mixed_script_confusables)]\n+\n+struct \u0391ctuallyNotLatin;\n+\n+fn main() {\n+    let \u03bb = 42; // this usage of Greek confirms that Greek is used intentionally.\n+}\n+\n+mod \u0440\u043e\u0440\u0435 {\n+    const \u30a8: &'static str = \"\u30a2\u30a4\u30a6\";\n+\n+    // this usage of Katakana confirms that Katakana is used intentionally.\n+    fn \u30cb\u30e3\u30f3() {\n+        let \u0434: usize = 100; // this usage of Cyrillic confirms that Cyrillic is used intentionally.\n+\n+        println!(\"meow!\");\n+    }\n+}"}, {"sha": "4637b03f250de14f7336fdf8b3cd0ca04a6c310b", "filename": "src/test/ui/lint/rfc-2457-non-ascii-idents/lint-mixed-script-confusables.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-mixed-script-confusables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-mixed-script-confusables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-mixed-script-confusables.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,15 @@\n+#![feature(non_ascii_idents)]\n+#![deny(mixed_script_confusables)]\n+\n+struct \u0391ctuallyNotLatin;\n+//~^ ERROR The usage of Script Group `Greek` in this crate consists solely of\n+\n+fn main() {\n+    let v = \u0391ctuallyNotLatin;\n+}\n+\n+mod \u0440\u043e\u0440\u0435 {\n+//~^ ERROR The usage of Script Group `Cyrillic` in this crate consists solely of\n+    const \u30a8: &'static str = \"\u30a2\u30a4\u30a6\";\n+    //~^ ERROR The usage of Script Group `Japanese, Katakana` in this crate consists solely of\n+}"}, {"sha": "6f75a1ece37662769c292d2a9f544e7c9cd65867", "filename": "src/test/ui/lint/rfc-2457-non-ascii-idents/lint-mixed-script-confusables.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-mixed-script-confusables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-mixed-script-confusables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-mixed-script-confusables.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,34 @@\n+error: The usage of Script Group `Greek` in this crate consists solely of mixed script confusables\n+  --> $DIR/lint-mixed-script-confusables.rs:4:8\n+   |\n+LL | struct \u0391ctuallyNotLatin;\n+   |        ^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-mixed-script-confusables.rs:2:9\n+   |\n+LL | #![deny(mixed_script_confusables)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: The usage includes '\u0391' (U+0391).\n+   = note: Please recheck to make sure their usages are indeed what you want.\n+\n+error: The usage of Script Group `Cyrillic` in this crate consists solely of mixed script confusables\n+  --> $DIR/lint-mixed-script-confusables.rs:11:5\n+   |\n+LL | mod \u0440\u043e\u0440\u0435 {\n+   |     ^^^^\n+   |\n+   = note: The usage includes '\u0435' (U+0435), '\u043e' (U+043E), '\u0440' (U+0440).\n+   = note: Please recheck to make sure their usages are indeed what you want.\n+\n+error: The usage of Script Group `Japanese, Katakana` in this crate consists solely of mixed script confusables\n+  --> $DIR/lint-mixed-script-confusables.rs:13:11\n+   |\n+LL |     const \u30a8: &'static str = \"\u30a2\u30a4\u30a6\";\n+   |           ^^\n+   |\n+   = note: The usage includes '\u30a8' (U+30A8).\n+   = note: Please recheck to make sure their usages are indeed what you want.\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "20d00cf701a1569fe5f33ef0b0d0fdbcdc3900a1", "filename": "src/test/ui/lint/rfc-2457-non-ascii-idents/lint-non-ascii-idents.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-non-ascii-idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-non-ascii-idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-non-ascii-idents.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -7,5 +7,7 @@ fn co\u00f6peration() {} //~ ERROR identifier contains non-ASCII characters\n \n fn main() {\n     let na\u00efvet\u00e9 = 2; //~ ERROR identifier contains non-ASCII characters\n-    println!(\"{}\", na\u00efvet\u00e9); //~ ERROR identifier contains non-ASCII characters\n+\n+    // using the same identifier the second time won't trigger the lint.\n+    println!(\"{}\", na\u00efvet\u00e9);\n }"}, {"sha": "048b6ff5d687f011dac0ac01991bf589e4821f70", "filename": "src/test/ui/lint/rfc-2457-non-ascii-idents/lint-non-ascii-idents.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-non-ascii-idents.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-non-ascii-idents.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-non-ascii-idents.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -22,11 +22,5 @@ error: identifier contains non-ASCII characters\n LL |     let na\u00efvet\u00e9 = 2;\n    |         ^^^^^^^\n \n-error: identifier contains non-ASCII characters\n-  --> $DIR/lint-non-ascii-idents.rs:10:20\n-   |\n-LL |     println!(\"{}\", na\u00efvet\u00e9);\n-   |                    ^^^^^^^\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "b5e251e047b5ad1f8ca37054603d4b1fb9577185", "filename": "src/test/ui/lint/rfc-2457-non-ascii-idents/lint-uncommon-codepoints.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-uncommon-codepoints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-uncommon-codepoints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-uncommon-codepoints.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -7,5 +7,7 @@ fn d\u0133kstra() {} //~ ERROR identifier contains uncommon Unicode codepoints\n \n fn main() {\n     let \u31fb\u31f2\u31f3 = \"rust\"; //~ ERROR identifier contains uncommon Unicode codepoints\n-    println!(\"{}\", \u31fb\u31f2\u31f3); //~ ERROR identifier contains uncommon Unicode codepoints\n+\n+    // using the same identifier the second time won't trigger the lint.\n+    println!(\"{}\", \u31fb\u31f2\u31f3);\n }"}, {"sha": "05ea3d5de7dbc9759ec0482fd006d8fbad544a7c", "filename": "src/test/ui/lint/rfc-2457-non-ascii-idents/lint-uncommon-codepoints.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-uncommon-codepoints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-uncommon-codepoints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Frfc-2457-non-ascii-idents%2Flint-uncommon-codepoints.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -22,11 +22,5 @@ error: identifier contains uncommon Unicode codepoints\n LL |     let \u31fb\u31f2\u31f3 = \"rust\";\n    |         ^^^^^^\n \n-error: identifier contains uncommon Unicode codepoints\n-  --> $DIR/lint-uncommon-codepoints.rs:10:20\n-   |\n-LL |     println!(\"{}\", \u31fb\u31f2\u31f3);\n-   |                    ^^^^^^\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "952985fcddee6c18268718248bf22ad9e355ff07", "filename": "src/test/ui/moves/moves-based-on-type-cyclic-types-issue-4821.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-cyclic-types-issue-4821.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-cyclic-types-issue-4821.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-cyclic-types-issue-4821.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -8,6 +8,10 @@ LL |     consume(node) + r\n    |             ^^^^ value used here after partial move\n    |\n    = note: move occurs because value has type `std::boxed::Box<List>`, which does not implement the `Copy` trait\n+help: borrow this field in the pattern to avoid moving `node.next.0`\n+   |\n+LL |         Some(ref right) => consume(right),\n+   |              ^^^\n \n error: aborting due to previous error\n "}, {"sha": "4f36a4ccab28f701419059b3bd9b2503a95562af", "filename": "src/test/ui/nll/issue-53807.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fnll%2Fissue-53807.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fnll%2Fissue-53807.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-53807.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -5,6 +5,10 @@ LL |         if let Some(thing) = maybe {\n    |                     ^^^^^ value moved here, in previous iteration of loop\n    |\n    = note: move occurs because value has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n+help: borrow this field in the pattern to avoid moving `maybe.0`\n+   |\n+LL |         if let Some(ref thing) = maybe {\n+   |                     ^^^\n \n error: aborting due to previous error\n "}, {"sha": "9be9064414796b52b1b10131584e1b6cc98a6087", "filename": "src/test/ui/parser/byte-string-literals.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -22,7 +22,7 @@ error: byte constant must be ASCII. Use a \\xHH escape for a non-ASCII byte\n LL |     b\"\u00e9\";\n    |       ^\n \n-error: unterminated double quote byte string\n+error[E0766]: unterminated double quote byte string\n   --> $DIR/byte-string-literals.rs:7:6\n    |\n LL |       b\"a\n@@ -32,3 +32,4 @@ LL | | }\n \n error: aborting due to 5 previous errors\n \n+For more information about this error, try `rustc --explain E0766`."}, {"sha": "5259dfe2e656c9f255920434c7706e45a00799ae", "filename": "src/test/ui/parser/issue-62524.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fparser%2Fissue-62524.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fparser%2Fissue-62524.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62524.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -1,4 +1,6 @@\n // ignore-tidy-trailing-newlines\n // error-pattern: aborting due to 3 previous errors\n+#![allow(uncommon_codepoints)]\n+\n y![\n \u03e4,\n\\ No newline at end of file"}, {"sha": "d5e07622b11b99dce7867a65762ed90655b5d692", "filename": "src/test/ui/parser/issue-62524.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fparser%2Fissue-62524.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fparser%2Fissue-62524.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62524.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -1,13 +1,13 @@\n error: this file contains an unclosed delimiter\n-  --> $DIR/issue-62524.rs:4:3\n+  --> $DIR/issue-62524.rs:6:3\n    |\n LL | y![\n    |   - unclosed delimiter\n LL | \u03e4,\n    |   ^\n \n error: macros that expand to items must be delimited with braces or followed by a semicolon\n-  --> $DIR/issue-62524.rs:3:3\n+  --> $DIR/issue-62524.rs:5:3\n    |\n LL |   y![\n    |  ___^\n@@ -24,7 +24,7 @@ LL | \u03e4,;\n    |   ^\n \n error: cannot find macro `y` in this scope\n-  --> $DIR/issue-62524.rs:3:1\n+  --> $DIR/issue-62524.rs:5:1\n    |\n LL | y![\n    | ^"}, {"sha": "8a6ea8e91a25afec56935b275eafbcb560af5ecf", "filename": "src/test/ui/pattern/bindings-after-at/bind-by-move-neither-can-live-while-the-other-survives-1.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -46,6 +46,10 @@ LL |         Some(_z @ ref _y) => {}\n    |              value moved here\n    |\n    = note: move occurs because value has type `X`, which does not implement the `Copy` trait\n+help: borrow this field in the pattern to avoid moving `x.0`\n+   |\n+LL |         Some(ref _z @ ref _y) => {}\n+   |              ^^^\n \n error[E0382]: borrow of moved value\n   --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:35:19\n@@ -57,6 +61,10 @@ LL |         Some(_z @ ref mut _y) => {}\n    |              value moved here\n    |\n    = note: move occurs because value has type `X`, which does not implement the `Copy` trait\n+help: borrow this field in the pattern to avoid moving `x.0`\n+   |\n+LL |         Some(ref _z @ ref mut _y) => {}\n+   |              ^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "5058998f2a7c1c79eb9df0d99000c8da4e2cace1", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref-inverse.stderr", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -357,6 +357,10 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                   value moved here\n    |\n    = note: move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+help: borrow this field in the pattern to avoid moving the value\n+   |\n+LL |         a @ Some((ref mut b @ ref mut c, d @ ref e)) => {}\n+   |                   ^^^\n \n error[E0382]: use of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:61:38\n@@ -379,6 +383,10 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                                      value moved here\n    |\n    = note: move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+help: borrow this field in the pattern to avoid moving the value\n+   |\n+LL |         a @ Some((mut b @ ref mut c, ref d @ ref e)) => {}\n+   |                                      ^^^\n \n error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:71:30\n@@ -412,6 +420,10 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                   value moved here\n    |\n    = note: move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+help: borrow this field in the pattern to avoid moving the value\n+   |\n+LL |         a @ Some((ref mut b @ ref mut c, d @ ref e)) => {}\n+   |                   ^^^\n \n error[E0382]: use of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:83:38\n@@ -434,6 +446,10 @@ LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n    |                                      value moved here\n    |\n    = note: move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+help: borrow this field in the pattern to avoid moving the value\n+   |\n+LL |         a @ Some((mut b @ ref mut c, ref d @ ref e)) => {}\n+   |                                      ^^^\n \n error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:93:30"}, {"sha": "97d2c174d9adbf082682c9b7e5d476eb967815ea", "filename": "src/test/ui/ref-suggestion.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fref-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fref-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fref-suggestion.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -28,6 +28,10 @@ LL |     x;\n    |     ^ value used here after partial move\n    |\n    = note: move occurs because value has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\n+help: borrow this field in the pattern to avoid moving `x.0.0`\n+   |\n+LL |         (Some(ref y), ()) => {},\n+   |               ^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "bea1b91558646a3d48283c052ca6b5a55fefa8cb", "filename": "src/test/ui/suggestions/invalid-bin-op.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,7 @@\n+pub fn foo<T>(s: S<T>, t: S<T>) {\n+    let _ = s == t; //~ ERROR binary operation `==` cannot be applied to type `S<T>`\n+}\n+\n+struct S<T>(T);\n+\n+fn main() {}"}, {"sha": "7668eddf6070ab102db3cf6fdc4d3c1cc29d86a0", "filename": "src/test/ui/suggestions/invalid-bin-op.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,13 @@\n+error[E0369]: binary operation `==` cannot be applied to type `S<T>`\n+  --> $DIR/invalid-bin-op.rs:2:15\n+   |\n+LL |     let _ = s == t;\n+   |             - ^^ - S<T>\n+   |             |\n+   |             S<T>\n+   |\n+   = note: the trait `std::cmp::PartialEq` is not implemented for `S<T>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "6b24375e41503cc5cb14801243ec85ad745ce6df", "filename": "src/test/ui/suggestions/missing-trait-bound-for-op.fixed", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.fixed?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,7 @@\n+// run-rustfix\n+\n+pub fn foo<T: std::cmp::PartialEq>(s: &[T], t: &[T]) {\n+    let _ = s == t; //~ ERROR binary operation `==` cannot be applied to type `&[T]`\n+}\n+\n+fn main() {}"}, {"sha": "df47be070c9ea3fa0e03f2edd76d328ef3023eb7", "filename": "src/test/ui/suggestions/missing-trait-bound-for-op.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,7 @@\n+// run-rustfix\n+\n+pub fn foo<T>(s: &[T], t: &[T]) {\n+    let _ = s == t; //~ ERROR binary operation `==` cannot be applied to type `&[T]`\n+}\n+\n+fn main() {}"}, {"sha": "0e0d397d6fc1546df01e12ca9fe47c06046d182d", "filename": "src/test/ui/suggestions/missing-trait-bound-for-op.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -0,0 +1,16 @@\n+error[E0369]: binary operation `==` cannot be applied to type `&[T]`\n+  --> $DIR/missing-trait-bound-for-op.rs:4:15\n+   |\n+LL |     let _ = s == t;\n+   |             - ^^ - &[T]\n+   |             |\n+   |             &[T]\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | pub fn foo<T: std::cmp::PartialEq>(s: &[T], t: &[T]) {\n+   |             ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "507d53dc07c4c9e4d2684db8afee0dfb3be963cf", "filename": "src/test/ui/traits/trait-resolution-in-overloaded-op.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -5,6 +5,11 @@ LL |     a * b\n    |     - ^ - f64\n    |     |\n    |     &T\n+   |\n+help: consider further restricting this bound\n+   |\n+LL | fn foo<T: MyMul<f64, f64> + std::ops::Mul<Output = f64>>(a: &T, b: f64) -> f64 {\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "6c54086cc2009a4059218f16825fd85dde53da3f", "filename": "src/test/ui/utf8_idents.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Futf8_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Futf8_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Futf8_idents.rs?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -1,3 +1,5 @@\n+#![allow(mixed_script_confusables)]\n+\n fn foo<\n     '\u03b2, //~ ERROR non-ascii idents are not fully supported\n     \u03b3  //~ ERROR non-ascii idents are not fully supported"}, {"sha": "2fc0b1c39effb54f6766d3f6f0b8cd413dbae562", "filename": "src/test/ui/utf8_idents.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Futf8_idents.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e093b6525079cb71d4158f97480ac6f6ce311eac/src%2Ftest%2Fui%2Futf8_idents.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Futf8_idents.stderr?ref=e093b6525079cb71d4158f97480ac6f6ce311eac", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: non-ascii idents are not fully supported\n-  --> $DIR/utf8_idents.rs:2:5\n+  --> $DIR/utf8_idents.rs:4:5\n    |\n LL |     '\u03b2,\n    |     ^^\n@@ -8,7 +8,7 @@ LL |     '\u03b2,\n    = help: add `#![feature(non_ascii_idents)]` to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported\n-  --> $DIR/utf8_idents.rs:3:5\n+  --> $DIR/utf8_idents.rs:5:5\n    |\n LL |     \u03b3\n    |     ^\n@@ -17,7 +17,7 @@ LL |     \u03b3\n    = help: add `#![feature(non_ascii_idents)]` to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported\n-  --> $DIR/utf8_idents.rs:8:5\n+  --> $DIR/utf8_idents.rs:10:5\n    |\n LL |     \u03b4: usize\n    |     ^\n@@ -26,7 +26,7 @@ LL |     \u03b4: usize\n    = help: add `#![feature(non_ascii_idents)]` to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported\n-  --> $DIR/utf8_idents.rs:12:9\n+  --> $DIR/utf8_idents.rs:14:9\n    |\n LL |     let \u03b1 = 0.00001f64;\n    |         ^\n@@ -35,7 +35,7 @@ LL |     let \u03b1 = 0.00001f64;\n    = help: add `#![feature(non_ascii_idents)]` to the crate attributes to enable\n \n warning: type parameter `\u03b3` should have an upper camel case name\n-  --> $DIR/utf8_idents.rs:3:5\n+  --> $DIR/utf8_idents.rs:5:5\n    |\n LL |     \u03b3\n    |     ^ help: convert the identifier to upper camel case: `\u0393`"}]}