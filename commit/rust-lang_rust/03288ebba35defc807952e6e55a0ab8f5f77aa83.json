{"sha": "03288ebba35defc807952e6e55a0ab8f5f77aa83", "node_id": "C_kwDOAAsO6NoAKDAzMjg4ZWJiYTM1ZGVmYzgwNzk1MmU2ZTU1YTBhYjhmNWY3N2FhODM", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2023-02-20T08:14:12Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2023-02-20T08:14:12Z"}, "message": ":arrow_up: rust-analyzer", "tree": {"sha": "45c8078fb5abbbe8ffb4009683f87f3fae962b91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45c8078fb5abbbe8ffb4009683f87f3fae962b91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03288ebba35defc807952e6e55a0ab8f5f77aa83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03288ebba35defc807952e6e55a0ab8f5f77aa83", "html_url": "https://github.com/rust-lang/rust/commit/03288ebba35defc807952e6e55a0ab8f5f77aa83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03288ebba35defc807952e6e55a0ab8f5f77aa83/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "824f915cbc32c0942122389274a1b6fbe2ffc51e", "url": "https://api.github.com/repos/rust-lang/rust/commits/824f915cbc32c0942122389274a1b6fbe2ffc51e", "html_url": "https://github.com/rust-lang/rust/commit/824f915cbc32c0942122389274a1b6fbe2ffc51e"}, {"sha": "a6603fc21d50b3386a488c96225b2d1fd492e533", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6603fc21d50b3386a488c96225b2d1fd492e533", "html_url": "https://github.com/rust-lang/rust/commit/a6603fc21d50b3386a488c96225b2d1fd492e533"}], "stats": {"total": 2742, "additions": 1800, "deletions": 942}, "files": [{"sha": "ec197767259d4e6d57e33f8b9a3edb4ddd14d572", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -711,6 +711,7 @@ dependencies = [\n  \"limit\",\n  \"memchr\",\n  \"once_cell\",\n+ \"oorandom\",\n  \"parser\",\n  \"profile\",\n  \"rayon\",\n@@ -932,9 +933,9 @@ dependencies = [\n \n [[package]]\n name = \"lsp-types\"\n-version = \"0.93.2\"\n+version = \"0.94.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9be6e9c7e2d18f651974370d7aff703f9513e0df6e464fd795660edc77e6ca51\"\n+checksum = \"0b63735a13a1f9cd4f4835223d828ed9c2e35c8c5e61837774399f558b6a1237\"\n dependencies = [\n  \"bitflags\",\n  \"serde\",\n@@ -1173,6 +1174,7 @@ dependencies = [\n  \"limit\",\n  \"rustc-ap-rustc_lexer\",\n  \"sourcegen\",\n+ \"stdx\",\n ]\n \n [[package]]"}, {"sha": "333f03ce2ffe5d6dfeb9c200598ce5d7127c8780", "filename": "src/tools/rust-analyzer/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.toml?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -74,3 +74,5 @@ toolchain = { path = \"./crates/toolchain\", version = \"0.0.0\" }\n tt = { path = \"./crates/tt\", version = \"0.0.0\" }\n vfs-notify = { path = \"./crates/vfs-notify\", version = \"0.0.0\" }\n vfs = { path = \"./crates/vfs\", version = \"0.0.0\" }\n+# non-local crates\n+smallvec = { version = \"1.10.0\", features = [\"const_new\", \"union\", \"const_generics\"] }"}, {"sha": "31d4018d2b6ab6e863c89c7f2012b96863ad342a", "filename": "src/tools/rust-analyzer/crates/hir-def/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -27,7 +27,7 @@ itertools = \"0.10.5\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n once_cell = \"1.17.0\"\n rustc-hash = \"1.1.0\"\n-smallvec = \"1.10.0\"\n+smallvec.workspace = true\n tracing = \"0.1.35\"\n \n rustc_abi = { version = \"0.0.20221221\", package = \"hkalbasi-rustc-ap-rustc_abi\", default-features = false }"}, {"sha": "9bc1c54a3c6412eb4531a9aa48decadbf2448bf4", "filename": "src/tools/rust-analyzer/crates/hir-def/src/adt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -2,9 +2,10 @@\n \n use std::sync::Arc;\n \n-use crate::tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n use base_db::CrateId;\n+use cfg::CfgOptions;\n use either::Either;\n+\n use hir_expand::{\n     name::{AsName, Name},\n     HirFileId, InFile,\n@@ -24,12 +25,12 @@ use crate::{\n     src::HasChildSource,\n     src::HasSource,\n     trace::Trace,\n+    tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree},\n     type_ref::TypeRef,\n     visibility::RawVisibility,\n     EnumId, LocalEnumVariantId, LocalFieldId, LocalModuleId, Lookup, ModuleId, StructId, UnionId,\n     VariantId,\n };\n-use cfg::CfgOptions;\n \n /// Note that we use `StructData` for unions as well!\n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "8fd9255b8b130e1ea963cfbff333f88d6e462cc7", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body.rs", "status": "modified", "additions": 91, "deletions": 49, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -19,7 +19,7 @@ use la_arena::{Arena, ArenaMap};\n use limit::Limit;\n use profile::Count;\n use rustc_hash::FxHashMap;\n-use syntax::{ast, AstPtr, SyntaxNodePtr};\n+use syntax::{ast, AstPtr, SyntaxNode, SyntaxNodePtr};\n \n use crate::{\n     attr::Attrs,\n@@ -51,7 +51,8 @@ pub struct Expander {\n     def_map: Arc<DefMap>,\n     current_file_id: HirFileId,\n     module: LocalModuleId,\n-    recursion_limit: usize,\n+    /// `recursion_depth == usize::MAX` indicates that the recursion limit has been reached.\n+    recursion_depth: usize,\n }\n \n impl CfgExpander {\n@@ -84,7 +85,7 @@ impl Expander {\n             def_map,\n             current_file_id,\n             module: module.local_id,\n-            recursion_limit: 0,\n+            recursion_depth: 0,\n         }\n     }\n \n@@ -93,47 +94,52 @@ impl Expander {\n         db: &dyn DefDatabase,\n         macro_call: ast::MacroCall,\n     ) -> Result<ExpandResult<Option<(Mark, T)>>, UnresolvedMacro> {\n-        if self.recursion_limit(db).check(self.recursion_limit + 1).is_err() {\n-            cov_mark::hit!(your_stack_belongs_to_me);\n-            return Ok(ExpandResult::only_err(ExpandError::Other(\n-                \"reached recursion limit during macro expansion\".into(),\n-            )));\n+        let mut unresolved_macro_err = None;\n+\n+        let result = self.within_limit(db, |this| {\n+            let macro_call = InFile::new(this.current_file_id, &macro_call);\n+\n+            let resolver =\n+                |path| this.resolve_path_as_macro(db, &path).map(|it| macro_id_to_def_id(db, it));\n+\n+            let mut err = None;\n+            let call_id = match macro_call.as_call_id_with_errors(\n+                db,\n+                this.def_map.krate(),\n+                resolver,\n+                &mut |e| {\n+                    err.get_or_insert(e);\n+                },\n+            ) {\n+                Ok(call_id) => call_id,\n+                Err(resolve_err) => {\n+                    unresolved_macro_err = Some(resolve_err);\n+                    return ExpandResult { value: None, err: None };\n+                }\n+            };\n+            ExpandResult { value: call_id.ok(), err }\n+        });\n+\n+        if let Some(err) = unresolved_macro_err {\n+            Err(err)\n+        } else {\n+            Ok(result)\n         }\n-\n-        let macro_call = InFile::new(self.current_file_id, &macro_call);\n-\n-        let resolver =\n-            |path| self.resolve_path_as_macro(db, &path).map(|it| macro_id_to_def_id(db, it));\n-\n-        let mut err = None;\n-        let call_id =\n-            macro_call.as_call_id_with_errors(db, self.def_map.krate(), resolver, &mut |e| {\n-                err.get_or_insert(e);\n-            })?;\n-        let call_id = match call_id {\n-            Ok(it) => it,\n-            Err(_) => {\n-                return Ok(ExpandResult { value: None, err });\n-            }\n-        };\n-\n-        Ok(self.enter_expand_inner(db, call_id, err))\n     }\n \n     pub fn enter_expand_id<T: ast::AstNode>(\n         &mut self,\n         db: &dyn DefDatabase,\n         call_id: MacroCallId,\n     ) -> ExpandResult<Option<(Mark, T)>> {\n-        self.enter_expand_inner(db, call_id, None)\n+        self.within_limit(db, |_this| ExpandResult::ok(Some(call_id)))\n     }\n \n-    fn enter_expand_inner<T: ast::AstNode>(\n-        &mut self,\n+    fn enter_expand_inner(\n         db: &dyn DefDatabase,\n         call_id: MacroCallId,\n         mut err: Option<ExpandError>,\n-    ) -> ExpandResult<Option<(Mark, T)>> {\n+    ) -> ExpandResult<Option<(HirFileId, SyntaxNode)>> {\n         if err.is_none() {\n             err = db.macro_expand_error(call_id);\n         }\n@@ -154,29 +160,21 @@ impl Expander {\n             }\n         };\n \n-        let node = match T::cast(raw_node) {\n-            Some(it) => it,\n-            None => {\n-                // This can happen without being an error, so only forward previous errors.\n-                return ExpandResult { value: None, err };\n-            }\n-        };\n-\n-        tracing::debug!(\"macro expansion {:#?}\", node.syntax());\n-\n-        self.recursion_limit += 1;\n-        let mark =\n-            Mark { file_id: self.current_file_id, bomb: DropBomb::new(\"expansion mark dropped\") };\n-        self.cfg_expander.hygiene = Hygiene::new(db.upcast(), file_id);\n-        self.current_file_id = file_id;\n-\n-        ExpandResult { value: Some((mark, node)), err }\n+        ExpandResult { value: Some((file_id, raw_node)), err }\n     }\n \n     pub fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {\n         self.cfg_expander.hygiene = Hygiene::new(db.upcast(), mark.file_id);\n         self.current_file_id = mark.file_id;\n-        self.recursion_limit -= 1;\n+        if self.recursion_depth == usize::MAX {\n+            // Recursion limit has been reached somewhere in the macro expansion tree. Reset the\n+            // depth only when we get out of the tree.\n+            if !self.current_file_id.is_macro() {\n+                self.recursion_depth = 0;\n+            }\n+        } else {\n+            self.recursion_depth -= 1;\n+        }\n         mark.bomb.defuse();\n     }\n \n@@ -215,6 +213,50 @@ impl Expander {\n         #[cfg(test)]\n         return Limit::new(std::cmp::min(32, limit));\n     }\n+\n+    fn within_limit<F, T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        op: F,\n+    ) -> ExpandResult<Option<(Mark, T)>>\n+    where\n+        F: FnOnce(&mut Self) -> ExpandResult<Option<MacroCallId>>,\n+    {\n+        if self.recursion_depth == usize::MAX {\n+            // Recursion limit has been reached somewhere in the macro expansion tree. We should\n+            // stop expanding other macro calls in this tree, or else this may result in\n+            // exponential number of macro expansions, leading to a hang.\n+            //\n+            // The overflow error should have been reported when it occurred (see the next branch),\n+            // so don't return overflow error here to avoid diagnostics duplication.\n+            cov_mark::hit!(overflow_but_not_me);\n+            return ExpandResult::only_err(ExpandError::RecursionOverflowPosioned);\n+        } else if self.recursion_limit(db).check(self.recursion_depth + 1).is_err() {\n+            self.recursion_depth = usize::MAX;\n+            cov_mark::hit!(your_stack_belongs_to_me);\n+            return ExpandResult::only_err(ExpandError::Other(\n+                \"reached recursion limit during macro expansion\".into(),\n+            ));\n+        }\n+\n+        let ExpandResult { value, err } = op(self);\n+        let Some(call_id) = value else {\n+            return ExpandResult { value: None, err };\n+        };\n+\n+        Self::enter_expand_inner(db, call_id, err).map(|value| {\n+            value.and_then(|(new_file_id, node)| {\n+                let node = T::cast(node)?;\n+\n+                self.recursion_depth += 1;\n+                self.cfg_expander.hygiene = Hygiene::new(db.upcast(), new_file_id);\n+                let old_file_id = std::mem::replace(&mut self.current_file_id, new_file_id);\n+                let mark =\n+                    Mark { file_id: old_file_id, bomb: DropBomb::new(\"expansion mark dropped\") };\n+                Some((mark, node))\n+            })\n+        })\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "04b1c4f01e22a4f0c263d9dc794ae413b986abed", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -624,6 +624,10 @@ impl ExprCollector<'_> {\n                         krate: *krate,\n                     });\n                 }\n+                Some(ExpandError::RecursionOverflowPosioned) => {\n+                    // Recursion limit has been reached in the macro expansion tree, but not in\n+                    // this very macro call. Don't add diagnostics to avoid duplication.\n+                }\n                 Some(err) => {\n                     self.source_map.diagnostics.push(BodyDiagnostic::MacroError {\n                         node: InFile::new(outer_file, syntax_ptr),\n@@ -636,6 +640,8 @@ impl ExprCollector<'_> {\n \n         match res.value {\n             Some((mark, expansion)) => {\n+                // Keep collecting even with expansion errors so we can provide completions and\n+                // other services in incomplete macro expressions.\n                 self.source_map.expansions.insert(macro_call_ptr, self.expander.current_file_id);\n                 let prev_ast_id_map = mem::replace(\n                     &mut self.ast_id_map,"}, {"sha": "edee2c7ff96bfb76809bf91a8a03f77e6bc0234b", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/tests.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Ftests.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -61,6 +61,19 @@ fn main() { n_nuple!(1,2,3); }\n     );\n }\n \n+#[test]\n+fn your_stack_belongs_to_me2() {\n+    cov_mark::check!(overflow_but_not_me);\n+    lower(\n+        r#\"\n+macro_rules! foo {\n+    () => {{ foo!(); foo!(); }}\n+}\n+fn main() { foo!(); }\n+\"#,\n+    );\n+}\n+\n #[test]\n fn recursion_limit() {\n     cov_mark::check!(your_stack_belongs_to_me);"}, {"sha": "d4d3c5ef19a60d84d89e7eea8fbc39c1a8a7ca29", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -659,15 +659,16 @@ fn desugar_future_path(orig: TypeRef) -> Path {\n     let path = path![core::future::Future];\n     let mut generic_args: Vec<_> =\n         std::iter::repeat(None).take(path.segments().len() - 1).collect();\n-    let mut last = GenericArgs::empty();\n     let binding = AssociatedTypeBinding {\n         name: name![Output],\n         args: None,\n         type_ref: Some(orig),\n-        bounds: Vec::new(),\n+        bounds: Box::default(),\n     };\n-    last.bindings.push(binding);\n-    generic_args.push(Some(Interned::new(last)));\n+    generic_args.push(Some(Interned::new(GenericArgs {\n+        bindings: Box::new([binding]),\n+        ..GenericArgs::empty()\n+    })));\n \n     Path::from_known_path(path, generic_args)\n }"}, {"sha": "7a3e8c3b05c911037963737f4d48b19aae9b0b03", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -1476,7 +1476,7 @@ macro_rules! m {\n /* parse error: expected identifier */\n /* parse error: expected SEMICOLON */\n /* parse error: expected SEMICOLON */\n-/* parse error: expected expression */\n+/* parse error: expected expression, item or let statement */\n fn f() {\n     K::(C(\"0\"));\n }"}, {"sha": "8358a46f0a9142f7db24a5ea143f6553ce6d0cf5", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe/regression.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -830,8 +830,7 @@ macro_rules! rgb_color {\n /* parse error: expected COMMA */\n /* parse error: expected R_ANGLE */\n /* parse error: expected SEMICOLON */\n-/* parse error: expected SEMICOLON */\n-/* parse error: expected expression */\n+/* parse error: expected expression, item or let statement */\n pub fn new() {\n     let _ = 0as u32<<(8+8);\n }\n@@ -848,21 +847,21 @@ pub fn new() {\n //     BLOCK_EXPR@10..31\n //       STMT_LIST@10..31\n //         L_CURLY@10..11 \"{\"\n-//         LET_STMT@11..27\n+//         LET_STMT@11..28\n //           LET_KW@11..14 \"let\"\n //           WILDCARD_PAT@14..15\n //             UNDERSCORE@14..15 \"_\"\n //           EQ@15..16 \"=\"\n-//           CAST_EXPR@16..27\n+//           CAST_EXPR@16..28\n //             LITERAL@16..17\n //               INT_NUMBER@16..17 \"0\"\n //             AS_KW@17..19 \"as\"\n-//             PATH_TYPE@19..27\n-//               PATH@19..27\n-//                 PATH_SEGMENT@19..27\n+//             PATH_TYPE@19..28\n+//               PATH@19..28\n+//                 PATH_SEGMENT@19..28\n //                   NAME_REF@19..22\n //                     IDENT@19..22 \"u32\"\n-//                   GENERIC_ARG_LIST@22..27\n+//                   GENERIC_ARG_LIST@22..28\n //                     L_ANGLE@22..23 \"<\"\n //                     TYPE_ARG@23..27\n //                       DYN_TRAIT_TYPE@23..27\n@@ -877,9 +876,9 @@ pub fn new() {\n //                                     ERROR@25..26\n //                                       INT_NUMBER@25..26 \"8\"\n //                           PLUS@26..27 \"+\"\n-//         EXPR_STMT@27..28\n-//           LITERAL@27..28\n-//             INT_NUMBER@27..28 \"8\"\n+//                     CONST_ARG@27..28\n+//                       LITERAL@27..28\n+//                         INT_NUMBER@27..28 \"8\"\n //         ERROR@28..29\n //           R_PAREN@28..29 \")\"\n //         SEMICOLON@29..30 \";\""}, {"sha": "36d4c36a26894550135d732e08ab3f704ae55f7e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/path.rs", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -38,26 +38,26 @@ impl Display for ImportAlias {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n     /// Type based path like `<T>::foo`.\n-    /// Note that paths like `<Type as Trait>::foo` are desugard to `Trait::<Self=Type>::foo`.\n+    /// Note that paths like `<Type as Trait>::foo` are desugared to `Trait::<Self=Type>::foo`.\n     type_anchor: Option<Interned<TypeRef>>,\n     mod_path: Interned<ModPath>,\n-    /// Invariant: the same len as `self.mod_path.segments`\n-    generic_args: Box<[Option<Interned<GenericArgs>>]>,\n+    /// Invariant: the same len as `self.mod_path.segments` or `None` if all segments are `None`.\n+    generic_args: Option<Box<[Option<Interned<GenericArgs>>]>>,\n }\n \n /// Generic arguments to a path segment (e.g. the `i32` in `Option<i32>`). This\n /// also includes bindings of associated types, like in `Iterator<Item = Foo>`.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct GenericArgs {\n-    pub args: Vec<GenericArg>,\n+    pub args: Box<[GenericArg]>,\n     /// This specifies whether the args contain a Self type as the first\n     /// element. This is the case for path segments like `<T as Trait>`, where\n     /// `T` is actually a type parameter for the path `Trait` specifying the\n     /// Self type. Otherwise, when we have a path `Trait<X, Y>`, the Self type\n     /// is left out.\n     pub has_self_type: bool,\n     /// Associated type bindings like in `Iterator<Item = T>`.\n-    pub bindings: Vec<AssociatedTypeBinding>,\n+    pub bindings: Box<[AssociatedTypeBinding]>,\n     /// Whether these generic args were desugared from `Trait(Arg) -> Output`\n     /// parenthesis notation typically used for the `Fn` traits.\n     pub desugared_from_fn: bool,\n@@ -77,7 +77,7 @@ pub struct AssociatedTypeBinding {\n     /// Bounds for the associated type, like in `Iterator<Item:\n     /// SomeOtherTrait>`. (This is the unstable `associated_type_bounds`\n     /// feature.)\n-    pub bounds: Vec<Interned<TypeBound>>,\n+    pub bounds: Box<[Interned<TypeBound>]>,\n }\n \n /// A single generic argument.\n@@ -102,7 +102,7 @@ impl Path {\n     ) -> Path {\n         let generic_args = generic_args.into();\n         assert_eq!(path.len(), generic_args.len());\n-        Path { type_anchor: None, mod_path: Interned::new(path), generic_args }\n+        Path { type_anchor: None, mod_path: Interned::new(path), generic_args: Some(generic_args) }\n     }\n \n     pub fn kind(&self) -> &PathKind {\n@@ -114,7 +114,14 @@ impl Path {\n     }\n \n     pub fn segments(&self) -> PathSegments<'_> {\n-        PathSegments { segments: self.mod_path.segments(), generic_args: &self.generic_args }\n+        let s = PathSegments {\n+            segments: self.mod_path.segments(),\n+            generic_args: self.generic_args.as_deref(),\n+        };\n+        if let Some(generic_args) = s.generic_args {\n+            assert_eq!(s.segments.len(), generic_args.len());\n+        }\n+        s\n     }\n \n     pub fn mod_path(&self) -> &ModPath {\n@@ -131,13 +138,15 @@ impl Path {\n                 self.mod_path.kind,\n                 self.mod_path.segments()[..self.mod_path.segments().len() - 1].iter().cloned(),\n             )),\n-            generic_args: self.generic_args[..self.generic_args.len() - 1].to_vec().into(),\n+            generic_args: self.generic_args.as_ref().map(|it| it[..it.len() - 1].to_vec().into()),\n         };\n         Some(res)\n     }\n \n     pub fn is_self_type(&self) -> bool {\n-        self.type_anchor.is_none() && *self.generic_args == [None] && self.mod_path.is_Self()\n+        self.type_anchor.is_none()\n+            && self.generic_args.as_deref().is_none()\n+            && self.mod_path.is_Self()\n     }\n }\n \n@@ -149,11 +158,11 @@ pub struct PathSegment<'a> {\n \n pub struct PathSegments<'a> {\n     segments: &'a [Name],\n-    generic_args: &'a [Option<Interned<GenericArgs>>],\n+    generic_args: Option<&'a [Option<Interned<GenericArgs>>]>,\n }\n \n impl<'a> PathSegments<'a> {\n-    pub const EMPTY: PathSegments<'static> = PathSegments { segments: &[], generic_args: &[] };\n+    pub const EMPTY: PathSegments<'static> = PathSegments { segments: &[], generic_args: None };\n     pub fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n@@ -167,26 +176,29 @@ impl<'a> PathSegments<'a> {\n         self.get(self.len().checked_sub(1)?)\n     }\n     pub fn get(&self, idx: usize) -> Option<PathSegment<'a>> {\n-        assert_eq!(self.segments.len(), self.generic_args.len());\n         let res = PathSegment {\n             name: self.segments.get(idx)?,\n-            args_and_bindings: self.generic_args.get(idx).unwrap().as_ref().map(|it| &**it),\n+            args_and_bindings: self.generic_args.and_then(|it| it.get(idx)?.as_deref()),\n         };\n         Some(res)\n     }\n     pub fn skip(&self, len: usize) -> PathSegments<'a> {\n-        assert_eq!(self.segments.len(), self.generic_args.len());\n-        PathSegments { segments: &self.segments[len..], generic_args: &self.generic_args[len..] }\n+        PathSegments {\n+            segments: &self.segments.get(len..).unwrap_or(&[]),\n+            generic_args: self.generic_args.and_then(|it| it.get(len..)),\n+        }\n     }\n     pub fn take(&self, len: usize) -> PathSegments<'a> {\n-        assert_eq!(self.segments.len(), self.generic_args.len());\n-        PathSegments { segments: &self.segments[..len], generic_args: &self.generic_args[..len] }\n+        PathSegments {\n+            segments: &self.segments.get(..len).unwrap_or(&self.segments),\n+            generic_args: self.generic_args.map(|it| it.get(..len).unwrap_or(it)),\n+        }\n     }\n     pub fn iter(&self) -> impl Iterator<Item = PathSegment<'a>> {\n-        self.segments.iter().zip(self.generic_args.iter()).map(|(name, args)| PathSegment {\n-            name,\n-            args_and_bindings: args.as_ref().map(|it| &**it),\n-        })\n+        self.segments\n+            .iter()\n+            .zip(self.generic_args.into_iter().flatten().chain(iter::repeat(&None)))\n+            .map(|(name, args)| PathSegment { name, args_and_bindings: args.as_deref() })\n     }\n }\n \n@@ -200,9 +212,9 @@ impl GenericArgs {\n \n     pub(crate) fn empty() -> GenericArgs {\n         GenericArgs {\n-            args: Vec::new(),\n+            args: Box::default(),\n             has_self_type: false,\n-            bindings: Vec::new(),\n+            bindings: Box::default(),\n             desugared_from_fn: false,\n         }\n     }\n@@ -213,7 +225,7 @@ impl From<Name> for Path {\n         Path {\n             type_anchor: None,\n             mod_path: Interned::new(ModPath::from_segments(PathKind::Plain, iter::once(name))),\n-            generic_args: Box::new([None]),\n+            generic_args: None,\n         }\n     }\n }"}, {"sha": "c85a11db6d1947fa6bdf0f8e11a81eeed8fb6e73", "filename": "src/tools/rust-analyzer/crates/hir-def/src/path/lower.rs", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -1,5 +1,7 @@\n //! Transforms syntax into `Path` objects, ideally with accounting for hygiene\n \n+use std::iter;\n+\n use crate::type_ref::ConstScalarOrPath;\n \n use either::Either;\n@@ -45,8 +47,11 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n                                 )\n                             })\n                             .map(Interned::new);\n+                        if let Some(_) = args {\n+                            generic_args.resize(segments.len(), None);\n+                            generic_args.push(args);\n+                        }\n                         segments.push(name);\n-                        generic_args.push(args)\n                     }\n                     Either::Right(crate_id) => {\n                         kind = PathKind::DollarCrate(crate_id);\n@@ -56,7 +61,6 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n             }\n             ast::PathSegmentKind::SelfTypeKw => {\n                 segments.push(name![Self]);\n-                generic_args.push(None)\n             }\n             ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n                 assert!(path.qualifier().is_none()); // this can only occur at the first segment\n@@ -77,18 +81,33 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n                         kind = mod_path.kind;\n \n                         segments.extend(mod_path.segments().iter().cloned().rev());\n-                        generic_args.extend(Vec::from(path_generic_args).into_iter().rev());\n+                        if let Some(path_generic_args) = path_generic_args {\n+                            generic_args.resize(segments.len() - num_segments, None);\n+                            generic_args.extend(Vec::from(path_generic_args).into_iter().rev());\n+                        } else {\n+                            generic_args.resize(segments.len(), None);\n+                        }\n+\n+                        let self_type = GenericArg::Type(self_type);\n \n                         // Insert the type reference (T in the above example) as Self parameter for the trait\n-                        let last_segment =\n-                            generic_args.iter_mut().rev().nth(num_segments.saturating_sub(1))?;\n-                        let mut args_inner = match last_segment {\n-                            Some(it) => it.as_ref().clone(),\n-                            None => GenericArgs::empty(),\n-                        };\n-                        args_inner.has_self_type = true;\n-                        args_inner.args.insert(0, GenericArg::Type(self_type));\n-                        *last_segment = Some(Interned::new(args_inner));\n+                        let last_segment = generic_args.get_mut(segments.len() - num_segments)?;\n+                        *last_segment = Some(Interned::new(match last_segment.take() {\n+                            Some(it) => GenericArgs {\n+                                args: iter::once(self_type)\n+                                    .chain(it.args.iter().cloned())\n+                                    .collect(),\n+\n+                                has_self_type: true,\n+                                bindings: it.bindings.clone(),\n+                                desugared_from_fn: it.desugared_from_fn,\n+                            },\n+                            None => GenericArgs {\n+                                args: Box::new([self_type]),\n+                                has_self_type: true,\n+                                ..GenericArgs::empty()\n+                            },\n+                        }));\n                     }\n                 }\n             }\n@@ -115,7 +134,10 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n         };\n     }\n     segments.reverse();\n-    generic_args.reverse();\n+    if !generic_args.is_empty() {\n+        generic_args.resize(segments.len(), None);\n+        generic_args.reverse();\n+    }\n \n     if segments.is_empty() && kind == PathKind::Plain && type_anchor.is_none() {\n         // plain empty paths don't exist, this means we got a single `self` segment as our path\n@@ -135,7 +157,11 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n     }\n \n     let mod_path = Interned::new(ModPath::from_segments(kind, segments));\n-    return Some(Path { type_anchor, mod_path, generic_args: generic_args.into() });\n+    return Some(Path {\n+        type_anchor,\n+        mod_path,\n+        generic_args: if generic_args.is_empty() { None } else { Some(generic_args.into()) },\n+    });\n \n     fn qualifier(path: &ast::Path) -> Option<ast::Path> {\n         if let Some(q) = path.qualifier() {\n@@ -174,7 +200,7 @@ pub(super) fn lower_generic_args(\n                             .map(|it| Interned::new(TypeBound::from_ast(lower_ctx, it)))\n                             .collect()\n                     } else {\n-                        Vec::new()\n+                        Box::default()\n                     };\n                     bindings.push(AssociatedTypeBinding { name, args, type_ref, bounds });\n                 }\n@@ -195,7 +221,12 @@ pub(super) fn lower_generic_args(\n     if args.is_empty() && bindings.is_empty() {\n         return None;\n     }\n-    Some(GenericArgs { args, has_self_type: false, bindings, desugared_from_fn: false })\n+    Some(GenericArgs {\n+        args: args.into_boxed_slice(),\n+        has_self_type: false,\n+        bindings: bindings.into_boxed_slice(),\n+        desugared_from_fn: false,\n+    })\n }\n \n /// Collect `GenericArgs` from the parts of a fn-like path, i.e. `Fn(X, Y)\n@@ -205,33 +236,30 @@ fn lower_generic_args_from_fn_path(\n     params: Option<ast::ParamList>,\n     ret_type: Option<ast::RetType>,\n ) -> Option<GenericArgs> {\n-    let mut args = Vec::new();\n-    let mut bindings = Vec::new();\n     let params = params?;\n     let mut param_types = Vec::new();\n     for param in params.params() {\n         let type_ref = TypeRef::from_ast_opt(ctx, param.ty());\n         param_types.push(type_ref);\n     }\n-    let arg = GenericArg::Type(TypeRef::Tuple(param_types));\n-    args.push(arg);\n-    if let Some(ret_type) = ret_type {\n+    let args = Box::new([GenericArg::Type(TypeRef::Tuple(param_types))]);\n+    let bindings = if let Some(ret_type) = ret_type {\n         let type_ref = TypeRef::from_ast_opt(ctx, ret_type.ty());\n-        bindings.push(AssociatedTypeBinding {\n+        Box::new([AssociatedTypeBinding {\n             name: name![Output],\n             args: None,\n             type_ref: Some(type_ref),\n-            bounds: Vec::new(),\n-        });\n+            bounds: Box::default(),\n+        }])\n     } else {\n         // -> ()\n         let type_ref = TypeRef::Tuple(Vec::new());\n-        bindings.push(AssociatedTypeBinding {\n+        Box::new([AssociatedTypeBinding {\n             name: name![Output],\n             args: None,\n             type_ref: Some(type_ref),\n-            bounds: Vec::new(),\n-        });\n-    }\n+            bounds: Box::default(),\n+        }])\n+    };\n     Some(GenericArgs { args, has_self_type: false, bindings, desugared_from_fn: true })\n }"}, {"sha": "2d45c8c8da1a5ba56db35223a4a59abf06bf0d6f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpretty.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -71,7 +71,7 @@ pub(crate) fn print_generic_args(generics: &GenericArgs, buf: &mut dyn Write) ->\n         first = false;\n         print_generic_arg(arg, buf)?;\n     }\n-    for binding in &generics.bindings {\n+    for binding in generics.bindings.iter() {\n         if !first {\n             write!(buf, \", \")?;\n         }"}, {"sha": "9652b01b91bf6bd8f593560ea332904d98f307ca", "filename": "src/tools/rust-analyzer/crates/hir-def/src/type_ref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftype_ref.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -292,7 +292,7 @@ impl TypeRef {\n             }\n             for segment in path.segments().iter() {\n                 if let Some(args_and_bindings) = segment.args_and_bindings {\n-                    for arg in &args_and_bindings.args {\n+                    for arg in args_and_bindings.args.iter() {\n                         match arg {\n                             crate::path::GenericArg::Type(type_ref) => {\n                                 go(type_ref, f);\n@@ -301,11 +301,11 @@ impl TypeRef {\n                             | crate::path::GenericArg::Lifetime(_) => {}\n                         }\n                     }\n-                    for binding in &args_and_bindings.bindings {\n+                    for binding in args_and_bindings.bindings.iter() {\n                         if let Some(type_ref) = &binding.type_ref {\n                             go(type_ref, f);\n                         }\n-                        for bound in &binding.bounds {\n+                        for bound in binding.bounds.iter() {\n                             match bound.as_ref() {\n                                 TypeBound::Path(path, _) | TypeBound::ForLifetime(_, path) => {\n                                     go_path(path, f)"}, {"sha": "5c684be03cf246c21ca2f6e9dfc86593a6739914", "filename": "src/tools/rust-analyzer/crates/hir-expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -21,7 +21,7 @@ itertools = \"0.10.5\"\n hashbrown = { version = \"0.12.1\", features = [\n     \"inline-more\",\n ], default-features = false }\n-smallvec = { version = \"1.10.0\", features = [\"const_new\"] }\n+smallvec.workspace = true\n \n # local deps\n stdx.workspace = true"}, {"sha": "a52716cc02c2589fa459b1d6015e8b1c59747ed8", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -55,6 +55,7 @@ pub type ExpandResult<T> = ValueResult<T, ExpandError>;\n pub enum ExpandError {\n     UnresolvedProcMacro(CrateId),\n     Mbe(mbe::ExpandError),\n+    RecursionOverflowPosioned,\n     Other(Box<str>),\n }\n \n@@ -69,6 +70,9 @@ impl fmt::Display for ExpandError {\n         match self {\n             ExpandError::UnresolvedProcMacro(_) => f.write_str(\"unresolved proc-macro\"),\n             ExpandError::Mbe(it) => it.fmt(f),\n+            ExpandError::RecursionOverflowPosioned => {\n+                f.write_str(\"overflow expanding the original macro\")\n+            }\n             ExpandError::Other(it) => f.write_str(it),\n         }\n     }"}, {"sha": "a8b8d5222e49c58478c8e272ce8635f9d180191a", "filename": "src/tools/rust-analyzer/crates/hir-ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -16,7 +16,7 @@ cov-mark = \"2.0.0-pre.1\"\n itertools = \"0.10.5\"\n arrayvec = \"0.7.2\"\n bitflags = \"1.3.2\"\n-smallvec = \"1.10.0\"\n+smallvec.workspace = true\n ena = \"0.14.0\"\n tracing = \"0.1.35\"\n rustc-hash = \"1.1.0\""}, {"sha": "b22064d8c42e49be63b872eeb35733b276c34256", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/display.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -1419,7 +1419,7 @@ impl HirDisplay for Path {\n \n                 write!(f, \"<\")?;\n                 let mut first = true;\n-                for arg in &generic_args.args {\n+                for arg in generic_args.args.iter() {\n                     if first {\n                         first = false;\n                         if generic_args.has_self_type {\n@@ -1431,7 +1431,7 @@ impl HirDisplay for Path {\n                     }\n                     arg.hir_fmt(f)?;\n                 }\n-                for binding in &generic_args.bindings {\n+                for binding in generic_args.bindings.iter() {\n                     if first {\n                         first = false;\n                     } else {\n@@ -1445,7 +1445,7 @@ impl HirDisplay for Path {\n                         }\n                         None => {\n                             write!(f, \": \")?;\n-                            f.write_joined(&binding.bounds, \" + \")?;\n+                            f.write_joined(binding.bounds.iter(), \" + \")?;\n                         }\n                     }\n                 }"}, {"sha": "299646737221d9cdd97d45d636b51dda9700f4c5", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -1025,7 +1025,7 @@ impl<'a> TyLoweringContext<'a> {\n         last_segment\n             .into_iter()\n             .filter_map(|segment| segment.args_and_bindings)\n-            .flat_map(|args_and_bindings| &args_and_bindings.bindings)\n+            .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n             .flat_map(move |binding| {\n                 let found = associated_type_by_name_including_super_traits(\n                     self.db,\n@@ -1068,7 +1068,7 @@ impl<'a> TyLoweringContext<'a> {\n                         AliasEq { alias: AliasTy::Projection(projection_ty.clone()), ty };\n                     preds.push(crate::wrap_empty_binders(WhereClause::AliasEq(alias_eq)));\n                 }\n-                for bound in &binding.bounds {\n+                for bound in binding.bounds.iter() {\n                     preds.extend(self.lower_type_bound(\n                         bound,\n                         TyKind::Alias(AliasTy::Projection(projection_ty.clone())).intern(Interner),"}, {"sha": "ef40a8902d73f78a4fbba3c75a890095a3296ed3", "filename": "src/tools/rust-analyzer/crates/hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -16,7 +16,7 @@ rustc-hash = \"1.1.0\"\n either = \"1.7.0\"\n arrayvec = \"0.7.2\"\n itertools = \"0.10.5\"\n-smallvec = \"1.10.0\"\n+smallvec.workspace = true\n once_cell = \"1.17.0\"\n \n # local deps"}, {"sha": "447e38f91f43e04bf6ad16f8b8e9c326c0387a31", "filename": "src/tools/rust-analyzer/crates/ide-assists/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -16,7 +16,7 @@ cov-mark = \"2.0.0-pre.1\"\n \n itertools = \"0.10.5\"\n either = \"1.7.0\"\n-smallvec = \"1.10.0\"\n+smallvec.workspace = true\n \n # local deps\n stdx.workspace = true"}, {"sha": "4595cfe29c85d1e5d685523881b9cf2e69d344f0", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_getter.rs", "status": "modified", "additions": 105, "deletions": 2, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -180,7 +180,9 @@ pub(crate) fn generate_getter_impl(\n \n                 // Insert `$0` only for last getter we generate\n                 if i == record_fields_count - 1 {\n-                    getter_buf = getter_buf.replacen(\"fn \", \"fn $0\", 1);\n+                    if ctx.config.snippet_cap.is_some() {\n+                        getter_buf = getter_buf.replacen(\"fn \", \"fn $0\", 1);\n+                    }\n                 }\n \n                 // For first element we do not merge with '\\n', as\n@@ -330,7 +332,7 @@ fn parse_record_field(record_field: ast::RecordField, mutable: bool) -> Option<R\n \n #[cfg(test)]\n mod tests {\n-    use crate::tests::{check_assist, check_assist_not_applicable};\n+    use crate::tests::{check_assist, check_assist_no_snippet_cap, check_assist_not_applicable};\n \n     use super::*;\n \n@@ -377,6 +379,49 @@ impl Context {\n         );\n     }\n \n+    #[test]\n+    fn test_generate_getter_from_field_no_snippet_cap() {\n+        check_assist_no_snippet_cap(\n+            generate_getter,\n+            r#\"\n+struct Context {\n+    dat$0a: Data,\n+}\n+\"#,\n+            r#\"\n+struct Context {\n+    data: Data,\n+}\n+\n+impl Context {\n+    fn data(&self) -> &Data {\n+        &self.data\n+    }\n+}\n+\"#,\n+        );\n+\n+        check_assist_no_snippet_cap(\n+            generate_getter_mut,\n+            r#\"\n+struct Context {\n+    dat$0a: Data,\n+}\n+\"#,\n+            r#\"\n+struct Context {\n+    data: Data,\n+}\n+\n+impl Context {\n+    fn data_mut(&mut self) -> &mut Data {\n+        &mut self.data\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_generate_getter_already_implemented() {\n         check_assist_not_applicable(\n@@ -433,6 +478,29 @@ impl Context {\n         );\n     }\n \n+    #[test]\n+    fn test_generate_getter_from_field_with_visibility_marker_no_snippet_cap() {\n+        check_assist_no_snippet_cap(\n+            generate_getter,\n+            r#\"\n+pub(crate) struct Context {\n+    dat$0a: Data,\n+}\n+\"#,\n+            r#\"\n+pub(crate) struct Context {\n+    data: Data,\n+}\n+\n+impl Context {\n+    pub(crate) fn data(&self) -> &Data {\n+        &self.data\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_multiple_generate_getter() {\n         check_assist(\n@@ -468,6 +536,41 @@ impl Context {\n         );\n     }\n \n+    #[test]\n+    fn test_multiple_generate_getter_no_snippet_cap() {\n+        check_assist_no_snippet_cap(\n+            generate_getter,\n+            r#\"\n+struct Context {\n+    data: Data,\n+    cou$0nt: usize,\n+}\n+\n+impl Context {\n+    fn data(&self) -> &Data {\n+        &self.data\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Context {\n+    data: Data,\n+    count: usize,\n+}\n+\n+impl Context {\n+    fn data(&self) -> &Data {\n+        &self.data\n+    }\n+\n+    fn count(&self) -> &usize {\n+        &self.count\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_not_a_special_case() {\n         cov_mark::check_count!(convert_reference_type, 0);"}, {"sha": "94be99fd7abf896bf06e05958c2a0bfdd60daefc", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -33,6 +33,20 @@ pub(crate) const TEST_CONFIG: AssistConfig = AssistConfig {\n     assist_emit_must_use: false,\n };\n \n+pub(crate) const TEST_CONFIG_NO_SNIPPET_CAP: AssistConfig = AssistConfig {\n+    snippet_cap: None,\n+    allowed: None,\n+    insert_use: InsertUseConfig {\n+        granularity: ImportGranularity::Crate,\n+        prefix_kind: hir::PrefixKind::Plain,\n+        enforce_granularity: true,\n+        group: true,\n+        skip_glob_imports: true,\n+    },\n+    prefer_no_std: false,\n+    assist_emit_must_use: false,\n+};\n+\n pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {\n     RootDatabase::with_single_file(text)\n }\n@@ -43,6 +57,22 @@ pub(crate) fn check_assist(assist: Handler, ra_fixture_before: &str, ra_fixture_\n     check(assist, ra_fixture_before, ExpectedResult::After(&ra_fixture_after), None);\n }\n \n+#[track_caller]\n+pub(crate) fn check_assist_no_snippet_cap(\n+    assist: Handler,\n+    ra_fixture_before: &str,\n+    ra_fixture_after: &str,\n+) {\n+    let ra_fixture_after = trim_indent(ra_fixture_after);\n+    check_with_config(\n+        TEST_CONFIG_NO_SNIPPET_CAP,\n+        assist,\n+        ra_fixture_before,\n+        ExpectedResult::After(&ra_fixture_after),\n+        None,\n+    );\n+}\n+\n // There is no way to choose what assist within a group you want to test against,\n // so this is here to allow you choose.\n pub(crate) fn check_assist_by_label(\n@@ -119,14 +149,24 @@ enum ExpectedResult<'a> {\n \n #[track_caller]\n fn check(handler: Handler, before: &str, expected: ExpectedResult<'_>, assist_label: Option<&str>) {\n+    check_with_config(TEST_CONFIG, handler, before, expected, assist_label);\n+}\n+\n+#[track_caller]\n+fn check_with_config(\n+    config: AssistConfig,\n+    handler: Handler,\n+    before: &str,\n+    expected: ExpectedResult<'_>,\n+    assist_label: Option<&str>,\n+) {\n     let (mut db, file_with_caret_id, range_or_offset) = RootDatabase::with_range_or_offset(before);\n     db.set_enable_proc_attr_macros(true);\n     let text_without_caret = db.file_text(file_with_caret_id).to_string();\n \n     let frange = FileRange { file_id: file_with_caret_id, range: range_or_offset.into() };\n \n     let sema = Semantics::new(&db);\n-    let config = TEST_CONFIG;\n     let ctx = AssistContext::new(sema, &config, frange);\n     let resolve = match expected {\n         ExpectedResult::Unresolved => AssistResolveStrategy::None,"}, {"sha": "092fb303668fe73e7ef3a578f9677fb0e7ef4fb3", "filename": "src/tools/rust-analyzer/crates/ide-completion/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -16,7 +16,7 @@ cov-mark = \"2.0.0-pre.1\"\n itertools = \"0.10.5\"\n \n once_cell = \"1.17.0\"\n-smallvec = \"1.10.0\"\n+smallvec.workspace = true\n \n \n # local deps"}, {"sha": "c55bd9aaae521b250d4d9217c51d1ad6220c7061", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/postfix.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -747,4 +747,16 @@ fn main() {\n             \"#,\n         );\n     }\n+\n+    #[test]\n+    fn no_postfix_completions_in_if_block_that_has_an_else() {\n+        check(\n+            r#\"\n+fn test() {\n+    if true {}.$0 else {}\n+}\n+\"#,\n+            expect![[r#\"\"#]],\n+        );\n+    }\n }"}, {"sha": "ea54068b0f8bf811089e155c078f38a0223b14e8", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -571,28 +571,25 @@ impl<'a> CompletionContext<'a> {\n \n         // try to skip completions on path with invalid colons\n         // this approach works in normal path and inside token tree\n-        match original_token.kind() {\n-            T![:] => {\n-                // return if no prev token before colon\n-                let prev_token = original_token.prev_token()?;\n-\n-                // only has a single colon\n-                if prev_token.kind() != T![:] {\n-                    return None;\n-                }\n+        if original_token.kind() == T![:] {\n+            // return if no prev token before colon\n+            let prev_token = original_token.prev_token()?;\n \n-                // has 3 colon or 2 coloncolon in a row\n-                // special casing this as per discussion in https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1031845205\n-                // and https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1032812751\n-                if prev_token\n-                    .prev_token()\n-                    .map(|t| t.kind() == T![:] || t.kind() == T![::])\n-                    .unwrap_or(false)\n-                {\n-                    return None;\n-                }\n+            // only has a single colon\n+            if prev_token.kind() != T![:] {\n+                return None;\n+            }\n+\n+            // has 3 colon or 2 coloncolon in a row\n+            // special casing this as per discussion in https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1031845205\n+            // and https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1032812751\n+            if prev_token\n+                .prev_token()\n+                .map(|t| t.kind() == T![:] || t.kind() == T![::])\n+                .unwrap_or(false)\n+            {\n+                return None;\n             }\n-            _ => {}\n         }\n \n         let AnalysisResult {"}, {"sha": "db0045aef6e0b23b77b31e3eef799a8e0f83b9ac", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 94, "deletions": 66, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -29,6 +29,7 @@ pub(super) struct AnalysisResult {\n     pub(super) analysis: CompletionAnalysis,\n     pub(super) expected: (Option<Type>, Option<ast::NameOrNameRef>),\n     pub(super) qualifier_ctx: QualifierCtx,\n+    /// the original token of the expanded file\n     pub(super) token: SyntaxToken,\n     pub(super) offset: TextSize,\n }\n@@ -213,15 +214,6 @@ fn analyze(\n     let _p = profile::span(\"CompletionContext::analyze\");\n     let ExpansionResult { original_file, speculative_file, offset, fake_ident_token, derive_ctx } =\n         expansion_result;\n-    let syntax_element = NodeOrToken::Token(fake_ident_token);\n-    if is_in_token_of_for_loop(syntax_element.clone()) {\n-        // for pat $0\n-        // there is nothing to complete here except `in` keyword\n-        // don't bother populating the context\n-        // FIXME: the completion calculations should end up good enough\n-        // such that this special case becomes unnecessary\n-        return None;\n-    }\n \n     // Overwrite the path kind for derives\n     if let Some((original_file, file_with_fake_ident, offset, origin_attr)) = derive_ctx {\n@@ -249,37 +241,35 @@ fn analyze(\n         return None;\n     }\n \n-    let name_like = match find_node_at_offset(&speculative_file, offset) {\n-        Some(it) => it,\n-        None => {\n-            let analysis = if let Some(original) = ast::String::cast(original_token.clone()) {\n-                CompletionAnalysis::String {\n-                    original,\n-                    expanded: ast::String::cast(self_token.clone()),\n+    let Some(name_like) = find_node_at_offset(&speculative_file, offset) else {\n+        let analysis = if let Some(original) = ast::String::cast(original_token.clone()) {\n+            CompletionAnalysis::String {\n+                original,\n+                expanded: ast::String::cast(self_token.clone()),\n+            }\n+        } else {\n+            // Fix up trailing whitespace problem\n+            // #[attr(foo = $0\n+            let token = syntax::algo::skip_trivia_token(self_token.clone(), Direction::Prev)?;\n+            let p = token.parent()?;\n+            if p.kind() == SyntaxKind::TOKEN_TREE\n+                && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n+            {\n+                let colon_prefix = previous_non_trivia_token(self_token.clone())\n+                    .map_or(false, |it| T![:] == it.kind());\n+                CompletionAnalysis::UnexpandedAttrTT {\n+                    fake_attribute_under_caret: fake_ident_token\n+                        .parent_ancestors()\n+                        .find_map(ast::Attr::cast),\n+                    colon_prefix,\n                 }\n             } else {\n-                // Fix up trailing whitespace problem\n-                // #[attr(foo = $0\n-                let token = syntax::algo::skip_trivia_token(self_token.clone(), Direction::Prev)?;\n-                let p = token.parent()?;\n-                if p.kind() == SyntaxKind::TOKEN_TREE\n-                    && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n-                {\n-                    let colon_prefix = previous_non_trivia_token(self_token.clone())\n-                        .map_or(false, |it| T![:] == it.kind());\n-                    CompletionAnalysis::UnexpandedAttrTT {\n-                        fake_attribute_under_caret: syntax_element\n-                            .ancestors()\n-                            .find_map(ast::Attr::cast),\n-                        colon_prefix,\n-                    }\n-                } else {\n-                    return None;\n-                }\n-            };\n-            return Some((analysis, (None, None), QualifierCtx::default()));\n-        }\n+                return None;\n+            }\n+        };\n+        return Some((analysis, (None, None), QualifierCtx::default()));\n     };\n+\n     let expected = expected_type_and_name(sema, self_token, &name_like);\n     let mut qual_ctx = QualifierCtx::default();\n     let analysis = match name_like {\n@@ -290,6 +280,22 @@ fn analyze(\n             let parent = name_ref.syntax().parent()?;\n             let (nameref_ctx, qualifier_ctx) =\n                 classify_name_ref(sema, &original_file, name_ref, parent)?;\n+\n+            if let NameRefContext {\n+                kind:\n+                    NameRefKind::Path(PathCompletionCtx { kind: PathKind::Expr { .. }, path, .. }, ..),\n+                ..\n+            } = &nameref_ctx\n+            {\n+                if is_in_token_of_for_loop(path) {\n+                    // for pat $0\n+                    // there is nothing to complete here except `in` keyword\n+                    // don't bother populating the context\n+                    // Ideally this special casing wouldn't be needed, but the parser recovers\n+                    return None;\n+                }\n+            }\n+\n             qual_ctx = qualifier_ctx;\n             CompletionAnalysis::NameRef(nameref_ctx)\n         }\n@@ -323,16 +329,14 @@ fn expected_type_and_name(\n                     ast::FieldExpr(e) => e\n                         .syntax()\n                         .ancestors()\n-                        .map_while(ast::FieldExpr::cast)\n-                        .last()\n-                        .map(|it| it.syntax().clone()),\n+                        .take_while(|it| ast::FieldExpr::can_cast(it.kind()))\n+                        .last(),\n                     ast::PathSegment(e) => e\n                         .syntax()\n                         .ancestors()\n                         .skip(1)\n                         .take_while(|it| ast::Path::can_cast(it.kind()) || ast::PathExpr::can_cast(it.kind()))\n-                        .find_map(ast::PathExpr::cast)\n-                        .map(|it| it.syntax().clone()),\n+                        .find(|it| ast::PathExpr::can_cast(it.kind())),\n                     _ => None\n                 }\n             };\n@@ -605,6 +609,18 @@ fn classify_name_ref(\n                     },\n                     _ => false,\n                 };\n+\n+                let reciever_is_part_of_indivisible_expression = match &receiver {\n+                    Some(ast::Expr::IfExpr(_)) => {\n+                        let next_token_kind = next_non_trivia_token(name_ref.syntax().clone()).map(|t| t.kind());\n+                        next_token_kind == Some(SyntaxKind::ELSE_KW)\n+                    },\n+                    _ => false\n+                };\n+                if reciever_is_part_of_indivisible_expression {\n+                    return None;\n+                }\n+\n                 let kind = NameRefKind::DotAccess(DotAccess {\n                     receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n                     kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal },\n@@ -656,8 +672,15 @@ fn classify_name_ref(\n     };\n     let after_if_expr = |node: SyntaxNode| {\n         let prev_expr = (|| {\n+            let node = match node.parent().and_then(ast::ExprStmt::cast) {\n+                Some(stmt) => stmt.syntax().clone(),\n+                None => node,\n+            };\n             let prev_sibling = non_trivia_sibling(node.into(), Direction::Prev)?.into_node()?;\n-            ast::ExprStmt::cast(prev_sibling)?.expr()\n+\n+            ast::ExprStmt::cast(prev_sibling.clone())\n+                .and_then(|it| it.expr())\n+                .or_else(|| ast::Expr::cast(prev_sibling))\n         })();\n         matches!(prev_expr, Some(ast::Expr::IfExpr(_)))\n     };\n@@ -1251,40 +1274,29 @@ fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<(ast::Path, bool)> {\n     Some((use_tree.path()?, true))\n }\n \n-pub(crate) fn is_in_token_of_for_loop(element: SyntaxElement) -> bool {\n+fn is_in_token_of_for_loop(path: &ast::Path) -> bool {\n     // oh my ...\n     (|| {\n-        let syntax_token = element.into_token()?;\n-        let range = syntax_token.text_range();\n-        let for_expr = syntax_token.parent_ancestors().find_map(ast::ForExpr::cast)?;\n-\n-        // check if the current token is the `in` token of a for loop\n-        if let Some(token) = for_expr.in_token() {\n-            return Some(syntax_token == token);\n+        let expr = path.syntax().parent().and_then(ast::PathExpr::cast)?;\n+        let for_expr = expr.syntax().parent().and_then(ast::ForExpr::cast)?;\n+        if for_expr.in_token().is_some() {\n+            return Some(false);\n         }\n         let pat = for_expr.pat()?;\n-        if range.end() < pat.syntax().text_range().end() {\n-            // if we are inside or before the pattern we can't be at the `in` token position\n-            return None;\n-        }\n         let next_sibl = next_non_trivia_sibling(pat.syntax().clone().into())?;\n         Some(match next_sibl {\n-            // the loop body is some node, if our token is at the start we are at the `in` position,\n-            // otherwise we could be in a recovered expression, we don't wanna ruin completions there\n-            syntax::NodeOrToken::Node(n) => n.text_range().start() == range.start(),\n-            // the loop body consists of a single token, if we are this we are certainly at the `in` token position\n-            syntax::NodeOrToken::Token(t) => t == syntax_token,\n+            syntax::NodeOrToken::Node(n) => {\n+                n.text_range().start() == path.syntax().text_range().start()\n+            }\n+            syntax::NodeOrToken::Token(t) => {\n+                t.text_range().start() == path.syntax().text_range().start()\n+            }\n         })\n     })()\n     .unwrap_or(false)\n }\n \n-#[test]\n-fn test_for_is_prev2() {\n-    crate::tests::check_pattern_is_applicable(r\"fn __() { for i i$0 }\", is_in_token_of_for_loop);\n-}\n-\n-pub(crate) fn is_in_loop_body(node: &SyntaxNode) -> bool {\n+fn is_in_loop_body(node: &SyntaxNode) -> bool {\n     node.ancestors()\n         .take_while(|it| it.kind() != SyntaxKind::FN && it.kind() != SyntaxKind::CLOSURE_EXPR)\n         .find_map(|it| {\n@@ -1317,6 +1329,22 @@ fn previous_non_trivia_token(e: impl Into<SyntaxElement>) -> Option<SyntaxToken>\n     None\n }\n \n+fn next_non_trivia_token(e: impl Into<SyntaxElement>) -> Option<SyntaxToken> {\n+    let mut token = match e.into() {\n+        SyntaxElement::Node(n) => n.last_token()?,\n+        SyntaxElement::Token(t) => t,\n+    }\n+    .next_token();\n+    while let Some(inner) = token {\n+        if !inner.kind().is_trivia() {\n+            return Some(inner);\n+        } else {\n+            token = inner.next_token();\n+        }\n+    }\n+    None\n+}\n+\n fn next_non_trivia_sibling(ele: SyntaxElement) -> Option<SyntaxElement> {\n     let mut e = ele.next_sibling_or_token();\n     while let Some(inner) = e {"}, {"sha": "2f65491d85e14f920474a0bbea16baf0c2666b7c", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/item.rs", "status": "modified", "additions": 35, "deletions": 69, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fitem.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -14,13 +14,14 @@ use crate::{\n     render::{render_path_resolution, RenderContext},\n };\n \n-/// `CompletionItem` describes a single completion variant in the editor pop-up.\n-/// It is basically a POD with various properties. To construct a\n-/// `CompletionItem`, use `new` method and the `Builder` struct.\n+/// `CompletionItem` describes a single completion entity which expands to 1 or more entries in the\n+/// editor pop-up. It is basically a POD with various properties. To construct a\n+/// [`CompletionItem`], use [`Builder::new`] method and the [`Builder`] struct.\n #[derive(Clone)]\n+#[non_exhaustive]\n pub struct CompletionItem {\n     /// Label in the completion pop up which identifies completion.\n-    label: SmolStr,\n+    pub label: SmolStr,\n     /// Range of identifier that is being completed.\n     ///\n     /// It should be used primarily for UI, but we also use this to convert\n@@ -29,33 +30,33 @@ pub struct CompletionItem {\n     /// `source_range` must contain the completion offset. `text_edit` should\n     /// start with what `source_range` points to, or VSCode will filter out the\n     /// completion silently.\n-    source_range: TextRange,\n+    pub source_range: TextRange,\n     /// What happens when user selects this item.\n     ///\n     /// Typically, replaces `source_range` with new identifier.\n-    text_edit: TextEdit,\n-    is_snippet: bool,\n+    pub text_edit: TextEdit,\n+    pub is_snippet: bool,\n \n     /// What item (struct, function, etc) are we completing.\n-    kind: CompletionItemKind,\n+    pub kind: CompletionItemKind,\n \n     /// Lookup is used to check if completion item indeed can complete current\n     /// ident.\n     ///\n     /// That is, in `foo.bar$0` lookup of `abracadabra` will be accepted (it\n     /// contains `bar` sub sequence), and `quux` will rejected.\n-    lookup: Option<SmolStr>,\n+    pub lookup: Option<SmolStr>,\n \n     /// Additional info to show in the UI pop up.\n-    detail: Option<String>,\n-    documentation: Option<Documentation>,\n+    pub detail: Option<String>,\n+    pub documentation: Option<Documentation>,\n \n     /// Whether this item is marked as deprecated\n-    deprecated: bool,\n+    pub deprecated: bool,\n \n     /// If completing a function call, ask the editor to show parameter popup\n     /// after completion.\n-    trigger_call_info: bool,\n+    pub trigger_call_info: bool,\n \n     /// We use this to sort completion. Relevance records facts like \"do the\n     /// types align precisely?\". We can't sort by relevances directly, they are\n@@ -64,36 +65,39 @@ pub struct CompletionItem {\n     /// Note that Relevance ignores fuzzy match score. We compute Relevance for\n     /// all possible items, and then separately build an ordered completion list\n     /// based on relevance and fuzzy matching with the already typed identifier.\n-    relevance: CompletionRelevance,\n+    pub relevance: CompletionRelevance,\n \n     /// Indicates that a reference or mutable reference to this variable is a\n     /// possible match.\n-    ref_match: Option<(Mutability, TextSize)>,\n+    // FIXME: We shouldn't expose Mutability here (that is HIR types at all), its fine for now though\n+    // until we have more splitting completions in which case we should think about\n+    // generalizing this. See https://github.com/rust-lang/rust-analyzer/issues/12571\n+    pub ref_match: Option<(Mutability, TextSize)>,\n \n     /// The import data to add to completion's edits.\n-    import_to_add: SmallVec<[LocatedImport; 1]>,\n+    pub import_to_add: SmallVec<[LocatedImport; 1]>,\n }\n \n // We use custom debug for CompletionItem to make snapshot tests more readable.\n impl fmt::Debug for CompletionItem {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut s = f.debug_struct(\"CompletionItem\");\n-        s.field(\"label\", &self.label()).field(\"source_range\", &self.source_range());\n-        if self.text_edit().len() == 1 {\n-            let atom = &self.text_edit().iter().next().unwrap();\n+        s.field(\"label\", &self.label).field(\"source_range\", &self.source_range);\n+        if self.text_edit.len() == 1 {\n+            let atom = &self.text_edit.iter().next().unwrap();\n             s.field(\"delete\", &atom.delete);\n             s.field(\"insert\", &atom.insert);\n         } else {\n             s.field(\"text_edit\", &self.text_edit);\n         }\n-        s.field(\"kind\", &self.kind());\n-        if self.lookup() != self.label() {\n+        s.field(\"kind\", &self.kind);\n+        if self.lookup() != self.label {\n             s.field(\"lookup\", &self.lookup());\n         }\n-        if let Some(detail) = self.detail() {\n+        if let Some(detail) = &self.detail {\n             s.field(\"detail\", &detail);\n         }\n-        if let Some(documentation) = self.documentation() {\n+        if let Some(documentation) = &self.documentation {\n             s.field(\"documentation\", &documentation);\n         }\n         if self.deprecated {\n@@ -351,63 +355,25 @@ impl CompletionItem {\n         }\n     }\n \n-    /// What user sees in pop-up in the UI.\n-    pub fn label(&self) -> &str {\n-        &self.label\n-    }\n-    pub fn source_range(&self) -> TextRange {\n-        self.source_range\n-    }\n-\n-    pub fn text_edit(&self) -> &TextEdit {\n-        &self.text_edit\n-    }\n-    /// Whether `text_edit` is a snippet (contains `$0` markers).\n-    pub fn is_snippet(&self) -> bool {\n-        self.is_snippet\n-    }\n-\n-    /// Short one-line additional information, like a type\n-    pub fn detail(&self) -> Option<&str> {\n-        self.detail.as_deref()\n-    }\n-    /// A doc-comment\n-    pub fn documentation(&self) -> Option<Documentation> {\n-        self.documentation.clone()\n-    }\n     /// What string is used for filtering.\n     pub fn lookup(&self) -> &str {\n         self.lookup.as_deref().unwrap_or(&self.label)\n     }\n \n-    pub fn kind(&self) -> CompletionItemKind {\n-        self.kind\n-    }\n-\n-    pub fn deprecated(&self) -> bool {\n-        self.deprecated\n-    }\n-\n-    pub fn relevance(&self) -> CompletionRelevance {\n-        self.relevance\n-    }\n-\n-    pub fn trigger_call_info(&self) -> bool {\n-        self.trigger_call_info\n-    }\n-\n-    pub fn ref_match(&self) -> Option<(Mutability, TextSize, CompletionRelevance)> {\n+    pub fn ref_match(&self) -> Option<(String, text_edit::Indel, CompletionRelevance)> {\n         // Relevance of the ref match should be the same as the original\n         // match, but with exact type match set because self.ref_match\n         // is only set if there is an exact type match.\n         let mut relevance = self.relevance;\n         relevance.type_match = Some(CompletionRelevanceTypeMatch::Exact);\n \n-        self.ref_match.map(|(mutability, offset)| (mutability, offset, relevance))\n-    }\n-\n-    pub fn imports_to_add(&self) -> &[LocatedImport] {\n-        &self.import_to_add\n+        self.ref_match.map(|(mutability, offset)| {\n+            (\n+                format!(\"&{}{}\", mutability.as_keyword_for_ref(), self.label),\n+                text_edit::Indel::insert(offset, format!(\"&{}\", mutability.as_keyword_for_ref())),\n+                relevance,\n+            )\n+        })\n     }\n }\n "}, {"sha": "6fe781114039921d1376418f46a39c561089eed4", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -156,21 +156,23 @@ pub fn completions(\n \n     // prevent `(` from triggering unwanted completion noise\n     if trigger_character == Some('(') {\n-        if let CompletionAnalysis::NameRef(NameRefContext { kind, .. }) = &analysis {\n-            if let NameRefKind::Path(\n-                path_ctx @ PathCompletionCtx { kind: PathKind::Vis { has_in_token }, .. },\n-            ) = kind\n-            {\n-                completions::vis::complete_vis_path(&mut completions, ctx, path_ctx, has_in_token);\n-            }\n+        if let CompletionAnalysis::NameRef(NameRefContext {\n+            kind:\n+                NameRefKind::Path(\n+                    path_ctx @ PathCompletionCtx { kind: PathKind::Vis { has_in_token }, .. },\n+                ),\n+            ..\n+        }) = analysis\n+        {\n+            completions::vis::complete_vis_path(&mut completions, ctx, path_ctx, has_in_token);\n         }\n         return Some(completions.into());\n     }\n \n     {\n         let acc = &mut completions;\n \n-        match &analysis {\n+        match analysis {\n             CompletionAnalysis::Name(name_ctx) => completions::complete_name(acc, ctx, name_ctx),\n             CompletionAnalysis::NameRef(name_ref_ctx) => {\n                 completions::complete_name_ref(acc, ctx, name_ref_ctx)"}, {"sha": "d99ad5f9f04ba14bbf942136c0a5687ad091e12d", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -503,18 +503,18 @@ mod tests {\n     #[track_caller]\n     fn check_relevance_for_kinds(ra_fixture: &str, kinds: &[CompletionItemKind], expect: Expect) {\n         let mut actual = get_all_items(TEST_CONFIG, ra_fixture, None);\n-        actual.retain(|it| kinds.contains(&it.kind()));\n-        actual.sort_by_key(|it| cmp::Reverse(it.relevance().score()));\n+        actual.retain(|it| kinds.contains(&it.kind));\n+        actual.sort_by_key(|it| cmp::Reverse(it.relevance.score()));\n         check_relevance_(actual, expect);\n     }\n \n     #[track_caller]\n     fn check_relevance(ra_fixture: &str, expect: Expect) {\n         let mut actual = get_all_items(TEST_CONFIG, ra_fixture, None);\n-        actual.retain(|it| it.kind() != CompletionItemKind::Snippet);\n-        actual.retain(|it| it.kind() != CompletionItemKind::Keyword);\n-        actual.retain(|it| it.kind() != CompletionItemKind::BuiltinType);\n-        actual.sort_by_key(|it| cmp::Reverse(it.relevance().score()));\n+        actual.retain(|it| it.kind != CompletionItemKind::Snippet);\n+        actual.retain(|it| it.kind != CompletionItemKind::Keyword);\n+        actual.retain(|it| it.kind != CompletionItemKind::BuiltinType);\n+        actual.sort_by_key(|it| cmp::Reverse(it.relevance.score()));\n         check_relevance_(actual, expect);\n     }\n \n@@ -525,12 +525,11 @@ mod tests {\n             .flat_map(|it| {\n                 let mut items = vec![];\n \n-                let tag = it.kind().tag();\n-                let relevance = display_relevance(it.relevance());\n-                items.push(format!(\"{tag} {} {relevance}\\n\", it.label()));\n+                let tag = it.kind.tag();\n+                let relevance = display_relevance(it.relevance);\n+                items.push(format!(\"{tag} {} {relevance}\\n\", it.label));\n \n-                if let Some((mutability, _offset, relevance)) = it.ref_match() {\n-                    let label = format!(\"&{}{}\", mutability.as_keyword_for_ref(), it.label());\n+                if let Some((label, _indel, relevance)) = it.ref_match() {\n                     let relevance = display_relevance(relevance);\n \n                     items.push(format!(\"{tag} {label} {relevance}\\n\"));\n@@ -587,6 +586,7 @@ fn main() { Foo::Fo$0 }\n                         ),\n                         lookup: \"Foo{}\",\n                         detail: \"Foo { x: i32, y: i32 }\",\n+                        trigger_call_info: true,\n                     },\n                 ]\n             \"#]],\n@@ -614,6 +614,7 @@ fn main() { Foo::Fo$0 }\n                         ),\n                         lookup: \"Foo()\",\n                         detail: \"Foo(i32, i32)\",\n+                        trigger_call_info: true,\n                     },\n                 ]\n             \"#]],\n@@ -679,6 +680,7 @@ fn main() { Foo::Fo$0 }\n                             Variant,\n                         ),\n                         detail: \"Foo\",\n+                        trigger_call_info: true,\n                     },\n                 ]\n             \"#]],\n@@ -745,6 +747,7 @@ fn main() { let _: m::Spam = S$0 }\n                             postfix_match: None,\n                             is_definite: false,\n                         },\n+                        trigger_call_info: true,\n                     },\n                     CompletionItem {\n                         label: \"m::Spam::Foo\",\n@@ -770,6 +773,7 @@ fn main() { let _: m::Spam = S$0 }\n                             postfix_match: None,\n                             is_definite: false,\n                         },\n+                        trigger_call_info: true,\n                     },\n                 ]\n             \"#]],\n@@ -942,6 +946,7 @@ use self::E::*;\n                         documentation: Documentation(\n                             \"variant docs\",\n                         ),\n+                        trigger_call_info: true,\n                     },\n                     CompletionItem {\n                         label: \"E\","}, {"sha": "ed78fcd8e6529049c5b4e869a945bd738cb6ce04", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -113,7 +113,7 @@ fn render(\n     item.detail(rendered.detail);\n \n     match snippet_cap {\n-        Some(snippet_cap) => item.insert_snippet(snippet_cap, rendered.literal),\n+        Some(snippet_cap) => item.insert_snippet(snippet_cap, rendered.literal).trigger_call_info(),\n         None => item.insert_text(rendered.literal),\n     };\n "}, {"sha": "6e0c53ec94c437d34d8bb7954e951ba16fa9436e", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/union_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -72,7 +72,7 @@ pub(crate) fn render_union_literal(\n         .set_relevance(ctx.completion_relevance());\n \n     match ctx.snippet_cap() {\n-        Some(snippet_cap) => item.insert_snippet(snippet_cap, literal),\n+        Some(snippet_cap) => item.insert_snippet(snippet_cap, literal).trigger_call_info(),\n         None => item.insert_text(literal),\n     };\n "}, {"sha": "1fe48b9e96f9dcaf5eb69b5dfce0bc09fb8a0987", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -23,15 +23,14 @@ mod type_pos;\n mod use_tree;\n mod visibility;\n \n-use hir::{db::DefDatabase, PrefixKind, Semantics};\n+use hir::{db::DefDatabase, PrefixKind};\n use ide_db::{\n     base_db::{fixture::ChangeFixture, FileLoader, FilePosition},\n     imports::insert_use::{ImportGranularity, InsertUseConfig},\n     RootDatabase, SnippetCap,\n };\n use itertools::Itertools;\n use stdx::{format_to, trim_indent};\n-use syntax::{AstNode, NodeOrToken, SyntaxElement};\n use test_utils::assert_eq_text;\n \n use crate::{\n@@ -109,10 +108,10 @@ fn completion_list_with_config(\n     let items = get_all_items(config, ra_fixture, trigger_character);\n     let items = items\n         .into_iter()\n-        .filter(|it| it.kind() != CompletionItemKind::BuiltinType || it.label() == \"u32\")\n-        .filter(|it| include_keywords || it.kind() != CompletionItemKind::Keyword)\n-        .filter(|it| include_keywords || it.kind() != CompletionItemKind::Snippet)\n-        .sorted_by_key(|it| (it.kind(), it.label().to_owned(), it.detail().map(ToOwned::to_owned)))\n+        .filter(|it| it.kind != CompletionItemKind::BuiltinType || it.label == \"u32\")\n+        .filter(|it| include_keywords || it.kind != CompletionItemKind::Keyword)\n+        .filter(|it| include_keywords || it.kind != CompletionItemKind::Snippet)\n+        .sorted_by_key(|it| (it.kind, it.label.clone(), it.detail.as_ref().map(ToOwned::to_owned)))\n         .collect();\n     render_completion_list(items)\n }\n@@ -139,8 +138,8 @@ pub(crate) fn do_completion_with_config(\n ) -> Vec<CompletionItem> {\n     get_all_items(config, code, None)\n         .into_iter()\n-        .filter(|c| c.kind() == kind)\n-        .sorted_by(|l, r| l.label().cmp(r.label()))\n+        .filter(|c| c.kind == kind)\n+        .sorted_by(|l, r| l.label.cmp(&r.label))\n         .collect()\n }\n \n@@ -149,18 +148,18 @@ fn render_completion_list(completions: Vec<CompletionItem>) -> String {\n         s.chars().count()\n     }\n     let label_width =\n-        completions.iter().map(|it| monospace_width(it.label())).max().unwrap_or_default().min(22);\n+        completions.iter().map(|it| monospace_width(&it.label)).max().unwrap_or_default().min(22);\n     completions\n         .into_iter()\n         .map(|it| {\n-            let tag = it.kind().tag();\n-            let var_name = format!(\"{tag} {}\", it.label());\n+            let tag = it.kind.tag();\n+            let var_name = format!(\"{tag} {}\", it.label);\n             let mut buf = var_name;\n-            if let Some(detail) = it.detail() {\n-                let width = label_width.saturating_sub(monospace_width(it.label()));\n+            if let Some(detail) = it.detail {\n+                let width = label_width.saturating_sub(monospace_width(&it.label));\n                 format_to!(buf, \"{:width$} {}\", \"\", detail, width = width);\n             }\n-            if it.deprecated() {\n+            if it.deprecated {\n                 format_to!(buf, \" DEPRECATED\");\n             }\n             format_to!(buf, \"\\n\");\n@@ -192,13 +191,13 @@ pub(crate) fn check_edit_with_config(\n         .unwrap_or_else(|| panic!(\"can't find {what:?} completion in {completions:#?}\"));\n     let mut actual = db.file_text(position.file_id).to_string();\n \n-    let mut combined_edit = completion.text_edit().to_owned();\n+    let mut combined_edit = completion.text_edit.clone();\n \n     resolve_completion_edits(\n         &db,\n         &config,\n         position,\n-        completion.imports_to_add().iter().filter_map(|import_edit| {\n+        completion.import_to_add.iter().filter_map(|import_edit| {\n             let import_path = &import_edit.import_path;\n             let import_name = import_path.segments().last()?;\n             Some((import_path.to_string(), import_name.to_string()))\n@@ -216,15 +215,6 @@ pub(crate) fn check_edit_with_config(\n     assert_eq_text!(&ra_fixture_after, &actual)\n }\n \n-pub(crate) fn check_pattern_is_applicable(code: &str, check: impl FnOnce(SyntaxElement) -> bool) {\n-    let (db, pos) = position(code);\n-\n-    let sema = Semantics::new(&db);\n-    let original_file = sema.parse(pos.file_id);\n-    let token = original_file.syntax().token_at_offset(pos.offset).left_biased().unwrap();\n-    assert!(check(NodeOrToken::Token(token)));\n-}\n-\n pub(crate) fn get_all_items(\n     config: CompletionConfig,\n     code: &str,\n@@ -235,7 +225,7 @@ pub(crate) fn get_all_items(\n         .map_or_else(Vec::default, Into::into);\n     // validate\n     res.iter().for_each(|it| {\n-        let sr = it.source_range();\n+        let sr = it.source_range;\n         assert!(\n             sr.contains_inclusive(position.offset),\n             \"source range {sr:?} does not contain the offset {:?} of the completion request: {it:?}\",\n@@ -246,8 +236,9 @@ pub(crate) fn get_all_items(\n }\n \n #[test]\n-fn test_no_completions_required() {\n+fn test_no_completions_in_for_loop_in_kw_pos() {\n     assert_eq!(completion_list(r#\"fn foo() { for i i$0 }\"#), String::new());\n+    assert_eq!(completion_list(r#\"fn foo() { for i in$0 }\"#), String::new());\n }\n \n #[test]"}, {"sha": "c1c6a689eb18a29a2e3e10e339dcb300ac0f99be", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/expression.rs", "status": "modified", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -745,3 +745,255 @@ fn return_value_no_block() {\n         r#\"fn f() -> i32 { match () { () => return $0 } }\"#,\n     );\n }\n+\n+#[test]\n+fn else_completion_after_if() {\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} $0 }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} el$0 }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { bar(if foo {} $0) }\n+\"#,\n+        expect![[r#\"\n+            fn foo()     fn()\n+            bt u32\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw false\n+            kw for\n+            kw if\n+            kw if let\n+            kw loop\n+            kw match\n+            kw return\n+            kw self::\n+            kw true\n+            kw unsafe\n+            kw while\n+            kw while let\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { bar(if foo {} el$0) }\n+\"#,\n+        expect![[r#\"\n+            fn foo()     fn()\n+            bt u32\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw false\n+            kw for\n+            kw if\n+            kw if let\n+            kw loop\n+            kw match\n+            kw return\n+            kw self::\n+            kw true\n+            kw unsafe\n+            kw while\n+            kw while let\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} $0 let x = 92; }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} el$0 let x = 92; }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} el$0 { let x = 92; } }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+}"}, {"sha": "cb71c7b2bdef3ff6a87e8c0d19afafff2de57a91", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -2,13 +2,20 @@\n \n use expect_test::{expect, Expect};\n \n-use crate::tests::{check_edit, completion_list_no_kw, completion_list_with_trigger_character};\n+use crate::tests::{\n+    check_edit, completion_list, completion_list_no_kw, completion_list_with_trigger_character,\n+};\n \n-fn check(ra_fixture: &str, expect: Expect) {\n+fn check_no_kw(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list_no_kw(ra_fixture);\n     expect.assert_eq(&actual)\n }\n \n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(ra_fixture);\n+    expect.assert_eq(&actual)\n+}\n+\n pub(crate) fn check_with_trigger_character(\n     ra_fixture: &str,\n     trigger_character: Option<char>,\n@@ -59,7 +66,7 @@ fn _alpha() {}\n \n #[test]\n fn completes_prelude() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /main.rs edition:2018 crate:main deps:std\n fn foo() { let x: $0 }\n@@ -81,7 +88,7 @@ pub mod prelude {\n \n #[test]\n fn completes_prelude_macros() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /main.rs edition:2018 crate:main deps:std\n fn f() {$0}\n@@ -110,7 +117,7 @@ mod macros {\n \n #[test]\n fn completes_std_prelude_if_core_is_defined() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /main.rs crate:main deps:core,std\n fn foo() { let x: $0 }\n@@ -140,7 +147,7 @@ pub mod prelude {\n \n #[test]\n fn respects_doc_hidden() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib deps:std\n fn f() {\n@@ -168,7 +175,7 @@ pub mod prelude {\n \n #[test]\n fn respects_doc_hidden_in_assoc_item_list() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib deps:std\n struct S;\n@@ -195,7 +202,7 @@ pub mod prelude {\n \n #[test]\n fn associated_item_visibility() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib new_source_root:library\n pub struct S;\n@@ -222,7 +229,7 @@ fn foo() { let _ = lib::S::$0 }\n \n #[test]\n fn completes_union_associated_method() {\n-    check(\n+    check_no_kw(\n         r#\"\n union U {};\n impl U { fn m() { } }\n@@ -237,7 +244,7 @@ fn foo() { let _ = U::$0 }\n \n #[test]\n fn completes_trait_associated_method_1() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Trait { fn m(); }\n \n@@ -251,7 +258,7 @@ fn foo() { let _ = Trait::$0 }\n \n #[test]\n fn completes_trait_associated_method_2() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Trait { fn m(); }\n \n@@ -268,7 +275,7 @@ fn foo() { let _ = S::$0 }\n \n #[test]\n fn completes_trait_associated_method_3() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Trait { fn m(); }\n \n@@ -285,7 +292,7 @@ fn foo() { let _ = <S as Trait>::$0 }\n \n #[test]\n fn completes_ty_param_assoc_ty() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Super {\n     type Ty;\n@@ -318,7 +325,7 @@ fn foo<T: Sub>() { T::$0 }\n \n #[test]\n fn completes_self_param_assoc_ty() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Super {\n     type Ty;\n@@ -358,7 +365,7 @@ impl<T> Sub for Wrap<T> {\n \n #[test]\n fn completes_type_alias() {\n-    check(\n+    check_no_kw(\n         r#\"\n struct S;\n impl S { fn foo() {} }\n@@ -376,7 +383,7 @@ fn main() { T::$0; }\n \n #[test]\n fn completes_qualified_macros() {\n-    check(\n+    check_no_kw(\n         r#\"\n #[macro_export]\n macro_rules! foo { () => {} }\n@@ -392,7 +399,7 @@ fn main() { let _ = crate::$0 }\n \n #[test]\n fn does_not_complete_non_fn_macros() {\n-    check(\n+    check_no_kw(\n         r#\"\n mod m {\n     #[rustc_builtin_macro]\n@@ -403,7 +410,7 @@ fn f() {m::$0}\n \"#,\n         expect![[r#\"\"#]],\n     );\n-    check(\n+    check_no_kw(\n         r#\"\n mod m {\n     #[rustc_builtin_macro]\n@@ -418,7 +425,7 @@ fn f() {m::$0}\n \n #[test]\n fn completes_reexported_items_under_correct_name() {\n-    check(\n+    check_no_kw(\n         r#\"\n fn foo() { self::m::$0 }\n \n@@ -475,7 +482,7 @@ mod p {\n \n #[test]\n fn completes_in_simple_macro_call() {\n-    check(\n+    check_no_kw(\n         r#\"\n macro_rules! m { ($e:expr) => { $e } }\n fn main() { m!(self::f$0); }\n@@ -490,7 +497,7 @@ fn foo() {}\n \n #[test]\n fn function_mod_share_name() {\n-    check(\n+    check_no_kw(\n         r#\"\n fn foo() { self::m::$0 }\n \n@@ -508,7 +515,7 @@ mod m {\n \n #[test]\n fn completes_hashmap_new() {\n-    check(\n+    check_no_kw(\n         r#\"\n struct RandomState;\n struct HashMap<K, V, S = RandomState> {}\n@@ -529,7 +536,7 @@ fn foo() {\n #[test]\n fn completes_variant_through_self() {\n     cov_mark::check!(completes_variant_through_self);\n-    check(\n+    check_no_kw(\n         r#\"\n enum Foo {\n     Bar,\n@@ -552,7 +559,7 @@ impl Foo {\n \n #[test]\n fn completes_non_exhaustive_variant_within_the_defining_crate() {\n-    check(\n+    check_no_kw(\n         r#\"\n enum Foo {\n     #[non_exhaustive]\n@@ -570,7 +577,7 @@ fn foo(self) {\n             \"#]],\n     );\n \n-    check(\n+    check_no_kw(\n         r#\"\n //- /main.rs crate:main deps:e\n fn foo(self) {\n@@ -593,7 +600,7 @@ enum Foo {\n #[test]\n fn completes_primitive_assoc_const() {\n     cov_mark::check!(completes_primitive_assoc_const);\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib deps:core\n fn f() {\n@@ -618,7 +625,7 @@ impl u8 {\n #[test]\n fn completes_variant_through_alias() {\n     cov_mark::check!(completes_variant_through_alias);\n-    check(\n+    check_no_kw(\n         r#\"\n enum Foo {\n     Bar\n@@ -636,7 +643,7 @@ fn main() {\n \n #[test]\n fn respects_doc_hidden2() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib deps:dep\n fn f() {\n@@ -665,7 +672,7 @@ pub mod m {}\n \n #[test]\n fn type_anchor_empty() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Foo {\n     fn foo() -> Self;\n@@ -688,7 +695,7 @@ fn bar() -> Bar {\n \n #[test]\n fn type_anchor_type() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Foo {\n     fn foo() -> Self;\n@@ -715,7 +722,7 @@ fn bar() -> Bar {\n \n #[test]\n fn type_anchor_type_trait() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Foo {\n     fn foo() -> Self;\n@@ -741,7 +748,7 @@ fn bar() -> Bar {\n \n #[test]\n fn completes_fn_in_pub_trait_generated_by_macro() {\n-    check(\n+    check_no_kw(\n         r#\"\n mod other_mod {\n     macro_rules! make_method {\n@@ -775,7 +782,7 @@ fn main() {\n \n #[test]\n fn completes_fn_in_pub_trait_generated_by_recursive_macro() {\n-    check(\n+    check_no_kw(\n         r#\"\n mod other_mod {\n     macro_rules! make_method {\n@@ -815,7 +822,7 @@ fn main() {\n \n #[test]\n fn completes_const_in_pub_trait_generated_by_macro() {\n-    check(\n+    check_no_kw(\n         r#\"\n mod other_mod {\n     macro_rules! make_const {\n@@ -847,7 +854,7 @@ fn main() {\n \n #[test]\n fn completes_locals_from_macros() {\n-    check(\n+    check_no_kw(\n         r#\"\n \n macro_rules! x {\n@@ -875,7 +882,7 @@ fn main() {\n \n #[test]\n fn regression_12644() {\n-    check(\n+    check_no_kw(\n         r#\"\n macro_rules! __rust_force_expr {\n     ($e:expr) => {\n@@ -974,7 +981,7 @@ fn foo { crate:::$0 }\n \"#,\n         expect![\"\"],\n     );\n-    check(\n+    check_no_kw(\n         r#\"\n fn foo { crate::::$0 }\n \"#,"}, {"sha": "57daaf623df29864c47bbe1bc1f9841fc8066316", "filename": "src/tools/rust-analyzer/crates/ide-db/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -37,8 +37,9 @@ text-edit.workspace = true\n hir.workspace = true\n \n [dev-dependencies]\n-xshell = \"0.2.2\"\n expect-test = \"1.4.0\"\n+oorandom = \"11.1.3\"\n+xshell = \"0.2.2\"\n \n # local deps\n test-utils.workspace = true"}, {"sha": "2b6b60547b355e9bb41f6f381f479f8101ddbbc4", "filename": "src/tools/rust-analyzer/crates/ide-db/src/active_parameter.rs", "status": "modified", "additions": 73, "deletions": 7, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Factive_parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Factive_parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Factive_parameter.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -2,9 +2,10 @@\n \n use either::Either;\n use hir::{Semantics, Type};\n+use parser::T;\n use syntax::{\n     ast::{self, HasArgList, HasName},\n-    AstNode, SyntaxToken,\n+    match_ast, AstNode, NodeOrToken, SyntaxToken,\n };\n \n use crate::RootDatabase;\n@@ -58,21 +59,86 @@ pub fn callable_for_node(\n     calling_node: &ast::CallableExpr,\n     token: &SyntaxToken,\n ) -> Option<(hir::Callable, Option<usize>)> {\n-    let callable = match &calling_node {\n+    let callable = match calling_node {\n         ast::CallableExpr::Call(call) => {\n             let expr = call.expr()?;\n             sema.type_of_expr(&expr)?.adjusted().as_callable(sema.db)\n         }\n         ast::CallableExpr::MethodCall(call) => sema.resolve_method_call_as_callable(call),\n     }?;\n     let active_param = if let Some(arg_list) = calling_node.arg_list() {\n-        let param = arg_list\n-            .args()\n-            .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n-            .count();\n-        Some(param)\n+        Some(\n+            arg_list\n+                .syntax()\n+                .children_with_tokens()\n+                .filter_map(NodeOrToken::into_token)\n+                .filter(|t| t.kind() == T![,])\n+                .take_while(|t| t.text_range().start() <= token.text_range().start())\n+                .count(),\n+        )\n     } else {\n         None\n     };\n     Some((callable, active_param))\n }\n+\n+pub fn generic_def_for_node(\n+    sema: &Semantics<'_, RootDatabase>,\n+    generic_arg_list: &ast::GenericArgList,\n+    token: &SyntaxToken,\n+) -> Option<(hir::GenericDef, usize, bool)> {\n+    let parent = generic_arg_list.syntax().parent()?;\n+    let def = match_ast! {\n+        match parent {\n+            ast::PathSegment(ps) => {\n+                let res = sema.resolve_path(&ps.parent_path())?;\n+                let generic_def: hir::GenericDef = match res {\n+                    hir::PathResolution::Def(hir::ModuleDef::Adt(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::Function(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::Trait(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::TypeAlias(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::Variant(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::BuiltinType(_))\n+                    | hir::PathResolution::Def(hir::ModuleDef::Const(_))\n+                    | hir::PathResolution::Def(hir::ModuleDef::Macro(_))\n+                    | hir::PathResolution::Def(hir::ModuleDef::Module(_))\n+                    | hir::PathResolution::Def(hir::ModuleDef::Static(_)) => return None,\n+                    hir::PathResolution::BuiltinAttr(_)\n+                    | hir::PathResolution::ToolModule(_)\n+                    | hir::PathResolution::Local(_)\n+                    | hir::PathResolution::TypeParam(_)\n+                    | hir::PathResolution::ConstParam(_)\n+                    | hir::PathResolution::SelfType(_)\n+                    | hir::PathResolution::DeriveHelper(_) => return None,\n+                };\n+\n+                generic_def\n+            },\n+            ast::AssocTypeArg(_) => {\n+                // FIXME: We don't record the resolutions for this anywhere atm\n+                return None;\n+            },\n+            ast::MethodCallExpr(mcall) => {\n+                // recv.method::<$0>()\n+                let method = sema.resolve_method_call(&mcall)?;\n+                method.into()\n+            },\n+            _ => return None,\n+        }\n+    };\n+\n+    let active_param = generic_arg_list\n+        .syntax()\n+        .children_with_tokens()\n+        .filter_map(NodeOrToken::into_token)\n+        .filter(|t| t.kind() == T![,])\n+        .take_while(|t| t.text_range().start() <= token.text_range().start())\n+        .count();\n+\n+    let first_arg_is_non_lifetime = generic_arg_list\n+        .generic_args()\n+        .next()\n+        .map_or(false, |arg| !matches!(arg, ast::GenericArg::LifetimeArg(_)));\n+\n+    Some((def, active_param, first_arg_is_non_lifetime))\n+}"}, {"sha": "16814a1e636fa2e51376bd86cafb7ab0d3215927", "filename": "src/tools/rust-analyzer/crates/ide-db/src/line_index.rs", "status": "modified", "additions": 103, "deletions": 92, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -7,56 +7,72 @@ use syntax::{TextRange, TextSize};\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct LineIndex {\n-    /// Offset the the beginning of each line, zero-based\n+    /// Offset the beginning of each line, zero-based.\n     pub(crate) newlines: Vec<TextSize>,\n-    /// List of non-ASCII characters on each line\n-    pub(crate) utf16_lines: NoHashHashMap<u32, Vec<Utf16Char>>,\n+    /// List of non-ASCII characters on each line.\n+    pub(crate) line_wide_chars: NoHashHashMap<u32, Vec<WideChar>>,\n }\n \n+/// Line/Column information in native, utf8 format.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct LineColUtf16 {\n+pub struct LineCol {\n     /// Zero-based\n     pub line: u32,\n-    /// Zero-based\n+    /// Zero-based utf8 offset\n     pub col: u32,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct LineCol {\n+pub enum WideEncoding {\n+    Utf16,\n+    Utf32,\n+}\n+\n+/// Line/Column information in legacy encodings.\n+///\n+/// Deliberately not a generic type and different from `LineCol`.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct WideLineCol {\n     /// Zero-based\n     pub line: u32,\n-    /// Zero-based utf8 offset\n+    /// Zero-based\n     pub col: u32,\n }\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n-pub(crate) struct Utf16Char {\n+pub(crate) struct WideChar {\n     /// Start offset of a character inside a line, zero-based\n     pub(crate) start: TextSize,\n     /// End offset of a character inside a line, zero-based\n     pub(crate) end: TextSize,\n }\n \n-impl Utf16Char {\n+impl WideChar {\n     /// Returns the length in 8-bit UTF-8 code units.\n     fn len(&self) -> TextSize {\n         self.end - self.start\n     }\n \n-    /// Returns the length in 16-bit UTF-16 code units.\n-    fn len_utf16(&self) -> usize {\n-        if self.len() == TextSize::from(4) {\n-            2\n-        } else {\n-            1\n+    /// Returns the length in UTF-16 or UTF-32 code units.\n+    fn wide_len(&self, enc: WideEncoding) -> usize {\n+        match enc {\n+            WideEncoding::Utf16 => {\n+                if self.len() == TextSize::from(4) {\n+                    2\n+                } else {\n+                    1\n+                }\n+            }\n+\n+            WideEncoding::Utf32 => 1,\n         }\n     }\n }\n \n impl LineIndex {\n     pub fn new(text: &str) -> LineIndex {\n-        let mut utf16_lines = NoHashHashMap::default();\n-        let mut utf16_chars = Vec::new();\n+        let mut line_wide_chars = NoHashHashMap::default();\n+        let mut wide_chars = Vec::new();\n \n         let mut newlines = Vec::with_capacity(16);\n         newlines.push(TextSize::from(0));\n@@ -71,8 +87,8 @@ impl LineIndex {\n                 newlines.push(curr_row);\n \n                 // Save any utf-16 characters seen in the previous line\n-                if !utf16_chars.is_empty() {\n-                    utf16_lines.insert(line, mem::take(&mut utf16_chars));\n+                if !wide_chars.is_empty() {\n+                    line_wide_chars.insert(line, mem::take(&mut wide_chars));\n                 }\n \n                 // Prepare for processing the next line\n@@ -82,18 +98,18 @@ impl LineIndex {\n             }\n \n             if !c.is_ascii() {\n-                utf16_chars.push(Utf16Char { start: curr_col, end: curr_col + c_len });\n+                wide_chars.push(WideChar { start: curr_col, end: curr_col + c_len });\n             }\n \n             curr_col += c_len;\n         }\n \n         // Save any utf-16 characters seen in the last line\n-        if !utf16_chars.is_empty() {\n-            utf16_lines.insert(line, utf16_chars);\n+        if !wide_chars.is_empty() {\n+            line_wide_chars.insert(line, wide_chars);\n         }\n \n-        LineIndex { newlines, utf16_lines }\n+        LineIndex { newlines, line_wide_chars }\n     }\n \n     pub fn line_col(&self, offset: TextSize) -> LineCol {\n@@ -109,13 +125,13 @@ impl LineIndex {\n             .map(|offset| offset + TextSize::from(line_col.col))\n     }\n \n-    pub fn to_utf16(&self, line_col: LineCol) -> LineColUtf16 {\n-        let col = self.utf8_to_utf16_col(line_col.line, line_col.col.into());\n-        LineColUtf16 { line: line_col.line, col: col as u32 }\n+    pub fn to_wide(&self, enc: WideEncoding, line_col: LineCol) -> WideLineCol {\n+        let col = self.utf8_to_wide_col(enc, line_col.line, line_col.col.into());\n+        WideLineCol { line: line_col.line, col: col as u32 }\n     }\n \n-    pub fn to_utf8(&self, line_col: LineColUtf16) -> LineCol {\n-        let col = self.utf16_to_utf8_col(line_col.line, line_col.col);\n+    pub fn to_utf8(&self, enc: WideEncoding, line_col: WideLineCol) -> LineCol {\n+        let col = self.wide_to_utf8_col(enc, line_col.line, line_col.col);\n         LineCol { line: line_col.line, col: col.into() }\n     }\n \n@@ -132,12 +148,12 @@ impl LineIndex {\n             .filter(|it| !it.is_empty())\n     }\n \n-    fn utf8_to_utf16_col(&self, line: u32, col: TextSize) -> usize {\n+    fn utf8_to_wide_col(&self, enc: WideEncoding, line: u32, col: TextSize) -> usize {\n         let mut res: usize = col.into();\n-        if let Some(utf16_chars) = self.utf16_lines.get(&line) {\n-            for c in utf16_chars {\n+        if let Some(wide_chars) = self.line_wide_chars.get(&line) {\n+            for c in wide_chars {\n                 if c.end <= col {\n-                    res -= usize::from(c.len()) - c.len_utf16();\n+                    res -= usize::from(c.len()) - c.wide_len(enc);\n                 } else {\n                     // From here on, all utf16 characters come *after* the character we are mapping,\n                     // so we don't need to take them into account\n@@ -148,11 +164,11 @@ impl LineIndex {\n         res\n     }\n \n-    fn utf16_to_utf8_col(&self, line: u32, mut col: u32) -> TextSize {\n-        if let Some(utf16_chars) = self.utf16_lines.get(&line) {\n-            for c in utf16_chars {\n+    fn wide_to_utf8_col(&self, enc: WideEncoding, line: u32, mut col: u32) -> TextSize {\n+        if let Some(wide_chars) = self.line_wide_chars.get(&line) {\n+            for c in wide_chars {\n                 if col > u32::from(c.start) {\n-                    col += u32::from(c.len()) - c.len_utf16() as u32;\n+                    col += u32::from(c.len()) - c.wide_len(enc) as u32;\n                 } else {\n                     // From here on, all utf16 characters come *after* the character we are mapping,\n                     // so we don't need to take them into account\n@@ -167,6 +183,9 @@ impl LineIndex {\n \n #[cfg(test)]\n mod tests {\n+    use test_utils::skip_slow_tests;\n+\n+    use super::WideEncoding::{Utf16, Utf32};\n     use super::*;\n \n     #[test]\n@@ -210,67 +229,59 @@ mod tests {\n const C: char = 'x';\n \",\n         );\n-        assert_eq!(col_index.utf16_lines.len(), 0);\n+        assert_eq!(col_index.line_wide_chars.len(), 0);\n     }\n \n     #[test]\n-    fn test_single_char() {\n-        let col_index = LineIndex::new(\n-            \"\n-const C: char = '\u30e1';\n-\",\n-        );\n-\n-        assert_eq!(col_index.utf16_lines.len(), 1);\n-        assert_eq!(col_index.utf16_lines[&1].len(), 1);\n-        assert_eq!(col_index.utf16_lines[&1][0], Utf16Char { start: 17.into(), end: 20.into() });\n-\n-        // UTF-8 to UTF-16, no changes\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 15.into()), 15);\n-\n-        // UTF-8 to UTF-16\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 22.into()), 20);\n-\n-        // UTF-16 to UTF-8, no changes\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 15), TextSize::from(15));\n-\n-        // UTF-16 to UTF-8\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 19), TextSize::from(21));\n-\n-        let col_index = LineIndex::new(\"a\ud801\udc0fb\");\n-        assert_eq!(col_index.utf16_to_utf8_col(0, 3), TextSize::from(5));\n-    }\n-\n-    #[test]\n-    fn test_string() {\n-        let col_index = LineIndex::new(\n-            \"\n-const C: char = \\\"\u30e1 \u30e1\\\";\n-\",\n-        );\n-\n-        assert_eq!(col_index.utf16_lines.len(), 1);\n-        assert_eq!(col_index.utf16_lines[&1].len(), 2);\n-        assert_eq!(col_index.utf16_lines[&1][0], Utf16Char { start: 17.into(), end: 20.into() });\n-        assert_eq!(col_index.utf16_lines[&1][1], Utf16Char { start: 21.into(), end: 24.into() });\n-\n-        // UTF-8 to UTF-16\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 15.into()), 15);\n-\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 21.into()), 19);\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 25.into()), 21);\n-\n-        assert!(col_index.utf8_to_utf16_col(2, 15.into()) == 15);\n-\n-        // UTF-16 to UTF-8\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 15), TextSize::from(15));\n+    fn test_every_chars() {\n+        if skip_slow_tests() {\n+            return;\n+        }\n \n-        // \u30e1 UTF-8: 0xE3 0x83 0xA1, UTF-16: 0x30E1\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 17), TextSize::from(17)); // first \u30e1 at 17..20\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 18), TextSize::from(20)); // space\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 19), TextSize::from(21)); // second \u30e1 at 21..24\n+        let text: String = {\n+            let mut chars: Vec<char> = ((0 as char)..char::MAX).collect(); // Neat!\n+            chars.extend(\"\\n\".repeat(chars.len() / 16).chars());\n+            let mut rng = oorandom::Rand32::new(stdx::rand::seed());\n+            stdx::rand::shuffle(&mut chars, |i| rng.rand_range(0..i as u32) as usize);\n+            chars.into_iter().collect()\n+        };\n+        assert!(text.contains('\ud83d\udca9')); // Sanity check.\n+\n+        let line_index = LineIndex::new(&text);\n+\n+        let mut lin_col = LineCol { line: 0, col: 0 };\n+        let mut col_utf16 = 0;\n+        let mut col_utf32 = 0;\n+        for (offset, c) in text.char_indices() {\n+            let got_offset = line_index.offset(lin_col).unwrap();\n+            assert_eq!(usize::from(got_offset), offset);\n+\n+            let got_lin_col = line_index.line_col(got_offset);\n+            assert_eq!(got_lin_col, lin_col);\n+\n+            for enc in [Utf16, Utf32] {\n+                let wide_lin_col = line_index.to_wide(enc, lin_col);\n+                let got_lin_col = line_index.to_utf8(enc, wide_lin_col);\n+                assert_eq!(got_lin_col, lin_col);\n+\n+                let want_col = match enc {\n+                    Utf16 => col_utf16,\n+                    Utf32 => col_utf32,\n+                };\n+                assert_eq!(wide_lin_col.col, want_col)\n+            }\n \n-        assert_eq!(col_index.utf16_to_utf8_col(2, 15), TextSize::from(15));\n+            if c == '\\n' {\n+                lin_col.line += 1;\n+                lin_col.col = 0;\n+                col_utf16 = 0;\n+                col_utf32 = 0;\n+            } else {\n+                lin_col.col += c.len_utf8() as u32;\n+                col_utf16 += c.len_utf16() as u32;\n+                col_utf32 += 1;\n+            }\n+        }\n     }\n \n     #[test]"}, {"sha": "c18a27f17d22cdcd5253299a59484405b04b28fc", "filename": "src/tools/rust-analyzer/crates/ide-db/src/search.rs", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -455,46 +455,45 @@ impl<'a> FindUsages<'a> {\n         }\n \n         let find_nodes = move |name: &str, node: &syntax::SyntaxNode, offset: TextSize| {\n-            node.token_at_offset(offset).find(|it| it.text() == name).map(|token| {\n-                // FIXME: There should be optimization potential here\n-                // Currently we try to descend everything we find which\n-                // means we call `Semantics::descend_into_macros` on\n-                // every textual hit. That function is notoriously\n-                // expensive even for things that do not get down mapped\n-                // into macros.\n-                sema.descend_into_macros(token).into_iter().filter_map(|it| it.parent())\n-            })\n+            node.token_at_offset(offset)\n+                .find(|it| {\n+                    // `name` is stripped of raw ident prefix. See the comment on name retrieval above.\n+                    it.text().trim_start_matches(\"r#\") == name\n+                })\n+                .into_iter()\n+                .flat_map(|token| {\n+                    // FIXME: There should be optimization potential here\n+                    // Currently we try to descend everything we find which\n+                    // means we call `Semantics::descend_into_macros` on\n+                    // every textual hit. That function is notoriously\n+                    // expensive even for things that do not get down mapped\n+                    // into macros.\n+                    sema.descend_into_macros(token).into_iter().filter_map(|it| it.parent())\n+                })\n         };\n \n         for (text, file_id, search_range) in scope_files(sema, &search_scope) {\n             let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n             // Search for occurrences of the items name\n             for offset in match_indices(&text, finder, search_range) {\n-                if let Some(iter) = find_nodes(name, &tree, offset) {\n-                    for name in iter.filter_map(ast::NameLike::cast) {\n-                        if match name {\n-                            ast::NameLike::NameRef(name_ref) => {\n-                                self.found_name_ref(&name_ref, sink)\n-                            }\n-                            ast::NameLike::Name(name) => self.found_name(&name, sink),\n-                            ast::NameLike::Lifetime(lifetime) => {\n-                                self.found_lifetime(&lifetime, sink)\n-                            }\n-                        } {\n-                            return;\n-                        }\n+                for name in find_nodes(name, &tree, offset).filter_map(ast::NameLike::cast) {\n+                    if match name {\n+                        ast::NameLike::NameRef(name_ref) => self.found_name_ref(&name_ref, sink),\n+                        ast::NameLike::Name(name) => self.found_name(&name, sink),\n+                        ast::NameLike::Lifetime(lifetime) => self.found_lifetime(&lifetime, sink),\n+                    } {\n+                        return;\n                     }\n                 }\n             }\n             // Search for occurrences of the `Self` referring to our type\n             if let Some((self_ty, finder)) = &include_self_kw_refs {\n                 for offset in match_indices(&text, finder, search_range) {\n-                    if let Some(iter) = find_nodes(\"Self\", &tree, offset) {\n-                        for name_ref in iter.filter_map(ast::NameRef::cast) {\n-                            if self.found_self_ty_name_ref(self_ty, &name_ref, sink) {\n-                                return;\n-                            }\n+                    for name_ref in find_nodes(\"Self\", &tree, offset).filter_map(ast::NameRef::cast)\n+                    {\n+                        if self.found_self_ty_name_ref(self_ty, &name_ref, sink) {\n+                            return;\n                         }\n                     }\n                 }\n@@ -513,21 +512,21 @@ impl<'a> FindUsages<'a> {\n                 let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n                 for offset in match_indices(&text, finder, search_range) {\n-                    if let Some(iter) = find_nodes(\"super\", &tree, offset) {\n-                        for name_ref in iter.filter_map(ast::NameRef::cast) {\n-                            if self.found_name_ref(&name_ref, sink) {\n-                                return;\n-                            }\n+                    for name_ref in\n+                        find_nodes(\"super\", &tree, offset).filter_map(ast::NameRef::cast)\n+                    {\n+                        if self.found_name_ref(&name_ref, sink) {\n+                            return;\n                         }\n                     }\n                 }\n                 if let Some(finder) = &is_crate_root {\n                     for offset in match_indices(&text, finder, search_range) {\n-                        if let Some(iter) = find_nodes(\"crate\", &tree, offset) {\n-                            for name_ref in iter.filter_map(ast::NameRef::cast) {\n-                                if self.found_name_ref(&name_ref, sink) {\n-                                    return;\n-                                }\n+                        for name_ref in\n+                            find_nodes(\"crate\", &tree, offset).filter_map(ast::NameRef::cast)\n+                        {\n+                            if self.found_name_ref(&name_ref, sink) {\n+                                return;\n                             }\n                         }\n                     }\n@@ -566,11 +565,10 @@ impl<'a> FindUsages<'a> {\n                 let finder = &Finder::new(\"self\");\n \n                 for offset in match_indices(&text, finder, search_range) {\n-                    if let Some(iter) = find_nodes(\"self\", &tree, offset) {\n-                        for name_ref in iter.filter_map(ast::NameRef::cast) {\n-                            if self.found_self_module_name_ref(&name_ref, sink) {\n-                                return;\n-                            }\n+                    for name_ref in find_nodes(\"self\", &tree, offset).filter_map(ast::NameRef::cast)\n+                    {\n+                        if self.found_self_module_name_ref(&name_ref, sink) {\n+                            return;\n                         }\n                     }\n                 }"}, {"sha": "30e514e4136a4243290d1bb5ca136711eb22cc60", "filename": "src/tools/rust-analyzer/crates/ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -22,7 +22,7 @@ pulldown-cmark-to-cmark = \"10.0.4\"\n pulldown-cmark = { version = \"0.9.1\", default-features = false }\n url = \"2.3.1\"\n dot = \"0.1.4\"\n-smallvec = \"1.10.0\"\n+smallvec.workspace = true\n \n # local deps\n cfg.workspace = true"}, {"sha": "5f2c61f5b5f80afdb7bef5d3a474fda9a90e2dc1", "filename": "src/tools/rust-analyzer/crates/ide/src/hover.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -201,6 +201,23 @@ fn hover_simple(\n \n                 Some(render::struct_rest_pat(sema, config, &record_pat))\n             })\n+        })\n+        // try () call hovers\n+        .or_else(|| {\n+            descended().find_map(|token| {\n+                if token.kind() != T!['('] && token.kind() != T![')'] {\n+                    return None;\n+                }\n+                let arg_list = token.parent().and_then(ast::ArgList::cast)?.syntax().parent()?;\n+                let call_expr = syntax::match_ast! {\n+                    match arg_list {\n+                        ast::CallExpr(expr) => expr.into(),\n+                        ast::MethodCallExpr(expr) => expr.into(),\n+                        _ => return None,\n+                    }\n+                };\n+                render::type_info_of(sema, config, &Either::Left(call_expr))\n+            })\n         });\n \n     result.map(|mut res: HoverResult| {"}, {"sha": "bd7ce2f1d0d079eee1a166c86615ac54af1e641f", "filename": "src/tools/rust-analyzer/crates/ide/src/hover/tests.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -5612,3 +5612,38 @@ fn main() {\n \"#,\n     );\n }\n+\n+#[test]\n+fn hover_call_parens() {\n+    check(\n+        r#\"\n+fn foo() -> i32 {}\n+fn main() {\n+    foo($0);\n+}\n+\"#,\n+        expect![[r#\"\n+            *)*\n+            ```rust\n+            i32\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+struct S;\n+impl S {\n+    fn foo(self) -> i32 {}\n+}\n+fn main() {\n+    S.foo($0);\n+}\n+\"#,\n+        expect![[r#\"\n+            *)*\n+            ```rust\n+            i32\n+            ```\n+        \"#]],\n+    );\n+}"}, {"sha": "5d9729263c270381b4e7c9dfd81754fa22e64775", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/binding_mode.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -29,8 +29,17 @@ pub(super) fn hints(\n             _ => None,\n         })\n         .last();\n-    let range =\n-        outer_paren_pat.as_ref().map_or_else(|| pat.syntax(), |it| it.syntax()).text_range();\n+    let range = outer_paren_pat.as_ref().map_or_else(\n+        || match pat {\n+            // for ident patterns that @ bind a name, render the un-ref patterns in front of the inner pattern\n+            // instead of the name as that makes it more clear and doesn't really change the outcome\n+            ast::Pat::IdentPat(it) => {\n+                it.pat().map_or_else(|| it.syntax().text_range(), |it| it.syntax().text_range())\n+            }\n+            it => it.syntax().text_range(),\n+        },\n+        |it| it.syntax().text_range(),\n+    );\n     let pattern_adjustments = sema.pattern_adjustments(pat);\n     pattern_adjustments.iter().for_each(|ty| {\n         let reference = ty.is_reference();\n@@ -123,4 +132,20 @@ fn __(\n }\"#,\n         );\n     }\n+\n+    #[test]\n+    fn hints_binding_modes_complex_ident_pat() {\n+        check_with_config(\n+            InlayHintsConfig { binding_mode_hints: true, ..DISABLED_CONFIG },\n+            r#\"\n+struct Struct {\n+    field: &'static str,\n+}\n+fn foo(s @ Struct { field, .. }: &Struct) {}\n+     //^^^^^^^^^^^^^^^^^^^^^^^^ref\n+         //^^^^^^^^^^^^^^^^^^^^&\n+                  //^^^^^ref\n+\"#,\n+        );\n+    }\n }"}, {"sha": "f2b535bdc7efed42599e2c7a29b8fbdcf215d63a", "filename": "src/tools/rust-analyzer/crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -115,7 +115,7 @@ pub use ide_db::{\n         SourceRoot, SourceRootId,\n     },\n     label::Label,\n-    line_index::{LineCol, LineColUtf16, LineIndex},\n+    line_index::{LineCol, LineIndex},\n     search::{ReferenceCategory, SearchScope},\n     source_change::{FileSystemEdit, SourceChange},\n     symbol_index::Query,"}, {"sha": "cabbc287279f691938c5ec45f68edb31462acfda", "filename": "src/tools/rust-analyzer/crates/ide/src/references.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -2016,4 +2016,19 @@ fn method$0() {}\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn raw_identifier() {\n+        check(\n+            r#\"\n+fn r#fn$0() {}\n+fn main() { r#fn(); }\n+\"#,\n+            expect![[r#\"\n+                r#fn Function FileId(0) 0..12 3..7\n+\n+                FileId(0) 25..29\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "c0237e1edd0d39fe5e2cece547bbdbaf200799dc", "filename": "src/tools/rust-analyzer/crates/ide/src/rename.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frename.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -1371,7 +1371,6 @@ pub fn baz() {}\n \n     #[test]\n     fn test_rename_mod_from_raw_ident() {\n-        // FIXME: `r#fn` in path expression is not renamed.\n         check_expect(\n             \"foo\",\n             r#\"\n@@ -1397,6 +1396,10 @@ pub fn baz() {}\n                                     insert: \"foo\",\n                                     delete: 4..8,\n                                 },\n+                                Indel {\n+                                    insert: \"foo\",\n+                                    delete: 23..27,\n+                                },\n                             ],\n                         },\n                     },"}, {"sha": "e606072a82375de5c67dda98688b272bce281441", "filename": "src/tools/rust-analyzer/crates/ide/src/shuffle_crate_graph.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -18,7 +18,9 @@ pub(crate) fn shuffle_crate_graph(db: &mut RootDatabase) {\n     let crate_graph = db.crate_graph();\n \n     let mut shuffled_ids = crate_graph.iter().collect::<Vec<_>>();\n-    shuffle(&mut shuffled_ids);\n+\n+    let mut rng = oorandom::Rand32::new(stdx::rand::seed());\n+    stdx::rand::shuffle(&mut shuffled_ids, |i| rng.rand_range(0..i as u32) as usize);\n \n     let mut new_graph = CrateGraph::default();\n \n@@ -52,21 +54,3 @@ pub(crate) fn shuffle_crate_graph(db: &mut RootDatabase) {\n \n     db.set_crate_graph_with_durability(Arc::new(new_graph), Durability::HIGH);\n }\n-\n-fn shuffle<T>(slice: &mut [T]) {\n-    let mut rng = oorandom::Rand32::new(seed());\n-\n-    let mut remaining = slice.len() - 1;\n-    while remaining > 0 {\n-        let index = rng.rand_range(0..remaining as u32);\n-        slice.swap(remaining, index as usize);\n-        remaining -= 1;\n-    }\n-}\n-\n-fn seed() -> u64 {\n-    use std::collections::hash_map::RandomState;\n-    use std::hash::{BuildHasher, Hasher};\n-\n-    RandomState::new().build_hasher().finish()\n-}"}, {"sha": "f70ca55a508d2b8045e841aa668b2a422342560b", "filename": "src/tools/rust-analyzer/crates/ide/src/signature_help.rs", "status": "modified", "additions": 49, "deletions": 75, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -7,12 +7,16 @@ use either::Either;\n use hir::{\n     AssocItem, GenericParam, HasAttrs, HirDisplay, ModuleDef, PathResolution, Semantics, Trait,\n };\n-use ide_db::{active_parameter::callable_for_node, base_db::FilePosition, FxIndexMap};\n+use ide_db::{\n+    active_parameter::{callable_for_node, generic_def_for_node},\n+    base_db::FilePosition,\n+    FxIndexMap,\n+};\n use stdx::format_to;\n use syntax::{\n     algo,\n     ast::{self, HasArgList},\n-    match_ast, AstNode, Direction, SyntaxKind, SyntaxToken, TextRange, TextSize,\n+    match_ast, AstNode, Direction, SyntaxToken, TextRange, TextSize,\n };\n \n use crate::RootDatabase;\n@@ -105,10 +109,10 @@ pub(crate) fn signature_help(db: &RootDatabase, position: FilePosition) -> Optio\n         // Stop at multi-line expressions, since the signature of the outer call is not very\n         // helpful inside them.\n         if let Some(expr) = ast::Expr::cast(node.clone()) {\n-            if expr.syntax().text().contains_char('\\n')\n-                && expr.syntax().kind() != SyntaxKind::RECORD_EXPR\n+            if !matches!(expr, ast::Expr::RecordExpr(..))\n+                && expr.syntax().text().contains_char('\\n')\n             {\n-                return None;\n+                break;\n             }\n         }\n     }\n@@ -122,18 +126,16 @@ fn signature_help_for_call(\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n     // Find the calling expression and its NameRef\n-    let mut node = arg_list.syntax().parent()?;\n+    let mut nodes = arg_list.syntax().ancestors().skip(1);\n     let calling_node = loop {\n-        if let Some(callable) = ast::CallableExpr::cast(node.clone()) {\n-            if callable\n+        if let Some(callable) = ast::CallableExpr::cast(nodes.next()?) {\n+            let inside_callable = callable\n                 .arg_list()\n-                .map_or(false, |it| it.syntax().text_range().contains(token.text_range().start()))\n-            {\n+                .map_or(false, |it| it.syntax().text_range().contains(token.text_range().start()));\n+            if inside_callable {\n                 break callable;\n             }\n         }\n-\n-        node = node.parent()?;\n     };\n \n     let (callable, active_parameter) = callable_for_node(sema, &calling_node, &token)?;\n@@ -216,59 +218,11 @@ fn signature_help_for_call(\n \n fn signature_help_for_generics(\n     sema: &Semantics<'_, RootDatabase>,\n-    garg_list: ast::GenericArgList,\n+    arg_list: ast::GenericArgList,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n-    let arg_list = garg_list\n-        .syntax()\n-        .ancestors()\n-        .filter_map(ast::GenericArgList::cast)\n-        .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n-\n-    let mut active_parameter = arg_list\n-        .generic_args()\n-        .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n-        .count();\n-\n-    let first_arg_is_non_lifetime = arg_list\n-        .generic_args()\n-        .next()\n-        .map_or(false, |arg| !matches!(arg, ast::GenericArg::LifetimeArg(_)));\n-\n-    let mut generics_def = if let Some(path) =\n-        arg_list.syntax().ancestors().find_map(ast::Path::cast)\n-    {\n-        let res = sema.resolve_path(&path)?;\n-        let generic_def: hir::GenericDef = match res {\n-            hir::PathResolution::Def(hir::ModuleDef::Adt(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Function(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Trait(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::TypeAlias(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Variant(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::BuiltinType(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Const(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Macro(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Module(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Static(_)) => return None,\n-            hir::PathResolution::BuiltinAttr(_)\n-            | hir::PathResolution::ToolModule(_)\n-            | hir::PathResolution::Local(_)\n-            | hir::PathResolution::TypeParam(_)\n-            | hir::PathResolution::ConstParam(_)\n-            | hir::PathResolution::SelfType(_)\n-            | hir::PathResolution::DeriveHelper(_) => return None,\n-        };\n-\n-        generic_def\n-    } else if let Some(method_call) = arg_list.syntax().parent().and_then(ast::MethodCallExpr::cast)\n-    {\n-        // recv.method::<$0>()\n-        let method = sema.resolve_method_call(&method_call)?;\n-        method.into()\n-    } else {\n-        return None;\n-    };\n-\n+    let (mut generics_def, mut active_parameter, first_arg_is_non_lifetime) =\n+        generic_def_for_node(sema, &arg_list, &token)?;\n     let mut res = SignatureHelp {\n         doc: None,\n         signature: String::new(),\n@@ -307,9 +261,9 @@ fn signature_help_for_generics(\n             // eg. `None::<u8>`\n             // We'll use the signature of the enum, but include the docs of the variant.\n             res.doc = it.docs(db).map(|it| it.into());\n-            let it = it.parent_enum(db);\n-            format_to!(res.signature, \"enum {}\", it.name(db));\n-            generics_def = it.into();\n+            let enum_ = it.parent_enum(db);\n+            format_to!(res.signature, \"enum {}\", enum_.name(db));\n+            generics_def = enum_.into();\n         }\n         // These don't have generic args that can be specified\n         hir::GenericDef::Impl(_) | hir::GenericDef::Const(_) => return None,\n@@ -388,16 +342,13 @@ fn signature_help_for_record_lit(\n     record: ast::RecordExpr,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n-    let arg_list = record\n-        .syntax()\n-        .ancestors()\n-        .filter_map(ast::RecordExpr::cast)\n-        .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n-\n-    let active_parameter = arg_list\n+    let active_parameter = record\n         .record_expr_field_list()?\n-        .fields()\n-        .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n+        .syntax()\n+        .children_with_tokens()\n+        .filter_map(syntax::NodeOrToken::into_token)\n+        .filter(|t| t.kind() == syntax::T![,])\n+        .take_while(|t| t.text_range().start() <= token.text_range().start())\n         .count();\n \n     let mut res = SignatureHelp {\n@@ -1594,4 +1545,27 @@ impl S {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn test_enum_in_nested_method_in_lambda() {\n+        check(\n+            r#\"\n+enum A {\n+    A,\n+    B\n+}\n+\n+fn bar(_: A) { }\n+\n+fn main() {\n+    let foo = Foo;\n+    std::thread::spawn(move || { bar(A:$0) } );\n+}\n+\"#,\n+            expect![[r#\"\n+                fn bar(_: A)\n+                       ^^^^\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "fc9b5d3ba4cd79303f3254b2306d20190e825ba7", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -1126,5 +1126,5 @@ fn benchmark_syntax_highlighting_parser() {\n             .filter(|it| it.highlight.tag == HlTag::Symbol(SymbolKind::Function))\n             .count()\n     };\n-    assert_eq!(hash, 1609);\n+    assert_eq!(hash, 1608);\n }"}, {"sha": "82105522ebdd9fa2b32ca0cc2ed29aa02c5ac01a", "filename": "src/tools/rust-analyzer/crates/mbe/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -14,7 +14,7 @@ doctest = false\n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n rustc-hash = \"1.1.0\"\n-smallvec = \"1.10.0\"\n+smallvec.workspace = true\n tracing = \"0.1.35\"\n \n # local deps"}, {"sha": "6e962abd75477aa09bf20ea94f3f18d9afe4e2f1", "filename": "src/tools/rust-analyzer/crates/parser/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2FCargo.toml?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -20,4 +20,5 @@ limit.workspace = true\n [dev-dependencies]\n expect-test = \"1.4.0\"\n \n+stdx.workspace = true\n sourcegen.workspace = true"}, {"sha": "15ec9e167e025534ffb2ceb63830a96f10aaaa72", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -200,6 +200,8 @@ impl BlockLike {\n     }\n }\n \n+const VISIBILITY_FIRST: TokenSet = TokenSet::new(&[T![pub], T![crate]]);\n+\n fn opt_visibility(p: &mut Parser<'_>, in_tuple_field: bool) -> bool {\n     match p.current() {\n         T![pub] => {\n@@ -340,3 +342,31 @@ fn error_block(p: &mut Parser<'_>, message: &str) {\n     p.eat(T!['}']);\n     m.complete(p, ERROR);\n }\n+\n+/// The `parser` passed this is required to at least consume one token if it returns `true`.\n+/// If the `parser` returns false, parsing will stop.\n+fn delimited(\n+    p: &mut Parser<'_>,\n+    bra: SyntaxKind,\n+    ket: SyntaxKind,\n+    delim: SyntaxKind,\n+    first_set: TokenSet,\n+    mut parser: impl FnMut(&mut Parser<'_>) -> bool,\n+) {\n+    p.bump(bra);\n+    while !p.at(ket) && !p.at(EOF) {\n+        if !parser(p) {\n+            break;\n+        }\n+        if !p.at(delim) {\n+            if p.at_ts(first_set) {\n+                p.error(format!(\"expected {:?}\", delim));\n+            } else {\n+                break;\n+            }\n+        } else {\n+            p.bump(delim);\n+        }\n+    }\n+    p.expect(ket);\n+}"}, {"sha": "4ecaa6e6a85e9a507780f24ebc075947ff0f753f", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/attributes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -1,5 +1,7 @@\n use super::*;\n \n+pub(super) const ATTRIBUTE_FIRST: TokenSet = TokenSet::new(&[T![#]]);\n+\n pub(super) fn inner_attrs(p: &mut Parser<'_>) {\n     while p.at(T![#]) && p.nth(1) == T![!] {\n         attr(p, true);"}, {"sha": "4b080102a2c3de1659e67d51b0ee472c5c770eb0", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/expressions.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -1,5 +1,7 @@\n mod atom;\n \n+use crate::grammar::attributes::ATTRIBUTE_FIRST;\n+\n use super::*;\n \n pub(crate) use self::atom::{block_expr, match_arm_list};\n@@ -68,6 +70,12 @@ pub(super) fn stmt(p: &mut Parser<'_>, semicolon: Semicolon) {\n         Err(m) => m,\n     };\n \n+    if !p.at_ts(EXPR_FIRST) {\n+        p.err_and_bump(\"expected expression, item or let statement\");\n+        m.abandon(p);\n+        return;\n+    }\n+\n     if let Some((cm, blocklike)) = expr_stmt(p, Some(m)) {\n         if !(p.at(T!['}']) || (semicolon != Semicolon::Required && p.at(EOF))) {\n             // test no_semi_after_block\n@@ -227,6 +235,12 @@ fn expr_bp(\n         attributes::outer_attrs(p);\n         m\n     });\n+\n+    if !p.at_ts(EXPR_FIRST) {\n+        p.err_recover(\"expected expression\", atom::EXPR_RECOVERY_SET);\n+        m.abandon(p);\n+        return None;\n+    }\n     let mut lhs = match lhs(p, r) {\n         Some((lhs, blocklike)) => {\n             let lhs = lhs.extend_to(p, m);\n@@ -551,23 +565,20 @@ fn cast_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker {\n     m.complete(p, CAST_EXPR)\n }\n \n+// test_err arg_list_recovery\n+// fn main() {\n+//     foo(bar::);\n+//     foo(bar:);\n+//     foo(bar+);\n+// }\n fn arg_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n-    p.bump(T!['(']);\n-    while !p.at(T![')']) && !p.at(EOF) {\n-        // test arg_with_attr\n-        // fn main() {\n-        //     foo(#[attr] 92)\n-        // }\n-        if !expr(p) {\n-            break;\n-        }\n-        if !p.at(T![')']) && !p.expect(T![,]) {\n-            break;\n-        }\n-    }\n-    p.eat(T![')']);\n+    // test arg_with_attr\n+    // fn main() {\n+    //     foo(#[attr] 92)\n+    // }\n+    delimited(p, T!['('], T![')'], T![,], EXPR_FIRST.union(ATTRIBUTE_FIRST), expr);\n     m.complete(p, ARG_LIST);\n }\n "}, {"sha": "efc2603835e8f4edd524cfb07d720b241081c5da", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -40,26 +40,28 @@ pub(super) const ATOM_EXPR_FIRST: TokenSet =\n         T!['{'],\n         T!['['],\n         T![|],\n-        T![move],\n+        T![async],\n         T![box],\n+        T![break],\n+        T![const],\n+        T![continue],\n+        T![do],\n+        T![for],\n         T![if],\n-        T![while],\n+        T![let],\n+        T![loop],\n         T![match],\n-        T![unsafe],\n+        T![move],\n         T![return],\n-        T![yield],\n-        T![do],\n-        T![break],\n-        T![continue],\n-        T![async],\n+        T![static],\n         T![try],\n-        T![const],\n-        T![loop],\n-        T![for],\n+        T![unsafe],\n+        T![while],\n+        T![yield],\n         LIFETIME_IDENT,\n     ]));\n \n-const EXPR_RECOVERY_SET: TokenSet = TokenSet::new(&[T![let]]);\n+pub(super) const EXPR_RECOVERY_SET: TokenSet = TokenSet::new(&[T![')'], T![']']]);\n \n pub(super) fn atom_expr(\n     p: &mut Parser<'_>,\n@@ -116,7 +118,7 @@ pub(super) fn atom_expr(\n                     // fn main() {\n                     //     'loop: impl\n                     // }\n-                    p.error(\"expected a loop\");\n+                    p.error(\"expected a loop or block\");\n                     m.complete(p, ERROR);\n                     return None;\n                 }\n@@ -157,7 +159,7 @@ pub(super) fn atom_expr(\n         T![for] => for_expr(p, None),\n \n         _ => {\n-            p.err_recover(\"expected expression\", EXPR_RECOVERY_SET);\n+            p.err_and_bump(\"expected expression\");\n             return None;\n         }\n     };"}, {"sha": "919d9b91ebab5dede8a8f5b3fce37348e8874338", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/generic_args.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_args.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -5,27 +5,35 @@ pub(super) fn opt_generic_arg_list(p: &mut Parser<'_>, colon_colon_required: boo\n     if p.at(T![::]) && p.nth(2) == T![<] {\n         m = p.start();\n         p.bump(T![::]);\n-        p.bump(T![<]);\n     } else if !colon_colon_required && p.at(T![<]) && p.nth(1) != T![=] {\n         m = p.start();\n-        p.bump(T![<]);\n     } else {\n         return;\n     }\n \n-    while !p.at(EOF) && !p.at(T![>]) {\n-        generic_arg(p);\n-        if !p.at(T![>]) && !p.expect(T![,]) {\n-            break;\n-        }\n-    }\n-    p.expect(T![>]);\n+    delimited(p, T![<], T![>], T![,], GENERIC_ARG_FIRST, generic_arg);\n     m.complete(p, GENERIC_ARG_LIST);\n }\n \n+const GENERIC_ARG_FIRST: TokenSet = TokenSet::new(&[\n+    LIFETIME_IDENT,\n+    IDENT,\n+    T!['{'],\n+    T![true],\n+    T![false],\n+    T![-],\n+    INT_NUMBER,\n+    FLOAT_NUMBER,\n+    CHAR,\n+    BYTE,\n+    STRING,\n+    BYTE_STRING,\n+])\n+.union(types::TYPE_FIRST);\n+\n // test generic_arg\n // type T = S<i32>;\n-fn generic_arg(p: &mut Parser<'_>) {\n+fn generic_arg(p: &mut Parser<'_>) -> bool {\n     match p.current() {\n         LIFETIME_IDENT => lifetime_arg(p),\n         T!['{'] | T![true] | T![false] | T![-] => const_arg(p),\n@@ -68,8 +76,10 @@ fn generic_arg(p: &mut Parser<'_>) {\n                 }\n             }\n         }\n-        _ => type_arg(p),\n+        _ if p.at_ts(types::TYPE_FIRST) => type_arg(p),\n+        _ => return false,\n     }\n+    true\n }\n \n // test lifetime_arg"}, {"sha": "7fcf938babdb1ef22f30bca1dc8674b69f60e592", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/generic_params.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_params.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -1,3 +1,5 @@\n+use crate::grammar::attributes::ATTRIBUTE_FIRST;\n+\n use super::*;\n \n pub(super) fn opt_generic_param_list(p: &mut Parser<'_>) {\n@@ -11,32 +13,31 @@ pub(super) fn opt_generic_param_list(p: &mut Parser<'_>) {\n fn generic_param_list(p: &mut Parser<'_>) {\n     assert!(p.at(T![<]));\n     let m = p.start();\n-    p.bump(T![<]);\n+    delimited(p, T![<], T![>], T![,], GENERIC_PARAM_FIRST.union(ATTRIBUTE_FIRST), |p| {\n+        // test generic_param_attribute\n+        // fn foo<#[lt_attr] 'a, #[t_attr] T>() {}\n+        let m = p.start();\n+        attributes::outer_attrs(p);\n+        generic_param(p, m)\n+    });\n \n-    while !p.at(EOF) && !p.at(T![>]) {\n-        generic_param(p);\n-        if !p.at(T![>]) && !p.expect(T![,]) {\n-            break;\n-        }\n-    }\n-    p.expect(T![>]);\n     m.complete(p, GENERIC_PARAM_LIST);\n }\n \n-fn generic_param(p: &mut Parser<'_>) {\n-    let m = p.start();\n-    // test generic_param_attribute\n-    // fn foo<#[lt_attr] 'a, #[t_attr] T>() {}\n-    attributes::outer_attrs(p);\n+const GENERIC_PARAM_FIRST: TokenSet = TokenSet::new(&[IDENT, LIFETIME_IDENT, T![const]]);\n+\n+fn generic_param(p: &mut Parser<'_>, m: Marker) -> bool {\n     match p.current() {\n         LIFETIME_IDENT => lifetime_param(p, m),\n         IDENT => type_param(p, m),\n         T![const] => const_param(p, m),\n         _ => {\n             m.abandon(p);\n-            p.err_and_bump(\"expected type parameter\");\n+            p.err_and_bump(\"expected generic parameter\");\n+            return false;\n         }\n     }\n+    true\n }\n \n // test lifetime_param"}, {"sha": "17f41b8e13a40d1c3e88e35724eadce199e652e9", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/items/adt.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -1,3 +1,5 @@\n+use crate::grammar::attributes::ATTRIBUTE_FIRST;\n+\n use super::*;\n \n // test struct_item\n@@ -141,28 +143,31 @@ pub(crate) fn record_field_list(p: &mut Parser<'_>) {\n     }\n }\n \n+const TUPLE_FIELD_FIRST: TokenSet =\n+    types::TYPE_FIRST.union(ATTRIBUTE_FIRST).union(VISIBILITY_FIRST);\n+\n fn tuple_field_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n-    p.bump(T!['(']);\n-    while !p.at(T![')']) && !p.at(EOF) {\n+    delimited(p, T!['('], T![')'], T![,], TUPLE_FIELD_FIRST, |p| {\n         let m = p.start();\n         // test tuple_field_attrs\n         // struct S (#[attr] f32);\n         attributes::outer_attrs(p);\n-        opt_visibility(p, true);\n+        let has_vis = opt_visibility(p, true);\n         if !p.at_ts(types::TYPE_FIRST) {\n             p.error(\"expected a type\");\n-            m.complete(p, ERROR);\n-            break;\n+            if has_vis {\n+                m.complete(p, ERROR);\n+            } else {\n+                m.abandon(p);\n+            }\n+            return false;\n         }\n         types::type_(p);\n         m.complete(p, TUPLE_FIELD);\n+        true\n+    });\n \n-        if !p.at(T![')']) {\n-            p.expect(T![,]);\n-        }\n-    }\n-    p.expect(T![')']);\n     m.complete(p, TUPLE_FIELD_LIST);\n }"}, {"sha": "74eae9151a2650cb934ec94e8fbff9d8e378feac", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/params.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -1,3 +1,5 @@\n+use crate::grammar::attributes::ATTRIBUTE_FIRST;\n+\n use super::*;\n \n // test param_list\n@@ -66,14 +68,20 @@ fn list_(p: &mut Parser<'_>, flavor: Flavor) {\n             }\n         };\n \n-        if !p.at_ts(PARAM_FIRST) {\n+        if !p.at_ts(PARAM_FIRST.union(ATTRIBUTE_FIRST)) {\n             p.error(\"expected value parameter\");\n             m.abandon(p);\n             break;\n         }\n         param(p, m, flavor);\n-        if !p.at(ket) {\n-            p.expect(T![,]);\n+        if !p.at(T![,]) {\n+            if p.at_ts(PARAM_FIRST.union(ATTRIBUTE_FIRST)) {\n+                p.error(\"expected `,`\");\n+            } else {\n+                break;\n+            }\n+        } else {\n+            p.bump(T![,]);\n         }\n     }\n "}, {"sha": "1064ae9970c99cd36b0893d180dec8ceaff02e13", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/paths.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -67,6 +67,10 @@ fn path_for_qualifier(\n     }\n }\n \n+const EXPR_PATH_SEGMENT_RECOVERY_SET: TokenSet =\n+    items::ITEM_RECOVERY_SET.union(TokenSet::new(&[T![')'], T![,], T![let]]));\n+const TYPE_PATH_SEGMENT_RECOVERY_SET: TokenSet = types::TYPE_RECOVERY_SET;\n+\n fn path_segment(p: &mut Parser<'_>, mode: Mode, first: bool) {\n     let m = p.start();\n     // test qual_paths\n@@ -102,7 +106,12 @@ fn path_segment(p: &mut Parser<'_>, mode: Mode, first: bool) {\n                 m.complete(p, NAME_REF);\n             }\n             _ => {\n-                p.err_recover(\"expected identifier\", items::ITEM_RECOVERY_SET);\n+                let recover_set = match mode {\n+                    Mode::Use => items::ITEM_RECOVERY_SET,\n+                    Mode::Type => TYPE_PATH_SEGMENT_RECOVERY_SET,\n+                    Mode::Expr => EXPR_PATH_SEGMENT_RECOVERY_SET,\n+                };\n+                p.err_recover(\"expected identifier\", recover_set);\n                 if empty {\n                     // test_err empty_segment\n                     // use crate::;"}, {"sha": "7d0b156c5a06ae9cc61fe753bf4823e26f404e0e", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -17,8 +17,9 @@ pub(super) const TYPE_FIRST: TokenSet = paths::PATH_FIRST.union(TokenSet::new(&[\n     T![Self],\n ]));\n \n-const TYPE_RECOVERY_SET: TokenSet = TokenSet::new(&[\n+pub(super) const TYPE_RECOVERY_SET: TokenSet = TokenSet::new(&[\n     T![')'],\n+    T![>],\n     T![,],\n     // test_err struct_field_recover\n     // struct S { f pub g: () }"}, {"sha": "2fec765bd7871f2c2edc9ce06e54e660c3ce29a1", "filename": "src/tools/rust-analyzer/crates/parser/src/tests.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -15,6 +15,7 @@ use crate::{LexedStr, TopEntryPoint};\n #[test]\n fn lex_ok() {\n     for case in TestCase::list(\"lexer/ok\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let actual = lex(&case.text);\n         expect_file![case.rast].assert_eq(&actual)\n     }\n@@ -23,6 +24,7 @@ fn lex_ok() {\n #[test]\n fn lex_err() {\n     for case in TestCase::list(\"lexer/err\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let actual = lex(&case.text);\n         expect_file![case.rast].assert_eq(&actual)\n     }\n@@ -46,6 +48,7 @@ fn lex(text: &str) -> String {\n #[test]\n fn parse_ok() {\n     for case in TestCase::list(\"parser/ok\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let (actual, errors) = parse(TopEntryPoint::SourceFile, &case.text);\n         assert!(!errors, \"errors in an OK file {}:\\n{actual}\", case.rs.display());\n         expect_file![case.rast].assert_eq(&actual);\n@@ -55,6 +58,7 @@ fn parse_ok() {\n #[test]\n fn parse_inline_ok() {\n     for case in TestCase::list(\"parser/inline/ok\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let (actual, errors) = parse(TopEntryPoint::SourceFile, &case.text);\n         assert!(!errors, \"errors in an OK file {}:\\n{actual}\", case.rs.display());\n         expect_file![case.rast].assert_eq(&actual);\n@@ -64,6 +68,7 @@ fn parse_inline_ok() {\n #[test]\n fn parse_err() {\n     for case in TestCase::list(\"parser/err\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let (actual, errors) = parse(TopEntryPoint::SourceFile, &case.text);\n         assert!(errors, \"no errors in an ERR file {}:\\n{actual}\", case.rs.display());\n         expect_file![case.rast].assert_eq(&actual)\n@@ -73,6 +78,7 @@ fn parse_err() {\n #[test]\n fn parse_inline_err() {\n     for case in TestCase::list(\"parser/inline/err\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let (actual, errors) = parse(TopEntryPoint::SourceFile, &case.text);\n         assert!(errors, \"no errors in an ERR file {}:\\n{actual}\", case.rs.display());\n         expect_file![case.rast].assert_eq(&actual)"}, {"sha": "49dd9e293b8feb1f75ca48333920828ba31b6c40", "filename": "src/tools/rust-analyzer/crates/parser/src/tests/top_entries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests%2Ftop_entries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests%2Ftop_entries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests%2Ftop_entries.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -65,7 +65,7 @@ fn macro_stmt() {\n             MACRO_STMTS\n               ERROR\n                 SHEBANG \"#!/usr/bin/rust\"\n-            error 0: expected expression\n+            error 0: expected expression, item or let statement\n         \"##]],\n     );\n     check("}, {"sha": "cdc01863ab04cd3e178006865f572fcc66b08416", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/err/0009_broken_struct_type_parameter.rast", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0009_broken_struct_type_parameter.rast", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0009_broken_struct_type_parameter.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0009_broken_struct_type_parameter.rast?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -44,8 +44,7 @@ SOURCE_FILE\n       IDENT \"T\"\n     SEMICOLON \";\"\n   WHITESPACE \"\\n\"\n-error 9: expected type parameter\n-error 11: expected COMMA\n+error 9: expected generic parameter\n error 11: expected R_ANGLE\n error 11: expected `;`, `{`, or `(`\n error 12: expected an item"}, {"sha": "b485c71ab394f2699599bf8dca47d98f952ce376", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/err/0013_invalid_type.rast", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0013_invalid_type.rast", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0013_invalid_type.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0013_invalid_type.rast?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -43,17 +43,14 @@ SOURCE_FILE\n                                     IDENT \"Box\"\n                                   GENERIC_ARG_LIST\n                                     L_ANGLE \"<\"\n-                                    TYPE_ARG\n-                                      ERROR\n-                                        AT \"@\"\n-      WHITESPACE \" \"\n-      TUPLE_FIELD\n-        PATH_TYPE\n-          PATH\n-            PATH_SEGMENT\n-              NAME_REF\n-                IDENT \"Any\"\n-      ERROR\n+  ERROR\n+    AT \"@\"\n+  WHITESPACE \" \"\n+  MACRO_CALL\n+    PATH\n+      PATH_SEGMENT\n+        NAME_REF\n+          IDENT \"Any\"\n   ERROR\n     R_ANGLE \">\"\n   ERROR\n@@ -69,17 +66,14 @@ SOURCE_FILE\n   ERROR\n     SEMICOLON \";\"\n   WHITESPACE \"\\n\\n\"\n-error 67: expected type\n-error 68: expected COMMA\n-error 68: expected R_ANGLE\n-error 68: expected COMMA\n-error 68: expected R_ANGLE\n-error 68: expected COMMA\n-error 68: expected R_ANGLE\n-error 68: expected COMMA\n-error 72: expected COMMA\n-error 72: expected a type\n-error 72: expected R_PAREN\n+error 67: expected R_ANGLE\n+error 67: expected R_ANGLE\n+error 67: expected R_ANGLE\n+error 67: expected R_PAREN\n+error 67: expected SEMICOLON\n+error 67: expected an item\n+error 72: expected BANG\n+error 72: expected `{`, `[`, `(`\n error 72: expected SEMICOLON\n error 72: expected an item\n error 73: expected an item"}, {"sha": "d97fc6c72091d8ff88a2aac7799bcfba150c35ce", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/err/0022_bad_exprs.rast", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0022_bad_exprs.rast", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0022_bad_exprs.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0022_bad_exprs.rast?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -145,27 +145,29 @@ SOURCE_FILE\n error 16: expected expression\n error 17: expected R_BRACK\n error 17: expected SEMICOLON\n-error 17: expected expression\n+error 17: expected expression, item or let statement\n error 25: expected a name\n error 26: expected `;`, `{`, or `(`\n error 30: expected pattern\n error 31: expected SEMICOLON\n error 53: expected expression\n+error 54: expected R_PAREN\n error 54: expected SEMICOLON\n-error 54: expected expression\n+error 54: expected expression, item or let statement\n error 60: expected type\n error 60: expected `{`\n-error 60: expected expression\n+error 60: expected expression, item or let statement\n error 65: expected pattern\n error 65: expected SEMICOLON\n-error 65: expected expression\n+error 65: expected expression, item or let statement\n error 92: expected expression\n+error 93: expected R_PAREN\n error 93: expected SEMICOLON\n-error 93: expected expression\n-error 95: expected expression\n-error 96: expected expression\n+error 93: expected expression, item or let statement\n+error 95: expected expression, item or let statement\n+error 96: expected expression, item or let statement\n error 103: expected a name\n error 104: expected `{`\n error 108: expected pattern\n error 108: expected SEMICOLON\n-error 108: expected expression\n+error 108: expected expression, item or let statement"}, {"sha": "f0dbc9b1027fa9221576974820bd80ebf7cd12f5", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/err/0024_many_type_parens.rast", "status": "modified", "additions": 98, "deletions": 113, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.rast", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.rast?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -168,75 +168,21 @@ SOURCE_FILE\n                       L_PAREN \"(\"\n                       ERROR\n                         QUESTION \"?\"\n-        EXPR_STMT\n-          PATH_EXPR\n-            PATH\n-              PATH_SEGMENT\n-                NAME_REF\n-                  IDENT \"Sized\"\n+                  TYPE_ARG\n+                    PATH_TYPE\n+                      PATH\n+                        PATH_SEGMENT\n+                          NAME_REF\n+                            IDENT \"Sized\"\n         ERROR\n           R_PAREN \")\"\n         WHITESPACE \" \"\n         ERROR\n           PLUS \"+\"\n         WHITESPACE \" \"\n-        TUPLE_EXPR\n-          L_PAREN \"(\"\n-          CLOSURE_EXPR\n-            FOR_KW \"for\"\n-            GENERIC_PARAM_LIST\n-              L_ANGLE \"<\"\n-              LIFETIME_PARAM\n-                LIFETIME\n-                  LIFETIME_IDENT \"'a\"\n-              R_ANGLE \">\"\n-          WHITESPACE \" \"\n-          BIN_EXPR\n-            BIN_EXPR\n-              BIN_EXPR\n-                BIN_EXPR\n-                  PATH_EXPR\n-                    PATH\n-                      PATH_SEGMENT\n-                        NAME_REF\n-                          IDENT \"Trait\"\n-                  L_ANGLE \"<\"\n-                  ERROR\n-                    LIFETIME_IDENT \"'a\"\n-                R_ANGLE \">\"\n-                ERROR\n-                  R_PAREN \")\"\n-              WHITESPACE \" \"\n-              PLUS \"+\"\n-              WHITESPACE \" \"\n-              PAREN_EXPR\n-                L_PAREN \"(\"\n-                PATH_EXPR\n-                  PATH\n-                    PATH_SEGMENT\n-                      NAME_REF\n-                        IDENT \"Copy\"\n-                R_PAREN \")\"\n-            R_ANGLE \">\"\n-            ERROR\n-              SEMICOLON \";\"\n-          WHITESPACE \"\\n    \"\n-          LET_EXPR\n-            LET_KW \"let\"\n-            WHITESPACE \" \"\n-            WILDCARD_PAT\n-              UNDERSCORE \"_\"\n-            ERROR\n-              COLON \":\"\n-          WHITESPACE \" \"\n+        EXPR_STMT\n           BIN_EXPR\n             BIN_EXPR\n-              PATH_EXPR\n-                PATH\n-                  PATH_SEGMENT\n-                    NAME_REF\n-                      IDENT \"Box\"\n-              L_ANGLE \"<\"\n               TUPLE_EXPR\n                 L_PAREN \"(\"\n                 CLOSURE_EXPR\n@@ -250,78 +196,117 @@ SOURCE_FILE\n                 WHITESPACE \" \"\n                 BIN_EXPR\n                   BIN_EXPR\n-                    BIN_EXPR\n-                      BIN_EXPR\n-                        PATH_EXPR\n-                          PATH\n-                            PATH_SEGMENT\n-                              NAME_REF\n-                                IDENT \"Trait\"\n-                        L_ANGLE \"<\"\n-                        ERROR\n-                          LIFETIME_IDENT \"'a\"\n-                      R_ANGLE \">\"\n-                      ERROR\n-                        R_PAREN \")\"\n-                    WHITESPACE \" \"\n-                    PLUS \"+\"\n-                    WHITESPACE \" \"\n-                    PAREN_EXPR\n-                      L_PAREN \"(\"\n-                      PATH_EXPR\n-                        PATH\n-                          PATH_SEGMENT\n-                            NAME_REF\n-                              IDENT \"Copy\"\n-                      R_PAREN \")\"\n-                  WHITESPACE \" \"\n-                  PLUS \"+\"\n-                  WHITESPACE \" \"\n-                  PAREN_EXPR\n-                    L_PAREN \"(\"\n+                    PATH_EXPR\n+                      PATH\n+                        PATH_SEGMENT\n+                          NAME_REF\n+                            IDENT \"Trait\"\n+                    L_ANGLE \"<\"\n                     ERROR\n-                      QUESTION \"?\"\n+                      LIFETIME_IDENT \"'a\"\n+                  R_ANGLE \">\"\n+                R_PAREN \")\"\n+              WHITESPACE \" \"\n+              PLUS \"+\"\n+              WHITESPACE \" \"\n+              PAREN_EXPR\n+                L_PAREN \"(\"\n                 PATH_EXPR\n                   PATH\n                     PATH_SEGMENT\n                       NAME_REF\n-                        IDENT \"Sized\"\n+                        IDENT \"Copy\"\n                 R_PAREN \")\"\n             R_ANGLE \">\"\n             ERROR\n               SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        LET_STMT\n+          LET_KW \"let\"\n+          WHITESPACE \" \"\n+          WILDCARD_PAT\n+            UNDERSCORE \"_\"\n+          COLON \":\"\n+          WHITESPACE \" \"\n+          DYN_TRAIT_TYPE\n+            TYPE_BOUND_LIST\n+              TYPE_BOUND\n+                PATH_TYPE\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"Box\"\n+                      GENERIC_ARG_LIST\n+                        L_ANGLE \"<\"\n+                        TYPE_ARG\n+                          PAREN_TYPE\n+                            L_PAREN \"(\"\n+                            FOR_TYPE\n+                              FOR_KW \"for\"\n+                              GENERIC_PARAM_LIST\n+                                L_ANGLE \"<\"\n+                                LIFETIME_PARAM\n+                                  LIFETIME\n+                                    LIFETIME_IDENT \"'a\"\n+                                R_ANGLE \">\"\n+                              WHITESPACE \" \"\n+                              PATH_TYPE\n+                                PATH\n+                                  PATH_SEGMENT\n+                                    NAME_REF\n+                                      IDENT \"Trait\"\n+                                    GENERIC_ARG_LIST\n+                                      L_ANGLE \"<\"\n+                                      LIFETIME_ARG\n+                                        LIFETIME\n+                                          LIFETIME_IDENT \"'a\"\n+                                      R_ANGLE \">\"\n+                            R_PAREN \")\"\n+              WHITESPACE \" \"\n+              PLUS \"+\"\n+              WHITESPACE \" \"\n+              TYPE_BOUND\n+                L_PAREN \"(\"\n+                PATH_TYPE\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"Copy\"\n+                R_PAREN \")\"\n+              WHITESPACE \" \"\n+              PLUS \"+\"\n+              WHITESPACE \" \"\n+              TYPE_BOUND\n+                L_PAREN \"(\"\n+                QUESTION \"?\"\n+                PATH_TYPE\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"Sized\"\n+                R_PAREN \")\"\n+        ERROR\n+          R_ANGLE \">\"\n+        SEMICOLON \";\"\n         WHITESPACE \"\\n\"\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\"\n-error 88: expected COMMA\n error 88: expected R_ANGLE\n error 121: expected SEMICOLON\n-error 121: expected expression\n+error 121: expected expression, item or let statement\n error 140: expected type\n error 141: expected R_PAREN\n error 141: expected COMMA\n-error 141: expected R_ANGLE\n-error 141: expected SEMICOLON\n+error 146: expected R_ANGLE\n error 146: expected SEMICOLON\n-error 146: expected expression\n-error 148: expected expression\n+error 146: expected expression, item or let statement\n+error 148: expected expression, item or let statement\n error 158: expected `|`\n error 158: expected COMMA\n error 165: expected expression\n error 168: expected expression\n error 179: expected expression\n-error 180: expected COMMA\n-error 190: expected EQ\n-error 190: expected expression\n-error 191: expected COMMA\n-error 204: expected `|`\n-error 204: expected COMMA\n-error 211: expected expression\n-error 214: expected expression\n-error 228: expected expression\n-error 229: expected R_PAREN\n-error 229: expected COMMA\n-error 236: expected expression\n-error 237: expected COMMA\n-error 237: expected expression\n-error 237: expected R_PAREN\n+error 180: expected SEMICOLON\n+error 215: expected R_ANGLE\n+error 235: expected SEMICOLON\n+error 235: expected expression, item or let statement"}, {"sha": "b6bc0088374fb8860fdb08064963877993c932ca", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/err/0025_nope.rast", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0025_nope.rast", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0025_nope.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0025_nope.rast?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -156,8 +156,7 @@ SOURCE_FILE\n                             PATH_SEGMENT\n                               NAME_REF\n                                 IDENT \"i32\"\n-                      WHITESPACE \" \"\n-                      ERROR\n+                  WHITESPACE \" \"\n                   ERROR\n                     L_CURLY \"{\"\n                     R_CURLY \"}\"\n@@ -199,10 +198,8 @@ error 95: expected type\n error 95: expected COMMA\n error 96: expected field\n error 98: expected field declaration\n+error 371: expected R_PAREN\n error 371: expected COMMA\n-error 372: expected a type\n-error 372: expected R_PAREN\n-error 372: expected COMMA\n error 372: expected enum variant\n error 374: expected enum variant\n error 494: expected pattern"}, {"sha": "1cdc6e6e7192736c39e4e56ea6d69fe2dd2ed121", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/err/0042_weird_blocks.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0042_weird_blocks.rast", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0042_weird_blocks.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0042_weird_blocks.rast?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -72,4 +72,4 @@ SOURCE_FILE\n error 24: expected existential, fn, trait or impl\n error 41: expected existential, fn, trait or impl\n error 56: expected a block\n-error 75: expected a loop\n+error 75: expected a loop or block"}, {"sha": "207a5c24dffd4840cdfcb6a721faf7aa974923f7", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/err/0048_double_fish.rast", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0048_double_fish.rast", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0048_double_fish.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0048_double_fish.rast?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -12,7 +12,7 @@ SOURCE_FILE\n       STMT_LIST\n         L_CURLY \"{\"\n         WHITESPACE \"\\n    \"\n-        EXPR_STMT\n+        BIN_EXPR\n           PATH_EXPR\n             PATH\n               PATH_SEGMENT\n@@ -41,13 +41,14 @@ SOURCE_FILE\n                         COLON2 \"::\"\n                         ERROR\n                           L_ANGLE \"<\"\n-        BIN_EXPR\n-          PATH_EXPR\n-            PATH\n-              PATH_SEGMENT\n-                NAME_REF\n-                  IDENT \"nope\"\n-          SHR \">>\"\n+                  TYPE_ARG\n+                    PATH_TYPE\n+                      PATH\n+                        PATH_SEGMENT\n+                          NAME_REF\n+                            IDENT \"nope\"\n+                  R_ANGLE \">\"\n+          R_ANGLE \">\"\n           ERROR\n             SEMICOLON \";\"\n         WHITESPACE \"\\n\"\n@@ -114,8 +115,6 @@ SOURCE_FILE\n   WHITESPACE \"\\n\"\n error 30: expected identifier\n error 31: expected COMMA\n-error 31: expected R_ANGLE\n-error 31: expected SEMICOLON\n error 37: expected expression\n error 75: expected identifier\n error 76: expected SEMICOLON"}, {"sha": "ea5203fb96e00bdc8abd84730af2f941176e947f", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/err/0002_misplaced_label_err.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0002_misplaced_label_err.rast", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0002_misplaced_label_err.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0002_misplaced_label_err.rast?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -23,6 +23,6 @@ SOURCE_FILE\n         WHITESPACE \"\\n\"\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\"\n-error 22: expected a loop\n+error 22: expected a loop or block\n error 27: expected type\n error 27: expected `{`"}, {"sha": "5d0fe859c2965290238f1b16d5586b981ba4d646", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/err/0015_arg_list_recovery.rast", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rast", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rast?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -0,0 +1,77 @@\n+SOURCE_FILE\n+  FN\n+    FN_KW \"fn\"\n+    WHITESPACE \" \"\n+    NAME\n+      IDENT \"main\"\n+    PARAM_LIST\n+      L_PAREN \"(\"\n+      R_PAREN \")\"\n+    WHITESPACE \" \"\n+    BLOCK_EXPR\n+      STMT_LIST\n+        L_CURLY \"{\"\n+        WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          CALL_EXPR\n+            PATH_EXPR\n+              PATH\n+                PATH_SEGMENT\n+                  NAME_REF\n+                    IDENT \"foo\"\n+            ARG_LIST\n+              L_PAREN \"(\"\n+              PATH_EXPR\n+                PATH\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"bar\"\n+                  COLON2 \"::\"\n+              R_PAREN \")\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          CALL_EXPR\n+            PATH_EXPR\n+              PATH\n+                PATH_SEGMENT\n+                  NAME_REF\n+                    IDENT \"foo\"\n+            ARG_LIST\n+              L_PAREN \"(\"\n+              PATH_EXPR\n+                PATH\n+                  PATH_SEGMENT\n+                    NAME_REF\n+                      IDENT \"bar\"\n+              ERROR\n+                COLON \":\"\n+              R_PAREN \")\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          CALL_EXPR\n+            PATH_EXPR\n+              PATH\n+                PATH_SEGMENT\n+                  NAME_REF\n+                    IDENT \"foo\"\n+            ARG_LIST\n+              L_PAREN \"(\"\n+              BIN_EXPR\n+                PATH_EXPR\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"bar\"\n+                PLUS \"+\"\n+              R_PAREN \")\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n\"\n+        R_CURLY \"}\"\n+  WHITESPACE \"\\n\"\n+error 25: expected identifier\n+error 39: expected COMMA\n+error 39: expected expression\n+error 55: expected expression"}, {"sha": "0e7ac9cc3075533cb4836f00fafd6a4230ae066a", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/err/0015_arg_list_recovery.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    foo(bar::);\n+    foo(bar:);\n+    foo(bar+);\n+}"}, {"sha": "ea50ad35d74db1f480aad1619dcd450ce43beaf5", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/err/0015_missing_fn_param_type.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_missing_fn_param_type.rast", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_missing_fn_param_type.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_missing_fn_param_type.rast?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -49,5 +49,5 @@ SOURCE_FILE\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\"\n error 6: missing type for function parameter\n-error 6: expected COMMA\n+error 6: expected `,`\n error 16: missing type for function parameter"}, {"sha": "cf637ec359a2da28b74bf8a45c86a2e11cef5226", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/src/version.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fversion.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -120,17 +120,20 @@ pub fn read_version(dylib_path: &AbsPath) -> io::Result<String> {\n     let version = u32::from_be_bytes([dot_rustc[4], dot_rustc[5], dot_rustc[6], dot_rustc[7]]);\n     // Last supported version is:\n     // https://github.com/rust-lang/rust/commit/0696e79f2740ad89309269b460579e548a5cd632\n-    match version {\n-        5 | 6 => {}\n+    let snappy_portion = match version {\n+        5 | 6 => &dot_rustc[8..],\n+        7 => {\n+            let len_bytes = &dot_rustc[8..12];\n+            let data_len = u32::from_be_bytes(len_bytes.try_into().unwrap()) as usize;\n+            &dot_rustc[12..data_len + 12]\n+        }\n         _ => {\n             return Err(io::Error::new(\n                 io::ErrorKind::InvalidData,\n                 format!(\"unsupported metadata version {version}\"),\n             ));\n         }\n-    }\n-\n-    let snappy_portion = &dot_rustc[8..];\n+    };\n \n     let mut snappy_decoder = SnapDecoder::new(snappy_portion);\n "}, {"sha": "f0f1900c78c56c7584faf1656f7017ffe023cecd", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -24,7 +24,7 @@ crossbeam-channel = \"0.5.5\"\n dissimilar = \"1.0.4\"\n itertools = \"0.10.5\"\n scip = \"0.1.1\"\n-lsp-types = { version = \"=0.93.2\", features = [\"proposed\"] }\n+lsp-types = { version = \"=0.94\", features = [\"proposed\"] }\n parking_lot = \"0.12.1\"\n xflags = \"0.3.0\"\n oorandom = \"11.1.3\""}, {"sha": "e49d7c144922d09aeca6dc5f31c8791b6c0939e2", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/default_12483297303756020505_0.profraw", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fdefault_12483297303756020505_0.profraw", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fdefault_12483297303756020505_0.profraw", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fdefault_12483297303756020505_0.profraw?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83"}, {"sha": "3628670ac98b98a74e0420e7f7d29aec9b8500db", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -1,4 +1,5 @@\n //! Advertises the capabilities of the LSP Server.\n+use ide_db::line_index::WideEncoding;\n use lsp_types::{\n     CallHierarchyServerCapability, ClientCapabilities, CodeActionKind, CodeActionOptions,\n     CodeActionProviderCapability, CodeLensOptions, CompletionOptions,\n@@ -16,16 +17,19 @@ use lsp_types::{\n use serde_json::json;\n \n use crate::config::{Config, RustfmtConfig};\n-use crate::lsp_ext::supports_utf8;\n+use crate::line_index::PositionEncoding;\n+use crate::lsp_ext::negotiated_encoding;\n use crate::semantic_tokens;\n \n pub fn server_capabilities(config: &Config) -> ServerCapabilities {\n     ServerCapabilities {\n-        position_encoding: if supports_utf8(config.caps()) {\n-            Some(PositionEncodingKind::UTF8)\n-        } else {\n-            None\n-        },\n+        position_encoding: Some(match negotiated_encoding(config.caps()) {\n+            PositionEncoding::Utf8 => PositionEncodingKind::UTF8,\n+            PositionEncoding::Wide(wide) => match wide {\n+                WideEncoding::Utf16 => PositionEncodingKind::UTF16,\n+                WideEncoding::Utf32 => PositionEncodingKind::UTF32,\n+            },\n+        }),\n         text_document_sync: Some(TextDocumentSyncCapability::Options(TextDocumentSyncOptions {\n             open_close: Some(true),\n             change: Some(TextDocumentSyncKind::INCREMENTAL),\n@@ -134,6 +138,7 @@ pub fn server_capabilities(config: &Config) -> ServerCapabilities {\n                 resolve_provider: Some(true),\n             },\n         ))),\n+        inline_value_provider: None,\n         experimental: Some(json!({\n             \"externalDocs\": true,\n             \"hoverRange\": true,"}, {"sha": "3fc1aa4eaeb4aaaad35bb744ebfcbc53f4d0ecd6", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -11,6 +11,7 @@ use ide::{\n use ide_db::LineIndexDatabase;\n \n use ide_db::base_db::salsa::{self, ParallelDatabase};\n+use ide_db::line_index::WideEncoding;\n use lsp_types::{self, lsif};\n use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace};\n use vfs::{AbsPathBuf, Vfs};\n@@ -127,7 +128,7 @@ impl LsifManager<'_> {\n         let line_index = self.db.line_index(file_id);\n         let line_index = LineIndex {\n             index: line_index,\n-            encoding: PositionEncoding::Utf16,\n+            encoding: PositionEncoding::Wide(WideEncoding::Utf16),\n             endings: LineEndings::Unix,\n         };\n         let range_id = self.add_vertex(lsif::Vertex::Range {\n@@ -249,7 +250,7 @@ impl LsifManager<'_> {\n         let line_index = self.db.line_index(file_id);\n         let line_index = LineIndex {\n             index: line_index,\n-            encoding: PositionEncoding::Utf16,\n+            encoding: PositionEncoding::Wide(WideEncoding::Utf16),\n             endings: LineEndings::Unix,\n         };\n         let result = folds"}, {"sha": "f609a50a05fafdd82de792cc63af4e4c84b2b2b0", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -33,7 +33,7 @@ use crate::{\n     caps::completion_item_edit_resolve,\n     diagnostics::DiagnosticsMapConfig,\n     line_index::PositionEncoding,\n-    lsp_ext::{self, supports_utf8, WorkspaceSymbolSearchKind, WorkspaceSymbolSearchScope},\n+    lsp_ext::{self, negotiated_encoding, WorkspaceSymbolSearchKind, WorkspaceSymbolSearchScope},\n };\n \n mod patch_old_style;\n@@ -999,11 +999,7 @@ impl Config {\n     }\n \n     pub fn position_encoding(&self) -> PositionEncoding {\n-        if supports_utf8(&self.caps) {\n-            PositionEncoding::Utf8\n-        } else {\n-            PositionEncoding::Utf16\n-        }\n+        negotiated_encoding(&self.caps)\n     }\n \n     fn experimental(&self, index: &'static str) -> bool {"}, {"sha": "415fa4e02f20cf7805c46b5d456c54916da65c8b", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -3,6 +3,7 @@\n use std::collections::HashMap;\n \n use flycheck::{Applicability, DiagnosticLevel, DiagnosticSpan};\n+use ide_db::line_index::WideEncoding;\n use itertools::Itertools;\n use stdx::format_to;\n use vfs::{AbsPath, AbsPathBuf};\n@@ -95,7 +96,8 @@ fn position(\n         let mut char_offset = 0;\n         let len_func = match position_encoding {\n             PositionEncoding::Utf8 => char::len_utf8,\n-            PositionEncoding::Utf16 => char::len_utf16,\n+            PositionEncoding::Wide(WideEncoding::Utf16) => char::len_utf16,\n+            PositionEncoding::Wide(WideEncoding::Utf32) => |_| 1,\n         };\n         for c in line.text.chars() {\n             char_offset += 1;"}, {"sha": "50af38cd6fe3746d70df37bfcfdde8cf1a53fd94", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -1,7 +1,10 @@\n //! Conversion lsp_types types to rust-analyzer specific ones.\n use anyhow::format_err;\n-use ide::{Annotation, AnnotationKind, AssistKind, LineCol, LineColUtf16};\n-use ide_db::base_db::{FileId, FilePosition, FileRange};\n+use ide::{Annotation, AnnotationKind, AssistKind, LineCol};\n+use ide_db::{\n+    base_db::{FileId, FilePosition, FileRange},\n+    line_index::WideLineCol,\n+};\n use syntax::{TextRange, TextSize};\n use vfs::AbsPathBuf;\n \n@@ -26,9 +29,9 @@ pub(crate) fn vfs_path(url: &lsp_types::Url) -> Result<vfs::VfsPath> {\n pub(crate) fn offset(line_index: &LineIndex, position: lsp_types::Position) -> Result<TextSize> {\n     let line_col = match line_index.encoding {\n         PositionEncoding::Utf8 => LineCol { line: position.line, col: position.character },\n-        PositionEncoding::Utf16 => {\n-            let line_col = LineColUtf16 { line: position.line, col: position.character };\n-            line_index.index.to_utf8(line_col)\n+        PositionEncoding::Wide(enc) => {\n+            let line_col = WideLineCol { line: position.line, col: position.character };\n+            line_index.index.to_utf8(enc, line_col)\n         }\n     };\n     let text_size ="}, {"sha": "791cd931d42a6bb0b90fb7de8de69a79b4ed1865", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/line_index.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -7,9 +7,12 @@\n \n use std::sync::Arc;\n \n+use ide_db::line_index::WideEncoding;\n+\n+#[derive(Clone, Copy)]\n pub enum PositionEncoding {\n     Utf8,\n-    Utf16,\n+    Wide(WideEncoding),\n }\n \n pub(crate) struct LineIndex {"}, {"sha": "e33589cc53696a90890c4d57e70e10ec12f3d8e8", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -2,6 +2,7 @@\n \n use std::{collections::HashMap, path::PathBuf};\n \n+use ide_db::line_index::WideEncoding;\n use lsp_types::request::Request;\n use lsp_types::PositionEncodingKind;\n use lsp_types::{\n@@ -10,6 +11,8 @@ use lsp_types::{\n };\n use serde::{Deserialize, Serialize};\n \n+use crate::line_index::PositionEncoding;\n+\n pub enum AnalyzerStatus {}\n \n impl Request for AnalyzerStatus {\n@@ -481,16 +484,22 @@ pub(crate) enum CodeLensResolveData {\n     References(lsp_types::TextDocumentPositionParams),\n }\n \n-pub fn supports_utf8(caps: &lsp_types::ClientCapabilities) -> bool {\n-    match &caps.general {\n-        Some(general) => general\n-            .position_encodings\n-            .as_deref()\n-            .unwrap_or_default()\n-            .iter()\n-            .any(|it| it == &PositionEncodingKind::UTF8),\n-        _ => false,\n+pub fn negotiated_encoding(caps: &lsp_types::ClientCapabilities) -> PositionEncoding {\n+    let client_encodings = match &caps.general {\n+        Some(general) => general.position_encodings.as_deref().unwrap_or_default(),\n+        None => &[],\n+    };\n+\n+    for enc in client_encodings {\n+        if enc == &PositionEncodingKind::UTF8 {\n+            return PositionEncoding::Utf8;\n+        } else if enc == &PositionEncodingKind::UTF32 {\n+            return PositionEncoding::Wide(WideEncoding::Utf32);\n+        }\n+        // NB: intentionally prefer just about anything else to utf-16.\n     }\n+\n+    PositionEncoding::Wide(WideEncoding::Utf16)\n }\n \n pub enum MoveItem {}"}, {"sha": "30f1c53c198f31d54e8668f8f2fe52d33bea46d1", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -161,6 +161,7 @@ impl GlobalState {\n }\n \n pub(crate) fn apply_document_changes(\n+    encoding: PositionEncoding,\n     file_contents: impl FnOnce() -> String,\n     mut content_changes: Vec<lsp_types::TextDocumentContentChangeEvent>,\n ) -> String {\n@@ -192,9 +193,9 @@ pub(crate) fn apply_document_changes(\n     let mut line_index = LineIndex {\n         // the index will be overwritten in the bottom loop's first iteration\n         index: Arc::new(ide::LineIndex::new(&text)),\n-        // We don't care about line endings or offset encoding here.\n+        // We don't care about line endings here.\n         endings: LineEndings::Unix,\n-        encoding: PositionEncoding::Utf16,\n+        encoding,\n     };\n \n     // The changes we got must be applied sequentially, but can cross lines so we\n@@ -256,6 +257,7 @@ pub(crate) fn all_edits_are_disjoint(\n \n #[cfg(test)]\n mod tests {\n+    use ide_db::line_index::WideEncoding;\n     use lsp_types::{\n         CompletionItem, CompletionTextEdit, InsertReplaceEdit, Position, Range,\n         TextDocumentContentChangeEvent,\n@@ -278,9 +280,11 @@ mod tests {\n             };\n         }\n \n-        let text = apply_document_changes(|| String::new(), vec![]);\n+        let encoding = PositionEncoding::Wide(WideEncoding::Utf16);\n+        let text = apply_document_changes(encoding, || String::new(), vec![]);\n         assert_eq!(text, \"\");\n         let text = apply_document_changes(\n+            encoding,\n             || text,\n             vec![TextDocumentContentChangeEvent {\n                 range: None,\n@@ -289,39 +293,49 @@ mod tests {\n             }],\n         );\n         assert_eq!(text, \"the\");\n-        let text = apply_document_changes(|| text, c![0, 3; 0, 3 => \" quick\"]);\n+        let text = apply_document_changes(encoding, || text, c![0, 3; 0, 3 => \" quick\"]);\n         assert_eq!(text, \"the quick\");\n-        let text = apply_document_changes(|| text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n+        let text =\n+            apply_document_changes(encoding, || text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n         assert_eq!(text, \"quick foxes\");\n-        let text = apply_document_changes(|| text, c![0, 11; 0, 11 => \"\\ndream\"]);\n+        let text = apply_document_changes(encoding, || text, c![0, 11; 0, 11 => \"\\ndream\"]);\n         assert_eq!(text, \"quick foxes\\ndream\");\n-        let text = apply_document_changes(|| text, c![1, 0; 1, 0 => \"have \"]);\n+        let text = apply_document_changes(encoding, || text, c![1, 0; 1, 0 => \"have \"]);\n         assert_eq!(text, \"quick foxes\\nhave dream\");\n         let text = apply_document_changes(\n+            encoding,\n             || text,\n             c![0, 0; 0, 0 => \"the \", 1, 4; 1, 4 => \" quiet\", 1, 16; 1, 16 => \"s\\n\"],\n         );\n         assert_eq!(text, \"the quick foxes\\nhave quiet dreams\\n\");\n-        let text = apply_document_changes(|| text, c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"]);\n+        let text = apply_document_changes(\n+            encoding,\n+            || text,\n+            c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"],\n+        );\n         assert_eq!(text, \"the quick foxes\\n\\nhave quiet dreams\\n\\n\");\n         let text = apply_document_changes(\n+            encoding,\n             || text,\n             c![1, 0; 1, 0 => \"DREAM\", 2, 0; 2, 0 => \"they \", 3, 0; 3, 0 => \"DON'T THEY?\"],\n         );\n         assert_eq!(text, \"the quick foxes\\nDREAM\\nthey have quiet dreams\\nDON'T THEY?\\n\");\n-        let text = apply_document_changes(|| text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n+        let text =\n+            apply_document_changes(encoding, || text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n         assert_eq!(text, \"the quick \\nthey have quiet dreams\\n\");\n \n         let text = String::from(\"\u2764\ufe0f\");\n-        let text = apply_document_changes(|| text, c![0, 0; 0, 0 => \"a\"]);\n+        let text = apply_document_changes(encoding, || text, c![0, 0; 0, 0 => \"a\"]);\n         assert_eq!(text, \"a\u2764\ufe0f\");\n \n         let text = String::from(\"a\\nb\");\n-        let text = apply_document_changes(|| text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n+        let text =\n+            apply_document_changes(encoding, || text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n         assert_eq!(text, \"adcb\");\n \n         let text = String::from(\"a\\nb\");\n-        let text = apply_document_changes(|| text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n+        let text =\n+            apply_document_changes(encoding, || text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n         assert_eq!(text, \"a\u021bc\\ncb\");\n     }\n "}, {"sha": "d1e38b33c7de2e38f342801e612c57a8c9787270", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -831,6 +831,7 @@ impl GlobalState {\n                     let vfs = &mut this.vfs.write().0;\n                     let file_id = vfs.file_id(&path).unwrap();\n                     let text = apply_document_changes(\n+                        this.config.position_encoding(),\n                         || std::str::from_utf8(vfs.file_contents(file_id)).unwrap().into(),\n                         params.content_changes,\n                     );"}, {"sha": "abce0d7378277dace857f14717e72aa97343dd04", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -268,7 +268,10 @@ impl GlobalState {\n                             ]\n                         })\n                     })\n-                    .map(|glob_pattern| lsp_types::FileSystemWatcher { glob_pattern, kind: None })\n+                    .map(|glob_pattern| lsp_types::FileSystemWatcher {\n+                        glob_pattern: lsp_types::GlobPattern::String(glob_pattern),\n+                        kind: None,\n+                    })\n                     .collect(),\n             };\n             let registration = lsp_types::Registration {"}, {"sha": "92029dc1de78f01e5b9b7878f1ad839402a55040", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -31,8 +31,8 @@ pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::P\n     let line_col = line_index.index.line_col(offset);\n     match line_index.encoding {\n         PositionEncoding::Utf8 => lsp_types::Position::new(line_col.line, line_col.col),\n-        PositionEncoding::Utf16 => {\n-            let line_col = line_index.index.to_utf16(line_col);\n+        PositionEncoding::Wide(enc) => {\n+            let line_col = line_index.index.to_wide(enc, line_col);\n             lsp_types::Position::new(line_col.line, line_col.col)\n         }\n     }\n@@ -212,7 +212,7 @@ pub(crate) fn completion_items(\n     tdpp: lsp_types::TextDocumentPositionParams,\n     items: Vec<CompletionItem>,\n ) -> Vec<lsp_types::CompletionItem> {\n-    let max_relevance = items.iter().map(|it| it.relevance().score()).max().unwrap_or_default();\n+    let max_relevance = items.iter().map(|it| it.relevance.score()).max().unwrap_or_default();\n     let mut res = Vec::with_capacity(items.len());\n     for item in items {\n         completion_item(&mut res, config, line_index, &tdpp, max_relevance, item);\n@@ -235,22 +235,26 @@ fn completion_item(\n     item: CompletionItem,\n ) {\n     let insert_replace_support = config.insert_replace_support().then_some(tdpp.position);\n+    let ref_match = item.ref_match();\n+    let lookup = item.lookup().to_string();\n+\n     let mut additional_text_edits = Vec::new();\n \n     // LSP does not allow arbitrary edits in completion, so we have to do a\n     // non-trivial mapping here.\n     let text_edit = {\n         let mut text_edit = None;\n-        let source_range = item.source_range();\n-        for indel in item.text_edit().iter() {\n+        let source_range = item.source_range;\n+        for indel in item.text_edit {\n             if indel.delete.contains_range(source_range) {\n+                // Extract this indel as the main edit\n                 text_edit = Some(if indel.delete == source_range {\n                     self::completion_text_edit(line_index, insert_replace_support, indel.clone())\n                 } else {\n                     assert!(source_range.end() == indel.delete.end());\n                     let range1 = TextRange::new(indel.delete.start(), source_range.start());\n                     let range2 = source_range;\n-                    let indel1 = Indel::replace(range1, String::new());\n+                    let indel1 = Indel::delete(range1);\n                     let indel2 = Indel::replace(range2, indel.insert.clone());\n                     additional_text_edits.push(self::text_edit(line_index, indel1));\n                     self::completion_text_edit(line_index, insert_replace_support, indel2)\n@@ -264,23 +268,23 @@ fn completion_item(\n         text_edit.unwrap()\n     };\n \n-    let insert_text_format = item.is_snippet().then_some(lsp_types::InsertTextFormat::SNIPPET);\n-    let tags = item.deprecated().then(|| vec![lsp_types::CompletionItemTag::DEPRECATED]);\n-    let command = if item.trigger_call_info() && config.client_commands().trigger_parameter_hints {\n+    let insert_text_format = item.is_snippet.then_some(lsp_types::InsertTextFormat::SNIPPET);\n+    let tags = item.deprecated.then(|| vec![lsp_types::CompletionItemTag::DEPRECATED]);\n+    let command = if item.trigger_call_info && config.client_commands().trigger_parameter_hints {\n         Some(command::trigger_parameter_hints())\n     } else {\n         None\n     };\n \n     let mut lsp_item = lsp_types::CompletionItem {\n-        label: item.label().to_string(),\n-        detail: item.detail().map(|it| it.to_string()),\n-        filter_text: Some(item.lookup().to_string()),\n-        kind: Some(completion_item_kind(item.kind())),\n+        label: item.label.to_string(),\n+        detail: item.detail.map(|it| it.to_string()),\n+        filter_text: Some(lookup),\n+        kind: Some(completion_item_kind(item.kind)),\n         text_edit: Some(text_edit),\n         additional_text_edits: Some(additional_text_edits),\n-        documentation: item.documentation().map(documentation),\n-        deprecated: Some(item.deprecated()),\n+        documentation: item.documentation.map(documentation),\n+        deprecated: Some(item.deprecated),\n         tags,\n         command,\n         insert_text_format,\n@@ -294,12 +298,13 @@ fn completion_item(\n         });\n     }\n \n-    set_score(&mut lsp_item, max_relevance, item.relevance());\n+    set_score(&mut lsp_item, max_relevance, item.relevance);\n \n     if config.completion().enable_imports_on_the_fly {\n-        if let imports @ [_, ..] = item.imports_to_add() {\n-            let imports: Vec<_> = imports\n-                .iter()\n+        if !item.import_to_add.is_empty() {\n+            let imports: Vec<_> = item\n+                .import_to_add\n+                .into_iter()\n                 .filter_map(|import_edit| {\n                     let import_path = &import_edit.import_path;\n                     let import_name = import_path.segments().last()?;\n@@ -316,18 +321,13 @@ fn completion_item(\n         }\n     }\n \n-    if let Some((mutability, offset, relevance)) = item.ref_match() {\n-        let mut lsp_item_with_ref = lsp_item.clone();\n+    if let Some((label, indel, relevance)) = ref_match {\n+        let mut lsp_item_with_ref = lsp_types::CompletionItem { label, ..lsp_item.clone() };\n+        lsp_item_with_ref\n+            .additional_text_edits\n+            .get_or_insert_with(Default::default)\n+            .push(self::text_edit(line_index, indel));\n         set_score(&mut lsp_item_with_ref, max_relevance, relevance);\n-        lsp_item_with_ref.label =\n-            format!(\"&{}{}\", mutability.as_keyword_for_ref(), lsp_item_with_ref.label);\n-        lsp_item_with_ref.additional_text_edits.get_or_insert_with(Default::default).push(\n-            self::text_edit(\n-                line_index,\n-                Indel::insert(offset, format!(\"&{}\", mutability.as_keyword_for_ref())),\n-            ),\n-        );\n-\n         acc.push(lsp_item_with_ref);\n     };\n \n@@ -766,6 +766,7 @@ pub(crate) fn folding_range(\n             end_line,\n             end_character: None,\n             kind,\n+            collapsed_text: None,\n         }\n     } else {\n         lsp_types::FoldingRange {\n@@ -774,6 +775,7 @@ pub(crate) fn folding_range(\n             end_line: range.end.line,\n             end_character: Some(range.end.character),\n             kind,\n+            collapsed_text: None,\n         }\n     }\n }\n@@ -1360,7 +1362,7 @@ pub(crate) mod command {\n     pub(crate) fn trigger_parameter_hints() -> lsp_types::Command {\n         lsp_types::Command {\n             title: \"triggerParameterHints\".into(),\n-            command: \"editor.action.triggerParameterHints\".into(),\n+            command: \"rust-analyzer.triggerParameterHints\".into(),\n             arguments: None,\n         }\n     }\n@@ -1429,7 +1431,7 @@ fn main() {\n         let line_index = LineIndex {\n             index: Arc::new(ide::LineIndex::new(text)),\n             endings: LineEndings::Unix,\n-            encoding: PositionEncoding::Utf16,\n+            encoding: PositionEncoding::Utf8,\n         };\n         let converted: Vec<lsp_types::FoldingRange> =\n             folds.into_iter().map(|it| folding_range(text, &line_index, true, it)).collect();"}, {"sha": "587d640969aac7394ef0063810e86046975eef6a", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/tests/slow-tests/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -22,7 +22,7 @@ use lsp_types::{\n     notification::DidOpenTextDocument,\n     request::{\n         CodeActionRequest, Completion, Formatting, GotoTypeDefinition, HoverRequest,\n-        WillRenameFiles, WorkspaceSymbol,\n+        WillRenameFiles, WorkspaceSymbolRequest,\n     },\n     CodeActionContext, CodeActionParams, CompletionParams, DidOpenTextDocumentParams,\n     DocumentFormattingParams, FileRename, FormattingOptions, GotoDefinitionParams, HoverParams,\n@@ -1095,5 +1095,5 @@ pub fn bar() {}\n     .server()\n     .wait_until_workspace_is_loaded();\n \n-    server.request::<WorkspaceSymbol>(Default::default(), json!([]));\n+    server.request::<WorkspaceSymbolRequest>(Default::default(), json!([]));\n }"}, {"sha": "037fc89ace09098f923eeec0b5153cb4df6a9d43", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/tests/slow-tests/support.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -107,6 +107,7 @@ impl<'a> Project<'a> {\n                     did_change_watched_files: Some(\n                         lsp_types::DidChangeWatchedFilesClientCapabilities {\n                             dynamic_registration: Some(true),\n+                            relative_pattern_support: None,\n                         },\n                     ),\n                     ..Default::default()"}, {"sha": "5639aaf57cd9713162e671258a7d3e6fccda299d", "filename": "src/tools/rust-analyzer/crates/stdx/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Flib.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -11,6 +11,7 @@ pub mod hash;\n pub mod process;\n pub mod panic_context;\n pub mod non_empty_vec;\n+pub mod rand;\n \n pub use always_assert::{always, never};\n "}, {"sha": "64aa57eae09cd9ac27483c5d4c2ce71042c4ee0b", "filename": "src/tools/rust-analyzer/crates/stdx/src/rand.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Frand.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -0,0 +1,21 @@\n+//! We don't use `rand`, as that's too many things for us.\n+//!\n+//! We currently use oorandom instead, but it's missing these two utilities.\n+//! Perhaps we should switch to `fastrand`, or our own small PRNG, it's not like\n+//! we need anything more complicated than xor-shift.\n+\n+pub fn shuffle<T>(slice: &mut [T], mut rand_index: impl FnMut(usize) -> usize) {\n+    let mut remaining = slice.len() - 1;\n+    while remaining > 0 {\n+        let index = rand_index(remaining);\n+        slice.swap(remaining, index);\n+        remaining -= 1;\n+    }\n+}\n+\n+pub fn seed() -> u64 {\n+    use std::collections::hash_map::RandomState;\n+    use std::hash::{BuildHasher, Hasher};\n+\n+    RandomState::new().build_hasher().finish()\n+}"}, {"sha": "6f57cbad66b16b5d947f0b5d437b69c873481aa9", "filename": "src/tools/rust-analyzer/crates/syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Flib.rs?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -186,7 +186,7 @@ impl SourceFile {\n /// ```\n #[macro_export]\n macro_rules! match_ast {\n-    (match $node:ident { $($tt:tt)* }) => { match_ast!(match ($node) { $($tt)* }) };\n+    (match $node:ident { $($tt:tt)* }) => { $crate::match_ast!(match ($node) { $($tt)* }) };\n \n     (match ($node:expr) {\n         $( $( $path:ident )::+ ($it:pat) => $res:expr, )*"}, {"sha": "895de5798ac30eefcdb4abf0b134b5741bd9dbdc", "filename": "src/tools/rust-analyzer/docs/dev/architecture.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -119,7 +119,7 @@ See [#93](https://github.com/rust-lang/rust-analyzer/pull/93) for an example PR\n **Architecture Invariant:** `syntax` crate is completely independent from the rest of rust-analyzer. It knows nothing about salsa or LSP.\n This is important because it is possible to make useful tooling using only the syntax tree.\n Without semantic information, you don't need to be able to _build_ code, which makes the tooling more robust.\n-See also https://web.stanford.edu/~mlfbrown/paper.pdf.\n+See also https://mlfbrown.com/paper.pdf.\n You can view the `syntax` crate as an entry point to rust-analyzer.\n `syntax` crate is an **API Boundary**.\n "}, {"sha": "c3623a5cc46cf841d0c2ead53b6d21bfdc5c9dbd", "filename": "src/tools/rust-analyzer/docs/dev/lsp-extensions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Flsp-extensions.md?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -1,5 +1,5 @@\n <!---\n-lsp_ext.rs hash: ec29403e67dfd15b\n+lsp_ext.rs hash: d87477896dfe41d4\n \n If you need to change the above hash to make the test pass, please check if you\n need to adjust this doc as well and ping this issue:"}, {"sha": "49a8ca4edba38a79ab3181b05a033c9eec817398", "filename": "src/tools/rust-analyzer/editors/code/src/commands.ts", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -87,6 +87,12 @@ export function shuffleCrateGraph(ctx: CtxInit): Cmd {\n     };\n }\n \n+export function triggerParameterHints(_: CtxInit): Cmd {\n+    return async () => {\n+        await vscode.commands.executeCommand(\"editor.action.triggerParameterHints\");\n+    };\n+}\n+\n export function matchingBrace(ctx: CtxInit): Cmd {\n     return async () => {\n         const editor = ctx.activeRustEditor;"}, {"sha": "5987368e6e08fab6efc75c4567f695e541af9e0f", "filename": "src/tools/rust-analyzer/editors/code/src/main.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -186,5 +186,6 @@ function createCommands(): Record<string, CommandFactory> {\n         resolveCodeAction: { enabled: commands.resolveCodeAction },\n         runSingle: { enabled: commands.runSingle },\n         showReferences: { enabled: commands.showReferences },\n+        triggerParameterHints: { enabled: commands.triggerParameterHints },\n     };\n }"}, {"sha": "6e32e3960526fcb8cc29458878eb77994516746e", "filename": "src/tools/rust-analyzer/lib/lsp-server/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03288ebba35defc807952e6e55a0ab8f5f77aa83/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2FCargo.toml?ref=03288ebba35defc807952e6e55a0ab8f5f77aa83", "patch": "@@ -13,4 +13,4 @@ serde = { version = \"1.0.144\", features = [\"derive\"] }\n crossbeam-channel = \"0.5.6\"\n \n [dev-dependencies]\n-lsp-types = \"=0.93.2\"\n+lsp-types = \"=0.94\""}]}