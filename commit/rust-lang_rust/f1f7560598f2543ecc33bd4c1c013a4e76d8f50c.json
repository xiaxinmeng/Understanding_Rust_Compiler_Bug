{"sha": "f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "node_id": "C_kwDOAAsO6NoAKGYxZjc1NjA1OThmMjU0M2VjYzMzYmQ0YzFjMDEzYTRlNzZkOGY1MGM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-08T11:57:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-08T11:57:30Z"}, "message": "Rollup merge of #105317 - RalfJung:retag-rework, r=oli-obk\n\nmake retagging work even with 'unstable' places\n\nThis is based on top of https://github.com/rust-lang/rust/pull/105301. Only the last two commits are new.\n\nWhile investigating https://github.com/rust-lang/unsafe-code-guidelines/issues/381 I realized that we would have caught this issue much earlier if the add_retag pass wouldn't bail out on assignments of the form `*ptr = ...`.\n\nSo this PR changes our retag strategy:\n- When a new reference is created via `Rvalue::Ref` (or a raw ptr via `Rvalue::AddressOf`), we do the retagging as part of just executing that address-taking operation.\n- For everything else, we still insert retags -- these retags basically serve to ensure that references stored in local variables (and their fields) are always freshly tagged, so skipping this for assignments like `*ptr = ...` is less egregious.\nr? ```@oli-obk```", "tree": {"sha": "4cffff2042ca13f643a7d8dbd2a19b33bcc33c3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cffff2042ca13f643a7d8dbd2a19b33bcc33c3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjkdEqCRBK7hj4Ov3rIwAApgcIABHs/QurhA5zVDEQ6klWgsrI\nNW0FqoZeR62NnFHmEJykaCb/yVCBME6XG1bJE9vv7ANabape83YNTVC7P7OtMMUT\nJrnh4k0KDUA6K0Iz5EC6h//5VvYdlRbEDVnra9PL/1wv/QfY4lqgS4+VeSwANTBD\nEtOi6zwke8mfJOR94dDFOfl15j0dsJovcRuymySUF9Estnccfg7HS6GNIXtPBVyl\nBYrUqAMJxYNvCpX7kD0X+KitYbrysZV3ZbKkA+PJJoEjakVXIrkEFNVrbYafqMZC\nRKiLonu4oRa+M0tgPwgB6zwDn78yXp9U0EmP7SmNvECQmg6UQhWPaHNhQSh4UhA=\n=jjcP\n-----END PGP SIGNATURE-----\n", "payload": "tree 4cffff2042ca13f643a7d8dbd2a19b33bcc33c3b\nparent e826a9acb4cab272af819da07f32df0514c4ad66\nparent 34c58e897fc6336e31da9c7d6301a1c3520a5cde\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1670500650 +0100\ncommitter GitHub <noreply@github.com> 1670500650 +0100\n\nRollup merge of #105317 - RalfJung:retag-rework, r=oli-obk\n\nmake retagging work even with 'unstable' places\n\nThis is based on top of https://github.com/rust-lang/rust/pull/105301. Only the last two commits are new.\n\nWhile investigating https://github.com/rust-lang/unsafe-code-guidelines/issues/381 I realized that we would have caught this issue much earlier if the add_retag pass wouldn't bail out on assignments of the form `*ptr = ...`.\n\nSo this PR changes our retag strategy:\n- When a new reference is created via `Rvalue::Ref` (or a raw ptr via `Rvalue::AddressOf`), we do the retagging as part of just executing that address-taking operation.\n- For everything else, we still insert retags -- these retags basically serve to ensure that references stored in local variables (and their fields) are always freshly tagged, so skipping this for assignments like `*ptr = ...` is less egregious.\nr? ```@oli-obk```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "html_url": "https://github.com/rust-lang/rust/commit/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e826a9acb4cab272af819da07f32df0514c4ad66", "url": "https://api.github.com/repos/rust-lang/rust/commits/e826a9acb4cab272af819da07f32df0514c4ad66", "html_url": "https://github.com/rust-lang/rust/commit/e826a9acb4cab272af819da07f32df0514c4ad66"}, {"sha": "34c58e897fc6336e31da9c7d6301a1c3520a5cde", "url": "https://api.github.com/repos/rust-lang/rust/commits/34c58e897fc6336e31da9c7d6301a1c3520a5cde", "html_url": "https://github.com/rust-lang/rust/commit/34c58e897fc6336e31da9c7d6301a1c3520a5cde"}], "stats": {"total": 577, "additions": 302, "deletions": 275}, "files": [{"sha": "0604d5ee6fa4c93e94211111da45abd2e4715f15", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -373,9 +373,21 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n-    /// Executes a retagging operation.\n+    /// Executes a retagging operation for a single pointer.\n+    /// Returns the possibly adjusted pointer.\n     #[inline]\n-    fn retag(\n+    fn retag_ptr_value(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _kind: mir::RetagKind,\n+        val: &ImmTy<'tcx, Self::Provenance>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Self::Provenance>> {\n+        Ok(val.clone())\n+    }\n+\n+    /// Executes a retagging operation on a compound value.\n+    /// Replaces all pointers stored in the given place.\n+    #[inline]\n+    fn retag_place_contents(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _kind: mir::RetagKind,\n         _place: &PlaceTy<'tcx, Self::Provenance>,"}, {"sha": "81b44a49484d0a72e213d8a32b510e784b7938b1", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::mir;\n use rustc_middle::mir::interpret::{InterpResult, Scalar};\n use rustc_middle::ty::layout::LayoutOf;\n \n-use super::{InterpCx, Machine};\n+use super::{ImmTy, InterpCx, Machine};\n \n /// Classify whether an operator is \"left-homogeneous\", i.e., the LHS has the\n /// same type as the result.\n@@ -108,7 +108,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Stacked Borrows.\n             Retag(kind, place) => {\n                 let dest = self.eval_place(**place)?;\n-                M::retag(self, *kind, &dest)?;\n+                M::retag_place_contents(self, *kind, &dest)?;\n             }\n \n             Intrinsic(box ref intrinsic) => self.emulate_nondiverging_intrinsic(intrinsic)?,\n@@ -247,10 +247,41 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(Scalar::from_machine_usize(len, self), &dest)?;\n             }\n \n-            AddressOf(_, place) | Ref(_, _, place) => {\n+            Ref(_, borrow_kind, place) => {\n                 let src = self.eval_place(place)?;\n                 let place = self.force_allocation(&src)?;\n-                self.write_immediate(place.to_ref(self), &dest)?;\n+                let val = ImmTy::from_immediate(place.to_ref(self), dest.layout);\n+                // A fresh reference was created, make sure it gets retagged.\n+                let val = M::retag_ptr_value(\n+                    self,\n+                    if borrow_kind.allows_two_phase_borrow() {\n+                        mir::RetagKind::TwoPhase\n+                    } else {\n+                        mir::RetagKind::Default\n+                    },\n+                    &val,\n+                )?;\n+                self.write_immediate(*val, &dest)?;\n+            }\n+\n+            AddressOf(_, place) => {\n+                // Figure out whether this is an addr_of of an already raw place.\n+                let place_base_raw = if place.has_deref() {\n+                    let ty = self.frame().body.local_decls[place.local].ty;\n+                    ty.is_unsafe_ptr()\n+                } else {\n+                    // Not a deref, and thus not raw.\n+                    false\n+                };\n+\n+                let src = self.eval_place(place)?;\n+                let place = self.force_allocation(&src)?;\n+                let mut val = ImmTy::from_immediate(place.to_ref(self), dest.layout);\n+                if !place_base_raw {\n+                    // If this was not already raw, it needs retagging.\n+                    val = M::retag_ptr_value(self, mir::RetagKind::Raw, &val)?;\n+                }\n+                self.write_immediate(*val, &dest)?;\n             }\n \n             NullaryOp(null_op, ty) => {"}, {"sha": "614e0d012b35a672a0da08663ff8ae65a6d02d13", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -400,7 +400,7 @@ impl std::fmt::Display for NonDivergingIntrinsic<'_> {\n #[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, Hash, HashStable)]\n #[rustc_pass_by_value]\n pub enum RetagKind {\n-    /// The initial retag when entering a function.\n+    /// The initial retag of arguments when entering a function.\n     FnEntry,\n     /// Retag preparing for a two-phase borrow.\n     TwoPhase,"}, {"sha": "3d22035f0785ed57509c86c251355156d92d3665", "filename": "compiler/rustc_mir_transform/src/add_retag.rs", "status": "modified", "additions": 13, "deletions": 40, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -10,16 +10,6 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n \n pub struct AddRetag;\n \n-/// Determines whether this place is \"stable\": Whether, if we evaluate it again\n-/// after the assignment, we can be sure to obtain the same place value.\n-/// (Concurrent accesses by other threads are no problem as these are anyway non-atomic\n-/// copies.  Data races are UB.)\n-fn is_stable(place: PlaceRef<'_>) -> bool {\n-    // Which place this evaluates to can change with any memory write,\n-    // so cannot assume deref to be stable.\n-    !place.has_deref()\n-}\n-\n /// Determine whether this type may contain a reference (or box), and thus needs retagging.\n /// We will only recurse `depth` times into Tuples/ADTs to bound the cost of this.\n fn may_contain_reference<'tcx>(ty: Ty<'tcx>, depth: u32, tcx: TyCtxt<'tcx>) -> bool {\n@@ -69,22 +59,10 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         let basic_blocks = body.basic_blocks.as_mut();\n         let local_decls = &body.local_decls;\n         let needs_retag = |place: &Place<'tcx>| {\n-            // FIXME: Instead of giving up for unstable places, we should introduce\n-            // a temporary and retag on that.\n-            is_stable(place.as_ref())\n+            !place.has_deref() // we're not eally interested in stores to \"outside\" locations, they are hard to keep track of anyway\n                 && may_contain_reference(place.ty(&*local_decls, tcx).ty, /*depth*/ 3, tcx)\n                 && !local_decls[place.local].is_deref_temp()\n         };\n-        let place_base_raw = |place: &Place<'tcx>| {\n-            // If this is a `Deref`, get the type of what we are deref'ing.\n-            if place.has_deref() {\n-                let ty = &local_decls[place.local].ty;\n-                ty.is_unsafe_ptr()\n-            } else {\n-                // Not a deref, and thus not raw.\n-                false\n-            }\n-        };\n \n         // PART 1\n         // Retag arguments at the beginning of the start block.\n@@ -108,7 +86,7 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         }\n \n         // PART 2\n-        // Retag return values of functions.  Also escape-to-raw the argument of `drop`.\n+        // Retag return values of functions.\n         // We collect the return destinations because we cannot mutate while iterating.\n         let returns = basic_blocks\n             .iter_mut()\n@@ -140,30 +118,25 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         }\n \n         // PART 3\n-        // Add retag after assignment.\n+        // Add retag after assignments where data \"enters\" this function: the RHS is behind a deref and the LHS is not.\n         for block_data in basic_blocks {\n             // We want to insert statements as we iterate.  To this end, we\n             // iterate backwards using indices.\n             for i in (0..block_data.statements.len()).rev() {\n                 let (retag_kind, place) = match block_data.statements[i].kind {\n-                    // Retag-as-raw after escaping to a raw pointer, if the referent\n-                    // is not already a raw pointer.\n-                    StatementKind::Assign(box (lplace, Rvalue::AddressOf(_, ref rplace)))\n-                        if !place_base_raw(rplace) =>\n-                    {\n-                        (RetagKind::Raw, lplace)\n-                    }\n                     // Retag after assignments of reference type.\n                     StatementKind::Assign(box (ref place, ref rvalue)) if needs_retag(place) => {\n-                        let kind = match rvalue {\n-                            Rvalue::Ref(_, borrow_kind, _)\n-                                if borrow_kind.allows_two_phase_borrow() =>\n-                            {\n-                                RetagKind::TwoPhase\n-                            }\n-                            _ => RetagKind::Default,\n+                        let add_retag = match rvalue {\n+                            // Ptr-creating operations already do their own internal retagging, no\n+                            // need to also add a retag statement.\n+                            Rvalue::Ref(..) | Rvalue::AddressOf(..) => false,\n+                            _ => true,\n                         };\n-                        (kind, *place)\n+                        if add_retag {\n+                            (RetagKind::Default, *place)\n+                        } else {\n+                            continue;\n+                        }\n                     }\n                     // Do nothing for the rest\n                     _ => continue,"}, {"sha": "69f96fe48ea2ff37365b16595428320b8927bac9", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -985,16 +985,6 @@ fn create_generator_drop_shim<'tcx>(\n         tcx.mk_ptr(ty::TypeAndMut { ty: gen_ty, mutbl: hir::Mutability::Mut }),\n         source_info,\n     );\n-    if tcx.sess.opts.unstable_opts.mir_emit_retag {\n-        // Alias tracking must know we changed the type\n-        body.basic_blocks_mut()[START_BLOCK].statements.insert(\n-            0,\n-            Statement {\n-                source_info,\n-                kind: StatementKind::Retag(RetagKind::Raw, Box::new(Place::from(SELF_ARG))),\n-            },\n-        )\n-    }\n \n     // Make sure we remove dead blocks to remove\n     // unrelated code from the resume part of the function"}, {"sha": "16b7dcad17e77843e6f90a458b5b2441d755542c", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -177,16 +177,6 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n     if ty.is_some() {\n         // The first argument (index 0), but add 1 for the return value.\n         let dropee_ptr = Place::from(Local::new(1 + 0));\n-        if tcx.sess.opts.unstable_opts.mir_emit_retag {\n-            // Function arguments should be retagged, and we make this one raw.\n-            body.basic_blocks_mut()[START_BLOCK].statements.insert(\n-                0,\n-                Statement {\n-                    source_info,\n-                    kind: StatementKind::Retag(RetagKind::Raw, Box::new(dropee_ptr)),\n-                },\n-            );\n-        }\n         let patch = {\n             let param_env = tcx.param_env_reveal_all_normalized(def_id);\n             let mut elaborator ="}, {"sha": "60149ff36064ecc3d87e433209e01328f5dc1843", "filename": "src/test/mir-opt/inline/inline_retag.bar.Inline.after.mir", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -38,9 +38,7 @@ fn bar() -> bool {\n                                          // + literal: Const { ty: &i32, val: Unevaluated(bar, [], Some(promoted[1])) }\n         Retag(_10);                      // scope 1 at $DIR/inline_retag.rs:+2:7: +2:9\n         _4 = &(*_10);                    // scope 1 at $DIR/inline_retag.rs:+2:7: +2:9\n-        Retag(_4);                       // scope 1 at $DIR/inline_retag.rs:+2:7: +2:9\n         _3 = &(*_4);                     // scope 1 at $DIR/inline_retag.rs:+2:7: +2:9\n-        Retag(_3);                       // scope 1 at $DIR/inline_retag.rs:+2:7: +2:9\n         StorageLive(_6);                 // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n         StorageLive(_7);                 // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n         _9 = const _;                    // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n@@ -49,9 +47,7 @@ fn bar() -> bool {\n                                          // + literal: Const { ty: &i32, val: Unevaluated(bar, [], Some(promoted[0])) }\n         Retag(_9);                       // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n         _7 = &(*_9);                     // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n-        Retag(_7);                       // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n         _6 = &(*_7);                     // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n-        Retag(_6);                       // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n         Retag(_3);                       // scope 2 at $DIR/inline_retag.rs:16:8: 16:9\n         Retag(_6);                       // scope 2 at $DIR/inline_retag.rs:16:17: 16:18\n         StorageLive(_11);                // scope 2 at $DIR/inline_retag.rs:17:5: 17:7"}, {"sha": "7b69b3e07d6c56c6d5b201d3d3da7b29f79751c0", "filename": "src/test/mir-opt/retag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -68,9 +68,7 @@ fn array_casts() -> () {\n         StorageLive(_3);                 // scope 1 at $DIR/retag.rs:+2:13: +2:19\n         StorageLive(_4);                 // scope 1 at $DIR/retag.rs:+2:13: +2:19\n         _4 = &mut _1;                    // scope 1 at $DIR/retag.rs:+2:13: +2:19\n-        Retag(_4);                       // scope 1 at $DIR/retag.rs:+2:13: +2:19\n         _3 = &raw mut (*_4);             // scope 1 at $DIR/retag.rs:+2:13: +2:19\n-        Retag([raw] _3);                 // scope 1 at $DIR/retag.rs:+2:13: +2:19\n         _2 = move _3 as *mut usize (Pointer(ArrayToPointer)); // scope 1 at $DIR/retag.rs:+2:13: +2:33\n         StorageDead(_3);                 // scope 1 at $DIR/retag.rs:+2:32: +2:33\n         StorageDead(_4);                 // scope 1 at $DIR/retag.rs:+2:33: +2:34\n@@ -96,9 +94,7 @@ fn array_casts() -> () {\n         StorageLive(_10);                // scope 4 at $DIR/retag.rs:+6:13: +6:15\n         StorageLive(_11);                // scope 4 at $DIR/retag.rs:+6:13: +6:15\n         _11 = &_8;                       // scope 4 at $DIR/retag.rs:+6:13: +6:15\n-        Retag(_11);                      // scope 4 at $DIR/retag.rs:+6:13: +6:15\n         _10 = &raw const (*_11);         // scope 4 at $DIR/retag.rs:+6:13: +6:15\n-        Retag([raw] _10);                // scope 4 at $DIR/retag.rs:+6:13: +6:15\n         _9 = move _10 as *const usize (Pointer(ArrayToPointer)); // scope 4 at $DIR/retag.rs:+6:13: +6:31\n         StorageDead(_10);                // scope 4 at $DIR/retag.rs:+6:30: +6:31\n         StorageDead(_11);                // scope 4 at $DIR/retag.rs:+6:31: +6:32\n@@ -119,15 +115,13 @@ fn array_casts() -> () {\n         StorageDead(_17);                // scope 6 at $DIR/retag.rs:+7:33: +7:34\n         _15 = (*_16);                    // scope 6 at $DIR/retag.rs:+7:25: +7:34\n         _14 = &_15;                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_14);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_18);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _35 = const _;                   // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                          // + literal: Const { ty: &usize, val: Unevaluated(array_casts, [], Some(promoted[0])) }\n         Retag(_35);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _18 = &(*_35);                   // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_18);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         Deinit(_13);                     // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         (_13.0: &usize) = move _14;      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         (_13.1: &usize) = move _18;      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n@@ -164,15 +158,11 @@ fn array_casts() -> () {\n         StorageLive(_30);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_31);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _31 = &(*_20);                   // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_31);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _30 = &(*_31);                   // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_30);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_32);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_33);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _33 = &(*_21);                   // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_33);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _32 = &(*_33);                   // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_32);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_34);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         Deinit(_34);                     // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         discriminant(_34) = 0;           // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL"}, {"sha": "14f297e948bec91b29791e7fce4c216c06c76458", "filename": "src/test/mir-opt/retag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftest%2Fmir-opt%2Fretag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftest%2Fmir-opt%2Fretag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -6,7 +6,6 @@ fn std::ptr::drop_in_place(_1: *mut Test) -> () {\n     let mut _3: ();                      // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n \n     bb0: {\n-        Retag([raw] _1);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n         _2 = &mut (*_1);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n         _3 = <Test as Drop>::drop(move _2) -> bb1; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n                                          // mir::Constant"}, {"sha": "9e5c119a2b24e3300dcca541b860c806c37efe34", "filename": "src/test/mir-opt/retag.main-{closure#0}.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftest%2Fmir-opt%2Fretag.main-%7Bclosure%230%7D.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftest%2Fmir-opt%2Fretag.main-%7Bclosure%230%7D.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.main-%7Bclosure%230%7D.SimplifyCfg-elaborate-drops.after.mir?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -15,7 +15,6 @@ fn main::{closure#0}(_1: &[closure@main::{closure#0}], _2: &i32) -> &i32 {\n         _3 = _2;                         // scope 0 at $DIR/retag.rs:+1:18: +1:19\n         Retag(_3);                       // scope 0 at $DIR/retag.rs:+1:18: +1:19\n         _0 = &(*_2);                     // scope 1 at $DIR/retag.rs:+2:9: +2:10\n-        Retag(_0);                       // scope 1 at $DIR/retag.rs:+2:9: +2:10\n         StorageDead(_3);                 // scope 0 at $DIR/retag.rs:+3:5: +3:6\n         return;                          // scope 0 at $DIR/retag.rs:+3:6: +3:6\n     }"}, {"sha": "b853e450541729d82ad1b577e63cd67309746209", "filename": "src/test/mir-opt/retag.main.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftest%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftest%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -65,13 +65,10 @@ fn main() -> () {\n         Deinit(_5);                      // scope 1 at $DIR/retag.rs:+3:17: +3:24\n         (_5.0: i32) = const 0_i32;       // scope 1 at $DIR/retag.rs:+3:17: +3:24\n         _4 = &_5;                        // scope 1 at $DIR/retag.rs:+3:17: +3:36\n-        Retag(_4);                       // scope 1 at $DIR/retag.rs:+3:17: +3:36\n         StorageLive(_6);                 // scope 1 at $DIR/retag.rs:+3:29: +3:35\n         StorageLive(_7);                 // scope 1 at $DIR/retag.rs:+3:29: +3:35\n         _7 = &mut _1;                    // scope 1 at $DIR/retag.rs:+3:29: +3:35\n-        Retag(_7);                       // scope 1 at $DIR/retag.rs:+3:29: +3:35\n         _6 = &mut (*_7);                 // scope 1 at $DIR/retag.rs:+3:29: +3:35\n-        Retag([2phase] _6);              // scope 1 at $DIR/retag.rs:+3:29: +3:35\n         _3 = Test::foo(move _4, move _6) -> [return: bb1, unwind: bb8]; // scope 1 at $DIR/retag.rs:+3:17: +3:36\n                                          // mir::Constant\n                                          // + span: $DIR/retag.rs:33:25: 33:28\n@@ -93,15 +90,13 @@ fn main() -> () {\n         _9 = move _3;                    // scope 2 at $DIR/retag.rs:+4:19: +4:20\n         Retag(_9);                       // scope 2 at $DIR/retag.rs:+4:19: +4:20\n         _8 = &mut (*_9);                 // scope 2 at $DIR/retag.rs:+4:19: +4:20\n-        Retag(_8);                       // scope 2 at $DIR/retag.rs:+4:19: +4:20\n         StorageDead(_9);                 // scope 2 at $DIR/retag.rs:+4:22: +4:23\n         StorageLive(_10);                // scope 3 at $DIR/retag.rs:+5:13: +5:14\n         _10 = move _8;                   // scope 3 at $DIR/retag.rs:+5:17: +5:18\n         Retag(_10);                      // scope 3 at $DIR/retag.rs:+5:17: +5:18\n         StorageLive(_11);                // scope 4 at $DIR/retag.rs:+7:13: +7:15\n         StorageLive(_12);                // scope 4 at $DIR/retag.rs:+7:18: +7:29\n         _12 = &raw mut (*_10);           // scope 4 at $DIR/retag.rs:+7:18: +7:19\n-        Retag([raw] _12);                // scope 4 at $DIR/retag.rs:+7:18: +7:19\n         _11 = _12;                       // scope 4 at $DIR/retag.rs:+7:18: +7:29\n         StorageDead(_12);                // scope 4 at $DIR/retag.rs:+7:29: +7:30\n         _2 = const ();                   // scope 1 at $DIR/retag.rs:+2:5: +8:6\n@@ -122,9 +117,7 @@ fn main() -> () {\n         StorageLive(_17);                // scope 6 at $DIR/retag.rs:+15:16: +15:18\n         StorageLive(_18);                // scope 6 at $DIR/retag.rs:+15:16: +15:18\n         _18 = &_1;                       // scope 6 at $DIR/retag.rs:+15:16: +15:18\n-        Retag(_18);                      // scope 6 at $DIR/retag.rs:+15:16: +15:18\n         _17 = &(*_18);                   // scope 6 at $DIR/retag.rs:+15:16: +15:18\n-        Retag(_17);                      // scope 6 at $DIR/retag.rs:+15:16: +15:18\n         _15 = move _16(move _17) -> bb3; // scope 6 at $DIR/retag.rs:+15:14: +15:19\n     }\n \n@@ -139,7 +132,6 @@ fn main() -> () {\n         Deinit(_21);                     // scope 7 at $DIR/retag.rs:+18:5: +18:12\n         (_21.0: i32) = const 0_i32;      // scope 7 at $DIR/retag.rs:+18:5: +18:12\n         _20 = &_21;                      // scope 7 at $DIR/retag.rs:+18:5: +18:24\n-        Retag(_20);                      // scope 7 at $DIR/retag.rs:+18:5: +18:24\n         StorageLive(_22);                // scope 7 at $DIR/retag.rs:+18:21: +18:23\n         StorageLive(_23);                // scope 7 at $DIR/retag.rs:+18:21: +18:23\n         _28 = const _;                   // scope 7 at $DIR/retag.rs:+18:21: +18:23\n@@ -148,9 +140,7 @@ fn main() -> () {\n                                          // + literal: Const { ty: &i32, val: Unevaluated(main, [], Some(promoted[0])) }\n         Retag(_28);                      // scope 7 at $DIR/retag.rs:+18:21: +18:23\n         _23 = &(*_28);                   // scope 7 at $DIR/retag.rs:+18:21: +18:23\n-        Retag(_23);                      // scope 7 at $DIR/retag.rs:+18:21: +18:23\n         _22 = &(*_23);                   // scope 7 at $DIR/retag.rs:+18:21: +18:23\n-        Retag(_22);                      // scope 7 at $DIR/retag.rs:+18:21: +18:23\n         _19 = Test::foo_shr(move _20, move _22) -> [return: bb4, unwind: bb7]; // scope 7 at $DIR/retag.rs:+18:5: +18:24\n                                          // mir::Constant\n                                          // + span: $DIR/retag.rs:48:13: 48:20\n@@ -171,7 +161,6 @@ fn main() -> () {\n         StorageLive(_25);                // scope 7 at $DIR/retag.rs:+21:9: +21:11\n         StorageLive(_26);                // scope 7 at $DIR/retag.rs:+21:14: +21:28\n         _26 = &raw const (*_15);         // scope 7 at $DIR/retag.rs:+21:14: +21:16\n-        Retag([raw] _26);                // scope 7 at $DIR/retag.rs:+21:14: +21:16\n         _25 = _26;                       // scope 7 at $DIR/retag.rs:+21:14: +21:28\n         StorageDead(_26);                // scope 7 at $DIR/retag.rs:+21:28: +21:29\n         StorageLive(_27);                // scope 8 at $DIR/retag.rs:+23:5: +23:18"}, {"sha": "4b50205fa8081ce7e284517a96d9c43f4a013bef", "filename": "src/test/mir-opt/retag.{impl#0}-foo.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftest%2Fmir-opt%2Fretag.%7Bimpl%230%7D-foo.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftest%2Fmir-opt%2Fretag.%7Bimpl%230%7D-foo.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.%7Bimpl%230%7D-foo.SimplifyCfg-elaborate-drops.after.mir?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -11,9 +11,7 @@ fn <impl at $DIR/retag.rs:12:1: 12:10>::foo(_1: &Test, _2: &mut i32) -> &mut i32\n         Retag([fn entry] _2);            // scope 0 at $DIR/retag.rs:+0:23: +0:24\n         StorageLive(_3);                 // scope 0 at $DIR/retag.rs:+1:9: +1:10\n         _3 = &mut (*_2);                 // scope 0 at $DIR/retag.rs:+1:9: +1:10\n-        Retag(_3);                       // scope 0 at $DIR/retag.rs:+1:9: +1:10\n         _0 = &mut (*_3);                 // scope 0 at $DIR/retag.rs:+1:9: +1:10\n-        Retag(_0);                       // scope 0 at $DIR/retag.rs:+1:9: +1:10\n         StorageDead(_3);                 // scope 0 at $DIR/retag.rs:+2:5: +2:6\n         return;                          // scope 0 at $DIR/retag.rs:+2:6: +2:6\n     }"}, {"sha": "f896a337f42caeff8afbbcc98399d6f7c5df0f02", "filename": "src/tools/miri/src/borrow_tracker/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -11,7 +11,6 @@ use rustc_target::abi::Size;\n \n use crate::*;\n pub mod stacked_borrows;\n-use stacked_borrows::diagnostics::RetagCause;\n \n pub type CallId = NonZeroU64;\n \n@@ -265,11 +264,19 @@ impl GlobalStateInner {\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n-    fn retag(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+    fn retag_ptr_value(&mut self, kind: RetagKind, val: &ImmTy<'tcx, Provenance>) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n         let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n         match method {\n-            BorrowTrackerMethod::StackedBorrows => this.sb_retag(kind, place),\n+            BorrowTrackerMethod::StackedBorrows => this.sb_retag_ptr_value(kind, val),\n+        }\n+    }\n+\n+    fn retag_place_contents(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n+        match method {\n+            BorrowTrackerMethod::StackedBorrows => this.sb_retag_place_contents(kind, place),\n         }\n     }\n "}, {"sha": "24b3489e0d1d67e61503017feb699a39bfc0b7f7", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -459,10 +459,10 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n             Operation::Dealloc(_) => format!(\" due to deallocation\"),\n             Operation::Access(AccessOp { kind, tag, .. }) =>\n                 format!(\" due to {kind:?} access for {tag:?}\"),\n-            Operation::Retag(RetagOp { orig_tag, permission, .. }) => {\n+            Operation::Retag(RetagOp { orig_tag, permission, new_tag, .. }) => {\n                 let permission = permission\n                     .expect(\"start_grant should set the current permission before popping a tag\");\n-                format!(\" due to {permission:?} retag from {orig_tag:?}\")\n+                format!(\" due to {permission:?} retag from {orig_tag:?} (that retag created {new_tag:?})\")\n             }\n         };\n "}, {"sha": "ffbc00864022f4c642d6d9ec6c41f75628d874e4", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 204, "deletions": 165, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -1,9 +1,13 @@\n //! Implements \"Stacked Borrows\".  See <https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md>\n //! for further information.\n \n+pub mod diagnostics;\n+mod item;\n+mod stack;\n+\n use log::trace;\n use std::cmp;\n-use std::fmt::{self, Write};\n+use std::fmt::Write;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::mir::{Mutability, RetagKind};\n@@ -15,15 +19,13 @@ use rustc_target::abi::{Abi, Size};\n \n use crate::borrow_tracker::{\n     stacked_borrows::diagnostics::{AllocHistory, DiagnosticCx, DiagnosticCxBuilder, TagHistory},\n-    AccessKind, GlobalStateInner, ProtectorKind, RetagCause, RetagFields,\n+    AccessKind, GlobalStateInner, ProtectorKind, RetagFields,\n };\n use crate::*;\n \n-mod item;\n+use diagnostics::RetagCause;\n pub use item::{Item, Permission};\n-mod stack;\n pub use stack::Stack;\n-pub mod diagnostics;\n \n pub type AllocState = Stacks;\n \n@@ -40,30 +42,104 @@ pub struct Stacks {\n     modified_since_last_gc: bool,\n }\n \n-/// Indicates which kind of reference is being created.\n-/// Used by high-level `reborrow` to compute which permissions to grant to the\n-/// new pointer.\n-#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n-enum RefKind {\n-    /// `Box`.\n-    Box,\n-    /// `&mut`.\n-    Unique { two_phase: bool },\n-    /// `&` with or without interior mutability.\n-    Shared,\n-    /// `*mut`/`*const` (raw pointers).\n-    Raw { mutable: bool },\n+/// Indicates which permissions to grant to the retagged pointer.\n+#[derive(Clone, Debug)]\n+enum NewPermission {\n+    Uniform {\n+        perm: Permission,\n+        access: Option<AccessKind>,\n+        protector: Option<ProtectorKind>,\n+    },\n+    FreezeSensitive {\n+        freeze_perm: Permission,\n+        freeze_access: Option<AccessKind>,\n+        freeze_protector: Option<ProtectorKind>,\n+        nonfreeze_perm: Permission,\n+        nonfreeze_access: Option<AccessKind>,\n+        // nonfreeze_protector must always be None\n+    },\n }\n \n-impl fmt::Display for RefKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+impl NewPermission {\n+    /// A key function: determine the permissions to grant at a retag for the given kind of\n+    /// reference/pointer.\n+    fn from_ref_ty<'tcx>(\n+        ty: ty::Ty<'tcx>,\n+        kind: RetagKind,\n+        cx: &crate::MiriInterpCx<'_, 'tcx>,\n+    ) -> Self {\n+        let protector = (kind == RetagKind::FnEntry).then_some(ProtectorKind::StrongProtector);\n+        match ty.kind() {\n+            ty::Ref(_, pointee, Mutability::Mut) => {\n+                if kind == RetagKind::TwoPhase {\n+                    // We mostly just give up on 2phase-borrows, and treat these exactly like raw pointers.\n+                    assert!(protector.is_none()); // RetagKind can't be both FnEntry and TwoPhase.\n+                    NewPermission::Uniform {\n+                        perm: Permission::SharedReadWrite,\n+                        access: None,\n+                        protector: None,\n+                    }\n+                } else if pointee.is_unpin(*cx.tcx, cx.param_env()) {\n+                    // A regular full mutable reference.\n+                    NewPermission::Uniform {\n+                        perm: Permission::Unique,\n+                        access: Some(AccessKind::Write),\n+                        protector,\n+                    }\n+                } else {\n+                    NewPermission::Uniform {\n+                        perm: Permission::SharedReadWrite,\n+                        // FIXME: We emit `dereferenceable` for `!Unpin` mutable references, so we\n+                        // should do fake accesses here. But then we run into\n+                        // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>, so for now\n+                        // we don't do that.\n+                        access: None,\n+                        protector,\n+                    }\n+                }\n+            }\n+            ty::RawPtr(ty::TypeAndMut { mutbl: Mutability::Mut, .. }) => {\n+                assert!(protector.is_none()); // RetagKind can't be both FnEntry and Raw.\n+                // Mutable raw pointer. No access, not protected.\n+                NewPermission::Uniform {\n+                    perm: Permission::SharedReadWrite,\n+                    access: None,\n+                    protector: None,\n+                }\n+            }\n+            ty::Ref(_, _pointee, Mutability::Not) => {\n+                NewPermission::FreezeSensitive {\n+                    freeze_perm: Permission::SharedReadOnly,\n+                    freeze_access: Some(AccessKind::Read),\n+                    freeze_protector: protector,\n+                    nonfreeze_perm: Permission::SharedReadWrite,\n+                    // Inside UnsafeCell, this does *not* count as an access, as there\n+                    // might actually be mutable references further up the stack that\n+                    // we have to keep alive.\n+                    nonfreeze_access: None,\n+                    // We do not protect inside UnsafeCell.\n+                    // This fixes https://github.com/rust-lang/rust/issues/55005.\n+                }\n+            }\n+            ty::RawPtr(ty::TypeAndMut { mutbl: Mutability::Not, .. }) => {\n+                assert!(protector.is_none()); // RetagKind can't be both FnEntry and Raw.\n+                // `*const T`, when freshly created, are read-only in the frozen part.\n+                NewPermission::FreezeSensitive {\n+                    freeze_perm: Permission::SharedReadOnly,\n+                    freeze_access: Some(AccessKind::Read),\n+                    freeze_protector: None,\n+                    nonfreeze_perm: Permission::SharedReadWrite,\n+                    nonfreeze_access: None,\n+                }\n+            }\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    fn protector(&self) -> Option<ProtectorKind> {\n         match self {\n-            RefKind::Box => write!(f, \"Box\"),\n-            RefKind::Unique { two_phase: false } => write!(f, \"unique reference\"),\n-            RefKind::Unique { two_phase: true } => write!(f, \"unique reference (two-phase)\"),\n-            RefKind::Shared => write!(f, \"shared reference\"),\n-            RefKind::Raw { mutable: true } => write!(f, \"raw (mutable) pointer\"),\n-            RefKind::Raw { mutable: false } => write!(f, \"raw (constant) pointer\"),\n+            NewPermission::Uniform { protector, .. } => *protector,\n+            NewPermission::FreezeSensitive { freeze_protector, .. } => *freeze_protector,\n         }\n     }\n }\n@@ -518,10 +594,9 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         &mut self,\n         place: &MPlaceTy<'tcx, Provenance>,\n         size: Size,\n-        kind: RefKind,\n-        retag_cause: RetagCause, // What caused this retag, for diagnostics only\n+        new_perm: NewPermission,\n         new_tag: BorTag,\n-        protect: Option<ProtectorKind>,\n+        retag_cause: RetagCause, // What caused this retag, for diagnostics only\n     ) -> InterpResult<'tcx, Option<AllocId>> {\n         let this = self.eval_context_mut();\n \n@@ -532,20 +607,16 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n             let global = this.machine.borrow_tracker.as_ref().unwrap().borrow();\n             let ty = place.layout.ty;\n             if global.tracked_pointer_tags.contains(&new_tag) {\n-                let mut kind_str = format!(\"{kind}\");\n-                match kind {\n-                    RefKind::Unique { two_phase: false }\n-                        if !ty.is_unpin(*this.tcx, this.param_env()) =>\n-                    {\n-                        write!(kind_str, \" (!Unpin pointee type {ty})\").unwrap()\n-                    },\n-                    RefKind::Shared\n-                        if !ty.is_freeze(*this.tcx, this.param_env()) =>\n-                    {\n-                        write!(kind_str, \" (!Freeze pointee type {ty})\").unwrap()\n-                    },\n-                    _ => write!(kind_str, \" (pointee type {ty})\").unwrap(),\n-                };\n+                let mut kind_str = String::new();\n+                match new_perm {\n+                    NewPermission::Uniform { perm, .. } =>\n+                        write!(kind_str, \"{perm:?} permission\").unwrap(),\n+                    NewPermission::FreezeSensitive { freeze_perm, .. } if ty.is_freeze(*this.tcx, this.param_env()) =>\n+                        write!(kind_str, \"{freeze_perm:?} permission\").unwrap(),\n+                    NewPermission::FreezeSensitive { freeze_perm, nonfreeze_perm, .. }  =>\n+                        write!(kind_str, \"{freeze_perm:?}/{nonfreeze_perm:?} permission for frozen/non-frozen parts\").unwrap(),\n+                }\n+                write!(kind_str, \" (pointee type {ty})\").unwrap();\n                 this.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(\n                     new_tag.inner(),\n                     Some(kind_str),\n@@ -579,7 +650,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     );\n                     let mut dcx = dcx.build(&mut stacked_borrows.history, base_offset);\n                     dcx.log_creation();\n-                    if protect.is_some() {\n+                    if new_perm.protector().is_some() {\n                         dcx.log_protector();\n                     }\n                 },\n@@ -592,8 +663,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n \n         if size == Size::ZERO {\n             trace!(\n-                \"reborrow of size 0: {} reference {:?} derived from {:?} (pointee {})\",\n-                kind,\n+                \"reborrow of size 0: reference {:?} derived from {:?} (pointee {})\",\n                 new_tag,\n                 place.ptr,\n                 place.layout.ty,\n@@ -630,16 +700,15 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         }\n \n         trace!(\n-            \"reborrow: {} reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n-            kind,\n+            \"reborrow: reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n             new_tag,\n             orig_tag,\n             place.layout.ty,\n             Pointer::new(alloc_id, base_offset),\n             size.bytes()\n         );\n \n-        if let Some(protect) = protect {\n+        if let Some(protect) = new_perm.protector() {\n             // See comment in `Stack::item_invalidated` for why we store the tag twice.\n             this.frame_mut().extra.borrow_tracker.as_mut().unwrap().protected_tags.push(new_tag);\n             this.machine\n@@ -651,30 +720,45 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                 .insert(new_tag, protect);\n         }\n \n-        // Update the stacks.\n-        // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n-        // There could be existing unique pointers reborrowed from them that should remain valid!\n-        let (perm, access) = match kind {\n-            RefKind::Unique { two_phase } => {\n-                // Permission is Unique only if the type is `Unpin` and this is not twophase\n-                if !two_phase && place.layout.ty.is_unpin(*this.tcx, this.param_env()) {\n-                    (Permission::Unique, Some(AccessKind::Write))\n-                } else {\n-                    // FIXME: We emit `dereferenceable` for `!Unpin` mutable references, so we\n-                    // should do fake accesses here. But then we run into\n-                    // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>, so for now\n-                    // we don't do that.\n-                    (Permission::SharedReadWrite, None)\n+        // Update the stacks, according to the new permission information we are given.\n+        match new_perm {\n+            NewPermission::Uniform { perm, access, protector } => {\n+                assert!(perm != Permission::SharedReadOnly);\n+                // Here we can avoid `borrow()` calls because we have mutable references.\n+                // Note that this asserts that the allocation is mutable -- but since we are creating a\n+                // mutable pointer, that seems reasonable.\n+                let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n+                let stacked_borrows = alloc_extra.borrow_tracker_sb_mut().get_mut();\n+                let item = Item::new(new_tag, perm, protector.is_some());\n+                let range = alloc_range(base_offset, size);\n+                let global = machine.borrow_tracker.as_ref().unwrap().borrow();\n+                let dcx = DiagnosticCxBuilder::retag(\n+                    machine,\n+                    retag_cause,\n+                    new_tag,\n+                    orig_tag,\n+                    alloc_range(base_offset, size),\n+                );\n+                stacked_borrows.for_each(range, dcx, |stack, dcx, exposed_tags| {\n+                    stack.grant(orig_tag, item, access, &global, dcx, exposed_tags)\n+                })?;\n+                drop(global);\n+                if let Some(access) = access {\n+                    assert_eq!(access, AccessKind::Write);\n+                    // Make sure the data race model also knows about this.\n+                    if let Some(data_race) = alloc_extra.data_race.as_mut() {\n+                        data_race.write(alloc_id, range, machine)?;\n+                    }\n                 }\n             }\n-            RefKind::Box => (Permission::Unique, Some(AccessKind::Write)),\n-            RefKind::Raw { mutable: true } => {\n-                // Creating a raw ptr does not count as an access\n-                (Permission::SharedReadWrite, None)\n-            }\n-            RefKind::Shared | RefKind::Raw { mutable: false } => {\n-                // Shared references and *const are a whole different kind of game, the\n-                // permission is not uniform across the entire range!\n+            NewPermission::FreezeSensitive {\n+                freeze_perm,\n+                freeze_access,\n+                freeze_protector,\n+                nonfreeze_perm,\n+                nonfreeze_access,\n+            } => {\n+                // The permission is not uniform across the entire range!\n                 // We need a frozen-sensitive reborrow.\n                 // We have to use shared references to alloc/memory_extra here since\n                 // `visit_freeze_sensitive` needs to access the global state.\n@@ -684,22 +768,12 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     // Adjust range.\n                     range.start += base_offset;\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n-                    let (perm, access) = if frozen {\n-                        (Permission::SharedReadOnly, Some(AccessKind::Read))\n-                    } else {\n-                        // Inside UnsafeCell, this does *not* count as an access, as there\n-                        // might actually be mutable references further up the stack that\n-                        // we have to keep alive.\n-                        (Permission::SharedReadWrite, None)\n-                    };\n-                    let protected = if frozen {\n-                        protect.is_some()\n+                    let (perm, access, protector) = if frozen {\n+                        (freeze_perm, freeze_access, freeze_protector)\n                     } else {\n-                        // We do not protect inside UnsafeCell.\n-                        // This fixes https://github.com/rust-lang/rust/issues/55005.\n-                        false\n+                        (nonfreeze_perm, nonfreeze_access, None)\n                     };\n-                    let item = Item::new(new_tag, perm, protected);\n+                    let item = Item::new(new_tag, perm, protector.is_some());\n                     let global = this.machine.borrow_tracker.as_ref().unwrap().borrow();\n                     let dcx = DiagnosticCxBuilder::retag(\n                         &this.machine,\n@@ -721,34 +795,6 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     }\n                     Ok(())\n                 })?;\n-                return Ok(Some(alloc_id));\n-            }\n-        };\n-\n-        // Here we can avoid `borrow()` calls because we have mutable references.\n-        // Note that this asserts that the allocation is mutable -- but since we are creating a\n-        // mutable pointer, that seems reasonable.\n-        let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n-        let stacked_borrows = alloc_extra.borrow_tracker_sb_mut().get_mut();\n-        let item = Item::new(new_tag, perm, protect.is_some());\n-        let range = alloc_range(base_offset, size);\n-        let global = machine.borrow_tracker.as_ref().unwrap().borrow();\n-        let dcx = DiagnosticCxBuilder::retag(\n-            machine,\n-            retag_cause,\n-            new_tag,\n-            orig_tag,\n-            alloc_range(base_offset, size),\n-        );\n-        stacked_borrows.for_each(range, dcx, |stack, dcx, exposed_tags| {\n-            stack.grant(orig_tag, item, access, &global, dcx, exposed_tags)\n-        })?;\n-        drop(global);\n-        if let Some(access) = access {\n-            assert_eq!(access, AccessKind::Write);\n-            // Make sure the data race model also knows about this.\n-            if let Some(data_race) = alloc_extra.data_race.as_mut() {\n-                data_race.write(alloc_id, range, machine)?;\n             }\n         }\n \n@@ -760,9 +806,8 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n     fn sb_retag_reference(\n         &mut self,\n         val: &ImmTy<'tcx, Provenance>,\n-        kind: RefKind,\n-        retag_cause: RetagCause, // What caused this retag, for diagnostics only\n-        protect: Option<ProtectorKind>,\n+        new_perm: NewPermission,\n+        cause: RetagCause, // What caused this retag, for diagnostics only\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n         // We want a place for where the ptr *points to*, so we get one.\n@@ -780,7 +825,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         let new_tag = this.machine.borrow_tracker.as_mut().unwrap().get_mut().new_ptr();\n \n         // Reborrow.\n-        let alloc_id = this.sb_reborrow(&place, size, kind, retag_cause, new_tag, protect)?;\n+        let alloc_id = this.sb_reborrow(&place, size, new_perm, new_tag, cause)?;\n \n         // Adjust pointer.\n         let new_place = place.map_provenance(|p| {\n@@ -807,17 +852,32 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n-    fn sb_retag(\n+    fn sb_retag_ptr_value(\n+        &mut self,\n+        kind: RetagKind,\n+        val: &ImmTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n+        let this = self.eval_context_mut();\n+        let new_perm = NewPermission::from_ref_ty(val.layout.ty, kind, this);\n+        let retag_cause = match kind {\n+            RetagKind::TwoPhase { .. } => RetagCause::TwoPhase,\n+            RetagKind::FnEntry => unreachable!(),\n+            RetagKind::Raw | RetagKind::Default => RetagCause::Normal,\n+        };\n+        this.sb_retag_reference(&val, new_perm, retag_cause)\n+    }\n+\n+    fn sb_retag_place_contents(\n         &mut self,\n         kind: RetagKind,\n         place: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let retag_fields = this.machine.borrow_tracker.as_mut().unwrap().get_mut().retag_fields;\n         let retag_cause = match kind {\n-            RetagKind::TwoPhase { .. } => RetagCause::TwoPhase,\n+            RetagKind::Raw | RetagKind::TwoPhase { .. } => unreachable!(), // these can only happen in `retag_ptr_value`\n             RetagKind::FnEntry => RetagCause::FnEntry,\n-            RetagKind::Raw | RetagKind::Default => RetagCause::Normal,\n+            RetagKind::Default => RetagCause::Normal,\n         };\n         let mut visitor = RetagVisitor { ecx: this, kind, retag_cause, retag_fields };\n         return visitor.visit_value(place);\n@@ -831,15 +891,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n         impl<'ecx, 'mir, 'tcx> RetagVisitor<'ecx, 'mir, 'tcx> {\n             #[inline(always)] // yes this helps in our benchmarks\n-            fn retag_place(\n+            fn retag_ptr_inplace(\n                 &mut self,\n                 place: &PlaceTy<'tcx, Provenance>,\n-                ref_kind: RefKind,\n+                new_perm: NewPermission,\n                 retag_cause: RetagCause,\n-                protector: Option<ProtectorKind>,\n             ) -> InterpResult<'tcx> {\n                 let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n-                let val = self.ecx.sb_retag_reference(&val, ref_kind, retag_cause, protector)?;\n+                let val = self.ecx.sb_retag_reference(&val, new_perm, retag_cause)?;\n                 self.ecx.write_immediate(*val, place)?;\n                 Ok(())\n             }\n@@ -856,13 +915,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n             fn visit_box(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n                 // Boxes get a weak protectors, since they may be deallocated.\n-                self.retag_place(\n-                    place,\n-                    RefKind::Box,\n-                    self.retag_cause,\n-                    /*protector*/\n-                    (self.kind == RetagKind::FnEntry).then_some(ProtectorKind::WeakProtector),\n-                )\n+                let new_perm = NewPermission::Uniform {\n+                    perm: Permission::Unique,\n+                    access: Some(AccessKind::Write),\n+                    protector: (self.kind == RetagKind::FnEntry)\n+                        .then_some(ProtectorKind::WeakProtector),\n+                };\n+                self.retag_ptr_inplace(place, new_perm, self.retag_cause)\n             }\n \n             fn visit_value(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n@@ -876,36 +935,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n                 // Check the type of this value to see what to do with it (retag, or recurse).\n                 match place.layout.ty.kind() {\n-                    ty::Ref(_, _, mutbl) => {\n-                        let ref_kind = match mutbl {\n-                            Mutability::Mut =>\n-                                RefKind::Unique { two_phase: self.kind == RetagKind::TwoPhase },\n-                            Mutability::Not => RefKind::Shared,\n-                        };\n-                        self.retag_place(\n-                            place,\n-                            ref_kind,\n-                            self.retag_cause,\n-                            /*protector*/\n-                            (self.kind == RetagKind::FnEntry)\n-                                .then_some(ProtectorKind::StrongProtector),\n-                        )?;\n+                    ty::Ref(..) => {\n+                        let new_perm =\n+                            NewPermission::from_ref_ty(place.layout.ty, self.kind, self.ecx);\n+                        self.retag_ptr_inplace(place, new_perm, self.retag_cause)?;\n                     }\n-                    ty::RawPtr(tym) => {\n-                        // We definitely do *not* want to recurse into raw pointers -- wide raw\n-                        // pointers have fields, and for dyn Trait pointees those can have reference\n-                        // type!\n-                        if self.kind == RetagKind::Raw {\n-                            // Raw pointers need to be enabled.\n-                            self.retag_place(\n-                                place,\n-                                RefKind::Raw { mutable: tym.mutbl == Mutability::Mut },\n-                                self.retag_cause,\n-                                /*protector*/ None,\n-                            )?;\n-                        }\n+                    ty::RawPtr(..) => {\n+                        // We do *not* want to recurse into raw pointers -- wide raw pointers have\n+                        // fields, and for dyn Trait pointees those can have reference type!\n                     }\n-                    _ if place.layout.ty.ty_adt_def().is_some_and(|adt| adt.is_box()) => {\n+                    ty::Adt(adt, _) if adt.is_box() => {\n                         // Recurse for boxes, they require some tricky handling and will end up in `visit_box` above.\n                         // (Yes this means we technically also recursively retag the allocator itself\n                         // even if field retagging is not enabled. *shrug*)\n@@ -953,12 +992,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let ptr_layout = this.layout_of(this.tcx.mk_mut_ptr(return_place.layout.ty))?;\n         let val = ImmTy::from_immediate(return_place.to_ref(this), ptr_layout);\n         // Reborrow it. With protection! That is part of the point.\n-        let val = this.sb_retag_reference(\n-            &val,\n-            RefKind::Unique { two_phase: false },\n-            RetagCause::FnReturn,\n-            /*protector*/ Some(ProtectorKind::StrongProtector),\n-        )?;\n+        let new_perm = NewPermission::Uniform {\n+            perm: Permission::Unique,\n+            access: Some(AccessKind::Write),\n+            protector: Some(ProtectorKind::StrongProtector),\n+        };\n+        let val = this.sb_retag_reference(&val, new_perm, RetagCause::FnReturn)?;\n         // And use reborrowed pointer for return place.\n         let return_place = this.ref_to_mplace(&val)?;\n         this.frame_mut().return_place = return_place.into();"}, {"sha": "d0fb9f9b0b5fe7409878f0c6abd96ebcd74e1975", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -63,9 +63,9 @@ impl MachineStopType for TerminationInfo {}\n \n /// Miri specific diagnostics\n pub enum NonHaltingDiagnostic {\n-    /// (new_tag, new_kind, (alloc_id, base_offset, orig_tag))\n+    /// (new_tag, new_perm, (alloc_id, base_offset, orig_tag))\n     ///\n-    /// new_kind is `None` for base tags.\n+    /// new_perm is `None` for base tags.\n     CreatedPointerTag(NonZeroU64, Option<String>, Option<(AllocId, AllocRange, ProvenanceExtra)>),\n     /// This `Item` was popped from the borrow stack. The string explains the reason.\n     PoppedPointerTag(Item, String),\n@@ -393,10 +393,10 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n \n         let msg = match &e {\n             CreatedPointerTag(tag, None, _) => format!(\"created base tag {tag:?}\"),\n-            CreatedPointerTag(tag, Some(kind), None) => format!(\"created {tag:?} for {kind}\"),\n-            CreatedPointerTag(tag, Some(kind), Some((alloc_id, range, orig_tag))) =>\n+            CreatedPointerTag(tag, Some(perm), None) => format!(\"created {tag:?} with {perm} derived from unknown tag\"),\n+            CreatedPointerTag(tag, Some(perm), Some((alloc_id, range, orig_tag))) =>\n                 format!(\n-                    \"created tag {tag:?} for {kind} at {alloc_id:?}{range:?} derived from {orig_tag:?}\"\n+                    \"created tag {tag:?} with {perm} at {alloc_id:?}{range:?} derived from {orig_tag:?}\"\n                 ),\n             PoppedPointerTag(item, cause) => format!(\"popped tracked tag for item {item:?}{cause}\"),\n             CreatedCallId(id) => format!(\"function call with id {id}\"),"}, {"sha": "e5b1eb2e4870696691a5f1672ea90f194665a865", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f7560598f2543ecc33bd4c1c013a4e76d8f50c/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=f1f7560598f2543ecc33bd4c1c013a4e76d8f50c", "patch": "@@ -967,8 +967,9 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         ptr: Pointer<Self::Provenance>,\n     ) -> InterpResult<'tcx> {\n         match ptr.provenance {\n-            Provenance::Concrete { alloc_id, tag } =>\n-                intptrcast::GlobalStateInner::expose_ptr(ecx, alloc_id, tag),\n+            Provenance::Concrete { alloc_id, tag } => {\n+                intptrcast::GlobalStateInner::expose_ptr(ecx, alloc_id, tag)\n+            }\n             Provenance::Wildcard => {\n                 // No need to do anything for wildcard pointers as\n                 // their provenances have already been previously exposed.\n@@ -1055,13 +1056,26 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     }\n \n     #[inline(always)]\n-    fn retag(\n+    fn retag_ptr_value(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        kind: mir::RetagKind,\n+        val: &ImmTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n+        if ecx.machine.borrow_tracker.is_some() {\n+            ecx.retag_ptr_value(kind, val)\n+        } else {\n+            Ok(val.clone())\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn retag_place_contents(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         kind: mir::RetagKind,\n         place: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n         if ecx.machine.borrow_tracker.is_some() {\n-            ecx.retag(kind, place)?;\n+            ecx.retag_place_contents(kind, place)?;\n         }\n         Ok(())\n     }"}]}