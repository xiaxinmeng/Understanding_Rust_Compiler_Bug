{"sha": "bff4c30ac7614c636a085e9ae65e1dec2714804e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmZjRjMzBhYzc2MTRjNjM2YTA4NWU5YWU2NWUxZGVjMjcxNDgwNGU=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2017-02-10T23:32:12Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2017-02-10T23:32:12Z"}, "message": "added test, fixed message & description, rustfmt", "tree": {"sha": "fbb6d3744d18eb5dc8a7c2bacbb61cb5324a4a41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbb6d3744d18eb5dc8a7c2bacbb61cb5324a4a41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bff4c30ac7614c636a085e9ae65e1dec2714804e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bff4c30ac7614c636a085e9ae65e1dec2714804e", "html_url": "https://github.com/rust-lang/rust/commit/bff4c30ac7614c636a085e9ae65e1dec2714804e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bff4c30ac7614c636a085e9ae65e1dec2714804e/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5650a599a8727ecab31537fc78e9d1ddec0f6d56", "url": "https://api.github.com/repos/rust-lang/rust/commits/5650a599a8727ecab31537fc78e9d1ddec0f6d56", "html_url": "https://github.com/rust-lang/rust/commit/5650a599a8727ecab31537fc78e9d1ddec0f6d56"}], "stats": {"total": 55, "additions": 36, "deletions": 19}, "files": [{"sha": "a30d632f15991b490ff60c5c4006064243fa5bb9", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bff4c30ac7614c636a085e9ae65e1dec2714804e/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff4c30ac7614c636a085e9ae65e1dec2714804e/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=bff4c30ac7614c636a085e9ae65e1dec2714804e", "patch": "@@ -44,13 +44,15 @@ declare_lint! {\n     \"comparing a pointer to a null pointer, suggesting to use `.is_null()` instead.\"\n }\n \n-/// **What it does:** This lint checks for functions that take immutable refs and return\n+/// **What it does:** This lint checks for functions that take immutable references and return\n /// mutable ones.\n ///\n-/// **Why is this bad?** This is trivially unsound, as one can create two mutable refs\n-/// from the same source.\n+/// **Why is this bad?** This is trivially unsound, as one can create two mutable references\n+/// from the same (immutable!) source. This [error](https://github.com/rust-lang/rust/issues/39465)\n+/// actually lead to an interim Rust release 1.15.1.\n ///\n-/// **Known problems:** This lint will overlook functions where input and output lifetimes differ\n+/// **Known problems:** To be on the conservative side, if there's at least one mutable reference\n+/// with the output lifetime, this lint will not trigger. In practice, this case is unlikely anyway.\n ///\n /// **Example:**\n /// ```rust\n@@ -131,25 +133,31 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n \n     if let FunctionRetTy::Return(ref ty) = decl.output {\n         if let Some((out, MutMutable)) = get_rptr_lm(ty) {\n-            if let Some(MutImmutable) = decl.inputs.iter()\n-                     .filter_map(|ty| get_rptr_lm(ty))\n-                     .filter(|&(lt, _)| lt.name == out.name)\n-                     .fold(None, |x, (_, m)| match (x, m) {\n+            if let Some(MutImmutable) =\n+                decl.inputs\n+                    .iter()\n+                    .filter_map(|ty| get_rptr_lm(ty))\n+                    .filter(|&(lt, _)| lt.name == out.name)\n+                    .fold(None, |x, (_, m)| match (x, m) {\n                         (Some(MutMutable), _) |\n                         (_, MutMutable) => Some(MutMutable),\n                         (_, m) => Some(m),\n-                     }) {\n+                    }) {\n                 span_lint(cx,\n                           MUT_FROM_REF,\n                           ty.span,\n-                          \"this function takes an immutable ref to return a mutable one:\");\n+                          \"this function takes an immutable ref to return a mutable one\");\n             }\n         }\n     }\n }\n \n fn get_rptr_lm(ty: &Ty) -> Option<(&Lifetime, Mutability)> {\n-    if let Ty_::TyRptr(ref lt, ref m) = ty.node { Some((lt, m.mutbl)) } else { None }\n+    if let Ty_::TyRptr(ref lt, ref m) = ty.node {\n+        Some((lt, m.mutbl))\n+    } else {\n+        None\n+    }\n }\n \n fn is_null_path(expr: &Expr) -> bool {"}, {"sha": "24b73eacc32c412fe47133f7ead6d62014b8566f", "filename": "tests/ui/mut_from_ref.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bff4c30ac7614c636a085e9ae65e1dec2714804e/tests%2Fui%2Fmut_from_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff4c30ac7614c636a085e9ae65e1dec2714804e/tests%2Fui%2Fmut_from_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_from_ref.rs?ref=bff4c30ac7614c636a085e9ae65e1dec2714804e", "patch": "@@ -25,6 +25,10 @@ fn fail(x: &u32) -> &mut u16 {\n     unimplemented!()\n }\n \n+fn fail_lifetime<'a>(x: &'a u32, y: &mut u32) -> &'a mut u32 {\n+    unimplemented!()\n+}\n+\n // this is OK, because the result borrows y\n fn works<'a>(x: &u32, y: &'a mut u32) -> &'a mut u32 {\n     unimplemented!()"}, {"sha": "799adb0071464d07e4e1d90b307ca4e60505ebfe", "filename": "tests/ui/mut_from_ref.stderr", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bff4c30ac7614c636a085e9ae65e1dec2714804e/tests%2Fui%2Fmut_from_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bff4c30ac7614c636a085e9ae65e1dec2714804e/tests%2Fui%2Fmut_from_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_from_ref.stderr?ref=bff4c30ac7614c636a085e9ae65e1dec2714804e", "patch": "@@ -1,26 +1,31 @@\n-error: this function takes an immutable ref to return a mutable one:\n- --> $DIR/mut_from_ref.rs:9:39\n+error: this function takes an immutable ref to return a mutable one\n+ --> tests/ui/mut_from_ref.rs:9:39\n   |\n 9 |     fn this_wont_hurt_a_bit(&self) -> &mut Foo {\n   |                                       ^^^^^^^^\n   |\n note: lint level defined here\n- --> $DIR/mut_from_ref.rs:4:9\n+ --> tests/ui/mut_from_ref.rs:4:9\n   |\n 4 | #![deny(mut_from_ref)]\n   |         ^^^^^^^^^^^^\n \n-error: this function takes an immutable ref to return a mutable one:\n-  --> $DIR/mut_from_ref.rs:15:25\n+error: this function takes an immutable ref to return a mutable one\n+  --> tests/ui/mut_from_ref.rs:15:25\n    |\n 15 |     fn ouch(x: &Foo) -> &mut Foo;\n    |                         ^^^^^^^^\n \n-error: this function takes an immutable ref to return a mutable one:\n-  --> $DIR/mut_from_ref.rs:24:21\n+error: this function takes an immutable ref to return a mutable one\n+  --> tests/ui/mut_from_ref.rs:24:21\n    |\n 24 | fn fail(x: &u32) -> &mut u16 {\n    |                     ^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: this function takes an immutable ref to return a mutable one\n+  --> tests/ui/mut_from_ref.rs:28:50\n+   |\n+28 | fn fail_lifetime<'a>(x: &'a u32, y: &mut u32) -> &'a mut u32 {\n+   |                                                  ^^^^^^^^^^^\n \n+error: aborting due to 4 previous errors"}]}