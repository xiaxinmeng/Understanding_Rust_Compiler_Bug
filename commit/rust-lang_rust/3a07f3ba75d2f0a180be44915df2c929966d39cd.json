{"sha": "3a07f3ba75d2f0a180be44915df2c929966d39cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMDdmM2JhNzVkMmYwYTE4MGJlNDQ5MTVkZjJjOTI5OTY2ZDM5Y2Q=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-23T14:16:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-23T14:16:28Z"}, "message": "Rollup merge of #67536 - Centril:move-is_range_literal, r=Mark-Simulacrum\n\nMove `{hir::lowering -> hir}::is_range_literal`\n\nThe function is never used inside lowering, but only ever in external crates.\nBy moving it, we facilitate lowering as its own crate.\n\nBest read commit-by-commit.\n\nr? @Mark-Simulacrum", "tree": {"sha": "93d43e0e112c32e4c15b42d45f1def8acaeb616b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93d43e0e112c32e4c15b42d45f1def8acaeb616b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a07f3ba75d2f0a180be44915df2c929966d39cd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeAMw8CRBK7hj4Ov3rIwAAdHIIAKDYBYRV10OjY5kX0qPIY83+\n1qTcVz4YrI8VDJHPlbdDwWkMGfI08EP2crhSAByPxRFS5VjH2B6iM+xppzXXZS//\nq3I7Q/YT0MSctxZCxFgw8FvDm6Ub0//Zd1jZVDsDa/woey4HdGd/x8tGec3Xbj6q\nSzwmaOgpBGFuB/8+l5ZYidlZg2THv6cE9jTQ2KCKMRV6FCHWZZsf+1n80U7bBbMp\n54SPDcbn0Fds2CynmQzDmkB02z6RXqWzEl91hLQk3nsJ+ak5SE78qaY7mUXi6MW3\n3s08hJzELj3+Wr7cJR04ytqK/QmPHpSoXY2S9cSxb46IloGpb3z8+u5Xq161V6E=\n=z3s7\n-----END PGP SIGNATURE-----\n", "payload": "tree 93d43e0e112c32e4c15b42d45f1def8acaeb616b\nparent 6f38a15c7b5a57abf024e7e38cb0239e39037e9f\nparent 4bb83468a202c7402de529199dd363db5f307f33\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1577110588 +0100\ncommitter GitHub <noreply@github.com> 1577110588 +0100\n\nRollup merge of #67536 - Centril:move-is_range_literal, r=Mark-Simulacrum\n\nMove `{hir::lowering -> hir}::is_range_literal`\n\nThe function is never used inside lowering, but only ever in external crates.\nBy moving it, we facilitate lowering as its own crate.\n\nBest read commit-by-commit.\n\nr? @Mark-Simulacrum\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a07f3ba75d2f0a180be44915df2c929966d39cd", "html_url": "https://github.com/rust-lang/rust/commit/3a07f3ba75d2f0a180be44915df2c929966d39cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a07f3ba75d2f0a180be44915df2c929966d39cd/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f38a15c7b5a57abf024e7e38cb0239e39037e9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f38a15c7b5a57abf024e7e38cb0239e39037e9f", "html_url": "https://github.com/rust-lang/rust/commit/6f38a15c7b5a57abf024e7e38cb0239e39037e9f"}, {"sha": "4bb83468a202c7402de529199dd363db5f307f33", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bb83468a202c7402de529199dd363db5f307f33", "html_url": "https://github.com/rust-lang/rust/commit/4bb83468a202c7402de529199dd363db5f307f33"}], "stats": {"total": 141, "additions": 69, "deletions": 72}, "files": [{"sha": "a702eb839845e4aa55fa4853cd22211d1a81b557", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3a07f3ba75d2f0a180be44915df2c929966d39cd/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a07f3ba75d2f0a180be44915df2c929966d39cd/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=3a07f3ba75d2f0a180be44915df2c929966d39cd", "patch": "@@ -3437,65 +3437,3 @@ fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body<'hir>>) -> Vec<hir::BodyId>\n     body_ids.sort_by_key(|b| bodies[b].value.span);\n     body_ids\n }\n-\n-/// Checks if the specified expression is a built-in range literal.\n-/// (See: `LoweringContext::lower_expr()`).\n-pub fn is_range_literal(sess: &Session, expr: &hir::Expr) -> bool {\n-    use hir::{Path, QPath, ExprKind, TyKind};\n-\n-    // Returns whether the given path represents a (desugared) range,\n-    // either in std or core, i.e. has either a `::std::ops::Range` or\n-    // `::core::ops::Range` prefix.\n-    fn is_range_path(path: &Path) -> bool {\n-        let segs: Vec<_> = path.segments.iter().map(|seg| seg.ident.to_string()).collect();\n-        let segs: Vec<_> = segs.iter().map(|seg| &**seg).collect();\n-\n-        // \"{{root}}\" is the equivalent of `::` prefix in `Path`.\n-        if let [\"{{root}}\", std_core, \"ops\", range] = segs.as_slice() {\n-            (*std_core == \"std\" || *std_core == \"core\") && range.starts_with(\"Range\")\n-        } else {\n-            false\n-        }\n-    };\n-\n-    // Check whether a span corresponding to a range expression is a\n-    // range literal, rather than an explicit struct or `new()` call.\n-    fn is_lit(sess: &Session, span: &Span) -> bool {\n-        let source_map = sess.source_map();\n-        let end_point = source_map.end_point(*span);\n-\n-        if let Ok(end_string) = source_map.span_to_snippet(end_point) {\n-            !(end_string.ends_with(\"}\") || end_string.ends_with(\")\"))\n-        } else {\n-            false\n-        }\n-    };\n-\n-    match expr.kind {\n-        // All built-in range literals but `..=` and `..` desugar to `Struct`s.\n-        ExprKind::Struct(ref qpath, _, _) => {\n-            if let QPath::Resolved(None, ref path) = **qpath {\n-                return is_range_path(&path) && is_lit(sess, &expr.span);\n-            }\n-        }\n-\n-        // `..` desugars to its struct path.\n-        ExprKind::Path(QPath::Resolved(None, ref path)) => {\n-            return is_range_path(&path) && is_lit(sess, &expr.span);\n-        }\n-\n-        // `..=` desugars into `::std::ops::RangeInclusive::new(...)`.\n-        ExprKind::Call(ref func, _) => {\n-            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.kind {\n-                if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.kind {\n-                    let new_call = segment.ident.name == sym::new;\n-                    return is_range_path(&path) && is_lit(sess, &expr.span) && new_call;\n-                }\n-            }\n-        }\n-\n-        _ => {}\n-    }\n-\n-    false\n-}"}, {"sha": "915b0afc48fcb0b3f4d55d35676aea622312ef5e", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 64, "deletions": 2, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3a07f3ba75d2f0a180be44915df2c929966d39cd/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a07f3ba75d2f0a180be44915df2c929966d39cd/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=3a07f3ba75d2f0a180be44915df2c929966d39cd", "patch": "@@ -29,10 +29,10 @@ use syntax::ast::{AttrVec, Attribute, FloatTy, IntTy, Label, LitKind, StrStyle,\n pub use syntax::ast::{BorrowKind, ImplPolarity, IsAuto};\n pub use syntax::ast::{CaptureBy, Constness, Movability, Mutability, Unsafety};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n-use syntax::source_map::Spanned;\n-use syntax::symbol::{kw, Symbol};\n use syntax::tokenstream::TokenStream;\n use syntax::util::parser::ExprPrecedence;\n+use syntax_pos::source_map::{SourceMap, Spanned};\n+use syntax_pos::symbol::{kw, sym, Symbol};\n use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n \n /// HIR doesn't commit to a concrete storage type and has its own alias for a vector.\n@@ -1564,6 +1564,68 @@ impl fmt::Debug for Expr {\n     }\n }\n \n+/// Checks if the specified expression is a built-in range literal.\n+/// (See: `LoweringContext::lower_expr()`).\n+///\n+/// FIXME(#60607): This function is a hack. If and when we have `QPath::Lang(...)`,\n+/// we can use that instead as simpler, more reliable mechanism, as opposed to using `SourceMap`.\n+pub fn is_range_literal(sm: &SourceMap, expr: &Expr) -> bool {\n+    // Returns whether the given path represents a (desugared) range,\n+    // either in std or core, i.e. has either a `::std::ops::Range` or\n+    // `::core::ops::Range` prefix.\n+    fn is_range_path(path: &Path) -> bool {\n+        let segs: Vec<_> = path.segments.iter().map(|seg| seg.ident.to_string()).collect();\n+        let segs: Vec<_> = segs.iter().map(|seg| &**seg).collect();\n+\n+        // \"{{root}}\" is the equivalent of `::` prefix in `Path`.\n+        if let [\"{{root}}\", std_core, \"ops\", range] = segs.as_slice() {\n+            (*std_core == \"std\" || *std_core == \"core\") && range.starts_with(\"Range\")\n+        } else {\n+            false\n+        }\n+    };\n+\n+    // Check whether a span corresponding to a range expression is a\n+    // range literal, rather than an explicit struct or `new()` call.\n+    fn is_lit(sm: &SourceMap, span: &Span) -> bool {\n+        let end_point = sm.end_point(*span);\n+\n+        if let Ok(end_string) = sm.span_to_snippet(end_point) {\n+            !(end_string.ends_with(\"}\") || end_string.ends_with(\")\"))\n+        } else {\n+            false\n+        }\n+    };\n+\n+    match expr.kind {\n+        // All built-in range literals but `..=` and `..` desugar to `Struct`s.\n+        ExprKind::Struct(ref qpath, _, _) => {\n+            if let QPath::Resolved(None, ref path) = **qpath {\n+                return is_range_path(&path) && is_lit(sm, &expr.span);\n+            }\n+        }\n+\n+        // `..` desugars to its struct path.\n+        ExprKind::Path(QPath::Resolved(None, ref path)) => {\n+            return is_range_path(&path) && is_lit(sm, &expr.span);\n+        }\n+\n+        // `..=` desugars into `::std::ops::RangeInclusive::new(...)`.\n+        ExprKind::Call(ref func, _) => {\n+            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.kind {\n+                if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.kind {\n+                    let new_call = segment.ident.name == sym::new;\n+                    return is_range_path(&path) && is_lit(sm, &expr.span) && new_call;\n+                }\n+            }\n+        }\n+\n+        _ => {}\n+    }\n+\n+    false\n+}\n+\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ExprKind {\n     /// A `box x` expression."}, {"sha": "45b8666c42b45d111aa081b3b1c8c4f00601991a", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3a07f3ba75d2f0a180be44915df2c929966d39cd/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a07f3ba75d2f0a180be44915df2c929966d39cd/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=3a07f3ba75d2f0a180be44915df2c929966d39cd", "patch": "@@ -3,8 +3,7 @@\n use crate::hir::def_id::DefId;\n use lint::{LateContext, LintArray, LintContext};\n use lint::{LateLintPass, LintPass};\n-use rustc::hir::lowering::is_range_literal;\n-use rustc::hir::{ExprKind, Node};\n+use rustc::hir::{is_range_literal, ExprKind, Node};\n use rustc::ty::layout::{self, IntegerExt, LayoutOf, SizeSkeleton, VariantIdx};\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n@@ -266,7 +265,7 @@ fn lint_int_literal<'a, 'tcx>(\n         let par_id = cx.tcx.hir().get_parent_node(e.hir_id);\n         if let Node::Expr(par_e) = cx.tcx.hir().get(par_id) {\n             if let hir::ExprKind::Struct(..) = par_e.kind {\n-                if is_range_literal(cx.sess(), par_e)\n+                if is_range_literal(cx.sess().source_map(), par_e)\n                     && lint_overflowing_range_endpoint(cx, lit, v, max, e, par_e, t.name_str())\n                 {\n                     // The overflowing literal lint was overridden.\n@@ -318,7 +317,7 @@ fn lint_uint_literal<'a, 'tcx>(\n                         return;\n                     }\n                 }\n-                hir::ExprKind::Struct(..) if is_range_literal(cx.sess(), par_e) => {\n+                hir::ExprKind::Struct(..) if is_range_literal(cx.sess().source_map(), par_e) => {\n                     let t = t.name_str();\n                     if lint_overflowing_range_endpoint(cx, lit, lit_val, max, e, par_e, t) {\n                         // The overflowing literal lint was overridden."}, {"sha": "3a25786365b483d26dcee63c93ac7bbde45171a8", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a07f3ba75d2f0a180be44915df2c929966d39cd/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a07f3ba75d2f0a180be44915df2c929966d39cd/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=3a07f3ba75d2f0a180be44915df2c929966d39cd", "patch": "@@ -3,9 +3,7 @@ use rustc::infer::InferOk;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n \n use errors::{Applicability, DiagnosticBuilder};\n-use rustc::hir;\n-use rustc::hir::Node;\n-use rustc::hir::{lowering::is_range_literal, print};\n+use rustc::hir::{self, is_range_literal, print, Node};\n use rustc::ty::adjustment::AllowTwoPhase;\n use rustc::ty::{self, AssocItem, Ty};\n use syntax::symbol::sym;\n@@ -478,7 +476,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // parenthesize if needed (Issue #46756)\n                             hir::ExprKind::Cast(_, _) | hir::ExprKind::Binary(_, _, _) => true,\n                             // parenthesize borrows of range literals (Issue #54505)\n-                            _ if is_range_literal(self.tcx.sess, expr) => true,\n+                            _ if is_range_literal(self.tcx.sess.source_map(), expr) => true,\n                             _ => false,\n                         };\n                         let sugg_expr = if needs_parens { format!(\"({})\", src) } else { src };"}]}