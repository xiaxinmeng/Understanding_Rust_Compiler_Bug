{"sha": "e4779b505092cf1a394c187eb77ab2738be6f280", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0Nzc5YjUwNTA5MmNmMWEzOTRjMTg3ZWI3N2FiMjczOGJlNmYyODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-07T06:36:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-07T06:36:38Z"}, "message": "auto merge of #13165 : sfackler/rust/io-vec, r=alexcrichton\n\n`Reader`, `Writer`, `MemReader`, `MemWriter`, and `MultiWriter` now work with `Vec<u8>` instead of `~[u8]`. This does introduce some extra copies since `from_utf8_owned` isn't usable anymore, but I think that can't be helped until `~str`'s representation changes.", "tree": {"sha": "9a0199b15bd0b4e7b352b58e3c123e89d70af5d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a0199b15bd0b4e7b352b58e3c123e89d70af5d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4779b505092cf1a394c187eb77ab2738be6f280", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4779b505092cf1a394c187eb77ab2738be6f280", "html_url": "https://github.com/rust-lang/rust/commit/e4779b505092cf1a394c187eb77ab2738be6f280", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4779b505092cf1a394c187eb77ab2738be6f280/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31e8f2448c8cdd913566d5cb9a5cb9f0c014dcbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/31e8f2448c8cdd913566d5cb9a5cb9f0c014dcbc", "html_url": "https://github.com/rust-lang/rust/commit/31e8f2448c8cdd913566d5cb9a5cb9f0c014dcbc"}, {"sha": "fcf9b30f426fcf8fd0b6e0a044825fdfa4a1bfdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcf9b30f426fcf8fd0b6e0a044825fdfa4a1bfdb", "html_url": "https://github.com/rust-lang/rust/commit/fcf9b30f426fcf8fd0b6e0a044825fdfa4a1bfdb"}], "stats": {"total": 364, "additions": 187, "deletions": 177}, "files": [{"sha": "aa0fb838284cc859cc7e27fbe8643152b40f578c", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -84,8 +84,8 @@ pub fn run(lib_path: &str,\n \n             Some(Result {\n                 status: status,\n-                out: str::from_utf8_owned(output).unwrap(),\n-                err: str::from_utf8_owned(error).unwrap()\n+                out: str::from_utf8(output.as_slice()).unwrap().to_owned(),\n+                err: str::from_utf8(error.as_slice()).unwrap().to_owned()\n             })\n         },\n         Err(..) => None"}, {"sha": "b290bd2838ab3de017676584de998aa9ee2433ed", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -153,7 +153,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n     let src = File::open(testfile).read_to_end().unwrap();\n-    let src = str::from_utf8_owned(src).unwrap();\n+    let src = str::from_utf8(src.as_slice()).unwrap().to_owned();\n     let mut srcs = vec!(src);\n \n     let mut round = 0;\n@@ -177,7 +177,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n         Some(ref file) => {\n             let filepath = testfile.dir_path().join(file);\n             let s = File::open(&filepath).read_to_end().unwrap();\n-            str::from_utf8_owned(s).unwrap()\n+            str::from_utf8(s.as_slice()).unwrap().to_owned()\n           }\n           None => { (*srcs.get(srcs.len() - 2u)).clone() }\n         };\n@@ -1163,7 +1163,7 @@ fn disassemble_extract(config: &config, _props: &TestProps,\n \n fn count_extracted_lines(p: &Path) -> uint {\n     let x = File::open(&p.with_extension(\"ll\")).read_to_end().unwrap();\n-    let x = str::from_utf8_owned(x).unwrap();\n+    let x = str::from_utf8(x.as_slice()).unwrap();\n     x.lines().len()\n }\n "}, {"sha": "4f7583f0855afe6ffe92e0d2870667eb905844d1", "filename": "src/doc/complement-cheatsheet.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Fdoc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Fdoc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-cheatsheet.md?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -96,7 +96,7 @@ Use the [`lines`](http://static.rust-lang.org/doc/master/std/io/trait.Buffer.htm\n use std::io::BufferedReader;\n # use std::io::MemReader;\n \n-# let reader = MemReader::new(~[]);\n+# let reader = MemReader::new(vec!());\n \n let mut reader = BufferedReader::new(reader);\n for line in reader.lines() {"}, {"sha": "025dc2a25754bc4c560b3f049fb50a69266f4b5a", "filename": "src/librand/reader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freader.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -23,7 +23,7 @@ use Rng;\n /// use rand::{reader, Rng};\n /// use std::io::MemReader;\n ///\n-/// let mut rng = reader::ReaderRng::new(MemReader::new(~[1,2,3,4,5,6,7,8]));\n+/// let mut rng = reader::ReaderRng::new(MemReader::new(vec!(1,2,3,4,5,6,7,8)));\n /// println!(\"{:x}\", rng.gen::<uint>());\n /// ```\n pub struct ReaderRng<R> {\n@@ -80,7 +80,7 @@ mod test {\n         // transmute from the target to avoid endianness concerns.\n         let v = ~[1u64, 2u64, 3u64];\n         let bytes: ~[u8] = unsafe {cast::transmute(v)};\n-        let mut rng = ReaderRng::new(MemReader::new(bytes));\n+        let mut rng = ReaderRng::new(MemReader::new(bytes.move_iter().collect()));\n \n         assert_eq!(rng.next_u64(), 1);\n         assert_eq!(rng.next_u64(), 2);\n@@ -91,7 +91,7 @@ mod test {\n         // transmute from the target to avoid endianness concerns.\n         let v = ~[1u32, 2u32, 3u32];\n         let bytes: ~[u8] = unsafe {cast::transmute(v)};\n-        let mut rng = ReaderRng::new(MemReader::new(bytes));\n+        let mut rng = ReaderRng::new(MemReader::new(bytes.move_iter().collect()));\n \n         assert_eq!(rng.next_u32(), 1);\n         assert_eq!(rng.next_u32(), 2);\n@@ -102,7 +102,7 @@ mod test {\n         let v = [1u8, 2, 3, 4, 5, 6, 7, 8];\n         let mut w = [0u8, .. 8];\n \n-        let mut rng = ReaderRng::new(MemReader::new(v.to_owned()));\n+        let mut rng = ReaderRng::new(MemReader::new(Vec::from_slice(v)));\n         rng.fill_bytes(w);\n \n         assert!(v == w);\n@@ -111,7 +111,7 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_reader_rng_insufficient_bytes() {\n-        let mut rng = ReaderRng::new(MemReader::new(~[]));\n+        let mut rng = ReaderRng::new(MemReader::new(vec!()));\n         let mut v = [0u8, .. 3];\n         rng.fill_bytes(v);\n     }"}, {"sha": "9b795e6957cf399ba78e6c8435f21b8454e5eebc", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -59,8 +59,10 @@ fn run_ar(sess: &Session, args: &str, cwd: Option<&Path>,\n             if !o.status.success() {\n                 sess.err(format!(\"{} {} failed with: {}\", ar, args.connect(\" \"),\n                                  o.status));\n-                sess.note(format!(\"stdout ---\\n{}\", str::from_utf8(o.output).unwrap()));\n-                sess.note(format!(\"stderr ---\\n{}\", str::from_utf8(o.error).unwrap()));\n+                sess.note(format!(\"stdout ---\\n{}\",\n+                                  str::from_utf8(o.output.as_slice()).unwrap()));\n+                sess.note(format!(\"stderr ---\\n{}\",\n+                                  str::from_utf8(o.error.as_slice()).unwrap()));\n                 sess.abort_if_errors();\n             }\n             o\n@@ -129,7 +131,7 @@ impl<'a> Archive<'a> {\n     /// Lists all files in an archive\n     pub fn files(&self) -> Vec<~str> {\n         let output = run_ar(self.sess, \"t\", None, [&self.dst]);\n-        let output = str::from_utf8(output.output).unwrap();\n+        let output = str::from_utf8(output.output.as_slice()).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n         // just `\\n`\n         output.lines_any().map(|s| s.to_owned()).collect()"}, {"sha": "61725bc27d12247f55ae362856838092fc4d8694", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -350,7 +350,9 @@ pub mod write {\n                 if !prog.status.success() {\n                     sess.err(format!(\"linking with `{}` failed: {}\", cc, prog.status));\n                     sess.note(format!(\"{} arguments: '{}'\", cc, args.connect(\"' '\")));\n-                    sess.note(str::from_utf8_owned(prog.error + prog.output).unwrap());\n+                    let mut note = prog.error.clone();\n+                    note.push_all(prog.output.as_slice());\n+                    sess.note(str::from_utf8(note.as_slice()).unwrap().to_owned());\n                     sess.abort_if_errors();\n                 }\n             },\n@@ -942,7 +944,8 @@ fn link_rlib<'a>(sess: &'a Session,\n             let bc = obj_filename.with_extension(\"bc\");\n             let bc_deflated = obj_filename.with_extension(\"bc.deflate\");\n             match fs::File::open(&bc).read_to_end().and_then(|data| {\n-                fs::File::create(&bc_deflated).write(flate::deflate_bytes(data).as_slice())\n+                fs::File::create(&bc_deflated)\n+                    .write(flate::deflate_bytes(data.as_slice()).as_slice())\n             }) {\n                 Ok(()) => {}\n                 Err(e) => {\n@@ -1038,7 +1041,9 @@ fn link_natively(sess: &Session, dylib: bool, obj_filename: &Path,\n             if !prog.status.success() {\n                 sess.err(format!(\"linking with `{}` failed: {}\", cc_prog, prog.status));\n                 sess.note(format!(\"{} arguments: '{}'\", cc_prog, cc_args.connect(\"' '\")));\n-                sess.note(str::from_utf8_owned(prog.error + prog.output).unwrap());\n+                let mut output = prog.error.clone();\n+                output.push_all(prog.output.as_slice());\n+                sess.note(str::from_utf8(output.as_slice()).unwrap().to_owned());\n                 sess.abort_if_errors();\n             }\n         },"}, {"sha": "0668abea2b12f1c1e7dfd4bbf24af1410ee8114a", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -681,7 +681,7 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let src_name = source_name(input);\n-    let src = sess.codemap().get_filemap(src_name).src.as_bytes().to_owned();\n+    let src = Vec::from_slice(sess.codemap().get_filemap(src_name).src.as_bytes());\n     let mut rdr = MemReader::new(src);\n \n     match ppm {"}, {"sha": "95627cd1039af50a15a61a4c7b0f2038e8641e61", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -274,7 +274,7 @@ pub fn run_compiler(args: &[~str]) {\n         let ifile = matches.free.get(0).as_slice();\n         if ifile == \"-\" {\n             let contents = io::stdin().read_to_end().unwrap();\n-            let src = str::from_utf8_owned(contents).unwrap();\n+            let src = str::from_utf8(contents.as_slice()).unwrap().to_owned();\n             (d::StrInput(src), None)\n         } else {\n             (d::FileInput(Path::new(ifile)), Some(Path::new(ifile)))"}, {"sha": "a9cc45d2b13d5a8b581e514b159f4e89602ab576", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -741,7 +741,7 @@ impl<'a> Liveness<'a> {\n             self.write_vars(wr, ln, |idx| self.users.get(idx).writer);\n             write!(wr, \"  precedes {}]\", self.successors.get(ln.get()).to_str());\n         }\n-        str::from_utf8_owned(wr.unwrap()).unwrap()\n+        str::from_utf8(wr.unwrap().as_slice()).unwrap().to_owned()\n     }\n \n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {"}, {"sha": "1f080f35dfbe84311b8ce3dcb20ef476fa676818", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -34,7 +34,7 @@ pub fn highlight(src: &str, class: Option<&str>) -> ~str {\n          lexer::new_string_reader(&sess.span_diagnostic, fm),\n          class,\n          &mut out).unwrap();\n-    str::from_utf8_lossy(out.unwrap()).into_owned()\n+    str::from_utf8_lossy(out.unwrap().as_slice()).into_owned()\n }\n \n /// Exhausts the `lexer` writing the output into `out`."}, {"sha": "3ed4ece514ad0c6d629a5744ddb09ef74e27370b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -312,7 +312,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         }\n         try!(write!(&mut w, \"\\\\};\"));\n \n-        str::from_utf8_owned(w.unwrap()).unwrap()\n+        str::from_utf8(w.unwrap().as_slice()).unwrap().to_owned()\n     };\n \n     // Write out the shared files. Note that these are shared among all rustdoc\n@@ -487,7 +487,7 @@ impl<'a> SourceCollector<'a> {\n                        filename.ends_with(\"macros>\") => return Ok(()),\n             Err(e) => return Err(e)\n         };\n-        let contents = str::from_utf8_owned(contents).unwrap();\n+        let contents = str::from_utf8(contents.as_slice()).unwrap();\n \n         // Remove the utf-8 BOM if any\n         let contents = if contents.starts_with(\"\\ufeff\") {"}, {"sha": "f6b122ae2aaf3cba24a59510e177d16522b00245", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -389,7 +389,7 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n             let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n             krate.encode(&mut encoder).unwrap();\n         }\n-        str::from_utf8_owned(w.unwrap()).unwrap()\n+        str::from_utf8(w.unwrap().as_slice()).unwrap().to_owned()\n     };\n     let crate_json = match json::from_str(crate_json_str) {\n         Ok(j) => j,"}, {"sha": "be91279844209e54ab892f934eef2c2656185774", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -22,7 +22,7 @@ use test::Collector;\n fn load_string(input: &Path) -> io::IoResult<Option<~str>> {\n     let mut f = try!(io::File::open(input));\n     let d = try!(f.read_to_end());\n-    Ok(str::from_utf8_owned(d))\n+    Ok(str::from_utf8(d.as_slice()).map(|s| s.to_owned()))\n }\n macro_rules! load_or_return {\n     ($input: expr, $cant_read: expr, $not_utf8: expr) => {"}, {"sha": "06b57780abe22305644e8021dc96998c30fa4dbe", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -159,7 +159,8 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n             if should_fail && out.status.success() {\n                 fail!(\"test executable succeeded when it should have failed\");\n             } else if !should_fail && !out.status.success() {\n-                fail!(\"test executable failed:\\n{}\", str::from_utf8(out.error));\n+                fail!(\"test executable failed:\\n{}\",\n+                      str::from_utf8(out.error.as_slice()));\n             }\n         }\n     }"}, {"sha": "aff4b07f755b0a609b69b4cd0e5ce23343ff7213", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -309,7 +309,7 @@ impl<'a> Encoder<'a> {\n     }\n \n     /// Encode the specified struct into a json [u8]\n-    pub fn buffer_encode<T:Encodable<Encoder<'a>, io::IoError>>(to_encode_object: &T) -> ~[u8]  {\n+    pub fn buffer_encode<T:Encodable<Encoder<'a>, io::IoError>>(to_encode_object: &T) -> Vec<u8>  {\n        //Serialize the object in a string using a writer\n         let mut m = MemWriter::new();\n         {\n@@ -322,8 +322,8 @@ impl<'a> Encoder<'a> {\n \n     /// Encode the specified struct into a json str\n     pub fn str_encode<T:Encodable<Encoder<'a>, io::IoError>>(to_encode_object: &T) -> ~str  {\n-        let buff:~[u8] = Encoder::buffer_encode(to_encode_object);\n-        str::from_utf8_owned(buff).unwrap()\n+        let buff = Encoder::buffer_encode(to_encode_object);\n+        str::from_utf8(buff.as_slice()).unwrap().to_owned()\n     }\n }\n \n@@ -484,7 +484,7 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         let mut check_encoder = Encoder::new(&mut buf);\n         try!(f(&mut check_encoder));\n         let buf = buf.unwrap();\n-        let out = from_utf8(buf).unwrap();\n+        let out = from_utf8(buf.as_slice()).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' &&\n             out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n@@ -715,7 +715,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         let mut check_encoder = PrettyEncoder::new(&mut buf);\n         try!(f(&mut check_encoder));\n         let buf = buf.unwrap();\n-        let out = from_utf8(buf).unwrap();\n+        let out = from_utf8(buf.as_slice()).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' &&\n             out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n@@ -763,7 +763,7 @@ impl Json {\n     pub fn to_pretty_str(&self) -> ~str {\n         let mut s = MemWriter::new();\n         self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n-        str::from_utf8_owned(s.unwrap()).unwrap()\n+        str::from_utf8(s.unwrap().as_slice()).unwrap().to_owned()\n     }\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n@@ -1282,8 +1282,8 @@ pub fn from_reader(rdr: &mut io::Reader) -> DecodeResult<Json> {\n         Ok(c) => c,\n         Err(e) => return Err(IoError(e))\n     };\n-    let s = match str::from_utf8_owned(contents) {\n-        Some(s) => s,\n+    let s = match str::from_utf8(contents.as_slice()) {\n+        Some(s) => s.to_owned(),\n         None => return Err(ParseError(~\"contents not utf-8\", 0, 0))\n     };\n     let mut parser = Parser::new(s.chars());\n@@ -1927,7 +1927,7 @@ mod tests {\n \n         let mut m = MemWriter::new();\n         f(&mut m as &mut io::Writer);\n-        str::from_utf8_owned(m.unwrap()).unwrap()\n+        str::from_utf8(m.unwrap().as_slice()).unwrap().to_owned()\n     }\n \n     #[test]\n@@ -2528,7 +2528,7 @@ mod tests {\n             hm.encode(&mut encoder).unwrap();\n         }\n         let bytes = mem_buf.unwrap();\n-        let json_str = from_utf8(bytes).unwrap();\n+        let json_str = from_utf8(bytes.as_slice()).unwrap();\n         match from_str(json_str) {\n             Err(_) => fail!(\"Unable to parse json_str: {:?}\", json_str),\n             _ => {} // it parsed and we are good to go\n@@ -2548,7 +2548,7 @@ mod tests {\n             hm.encode(&mut encoder).unwrap();\n         }\n         let bytes = mem_buf.unwrap();\n-        let json_str = from_utf8(bytes).unwrap();\n+        let json_str = from_utf8(bytes.as_slice()).unwrap();\n         match from_str(json_str) {\n             Err(_) => fail!(\"Unable to parse json_str: {:?}\", json_str),\n             _ => {} // it parsed and we are good to go"}, {"sha": "6514743c42e67fdbb285a67ac4155d0f39a0a90a", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -490,7 +490,7 @@ use repr;\n use result::{Ok, Err};\n use str::StrSlice;\n use str;\n-use slice::ImmutableVector;\n+use slice::{Vector, ImmutableVector};\n use slice;\n \n pub use self::num::radix;\n@@ -795,7 +795,7 @@ pub fn format(args: &Arguments) -> ~str {\n pub unsafe fn format_unsafe(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n     let mut output = MemWriter::new();\n     write_unsafe(&mut output as &mut io::Writer, fmt, args).unwrap();\n-    return str::from_utf8_owned(output.unwrap()).unwrap();\n+    return str::from_utf8(output.unwrap().as_slice()).unwrap().to_owned();\n }\n \n impl<'a> Formatter<'a> {"}, {"sha": "c9d412973ec7ea517ed44796a361ed7730453665", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -405,7 +405,7 @@ mod test {\n \n     #[test]\n     fn test_buffered_reader() {\n-        let inner = MemReader::new(~[0, 1, 2, 3, 4]);\n+        let inner = MemReader::new(vec!(0, 1, 2, 3, 4));\n         let mut reader = BufferedReader::with_capacity(2, inner);\n \n         let mut buf = [0, 0, 0];\n@@ -502,12 +502,12 @@ mod test {\n \n     #[test]\n     fn test_read_until() {\n-        let inner = MemReader::new(~[0, 1, 2, 1, 0]);\n+        let inner = MemReader::new(vec!(0, 1, 2, 1, 0));\n         let mut reader = BufferedReader::with_capacity(2, inner);\n-        assert_eq!(reader.read_until(0), Ok(~[0]));\n-        assert_eq!(reader.read_until(2), Ok(~[1, 2]));\n-        assert_eq!(reader.read_until(1), Ok(~[1]));\n-        assert_eq!(reader.read_until(8), Ok(~[0]));\n+        assert_eq!(reader.read_until(0), Ok(vec!(0)));\n+        assert_eq!(reader.read_until(2), Ok(vec!(1, 2)));\n+        assert_eq!(reader.read_until(1), Ok(vec!(1)));\n+        assert_eq!(reader.read_until(8), Ok(vec!(0)));\n         assert!(reader.read_until(9).is_err());\n     }\n \n@@ -533,7 +533,7 @@ mod test {\n \n     #[test]\n     fn test_read_line() {\n-        let in_buf = MemReader::new(bytes!(\"a\\nb\\nc\").to_owned());\n+        let in_buf = MemReader::new(Vec::from_slice(bytes!(\"a\\nb\\nc\")));\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n         assert_eq!(reader.read_line(), Ok(~\"a\\n\"));\n         assert_eq!(reader.read_line(), Ok(~\"b\\n\"));\n@@ -543,7 +543,7 @@ mod test {\n \n     #[test]\n     fn test_lines() {\n-        let in_buf = MemReader::new(bytes!(\"a\\nb\\nc\").to_owned());\n+        let in_buf = MemReader::new(Vec::from_slice(bytes!(\"a\\nb\\nc\")));\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n         let mut it = reader.lines();\n         assert_eq!(it.next(), Some(Ok(~\"a\\n\")));"}, {"sha": "f87f4a69f17a6d32e1f7beb1bbbf485f2991990b", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -267,7 +267,7 @@ mod test {\n \n     #[test]\n     fn read_byte() {\n-        let mut reader = MemReader::new(~[10]);\n+        let mut reader = MemReader::new(vec!(10));\n         let byte = reader.read_byte();\n         assert!(byte == Ok(10));\n     }\n@@ -321,9 +321,9 @@ mod test {\n \n     #[test]\n     fn read_bytes() {\n-        let mut reader = MemReader::new(~[10, 11, 12, 13]);\n+        let mut reader = MemReader::new(vec!(10, 11, 12, 13));\n         let bytes = reader.read_exact(4).unwrap();\n-        assert!(bytes == ~[10, 11, 12, 13]);\n+        assert!(bytes == vec!(10, 11, 12, 13));\n     }\n \n     #[test]\n@@ -332,49 +332,49 @@ mod test {\n             count: 0,\n         };\n         let bytes = reader.read_exact(4).unwrap();\n-        assert!(bytes == ~[10, 11, 12, 13]);\n+        assert!(bytes == vec!(10, 11, 12, 13));\n     }\n \n     #[test]\n     fn read_bytes_eof() {\n-        let mut reader = MemReader::new(~[10, 11]);\n+        let mut reader = MemReader::new(vec!(10, 11));\n         assert!(reader.read_exact(4).is_err());\n     }\n \n     #[test]\n     fn push_exact() {\n-        let mut reader = MemReader::new(~[10, 11, 12, 13]);\n-        let mut buf = ~[8, 9];\n+        let mut reader = MemReader::new(vec!(10, 11, 12, 13));\n+        let mut buf = vec!(8, 9);\n         reader.push_exact(&mut buf, 4).unwrap();\n-        assert!(buf == ~[8, 9, 10, 11, 12, 13]);\n+        assert!(buf == vec!(8, 9, 10, 11, 12, 13));\n     }\n \n     #[test]\n     fn push_exact_partial() {\n         let mut reader = PartialReader {\n             count: 0,\n         };\n-        let mut buf = ~[8, 9];\n+        let mut buf = vec!(8, 9);\n         reader.push_exact(&mut buf, 4).unwrap();\n-        assert!(buf == ~[8, 9, 10, 11, 12, 13]);\n+        assert!(buf == vec!(8, 9, 10, 11, 12, 13));\n     }\n \n     #[test]\n     fn push_exact_eof() {\n-        let mut reader = MemReader::new(~[10, 11]);\n-        let mut buf = ~[8, 9];\n+        let mut reader = MemReader::new(vec!(10, 11));\n+        let mut buf = vec!(8, 9);\n         assert!(reader.push_exact(&mut buf, 4).is_err());\n-        assert!(buf == ~[8, 9, 10, 11]);\n+        assert!(buf == vec!(8, 9, 10, 11));\n     }\n \n     #[test]\n     fn push_exact_error() {\n         let mut reader = ErroringLaterReader {\n             count: 0,\n         };\n-        let mut buf = ~[8, 9];\n+        let mut buf = vec!(8, 9);\n         assert!(reader.push_exact(&mut buf, 4).is_err());\n-        assert!(buf == ~[8, 9, 10]);\n+        assert!(buf == vec!(8, 9, 10));\n     }\n \n     #[test]\n@@ -383,7 +383,7 @@ mod test {\n             count: 0,\n         };\n         let buf = reader.read_to_end().unwrap();\n-        assert!(buf == ~[10, 11, 12, 13]);\n+        assert!(buf == vec!(10, 11, 12, 13));\n     }\n \n     #[test]\n@@ -393,7 +393,7 @@ mod test {\n             count: 0,\n         };\n         let buf = reader.read_to_end().unwrap();\n-        assert!(buf == ~[10, 11]);\n+        assert!(buf == vec!(10, 11));\n     }\n \n     #[test]"}, {"sha": "2fea002d4197f85a59fc4617b65331b389dea61b", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -1074,7 +1074,7 @@ mod test {\n         check!(copy(&input, &output));\n \n         assert_eq!(check!(File::open(&output).read_to_end()),\n-                   (bytes!(\"foo\")).to_owned());\n+                   (Vec::from_slice(bytes!(\"foo\"))));\n     })\n \n     iotest!(fn copy_file_src_dir() {\n@@ -1114,7 +1114,7 @@ mod test {\n         }\n         assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n         assert_eq!(check!(File::open(&out).read_to_end()),\n-                   (bytes!(\"foobar\")).to_owned());\n+                   (Vec::from_slice(bytes!(\"foobar\"))));\n     })\n \n     #[cfg(not(windows))] // apparently windows doesn't like symlinks\n@@ -1146,7 +1146,7 @@ mod test {\n         }\n         assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n         assert_eq!(check!(File::open(&out).read_to_end()),\n-                   (bytes!(\"foobar\")).to_owned());\n+                   (Vec::from_slice(bytes!(\"foobar\"))));\n \n         // can't link to yourself\n         match link(&input, &input) {\n@@ -1206,7 +1206,7 @@ mod test {\n         check!(file.fsync());\n         assert_eq!(check!(stat(&path)).size, 10);\n         assert_eq!(check!(File::open(&path).read_to_end()),\n-                   (bytes!(\"foobar\", 0, 0, 0, 0)).to_owned());\n+                   (Vec::from_slice(bytes!(\"foobar\", 0, 0, 0, 0))));\n \n         // Truncate to a smaller length, don't seek, and then write something.\n         // Ensure that the intermediate zeroes are all filled in (we're seeked\n@@ -1217,7 +1217,7 @@ mod test {\n         check!(file.fsync());\n         assert_eq!(check!(stat(&path)).size, 9);\n         assert_eq!(check!(File::open(&path).read_to_end()),\n-                   (bytes!(\"fo\", 0, 0, 0, 0, \"wut\")).to_owned());\n+                   (Vec::from_slice(bytes!(\"fo\", 0, 0, 0, 0, \"wut\"))));\n         drop(file);\n     })\n "}, {"sha": "1cf6ed9a5d97dd9d4d6b7652451f803d24187ff6", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -18,6 +18,7 @@ use io;\n use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use slice;\n use slice::{Vector, ImmutableVector, MutableVector, OwnedCloneableVector};\n+use vec::Vec;\n \n fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n     // compute offset as signed and clamp to prevent overflow\n@@ -49,10 +50,10 @@ fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64>\n /// let mut w = MemWriter::new();\n /// w.write([0, 1, 2]);\n ///\n-/// assert_eq!(w.unwrap(), ~[0, 1, 2]);\n+/// assert_eq!(w.unwrap(), vec!(0, 1, 2));\n /// ```\n pub struct MemWriter {\n-    buf: ~[u8],\n+    buf: Vec<u8>,\n     pos: uint,\n }\n \n@@ -64,7 +65,7 @@ impl MemWriter {\n     /// Create a new `MemWriter`, allocating at least `n` bytes for\n     /// the internal buffer.\n     pub fn with_capacity(n: uint) -> MemWriter {\n-        MemWriter { buf: slice::with_capacity(n), pos: 0 }\n+        MemWriter { buf: Vec::with_capacity(n), pos: 0 }\n     }\n \n     /// Acquires an immutable reference to the underlying buffer of this\n@@ -75,7 +76,7 @@ impl MemWriter {\n     pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n \n     /// Unwraps this `MemWriter`, returning the underlying buffer\n-    pub fn unwrap(self) -> ~[u8] { self.buf }\n+    pub fn unwrap(self) -> Vec<u8> { self.buf }\n }\n \n impl Writer for MemWriter {\n@@ -127,19 +128,19 @@ impl Seek for MemWriter {\n /// # #[allow(unused_must_use)];\n /// use std::io::MemReader;\n ///\n-/// let mut r = MemReader::new(~[0, 1, 2]);\n+/// let mut r = MemReader::new(vec!(0, 1, 2));\n ///\n-/// assert_eq!(r.read_to_end().unwrap(), ~[0, 1, 2]);\n+/// assert_eq!(r.read_to_end().unwrap(), vec!(0, 1, 2));\n /// ```\n pub struct MemReader {\n-    buf: ~[u8],\n+    buf: Vec<u8>,\n     pos: uint\n }\n \n impl MemReader {\n     /// Creates a new `MemReader` which will read the buffer given. The buffer\n     /// can be re-acquired through `unwrap`\n-    pub fn new(buf: ~[u8]) -> MemReader {\n+    pub fn new(buf: Vec<u8>) -> MemReader {\n         MemReader {\n             buf: buf,\n             pos: 0\n@@ -159,7 +160,7 @@ impl MemReader {\n     pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n \n     /// Unwraps this `MemReader`, returning the underlying buffer\n-    pub fn unwrap(self) -> ~[u8] { self.buf }\n+    pub fn unwrap(self) -> Vec<u8> { self.buf }\n }\n \n impl Reader for MemReader {\n@@ -272,7 +273,7 @@ impl<'a> Seek for BufWriter<'a> {\n /// let mut buf = [0, 1, 2, 3];\n /// let mut r = BufReader::new(buf);\n ///\n-/// assert_eq!(r.read_to_end().unwrap(), ~[0, 1, 2, 3]);\n+/// assert_eq!(r.read_to_end().unwrap(), vec!(0, 1, 2, 3));\n /// ```\n pub struct BufReader<'a> {\n     buf: &'a [u8],\n@@ -425,7 +426,7 @@ mod test {\n \n     #[test]\n     fn test_mem_reader() {\n-        let mut reader = MemReader::new(~[0, 1, 2, 3, 4, 5, 6, 7]);\n+        let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n         let mut buf = [];\n         assert_eq!(reader.read(buf), Ok(0));\n         assert_eq!(reader.tell(), Ok(0));\n@@ -440,9 +441,9 @@ mod test {\n         assert_eq!(reader.read(buf), Ok(3));\n         assert_eq!(buf.slice(0, 3), &[5, 6, 7]);\n         assert!(reader.read(buf).is_err());\n-        let mut reader = MemReader::new(~[0, 1, 2, 3, 4, 5, 6, 7]);\n-        assert_eq!(reader.read_until(3).unwrap(), ~[0, 1, 2, 3]);\n-        assert_eq!(reader.read_until(3).unwrap(), ~[4, 5, 6, 7]);\n+        let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n+        assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n+        assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n         assert!(reader.read(buf).is_err());\n     }\n \n@@ -465,8 +466,8 @@ mod test {\n         assert_eq!(buf.slice(0, 3), &[5, 6, 7]);\n         assert!(reader.read(buf).is_err());\n         let mut reader = BufReader::new(in_buf);\n-        assert_eq!(reader.read_until(3).unwrap(), ~[0, 1, 2, 3]);\n-        assert_eq!(reader.read_until(3).unwrap(), ~[4, 5, 6, 7]);\n+        assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n+        assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n         assert!(reader.read(buf).is_err());\n     }\n \n@@ -525,7 +526,7 @@ mod test {\n         r.seek(10, SeekSet).unwrap();\n         assert!(r.read(&mut []).is_err());\n \n-        let mut r = MemReader::new(~[10]);\n+        let mut r = MemReader::new(vec!(10));\n         r.seek(10, SeekSet).unwrap();\n         assert!(r.read(&mut []).is_err());\n \n@@ -545,7 +546,7 @@ mod test {\n         let mut r = BufReader::new(buf);\n         assert!(r.seek(-1, SeekSet).is_err());\n \n-        let mut r = MemReader::new(~[10]);\n+        let mut r = MemReader::new(vec!(10));\n         assert!(r.seek(-1, SeekSet).is_err());\n \n         let mut r = MemWriter::new();\n@@ -558,7 +559,7 @@ mod test {\n \n     #[test]\n     fn io_fill() {\n-        let mut r = MemReader::new(~[1, 2, 3, 4, 5, 6, 7, 8]);\n+        let mut r = MemReader::new(vec!(1, 2, 3, 4, 5, 6, 7, 8));\n         let mut buf = [0, ..3];\n         assert_eq!(r.fill(buf), Ok(()));\n         assert_eq!(buf.as_slice(), &[1, 2, 3]);"}, {"sha": "97519adbc3f828e436e3b8e5238fba218733eb3a", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -225,8 +225,8 @@ use str::{StrSlice, OwnedStr};\n use str;\n use uint;\n use unstable::finally::try_finally;\n-use slice::{OwnedVector, MutableVector, ImmutableVector, OwnedCloneableVector};\n-use slice;\n+use slice::{Vector, OwnedVector, MutableVector, ImmutableVector, OwnedCloneableVector};\n+use vec::Vec;\n \n // Reexports\n pub use self::stdio::stdin;\n@@ -486,9 +486,9 @@ pub trait Reader {\n     /// or EOF. If `Ok(())` is returned, then all of the requested bytes were\n     /// pushed on to the vector, otherwise the amount `len` bytes couldn't be\n     /// read (an error was encountered), and the error is returned.\n-    fn push_exact(&mut self, buf: &mut ~[u8], len: uint) -> IoResult<()> {\n+    fn push_exact(&mut self, buf: &mut Vec<u8>, len: uint) -> IoResult<()> {\n         struct State<'a> {\n-            buf: &'a mut ~[u8],\n+            buf: &'a mut Vec<u8>,\n             total_read: uint\n         }\n \n@@ -526,8 +526,8 @@ pub trait Reader {\n     /// have already been consumed from the underlying reader, and they are lost\n     /// (not returned as part of the error). If this is unacceptable, then it is\n     /// recommended to use the `push_exact` or `read` methods.\n-    fn read_exact(&mut self, len: uint) -> IoResult<~[u8]> {\n-        let mut buf = slice::with_capacity(len);\n+    fn read_exact(&mut self, len: uint) -> IoResult<Vec<u8>> {\n+        let mut buf = Vec::with_capacity(len);\n         match self.push_exact(&mut buf, len) {\n             Ok(()) => Ok(buf),\n             Err(e) => Err(e),\n@@ -542,8 +542,8 @@ pub trait Reader {\n     /// discarded when an error is returned.\n     ///\n     /// When EOF is encountered, all bytes read up to that point are returned.\n-    fn read_to_end(&mut self) -> IoResult<~[u8]> {\n-        let mut buf = slice::with_capacity(DEFAULT_BUF_SIZE);\n+    fn read_to_end(&mut self) -> IoResult<Vec<u8>> {\n+        let mut buf = Vec::with_capacity(DEFAULT_BUF_SIZE);\n         loop {\n             match self.push_exact(&mut buf, DEFAULT_BUF_SIZE) {\n                 Ok(()) => {}\n@@ -564,8 +564,8 @@ pub trait Reader {\n     /// UTF-8 bytes.\n     fn read_to_str(&mut self) -> IoResult<~str> {\n         self.read_to_end().and_then(|s| {\n-            match str::from_utf8_owned(s) {\n-                Some(s) => Ok(s),\n+            match str::from_utf8(s.as_slice()) {\n+                Some(s) => Ok(s.to_owned()),\n                 None => Err(standard_error(InvalidInput)),\n             }\n         })\n@@ -1198,8 +1198,8 @@ pub trait Buffer: Reader {\n     /// valid UTF-8 sequence of bytes.\n     fn read_line(&mut self) -> IoResult<~str> {\n         self.read_until('\\n' as u8).and_then(|line|\n-            match str::from_utf8_owned(line) {\n-                Some(s) => Ok(s),\n+            match str::from_utf8(line.as_slice()) {\n+                Some(s) => Ok(s.to_owned()),\n                 None => Err(standard_error(InvalidInput)),\n             }\n         )\n@@ -1230,8 +1230,8 @@ pub trait Buffer: Reader {\n     /// have been read, otherwise the pending byte buffer is returned. This\n     /// is the reason that the byte buffer returned may not always contain the\n     /// delimiter.\n-    fn read_until(&mut self, byte: u8) -> IoResult<~[u8]> {\n-        let mut res = ~[];\n+    fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> {\n+        let mut res = Vec::new();\n \n         let mut used;\n         loop {"}, {"sha": "02c061c54dd9941067df412e00dfb652d158ce6d", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -718,14 +718,14 @@ mod test {\n         spawn(proc() {\n             let mut a = a;\n             let mut c = a.accept().unwrap();\n-            assert_eq!(c.read_to_end(), Ok(~[]));\n+            assert_eq!(c.read_to_end(), Ok(vec!()));\n             c.write([1]).unwrap();\n         });\n \n         let mut s = TcpStream::connect(addr).unwrap();\n         assert!(s.obj.close_write().is_ok());\n         assert!(s.write([1]).is_err());\n-        assert_eq!(s.read_to_end(), Ok(~[1]));\n+        assert_eq!(s.read_to_end(), Ok(vec!(1)));\n     })\n }\n "}, {"sha": "f0b96e2e76c0b9a862f6dd7bc5fcfbf90329e793", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -142,9 +142,9 @@ pub struct ProcessOutput {\n     /// The status (exit code) of the process.\n     pub status: ProcessExit,\n     /// The data that the process wrote to stdout.\n-    pub output: ~[u8],\n+    pub output: Vec<u8>,\n     /// The data that the process wrote to stderr.\n-    pub error: ~[u8],\n+    pub error: Vec<u8>,\n }\n \n /// Describes what to do with a standard io stream for a child process.\n@@ -277,8 +277,8 @@ impl Process {\n     /// };\n     ///\n     /// println!(\"status: {}\", output.status);\n-    /// println!(\"stdout: {}\", str::from_utf8_lossy(output.output));\n-    /// println!(\"stderr: {}\", str::from_utf8_lossy(output.error));\n+    /// println!(\"stdout: {}\", str::from_utf8_lossy(output.output.as_slice()));\n+    /// println!(\"stderr: {}\", str::from_utf8_lossy(output.error.as_slice()));\n     /// ```\n     pub fn output(prog: &str, args: &[~str]) -> IoResult<ProcessOutput> {\n         Process::new(prog, args).map(|mut p| p.wait_with_output())\n@@ -387,14 +387,14 @@ impl Process {\n     /// The stdin handle to the child is closed before waiting.\n     pub fn wait_with_output(&mut self) -> ProcessOutput {\n         drop(self.stdin.take());\n-        fn read(stream: Option<io::PipeStream>) -> Receiver<IoResult<~[u8]>> {\n+        fn read(stream: Option<io::PipeStream>) -> Receiver<IoResult<Vec<u8>>> {\n             let (tx, rx) = channel();\n             match stream {\n                 Some(stream) => spawn(proc() {\n                     let mut stream = stream;\n                     tx.send(stream.read_to_end())\n                 }),\n-                None => tx.send(Ok(~[]))\n+                None => tx.send(Ok(Vec::new()))\n             }\n             rx\n         }\n@@ -404,8 +404,8 @@ impl Process {\n         let status = self.wait();\n \n         ProcessOutput { status: status,\n-                        output: stdout.recv().ok().unwrap_or(~[]),\n-                        error:  stderr.recv().ok().unwrap_or(~[]) }\n+                        output: stdout.recv().ok().unwrap_or(Vec::new()),\n+                        error:  stderr.recv().ok().unwrap_or(Vec::new()) }\n     }\n }\n \n@@ -614,13 +614,13 @@ mod tests {\n \n         let ProcessOutput {status, output, error}\n              = Process::output(\"echo\", [~\"hello\"]).unwrap();\n-        let output_str = str::from_utf8_owned(output).unwrap();\n+        let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n         // FIXME #7224\n         if !running_on_valgrind() {\n-            assert_eq!(error, ~[]);\n+            assert_eq!(error, Vec::new());\n         }\n     })\n \n@@ -630,7 +630,7 @@ mod tests {\n              = Process::output(\"mkdir\", [~\".\"]).unwrap();\n \n         assert!(status.matches_exit_status(1));\n-        assert_eq!(output, ~[]);\n+        assert_eq!(output, Vec::new());\n         assert!(!error.is_empty());\n     })\n \n@@ -652,13 +652,13 @@ mod tests {\n \n         let mut prog = Process::new(\"echo\", [~\"hello\"]).unwrap();\n         let ProcessOutput {status, output, error} = prog.wait_with_output();\n-        let output_str = str::from_utf8_owned(output).unwrap();\n+        let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n         // FIXME #7224\n         if !running_on_valgrind() {\n-            assert_eq!(error, ~[]);\n+            assert_eq!(error, Vec::new());\n         }\n     })\n \n@@ -667,22 +667,22 @@ mod tests {\n         let mut prog = Process::new(\"echo\", [~\"hello\"]).unwrap();\n         let ProcessOutput {status, output, error} = prog.wait_with_output();\n \n-        let output_str = str::from_utf8_owned(output).unwrap();\n+        let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n         // FIXME #7224\n         if !running_on_valgrind() {\n-            assert_eq!(error, ~[]);\n+            assert_eq!(error, Vec::new());\n         }\n \n         let ProcessOutput {status, output, error} = prog.wait_with_output();\n \n         assert!(status.success());\n-        assert_eq!(output, ~[]);\n+        assert_eq!(output, Vec::new());\n         // FIXME #7224\n         if !running_on_valgrind() {\n-            assert_eq!(error, ~[]);\n+            assert_eq!(error, Vec::new());\n         }\n     })\n \n@@ -718,7 +718,7 @@ mod tests {\n         use os;\n         let mut prog = run_pwd(None);\n \n-        let output = str::from_utf8_owned(prog.wait_with_output().output).unwrap();\n+        let output = str::from_utf8(prog.wait_with_output().output.as_slice()).unwrap().to_owned();\n         let parent_dir = os::getcwd();\n         let child_dir = Path::new(output.trim());\n \n@@ -736,7 +736,7 @@ mod tests {\n         let parent_dir = os::getcwd().dir_path();\n         let mut prog = run_pwd(Some(&parent_dir));\n \n-        let output = str::from_utf8_owned(prog.wait_with_output().output).unwrap();\n+        let output = str::from_utf8(prog.wait_with_output().output.as_slice()).unwrap().to_owned();\n         let child_dir = Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n@@ -780,7 +780,7 @@ mod tests {\n         if running_on_valgrind() { return; }\n \n         let mut prog = run_env(None);\n-        let output = str::from_utf8_owned(prog.wait_with_output().output).unwrap();\n+        let output = str::from_utf8(prog.wait_with_output().output.as_slice()).unwrap().to_owned();\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -794,7 +794,7 @@ mod tests {\n         if running_on_valgrind() { return; }\n \n         let mut prog = run_env(None);\n-        let output = str::from_utf8_owned(prog.wait_with_output().output).unwrap();\n+        let output = str::from_utf8(prog.wait_with_output().output.as_slice()).unwrap().to_owned();\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -811,7 +811,7 @@ mod tests {\n \n         let mut prog = run_env(Some(new_env));\n         let result = prog.wait_with_output();\n-        let output = str::from_utf8_lossy(result.output).into_owned();\n+        let output = str::from_utf8_lossy(result.output.as_slice()).into_owned();\n \n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);"}, {"sha": "a69f6c10abf8ed03c99f1497bcf7e0caf0948e5e", "filename": "src/libstd/io/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fresult.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -87,7 +87,7 @@ mod test {\n         let mut writer: io::IoResult<MemWriter> = Ok(MemWriter::new());\n         writer.write([0, 1, 2]).unwrap();\n         writer.flush().unwrap();\n-        assert_eq!(writer.unwrap().unwrap(), ~[0, 1, 2]);\n+        assert_eq!(writer.unwrap().unwrap(), vec!(0, 1, 2));\n     }\n \n     #[test]\n@@ -108,7 +108,7 @@ mod test {\n     #[test]\n     fn test_option_reader() {\n         let mut reader: io::IoResult<MemReader> =\n-            Ok(MemReader::new(~[0, 1, 2, 3]));\n+            Ok(MemReader::new(vec!(0, 1, 2, 3)));\n         let mut buf = [0, 0];\n         reader.read(buf).unwrap();\n         assert_eq!(buf.as_slice(), &[0, 1]);"}, {"sha": "cbe157633b20f2347cfb7a1972eea44524c6a6e9", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -85,12 +85,12 @@ impl Reader for NullReader {\n \n /// A `Writer` which multiplexes writes to a set of `Writers`.\n pub struct MultiWriter {\n-    writers: ~[~Writer]\n+    writers: Vec<~Writer>\n }\n \n impl MultiWriter {\n     /// Creates a new `MultiWriter`\n-    pub fn new(writers: ~[~Writer]) -> MultiWriter {\n+    pub fn new(writers: Vec<~Writer>) -> MultiWriter {\n         MultiWriter { writers: writers }\n     }\n }\n@@ -204,31 +204,31 @@ mod test {\n \n     #[test]\n     fn test_limit_reader_unlimited() {\n-        let mut r = MemReader::new(~[0, 1, 2]);\n+        let mut r = MemReader::new(vec!(0, 1, 2));\n         {\n             let mut r = LimitReader::new(r.by_ref(), 4);\n-            assert_eq!(~[0, 1, 2], r.read_to_end().unwrap());\n+            assert_eq!(vec!(0, 1, 2), r.read_to_end().unwrap());\n         }\n     }\n \n     #[test]\n     fn test_limit_reader_limited() {\n-        let mut r = MemReader::new(~[0, 1, 2]);\n+        let mut r = MemReader::new(vec!(0, 1, 2));\n         {\n             let mut r = LimitReader::new(r.by_ref(), 2);\n-            assert_eq!(~[0, 1], r.read_to_end().unwrap());\n+            assert_eq!(vec!(0, 1), r.read_to_end().unwrap());\n         }\n-        assert_eq!(~[2], r.read_to_end().unwrap());\n+        assert_eq!(vec!(2), r.read_to_end().unwrap());\n     }\n \n     #[test]\n     fn test_limit_reader_limit() {\n-        let r = MemReader::new(~[0, 1, 2]);\n+        let r = MemReader::new(vec!(0, 1, 2));\n         let mut r = LimitReader::new(r, 3);\n         assert_eq!(3, r.limit());\n         assert_eq!(0, r.read_byte().unwrap());\n         assert_eq!(2, r.limit());\n-        assert_eq!(~[1, 2], r.read_to_end().unwrap());\n+        assert_eq!(vec!(1, 2), r.read_to_end().unwrap());\n         assert_eq!(0, r.limit());\n     }\n \n@@ -273,8 +273,8 @@ mod test {\n             }\n         }\n \n-        let mut multi = MultiWriter::new(~[~TestWriter as ~Writer,\n-                                           ~TestWriter as ~Writer]);\n+        let mut multi = MultiWriter::new(vec!(~TestWriter as ~Writer,\n+                                              ~TestWriter as ~Writer));\n         multi.write([1, 2, 3]).unwrap();\n         assert_eq!(2, unsafe { writes });\n         assert_eq!(0, unsafe { flushes });\n@@ -285,26 +285,26 @@ mod test {\n \n     #[test]\n     fn test_chained_reader() {\n-        let rs = ~[MemReader::new(~[0, 1]), MemReader::new(~[]),\n-                   MemReader::new(~[2, 3])];\n+        let rs = vec!(MemReader::new(vec!(0, 1)), MemReader::new(vec!()),\n+                      MemReader::new(vec!(2, 3)));\n         let mut r = ChainedReader::new(rs.move_iter());\n-        assert_eq!(~[0, 1, 2, 3], r.read_to_end().unwrap());\n+        assert_eq!(vec!(0, 1, 2, 3), r.read_to_end().unwrap());\n     }\n \n     #[test]\n     fn test_tee_reader() {\n-        let mut r = TeeReader::new(MemReader::new(~[0, 1, 2]),\n+        let mut r = TeeReader::new(MemReader::new(vec!(0, 1, 2)),\n                                    MemWriter::new());\n-        assert_eq!(~[0, 1, 2], r.read_to_end().unwrap());\n+        assert_eq!(vec!(0, 1, 2), r.read_to_end().unwrap());\n         let (_, w) = r.unwrap();\n-        assert_eq!(~[0, 1, 2], w.unwrap());\n+        assert_eq!(vec!(0, 1, 2), w.unwrap());\n     }\n \n     #[test]\n     fn test_copy() {\n-        let mut r = MemReader::new(~[0, 1, 2, 3, 4]);\n+        let mut r = MemReader::new(vec!(0, 1, 2, 3, 4));\n         let mut w = MemWriter::new();\n         copy(&mut r, &mut w).unwrap();\n-        assert_eq!(~[0, 1, 2, 3, 4], w.unwrap());\n+        assert_eq!(vec!(0, 1, 2, 3, 4), w.unwrap());\n     }\n }"}, {"sha": "e12e0234d96503343a154d8c3a61298c24d9bf2f", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -28,7 +28,7 @@ use reflect::{MovePtr, align};\n use result::{Ok, Err};\n use str::StrSlice;\n use to_str::ToStr;\n-use slice::OwnedVector;\n+use slice::{Vector, OwnedVector};\n use intrinsics::{Disr, Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n use raw;\n \n@@ -608,7 +608,7 @@ pub fn repr_to_str<T>(t: &T) -> ~str {\n \n     let mut result = io::MemWriter::new();\n     write_repr(&mut result as &mut io::Writer, t).unwrap();\n-    str::from_utf8_owned(result.unwrap()).unwrap()\n+    str::from_utf8(result.unwrap().as_slice()).unwrap().to_owned()\n }\n \n #[cfg(test)]\n@@ -626,7 +626,7 @@ fn test_repr() {\n     fn exact_test<T>(t: &T, e:&str) {\n         let mut m = io::MemWriter::new();\n         write_repr(&mut m as &mut io::Writer, t).unwrap();\n-        let s = str::from_utf8_owned(m.unwrap()).unwrap();\n+        let s = str::from_utf8(m.unwrap().as_slice()).unwrap().to_owned();\n         assert_eq!(s.as_slice(), e);\n     }\n "}, {"sha": "bf8c15c20abbd0e09641bb0cf0321fb515891e39", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -756,7 +756,7 @@ mod test {\n     macro_rules! t( ($a:expr, $b:expr) => ({\n         let mut m = MemWriter::new();\n         super::demangle(&mut m, $a).unwrap();\n-        assert_eq!(str::from_utf8_owned(m.unwrap()).unwrap(), $b.to_owned());\n+        assert_eq!(str::from_utf8(m.unwrap().as_slice()).unwrap().to_owned(), $b.to_owned());\n     }) )\n \n     #[test]"}, {"sha": "008532bcafe67cb3a237fbb4155dfda54f0e8e97", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -113,13 +113,13 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n         Ok(bytes) => bytes,\n     };\n-    match str::from_utf8_owned(bytes) {\n+    match str::from_utf8(bytes.as_slice()) {\n         Some(src) => {\n             // Add this input file to the code map to make it available as\n             // dependency information\n             let filename = file.display().to_str();\n             let interned = token::intern_and_get_ident(src);\n-            cx.codemap().new_filemap(filename, src);\n+            cx.codemap().new_filemap(filename, src.to_owned());\n \n             base::MRExpr(cx.expr_str(sp, interned))\n         }"}, {"sha": "bb812f7f6b4136c16009afeeed3d78dbe957994e", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -350,7 +350,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n                                     srdr: &mut io::Reader)\n                                  -> (Vec<Comment>, Vec<Literal>) {\n     let src = srdr.read_to_end().unwrap();\n-    let src = str::from_utf8_owned(src).unwrap();\n+    let src = str::from_utf8(src.as_slice()).unwrap().to_owned();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n     let mut rdr = lexer::new_low_level_string_reader(span_diagnostic, filemap);"}, {"sha": "35f9898ebbbf76345d6b62341f295e733063f2b5", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -228,9 +228,10 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n             unreachable!()\n         }\n     };\n-    match str::from_utf8_owned(bytes) {\n+    match str::from_utf8(bytes.as_slice()) {\n         Some(s) => {\n-            return string_to_filemap(sess, s, path.as_str().unwrap().to_str())\n+            return string_to_filemap(sess, s.to_owned(),\n+                                     path.as_str().unwrap().to_str())\n         }\n         None => err(format!(\"{} is not UTF-8 encoded\", path.display())),\n     }\n@@ -292,7 +293,7 @@ mod test {\n         let mut writer = MemWriter::new();\n         let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n         let _ = val.encode(&mut encoder);\n-        str::from_utf8_owned(writer.unwrap()).unwrap()\n+        str::from_utf8(writer.unwrap().as_slice()).unwrap().to_owned()\n     }\n \n     // produce a codemap::span"}, {"sha": "37ef3c133a57f639d08c6e9a583e1b84492896da", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -208,8 +208,8 @@ pub fn parse(file: &mut io::Reader,\n \n     // don't read NUL\n     let bytes = try!(file.read_exact(names_bytes as uint - 1));\n-    let names_str = match str::from_utf8_owned(bytes) {\n-        Some(s) => s, None => return Err(~\"input not utf-8\"),\n+    let names_str = match str::from_utf8(bytes.as_slice()) {\n+        Some(s) => s.to_owned(), None => return Err(~\"input not utf-8\"),\n     };\n \n     let term_names: Vec<~str> = names_str.split('|').map(|s| s.to_owned()).collect();"}, {"sha": "d04aa4082c45c4e533a5a4870a38986f30527a3b", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -1015,7 +1015,7 @@ mod tests {\n             use std::io::MemWriter;\n             let mut m = MemWriter::new();\n             write_boxplot(&mut m as &mut io::Writer, s, 30).unwrap();\n-            let out = str::from_utf8_owned(m.unwrap()).unwrap();\n+            let out = str::from_utf8(m.unwrap().as_slice()).unwrap().to_owned();\n             assert_eq!(out, expected);\n         }\n "}, {"sha": "cd8e36b3c93acd83fd0fa027913498cd724b21b7", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -460,7 +460,7 @@ pub fn query_to_str(query: &Query) -> ~str {\n         write!(&mut writer, \"{}={}\", encode_component(*k),\n                encode_component(*v));\n     }\n-    str::from_utf8_lossy(writer.unwrap()).into_owned()\n+    str::from_utf8_lossy(writer.unwrap().as_slice()).into_owned()\n }\n \n /**"}, {"sha": "af1958127f97488b699e01a1a2b4c25ab02d4abb", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -256,7 +256,7 @@ fn json_encode<'a, T:Encodable<json::Encoder<'a>, io::IoError>>(t: &T) -> ~str {\n     let mut writer = MemWriter::new();\n     let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n     let _ = t.encode(&mut encoder);\n-    str::from_utf8_owned(writer.unwrap()).unwrap()\n+    str::from_utf8(writer.unwrap().as_slice()).unwrap().to_owned()\n }\n \n // FIXME(#5121)\n@@ -479,7 +479,7 @@ impl<'a, T:Send +\n fn test() {\n     use std::os;\n     use std::io::{fs, Process};\n-    use std::str::from_utf8_owned;\n+    use std::str::from_utf8;\n \n     // Create a path to a new file 'filename' in the directory in which\n     // this test is running.\n@@ -505,7 +505,7 @@ fn test() {\n         let pth = pth.clone();\n \n         let contents = File::open(&pth).read_to_end().unwrap();\n-        let file_content = from_utf8_owned(contents).unwrap();\n+        let file_content = from_utf8(contents.as_slice()).unwrap().to_owned();\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prep.declare_input(\"file\", pth.as_str().unwrap(), file_content);"}, {"sha": "4c367b8539490ce9acffa3fa0ca1f910e4d45e0d", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -154,7 +154,7 @@ fn main() {\n \n     let rdr = if os::getenv(\"RUST_BENCH\").is_some() {\n         let foo = include_bin!(\"shootout-k-nucleotide.data\");\n-        ~MemReader::new(foo.to_owned()) as ~Reader\n+        ~MemReader::new(Vec::from_slice(foo)) as ~Reader\n     } else {\n         ~stdio::stdin() as ~Reader\n     };"}, {"sha": "4ee4f94d4354bc8e8e3685f9f267c9b3a6f52433", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -44,7 +44,7 @@ fn main() {\n     };\n     let mut data = data.unwrap();\n \n-    for seq in data.mut_split(|c| *c == '>' as u8) {\n+    for seq in data.as_mut_slice().mut_split(|c| *c == '>' as u8) {\n         // skip header and last \\n\n         let begin = match seq.iter().position(|c| *c == '\\n' as u8) {\n             None => continue,\n@@ -80,5 +80,5 @@ fn main() {\n         }\n     }\n \n-    stdout().write(data).unwrap();\n+    stdout().write(data.as_slice()).unwrap();\n }"}, {"sha": "66ddbac05134200be493300d55306063c551c17a", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -58,7 +58,7 @@ fn main() {\n         // rustc is passed to us with --out-dir and -L etc., so we\n         // can't exec it directly\n         let result = Process::output(\"sh\", [~\"-c\", rustc + \" \" + main_file_str]).unwrap();\n-        let err = str::from_utf8_lossy(result.error);\n+        let err = str::from_utf8_lossy(result.error.as_slice());\n \n         // positive test so that this test will be updated when the\n         // compiler changes."}, {"sha": "faa22962290e7ae01f98b896270250dfb4258e83", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -55,7 +55,7 @@ fn main() {\n         // can't exec it directly\n         let result = Process::output(\"sh\", [~\"-c\", rustc + \" \" + main_file_str]).unwrap();\n \n-        let err = str::from_utf8_lossy(result.error);\n+        let err = str::from_utf8_lossy(result.error.as_slice());\n \n         // the span should end the line (e.g no extra ~'s)\n         let expected_span = \"^\" + \"~\".repeat(n - 1) + \"\\n\";"}, {"sha": "a34403daaab3ac277e1e9bec5759975f6333b928", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -53,7 +53,7 @@ fn runtest(me: &str) {\n     }).unwrap();\n     let out = p.wait_with_output();\n     assert!(!out.status.success());\n-    let s = str::from_utf8(out.error).unwrap();\n+    let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(s.contains(\"stack backtrace\") && s.contains(\"foo::h\"),\n             \"bad output: {}\", s);\n \n@@ -65,7 +65,7 @@ fn runtest(me: &str) {\n     }).unwrap();\n     let out = p.wait_with_output();\n     assert!(!out.status.success());\n-    let s = str::from_utf8(out.error).unwrap();\n+    let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(!s.contains(\"stack backtrace\") && !s.contains(\"foo::h\"),\n             \"bad output2: {}\", s);\n \n@@ -77,7 +77,7 @@ fn runtest(me: &str) {\n     }).unwrap();\n     let out = p.wait_with_output();\n     assert!(!out.status.success());\n-    let s = str::from_utf8(out.error).unwrap();\n+    let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(s.contains(\"stack backtrace\") && s.contains(\"double::h\"),\n             \"bad output3: {}\", s);\n \n@@ -90,7 +90,7 @@ fn runtest(me: &str) {\n     }).unwrap();\n     let out = p.wait_with_output();\n     assert!(!out.status.success());\n-    let s = str::from_utf8(out.error).unwrap();\n+    let s = str::from_utf8(out.error.as_slice()).unwrap();\n     let mut i = 0;\n     for _ in range(0, 2) {\n         i += s.slice_from(i + 10).find_str(\"stack backtrace\").unwrap() + 10;"}, {"sha": "1676463e544dbec8d98db0af06ce2df5e0baa08c", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -174,7 +174,7 @@ fn test_write() {\n         writeln!(w, \"{foo}\", foo=\"bar\");\n     }\n \n-    let s = str::from_utf8_owned(buf.unwrap()).unwrap();\n+    let s = str::from_utf8(buf.unwrap().as_slice()).unwrap().to_owned();\n     t!(s, \"34helloline\\nbar\\n\");\n }\n \n@@ -198,7 +198,7 @@ fn test_format_args() {\n         format_args!(|args| { fmt::write(w, args); }, \"test\");\n         format_args!(|args| { fmt::write(w, args); }, \"{test}\", test=3);\n     }\n-    let s = str::from_utf8_owned(buf.unwrap()).unwrap();\n+    let s = str::from_utf8(buf.unwrap().as_slice()).unwrap().to_owned();\n     t!(s, \"1test3\");\n \n     let s = format_args!(fmt::format, \"hello {}\", \"world\");"}, {"sha": "2e710cbf5c86c82f8af8dda0b9654f266de3170c", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4779b505092cf1a394c187eb77ab2738be6f280/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=e4779b505092cf1a394c187eb77ab2738be6f280", "patch": "@@ -43,12 +43,12 @@ fn main() {\n     } else {\n         let silent = Process::output(args[0], [~\"silent\"]).unwrap();\n         assert!(!silent.status.success());\n-        let error = str::from_utf8_lossy(silent.error);\n+        let error = str::from_utf8_lossy(silent.error.as_slice());\n         assert!(error.as_slice().contains(\"has overflowed its stack\"));\n \n         let loud = Process::output(args[0], [~\"loud\"]).unwrap();\n         assert!(!loud.status.success());\n-        let error = str::from_utf8_lossy(silent.error);\n+        let error = str::from_utf8_lossy(silent.error.as_slice());\n         assert!(error.as_slice().contains(\"has overflowed its stack\"));\n     }\n }"}]}