{"sha": "537889aa78c984ee6484d16fec4a67f35778aec6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNzg4OWFhNzhjOTg0ZWU2NDg0ZDE2ZmVjNGE2N2YzNTc3OGFlYzY=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-01-21T19:16:00Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-01-21T19:16:00Z"}, "message": "Fix type inference problems in tests and docs", "tree": {"sha": "275a624afad3249473407eca83548f3bcb6e46fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/275a624afad3249473407eca83548f3bcb6e46fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/537889aa78c984ee6484d16fec4a67f35778aec6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/537889aa78c984ee6484d16fec4a67f35778aec6", "html_url": "https://github.com/rust-lang/rust/commit/537889aa78c984ee6484d16fec4a67f35778aec6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/537889aa78c984ee6484d16fec4a67f35778aec6/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da8023d653618431f8e1c651e0c3b83fa0d4269a", "url": "https://api.github.com/repos/rust-lang/rust/commits/da8023d653618431f8e1c651e0c3b83fa0d4269a", "html_url": "https://github.com/rust-lang/rust/commit/da8023d653618431f8e1c651e0c3b83fa0d4269a"}], "stats": {"total": 46, "additions": 23, "deletions": 23}, "files": [{"sha": "b92d38215c29b3ecdd66ba4b99566ad51612f8ed", "filename": "src/doc/intro.md", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/537889aa78c984ee6484d16fec4a67f35778aec6/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/537889aa78c984ee6484d16fec4a67f35778aec6/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=537889aa78c984ee6484d16fec4a67f35778aec6", "patch": "@@ -480,14 +480,12 @@ use std::sync::{Arc,Mutex};\n fn main() {\n     let numbers = Arc::new(Mutex::new(vec![1is, 2, 3]));\n \n-    for i in 0..3 {\n+    for i in 0us..3 {\n         let number = numbers.clone();\n         Thread::spawn(move || {\n             let mut array = number.lock().unwrap();\n-\n-            array[i as usize] += 1;\n-\n-            println!(\"numbers[{}] is {}\", i, array[i as usize]);\n+            array[i] += 1;\n+            println!(\"numbers[{}] is {}\", i, array[i]);\n         });\n     }\n }"}, {"sha": "4301149d1f8b3d62a26c07ba395f43976c5c3a5c", "filename": "src/doc/trpl/looping.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/537889aa78c984ee6484d16fec4a67f35778aec6/src%2Fdoc%2Ftrpl%2Flooping.md", "raw_url": "https://github.com/rust-lang/rust/raw/537889aa78c984ee6484d16fec4a67f35778aec6/src%2Fdoc%2Ftrpl%2Flooping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flooping.md?ref=537889aa78c984ee6484d16fec4a67f35778aec6", "patch": "@@ -123,7 +123,7 @@ We now loop forever with `loop` and use `break` to break out early.\n iteration. This will only print the odd numbers:\n \n ```{rust}\n-for x in 0..10 {\n+for x in 0u32..10 {\n     if x % 2 == 0 { continue; }\n \n     println!(\"{}\", x);"}, {"sha": "a801a1ab0e9217e1982f406aeabe5160b42662ef", "filename": "src/doc/trpl/threads.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/537889aa78c984ee6484d16fec4a67f35778aec6/src%2Fdoc%2Ftrpl%2Fthreads.md", "raw_url": "https://github.com/rust-lang/rust/raw/537889aa78c984ee6484d16fec4a67f35778aec6/src%2Fdoc%2Ftrpl%2Fthreads.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthreads.md?ref=537889aa78c984ee6484d16fec4a67f35778aec6", "patch": "@@ -179,7 +179,7 @@ for init_val in 0 .. 3 {\n }\n \n let result = rx.recv().unwrap() + rx.recv().unwrap() + rx.recv().unwrap();\n-# fn some_expensive_computation(_i: u32) -> u32 { 42 }\n+# fn some_expensive_computation(_i: i32) -> i32 { 42 }\n ```\n \n Cloning a `Sender` produces a new handle to the same channel, allowing multiple\n@@ -207,7 +207,7 @@ let rxs = (0 .. 3).map(|&:init_val| {\n \n // Wait on each port, accumulating the results\n let result = rxs.iter().fold(0, |&:accum, rx| accum + rx.recv().unwrap() );\n-# fn some_expensive_computation(_i: u32) -> u32 { 42 }\n+# fn some_expensive_computation(_i: i32) -> i32 { 42 }\n ```\n \n ## Backgrounding computations: Futures"}, {"sha": "4182f8b651b2eaf1fec970b70fa031de789457ce", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/537889aa78c984ee6484d16fec4a67f35778aec6/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/537889aa78c984ee6484d16fec4a67f35778aec6/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=537889aa78c984ee6484d16fec4a67f35778aec6", "patch": "@@ -41,7 +41,7 @@\n extern crate arena;\n \n use std::iter::range_step;\n-use std::thread::Thread;\n+use std::thread::{Thread, JoinGuard};\n use arena::TypedArena;\n \n struct Tree<'a> {\n@@ -71,6 +71,18 @@ fn bottom_up_tree<'r>(arena: &'r TypedArena<Tree<'r>>, item: i32, depth: i32)\n     }\n }\n \n+fn inner(depth: i32, iterations: i32) -> String {\n+    let mut chk = 0;\n+    for i in 1 .. iterations + 1 {\n+        let arena = TypedArena::new();\n+        let a = bottom_up_tree(&arena, i, depth);\n+        let b = bottom_up_tree(&arena, -i, depth);\n+        chk += item_check(&a) + item_check(&b);\n+    }\n+    format!(\"{}\\t trees of depth {}\\t check: {}\",\n+            iterations * 2, depth, chk)\n+}\n+\n fn main() {\n     let args = std::os::args();\n     let args = args.as_slice();\n@@ -97,20 +109,10 @@ fn main() {\n     let long_lived_tree = bottom_up_tree(&long_lived_arena, 0, max_depth);\n \n     let messages = range_step(min_depth, max_depth + 1, 2).map(|depth| {\n-            use std::num::Int;\n-            let iterations = 2.pow((max_depth - depth + min_depth) as usize);\n-            Thread::scoped(move|| {\n-                let mut chk = 0;\n-                for i in 1 .. iterations + 1 {\n-                    let arena = TypedArena::new();\n-                    let a = bottom_up_tree(&arena, i, depth);\n-                    let b = bottom_up_tree(&arena, -i, depth);\n-                    chk += item_check(&a) + item_check(&b);\n-                }\n-                format!(\"{}\\t trees of depth {}\\t check: {}\",\n-                        iterations * 2, depth, chk)\n-            })\n-        }).collect::<Vec<_>>();\n+        use std::num::Int;\n+        let iterations = 2.pow((max_depth - depth + min_depth) as usize);\n+        Thread::scoped(move || inner(depth, iterations))\n+    }).collect::<Vec<_>>();\n \n     for message in messages.into_iter() {\n         println!(\"{}\", message.join().ok().unwrap());"}]}