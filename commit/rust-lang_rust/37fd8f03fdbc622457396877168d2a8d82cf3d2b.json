{"sha": "37fd8f03fdbc622457396877168d2a8d82cf3d2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3ZmQ4ZjAzZmRiYzYyMjQ1NzM5Njg3NzE2OGQyYThkODJjZjNkMmI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-08-02T23:59:58Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-08-09T21:11:55Z"}, "message": "rustpkg: Simplify the PkgId struct\n\nGet rid of special cases for names beginning with \"rust-\" or\ncontaining hyphens, and just store a Path in a package ID. The Rust-identifier\nfor the crate is none of rustpkg's business.", "tree": {"sha": "5c866d538dc1900003ee925a63bf3bfba0fc7b87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c866d538dc1900003ee925a63bf3bfba0fc7b87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37fd8f03fdbc622457396877168d2a8d82cf3d2b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37fd8f03fdbc622457396877168d2a8d82cf3d2b", "html_url": "https://github.com/rust-lang/rust/commit/37fd8f03fdbc622457396877168d2a8d82cf3d2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37fd8f03fdbc622457396877168d2a8d82cf3d2b/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96fd606dddba6bd4773c41be66c44fc076a96ff8", "url": "https://api.github.com/repos/rust-lang/rust/commits/96fd606dddba6bd4773c41be66c44fc076a96ff8", "html_url": "https://github.com/rust-lang/rust/commit/96fd606dddba6bd4773c41be66c44fc076a96ff8"}], "stats": {"total": 288, "additions": 99, "deletions": 189}, "files": [{"sha": "6165fbc855759d5b10b400678b1f1185ffbe4420", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37fd8f03fdbc622457396877168d2a8d82cf3d2b/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/37fd8f03fdbc622457396877168d2a8d82cf3d2b/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=37fd8f03fdbc622457396877168d2a8d82cf3d2b", "patch": "@@ -349,7 +349,8 @@ $(3)/stage$(1)/test/rustpkgtest-$(2)$$(X_$(2)):\t\t\t\t\t\\\n \t\t$$(SREQ$(1)_T_$(2)_H_$(3)) \\\n \t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBSYNTAX_$(2)) \\\n \t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC_$(2)) \\\n-\t\t$$(TBIN$(1)_T_$(2)_H_$(3))/rustpkg$$(X_$(2))\n+\t\t$$(TBIN$(1)_T_$(2)_H_$(3))/rustpkg$$(X_$(2)) \\\n+\t\t$$(TBIN$(1)_T_$(2)_H_$(3))/rustc$$(X_$(2))\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n "}, {"sha": "e3b3252587a082662f9258e33f98885a3302cfa1", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 40, "deletions": 31, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/37fd8f03fdbc622457396877168d2a8d82cf3d2b/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37fd8f03fdbc622457396877168d2a8d82cf3d2b/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=37fd8f03fdbc622457396877168d2a8d82cf3d2b", "patch": "@@ -8,43 +8,44 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use package_path::{RemotePath, LocalPath, normalize, hash};\n use version::{try_getting_version, try_getting_local_version,\n               Version, NoVersion, split_version};\n+use std::rt::io::Writer;\n+use std::hash::Streaming;\n+use std::hash;\n \n /// Path-fragment identifier of a package such as\n /// 'github.com/graydon/test'; path must be a relative\n /// path with >=1 component.\n #[deriving(Clone)]\n pub struct PkgId {\n-    /// Remote path: for example, github.com/mozilla/quux-whatever\n-    remote_path: RemotePath,\n-    /// Local path: for example, /home/quux/github.com/mozilla/quux_whatever\n-    /// Note that '-' normalizes to '_' when mapping a remote path\n-    /// onto a local path\n-    /// Also, this will change when we implement #6407, though we'll still\n-    /// need to keep track of separate local and remote paths\n-    local_path: LocalPath,\n-    /// Short name. This is the local path's filestem, but we store it\n+    /// This is a path, on the local filesystem, referring to where the\n+    /// files for this package live. For example:\n+    /// github.com/mozilla/quux-whatever (it's assumed that if we're\n+    /// working with a package ID of this form, rustpkg has already cloned\n+    /// the sources into a local directory in the RUST_PATH).\n+    path: Path,\n+    /// Short name. This is the path's filestem, but we store it\n     /// redundantly so as to not call get() everywhere (filestem() returns an\n     /// option)\n+    /// The short name does not need to be a valid Rust identifier.\n+    /// Users can write: `extern mod foo = \"...\";` to get around the issue\n+    /// of package IDs whose short names aren't valid Rust identifiers.\n     short_name: ~str,\n+    /// The requested package version.\n     version: Version\n }\n \n impl Eq for PkgId {\n     fn eq(&self, p: &PkgId) -> bool {\n-        *p.local_path == *self.local_path && p.version == self.version\n+        p.path == self.path && p.version == self.version\n     }\n     fn ne(&self, p: &PkgId) -> bool {\n         !(self.eq(p))\n     }\n }\n \n impl PkgId {\n-    // The PkgId constructor takes a Path argument so as\n-    // to be able to infer the version if the path refers\n-    // to a local git repository\n     pub fn new(s: &str) -> PkgId {\n         use conditions::bad_pkg_id::cond;\n \n@@ -63,40 +64,37 @@ impl PkgId {\n             }\n         };\n \n-        let p = Path(s);\n-        if p.is_absolute {\n-            return cond.raise((p, ~\"absolute pkgid\"));\n+        let path = Path(s);\n+        if path.is_absolute {\n+            return cond.raise((path, ~\"absolute pkgid\"));\n         }\n-        if p.components.len() < 1 {\n-            return cond.raise((p, ~\"0-length pkgid\"));\n+        if path.components.len() < 1 {\n+            return cond.raise((path, ~\"0-length pkgid\"));\n         }\n-        let remote_path = RemotePath(p);\n-        let local_path = normalize(remote_path.clone());\n-        let short_name = local_path.clone().filestem().expect(fmt!(\"Strange path! %s\", s));\n+        let short_name = path.clone().filestem().expect(fmt!(\"Strange path! %s\", s));\n \n         let version = match given_version {\n             Some(v) => v,\n-            None => match try_getting_local_version(&*local_path) {\n+            None => match try_getting_local_version(&path) {\n                 Some(v) => v,\n-                None => match try_getting_version(&remote_path) {\n+                None => match try_getting_version(&path) {\n                     Some(v) => v,\n                     None => NoVersion\n                 }\n             }\n         };\n \n-        debug!(\"local_path = %s, remote_path = %s\", local_path.to_str(), remote_path.to_str());\n+        debug!(\"path = %s\", path.to_str());\n         PkgId {\n-            local_path: local_path,\n-            remote_path: remote_path,\n+            path: path,\n             short_name: short_name,\n             version: version\n         }\n     }\n \n     pub fn hash(&self) -> ~str {\n-        fmt!(\"%s-%s-%s\", self.remote_path.to_str(),\n-             hash(self.remote_path.to_str() + self.version.to_str()),\n+        fmt!(\"%s-%s-%s\", self.path.to_str(),\n+             hash(self.path.to_str() + self.version.to_str()),\n              self.version.to_str())\n     }\n \n@@ -106,13 +104,24 @@ impl PkgId {\n \n     /// True if the ID has multiple components\n     pub fn is_complex(&self) -> bool {\n-        self.short_name != self.local_path.to_str()\n+        self.short_name != self.path.to_str()\n      }\n }\n \n impl ToStr for PkgId {\n     fn to_str(&self) -> ~str {\n         // should probably use the filestem and not the whole path\n-        fmt!(\"%s-%s\", self.local_path.to_str(), self.version.to_str())\n+        fmt!(\"%s-%s\", self.path.to_str(), self.version.to_str())\n     }\n }\n+\n+\n+pub fn write<W: Writer>(writer: &mut W, string: &str) {\n+    writer.write(string.as_bytes());\n+}\n+\n+pub fn hash(data: ~str) -> ~str {\n+    let hasher = &mut hash::default_state();\n+    write(hasher, data);\n+    hasher.result_str()\n+}"}, {"sha": "4ba9c8066e4f3ac9e88e2e57faae8f1648c8fa20", "filename": "src/librustpkg/package_path.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fpackage_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fpackage_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_path.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -1,68 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// rustpkg utilities having to do with local and remote paths\n-\n-use std::clone::Clone;\n-use std::hash::Streaming;\n-use std::hash;\n-use std::option::Some;\n-use std::path::Path;\n-use std::rt::io::Writer;\n-\n-/// Wrappers to prevent local and remote paths from getting confused\n-/// (These will go away after #6407)\n-pub struct RemotePath (Path);\n-\n-impl Clone for RemotePath {\n-    fn clone(&self) -> RemotePath {\n-        RemotePath((**self).clone())\n-    }\n-}\n-\n-pub struct LocalPath (Path);\n-\n-impl Clone for LocalPath {\n-    fn clone(&self) -> LocalPath {\n-        LocalPath((**self).clone())\n-    }\n-}\n-\n-\n-// normalize should be the only way to construct a LocalPath\n-// (though this isn't enforced)\n-/// Replace all occurrences of '-' in the stem part of path with '_'\n-/// This is because we treat rust-foo-bar-quux and rust_foo_bar_quux\n-/// as the same name\n-pub fn normalize(p_: RemotePath) -> LocalPath {\n-    let RemotePath(p) = p_;\n-    match p.filestem() {\n-        None => LocalPath(p),\n-        Some(st) => {\n-            let replaced = st.replace(\"-\", \"_\");\n-            if replaced != st {\n-                LocalPath(p.with_filestem(replaced))\n-            }\n-            else {\n-                LocalPath(p)\n-            }\n-        }\n-    }\n-}\n-\n-pub fn write<W: Writer>(writer: &mut W, string: &str) {\n-    writer.write(string.as_bytes());\n-}\n-\n-pub fn hash(data: ~str) -> ~str {\n-    let hasher = &mut hash::default_state();\n-    write(hasher, data);\n-    hasher.result_str()\n-}"}, {"sha": "9833e18e016b63cf4d862a74d05c33096581d7a8", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/37fd8f03fdbc622457396877168d2a8d82cf3d2b/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37fd8f03fdbc622457396877168d2a8d82cf3d2b/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=37fd8f03fdbc622457396877168d2a8d82cf3d2b", "patch": "@@ -11,7 +11,7 @@\n use target::*;\n use package_id::PkgId;\n use std::path::Path;\n-use std::{os, str};\n+use std::os;\n use context::*;\n use crate::Crate;\n use messages::*;\n@@ -51,8 +51,7 @@ impl PkgSrc {\n     fn check_dir(&self) -> Path {\n         use conditions::nonexistent_package::cond;\n \n-        debug!(\"Pushing onto root: %s | %s\", self.id.remote_path.to_str(),\n-               self.root.to_str());\n+        debug!(\"Pushing onto root: %s | %s\", self.id.path.to_str(), self.root.to_str());\n         let dir;\n         let dirs = pkgid_src_in_workspace(&self.id, &self.root);\n         debug!(\"Checking dirs: %?\", dirs);\n@@ -86,18 +85,18 @@ impl PkgSrc {\n         os::remove_dir_recursive(&local);\n \n         debug!(\"Checking whether %s exists locally. Cwd = %s, does it? %?\",\n-               self.id.local_path.to_str(),\n+               self.id.path.to_str(),\n                os::getcwd().to_str(),\n-               os::path_exists(&*self.id.local_path));\n+               os::path_exists(&self.id.path));\n \n-        if os::path_exists(&*self.id.local_path) {\n+        if os::path_exists(&self.id.path) {\n             debug!(\"%s exists locally! Cloning it into %s\",\n-                   self.id.local_path.to_str(), local.to_str());\n-            git_clone(&*self.id.local_path, &local, &self.id.version);\n+                   self.id.path.to_str(), local.to_str());\n+            git_clone(&self.id.path, &local, &self.id.version);\n             return Some(local);\n         }\n \n-        let url = fmt!(\"https://%s\", self.id.remote_path.to_str());\n+        let url = fmt!(\"https://%s\", self.id.path.to_str());\n         note(fmt!(\"Fetching package: git clone %s %s [version=%s]\",\n                   url, local.to_str(), self.id.version.to_str()));\n         if git_clone_general(url, &local, &self.id.version) {\n@@ -122,25 +121,8 @@ impl PkgSrc {\n     }\n \n     /// True if the given path's stem is self's pkg ID's stem\n-    /// or if the pkg ID's stem is <rust-foo> and the given path's\n-    /// stem is foo\n-    /// Requires that dashes in p have already been normalized to\n-    /// underscores\n     fn stem_matches(&self, p: &Path) -> bool {\n-        let self_id = self.id.local_path.filestem();\n-        if self_id == p.filestem() {\n-            return true;\n-        }\n-        else {\n-            for pth in self_id.iter() {\n-                if pth.starts_with(\"rust_\") // because p is already normalized\n-                    && match p.filestem() {\n-                           Some(s) => str::eq_slice(s, pth.slice(5, pth.len())),\n-                           None => false\n-                       } { return true; }\n-            }\n-        }\n-        false\n+        p.filestem().map_default(false, |p| { p == &self.id.short_name })\n     }\n \n     fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n@@ -161,7 +143,7 @@ impl PkgSrc {\n         let dir = self.check_dir();\n         debug!(\"Called check_dir, I'm in %s\", dir.to_str());\n         let prefix = dir.components.len();\n-        debug!(\"Matching against %?\", self.id.local_path.filestem());\n+        debug!(\"Matching against %?\", self.id.short_name);\n         do os::walk_dir(&dir) |pth| {\n             match pth.filename() {\n                 Some(~\"lib.rs\") => PkgSrc::push_crate(&mut self.libs,"}, {"sha": "bbe84b2ecac4f8ddfa7539d5ca5961c3b102d3dd", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/37fd8f03fdbc622457396877168d2a8d82cf3d2b/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37fd8f03fdbc622457396877168d2a8d82cf3d2b/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=37fd8f03fdbc622457396877168d2a8d82cf3d2b", "patch": "@@ -10,7 +10,6 @@\n \n // rustpkg utilities having to do with paths and directories\n \n-pub use package_path::{RemotePath, LocalPath, normalize};\n pub use package_id::PkgId;\n pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n pub use version::{Version, NoVersion, split_version_general};\n@@ -94,9 +93,9 @@ pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n pub fn pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> ~[Path] {\n     let mut results = ~[];\n     let result = workspace.push(\"src\").push(fmt!(\"%s-%s\",\n-                     pkgid.local_path.to_str(), pkgid.version.to_str()));\n+                     pkgid.path.to_str(), pkgid.version.to_str()));\n     results.push(result);\n-    results.push(workspace.push(\"src\").push_rel(&*pkgid.remote_path));\n+    results.push(workspace.push(\"src\").push_rel(&pkgid.path));\n     results\n }\n \n@@ -159,22 +158,20 @@ fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Opt\n /// Figure out what the library name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n-    library_in_workspace(&pkgid.local_path, pkgid.short_name,\n-                         Build, workspace, \"build\")\n+    library_in_workspace(&pkgid.path, pkgid.short_name, Build, workspace, \"build\")\n }\n \n /// Does the actual searching stuff\n pub fn installed_library_in_workspace(short_name: &str, workspace: &Path) -> Option<Path> {\n-    library_in_workspace(&normalize(RemotePath(Path(short_name))),\n-                         short_name, Install, workspace, \"lib\")\n+    library_in_workspace(&Path(short_name), short_name, Install, workspace, \"lib\")\n }\n \n \n /// This doesn't take a PkgId, so we can use it for `extern mod` inference, where we\n /// don't know the entire package ID.\n /// `workspace` is used to figure out the directory to search.\n /// `short_name` is taken as the link name of the library.\n-pub fn library_in_workspace(path: &LocalPath, short_name: &str, where: Target,\n+pub fn library_in_workspace(path: &Path, short_name: &str, where: Target,\n                         workspace: &Path, prefix: &str) -> Option<Path> {\n     debug!(\"library_in_workspace: checking whether a library named %s exists\",\n            short_name);\n@@ -186,7 +183,7 @@ pub fn library_in_workspace(path: &LocalPath, short_name: &str, where: Target,\n             prefix = %s\", short_name, where, workspace.to_str(), prefix);\n \n     let dir_to_search = match where {\n-        Build => workspace.push(prefix).push_rel(&**path),\n+        Build => workspace.push(prefix).push_rel(path),\n         Install => workspace.push(prefix)\n     };\n     debug!(\"Listing directory %s\", dir_to_search.to_str());\n@@ -302,7 +299,7 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n     // Artifacts in the build directory live in a package-ID-specific subdirectory,\n     // but installed ones don't.\n     let result = match where {\n-                Build => workspace.push(subdir).push_rel(&*pkgid.local_path),\n+                Build => workspace.push(subdir).push_rel(&pkgid.path),\n                 _     => workspace.push(subdir)\n     };\n     if !os::path_exists(&result) && !mkdir_recursive(&result, U_RWX) {\n@@ -321,7 +318,7 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     let mut result = workspace.push(\"build\");\n     // n.b. Should actually use a target-specific\n     // subdirectory of build/\n-    result = result.push_rel(&*pkgid.local_path);\n+    result = result.push_rel(&pkgid.path);\n     if os::path_exists(&result) || os::mkdir_recursive(&result, U_RWX) {\n         result\n     }\n@@ -342,7 +339,7 @@ pub fn mk_output_path(what: OutputType, where: Target,\n         // If we're installing, it just goes under <workspace>...\n         Install => workspace,\n         // and if we're just building, it goes in a package-specific subdir\n-        Build => workspace.push_rel(&*pkg_id.local_path)\n+        Build => workspace.push_rel(&pkg_id.path)\n     };\n     debug!(\"[%?:%?] mk_output_path: short_name = %s, path = %s\", what, where,\n            if what == Lib { short_name_with_version.clone() } else { pkg_id.short_name.clone() },"}, {"sha": "26dab4120fda452d5ec1964549fce1518bf600d2", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/37fd8f03fdbc622457396877168d2a8d82cf3d2b/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37fd8f03fdbc622457396877168d2a8d82cf3d2b/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=37fd8f03fdbc622457396877168d2a8d82cf3d2b", "patch": "@@ -55,7 +55,6 @@ mod crate;\n mod installed_packages;\n mod messages;\n mod package_id;\n-mod package_path;\n mod package_source;\n mod path_util;\n mod search;\n@@ -268,7 +267,7 @@ impl CtxMethods for Ctx {\n             \"list\" => {\n                 io::println(\"Installed packages:\");\n                 do installed_packages::list_installed_packages |pkg_id| {\n-                    println(pkg_id.local_path.to_str());\n+                    println(pkg_id.path.to_str());\n                     true\n                 };\n             }\n@@ -322,18 +321,18 @@ impl CtxMethods for Ctx {\n     fn build(&self, workspace: &Path, pkgid: &PkgId) {\n         debug!(\"build: workspace = %s (in Rust path? %? is git dir? %? \\\n                 pkgid = %s\", workspace.to_str(),\n-               in_rust_path(workspace), is_git_dir(&workspace.push_rel(&*pkgid.local_path)),\n+               in_rust_path(workspace), is_git_dir(&workspace.push_rel(&pkgid.path)),\n                pkgid.to_str());\n         let src_dir   = first_pkgid_src_in_workspace(pkgid, workspace);\n \n         // If workspace isn't in the RUST_PATH, and it's a git repo,\n         // then clone it into the first entry in RUST_PATH, and repeat\n         debug!(\"%? %? %s\", in_rust_path(workspace),\n-               is_git_dir(&workspace.push_rel(&*pkgid.local_path)),\n+               is_git_dir(&workspace.push_rel(&pkgid.path)),\n                workspace.to_str());\n-        if !in_rust_path(workspace) && is_git_dir(&workspace.push_rel(&*pkgid.local_path)) {\n-            let out_dir = default_workspace().push(\"src\").push_rel(&*pkgid.local_path);\n-            source_control::git_clone(&workspace.push_rel(&*pkgid.local_path),\n+        if !in_rust_path(workspace) && is_git_dir(&workspace.push_rel(&pkgid.path)) {\n+            let out_dir = default_workspace().push(\"src\").push_rel(&pkgid.path);\n+            source_control::git_clone(&workspace.push_rel(&pkgid.path),\n                                       &out_dir, &pkgid.version);\n             let default_ws = default_workspace();\n             debug!(\"Calling build recursively with %? and %?\", default_ws.to_str(),"}, {"sha": "121dcf40150211f56aea9e52f9036b227a5a42df", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/37fd8f03fdbc622457396877168d2a8d82cf3d2b/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37fd8f03fdbc622457396877168d2a8d82cf3d2b/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=37fd8f03fdbc622457396877168d2a8d82cf3d2b", "patch": "@@ -12,11 +12,10 @@\n \n use context::Ctx;\n use std::hashmap::HashMap;\n-use std::{io, libc, os, result, run, str};\n+use std::{io, libc, os, run, str};\n use extra::tempfile::mkdtemp;\n use std::run::ProcessOutput;\n use installed_packages::list_installed_packages;\n-use package_path::*;\n use package_id::{PkgId};\n use version::{ExactRevision, NoVersion, Version, Tagged};\n use path_util::{target_executable_in_workspace, target_library_in_workspace,\n@@ -44,31 +43,25 @@ fn fake_ctxt(sysroot_opt: Option<@Path>) -> Ctx {\n \n fn fake_pkg() -> PkgId {\n     let sn = ~\"bogus\";\n-    let remote = RemotePath(Path(sn));\n     PkgId {\n-        local_path: normalize(remote.clone()),\n-        remote_path: remote,\n+        path: Path(sn),\n         short_name: sn,\n         version: NoVersion\n     }\n }\n \n fn git_repo_pkg() -> PkgId {\n-    let remote = RemotePath(Path(\"mockgithub.com/catamorphism/test-pkg\"));\n     PkgId {\n-        local_path: normalize(remote.clone()),\n-        remote_path: remote,\n-        short_name: ~\"test_pkg\",\n+        path: Path(\"mockgithub.com/catamorphism/test-pkg\"),\n+        short_name: ~\"test-pkg\",\n         version: NoVersion\n     }\n }\n \n fn git_repo_pkg_with_tag(a_tag: ~str) -> PkgId {\n-    let remote = RemotePath(Path(\"mockgithub.com/catamorphism/test-pkg\"));\n     PkgId {\n-        local_path: normalize(remote.clone()),\n-        remote_path: remote,\n-        short_name: ~\"test_pkg\",\n+        path: Path(\"mockgithub.com/catamorphism/test-pkg\"),\n+        short_name: ~\"test-pkg\",\n         version: Tagged(a_tag)\n     }\n }\n@@ -78,21 +71,21 @@ fn writeFile(file_path: &Path, contents: &str) {\n     out.write_line(contents);\n }\n \n-fn mk_empty_workspace(short_name: &LocalPath, version: &Version) -> Path {\n+fn mk_empty_workspace(short_name: &Path, version: &Version) -> Path {\n     let workspace_dir = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n     mk_workspace(&workspace_dir, short_name, version);\n     workspace_dir\n }\n \n-fn mk_workspace(workspace: &Path, short_name: &LocalPath, version: &Version) -> Path {\n+fn mk_workspace(workspace: &Path, short_name: &Path, version: &Version) -> Path {\n     // include version number in directory name\n     let package_dir = workspace.push(\"src\").push(fmt!(\"%s-%s\",\n                                                       short_name.to_str(), version.to_str()));\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     package_dir\n }\n \n-fn mk_temp_workspace(short_name: &LocalPath, version: &Version) -> Path {\n+fn mk_temp_workspace(short_name: &Path, version: &Version) -> Path {\n     let package_dir = mk_empty_workspace(short_name,\n                                          version).push(\"src\").push(fmt!(\"%s-%s\",\n                                                             short_name.to_str(),\n@@ -255,7 +248,7 @@ to make sure the command succeeded\n }\n \n fn create_local_package(pkgid: &PkgId) -> Path {\n-    let parent_dir = mk_temp_workspace(&pkgid.local_path, &pkgid.version);\n+    let parent_dir = mk_temp_workspace(&pkgid.path, &pkgid.version);\n     debug!(\"Created empty package dir for %s, returning %s\", pkgid.to_str(), parent_dir.to_str());\n     parent_dir.pop().pop()\n }\n@@ -312,7 +305,7 @@ fn create_local_package_with_custom_build_hook(pkgid: &PkgId,\n \n }\n \n-fn assert_lib_exists(repo: &Path, short_name: &str, v: Version) {\n+fn assert_lib_exists(repo: &Path, short_name: &str, _v: Version) { // ??? version?\n     debug!(\"assert_lib_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n     let lib = installed_library_in_workspace(short_name, repo);\n     debug!(\"assert_lib_exists: checking whether %? exists\", lib);\n@@ -357,11 +350,11 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n     result\n }\n \n-// assumes short_name and local_path are one and the same -- I should fix\n+// assumes short_name and path are one and the same -- I should fix\n fn lib_output_file_name(workspace: &Path, parent: &str, short_name: &str) -> Path {\n     debug!(\"lib_output_file_name: given %s and parent %s and short name %s\",\n            workspace.to_str(), parent, short_name);\n-    library_in_workspace(&normalize(RemotePath(Path(short_name))),\n+    library_in_workspace(&Path(short_name),\n                          short_name,\n                          Build,\n                          workspace,\n@@ -436,7 +429,7 @@ fn test_install_valid() {\n     debug!(\"sysroot = %s\", sysroot.to_str());\n     let ctxt = fake_ctxt(Some(@sysroot));\n     let temp_pkg_id = fake_pkg();\n-    let temp_workspace = mk_temp_workspace(&temp_pkg_id.local_path, &NoVersion).pop().pop();\n+    let temp_workspace = mk_temp_workspace(&temp_pkg_id.path, &NoVersion).pop().pop();\n     debug!(\"temp_workspace = %s\", temp_workspace.to_str());\n     // should have test, bench, lib, and main\n     ctxt.install(&temp_workspace, &temp_pkg_id);\n@@ -489,7 +482,7 @@ fn test_install_git() {\n     let sysroot = test_sysroot();\n     debug!(\"sysroot = %s\", sysroot.to_str());\n     let temp_pkg_id = git_repo_pkg();\n-    let repo = init_git_repo(&Path(temp_pkg_id.local_path.to_str()));\n+    let repo = init_git_repo(&temp_pkg_id.path);\n     let repo_subdir = repo.push(\"mockgithub.com\").push(\"catamorphism\").push(\"test_pkg\");\n     writeFile(&repo_subdir.push(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n@@ -502,9 +495,9 @@ fn test_install_git() {\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n     debug!(\"test_install_git: calling rustpkg install %s in %s\",\n-           temp_pkg_id.local_path.to_str(), repo.to_str());\n+           temp_pkg_id.path.to_str(), repo.to_str());\n     // should have test, bench, lib, and main\n-    command_line_test([~\"install\", temp_pkg_id.local_path.to_str()], &repo);\n+    command_line_test([~\"install\", temp_pkg_id.path.to_str()], &repo);\n     // Check that all files exist\n     debug!(\"Checking for files in %s\", repo.to_str());\n     let exec = target_executable_in_workspace(&temp_pkg_id, &repo);\n@@ -551,7 +544,7 @@ fn test_package_ids_must_be_relative_path_like() {\n     let whatever = PkgId::new(\"foo\");\n \n     assert_eq!(~\"foo-0.1\", whatever.to_str());\n-    assert!(\"github.com/catamorphism/test_pkg-0.1\" ==\n+    assert!(\"github.com/catamorphism/test-pkg-0.1\" ==\n             PkgId::new(\"github.com/catamorphism/test-pkg\").to_str());\n \n     do cond.trap(|(p, e)| {\n@@ -755,7 +748,7 @@ fn rustpkg_clean_no_arg() {\n #[ignore (reason = \"Specifying env doesn't work -- see #8028\")]\n fn rust_path_test() {\n     let dir_for_path = mkdtemp(&os::tmpdir(), \"more_rust\").expect(\"rust_path_test failed\");\n-    let dir = mk_workspace(&dir_for_path, &normalize(RemotePath(Path(\"foo\"))), &NoVersion);\n+    let dir = mk_workspace(&dir_for_path, &Path(\"foo\"), &NoVersion);\n     debug!(\"dir = %s\", dir.to_str());\n     writeFile(&dir.push(\"main.rs\"), \"fn main() { let _x = (); }\");\n \n@@ -877,7 +870,7 @@ fn install_check_duplicates() {\n     let mut contents = ~[];\n     let check_dups = |p: &PkgId| {\n         if contents.contains(p) {\n-            fail!(\"package %s appears in `list` output more than once\", p.local_path.to_str());\n+            fail!(\"package %s appears in `list` output more than once\", p.path.to_str());\n         }\n         else {\n             contents.push((*p).clone());\n@@ -992,8 +985,8 @@ fn test_uninstall() {\n #[test]\n fn test_non_numeric_tag() {\n     let temp_pkg_id = git_repo_pkg();\n-    let repo = init_git_repo(&Path(temp_pkg_id.local_path.to_str()));\n-    let repo_subdir = repo.push(\"mockgithub.com\").push(\"catamorphism\").push(\"test_pkg\");\n+    let repo = init_git_repo(&temp_pkg_id.path);\n+    let repo_subdir = repo.push(\"mockgithub.com\").push(\"catamorphism\").push(\"test-pkg\");\n     writeFile(&repo_subdir.push(\"foo\"), \"foo\");\n     writeFile(&repo_subdir.push(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n@@ -1003,12 +996,10 @@ fn test_non_numeric_tag() {\n     writeFile(&repo_subdir.push(\"not_on_testbranch_only\"), \"bye bye\");\n     add_all_and_commit(&repo_subdir);\n \n-\n-    command_line_test([~\"install\", fmt!(\"%s#testbranch\", temp_pkg_id.remote_path.to_str())],\n-                      &repo);\n+    command_line_test([~\"install\", fmt!(\"%s#testbranch\", temp_pkg_id.path.to_str())], &repo);\n     let file1 = repo.push_many([\"mockgithub.com\", \"catamorphism\",\n-                                \"test_pkg\", \"testbranch_only\"]);\n-    let file2 = repo.push_many([\"mockgithub.com\", \"catamorphism\", \"test_pkg\",\n+                                \"test-pkg\", \"testbranch_only\"]);\n+    let file2 = repo.push_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\",\n                                 \"master_only\"]);\n     assert!(os::path_exists(&file1));\n     assert!(!os::path_exists(&file2));"}, {"sha": "ed21f8e0872fbf58ee9eed2e2df1686126e89e7f", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37fd8f03fdbc622457396877168d2a8d82cf3d2b/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37fd8f03fdbc622457396877168d2a8d82cf3d2b/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=37fd8f03fdbc622457396877168d2a8d82cf3d2b", "patch": "@@ -166,7 +166,7 @@ pub fn compile_input(ctxt: &Ctx,\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n \n-    let out_dir = workspace.push(\"build\").push_rel(&*pkg_id.local_path);\n+    let out_dir = workspace.push(\"build\").push_rel(&pkg_id.path);\n \n     let binary = os::args()[0].to_managed();\n \n@@ -246,8 +246,8 @@ pub fn compile_input(ctxt: &Ctx,\n     // Inject the link attributes so we get the right package name and version\n     if attr::find_linkage_metas(crate.attrs).is_empty() {\n         let name_to_use = match what {\n-            Test  => fmt!(\"%stest\", pkg_id.local_path.to_str()).to_managed(),\n-            Bench => fmt!(\"%sbench\", pkg_id.local_path.to_str()).to_managed(),\n+            Test  => fmt!(\"%stest\", pkg_id.short_name).to_managed(),\n+            Bench => fmt!(\"%sbench\", pkg_id.short_name).to_managed(),\n             _     => pkg_id.short_name.to_managed()\n         };\n         debug!(\"Injecting link name: %s\", name_to_use);\n@@ -256,7 +256,7 @@ pub fn compile_input(ctxt: &Ctx,\n               attr::mk_name_value_item_str(@\"vers\", pkg_id.version.to_str().to_managed())] +\n                         if pkg_id.is_complex() {\n                         ~[attr::mk_name_value_item_str(@\"package_id\",\n-                                                       pkg_id.local_path.to_str().to_managed())]\n+                                                       pkg_id.path.to_str().to_managed())]\n                 } else { ~[] };\n \n         debug!(\"link options: %?\", link_options);"}, {"sha": "ab4f47ba69abcf600ec6c0b030c901480c27b69b", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37fd8f03fdbc622457396877168d2a8d82cf3d2b/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37fd8f03fdbc622457396877168d2a8d82cf3d2b/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=37fd8f03fdbc622457396877168d2a8d82cf3d2b", "patch": "@@ -15,7 +15,6 @@ extern mod std;\n \n use extra::semver;\n use std::{char, os, result, run, str};\n-use package_path::RemotePath;\n use extra::tempfile::mkdtemp;\n use path_util::rust_path;\n \n@@ -128,7 +127,7 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n /// If `remote_path` refers to a git repo that can be downloaded,\n /// and the most recent tag in that repo denotes a version, return it;\n /// otherwise, `None`\n-pub fn try_getting_version(remote_path: &RemotePath) -> Option<Version> {\n+pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n     debug!(\"try_getting_version: %s\", remote_path.to_str());\n     if is_url_like(remote_path) {\n         debug!(\"Trying to fetch its sources..\");\n@@ -199,7 +198,7 @@ fn try_parsing_version(s: &str) -> Option<Version> {\n }\n \n /// Just an approximation\n-fn is_url_like(p: &RemotePath) -> bool {\n+fn is_url_like(p: &Path) -> bool {\n     let str = p.to_str();\n     str.split_iter('/').len_() > 2\n }"}, {"sha": "3e0e08dfe2d7c3d7efc5c7b1c74e3962fc788897", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37fd8f03fdbc622457396877168d2a8d82cf3d2b/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37fd8f03fdbc622457396877168d2a8d82cf3d2b/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=37fd8f03fdbc622457396877168d2a8d82cf3d2b", "patch": "@@ -25,7 +25,7 @@ pub fn each_pkg_parent_workspace(pkgid: &PkgId, action: &fn(&Path) -> bool) -> b\n         // tjc: make this a condition\n         fail!(\"Package %s not found in any of \\\n                     the following workspaces: %s\",\n-                   pkgid.remote_path.to_str(),\n+                   pkgid.path.to_str(),\n                    rust_path().to_str());\n     }\n     for ws in workspaces.iter() {"}]}