{"sha": "589c1dfa04bbb4429223c810c2fefc2f12beb6cd", "node_id": "C_kwDOAAsO6NoAKDU4OWMxZGZhMDRiYmI0NDI5MjIzYzgxMGMyZmVmYzJmMTJiZWI2Y2Q", "commit": {"author": {"name": "hamidreza kalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2021-09-22T15:05:54Z"}, "committer": {"name": "hamidreza kalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2021-09-22T15:05:54Z"}, "message": "move function to defs.rs", "tree": {"sha": "1838586164bcad706fa97d00e2c3d1a64daadc46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1838586164bcad706fa97d00e2c3d1a64daadc46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/589c1dfa04bbb4429223c810c2fefc2f12beb6cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/589c1dfa04bbb4429223c810c2fefc2f12beb6cd", "html_url": "https://github.com/rust-lang/rust/commit/589c1dfa04bbb4429223c810c2fefc2f12beb6cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/589c1dfa04bbb4429223c810c2fefc2f12beb6cd/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18e6b508dd48d7559f8033e10a3741135e6425ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/18e6b508dd48d7559f8033e10a3741135e6425ce", "html_url": "https://github.com/rust-lang/rust/commit/18e6b508dd48d7559f8033e10a3741135e6425ce"}], "stats": {"total": 236, "additions": 114, "deletions": 122}, "files": [{"sha": "4c01231f4a2b5aeb3329294d8265355f254d5ff2", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 36, "deletions": 47, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/589c1dfa04bbb4429223c810c2fefc2f12beb6cd/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589c1dfa04bbb4429223c810c2fefc2f12beb6cd/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=589c1dfa04bbb4429223c810c2fefc2f12beb6cd", "patch": "@@ -1,6 +1,5 @@\n use std::convert::TryInto;\n \n-use crate::hover::find_definition;\n use crate::{\n     display::TryToNav,\n     doc_links::{doc_attributes, extract_definitions_from_docs, resolve_doc_path_for_def},\n@@ -10,11 +9,11 @@ use hir::{AsAssocItem, InFile, ModuleDef, Semantics};\n use ide_db::{\n     base_db::{AnchoredPath, FileId, FileLoader},\n     defs::Definition,\n-    helpers::{pick_best_token, try_resolve_derive_input_at},\n+    helpers::pick_best_token,\n     RootDatabase,\n };\n use itertools::Itertools;\n-use syntax::{ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, TextRange, T};\n+use syntax::{ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, TextRange, T};\n \n // Feature: Go to Definition\n //\n@@ -57,22 +56,22 @@ pub(crate) fn goto_definition(\n         .into_iter()\n         .filter_map(|token| {\n             let parent = token.parent()?;\n-            let result = find_definition(&sema, &parent)\n-                .flat_map(|def| {\n-                    try_find_trait_item_definition(sema.db, &def)\n-                        .unwrap_or_else(|| def_to_nav(sema.db, def))\n-                })\n-                .collect::<Vec<_>>();\n-            if !result.is_empty() {\n-                return Some(result);\n-            }\n-            match_ast! {\n-                match parent {\n-                    ast::TokenTree(tt) =>\n-                        try_lookup_include_path_or_derive(&sema, tt, token, position.file_id),\n-                    _ => None\n+            if let Some(tt) = ast::TokenTree::cast(parent.clone()) {\n+                if let x @ Some(_) =\n+                    try_lookup_include_path(&sema, tt, token.clone(), position.file_id)\n+                {\n+                    return x;\n                 }\n             }\n+            Some(\n+                Definition::from_node(&sema, &token)\n+                    .into_iter()\n+                    .flat_map(|def| {\n+                        try_find_trait_item_definition(sema.db, &def)\n+                            .unwrap_or_else(|| def_to_nav(sema.db, def))\n+                    })\n+                    .collect::<Vec<_>>(),\n+            )\n         })\n         .flatten()\n         .unique()\n@@ -81,41 +80,31 @@ pub(crate) fn goto_definition(\n     Some(RangeInfo::new(original_token.text_range(), navs))\n }\n \n-fn try_lookup_include_path_or_derive(\n+fn try_lookup_include_path(\n     sema: &Semantics<RootDatabase>,\n     tt: ast::TokenTree,\n     token: SyntaxToken,\n     file_id: FileId,\n ) -> Option<Vec<NavigationTarget>> {\n-    match ast::String::cast(token.clone()) {\n-        Some(token) => {\n-            let path = token.value()?.into_owned();\n-            let macro_call = tt.syntax().parent().and_then(ast::MacroCall::cast)?;\n-            let name = macro_call.path()?.segment()?.name_ref()?;\n-            if !matches!(&*name.text(), \"include\" | \"include_str\" | \"include_bytes\") {\n-                return None;\n-            }\n-            let file_id = sema.db.resolve_path(AnchoredPath { anchor: file_id, path: &path })?;\n-            let size = sema.db.file_text(file_id).len().try_into().ok()?;\n-            Some(vec![NavigationTarget {\n-                file_id,\n-                full_range: TextRange::new(0.into(), size),\n-                name: path.into(),\n-                focus_range: None,\n-                kind: None,\n-                container_name: None,\n-                description: None,\n-                docs: None,\n-            }])\n-        }\n-        None => try_resolve_derive_input_at(\n-            sema,\n-            &tt.syntax().ancestors().nth(2).and_then(ast::Attr::cast)?,\n-            &token,\n-        )\n-        .and_then(|it| it.try_to_nav(sema.db))\n-        .map(|it| vec![it]),\n-    }\n+    let token = ast::String::cast(token.clone())?;\n+    let path = token.value()?.into_owned();\n+    let macro_call = tt.syntax().parent().and_then(ast::MacroCall::cast)?;\n+    let name = macro_call.path()?.segment()?.name_ref()?;\n+    if !matches!(&*name.text(), \"include\" | \"include_str\" | \"include_bytes\") {\n+        return None;\n+    }\n+    let file_id = sema.db.resolve_path(AnchoredPath { anchor: file_id, path: &path })?;\n+    let size = sema.db.file_text(file_id).len().try_into().ok()?;\n+    Some(vec![NavigationTarget {\n+        file_id,\n+        full_range: TextRange::new(0.into(), size),\n+        name: path.into(),\n+        focus_range: None,\n+        kind: None,\n+        container_name: None,\n+        description: None,\n+        docs: None,\n+    }])\n }\n \n /// finds the trait definition of an impl'd item"}, {"sha": "80e91f303cd1358019312731e16fd973a9702042", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 19, "deletions": 72, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/589c1dfa04bbb4429223c810c2fefc2f12beb6cd/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589c1dfa04bbb4429223c810c2fefc2f12beb6cd/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=589c1dfa04bbb4429223c810c2fefc2f12beb6cd", "patch": "@@ -1,13 +1,13 @@\n-use std::{collections::HashSet, iter, ops::ControlFlow};\n+use std::{collections::HashSet, ops::ControlFlow};\n \n use either::Either;\n use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo};\n use ide_db::{\n     base_db::{FileRange, SourceDatabase},\n-    defs::{Definition, NameClass, NameRefClass},\n+    defs::Definition,\n     helpers::{\n         generated_lints::{CLIPPY_LINTS, DEFAULT_LINTS, FEATURES},\n-        pick_best_token, try_resolve_derive_input_at, FamousDefs,\n+        pick_best_token, FamousDefs,\n     },\n     RootDatabase,\n };\n@@ -107,7 +107,7 @@ pub(crate) fn hover(\n     }\n     let offset = range.start();\n \n-    let token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n+    let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n         IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] => 3,\n         T!['('] | T![')'] => 2,\n         kind if kind.is_trivia() => 0,\n@@ -119,29 +119,14 @@ pub(crate) fn hover(\n     let mut fallback = None;\n     // attributes, require special machinery as they are mere ident tokens\n \n-    let descend_macros = sema.descend_into_macros_many(token.clone());\n+    let descend_macros = sema.descend_into_macros_many(original_token.clone());\n \n     for token in &descend_macros {\n         if token.kind() != COMMENT {\n             if let Some(attr) = token.ancestors().find_map(ast::Attr::cast) {\n                 // lints\n                 if let Some(res) = try_hover_for_lint(&attr, &token) {\n                     return Some(res);\n-                // derives\n-                } else {\n-                    let def =\n-                        try_resolve_derive_input_at(&sema, &attr, &token).map(Definition::Macro);\n-                    if let Some(def) = def {\n-                        if let Some(hover) = hover_for_definition(\n-                            &sema,\n-                            file_id,\n-                            def,\n-                            &token.parent().unwrap(),\n-                            config,\n-                        ) {\n-                            return Some(RangeInfo::new(token.text_range(), hover));\n-                        }\n-                    }\n                 }\n             }\n         }\n@@ -151,7 +136,16 @@ pub(crate) fn hover(\n         .iter()\n         .filter_map(|token| match token.parent() {\n             Some(node) => {\n-                match find_hover_result(&sema, file_id, offset, config, token, &node, &mut seen) {\n+                match find_hover_result(\n+                    &sema,\n+                    file_id,\n+                    offset,\n+                    config,\n+                    &original_token,\n+                    token,\n+                    &node,\n+                    &mut seen,\n+                ) {\n                     Some(res) => match res {\n                         ControlFlow::Break(inner) => Some(inner),\n                         ControlFlow::Continue(_) => {\n@@ -189,6 +183,7 @@ fn find_hover_result(\n     file_id: FileId,\n     offset: TextSize,\n     config: &HoverConfig,\n+    original_token: &SyntaxToken,\n     token: &SyntaxToken,\n     node: &SyntaxNode,\n     seen: &mut HashSet<Definition>,\n@@ -199,7 +194,7 @@ fn find_hover_result(\n     // so don't add them to the `seen` duplicate check\n     let mut add_to_seen_definitions = true;\n \n-    let definition = find_definition(sema, node).next().or_else(|| {\n+    let definition = Definition::from_node(sema, token).into_iter().next().or_else(|| {\n         // intra-doc links\n         // FIXME: move comment + attribute special cases somewhere else to simplify control flow,\n         // hopefully simplifying the return type of this function in the process\n@@ -242,7 +237,7 @@ fn find_hover_result(\n             seen.insert(definition);\n         }\n         if let Some(res) = hover_for_definition(sema, file_id, definition, &node, config) {\n-            let range = range_override.unwrap_or_else(|| sema.original_range(&node).range);\n+            let range = range_override.unwrap_or_else(|| original_token.text_range());\n             return Some(ControlFlow::Break(RangeInfo::new(range, res)));\n         }\n     }\n@@ -724,53 +719,6 @@ fn definition_mod_path(db: &RootDatabase, def: &Definition) -> Option<String> {\n     def.module(db).map(|module| render_path(db, module, definition_owner_name(db, def)))\n }\n \n-pub(crate) fn find_definition<'a>(\n-    sema: &'a Semantics<RootDatabase>,\n-    node: &SyntaxNode,\n-) -> impl Iterator<Item = Definition> + 'a {\n-    iter::once(node.clone()).flat_map(move |node| {\n-        match_ast! {\n-            match node {\n-                ast::Name(name) => {\n-                    let class = if let Some(x) = NameClass::classify(&sema, &name) {\n-                        x\n-                    } else {\n-                        return vec![];\n-                    };\n-                    match class {\n-                        NameClass::Definition(it) | NameClass::ConstReference(it) => vec![it],\n-                        NameClass::PatFieldShorthand { local_def, field_ref } => vec![Definition::Local(local_def), Definition::Field(field_ref)],\n-                    }\n-                },\n-                ast::NameRef(name_ref) => {\n-                    let class = if let Some(x) = NameRefClass::classify(sema, &name_ref) {\n-                        x\n-                    } else {\n-                        return vec![];\n-                    };\n-                    match class {\n-                        NameRefClass::Definition(def) => vec![def],\n-                        NameRefClass::FieldShorthand { local_ref, field_ref } => {\n-                            vec![Definition::Field(field_ref), Definition::Local(local_ref)]\n-                        }\n-                    }\n-                },\n-                ast::Lifetime(lifetime) => {\n-                    (if let Some(x) = NameClass::classify_lifetime(&sema, &lifetime) {\n-                        NameClass::defined(x)\n-                    } else {\n-                        NameRefClass::classify_lifetime(&sema, &lifetime).and_then(|class| match class {\n-                            NameRefClass::Definition(it) => Some(it),\n-                            _ => None,\n-                        })\n-                    }).into_iter().collect()\n-                },\n-                _ => vec![],\n-            }\n-        }\n-    })\n-}\n-\n pub(crate) fn hover_for_definition(\n     sema: &Semantics<RootDatabase>,\n     file_id: FileId,\n@@ -4587,7 +4535,6 @@ use crate as foo$0;\n         );\n     }\n \n-    // FIXME: wrong range in macros. `es! ` should be `Copy`\n     #[test]\n     fn hover_attribute_in_macro() {\n         check(\n@@ -4605,7 +4552,7 @@ identity!{\n }\n \"#,\n             expect![[r#\"\n-                *es! *\n+                *Copy*\n \n                 ```rust\n                 test"}, {"sha": "21872c81d134788d9673aaa85fdfa90bbdb13a47", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589c1dfa04bbb4429223c810c2fefc2f12beb6cd/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589c1dfa04bbb4429223c810c2fefc2f12beb6cd/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=589c1dfa04bbb4429223c810c2fefc2f12beb6cd", "patch": "@@ -35,7 +35,7 @@ mod goto_declaration;\n mod goto_definition;\n mod goto_implementation;\n mod goto_type_definition;\n-pub mod hover;\n+mod hover;\n mod inlay_hints;\n mod join_lines;\n mod markdown_remove;"}, {"sha": "d42af9c38f590abc1e8686e1f55311c29f9a2751", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/589c1dfa04bbb4429223c810c2fefc2f12beb6cd/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589c1dfa04bbb4429223c810c2fefc2f12beb6cd/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=589c1dfa04bbb4429223c810c2fefc2f12beb6cd", "patch": "@@ -11,10 +11,10 @@ use hir::{\n };\n use syntax::{\n     ast::{self, AstNode},\n-    match_ast, SyntaxKind,\n+    match_ast, SyntaxKind, SyntaxToken,\n };\n \n-use crate::RootDatabase;\n+use crate::{helpers::try_resolve_derive_input_at, RootDatabase};\n \n // FIXME: a more precise name would probably be `Symbol`?\n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -29,6 +29,62 @@ pub enum Definition {\n }\n \n impl Definition {\n+    pub fn from_node(sema: &Semantics<RootDatabase>, token: &SyntaxToken) -> Vec<Definition> {\n+        let node = if let Some(x) = token.parent() {\n+            x\n+        } else {\n+            return vec![];\n+        };\n+        if token.kind() != SyntaxKind::COMMENT {\n+            if let Some(attr) = token.ancestors().find_map(ast::Attr::cast) {\n+                // derives\n+                let def = try_resolve_derive_input_at(&sema, &attr, &token).map(Definition::Macro);\n+                if let Some(def) = def {\n+                    return vec![def];\n+                }\n+            }\n+        }\n+        match_ast! {\n+            match node {\n+                ast::Name(name) => {\n+                    let class = if let Some(x) = NameClass::classify(&sema, &name) {\n+                        x\n+                    } else {\n+                        return vec![];\n+                    };\n+                    match class {\n+                        NameClass::Definition(it) | NameClass::ConstReference(it) => vec![it],\n+                        NameClass::PatFieldShorthand { local_def, field_ref } => vec![Definition::Local(local_def), Definition::Field(field_ref)],\n+                    }\n+                },\n+                ast::NameRef(name_ref) => {\n+                    let class = if let Some(x) = NameRefClass::classify(sema, &name_ref) {\n+                        x\n+                    } else {\n+                        return vec![];\n+                    };\n+                    match class {\n+                        NameRefClass::Definition(def) => vec![def],\n+                        NameRefClass::FieldShorthand { local_ref, field_ref } => {\n+                            vec![Definition::Field(field_ref), Definition::Local(local_ref)]\n+                        }\n+                    }\n+                },\n+                ast::Lifetime(lifetime) => {\n+                    (if let Some(x) = NameClass::classify_lifetime(&sema, &lifetime) {\n+                        NameClass::defined(x)\n+                    } else {\n+                        NameRefClass::classify_lifetime(&sema, &lifetime).and_then(|class| match class {\n+                            NameRefClass::Definition(it) => Some(it),\n+                            _ => None,\n+                        })\n+                    }).into_iter().collect()\n+                },\n+                _ => vec![],\n+            }\n+        }\n+    }\n+\n     pub fn module(&self, db: &RootDatabase) -> Option<Module> {\n         match self {\n             Definition::Macro(it) => it.module(db),"}]}