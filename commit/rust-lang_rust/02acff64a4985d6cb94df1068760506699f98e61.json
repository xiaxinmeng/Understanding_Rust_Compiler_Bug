{"sha": "02acff64a4985d6cb94df1068760506699f98e61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYWNmZjY0YTQ5ODVkNmNiOTRkZjEwNjg3NjA1MDY2OTlmOThlNjE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-07T17:56:18Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-07T17:56:18Z"}, "message": "Rollup merge of #32732 - dotdash:ext_arg, r=eddyb\n\nHandle integer-extending for C ABI\n\nWe need to supply sext/zext attributes to LLVM to ensure that arguments\nare extended to the appropriate width in the correct way.\n\nMost platforms extend integers less than 32 bits, though not all.", "tree": {"sha": "3a9ee1cf155d07bfe895d1e61db6895b652663b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a9ee1cf155d07bfe895d1e61db6895b652663b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02acff64a4985d6cb94df1068760506699f98e61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02acff64a4985d6cb94df1068760506699f98e61", "html_url": "https://github.com/rust-lang/rust/commit/02acff64a4985d6cb94df1068760506699f98e61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02acff64a4985d6cb94df1068760506699f98e61/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e360e521ff3f4ae05856b9303fa465aa481b093", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e360e521ff3f4ae05856b9303fa465aa481b093", "html_url": "https://github.com/rust-lang/rust/commit/6e360e521ff3f4ae05856b9303fa465aa481b093"}, {"sha": "4815f7e668640ae968418307909f41a7eaabf050", "url": "https://api.github.com/repos/rust-lang/rust/commits/4815f7e668640ae968418307909f41a7eaabf050", "html_url": "https://github.com/rust-lang/rust/commit/4815f7e668640ae968418307909f41a7eaabf050"}], "stats": {"total": 123, "additions": 102, "deletions": 21}, "files": [{"sha": "cb29f27b83fd7a15ac173be75be667ff9c3a4e96", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=02acff64a4985d6cb94df1068760506699f98e61", "patch": "@@ -80,6 +80,8 @@ pub struct ArgType {\n     /// Only later will `original_ty` aka `%Foo` be used in the LLVM function\n     /// pointer type, without ever having introspected it.\n     pub ty: Type,\n+    /// Signedness for integer types, None for other types\n+    pub signedness: Option<bool>,\n     /// Coerced LLVM Type\n     pub cast: Option<Type>,\n     /// Dummy argument, which is emitted before the real argument\n@@ -94,6 +96,7 @@ impl ArgType {\n             kind: ArgKind::Direct,\n             original_ty: original_ty,\n             ty: ty,\n+            signedness: None,\n             cast: None,\n             pad: None,\n             attrs: llvm::Attributes::default()\n@@ -123,6 +126,19 @@ impl ArgType {\n         self.kind = ArgKind::Ignore;\n     }\n \n+    pub fn extend_integer_width_to(&mut self, bits: u64) {\n+        // Only integers have signedness\n+        if let Some(signed) = self.signedness {\n+            if self.ty.int_width() < bits {\n+                self.attrs.set(if signed {\n+                    llvm::Attribute::SExt\n+                } else {\n+                    llvm::Attribute::ZExt\n+                });\n+            }\n+        }\n+    }\n+\n     pub fn is_indirect(&self) -> bool {\n         self.kind == ArgKind::Indirect\n     }\n@@ -268,6 +284,9 @@ impl FnType {\n             } else {\n                 let mut arg = ArgType::new(type_of::type_of(ccx, ty),\n                                            type_of::sizing_type_of(ccx, ty));\n+                if ty.is_integral() {\n+                    arg.signedness = Some(ty.is_signed());\n+                }\n                 if llsize_of_real(ccx, arg.ty) == 0 {\n                     // For some forsaken reason, x86_64-pc-windows-gnu\n                     // doesn't ignore zero-sized struct arguments."}, {"sha": "fc11e3888d3c2e6cfcf72d42e3384ff25d11c39e", "filename": "src/librustc_trans/cabi_aarch64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_aarch64.rs?ref=02acff64a4985d6cb94df1068760506699f98e61", "patch": "@@ -163,6 +163,7 @@ fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n \n fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n     if is_reg_ty(ret.ty) {\n+        ret.extend_integer_width_to(32);\n         return;\n     }\n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ret.ty) {\n@@ -190,6 +191,7 @@ fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n     if is_reg_ty(arg.ty) {\n+        arg.extend_integer_width_to(32);\n         return;\n     }\n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(arg.ty) {"}, {"sha": "68a2e8aa8ce95d8c38bfd91ad30db2cc08927a39", "filename": "src/librustc_trans/cabi_arm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_arm.rs?ref=02acff64a4985d6cb94df1068760506699f98e61", "patch": "@@ -131,6 +131,7 @@ fn ty_size(ty: Type, align_fn: TyAlignFn) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType, align_fn: TyAlignFn) {\n     if is_reg_ty(ret.ty) {\n+        ret.extend_integer_width_to(32);\n         return;\n     }\n     let size = ty_size(ret.ty, align_fn);\n@@ -150,6 +151,7 @@ fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType, align_fn: TyAlignFn) {\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, align_fn: TyAlignFn) {\n     if is_reg_ty(arg.ty) {\n+        arg.extend_integer_width_to(32);\n         return;\n     }\n     let align = align_fn(arg.ty);"}, {"sha": "680310e195a41536d18554af0a994b095f79951d", "filename": "src/librustc_trans/cabi_mips.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips.rs?ref=02acff64a4985d6cb94df1068760506699f98e61", "patch": "@@ -86,6 +86,14 @@ fn ty_size(ty: Type) -> usize {\n     }\n }\n \n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if is_reg_ty(ret.ty) {\n+        ret.extend_integer_width_to(32);\n+    } else {\n+        ret.make_indirect(ccx);\n+    }\n+}\n+\n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n     let orig_offset = *offset;\n     let size = ty_size(arg.ty) * 8;\n@@ -98,6 +106,8 @@ fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n     if !is_reg_ty(arg.ty) {\n         arg.cast = Some(struct_ty(ccx, arg.ty));\n         arg.pad = padding_ty(ccx, align, orig_offset);\n+    } else {\n+        arg.extend_integer_width_to(32);\n     }\n }\n \n@@ -146,8 +156,8 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n }\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    if !fty.ret.is_ignore() && !is_reg_ty(fty.ret.ty) {\n-        fty.ret.make_indirect(ccx);\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret);\n     }\n \n     let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };"}, {"sha": "efbdce67a8b2ad911cd837b3d016a20be58cce46", "filename": "src/librustc_trans/cabi_powerpc.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc.rs?ref=02acff64a4985d6cb94df1068760506699f98e61", "patch": "@@ -82,6 +82,14 @@ fn ty_size(ty: Type) -> usize {\n     }\n }\n \n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if is_reg_ty(ret.ty) {\n+        ret.extend_integer_width_to(32);\n+    } else {\n+        ret.make_indirect(ccx);\n+    }\n+}\n+\n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n     let orig_offset = *offset;\n     let size = ty_size(arg.ty) * 8;\n@@ -94,6 +102,8 @@ fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n     if !is_reg_ty(arg.ty) {\n         arg.cast = Some(struct_ty(ccx, arg.ty));\n         arg.pad = padding_ty(ccx, align, orig_offset);\n+    } else {\n+        arg.extend_integer_width_to(32);\n     }\n }\n \n@@ -141,8 +151,8 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n }\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    if !fty.ret.is_ignore() && !is_reg_ty(fty.ret.ty) {\n-        fty.ret.make_indirect(ccx);\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret);\n     }\n \n     let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };"}, {"sha": "ba54e369fd8382779b9ee6bfd567ccc82b4d2834", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=02acff64a4985d6cb94df1068760506699f98e61", "patch": "@@ -153,6 +153,7 @@ fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n \n fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n     if is_reg_ty(ret.ty) {\n+        ret.extend_integer_width_to(64);\n         return;\n     }\n \n@@ -187,6 +188,7 @@ fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n     if is_reg_ty(arg.ty) {\n+        arg.extend_integer_width_to(64);\n         return;\n     }\n "}, {"sha": "b52231fa6b432f8aaca36d346d29368f2ea024c4", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=02acff64a4985d6cb94df1068760506699f98e61", "patch": "@@ -15,25 +15,29 @@ use super::common::*;\n use super::machine::*;\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    if !fty.ret.is_ignore() && fty.ret.ty.kind() == Struct {\n-        // Returning a structure. Most often, this will use\n-        // a hidden first argument. On some platforms, though,\n-        // small structs are returned as integers.\n-        //\n-        // Some links:\n-        // http://www.angelcode.com/dev/callconv/callconv.html\n-        // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n-        let t = &ccx.sess().target.target;\n-        if t.options.is_like_osx || t.options.is_like_windows {\n-            match llsize_of_alloc(ccx, fty.ret.ty) {\n-                1 => fty.ret.cast = Some(Type::i8(ccx)),\n-                2 => fty.ret.cast = Some(Type::i16(ccx)),\n-                4 => fty.ret.cast = Some(Type::i32(ccx)),\n-                8 => fty.ret.cast = Some(Type::i64(ccx)),\n-                _ => fty.ret.make_indirect(ccx)\n+    if !fty.ret.is_ignore() {\n+        if fty.ret.ty.kind() == Struct {\n+            // Returning a structure. Most often, this will use\n+            // a hidden first argument. On some platforms, though,\n+            // small structs are returned as integers.\n+            //\n+            // Some links:\n+            // http://www.angelcode.com/dev/callconv/callconv.html\n+            // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n+            let t = &ccx.sess().target.target;\n+            if t.options.is_like_osx || t.options.is_like_windows {\n+                match llsize_of_alloc(ccx, fty.ret.ty) {\n+                    1 => fty.ret.cast = Some(Type::i8(ccx)),\n+                    2 => fty.ret.cast = Some(Type::i16(ccx)),\n+                    4 => fty.ret.cast = Some(Type::i32(ccx)),\n+                    8 => fty.ret.cast = Some(Type::i64(ccx)),\n+                    _ => fty.ret.make_indirect(ccx)\n+                }\n+            } else {\n+                fty.ret.make_indirect(ccx);\n             }\n         } else {\n-            fty.ret.make_indirect(ccx);\n+            fty.ret.extend_integer_width_to(32);\n         }\n     }\n \n@@ -42,6 +46,8 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n         if arg.ty.kind() == Struct {\n             arg.make_indirect(ccx);\n             arg.attrs.set(Attribute::ByVal);\n+        } else {\n+            arg.extend_integer_width_to(32);\n         }\n     }\n }"}, {"sha": "805c7d345a0e72d2de3a47209f325937e74d7c83", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=02acff64a4985d6cb94df1068760506699f98e61", "patch": "@@ -400,6 +400,8 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n             } else {\n                 arg.cast = Some(llreg_ty(ccx, &cls));\n             }\n+        } else {\n+            arg.extend_integer_width_to(32);\n         }\n     }\n "}, {"sha": "71ecb6e9ca104593024e0b10a04be9874f9c6b73", "filename": "src/librustc_trans/cabi_x86_win64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02acff64a4985d6cb94df1068760506699f98e61/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_win64.rs?ref=02acff64a4985d6cb94df1068760506699f98e61", "patch": "@@ -26,6 +26,8 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n                 8 => a.cast = Some(Type::i64(ccx)),\n                 _ => a.make_indirect(ccx)\n             }\n+        } else {\n+            a.extend_integer_width_to(32);\n         }\n     };\n "}, {"sha": "d2ebdcca80cf0cb6b44a037b1b3c08fa7e1921b7", "filename": "src/rt/rust_test_helpers.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02acff64a4985d6cb94df1068760506699f98e61/src%2Frt%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/02acff64a4985d6cb94df1068760506699f98e61/src%2Frt%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.c?ref=02acff64a4985d6cb94df1068760506699f98e61", "patch": "@@ -243,3 +243,7 @@ double rust_interesting_average(uint64_t n, ...) {\n     va_end(pairs);\n     return sum / n;\n }\n+\n+int32_t rust_int8_to_int32(int8_t x) {\n+    return (int32_t)x;\n+}"}, {"sha": "c7a227593333524eea1d04c83de7bd97fa3fded3", "filename": "src/test/run-pass/cabi-int-widening.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/02acff64a4985d6cb94df1068760506699f98e61/src%2Ftest%2Frun-pass%2Fcabi-int-widening.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02acff64a4985d6cb94df1068760506699f98e61/src%2Ftest%2Frun-pass%2Fcabi-int-widening.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcabi-int-widening.rs?ref=02acff64a4985d6cb94df1068760506699f98e61", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[link(name = \"rust_test_helpers\")]\n+extern {\n+    fn rust_int8_to_int32(_: i8) -> i32;\n+}\n+\n+fn main() {\n+    let x = unsafe {\n+        rust_int8_to_int32(-1)\n+    };\n+\n+    assert!(x == -1);\n+}"}]}