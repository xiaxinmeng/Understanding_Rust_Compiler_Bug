{"sha": "0d892873d84c3aca95715eb162d5941e278761ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkODkyODczZDg0YzNhY2E5NTcxNWViMTYyZDU5NDFlMjc4NzYxZWY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-04-10T16:15:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-10T16:15:19Z"}, "message": "Rollup merge of #70973 - ecstatic-morse:recursion-lint, r=jonas-schievink\n\nUse forward traversal for unconditional recursion lint\n\nWhile reviewing #70822, I noted that #54444 could be solved without requiring the predecessor graph and without allocating a `Vec<Span>` for every basic block. The unconditional recursion lint is not a performance bottleneck however, so I approved #70822 as it was.\n\nNevertheless, I wanted to try implementing my idea using `TriColorDepthFirstSearch`, which is a DFS that can differentiate between [forward/tree edges and backward ones](https://en.wikipedia.org/wiki/Depth-first_search#Output_of_a_depth-first_search). I found this approach more straightforward than the existing one, so I'm opening this PR to see if it is desirable.\n\nThe pass is now just a DFS across the control-flow graph. We ignore false edges and false unwinds, as well as the successors of recursive calls, just like existing pass does. If we see a back-edge (loop) or a terminator that would cause us to yield control-flow back to the caller (`Return`, `Resume`, etc.), we know that the function does not unconditionally recurse.\n\nr? @jonas-schievink", "tree": {"sha": "caadf38c39d48ccbc7c8d8d5b0e080a8307c4b9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caadf38c39d48ccbc7c8d8d5b0e080a8307c4b9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d892873d84c3aca95715eb162d5941e278761ef", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJekJuXCRBK7hj4Ov3rIwAAdHIIAGxmDOZdLIDX4bZG3Mh6Jafh\n+bLSWhdFVNgUPhzaVVcXVG3m3sZ1T1KIOGrte152JFeVf7vDpDite1InnETgKK4F\n26oh4itWN9Fxfrn1/sjA4tdorH2QnIKgzkpKg8WOrcrqxCIirMzhOoEOc9ZctBSa\nZijgQ5FotdF6u44LesH8YK4ZRPxFCBB2IuGv5KOTacG0uK9SeC5zOXwVSu/VY1VY\nxZ/7QCLY3UQbKnJtUmQrMjFLHk4qZWe+eunRWEQrYwSuy6LvCGzcLj3ud2pFtTIE\nZDMZcq+tYgV81YEQf3ZaqSElq+RBFcgdJbtqin1uTCSx8aox1qqcYnnkGoE26XA=\n=cO61\n-----END PGP SIGNATURE-----\n", "payload": "tree caadf38c39d48ccbc7c8d8d5b0e080a8307c4b9c\nparent 6b2df46b2e25c20ce825c293bfc367846513560b\nparent 0fc0f34ae4fdae562b445e26778c64d60b69cf02\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1586535319 +0200\ncommitter GitHub <noreply@github.com> 1586535319 +0200\n\nRollup merge of #70973 - ecstatic-morse:recursion-lint, r=jonas-schievink\n\nUse forward traversal for unconditional recursion lint\n\nWhile reviewing #70822, I noted that #54444 could be solved without requiring the predecessor graph and without allocating a `Vec<Span>` for every basic block. The unconditional recursion lint is not a performance bottleneck however, so I approved #70822 as it was.\n\nNevertheless, I wanted to try implementing my idea using `TriColorDepthFirstSearch`, which is a DFS that can differentiate between [forward/tree edges and backward ones](https://en.wikipedia.org/wiki/Depth-first_search#Output_of_a_depth-first_search). I found this approach more straightforward than the existing one, so I'm opening this PR to see if it is desirable.\n\nThe pass is now just a DFS across the control-flow graph. We ignore false edges and false unwinds, as well as the successors of recursive calls, just like existing pass does. If we see a back-edge (loop) or a terminator that would cause us to yield control-flow back to the caller (`Return`, `Resume`, etc.), we know that the function does not unconditionally recurse.\n\nr? @jonas-schievink\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d892873d84c3aca95715eb162d5941e278761ef", "html_url": "https://github.com/rust-lang/rust/commit/0d892873d84c3aca95715eb162d5941e278761ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d892873d84c3aca95715eb162d5941e278761ef/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b2df46b2e25c20ce825c293bfc367846513560b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b2df46b2e25c20ce825c293bfc367846513560b", "html_url": "https://github.com/rust-lang/rust/commit/6b2df46b2e25c20ce825c293bfc367846513560b"}, {"sha": "0fc0f34ae4fdae562b445e26778c64d60b69cf02", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fc0f34ae4fdae562b445e26778c64d60b69cf02", "html_url": "https://github.com/rust-lang/rust/commit/0fc0f34ae4fdae562b445e26778c64d60b69cf02"}], "stats": {"total": 259, "additions": 121, "deletions": 138}, "files": [{"sha": "64ff6130ddffb0e9679e18f7c26bc62f88ea5345", "filename": "src/librustc_data_structures/graph/iterate/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d892873d84c3aca95715eb162d5941e278761ef/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d892873d84c3aca95715eb162d5941e278761ef/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs?ref=0d892873d84c3aca95715eb162d5941e278761ef", "patch": "@@ -209,7 +209,9 @@ where\n                     // schedule its successors for examination.\n                     self.stack.push(Event { node, becomes: Settled });\n                     for succ in self.graph.successors(node) {\n-                        self.stack.push(Event { node: succ, becomes: Visited });\n+                        if !visitor.ignore_edge(node, succ) {\n+                            self.stack.push(Event { node: succ, becomes: Visited });\n+                        }\n                     }\n                 }\n             }\n@@ -255,16 +257,21 @@ where\n     /// [CLR]: https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n     fn node_examined(\n         &mut self,\n-        _target: G::Node,\n+        _node: G::Node,\n         _prior_status: Option<NodeStatus>,\n     ) -> ControlFlow<Self::BreakVal> {\n         ControlFlow::Continue\n     }\n \n     /// Called after all nodes reachable from this one have been examined.\n-    fn node_settled(&mut self, _target: G::Node) -> ControlFlow<Self::BreakVal> {\n+    fn node_settled(&mut self, _node: G::Node) -> ControlFlow<Self::BreakVal> {\n         ControlFlow::Continue\n     }\n+\n+    /// Behave as if no edges exist from `source` to `target`.\n+    fn ignore_edge(&mut self, _source: G::Node, _target: G::Node) -> bool {\n+        false\n+    }\n }\n \n /// This `TriColorVisitor` looks for back edges in a graph, which indicate that a cycle exists."}, {"sha": "04cb509d44e4b32b337a53640d969b04fd5f07f4", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d892873d84c3aca95715eb162d5941e278761ef/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d892873d84c3aca95715eb162d5941e278761ef/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=0d892873d84c3aca95715eb162d5941e278761ef", "patch": "@@ -178,11 +178,11 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n             build::construct_const(cx, body_id, return_ty, return_ty_span)\n         };\n \n+        lints::check(tcx, &body, def_id);\n+\n         let mut body = BodyAndCache::new(body);\n         body.ensure_predecessors();\n \n-        lints::check(tcx, &body.unwrap_read_only(), def_id);\n-\n         // The borrow checker will replace all the regions here with its own\n         // inference variables. There's no point having non-erased regions here.\n         // The exception is `body.user_type_annotations`, which is used unmodified"}, {"sha": "948f1ae0b427730bb2d6c249914b271a3a5c486a", "filename": "src/librustc_mir_build/lints.rs", "status": "modified", "additions": 109, "deletions": 133, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/0d892873d84c3aca95715eb162d5941e278761ef/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d892873d84c3aca95715eb162d5941e278761ef/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=0d892873d84c3aca95715eb162d5941e278761ef", "patch": "@@ -1,15 +1,16 @@\n+use rustc_data_structures::graph::iterate::{\n+    ControlFlow, NodeStatus, TriColorDepthFirstSearch, TriColorVisitor,\n+};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::FnKind;\n-use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n use rustc_middle::hir::map::blocks::FnLikeNode;\n-use rustc_middle::mir::{BasicBlock, Body, ReadOnlyBodyAndCache, TerminatorKind, START_BLOCK};\n-use rustc_middle::ty::subst::InternalSubsts;\n+use rustc_middle::mir::{BasicBlock, Body, Operand, TerminatorKind};\n+use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n use rustc_middle::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n-use std::collections::VecDeque;\n+use rustc_span::Span;\n \n-crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &ReadOnlyBodyAndCache<'_, 'tcx>, def_id: DefId) {\n+crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get(hir_id)) {\n@@ -18,158 +19,133 @@ crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &ReadOnlyBodyAndCache<'_, 'tcx>, d\n             return;\n         }\n \n-        check_fn_for_unconditional_recursion(tcx, body, def_id);\n-    }\n-}\n-\n-fn check_fn_for_unconditional_recursion<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    body: &ReadOnlyBodyAndCache<'_, 'tcx>,\n-    def_id: DefId,\n-) {\n-    let self_calls = find_blocks_calling_self(tcx, &body, def_id);\n-\n-    // Stores a list of `Span`s for every basic block. Those are the spans of self-calls where we\n-    // know that one of them will definitely be reached. If the list is empty, the block either\n-    // wasn't processed yet or will not always go to a self-call.\n-    let mut results = IndexVec::from_elem_n(vec![], body.basic_blocks().len());\n-\n-    // We start the analysis at the self calls and work backwards.\n-    let mut queue: VecDeque<_> = self_calls.iter().collect();\n-\n-    while let Some(bb) = queue.pop_front() {\n-        if !results[bb].is_empty() {\n-            // Already propagated.\n-            continue;\n-        }\n-\n-        let locations = if self_calls.contains(bb) {\n-            // `bb` *is* a self-call.\n-            // We don't look at successors here because they are irrelevant here and we don't want\n-            // to lint them (eg. `f(); f()` should only lint the first call).\n-            vec![bb]\n-        } else {\n-            // If *all* successors of `bb` lead to a self-call, emit notes at all of their\n-            // locations.\n-\n-            // Determine all \"relevant\" successors. We ignore successors only reached via unwinding.\n-            let terminator = body[bb].terminator();\n-            let relevant_successors = match &terminator.kind {\n-                TerminatorKind::Call { destination: None, .. }\n-                | TerminatorKind::Yield { .. }\n-                | TerminatorKind::GeneratorDrop => None.into_iter().chain(&[]),\n-                TerminatorKind::SwitchInt { targets, .. } => None.into_iter().chain(targets),\n-                TerminatorKind::Goto { target }\n-                | TerminatorKind::Drop { target, .. }\n-                | TerminatorKind::DropAndReplace { target, .. }\n-                | TerminatorKind::Assert { target, .. }\n-                | TerminatorKind::FalseEdges { real_target: target, .. }\n-                | TerminatorKind::FalseUnwind { real_target: target, .. }\n-                | TerminatorKind::Call { destination: Some((_, target)), .. } => {\n-                    Some(target).into_iter().chain(&[])\n-                }\n-                TerminatorKind::Resume\n-                | TerminatorKind::Abort\n-                | TerminatorKind::Return\n-                | TerminatorKind::Unreachable => {\n-                    // We propagate backwards, so these should never be encountered here.\n-                    unreachable!(\"unexpected terminator {:?}\", terminator.kind)\n-                }\n-            };\n-\n-            // If all our successors are known to lead to self-calls, then we do too.\n-            let all_are_self_calls =\n-                relevant_successors.clone().all(|&succ| !results[succ].is_empty());\n-\n-            if all_are_self_calls {\n-                // We'll definitely lead to a self-call. Merge all call locations of the successors\n-                // for linting them later.\n-                relevant_successors.flat_map(|&succ| results[succ].iter().copied()).collect()\n-            } else {\n-                // At least 1 successor does not always lead to a self-call, so we also don't.\n-                vec![]\n+        // If this is trait/impl method, extract the trait's substs.\n+        let trait_substs = match tcx.opt_associated_item(def_id) {\n+            Some(AssocItem {\n+                container: AssocItemContainer::TraitContainer(trait_def_id), ..\n+            }) => {\n+                let trait_substs_count = tcx.generics_of(trait_def_id).count();\n+                &InternalSubsts::identity_for_item(tcx, def_id)[..trait_substs_count]\n             }\n+            _ => &[],\n         };\n \n-        if !locations.is_empty() {\n-            // This is a newly confirmed-to-always-reach-self-call block.\n-            results[bb] = locations;\n-\n-            // Propagate backwards through the CFG.\n-            debug!(\"propagate loc={:?} in {:?} -> {:?}\", results[bb], bb, body.predecessors()[bb]);\n-            queue.extend(body.predecessors()[bb].iter().copied());\n+        let mut vis = Search { tcx, body, def_id, reachable_recursive_calls: vec![], trait_substs };\n+        if let Some(NonRecursive) = TriColorDepthFirstSearch::new(&body).run_from_start(&mut vis) {\n+            return;\n         }\n-    }\n-\n-    debug!(\"unconditional recursion results: {:?}\", results);\n \n-    let self_call_locations = &mut results[START_BLOCK];\n-    self_call_locations.sort();\n-    self_call_locations.dedup();\n+        vis.reachable_recursive_calls.sort();\n \n-    if !self_call_locations.is_empty() {\n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let sp = tcx.sess.source_map().guess_head_span(tcx.hir().span(hir_id));\n         tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION, hir_id, sp, |lint| {\n             let mut db = lint.build(\"function cannot return without recursing\");\n             db.span_label(sp, \"cannot return without recursing\");\n             // offer some help to the programmer.\n-            for bb in self_call_locations {\n-                let span = body.basic_blocks()[*bb].terminator().source_info.span;\n-                db.span_label(span, \"recursive call site\");\n+            for call_span in vis.reachable_recursive_calls {\n+                db.span_label(call_span, \"recursive call site\");\n             }\n             db.help(\"a `loop` may express intention better if this is on purpose\");\n             db.emit();\n         });\n     }\n }\n \n-/// Finds blocks with `Call` terminators that would end up calling back into the same method.\n-fn find_blocks_calling_self<'tcx>(\n+struct NonRecursive;\n+\n+struct Search<'mir, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n+    body: &'mir Body<'tcx>,\n     def_id: DefId,\n-) -> BitSet<BasicBlock> {\n-    let param_env = tcx.param_env(def_id);\n+    trait_substs: &'tcx [GenericArg<'tcx>],\n \n-    // If this is trait/impl method, extract the trait's substs.\n-    let trait_substs_count = match tcx.opt_associated_item(def_id) {\n-        Some(AssocItem { container: AssocItemContainer::TraitContainer(trait_def_id), .. }) => {\n-            tcx.generics_of(trait_def_id).count()\n+    reachable_recursive_calls: Vec<Span>,\n+}\n+\n+impl<'mir, 'tcx> Search<'mir, 'tcx> {\n+    /// Returns `true` if `func` refers to the function we are searching in.\n+    fn is_recursive_call(&self, func: &Operand<'tcx>) -> bool {\n+        let Search { tcx, body, def_id, trait_substs, .. } = *self;\n+        let param_env = tcx.param_env(def_id);\n+\n+        let func_ty = func.ty(body, tcx);\n+        if let ty::FnDef(fn_def_id, substs) = func_ty.kind {\n+            let (call_fn_id, call_substs) =\n+                if let Some(instance) = Instance::resolve(tcx, param_env, fn_def_id, substs) {\n+                    (instance.def_id(), instance.substs)\n+                } else {\n+                    (fn_def_id, substs)\n+                };\n+\n+            // FIXME(#57965): Make this work across function boundaries\n+\n+            // If this is a trait fn, the substs on the trait have to match, or we might be\n+            // calling into an entirely different method (for example, a call from the default\n+            // method in the trait to `<A as Trait<B>>::method`, where `A` and/or `B` are\n+            // specific types).\n+            return call_fn_id == def_id && &call_substs[..trait_substs.len()] == trait_substs;\n+        }\n+\n+        false\n+    }\n+}\n+\n+impl<'mir, 'tcx> TriColorVisitor<&'mir Body<'tcx>> for Search<'mir, 'tcx> {\n+    type BreakVal = NonRecursive;\n+\n+    fn node_examined(\n+        &mut self,\n+        bb: BasicBlock,\n+        prior_status: Option<NodeStatus>,\n+    ) -> ControlFlow<Self::BreakVal> {\n+        // Back-edge in the CFG (loop).\n+        if let Some(NodeStatus::Visited) = prior_status {\n+            return ControlFlow::Break(NonRecursive);\n+        }\n+\n+        match self.body[bb].terminator().kind {\n+            // These terminators return control flow to the caller.\n+            TerminatorKind::Abort\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Yield { .. } => ControlFlow::Break(NonRecursive),\n+\n+            // These do not.\n+            TerminatorKind::Assert { .. }\n+            | TerminatorKind::Call { .. }\n+            | TerminatorKind::Drop { .. }\n+            | TerminatorKind::DropAndReplace { .. }\n+            | TerminatorKind::FalseEdges { .. }\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::Goto { .. }\n+            | TerminatorKind::SwitchInt { .. } => ControlFlow::Continue,\n         }\n-        _ => 0,\n-    };\n-    let trait_substs = &InternalSubsts::identity_for_item(tcx, def_id)[..trait_substs_count];\n-\n-    let mut self_calls = BitSet::new_empty(body.basic_blocks().len());\n-\n-    for (bb, data) in body.basic_blocks().iter_enumerated() {\n-        if let TerminatorKind::Call { func, .. } = &data.terminator().kind {\n-            let func_ty = func.ty(body, tcx);\n-\n-            if let ty::FnDef(fn_def_id, substs) = func_ty.kind {\n-                let (call_fn_id, call_substs) =\n-                    if let Some(instance) = Instance::resolve(tcx, param_env, fn_def_id, substs) {\n-                        (instance.def_id(), instance.substs)\n-                    } else {\n-                        (fn_def_id, substs)\n-                    };\n-\n-                // FIXME(#57965): Make this work across function boundaries\n-\n-                // If this is a trait fn, the substs on the trait have to match, or we might be\n-                // calling into an entirely different method (for example, a call from the default\n-                // method in the trait to `<A as Trait<B>>::method`, where `A` and/or `B` are\n-                // specific types).\n-                let is_self_call =\n-                    call_fn_id == def_id && &call_substs[..trait_substs.len()] == trait_substs;\n-\n-                if is_self_call {\n-                    self_calls.insert(bb);\n-                }\n+    }\n+\n+    fn node_settled(&mut self, bb: BasicBlock) -> ControlFlow<Self::BreakVal> {\n+        // When we examine a node for the last time, remember it if it is a recursive call.\n+        let terminator = self.body[bb].terminator();\n+        if let TerminatorKind::Call { func, .. } = &terminator.kind {\n+            if self.is_recursive_call(func) {\n+                self.reachable_recursive_calls.push(terminator.source_info.span);\n             }\n         }\n+\n+        ControlFlow::Continue\n     }\n \n-    self_calls\n+    fn ignore_edge(&mut self, bb: BasicBlock, target: BasicBlock) -> bool {\n+        // Don't traverse successors of recursive calls or false CFG edges.\n+        match self.body[bb].terminator().kind {\n+            TerminatorKind::Call { ref func, .. } => self.is_recursive_call(func),\n+\n+            TerminatorKind::FalseUnwind { unwind: Some(imaginary_target), .. }\n+            | TerminatorKind::FalseEdges { imaginary_target, .. } => imaginary_target == target,\n+\n+            _ => false,\n+        }\n+    }\n }"}]}