{"sha": "88c3242ef26956266970d62571a1d7d079b5799a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4YzMyNDJlZjI2OTU2MjY2OTcwZDYyNTcxYTFkN2QwNzliNTc5OWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-28T03:41:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-28T03:41:22Z"}, "message": "Auto merge of #42431 - nagisa:core-float-2, r=alexcrichton\n\nFix NaN handling in is_sign_negative/positive\n\nThis would be my proposed fix for the #42425 provided we decide it is indeed a problem.\n\nNote this would technically be a breaking change to a stable API. We might want to consider deprecating these methods and adding new ones.", "tree": {"sha": "0e5053f9f06d10328b0c993ee996c16f2b42cc96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e5053f9f06d10328b0c993ee996c16f2b42cc96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88c3242ef26956266970d62571a1d7d079b5799a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88c3242ef26956266970d62571a1d7d079b5799a", "html_url": "https://github.com/rust-lang/rust/commit/88c3242ef26956266970d62571a1d7d079b5799a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88c3242ef26956266970d62571a1d7d079b5799a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7", "html_url": "https://github.com/rust-lang/rust/commit/4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7"}, {"sha": "3b9fe77bfcd4c800fab8afcdcc82d31facdc515b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b9fe77bfcd4c800fab8afcdcc82d31facdc515b", "html_url": "https://github.com/rust-lang/rust/commit/3b9fe77bfcd4c800fab8afcdcc82d31facdc515b"}], "stats": {"total": 86, "additions": 40, "deletions": 46}, "files": [{"sha": "ebc30dc8b61fb0fd390e16a745728c89d60cdc3f", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/88c3242ef26956266970d62571a1d7d079b5799a/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c3242ef26956266970d62571a1d7d079b5799a/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=88c3242ef26956266970d62571a1d7d079b5799a", "patch": "@@ -205,18 +205,25 @@ impl Float for f32 {\n         }\n     }\n \n-    /// Returns `true` if `self` is positive, including `+0.0` and\n-    /// `Float::infinity()`.\n+    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// positive sign bit and positive infinity.\n     #[inline]\n     fn is_sign_positive(self) -> bool {\n-        self > 0.0 || (1.0 / self) == INFINITY\n+        !self.is_sign_negative()\n     }\n \n-    /// Returns `true` if `self` is negative, including `-0.0` and\n-    /// `Float::neg_infinity()`.\n+    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// negative sign bit and negative infinity.\n     #[inline]\n     fn is_sign_negative(self) -> bool {\n-        self < 0.0 || (1.0 / self) == NEG_INFINITY\n+        // IEEE754 says: isSignMinus(x) is true if and only if x has negative sign. isSignMinus\n+        // applies to zeros and NaNs as well.\n+        #[repr(C)]\n+        union F32Bytes {\n+            f: f32,\n+            b: u32\n+        }\n+        unsafe { F32Bytes { f: self }.b & 0x8000_0000 != 0 }\n     }\n \n     /// Returns the reciprocal (multiplicative inverse) of the number."}, {"sha": "1a1fe4d86e0d093ccb3dab01139374948a88023b", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/88c3242ef26956266970d62571a1d7d079b5799a/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c3242ef26956266970d62571a1d7d079b5799a/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=88c3242ef26956266970d62571a1d7d079b5799a", "patch": "@@ -205,18 +205,23 @@ impl Float for f64 {\n         }\n     }\n \n-    /// Returns `true` if `self` is positive, including `+0.0` and\n-    /// `Float::infinity()`.\n+    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// positive sign bit and positive infinity.\n     #[inline]\n     fn is_sign_positive(self) -> bool {\n-        self > 0.0 || (1.0 / self) == INFINITY\n+        !self.is_sign_negative()\n     }\n \n-    /// Returns `true` if `self` is negative, including `-0.0` and\n-    /// `Float::neg_infinity()`.\n+    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// negative sign bit and negative infinity.\n     #[inline]\n     fn is_sign_negative(self) -> bool {\n-        self < 0.0 || (1.0 / self) == NEG_INFINITY\n+        #[repr(C)]\n+        union F64Bytes {\n+            f: f64,\n+            b: u64\n+        }\n+        unsafe { F64Bytes { f: self }.b & 0x8000_0000_0000_0000 != 0 }\n     }\n \n     /// Returns the reciprocal (multiplicative inverse) of the number."}, {"sha": "7d79fb078116f568cd6124af01b6beac93108c97", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/88c3242ef26956266970d62571a1d7d079b5799a/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c3242ef26956266970d62571a1d7d079b5799a/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=88c3242ef26956266970d62571a1d7d079b5799a", "patch": "@@ -363,39 +363,29 @@ impl f32 {\n     #[inline]\n     pub fn signum(self) -> f32 { num::Float::signum(self) }\n \n-    /// Returns `true` if `self`'s sign bit is positive, including\n-    /// `+0.0` and `INFINITY`.\n+    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// positive sign bit and positive infinity.\n     ///\n     /// ```\n-    /// use std::f32;\n-    ///\n-    /// let nan = f32::NAN;\n     /// let f = 7.0_f32;\n     /// let g = -7.0_f32;\n     ///\n     /// assert!(f.is_sign_positive());\n     /// assert!(!g.is_sign_positive());\n-    /// // Requires both tests to determine if is `NaN`\n-    /// assert!(!nan.is_sign_positive() && !nan.is_sign_negative());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_sign_positive(self) -> bool { num::Float::is_sign_positive(self) }\n \n-    /// Returns `true` if `self`'s sign is negative, including `-0.0`\n-    /// and `NEG_INFINITY`.\n+    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// negative sign bit and negative infinity.\n     ///\n     /// ```\n-    /// use std::f32;\n-    ///\n-    /// let nan = f32::NAN;\n     /// let f = 7.0f32;\n     /// let g = -7.0f32;\n     ///\n     /// assert!(!f.is_sign_negative());\n     /// assert!(g.is_sign_negative());\n-    /// // Requires both tests to determine if is `NaN`.\n-    /// assert!(!nan.is_sign_positive() && !nan.is_sign_negative());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1184,7 +1174,7 @@ mod tests {\n         assert!(!nan.is_infinite());\n         assert!(!nan.is_finite());\n         assert!(!nan.is_normal());\n-        assert!(!nan.is_sign_positive());\n+        assert!(nan.is_sign_positive());\n         assert!(!nan.is_sign_negative());\n         assert_eq!(Fp::Nan, nan.classify());\n     }\n@@ -1428,7 +1418,8 @@ mod tests {\n         assert!(!(-1f32).is_sign_positive());\n         assert!(!NEG_INFINITY.is_sign_positive());\n         assert!(!(1f32/NEG_INFINITY).is_sign_positive());\n-        assert!(!NAN.is_sign_positive());\n+        assert!(NAN.is_sign_positive());\n+        assert!(!(-NAN).is_sign_positive());\n     }\n \n     #[test]\n@@ -1441,6 +1432,7 @@ mod tests {\n         assert!(NEG_INFINITY.is_sign_negative());\n         assert!((1f32/NEG_INFINITY).is_sign_negative());\n         assert!(!NAN.is_sign_negative());\n+        assert!((-NAN).is_sign_negative());\n     }\n \n     #[test]"}, {"sha": "d5b0cd3a1fc796b5493cfab84ce3adaadecfbaf7", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/88c3242ef26956266970d62571a1d7d079b5799a/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c3242ef26956266970d62571a1d7d079b5799a/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=88c3242ef26956266970d62571a1d7d079b5799a", "patch": "@@ -301,21 +301,15 @@ impl f64 {\n     #[inline]\n     pub fn signum(self) -> f64 { num::Float::signum(self) }\n \n-    /// Returns `true` if `self`'s sign bit is positive, including\n-    /// `+0.0` and `INFINITY`.\n+    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// positive sign bit and positive infinity.\n     ///\n     /// ```\n-    /// use std::f64;\n-    ///\n-    /// let nan: f64 = f64::NAN;\n-    ///\n     /// let f = 7.0_f64;\n     /// let g = -7.0_f64;\n     ///\n     /// assert!(f.is_sign_positive());\n     /// assert!(!g.is_sign_positive());\n-    /// // Requires both tests to determine if is `NaN`\n-    /// assert!(!nan.is_sign_positive() && !nan.is_sign_negative());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -326,21 +320,15 @@ impl f64 {\n     #[inline]\n     pub fn is_positive(self) -> bool { num::Float::is_sign_positive(self) }\n \n-    /// Returns `true` if `self`'s sign is negative, including `-0.0`\n-    /// and `NEG_INFINITY`.\n+    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// negative sign bit and negative infinity.\n     ///\n     /// ```\n-    /// use std::f64;\n-    ///\n-    /// let nan = f64::NAN;\n-    ///\n     /// let f = 7.0_f64;\n     /// let g = -7.0_f64;\n     ///\n     /// assert!(!f.is_sign_negative());\n     /// assert!(g.is_sign_negative());\n-    /// // Requires both tests to determine if is `NaN`.\n-    /// assert!(!nan.is_sign_positive() && !nan.is_sign_negative());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1101,7 +1089,7 @@ mod tests {\n         assert!(!nan.is_infinite());\n         assert!(!nan.is_finite());\n         assert!(!nan.is_normal());\n-        assert!(!nan.is_sign_positive());\n+        assert!(nan.is_sign_positive());\n         assert!(!nan.is_sign_negative());\n         assert_eq!(Fp::Nan, nan.classify());\n     }\n@@ -1347,7 +1335,8 @@ mod tests {\n         assert!(!(-1f64).is_sign_positive());\n         assert!(!NEG_INFINITY.is_sign_positive());\n         assert!(!(1f64/NEG_INFINITY).is_sign_positive());\n-        assert!(!NAN.is_sign_positive());\n+        assert!(NAN.is_sign_positive());\n+        assert!(!(-NAN).is_sign_positive());\n     }\n \n     #[test]\n@@ -1360,6 +1349,7 @@ mod tests {\n         assert!(NEG_INFINITY.is_sign_negative());\n         assert!((1f64/NEG_INFINITY).is_sign_negative());\n         assert!(!NAN.is_sign_negative());\n+        assert!((-NAN).is_sign_negative());\n     }\n \n     #[test]"}]}