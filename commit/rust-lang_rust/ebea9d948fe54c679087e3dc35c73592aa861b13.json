{"sha": "ebea9d948fe54c679087e3dc35c73592aa861b13", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZWE5ZDk0OGZlNTRjNjc5MDg3ZTNkYzM1YzczNTkyYWE4NjFiMTM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-03-27T19:37:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-27T19:37:06Z"}, "message": "Rollup merge of #82626 - lcnr:encode_with_shorthandb, r=estebank\n\nupdate array missing `IntoIterator` msg\n\nfixes #82602\n\nr? ```@estebank``` do you know whether we can use the expr span in `rustc_on_unimplemented`? The label isn't too great rn", "tree": {"sha": "0e50fc4a5ffce45466a01c0dd9cfa08b9f4043c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e50fc4a5ffce45466a01c0dd9cfa08b9f4043c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebea9d948fe54c679087e3dc35c73592aa861b13", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgX4ljCRBK7hj4Ov3rIwAAdHIIAFxJnPXSWi0cN8fAbXUJwKL6\nrD9XhvrZLEtmINQMB4rKkM1L59NuJmb4Bwi3ETquDNo9PYxRWMrc1NnR32dAjwMO\nZ+Q39OqVrQa+sXcrRUEGf1XZWOODi1O/aYpshuhsX+sgeZY8WOF+T0mSF0u22P86\nEdqKC9MEX/OxaffBbkxTSrx2MeVwYYz6ryGHiv+vR/Y4qbnjJNDP6Dkw1MOZCxcp\naYsOM4anhr86JjvkxGvnYGX9jw6K6+HWBZ11sOIFqM59MNqhQiDIup+nfRJv/PSK\ntYxCiwPoBmOn9aeRRYxjeYL5en8AFz1j0BEKp0YDJ5qdGA9FKoLN88F2jC/VZVs=\n=nUWE\n-----END PGP SIGNATURE-----\n", "payload": "tree 0e50fc4a5ffce45466a01c0dd9cfa08b9f4043c1\nparent a900677eb962741bd522c653b7933e97af130f24\nparent 5ac917dbb224de8445d1526c62b75941db5e5254\nauthor Dylan DPC <dylan.dpc@gmail.com> 1616873826 +0100\ncommitter GitHub <noreply@github.com> 1616873826 +0100\n\nRollup merge of #82626 - lcnr:encode_with_shorthandb, r=estebank\n\nupdate array missing `IntoIterator` msg\n\nfixes #82602\n\nr? ```@estebank``` do you know whether we can use the expr span in `rustc_on_unimplemented`? The label isn't too great rn\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebea9d948fe54c679087e3dc35c73592aa861b13", "html_url": "https://github.com/rust-lang/rust/commit/ebea9d948fe54c679087e3dc35c73592aa861b13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebea9d948fe54c679087e3dc35c73592aa861b13/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a900677eb962741bd522c653b7933e97af130f24", "url": "https://api.github.com/repos/rust-lang/rust/commits/a900677eb962741bd522c653b7933e97af130f24", "html_url": "https://github.com/rust-lang/rust/commit/a900677eb962741bd522c653b7933e97af130f24"}, {"sha": "5ac917dbb224de8445d1526c62b75941db5e5254", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ac917dbb224de8445d1526c62b75941db5e5254", "html_url": "https://github.com/rust-lang/rust/commit/5ac917dbb224de8445d1526c62b75941db5e5254"}], "stats": {"total": 153, "additions": 81, "deletions": 72}, "files": [{"sha": "49ebca0502c089bee6303cccacd113c460b87df8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 51, "deletions": 47, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ebea9d948fe54c679087e3dc35c73592aa861b13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebea9d948fe54c679087e3dc35c73592aa861b13/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=ebea9d948fe54c679087e3dc35c73592aa861b13", "patch": "@@ -163,61 +163,65 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             flags.push((sym::from_desugaring, None));\n             flags.push((sym::from_desugaring, Some(format!(\"{:?}\", k))));\n         }\n-        let generics = self.tcx.generics_of(def_id);\n-        let self_ty = trait_ref.self_ty();\n-        // This is also included through the generics list as `Self`,\n-        // but the parser won't allow you to use it\n-        flags.push((sym::_Self, Some(self_ty.to_string())));\n-        if let Some(def) = self_ty.ty_adt_def() {\n-            // We also want to be able to select self's original\n-            // signature with no type arguments resolved\n-            flags.push((sym::_Self, Some(self.tcx.type_of(def.did).to_string())));\n-        }\n \n-        for param in generics.params.iter() {\n-            let value = match param.kind {\n-                GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n-                    trait_ref.substs[param.index as usize].to_string()\n-                }\n-                GenericParamDefKind::Lifetime => continue,\n-            };\n-            let name = param.name;\n-            flags.push((name, Some(value)));\n-        }\n+        // Add all types without trimmed paths.\n+        ty::print::with_no_trimmed_paths(|| {\n+            let generics = self.tcx.generics_of(def_id);\n+            let self_ty = trait_ref.self_ty();\n+            // This is also included through the generics list as `Self`,\n+            // but the parser won't allow you to use it\n+            flags.push((sym::_Self, Some(self_ty.to_string())));\n+            if let Some(def) = self_ty.ty_adt_def() {\n+                // We also want to be able to select self's original\n+                // signature with no type arguments resolved\n+                flags.push((sym::_Self, Some(self.tcx.type_of(def.did).to_string())));\n+            }\n \n-        if let Some(true) = self_ty.ty_adt_def().map(|def| def.did.is_local()) {\n-            flags.push((sym::crate_local, None));\n-        }\n+            for param in generics.params.iter() {\n+                let value = match param.kind {\n+                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n+                        trait_ref.substs[param.index as usize].to_string()\n+                    }\n+                    GenericParamDefKind::Lifetime => continue,\n+                };\n+                let name = param.name;\n+                flags.push((name, Some(value)));\n+            }\n \n-        // Allow targeting all integers using `{integral}`, even if the exact type was resolved\n-        if self_ty.is_integral() {\n-            flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n-        }\n+            if let Some(true) = self_ty.ty_adt_def().map(|def| def.did.is_local()) {\n+                flags.push((sym::crate_local, None));\n+            }\n \n-        if let ty::Array(aty, len) = self_ty.kind() {\n-            flags.push((sym::_Self, Some(\"[]\".to_owned())));\n-            flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n-            if let Some(def) = aty.ty_adt_def() {\n-                // We also want to be able to select the array's type's original\n-                // signature with no type arguments resolved\n-                let type_string = self.tcx.type_of(def.did).to_string();\n-                flags.push((sym::_Self, Some(format!(\"[{}]\", type_string))));\n+            // Allow targeting all integers using `{integral}`, even if the exact type was resolved\n+            if self_ty.is_integral() {\n+                flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n+            }\n \n-                let len = len.val.try_to_value().and_then(|v| v.try_to_machine_usize(self.tcx));\n-                let string = match len {\n-                    Some(n) => format!(\"[{}; {}]\", type_string, n),\n-                    None => format!(\"[{}; _]\", type_string),\n-                };\n-                flags.push((sym::_Self, Some(string)));\n+            if let ty::Array(aty, len) = self_ty.kind() {\n+                flags.push((sym::_Self, Some(\"[]\".to_owned())));\n+                flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n+                if let Some(def) = aty.ty_adt_def() {\n+                    // We also want to be able to select the array's type's original\n+                    // signature with no type arguments resolved\n+                    let type_string = self.tcx.type_of(def.did).to_string();\n+                    flags.push((sym::_Self, Some(format!(\"[{}]\", type_string))));\n+\n+                    let len = len.val.try_to_value().and_then(|v| v.try_to_machine_usize(self.tcx));\n+                    let string = match len {\n+                        Some(n) => format!(\"[{}; {}]\", type_string, n),\n+                        None => format!(\"[{}; _]\", type_string),\n+                    };\n+                    flags.push((sym::_Self, Some(string)));\n+                }\n             }\n-        }\n-        if let ty::Dynamic(traits, _) = self_ty.kind() {\n-            for t in traits.iter() {\n-                if let ty::ExistentialPredicate::Trait(trait_ref) = t.skip_binder() {\n-                    flags.push((sym::_Self, Some(self.tcx.def_path_str(trait_ref.def_id))))\n+            if let ty::Dynamic(traits, _) = self_ty.kind() {\n+                for t in traits.iter() {\n+                    if let ty::ExistentialPredicate::Trait(trait_ref) = t.skip_binder() {\n+                        flags.push((sym::_Self, Some(self.tcx.def_path_str(trait_ref.def_id))))\n+                    }\n                 }\n             }\n-        }\n+        });\n \n         if let Ok(Some(command)) =\n             OnUnimplementedDirective::of_item(self.tcx, trait_ref.def_id, def_id)"}, {"sha": "e75a36477188c9bf776e7dfbc6cd6a0641f031f5", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebea9d948fe54c679087e3dc35c73592aa861b13/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebea9d948fe54c679087e3dc35c73592aa861b13/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=ebea9d948fe54c679087e3dc35c73592aa861b13", "patch": "@@ -81,8 +81,8 @@ fn _assert_is_object_safe(_: &dyn Iterator<Item = ()>) {}\n     ),\n     on(\n         _Self = \"[]\",\n-        label = \"borrow the array with `&` or call `.iter()` on it to iterate over it\",\n-        note = \"arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\"\n+        label = \"arrays do not yet implement `IntoIterator`; try using `std::array::IntoIter::new(arr)`\",\n+        note = \"see <https://github.com/rust-lang/rust/pull/65819> for more details\"\n     ),\n     on(\n         _Self = \"{integral}\","}, {"sha": "7d58eb948ea815991b79245d2e926b075d1fd9c8", "filename": "src/test/ui/iterators/array-of-ranges.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ebea9d948fe54c679087e3dc35c73592aa861b13/src%2Ftest%2Fui%2Fiterators%2Farray-of-ranges.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebea9d948fe54c679087e3dc35c73592aa861b13/src%2Ftest%2Fui%2Fiterators%2Farray-of-ranges.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Farray-of-ranges.stderr?ref=ebea9d948fe54c679087e3dc35c73592aa861b13", "patch": "@@ -13,43 +13,43 @@ error[E0277]: `[RangeInclusive<{integer}>; 1]` is not an iterator\n   --> $DIR/array-of-ranges.rs:4:14\n    |\n LL |     for _ in [0..=1] {}\n-   |              ^^^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^^^^^^^ if you meant to iterate between two values, remove the square brackets\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeInclusive<{integer}>; 1]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: `[start..=end]` is an array of one `RangeInclusive`; you might have meant to have a `RangeInclusive` without the brackets: `start..=end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `[RangeInclusive<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error[E0277]: `[RangeFrom<{integer}>; 1]` is not an iterator\n   --> $DIR/array-of-ranges.rs:6:14\n    |\n LL |     for _ in [0..] {}\n-   |              ^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^^^^^ if you meant to iterate from a value onwards, remove the square brackets\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeFrom<{integer}>; 1]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: `[start..]` is an array of one `RangeFrom`; you might have meant to have a `RangeFrom` without the brackets: `start..`, keeping in mind that iterating over an unbounded iterator will run forever unless you `break` or `return` from within the loop\n    = note: required because of the requirements on the impl of `IntoIterator` for `[RangeFrom<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error[E0277]: `[RangeTo<{integer}>; 1]` is not an iterator\n   --> $DIR/array-of-ranges.rs:8:14\n    |\n LL |     for _ in [..1] {}\n-   |              ^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^^^^^ if you meant to iterate until a value, remove the square brackets and add a starting value\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeTo<{integer}>; 1]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: `[..end]` is an array of one `RangeTo`; you might have meant to have a bounded `Range` without the brackets: `0..end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `[RangeTo<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error[E0277]: `[RangeToInclusive<{integer}>; 1]` is not an iterator\n   --> $DIR/array-of-ranges.rs:10:14\n    |\n LL |     for _ in [..=1] {}\n-   |              ^^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^^^^^^ if you meant to iterate until a value (including it), remove the square brackets and add a starting value\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeToInclusive<{integer}>; 1]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: `[..=end]` is an array of one `RangeToInclusive`; you might have meant to have a bounded `RangeInclusive` without the brackets: `0..=end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `[RangeToInclusive<{integer}>; 1]`\n    = note: required by `into_iter`\n \n@@ -79,21 +79,21 @@ error[E0277]: `[std::ops::Range<{integer}>; 2]` is not an iterator\n   --> $DIR/array-of-ranges.rs:19:14\n    |\n LL |     for _ in [0..1, 2..3] {}\n-   |              ^^^^^^^^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^^^^^^^^^^^^ arrays do not yet implement `IntoIterator`; try using `std::array::IntoIter::new(arr)`\n    |\n    = help: the trait `Iterator` is not implemented for `[std::ops::Range<{integer}>; 2]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: see <https://github.com/rust-lang/rust/pull/65819> for more details\n    = note: required because of the requirements on the impl of `IntoIterator` for `[std::ops::Range<{integer}>; 2]`\n    = note: required by `into_iter`\n \n error[E0277]: `[RangeInclusive<{integer}>; 1]` is not an iterator\n   --> $DIR/array-of-ranges.rs:21:14\n    |\n LL |     for _ in [0..=1] {}\n-   |              ^^^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^^^^^^^ if you meant to iterate between two values, remove the square brackets\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeInclusive<{integer}>; 1]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: `[start..=end]` is an array of one `RangeInclusive`; you might have meant to have a `RangeInclusive` without the brackets: `start..=end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `[RangeInclusive<{integer}>; 1]`\n    = note: required by `into_iter`\n "}, {"sha": "7e2b600fb7af2be302796965fe9ca83211932396", "filename": "src/test/ui/iterators/array.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ebea9d948fe54c679087e3dc35c73592aa861b13/src%2Ftest%2Fui%2Fiterators%2Farray.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebea9d948fe54c679087e3dc35c73592aa861b13/src%2Ftest%2Fui%2Fiterators%2Farray.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Farray.stderr?ref=ebea9d948fe54c679087e3dc35c73592aa861b13", "patch": "@@ -2,32 +2,32 @@ error[E0277]: `[{integer}; 2]` is not an iterator\n   --> $DIR/array.rs:2:14\n    |\n LL |     for _ in [1, 2] {}\n-   |              ^^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^^^^^^ arrays do not yet implement `IntoIterator`; try using `std::array::IntoIter::new(arr)`\n    |\n    = help: the trait `Iterator` is not implemented for `[{integer}; 2]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: see <https://github.com/rust-lang/rust/pull/65819> for more details\n    = note: required because of the requirements on the impl of `IntoIterator` for `[{integer}; 2]`\n    = note: required by `into_iter`\n \n error[E0277]: `[{integer}; 2]` is not an iterator\n   --> $DIR/array.rs:5:14\n    |\n LL |     for _ in x {}\n-   |              ^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^ arrays do not yet implement `IntoIterator`; try using `std::array::IntoIter::new(arr)`\n    |\n    = help: the trait `Iterator` is not implemented for `[{integer}; 2]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: see <https://github.com/rust-lang/rust/pull/65819> for more details\n    = note: required because of the requirements on the impl of `IntoIterator` for `[{integer}; 2]`\n    = note: required by `into_iter`\n \n error[E0277]: `[{float}; 2]` is not an iterator\n   --> $DIR/array.rs:7:14\n    |\n LL |     for _ in [1.0, 2.0] {}\n-   |              ^^^^^^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it\n+   |              ^^^^^^^^^^ arrays do not yet implement `IntoIterator`; try using `std::array::IntoIter::new(arr)`\n    |\n    = help: the trait `Iterator` is not implemented for `[{float}; 2]`\n-   = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: see <https://github.com/rust-lang/rust/pull/65819> for more details\n    = note: required because of the requirements on the impl of `IntoIterator` for `[{float}; 2]`\n    = note: required by `into_iter`\n "}, {"sha": "73844329e361d5d69c8773d8bae997318df9aa3e", "filename": "src/test/ui/iterators/ranges.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebea9d948fe54c679087e3dc35c73592aa861b13/src%2Ftest%2Fui%2Fiterators%2Franges.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebea9d948fe54c679087e3dc35c73592aa861b13/src%2Ftest%2Fui%2Fiterators%2Franges.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Franges.stderr?ref=ebea9d948fe54c679087e3dc35c73592aa861b13", "patch": "@@ -2,19 +2,21 @@ error[E0277]: `RangeTo<{integer}>` is not an iterator\n   --> $DIR/ranges.rs:2:14\n    |\n LL |     for _ in ..10 {}\n-   |              ^^^^ `RangeTo<{integer}>` is not an iterator\n+   |              ^^^^ if you meant to iterate until a value, add a starting value\n    |\n    = help: the trait `Iterator` is not implemented for `RangeTo<{integer}>`\n+   = note: `..end` is a `RangeTo`, which cannot be iterated on; you might have meant to have a bounded `Range`: `0..end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `RangeTo<{integer}>`\n    = note: required by `into_iter`\n \n error[E0277]: `RangeToInclusive<{integer}>` is not an iterator\n   --> $DIR/ranges.rs:4:14\n    |\n LL |     for _ in ..=10 {}\n-   |              ^^^^^ `RangeToInclusive<{integer}>` is not an iterator\n+   |              ^^^^^ if you meant to iterate until a value (including it), add a starting value\n    |\n    = help: the trait `Iterator` is not implemented for `RangeToInclusive<{integer}>`\n+   = note: `..=end` is a `RangeToInclusive`, which cannot be iterated on; you might have meant to have a bounded `RangeInclusive`: `0..=end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `RangeToInclusive<{integer}>`\n    = note: required by `into_iter`\n "}, {"sha": "1d77bcb753630f860ce28fd2999e59ce91a3751e", "filename": "src/test/ui/iterators/string.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebea9d948fe54c679087e3dc35c73592aa861b13/src%2Ftest%2Fui%2Fiterators%2Fstring.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebea9d948fe54c679087e3dc35c73592aa861b13/src%2Ftest%2Fui%2Fiterators%2Fstring.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fstring.stderr?ref=ebea9d948fe54c679087e3dc35c73592aa861b13", "patch": "@@ -2,7 +2,7 @@ error[E0277]: `String` is not an iterator\n   --> $DIR/string.rs:2:14\n    |\n LL |     for _ in \"\".to_owned() {}\n-   |              ^^^^^^^^^^^^^ `String` is not an iterator\n+   |              ^^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help: the trait `Iterator` is not implemented for `String`\n    = note: required because of the requirements on the impl of `IntoIterator` for `String`"}, {"sha": "3786457fb1ae3ac5fc54a2d2f83cd59ec9e5944f", "filename": "src/test/ui/suggestions/expected-boxed-future-isnt-pinned.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebea9d948fe54c679087e3dc35c73592aa861b13/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebea9d948fe54c679087e3dc35c73592aa861b13/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr?ref=ebea9d948fe54c679087e3dc35c73592aa861b13", "patch": "@@ -46,6 +46,7 @@ error[E0277]: `dyn Future<Output = i32> + Send` cannot be unpinned\n LL |     Pin::new(x)\n    |     ^^^^^^^^ the trait `Unpin` is not implemented for `dyn Future<Output = i32> + Send`\n    |\n+   = note: consider using `Box::pin`\n    = note: required by `Pin::<P>::new`\n \n error[E0277]: `dyn Future<Output = i32> + Send` cannot be unpinned\n@@ -54,6 +55,7 @@ error[E0277]: `dyn Future<Output = i32> + Send` cannot be unpinned\n LL |     Pin::new(Box::new(x))\n    |     ^^^^^^^^ the trait `Unpin` is not implemented for `dyn Future<Output = i32> + Send`\n    |\n+   = note: consider using `Box::pin`\n    = note: required by `Pin::<P>::new`\n \n error[E0308]: mismatched types"}, {"sha": "26efd50bb8fd3479c2eaaff85cf6e9109696a73b", "filename": "src/test/ui/suggestions/into-str.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ebea9d948fe54c679087e3dc35c73592aa861b13/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebea9d948fe54c679087e3dc35c73592aa861b13/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr?ref=ebea9d948fe54c679087e3dc35c73592aa861b13", "patch": "@@ -7,6 +7,7 @@ LL | fn foo<'a, T>(_t: T) where T: Into<&'a str> {}\n LL |     foo(String::new());\n    |     ^^^ the trait `From<String>` is not implemented for `&str`\n    |\n+   = note: to coerce a `String` into a `&str`, use `&*` as a prefix\n    = note: required because of the requirements on the impl of `Into<&str>` for `String`\n \n error: aborting due to previous error"}, {"sha": "3ee2860b4ffc7033b91131d17c06ce1bb59b5116", "filename": "src/test/ui/suggestions/path-display.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebea9d948fe54c679087e3dc35c73592aa861b13/src%2Ftest%2Fui%2Fsuggestions%2Fpath-display.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebea9d948fe54c679087e3dc35c73592aa861b13/src%2Ftest%2Fui%2Fsuggestions%2Fpath-display.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fpath-display.stderr?ref=ebea9d948fe54c679087e3dc35c73592aa861b13", "patch": "@@ -2,10 +2,10 @@ error[E0277]: `Path` doesn't implement `std::fmt::Display`\n   --> $DIR/path-display.rs:5:20\n    |\n LL |     println!(\"{}\", path);\n-   |                    ^^^^ `Path` cannot be formatted with the default formatter\n+   |                    ^^^^ `Path` cannot be formatted with the default formatter; call `.display()` on it\n    |\n    = help: the trait `std::fmt::Display` is not implemented for `Path`\n-   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+   = note: call `.display()` or `.to_string_lossy()` to safely print paths, as they may contain non-Unicode data\n    = note: required because of the requirements on the impl of `std::fmt::Display` for `&Path`\n    = note: required by `std::fmt::Display::fmt`\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)"}]}