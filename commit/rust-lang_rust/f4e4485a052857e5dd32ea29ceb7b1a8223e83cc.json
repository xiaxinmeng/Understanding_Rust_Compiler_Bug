{"sha": "f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZTQ0ODVhMDUyODU3ZTVkZDMyZWEyOWNlYjdiMWE4MjIzZTgzY2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-16T00:56:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-16T00:56:12Z"}, "message": "Auto merge of #76771 - Dylan-DPC:rollup-qj4j3ma, r=Dylan-DPC\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #73955 (deny(unsafe_op_in_unsafe_fn) in libstd/process.rs)\n - #75146 (Detect overflow in proc_macro_server subspan)\n - #75304 (Note when a a move/borrow error is caused by a deref coercion)\n - #75749 (Consolidate some duplicate code in the sys modules.)\n - #75882 (Use translated variable for test string)\n - #75886 (Test that bounds checks are elided for [..index] after .position())\n - #76048 (Initial support for riscv32gc_unknown_linux_gnu)\n - #76198 (Make some Ordering methods const)\n - #76689 (Upgrade to pulldown-cmark 0.8.0)\n - #76763 (Update cargo)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "187b836dc0d60f2fe5cecd273a99ca0ba306a073", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/187b836dc0d60f2fe5cecd273a99ca0ba306a073"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "html_url": "https://github.com/rust-lang/rust/commit/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f04c9065764e56c91cbe567f78d2b207f546ba7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f04c9065764e56c91cbe567f78d2b207f546ba7", "html_url": "https://github.com/rust-lang/rust/commit/9f04c9065764e56c91cbe567f78d2b207f546ba7"}, {"sha": "2e1f0121e8bf138789fd41ae13ede9450cf373f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e1f0121e8bf138789fd41ae13ede9450cf373f3", "html_url": "https://github.com/rust-lang/rust/commit/2e1f0121e8bf138789fd41ae13ede9450cf373f3"}], "stats": {"total": 1537, "additions": 564, "deletions": 973}, "files": [{"sha": "d3f777bc663ddd250b9d13cf6f2ea5d0bbf33a0c", "filename": "Cargo.lock", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -534,7 +534,7 @@ dependencies = [\n  \"if_chain\",\n  \"itertools 0.9.0\",\n  \"lazy_static\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.7.2\",\n  \"quine-mc_cluskey\",\n  \"quote\",\n  \"regex-syntax\",\n@@ -1853,7 +1853,7 @@ dependencies = [\n  \"log\",\n  \"memchr\",\n  \"open\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.7.2\",\n  \"regex\",\n  \"serde\",\n  \"serde_derive\",\n@@ -2511,6 +2511,17 @@ dependencies = [\n  \"unicase\",\n ]\n \n+[[package]]\n+name = \"pulldown-cmark\"\n+version = \"0.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ffade02495f22453cd593159ea2f59827aae7f53fa8323f756799b670881dcf8\"\n+dependencies = [\n+ \"bitflags\",\n+ \"memchr\",\n+ \"unicase\",\n+]\n+\n [[package]]\n name = \"punycode\"\n version = \"0.4.1\"\n@@ -4122,7 +4133,7 @@ dependencies = [\n  \"expect-test\",\n  \"itertools 0.9.0\",\n  \"minifier\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.8.0\",\n  \"rustc-rayon\",\n  \"serde\",\n  \"serde_json\","}, {"sha": "4cfb188783ba110c42165132188d698c3a535152", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -584,12 +584,12 @@ impl server::Literal for Rustc<'_> {\n \n         let start = match start {\n             Bound::Included(lo) => lo,\n-            Bound::Excluded(lo) => lo + 1,\n+            Bound::Excluded(lo) => lo.checked_add(1)?,\n             Bound::Unbounded => 0,\n         };\n \n         let end = match end {\n-            Bound::Included(hi) => hi + 1,\n+            Bound::Included(hi) => hi.checked_add(1)?,\n             Bound::Excluded(hi) => hi,\n             Bound::Unbounded => length,\n         };"}, {"sha": "46ef5ff7dd8c5c97e71278b3df39e44040ef2716", "filename": "compiler/rustc_middle/src/ty/adjustment.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -4,6 +4,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_macros::HashStable;\n+use rustc_span::Span;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum PointerCast {\n@@ -113,6 +114,9 @@ pub enum Adjust<'tcx> {\n pub struct OverloadedDeref<'tcx> {\n     pub region: ty::Region<'tcx>,\n     pub mutbl: hir::Mutability,\n+    /// The `Span` associated with the field access or method call\n+    /// that triggered this overloaded deref.\n+    pub span: Span,\n }\n \n impl<'tcx> OverloadedDeref<'tcx> {"}, {"sha": "6d9d23836fc69d920284317bde8689d07d6f887f", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -612,8 +612,11 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n     type Lifted = ty::adjustment::OverloadedDeref<'tcx>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.region)\n-            .map(|region| ty::adjustment::OverloadedDeref { region, mutbl: self.mutbl })\n+        tcx.lift(&self.region).map(|region| ty::adjustment::OverloadedDeref {\n+            region,\n+            mutbl: self.mutbl,\n+            span: self.span,\n+        })\n     }\n }\n "}, {"sha": "11122b195c0c4bf2c7fe4173688afe12753fd3b5", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -66,7 +66,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let span = use_spans.args_or_use();\n \n         let move_site_vec = self.get_moved_indexes(location, mpi);\n-        debug!(\"report_use_of_moved_or_uninitialized: move_site_vec={:?}\", move_site_vec);\n+        debug!(\n+            \"report_use_of_moved_or_uninitialized: move_site_vec={:?} use_spans={:?}\",\n+            move_site_vec, use_spans\n+        );\n         let move_out_indices: Vec<_> =\n             move_site_vec.iter().map(|move_site| move_site.moi).collect();\n \n@@ -229,6 +232,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     );\n                                 }\n                             }\n+                            // Deref::deref takes &self, which cannot cause a move\n+                            FnSelfUseKind::DerefCoercion { .. } => unreachable!(),\n                         }\n                     } else {\n                         err.span_label(\n@@ -355,6 +360,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.note_type_does_not_implement_copy(&mut err, &note_msg, ty, span, partial_str);\n             }\n \n+            if let UseSpans::FnSelfUse {\n+                kind: FnSelfUseKind::DerefCoercion { deref_target, deref_target_ty },\n+                ..\n+            } = use_spans\n+            {\n+                err.note(&format!(\n+                    \"{} occurs due to deref coercion to `{}`\",\n+                    desired_action.as_noun(),\n+                    deref_target_ty\n+                ));\n+\n+                err.span_note(deref_target, \"deref defined here\");\n+            }\n+\n             if let Some((_, mut old_err)) =\n                 self.move_error_reported.insert(move_out_indices, (used_place, err))\n             {\n@@ -945,7 +964,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         name: &str,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n-        borrow_spans: UseSpans,\n+        borrow_spans: UseSpans<'tcx>,\n         explanation: BorrowExplanation,\n     ) -> DiagnosticBuilder<'cx> {\n         debug!(\n@@ -1146,7 +1165,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n-        borrow_spans: UseSpans,\n+        borrow_spans: UseSpans<'tcx>,\n         proper_span: Span,\n         explanation: BorrowExplanation,\n     ) -> DiagnosticBuilder<'cx> {\n@@ -1274,7 +1293,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     fn report_escaping_closure_capture(\n         &mut self,\n-        use_span: UseSpans,\n+        use_span: UseSpans<'tcx>,\n         var_span: Span,\n         fr_name: &RegionName,\n         category: ConstraintCategory,"}, {"sha": "eccb6168229c29f5949ef6f468ff03bd6cfb1175", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -501,7 +501,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn later_use_kind(\n         &self,\n         borrow: &BorrowData<'tcx>,\n-        use_spans: UseSpans,\n+        use_spans: UseSpans<'tcx>,\n         location: Location,\n     ) -> (LaterUseKind, Span) {\n         match use_spans {"}, {"sha": "4256f6e39d5e863234dcefda647b0994c5fc4bc2", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 57, "deletions": 16, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::mir::{\n     PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty::print::Print;\n-use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, Instance, Ty, TyCtxt};\n use rustc_span::{\n     hygiene::{DesugaringKind, ForLoopLoc},\n     symbol::sym,\n@@ -538,7 +538,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n /// The span(s) associated to a use of a place.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub(super) enum UseSpans {\n+pub(super) enum UseSpans<'tcx> {\n     /// The access is caused by capturing a variable for a closure.\n     ClosureUse {\n         /// This is true if the captured variable was from a generator.\n@@ -558,7 +558,7 @@ pub(super) enum UseSpans {\n         fn_call_span: Span,\n         /// The definition span of the method being called\n         fn_span: Span,\n-        kind: FnSelfUseKind,\n+        kind: FnSelfUseKind<'tcx>,\n     },\n     /// This access is caused by a `match` or `if let` pattern.\n     PatUse(Span),\n@@ -567,31 +567,44 @@ pub(super) enum UseSpans {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub(super) enum FnSelfUseKind {\n+pub(super) enum FnSelfUseKind<'tcx> {\n     /// A normal method call of the form `receiver.foo(a, b, c)`\n     Normal { self_arg: Ident, implicit_into_iter: bool },\n     /// A call to `FnOnce::call_once`, desugared from `my_closure(a, b, c)`\n     FnOnceCall,\n     /// A call to an operator trait, desuraged from operator syntax (e.g. `a << b`)\n     Operator { self_arg: Ident },\n+    DerefCoercion {\n+        /// The `Span` of the `Target` associated type\n+        /// in the `Deref` impl we are using.\n+        deref_target: Span,\n+        /// The type `T::Deref` we are dereferencing to\n+        deref_target_ty: Ty<'tcx>,\n+    },\n }\n \n-impl UseSpans {\n+impl UseSpans<'_> {\n     pub(super) fn args_or_use(self) -> Span {\n         match self {\n             UseSpans::ClosureUse { args_span: span, .. }\n             | UseSpans::PatUse(span)\n-            | UseSpans::FnSelfUse { var_span: span, .. }\n             | UseSpans::OtherUse(span) => span,\n+            UseSpans::FnSelfUse {\n+                fn_call_span, kind: FnSelfUseKind::DerefCoercion { .. }, ..\n+            } => fn_call_span,\n+            UseSpans::FnSelfUse { var_span, .. } => var_span,\n         }\n     }\n \n     pub(super) fn var_or_use(self) -> Span {\n         match self {\n             UseSpans::ClosureUse { var_span: span, .. }\n             | UseSpans::PatUse(span)\n-            | UseSpans::FnSelfUse { var_span: span, .. }\n             | UseSpans::OtherUse(span) => span,\n+            UseSpans::FnSelfUse {\n+                fn_call_span, kind: FnSelfUseKind::DerefCoercion { .. }, ..\n+            } => fn_call_span,\n+            UseSpans::FnSelfUse { var_span, .. } => var_span,\n         }\n     }\n \n@@ -754,7 +767,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         moved_place: PlaceRef<'tcx>, // Could also be an upvar.\n         location: Location,\n-    ) -> UseSpans {\n+    ) -> UseSpans<'tcx> {\n         use self::UseSpans::*;\n \n         let stmt = match self.body[location.block].statements.get(location.statement_index) {\n@@ -809,36 +822,64 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             kind: TerminatorKind::Call { fn_span, from_hir_call, .. }, ..\n         }) = &self.body[location.block].terminator\n         {\n-            let method_did = if let Some(method_did) =\n+            let (method_did, method_substs) = if let Some(info) =\n                 crate::util::find_self_call(self.infcx.tcx, &self.body, target_temp, location.block)\n             {\n-                method_did\n+                info\n             } else {\n                 return normal_ret;\n             };\n \n             let tcx = self.infcx.tcx;\n-\n             let parent = tcx.parent(method_did);\n             let is_fn_once = parent == tcx.lang_items().fn_once_trait();\n             let is_operator = !from_hir_call\n                 && parent.map_or(false, |p| tcx.lang_items().group(LangItemGroup::Op).contains(&p));\n+            let is_deref = !from_hir_call && tcx.is_diagnostic_item(sym::deref_method, method_did);\n             let fn_call_span = *fn_span;\n \n             let self_arg = tcx.fn_arg_names(method_did)[0];\n \n+            debug!(\n+                \"terminator = {:?} from_hir_call={:?}\",\n+                self.body[location.block].terminator, from_hir_call\n+            );\n+\n+            // Check for a 'special' use of 'self' -\n+            // an FnOnce call, an operator (e.g. `<<`), or a\n+            // deref coercion.\n             let kind = if is_fn_once {\n-                FnSelfUseKind::FnOnceCall\n+                Some(FnSelfUseKind::FnOnceCall)\n             } else if is_operator {\n-                FnSelfUseKind::Operator { self_arg }\n+                Some(FnSelfUseKind::Operator { self_arg })\n+            } else if is_deref {\n+                let deref_target =\n+                    tcx.get_diagnostic_item(sym::deref_target).and_then(|deref_target| {\n+                        Instance::resolve(tcx, self.param_env, deref_target, method_substs)\n+                            .transpose()\n+                    });\n+                if let Some(Ok(instance)) = deref_target {\n+                    let deref_target_ty = instance.ty(tcx, self.param_env);\n+                    Some(FnSelfUseKind::DerefCoercion {\n+                        deref_target: tcx.def_span(instance.def_id()),\n+                        deref_target_ty,\n+                    })\n+                } else {\n+                    None\n+                }\n             } else {\n+                None\n+            };\n+\n+            let kind = kind.unwrap_or_else(|| {\n+                // This isn't a 'special' use of `self`\n                 debug!(\"move_spans: method_did={:?}, fn_call_span={:?}\", method_did, fn_call_span);\n                 let implicit_into_iter = matches!(\n                     fn_call_span.desugaring_kind(),\n                     Some(DesugaringKind::ForLoop(ForLoopLoc::IntoIter))\n                 );\n                 FnSelfUseKind::Normal { self_arg, implicit_into_iter }\n-            };\n+            });\n \n             return FnSelfUse {\n                 var_span: stmt.source_info.span,\n@@ -859,7 +900,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// and its usage of the local assigned at `location`.\n     /// This is done by searching in statements succeeding `location`\n     /// and originating from `maybe_closure_span`.\n-    pub(super) fn borrow_spans(&self, use_span: Span, location: Location) -> UseSpans {\n+    pub(super) fn borrow_spans(&self, use_span: Span, location: Location) -> UseSpans<'tcx> {\n         use self::UseSpans::*;\n         debug!(\"borrow_spans: use_span={:?} location={:?}\", use_span, location);\n \n@@ -963,7 +1004,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Helper to retrieve span(s) of given borrow from the current MIR\n     /// representation\n-    pub(super) fn retrieve_borrow_spans(&self, borrow: &BorrowData<'_>) -> UseSpans {\n+    pub(super) fn retrieve_borrow_spans(&self, borrow: &BorrowData<'_>) -> UseSpans<'tcx> {\n         let span = self.body.source_info(borrow.reserve_location).span;\n         self.borrow_spans(span, borrow.reserve_location)\n     }"}, {"sha": "e256fb55b124b70a2d3eec66140982b394056a05", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -47,7 +47,7 @@ enum GroupedMoveError<'tcx> {\n     // Everything that isn't from pattern matching.\n     OtherIllegalMove {\n         original_path: Place<'tcx>,\n-        use_spans: UseSpans,\n+        use_spans: UseSpans<'tcx>,\n         kind: IllegalMoveOriginKind<'tcx>,\n     },\n }\n@@ -222,7 +222,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let (mut err, err_span) = {\n             let (span, use_spans, original_path, kind): (\n                 Span,\n-                Option<UseSpans>,\n+                Option<UseSpans<'tcx>>,\n                 Place<'tcx>,\n                 &IllegalMoveOriginKind<'_>,\n             ) = match error {\n@@ -291,7 +291,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         move_place: Place<'tcx>,\n         deref_target_place: Place<'tcx>,\n         span: Span,\n-        use_spans: Option<UseSpans>,\n+        use_spans: Option<UseSpans<'tcx>>,\n     ) -> DiagnosticBuilder<'a> {\n         // Inspect the type of the content behind the\n         // borrow to provide feedback about why this"}, {"sha": "64ad0627720aa0286b26af7ab2a6bccfb4269ba4", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind\n use rustc_middle::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, InstanceDef, RegionVid, TyCtxt};\n+use rustc_middle::ty::{self, InstanceDef, ParamEnv, RegionVid, TyCtxt};\n use rustc_session::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT, UNUSED_MUT};\n use rustc_span::{Span, Symbol, DUMMY_SP};\n \n@@ -287,6 +287,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         if let Err((move_data, move_errors)) = move_data_results {\n             let mut promoted_mbcx = MirBorrowckCtxt {\n                 infcx,\n+                param_env,\n                 body: promoted_body,\n                 mir_def_id: def.did,\n                 move_data: &move_data,\n@@ -320,6 +321,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let mut mbcx = MirBorrowckCtxt {\n         infcx,\n+        param_env,\n         body,\n         mir_def_id: def.did,\n         move_data: &mdpe.move_data,\n@@ -473,6 +475,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     crate infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     body: &'cx Body<'tcx>,\n     mir_def_id: LocalDefId,\n     move_data: &'cx MoveData<'tcx>,"}, {"sha": "70c1aed0957f8554279a33ca93924c8c1f7c800f", "filename": "compiler/rustc_mir/src/transform/check_const_item_mutation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ConstMutationChecker<'a, 'tcx> {\n                         .note(\"each usage of a `const` item creates a new temporary\")\n                         .note(\"the mutable reference will refer to this temporary, not the original `const` item\");\n \n-                    if let Some(method_did) = method_did {\n+                    if let Some((method_did, _substs)) = method_did {\n                         lint.span_note(self.tcx.def_span(method_did), \"mutable reference created due to call to this method\");\n                     }\n "}, {"sha": "5b146eeb87c044956846f6f5c4a33e7e9ad1a5cc", "filename": "compiler/rustc_mir/src/util/find_self_call.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_mir%2Fsrc%2Futil%2Ffind_self_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_mir%2Fsrc%2Futil%2Ffind_self_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Ffind_self_call.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -1,30 +1,31 @@\n use rustc_middle::mir::*;\n+use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::def_id::DefId;\n \n /// Checks if the specified `local` is used as the `self` prameter of a method call\n /// in the provided `BasicBlock`. If it is, then the `DefId` of the called method is\n /// returned.\n-pub fn find_self_call(\n-    tcx: TyCtxt<'_>,\n-    body: &Body<'_>,\n+pub fn find_self_call<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n     local: Local,\n     block: BasicBlock,\n-) -> Option<DefId> {\n+) -> Option<(DefId, SubstsRef<'tcx>)> {\n     debug!(\"find_self_call(local={:?}): terminator={:?}\", local, &body[block].terminator);\n     if let Some(Terminator { kind: TerminatorKind::Call { func, args, .. }, .. }) =\n         &body[block].terminator\n     {\n         debug!(\"find_self_call: func={:?}\", func);\n         if let Operand::Constant(box Constant { literal: ty::Const { ty, .. }, .. }) = func {\n-            if let ty::FnDef(def_id, _) = *ty.kind() {\n+            if let ty::FnDef(def_id, substs) = *ty.kind() {\n                 if let Some(ty::AssocItem { fn_has_self_parameter: true, .. }) =\n                     tcx.opt_associated_item(def_id)\n                 {\n                     debug!(\"find_self_call: args={:?}\", args);\n                     if let [Operand::Move(self_place) | Operand::Copy(self_place), ..] = **args {\n                         if self_place.as_local() == Some(local) {\n-                            return Some(def_id);\n+                            return Some((def_id, substs));\n                         }\n                     }\n                 }"}, {"sha": "13e69474cfb965b706f45ff1d4ce092803a8b2f1", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -117,7 +117,14 @@ fn apply_adjustment<'a, 'tcx>(\n                 },\n             };\n \n-            overloaded_place(cx, hir_expr, adjustment.target, Some(call), vec![expr.to_ref()])\n+            overloaded_place(\n+                cx,\n+                hir_expr,\n+                adjustment.target,\n+                Some(call),\n+                vec![expr.to_ref()],\n+                deref.span,\n+            )\n         }\n         Adjust::Borrow(AutoBorrow::Ref(_, m)) => {\n             ExprKind::Borrow { borrow_kind: m.to_borrow_kind(), arg: expr.to_ref() }\n@@ -277,15 +284,22 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n \n         hir::ExprKind::Index(ref lhs, ref index) => {\n             if cx.typeck_results().is_method_call(expr) {\n-                overloaded_place(cx, expr, expr_ty, None, vec![lhs.to_ref(), index.to_ref()])\n+                overloaded_place(\n+                    cx,\n+                    expr,\n+                    expr_ty,\n+                    None,\n+                    vec![lhs.to_ref(), index.to_ref()],\n+                    expr.span,\n+                )\n             } else {\n                 ExprKind::Index { lhs: lhs.to_ref(), index: index.to_ref() }\n             }\n         }\n \n         hir::ExprKind::Unary(hir::UnOp::UnDeref, ref arg) => {\n             if cx.typeck_results().is_method_call(expr) {\n-                overloaded_place(cx, expr, expr_ty, None, vec![arg.to_ref()])\n+                overloaded_place(cx, expr, expr_ty, None, vec![arg.to_ref()], expr.span)\n             } else {\n                 ExprKind::Deref { arg: arg.to_ref() }\n             }\n@@ -1025,6 +1039,7 @@ fn overloaded_place<'a, 'tcx>(\n     place_ty: Ty<'tcx>,\n     overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n     args: Vec<ExprRef<'tcx>>,\n+    span: Span,\n ) -> ExprKind<'tcx> {\n     // For an overloaded *x or x[y] expression of type T, the method\n     // call returns an &T and we must add the deref so that the types\n@@ -1040,24 +1055,24 @@ fn overloaded_place<'a, 'tcx>(\n     // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n     let (region, mutbl) = match *recv_ty.kind() {\n         ty::Ref(region, _, mutbl) => (region, mutbl),\n-        _ => span_bug!(expr.span, \"overloaded_place: receiver is not a reference\"),\n+        _ => span_bug!(span, \"overloaded_place: receiver is not a reference\"),\n     };\n     let ref_ty = cx.tcx.mk_ref(region, ty::TypeAndMut { ty: place_ty, mutbl });\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-    let fun = method_callee(cx, expr, expr.span, overloaded_callee);\n+    let fun = method_callee(cx, expr, span, overloaded_callee);\n     let ref_expr = Expr {\n         temp_lifetime,\n         ty: ref_ty,\n-        span: expr.span,\n+        span,\n         kind: ExprKind::Call {\n             ty: fun.ty,\n             fun: fun.to_ref(),\n             args,\n             from_hir_call: false,\n-            fn_span: expr.span,\n+            fn_span: span,\n         },\n     };\n "}, {"sha": "94f795b11ea4d3047b72efdb3d93c8eec1c8a46f", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -416,7 +416,9 @@ symbols! {\n         deny,\n         deprecated,\n         deref,\n+        deref_method,\n         deref_mut,\n+        deref_target,\n         derive,\n         diagnostic,\n         direct,"}, {"sha": "f1e8330425e25c099c5e3669e6c64dfa57045939", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -654,6 +654,7 @@ supported_targets! {\n     (\"riscv32i-unknown-none-elf\", riscv32i_unknown_none_elf),\n     (\"riscv32imc-unknown-none-elf\", riscv32imc_unknown_none_elf),\n     (\"riscv32imac-unknown-none-elf\", riscv32imac_unknown_none_elf),\n+    (\"riscv32gc-unknown-linux-gnu\", riscv32gc_unknown_linux_gnu),\n     (\"riscv64imac-unknown-none-elf\", riscv64imac_unknown_none_elf),\n     (\"riscv64gc-unknown-none-elf\", riscv64gc_unknown_none_elf),\n     (\"riscv64gc-unknown-linux-gnu\", riscv64gc_unknown_linux_gnu),"}, {"sha": "28710c60175b0ab479e9f628db6f43e04ac56701", "filename": "compiler/rustc_target/src/spec/riscv32gc_unknown_linux_gnu.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv32gc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv32gc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv32gc_unknown_linux_gnu.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -0,0 +1,25 @@\n+use crate::spec::{CodeModel, LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n+        llvm_target: \"riscv32-unknown-linux-gnu\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-n32-S128\".to_string(),\n+        arch: \"riscv32\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            unsupported_abis: super::riscv_base::unsupported_abis(),\n+            code_model: Some(CodeModel::Medium),\n+            cpu: \"generic-rv32\".to_string(),\n+            features: \"+m,+a,+f,+d,+c\".to_string(),\n+            llvm_abiname: \"ilp32d\".to_string(),\n+            max_atomic_width: Some(32),\n+            ..super::linux_base::opts()\n+        },\n+    })\n+}"}, {"sha": "b9c5123e49a0ea3b35f3aa7c18e260647cce8f96", "filename": "compiler/rustc_trait_selection/src/autoderef.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -27,6 +27,7 @@ pub struct Autoderef<'a, 'tcx> {\n     // Meta infos:\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     span: Span,\n+    overloaded_span: Span,\n     body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n \n@@ -98,10 +99,12 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n         body_id: hir::HirId,\n         span: Span,\n         base_ty: Ty<'tcx>,\n+        overloaded_span: Span,\n     ) -> Autoderef<'a, 'tcx> {\n         Autoderef {\n             infcx,\n             span,\n+            overloaded_span,\n             body_id,\n             param_env,\n             state: AutoderefSnapshot {\n@@ -190,6 +193,10 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n         self.span\n     }\n \n+    pub fn overloaded_span(&self) -> Span {\n+        self.overloaded_span\n+    }\n+\n     pub fn reached_recursion_limit(&self) -> bool {\n         self.state.reached_recursion_limit\n     }"}, {"sha": "90a8d9634ae1e183907226e7831c6bf12ec9a3ba", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -483,7 +483,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n \n         if let ty::Ref(region, base_ty, mutbl) = *real_ty.kind() {\n-            let mut autoderef = Autoderef::new(self, param_env, body_id, span, base_ty);\n+            let mut autoderef = Autoderef::new(self, param_env, body_id, span, base_ty, span);\n             if let Some(steps) = autoderef.find_map(|(ty, steps)| {\n                 // Re-add the `&`\n                 let ty = self.tcx.mk_ref(region, TypeAndMut { ty, mutbl });"}, {"sha": "59c366ad7d776cb41868bc18140e042f70ccab60", "filename": "compiler/rustc_typeck/src/check/autoderef.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fautoderef.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -12,7 +12,18 @@ use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'tcx> {\n-        Autoderef::new(self, self.param_env, self.body_id, span, base_ty)\n+        Autoderef::new(self, self.param_env, self.body_id, span, base_ty, span)\n+    }\n+\n+    /// Like `autoderef`, but provides a custom `Span` to use for calls to\n+    /// an overloaded `Deref` operator\n+    pub fn autoderef_overloaded_span(\n+        &'a self,\n+        span: Span,\n+        base_ty: Ty<'tcx>,\n+        overloaded_span: Span,\n+    ) -> Autoderef<'a, 'tcx> {\n+        Autoderef::new(self, self.param_env, self.body_id, span, base_ty, overloaded_span)\n     }\n \n     pub fn try_overloaded_deref(\n@@ -44,7 +55,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         |InferOk { value: method, obligations: o }| {\n                             obligations.extend(o);\n                             if let ty::Ref(region, _, mutbl) = *method.sig.output().kind() {\n-                                Some(OverloadedDeref { region, mutbl })\n+                                Some(OverloadedDeref {\n+                                    region,\n+                                    mutbl,\n+                                    span: autoderef.overloaded_span(),\n+                                })\n                             } else {\n                                 None\n                             }"}, {"sha": "fd2700b85e2790a7721e523f4e0a272880babb21", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -137,7 +137,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         // Commit the autoderefs by calling `autoderef` again, but this\n         // time writing the results into the various typeck results.\n-        let mut autoderef = self.autoderef(self.span, unadjusted_self_ty);\n+        let mut autoderef =\n+            self.autoderef_overloaded_span(self.span, unadjusted_self_ty, self.call_expr.span);\n         let (_, n) = match autoderef.nth(pick.autoderefs) {\n             Some(n) => n,\n             None => {"}, {"sha": "8a62031ec887caed2885f04f843ec053dfcc8701", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -446,9 +446,10 @@ fn method_autoderef_steps<'tcx>(\n     tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, &goal, |ref infcx, goal, inference_vars| {\n         let ParamEnvAnd { param_env, value: self_ty } = goal;\n \n-        let mut autoderef = Autoderef::new(infcx, param_env, hir::CRATE_HIR_ID, DUMMY_SP, self_ty)\n-            .include_raw_pointers()\n-            .silence_errors();\n+        let mut autoderef =\n+            Autoderef::new(infcx, param_env, hir::CRATE_HIR_ID, DUMMY_SP, self_ty, DUMMY_SP)\n+                .include_raw_pointers()\n+                .silence_errors();\n         let mut reached_raw_pointer = false;\n         let mut steps: Vec<_> = autoderef\n             .by_ref()"}, {"sha": "502cb562385e0de9432f10d4ab88b95ff4e51955", "filename": "compiler/rustc_typeck/src/check/place_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -242,7 +242,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ) {\n                             let method = self.register_infer_ok_obligations(ok);\n                             if let ty::Ref(region, _, mutbl) = *method.sig.output().kind() {\n-                                *deref = OverloadedDeref { region, mutbl };\n+                                *deref = OverloadedDeref { region, mutbl, span: deref.span };\n                             }\n                             // If this is a union field, also throw an error for `DerefMut` of `ManuallyDrop` (see RFC 2514).\n                             // This helps avoid accidental drops."}, {"sha": "03737e1ef1f4dcd4d8be3439edffbd365ea8741f", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -15,6 +15,7 @@\n #![feature(slice_ptr_get)]\n #![feature(split_inclusive)]\n #![feature(binary_heap_retain)]\n+#![feature(deque_range)]\n #![feature(inplace_iteration)]\n #![feature(iter_map_while)]\n "}, {"sha": "4e6043541226f77310e96628c9b23a7a5026354e", "filename": "library/alloc/tests/string.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Falloc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Falloc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstring.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -1,6 +1,7 @@\n use std::borrow::Cow;\n use std::collections::TryReserveError::*;\n use std::mem::size_of;\n+use std::ops::Bound::*;\n \n pub trait IntoCow<'a, B: ?Sized>\n where\n@@ -271,8 +272,8 @@ fn test_split_off_past_end() {\n #[test]\n #[should_panic]\n fn test_split_off_mid_char() {\n-    let mut orig = String::from(\"\u5c71\");\n-    let _ = orig.split_off(1);\n+    let mut shan = String::from(\"\u5c71\");\n+    let _broken_mountain = shan.split_off(1);\n }\n \n #[test]\n@@ -467,6 +468,20 @@ fn test_drain() {\n     assert_eq!(t, \"\");\n }\n \n+#[test]\n+#[should_panic]\n+fn test_drain_start_overflow() {\n+    let mut s = String::from(\"abc\");\n+    s.drain((Excluded(usize::MAX), Included(0)));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_drain_end_overflow() {\n+    let mut s = String::from(\"abc\");\n+    s.drain((Included(0), Included(usize::MAX)));\n+}\n+\n #[test]\n fn test_replace_range() {\n     let mut s = \"Hello, world!\".to_owned();\n@@ -504,6 +519,20 @@ fn test_replace_range_inclusive_out_of_bounds() {\n     s.replace_range(5..=5, \"789\");\n }\n \n+#[test]\n+#[should_panic]\n+fn test_replace_range_start_overflow() {\n+    let mut s = String::from(\"123\");\n+    s.replace_range((Excluded(usize::MAX), Included(0)), \"\");\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_replace_range_end_overflow() {\n+    let mut s = String::from(\"456\");\n+    s.replace_range((Included(0), Included(usize::MAX)), \"\");\n+}\n+\n #[test]\n fn test_replace_range_empty() {\n     let mut s = String::from(\"12345\");"}, {"sha": "563dd7ab6457d58fe014299317a2590e5c4580a0", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -3,6 +3,7 @@ use std::collections::TryReserveError::*;\n use std::fmt::Debug;\n use std::iter::InPlaceIterable;\n use std::mem::size_of;\n+use std::ops::Bound::*;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::rc::Rc;\n use std::vec::{Drain, IntoIter};\n@@ -645,13 +646,37 @@ fn test_drain_max_vec_size() {\n     assert_eq!(v.len(), usize::MAX - 1);\n }\n \n+#[test]\n+#[should_panic]\n+fn test_drain_index_overflow() {\n+    let mut v = Vec::<()>::with_capacity(usize::MAX);\n+    unsafe {\n+        v.set_len(usize::MAX);\n+    }\n+    v.drain(0..=usize::MAX);\n+}\n+\n #[test]\n #[should_panic]\n fn test_drain_inclusive_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     v.drain(5..=5);\n }\n \n+#[test]\n+#[should_panic]\n+fn test_drain_start_overflow() {\n+    let mut v = vec![1, 2, 3];\n+    v.drain((Excluded(usize::MAX), Included(0)));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_drain_end_overflow() {\n+    let mut v = vec![1, 2, 3];\n+    v.drain((Included(0), Included(usize::MAX)));\n+}\n+\n #[test]\n fn test_drain_leak() {\n     static mut DROPS: i32 = 0;"}, {"sha": "46d8a3c4cb4931126d578fd51d675e3f8758ff79", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -2,6 +2,7 @@ use std::collections::TryReserveError::*;\n use std::collections::{vec_deque::Drain, VecDeque};\n use std::fmt::Debug;\n use std::mem::size_of;\n+use std::ops::Bound::*;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n use crate::hash;\n@@ -115,6 +116,20 @@ fn test_index_out_of_bounds() {\n     deq[3];\n }\n \n+#[test]\n+#[should_panic]\n+fn test_range_start_overflow() {\n+    let deq = VecDeque::from(vec![1, 2, 3]);\n+    deq.range((Included(0), Included(usize::MAX)));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_range_end_overflow() {\n+    let deq = VecDeque::from(vec![1, 2, 3]);\n+    deq.range((Excluded(usize::MAX), Included(0)));\n+}\n+\n #[derive(Clone, PartialEq, Debug)]\n enum Taggy {\n     One(i32),"}, {"sha": "dde442aa7b52de84c2a3810c6627c70fb99f6295", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -356,8 +356,9 @@ impl Ordering {\n     /// ```\n     #[inline]\n     #[must_use]\n+    #[rustc_const_stable(feature = \"const_ordering\", since = \"1.48.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reverse(self) -> Ordering {\n+    pub const fn reverse(self) -> Ordering {\n         match self {\n             Less => Greater,\n             Equal => Equal,\n@@ -394,8 +395,9 @@ impl Ordering {\n     /// ```\n     #[inline]\n     #[must_use]\n+    #[rustc_const_stable(feature = \"const_ordering\", since = \"1.48.0\")]\n     #[stable(feature = \"ordering_chaining\", since = \"1.17.0\")]\n-    pub fn then(self, other: Ordering) -> Ordering {\n+    pub const fn then(self, other: Ordering) -> Ordering {\n         match self {\n             Equal => other,\n             _ => self,"}, {"sha": "245152e5490d8c5e87c35f1479463985d428cce4", "filename": "library/core/src/ops/deref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fderef.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -63,11 +63,13 @@\n pub trait Deref {\n     /// The resulting type after dereferencing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_diagnostic_item = \"deref_target\"]\n     type Target: ?Sized;\n \n     /// Dereferences the value.\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_diagnostic_item = \"deref_method\"]\n     fn deref(&self) -> &Self::Target;\n }\n "}, {"sha": "835289daf715adf936723f10b62f145248491640", "filename": "library/core/tests/cmp.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fcore%2Ftests%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fcore%2Ftests%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fcmp.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -1,4 +1,7 @@\n-use core::cmp::{self, Ordering::*};\n+use core::cmp::{\n+    self,\n+    Ordering::{self, *},\n+};\n \n #[test]\n fn test_int_totalord() {\n@@ -116,3 +119,16 @@ fn test_user_defined_eq() {\n     assert!(SketchyNum { num: 37 } == SketchyNum { num: 34 });\n     assert!(SketchyNum { num: 25 } != SketchyNum { num: 57 });\n }\n+\n+#[test]\n+fn ordering_const() {\n+    // test that the methods of `Ordering` are usable in a const context\n+\n+    const ORDERING: Ordering = Greater;\n+\n+    const REVERSE: Ordering = ORDERING.reverse();\n+    assert_eq!(REVERSE, Less);\n+\n+    const THEN: Ordering = Equal.then(ORDERING);\n+    assert_eq!(THEN, Greater);\n+}"}, {"sha": "00e2dbc9c1dbf33e5d3c7c94c36edf4b6635f762", "filename": "library/std/src/process.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -95,6 +95,7 @@\n //! [`Read`]: io::Read\n \n #![stable(feature = \"process\", since = \"1.0.0\")]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n #[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\", target_env = \"sgx\"))))]\n mod tests;\n@@ -321,7 +322,8 @@ impl Read for ChildStdout {\n \n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n+        // SAFETY: Read is guaranteed to work on uninitialized memory\n+        unsafe { Initializer::nop() }\n     }\n }\n \n@@ -381,7 +383,8 @@ impl Read for ChildStderr {\n \n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n+        // SAFETY: Read is guaranteed to work on uninitialized memory\n+        unsafe { Initializer::nop() }\n     }\n }\n "}, {"sha": "ecb5b51cccdcd965d85e9ee8e22ecb878d876719", "filename": "library/std/src/sys/sgx/fs.rs", "status": "removed", "additions": 0, "deletions": 308, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ffs.rs?ref=9f04c9065764e56c91cbe567f78d2b207f546ba7", "patch": "@@ -1,308 +0,0 @@\n-use crate::ffi::OsString;\n-use crate::fmt;\n-use crate::hash::{Hash, Hasher};\n-use crate::io::{self, IoSlice, IoSliceMut, SeekFrom};\n-use crate::path::{Path, PathBuf};\n-use crate::sys::time::SystemTime;\n-use crate::sys::{unsupported, Void};\n-\n-pub struct File(Void);\n-\n-pub struct FileAttr(Void);\n-\n-pub struct ReadDir(Void);\n-\n-pub struct DirEntry(Void);\n-\n-#[derive(Clone, Debug)]\n-pub struct OpenOptions {}\n-\n-pub struct FilePermissions(Void);\n-\n-pub struct FileType(Void);\n-\n-#[derive(Debug)]\n-pub struct DirBuilder {}\n-\n-impl FileAttr {\n-    pub fn size(&self) -> u64 {\n-        match self.0 {}\n-    }\n-\n-    pub fn perm(&self) -> FilePermissions {\n-        match self.0 {}\n-    }\n-\n-    pub fn file_type(&self) -> FileType {\n-        match self.0 {}\n-    }\n-\n-    pub fn modified(&self) -> io::Result<SystemTime> {\n-        match self.0 {}\n-    }\n-\n-    pub fn accessed(&self) -> io::Result<SystemTime> {\n-        match self.0 {}\n-    }\n-\n-    pub fn created(&self) -> io::Result<SystemTime> {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Clone for FileAttr {\n-    fn clone(&self) -> FileAttr {\n-        match self.0 {}\n-    }\n-}\n-\n-impl FilePermissions {\n-    pub fn readonly(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn set_readonly(&mut self, _readonly: bool) {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Clone for FilePermissions {\n-    fn clone(&self) -> FilePermissions {\n-        match self.0 {}\n-    }\n-}\n-\n-impl PartialEq for FilePermissions {\n-    fn eq(&self, _other: &FilePermissions) -> bool {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Eq for FilePermissions {}\n-\n-impl fmt::Debug for FilePermissions {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-impl FileType {\n-    pub fn is_dir(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_file(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_symlink(&self) -> bool {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Clone for FileType {\n-    fn clone(&self) -> FileType {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Copy for FileType {}\n-\n-impl PartialEq for FileType {\n-    fn eq(&self, _other: &FileType) -> bool {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Eq for FileType {}\n-\n-impl Hash for FileType {\n-    fn hash<H: Hasher>(&self, _h: &mut H) {\n-        match self.0 {}\n-    }\n-}\n-\n-impl fmt::Debug for FileType {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-impl fmt::Debug for ReadDir {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Iterator for ReadDir {\n-    type Item = io::Result<DirEntry>;\n-\n-    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n-        match self.0 {}\n-    }\n-}\n-\n-impl DirEntry {\n-    pub fn path(&self) -> PathBuf {\n-        match self.0 {}\n-    }\n-\n-    pub fn file_name(&self) -> OsString {\n-        match self.0 {}\n-    }\n-\n-    pub fn metadata(&self) -> io::Result<FileAttr> {\n-        match self.0 {}\n-    }\n-\n-    pub fn file_type(&self) -> io::Result<FileType> {\n-        match self.0 {}\n-    }\n-}\n-\n-impl OpenOptions {\n-    pub fn new() -> OpenOptions {\n-        OpenOptions {}\n-    }\n-\n-    pub fn read(&mut self, _read: bool) {}\n-    pub fn write(&mut self, _write: bool) {}\n-    pub fn append(&mut self, _append: bool) {}\n-    pub fn truncate(&mut self, _truncate: bool) {}\n-    pub fn create(&mut self, _create: bool) {}\n-    pub fn create_new(&mut self, _create_new: bool) {}\n-}\n-\n-impl File {\n-    pub fn open(_path: &Path, _opts: &OpenOptions) -> io::Result<File> {\n-        unsupported()\n-    }\n-\n-    pub fn file_attr(&self) -> io::Result<FileAttr> {\n-        match self.0 {}\n-    }\n-\n-    pub fn fsync(&self) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn datasync(&self) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn truncate(&self, _size: u64) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_read_vectored(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_write_vectored(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn flush(&self) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {\n-        match self.0 {}\n-    }\n-\n-    pub fn duplicate(&self) -> io::Result<File> {\n-        match self.0 {}\n-    }\n-\n-    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn diverge(&self) -> ! {\n-        match self.0 {}\n-    }\n-}\n-\n-impl DirBuilder {\n-    pub fn new() -> DirBuilder {\n-        DirBuilder {}\n-    }\n-\n-    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {\n-        unsupported()\n-    }\n-}\n-\n-impl fmt::Debug for File {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-pub fn readdir(_p: &Path) -> io::Result<ReadDir> {\n-    unsupported()\n-}\n-\n-pub fn unlink(_p: &Path) -> io::Result<()> {\n-    unsupported()\n-}\n-\n-pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n-    unsupported()\n-}\n-\n-pub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> {\n-    match perm.0 {}\n-}\n-\n-pub fn rmdir(_p: &Path) -> io::Result<()> {\n-    unsupported()\n-}\n-\n-pub fn remove_dir_all(_path: &Path) -> io::Result<()> {\n-    unsupported()\n-}\n-\n-pub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n-    unsupported()\n-}\n-\n-pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n-    unsupported()\n-}\n-\n-pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n-    unsupported()\n-}\n-\n-pub fn stat(_p: &Path) -> io::Result<FileAttr> {\n-    unsupported()\n-}\n-\n-pub fn lstat(_p: &Path) -> io::Result<FileAttr> {\n-    unsupported()\n-}\n-\n-pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n-    unsupported()\n-}\n-\n-pub fn copy(_from: &Path, _to: &Path) -> io::Result<u64> {\n-    unsupported()\n-}"}, {"sha": "d5f475b4310fde64b7f0f50154c14d345ce3788f", "filename": "library/std/src/sys/sgx/io.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fio.rs?ref=9f04c9065764e56c91cbe567f78d2b207f546ba7", "patch": "@@ -1,47 +0,0 @@\n-use crate::mem;\n-\n-#[derive(Copy, Clone)]\n-pub struct IoSlice<'a>(&'a [u8]);\n-\n-impl<'a> IoSlice<'a> {\n-    #[inline]\n-    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n-        IoSlice(buf)\n-    }\n-\n-    #[inline]\n-    pub fn advance(&mut self, n: usize) {\n-        self.0 = &self.0[n..]\n-    }\n-\n-    #[inline]\n-    pub fn as_slice(&self) -> &[u8] {\n-        self.0\n-    }\n-}\n-\n-pub struct IoSliceMut<'a>(&'a mut [u8]);\n-\n-impl<'a> IoSliceMut<'a> {\n-    #[inline]\n-    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n-        IoSliceMut(buf)\n-    }\n-\n-    #[inline]\n-    pub fn advance(&mut self, n: usize) {\n-        let slice = mem::replace(&mut self.0, &mut []);\n-        let (_, remaining) = slice.split_at_mut(n);\n-        self.0 = remaining;\n-    }\n-\n-    #[inline]\n-    pub fn as_slice(&self) -> &[u8] {\n-        self.0\n-    }\n-\n-    #[inline]\n-    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n-        self.0\n-    }\n-}"}, {"sha": "1abd91e75e8c40d9e3a472efce09e3e075b01367", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -17,14 +17,18 @@ pub mod condvar;\n pub mod env;\n pub mod ext;\n pub mod fd;\n+#[path = \"../unsupported/fs.rs\"]\n pub mod fs;\n+#[path = \"../unsupported/io.rs\"]\n pub mod io;\n pub mod memchr;\n pub mod mutex;\n pub mod net;\n pub mod os;\n pub mod path;\n+#[path = \"../unsupported/pipe.rs\"]\n pub mod pipe;\n+#[path = \"../unsupported/process.rs\"]\n pub mod process;\n pub mod rwlock;\n pub mod stack_overflow;"}, {"sha": "10d0925823eb94660278ce2390c892c093d7e3c6", "filename": "library/std/src/sys/sgx/pipe.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fpipe.rs?ref=9f04c9065764e56c91cbe567f78d2b207f546ba7", "patch": "@@ -1,38 +0,0 @@\n-use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::sys::Void;\n-\n-pub struct AnonPipe(Void);\n-\n-impl AnonPipe {\n-    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_read_vectored(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_write_vectored(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn diverge(&self) -> ! {\n-        match self.0 {}\n-    }\n-}\n-\n-pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {\n-    match p1.0 {}\n-}"}, {"sha": "4702e5c549228ea27e5c59777cb707b34ea5d248", "filename": "library/std/src/sys/sgx/process.rs", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fprocess.rs?ref=9f04c9065764e56c91cbe567f78d2b207f546ba7", "patch": "@@ -1,149 +0,0 @@\n-use crate::ffi::OsStr;\n-use crate::fmt;\n-use crate::io;\n-use crate::sys::fs::File;\n-use crate::sys::pipe::AnonPipe;\n-use crate::sys::{unsupported, Void};\n-use crate::sys_common::process::CommandEnv;\n-\n-pub use crate::ffi::OsString as EnvKey;\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Command\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct Command {\n-    env: CommandEnv,\n-}\n-\n-// passed back to std::process with the pipes connected to the child, if any\n-// were requested\n-pub struct StdioPipes {\n-    pub stdin: Option<AnonPipe>,\n-    pub stdout: Option<AnonPipe>,\n-    pub stderr: Option<AnonPipe>,\n-}\n-\n-pub enum Stdio {\n-    Inherit,\n-    Null,\n-    MakePipe,\n-}\n-\n-impl Command {\n-    pub fn new(_program: &OsStr) -> Command {\n-        Command { env: Default::default() }\n-    }\n-\n-    pub fn arg(&mut self, _arg: &OsStr) {}\n-\n-    pub fn env_mut(&mut self) -> &mut CommandEnv {\n-        &mut self.env\n-    }\n-\n-    pub fn cwd(&mut self, _dir: &OsStr) {}\n-\n-    pub fn stdin(&mut self, _stdin: Stdio) {}\n-\n-    pub fn stdout(&mut self, _stdout: Stdio) {}\n-\n-    pub fn stderr(&mut self, _stderr: Stdio) {}\n-\n-    pub fn spawn(\n-        &mut self,\n-        _default: Stdio,\n-        _needs_stdin: bool,\n-    ) -> io::Result<(Process, StdioPipes)> {\n-        unsupported()\n-    }\n-}\n-\n-impl From<AnonPipe> for Stdio {\n-    fn from(pipe: AnonPipe) -> Stdio {\n-        pipe.diverge()\n-    }\n-}\n-\n-impl From<File> for Stdio {\n-    fn from(file: File) -> Stdio {\n-        file.diverge()\n-    }\n-}\n-\n-impl fmt::Debug for Command {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Ok(())\n-    }\n-}\n-\n-pub struct ExitStatus(Void);\n-\n-impl ExitStatus {\n-    pub fn success(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn code(&self) -> Option<i32> {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Clone for ExitStatus {\n-    fn clone(&self) -> ExitStatus {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Copy for ExitStatus {}\n-\n-impl PartialEq for ExitStatus {\n-    fn eq(&self, _other: &ExitStatus) -> bool {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Eq for ExitStatus {}\n-\n-impl fmt::Debug for ExitStatus {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-impl fmt::Display for ExitStatus {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitCode(bool);\n-\n-impl ExitCode {\n-    pub const SUCCESS: ExitCode = ExitCode(false);\n-    pub const FAILURE: ExitCode = ExitCode(true);\n-\n-    pub fn as_i32(&self) -> i32 {\n-        self.0 as i32\n-    }\n-}\n-\n-pub struct Process(Void);\n-\n-impl Process {\n-    pub fn id(&self) -> u32 {\n-        match self.0 {}\n-    }\n-\n-    pub fn kill(&mut self) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n-        match self.0 {}\n-    }\n-\n-    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n-        match self.0 {}\n-    }\n-}"}, {"sha": "964abe8b8c9ea86ffe714811e897110ab488c083", "filename": "library/std/src/sys/unix/alloc.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -52,46 +52,48 @@ unsafe impl GlobalAlloc for System {\n     }\n }\n \n-#[cfg(any(\n-    target_os = \"android\",\n-    target_os = \"illumos\",\n-    target_os = \"redox\",\n-    target_os = \"solaris\"\n-))]\n-#[inline]\n-unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-    // On android we currently target API level 9 which unfortunately\n-    // doesn't have the `posix_memalign` API used below. Instead we use\n-    // `memalign`, but this unfortunately has the property on some systems\n-    // where the memory returned cannot be deallocated by `free`!\n-    //\n-    // Upon closer inspection, however, this appears to work just fine with\n-    // Android, so for this platform we should be fine to call `memalign`\n-    // (which is present in API level 9). Some helpful references could\n-    // possibly be chromium using memalign [1], attempts at documenting that\n-    // memalign + free is ok [2] [3], or the current source of chromium\n-    // which still uses memalign on android [4].\n-    //\n-    // [1]: https://codereview.chromium.org/10796020/\n-    // [2]: https://code.google.com/p/android/issues/detail?id=35391\n-    // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n-    // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n-    //                                       /memory/aligned_memory.cc\n-    libc::memalign(layout.align(), layout.size()) as *mut u8\n-}\n-\n-#[cfg(not(any(\n-    target_os = \"android\",\n-    target_os = \"illumos\",\n-    target_os = \"redox\",\n-    target_os = \"solaris\"\n-)))]\n-#[inline]\n-unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-    let mut out = ptr::null_mut();\n-    // posix_memalign requires that the alignment be a multiple of `sizeof(void*)`.\n-    // Since these are all powers of 2, we can just use max.\n-    let align = layout.align().max(crate::mem::size_of::<usize>());\n-    let ret = libc::posix_memalign(&mut out, align, layout.size());\n-    if ret != 0 { ptr::null_mut() } else { out as *mut u8 }\n+cfg_if::cfg_if! {\n+    if #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"illumos\",\n+        target_os = \"redox\",\n+        target_os = \"solaris\"\n+    ))] {\n+        #[inline]\n+        unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+            // On android we currently target API level 9 which unfortunately\n+            // doesn't have the `posix_memalign` API used below. Instead we use\n+            // `memalign`, but this unfortunately has the property on some systems\n+            // where the memory returned cannot be deallocated by `free`!\n+            //\n+            // Upon closer inspection, however, this appears to work just fine with\n+            // Android, so for this platform we should be fine to call `memalign`\n+            // (which is present in API level 9). Some helpful references could\n+            // possibly be chromium using memalign [1], attempts at documenting that\n+            // memalign + free is ok [2] [3], or the current source of chromium\n+            // which still uses memalign on android [4].\n+            //\n+            // [1]: https://codereview.chromium.org/10796020/\n+            // [2]: https://code.google.com/p/android/issues/detail?id=35391\n+            // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n+            // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n+            //                                       /memory/aligned_memory.cc\n+            libc::memalign(layout.align(), layout.size()) as *mut u8\n+        }\n+    } else if #[cfg(target_os = \"wasi\")] {\n+        #[inline]\n+        unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+            libc::aligned_alloc(layout.align(), layout.size()) as *mut u8\n+        }\n+    } else {\n+        #[inline]\n+        unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+            let mut out = ptr::null_mut();\n+            // posix_memalign requires that the alignment be a multiple of `sizeof(void*)`.\n+            // Since these are all powers of 2, we can just use max.\n+            let align = layout.align().max(crate::mem::size_of::<usize>());\n+            let ret = libc::posix_memalign(&mut out, align, layout.size());\n+            if ret != 0 { ptr::null_mut() } else { out as *mut u8 }\n+        }\n+    }\n }"}, {"sha": "faa53b6a74422ddff884dec7a850c37252798d58", "filename": "library/std/src/sys/unsupported/fs.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ffs.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -233,10 +233,6 @@ impl File {\n     pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n         match self.0 {}\n     }\n-\n-    pub fn diverge(&self) -> ! {\n-        match self.0 {}\n-    }\n }\n \n impl DirBuilder {"}, {"sha": "8ba870c5dbc14cecba6f52158fae1d49a799ea8e", "filename": "library/std/src/sys/unsupported/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fmod.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -8,6 +8,7 @@ pub mod io;\n pub mod mutex;\n pub mod net;\n pub mod os;\n+#[path = \"../unix/path.rs\"]\n pub mod path;\n pub mod pipe;\n pub mod process;"}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "library/std/src/sys/unsupported/path.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fpath.rs?ref=9f04c9065764e56c91cbe567f78d2b207f546ba7", "patch": "@@ -1,19 +0,0 @@\n-use crate::ffi::OsStr;\n-use crate::path::Prefix;\n-\n-#[inline]\n-pub fn is_sep_byte(b: u8) -> bool {\n-    b == b'/'\n-}\n-\n-#[inline]\n-pub fn is_verbatim_sep(b: u8) -> bool {\n-    b == b'/'\n-}\n-\n-pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n-    None\n-}\n-\n-pub const MAIN_SEP_STR: &str = \"/\";\n-pub const MAIN_SEP: char = '/';"}, {"sha": "7156c9ab92f2b6af3da9699a3618f76275280af1", "filename": "library/std/src/sys/unsupported/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fprocess.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -65,8 +65,8 @@ impl From<AnonPipe> for Stdio {\n }\n \n impl From<File> for Stdio {\n-    fn from(file: File) -> Stdio {\n-        file.diverge()\n+    fn from(_file: File) -> Stdio {\n+        panic!(\"unsupported\")\n     }\n }\n "}, {"sha": "4d0afe27bb8b2ed0943676ca253a180b92fae215", "filename": "library/std/src/sys/wasi/alloc.rs", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Falloc.rs?ref=9f04c9065764e56c91cbe567f78d2b207f546ba7", "patch": "@@ -1,69 +0,0 @@\n-#![deny(unsafe_op_in_unsafe_fn)]\n-\n-use crate::alloc::{GlobalAlloc, Layout, System};\n-use crate::ptr;\n-use crate::sys_common::alloc::{realloc_fallback, MIN_ALIGN};\n-\n-// SAFETY: All methods implemented follow the contract rules defined\n-// in `GlobalAlloc`.\n-#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-unsafe impl GlobalAlloc for System {\n-    #[inline]\n-    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-            // SAFETY: `libc::malloc` is guaranteed to be safe, it will allocate\n-            // `layout.size()` bytes of memory and return a pointer to it\n-            unsafe { libc::malloc(layout.size()) as *mut u8 }\n-        } else {\n-            // SAFETY: `libc::aligned_alloc` is guaranteed to be safe if\n-            // `layout.size()` is a multiple of `layout.align()`. This\n-            // constraint can be satisfied if `pad_to_align` is called,\n-            // which creates a layout by rounding the size of this layout up\n-            // to a multiple of the layout's alignment\n-            let aligned_layout = layout.pad_to_align();\n-            unsafe { libc::aligned_alloc(aligned_layout.align(), aligned_layout.size()) as *mut u8 }\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-            // SAFETY: `libc::calloc` is safe as long that `layout.size() * 1`\n-            // would not result in integer overflow which cannot happen,\n-            // multiplying by one never overflows\n-            unsafe { libc::calloc(layout.size(), 1) as *mut u8 }\n-        } else {\n-            // SAFETY: The safety contract for `alloc` must be upheld by the caller\n-            let ptr = unsafe { self.alloc(layout.clone()) };\n-            if !ptr.is_null() {\n-                // SAFETY: in the case of the `ptr` being not null\n-                // it will be properly aligned and a valid ptr\n-                // which satisfies `ptr::write_bytes` safety constrains\n-                unsafe { ptr::write_bytes(ptr, 0, layout.size()) };\n-            }\n-            ptr\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n-        // SAFETY: `libc::free` is guaranteed to be safe if `ptr` is allocated\n-        // by this allocator or if `ptr` is NULL\n-        unsafe { libc::free(ptr as *mut libc::c_void) }\n-    }\n-\n-    #[inline]\n-    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-        if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n-            // SAFETY: `libc::realloc` is safe if `ptr` is allocated by this\n-            // allocator or NULL\n-            // - If `new_size` is 0 and `ptr` is not NULL, it will act as `libc::free`\n-            // - If `new_size` is not 0 and `ptr` is NULL, it will act as `libc::malloc`\n-            // - Else, it will resize the block accordingly\n-            unsafe { libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8 }\n-        } else {\n-            // SAFETY: The safety contract for `realloc_fallback` must be upheld by the caller\n-            unsafe { realloc_fallback(self, ptr, layout, new_size) }\n-        }\n-    }\n-}"}, {"sha": "a7a4407ac38e281fb4ac716d2f8e75679c0d26af", "filename": "library/std/src/sys/wasi/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -17,6 +17,7 @@\n use crate::io as std_io;\n use crate::mem;\n \n+#[path = \"../unix/alloc.rs\"]\n pub mod alloc;\n pub mod args;\n #[path = \"../unsupported/cmath.rs\"]\n@@ -33,8 +34,11 @@ pub mod net;\n pub mod os;\n pub use crate::sys_common::os_str_bytes as os_str;\n pub mod ext;\n+#[path = \"../unix/path.rs\"]\n pub mod path;\n+#[path = \"../unsupported/pipe.rs\"]\n pub mod pipe;\n+#[path = \"../unsupported/process.rs\"]\n pub mod process;\n #[path = \"../unsupported/rwlock.rs\"]\n pub mod rwlock;"}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "library/std/src/sys/wasi/path.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fpath.rs?ref=9f04c9065764e56c91cbe567f78d2b207f546ba7", "patch": "@@ -1,19 +0,0 @@\n-use crate::ffi::OsStr;\n-use crate::path::Prefix;\n-\n-#[inline]\n-pub fn is_sep_byte(b: u8) -> bool {\n-    b == b'/'\n-}\n-\n-#[inline]\n-pub fn is_verbatim_sep(b: u8) -> bool {\n-    b == b'/'\n-}\n-\n-pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n-    None\n-}\n-\n-pub const MAIN_SEP_STR: &str = \"/\";\n-pub const MAIN_SEP: char = '/';"}, {"sha": "180fc114d86db2753290503ae629f66e58976792", "filename": "library/std/src/sys/wasi/pipe.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fpipe.rs?ref=9f04c9065764e56c91cbe567f78d2b207f546ba7", "patch": "@@ -1,40 +0,0 @@\n-#![deny(unsafe_op_in_unsafe_fn)]\n-\n-use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::sys::Void;\n-\n-pub struct AnonPipe(Void);\n-\n-impl AnonPipe {\n-    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_read_vectored(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_write_vectored(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn diverge(&self) -> ! {\n-        match self.0 {}\n-    }\n-}\n-\n-pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {\n-    match p1.0 {}\n-}"}, {"sha": "c69d6376b0138d0a89b08143d47bcd1e0fe1f01b", "filename": "library/std/src/sys/wasi/process.rs", "status": "removed", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f04c9065764e56c91cbe567f78d2b207f546ba7/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fprocess.rs?ref=9f04c9065764e56c91cbe567f78d2b207f546ba7", "patch": "@@ -1,151 +0,0 @@\n-#![deny(unsafe_op_in_unsafe_fn)]\n-\n-use crate::ffi::OsStr;\n-use crate::fmt;\n-use crate::io;\n-use crate::sys::fs::File;\n-use crate::sys::pipe::AnonPipe;\n-use crate::sys::{unsupported, Void};\n-use crate::sys_common::process::CommandEnv;\n-\n-pub use crate::ffi::OsString as EnvKey;\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Command\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct Command {\n-    env: CommandEnv,\n-}\n-\n-// passed back to std::process with the pipes connected to the child, if any\n-// were requested\n-pub struct StdioPipes {\n-    pub stdin: Option<AnonPipe>,\n-    pub stdout: Option<AnonPipe>,\n-    pub stderr: Option<AnonPipe>,\n-}\n-\n-pub enum Stdio {\n-    Inherit,\n-    Null,\n-    MakePipe,\n-}\n-\n-impl Command {\n-    pub fn new(_program: &OsStr) -> Command {\n-        Command { env: Default::default() }\n-    }\n-\n-    pub fn arg(&mut self, _arg: &OsStr) {}\n-\n-    pub fn env_mut(&mut self) -> &mut CommandEnv {\n-        &mut self.env\n-    }\n-\n-    pub fn cwd(&mut self, _dir: &OsStr) {}\n-\n-    pub fn stdin(&mut self, _stdin: Stdio) {}\n-\n-    pub fn stdout(&mut self, _stdout: Stdio) {}\n-\n-    pub fn stderr(&mut self, _stderr: Stdio) {}\n-\n-    pub fn spawn(\n-        &mut self,\n-        _default: Stdio,\n-        _needs_stdin: bool,\n-    ) -> io::Result<(Process, StdioPipes)> {\n-        unsupported()\n-    }\n-}\n-\n-impl From<AnonPipe> for Stdio {\n-    fn from(pipe: AnonPipe) -> Stdio {\n-        pipe.diverge()\n-    }\n-}\n-\n-impl From<File> for Stdio {\n-    fn from(_file: File) -> Stdio {\n-        panic!(\"unsupported\")\n-    }\n-}\n-\n-impl fmt::Debug for Command {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Ok(())\n-    }\n-}\n-\n-pub struct ExitStatus(Void);\n-\n-impl ExitStatus {\n-    pub fn success(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn code(&self) -> Option<i32> {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Clone for ExitStatus {\n-    fn clone(&self) -> ExitStatus {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Copy for ExitStatus {}\n-\n-impl PartialEq for ExitStatus {\n-    fn eq(&self, _other: &ExitStatus) -> bool {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Eq for ExitStatus {}\n-\n-impl fmt::Debug for ExitStatus {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-impl fmt::Display for ExitStatus {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitCode(bool);\n-\n-impl ExitCode {\n-    pub const SUCCESS: ExitCode = ExitCode(false);\n-    pub const FAILURE: ExitCode = ExitCode(true);\n-\n-    pub fn as_i32(&self) -> i32 {\n-        self.0 as i32\n-    }\n-}\n-\n-pub struct Process(Void);\n-\n-impl Process {\n-    pub fn id(&self) -> u32 {\n-        match self.0 {}\n-    }\n-\n-    pub fn kill(&mut self) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n-        match self.0 {}\n-    }\n-\n-    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n-        match self.0 {}\n-    }\n-}"}, {"sha": "2934ea59ab5ff687081f502df9e48417f7edea9d", "filename": "library/std/src/sys/wasm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -27,7 +27,7 @@ pub mod io;\n pub mod net;\n #[path = \"../unsupported/os.rs\"]\n pub mod os;\n-#[path = \"../unsupported/path.rs\"]\n+#[path = \"../unix/path.rs\"]\n pub mod path;\n #[path = \"../unsupported/pipe.rs\"]\n pub mod pipe;"}, {"sha": "da27d2fbf99a3675c39b732e8462e03c85b5c51e", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -195,6 +195,7 @@ target | std | host | notes\n `powerpc64-unknown-linux-musl` | ? |  |\n `powerpc64-wrs-vxworks` | ? |  |\n `powerpc64le-unknown-linux-musl` | ? |  |\n+`riscv32gc-unknown-linux-gnu` |   |   | RISC-V Linux (kernel 5.4, glibc 2.33)\n `sparc-unknown-linux-gnu` | \u2713 |  | 32-bit SPARC Linux\n `sparc64-unknown-netbsd` | \u2713 | \u2713 | NetBSD/sparc64\n `sparc64-unknown-openbsd` | ? |  |"}, {"sha": "a40a44fe27da3edb9aace137a22d08ed93c4239a", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -8,7 +8,7 @@ edition = \"2018\"\n path = \"lib.rs\"\n \n [dependencies]\n-pulldown-cmark = { version = \"0.7\", default-features = false }\n+pulldown-cmark = { version = \"0.8\", default-features = false }\n minifier = \"0.0.33\"\n rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n serde = { version = \"1.0\", features = [\"derive\"] }"}, {"sha": "6c0f1c02ac6da77d48c602932c30957d4742b8ff", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -27,7 +27,6 @@ use rustc_session::lint;\n use rustc_span::edition::Edition;\n use rustc_span::Span;\n use std::borrow::Cow;\n-use std::cell::RefCell;\n use std::collections::VecDeque;\n use std::default::Default;\n use std::fmt::Write;\n@@ -39,7 +38,7 @@ use crate::doctest;\n use crate::html::highlight;\n use crate::html::toc::TocBuilder;\n \n-use pulldown_cmark::{html, CodeBlockKind, CowStr, Event, Options, Parser, Tag};\n+use pulldown_cmark::{html, BrokenLink, CodeBlockKind, CowStr, Event, Options, Parser, Tag};\n \n #[cfg(test)]\n mod tests;\n@@ -931,15 +930,17 @@ impl Markdown<'_> {\n         if md.is_empty() {\n             return String::new();\n         }\n-        let replacer = |_: &str, s: &str| {\n-            if let Some(link) = links.iter().find(|link| &*link.original_text == s) {\n-                Some((link.href.clone(), link.new_text.clone()))\n+        let mut replacer = |broken_link: BrokenLink<'_>| {\n+            if let Some(link) =\n+                links.iter().find(|link| &*link.original_text == broken_link.reference)\n+            {\n+                Some((link.href.as_str().into(), link.new_text.as_str().into()))\n             } else {\n                 None\n             }\n         };\n \n-        let p = Parser::new_with_broken_link_callback(md, opts(), Some(&replacer));\n+        let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut replacer));\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n@@ -1009,9 +1010,11 @@ impl MarkdownSummaryLine<'_> {\n             return String::new();\n         }\n \n-        let replacer = |_: &str, s: &str| {\n-            if let Some(link) = links.iter().find(|link| &*link.original_text == s) {\n-                Some((link.href.clone(), link.new_text.clone()))\n+        let mut replacer = |broken_link: BrokenLink<'_>| {\n+            if let Some(link) =\n+                links.iter().find(|link| &*link.original_text == broken_link.reference)\n+            {\n+                Some((link.href.as_str().into(), link.new_text.as_str().into()))\n             } else {\n                 None\n             }\n@@ -1020,7 +1023,7 @@ impl MarkdownSummaryLine<'_> {\n         let p = Parser::new_with_broken_link_callback(\n             md,\n             Options::ENABLE_STRIKETHROUGH,\n-            Some(&replacer),\n+            Some(&mut replacer),\n         );\n \n         let mut s = String::new();\n@@ -1067,7 +1070,7 @@ pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n     }\n \n     let mut links = vec![];\n-    let shortcut_links = RefCell::new(vec![]);\n+    let mut shortcut_links = vec![];\n \n     {\n         let locate = |s: &str| unsafe {\n@@ -1084,11 +1087,13 @@ pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n             }\n         };\n \n-        let push = |_: &str, s: &str| {\n-            shortcut_links.borrow_mut().push((s.to_owned(), locate(s)));\n+        let mut push = |link: BrokenLink<'_>| {\n+            // FIXME: use `link.span` instead of `locate`\n+            // (doing it now includes the `[]` as well as the text)\n+            shortcut_links.push((link.reference.to_owned(), locate(link.reference)));\n             None\n         };\n-        let p = Parser::new_with_broken_link_callback(md, opts(), Some(&push));\n+        let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut push));\n \n         // There's no need to thread an IdMap through to here because\n         // the IDs generated aren't going to be emitted anywhere.\n@@ -1106,8 +1111,7 @@ pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n         }\n     }\n \n-    let mut shortcut_links = shortcut_links.into_inner();\n-    links.extend(shortcut_links.drain(..));\n+    links.append(&mut shortcut_links);\n \n     links\n }"}, {"sha": "e5f3ae45c07d345c967058f821f7381455adde7f", "filename": "src/test/codegen/issue-73396-bounds-check-after-position.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Ftest%2Fcodegen%2Fissue-73396-bounds-check-after-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Ftest%2Fcodegen%2Fissue-73396-bounds-check-after-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-73396-bounds-check-after-position.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -0,0 +1,78 @@\n+// min-llvm-version: 11.0.0\n+// compile-flags: -O\n+// ignore-debug: the debug assertions get in the way\n+#![crate_type = \"lib\"]\n+\n+// Make sure no bounds checks are emitted when slicing or indexing\n+// with an index from `position()` or `rposition()`.\n+\n+// CHECK-LABEL: @position_slice_to_no_bounds_check\n+#[no_mangle]\n+pub fn position_slice_to_no_bounds_check(s: &[u8]) -> &[u8] {\n+    // CHECK-NOT: panic\n+    // CHECK-NOT: slice_index_len_fail\n+    if let Some(idx) = s.iter().position(|b| *b == b'\\\\') {\n+        &s[..idx]\n+    } else {\n+        s\n+    }\n+}\n+\n+// CHECK-LABEL: @position_slice_from_no_bounds_check\n+#[no_mangle]\n+pub fn position_slice_from_no_bounds_check(s: &[u8]) -> &[u8] {\n+    // CHECK-NOT: panic\n+    // CHECK-NOT: slice_index_len_fail\n+    if let Some(idx) = s.iter().position(|b| *b == b'\\\\') {\n+        &s[idx..]\n+    } else {\n+        s\n+    }\n+}\n+\n+// CHECK-LABEL: @position_index_no_bounds_check\n+#[no_mangle]\n+pub fn position_index_no_bounds_check(s: &[u8]) -> u8 {\n+    // CHECK-NOT: panic\n+    // CHECK-NOT: slice_index_len_fail\n+    if let Some(idx) = s.iter().position(|b| *b == b'\\\\') {\n+        s[idx]\n+    } else {\n+        42\n+    }\n+}\n+// CHECK-LABEL: @rposition_slice_to_no_bounds_check\n+#[no_mangle]\n+pub fn rposition_slice_to_no_bounds_check(s: &[u8]) -> &[u8] {\n+    // CHECK-NOT: panic\n+    // CHECK-NOT: slice_index_len_fail\n+    if let Some(idx) = s.iter().rposition(|b| *b == b'\\\\') {\n+        &s[..idx]\n+    } else {\n+        s\n+    }\n+}\n+\n+// CHECK-LABEL: @rposition_slice_from_no_bounds_check\n+#[no_mangle]\n+pub fn rposition_slice_from_no_bounds_check(s: &[u8]) -> &[u8] {\n+    // CHECK-NOT: panic\n+    // CHECK-NOT: slice_index_len_fail\n+    if let Some(idx) = s.iter().rposition(|b| *b == b'\\\\') {\n+        &s[idx..]\n+    } else {\n+        s\n+    }\n+}\n+\n+// CHECK-LABEL: @rposition_index_no_bounds_check\n+#[no_mangle]\n+pub fn rposition_index_no_bounds_check(s: &[u8]) -> u8 {\n+    // CHECK-NOT: panic\n+    // CHECK-NOT: slice_index_len_fail\n+    if let Some(idx) = s.iter().rposition(|b| *b == b'\\\\') {\n+        s[idx]\n+    } else {\n+        42\n+    }\n+}"}, {"sha": "a01211c4f32b1b8479e37c37cf476be43a6c1339", "filename": "src/test/rustdoc-ui/intra-link-double-anchor.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Ftest%2Frustdoc-ui%2Fintra-link-double-anchor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Ftest%2Frustdoc-ui%2Fintra-link-double-anchor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-double-anchor.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -0,0 +1,7 @@\n+// check-pass\n+\n+// regression test for #73264\n+// should only give one error\n+/// docs [label][with#anchor#error]\n+//~^ WARNING multiple anchors\n+pub struct S;"}, {"sha": "3282ec8b79379d75b9b0a686471491857ccd6f95", "filename": "src/test/rustdoc-ui/intra-link-double-anchor.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Ftest%2Frustdoc-ui%2Fintra-link-double-anchor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Ftest%2Frustdoc-ui%2Fintra-link-double-anchor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-double-anchor.stderr?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -0,0 +1,10 @@\n+warning: `with#anchor#error` contains multiple anchors\n+  --> $DIR/intra-link-double-anchor.rs:5:18\n+   |\n+LL | /// docs [label][with#anchor#error]\n+   |                  ^^^^^^^^^^^^^^^^^ contains invalid anchor\n+   |\n+   = note: `#[warn(broken_intra_doc_links)]` on by default\n+\n+warning: 1 warning emitted\n+"}, {"sha": "fb884e3129999c3246f085522ebc6e553705c25a", "filename": "src/test/ui/lint/lint-unconditional-recursion.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Ftest%2Fui%2Flint%2Flint-unconditional-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Ftest%2Fui%2Flint%2Flint-unconditional-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unconditional-recursion.stderr?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -149,7 +149,7 @@ error: function cannot return without recursing\n LL |     fn deref(&self) -> &Baz {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ cannot return without recursing\n LL |         self.as_ref()\n-   |         ---- recursive call site\n+   |         ------------- recursive call site\n    |\n    = help: a `loop` may express intention better if this is on purpose\n "}, {"sha": "41154388f56a835b8b8fa767a916c6907f6510ab", "filename": "src/test/ui/moves/move-deref-coercion.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Ftest%2Fui%2Fmoves%2Fmove-deref-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Ftest%2Fui%2Fmoves%2Fmove-deref-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-deref-coercion.rs?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -0,0 +1,33 @@\n+use std::ops::Deref;\n+\n+struct NotCopy {\n+    inner: bool\n+}\n+\n+impl NotCopy {\n+    fn inner_method(&self) {}\n+}\n+\n+struct Foo {\n+    first: NotCopy,\n+    second: NotCopy\n+}\n+\n+impl Deref for Foo {\n+    type Target = NotCopy;\n+    fn deref(&self) -> &NotCopy {\n+        &self.second\n+    }\n+}\n+\n+fn use_field(val: Foo) {\n+    let _val = val.first;\n+    val.inner; //~ ERROR borrow of\n+}\n+\n+fn use_method(val: Foo) {\n+    let _val = val.first;\n+    val.inner_method(); //~ ERROR borrow of\n+}\n+\n+fn main() {}"}, {"sha": "e3bdf6d78320734e4cf7e06e0081061037ceb017", "filename": "src/test/ui/moves/move-deref-coercion.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Ftest%2Fui%2Fmoves%2Fmove-deref-coercion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Ftest%2Fui%2Fmoves%2Fmove-deref-coercion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-deref-coercion.stderr?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -0,0 +1,35 @@\n+error[E0382]: borrow of partially moved value: `val`\n+  --> $DIR/move-deref-coercion.rs:25:5\n+   |\n+LL |     let _val = val.first;\n+   |                --------- value partially moved here\n+LL |     val.inner;\n+   |     ^^^^^^^^^ value borrowed here after partial move\n+   |\n+   = note: partial move occurs because `val.first` has type `NotCopy`, which does not implement the `Copy` trait\n+   = note: borrow occurs due to deref coercion to `NotCopy`\n+note: deref defined here\n+  --> $DIR/move-deref-coercion.rs:17:5\n+   |\n+LL |     type Target = NotCopy;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0382]: borrow of partially moved value: `val`\n+  --> $DIR/move-deref-coercion.rs:30:5\n+   |\n+LL |     let _val = val.first;\n+   |                --------- value partially moved here\n+LL |     val.inner_method();\n+   |     ^^^^^^^^^^^^^^^^^^ value borrowed here after partial move\n+   |\n+   = note: partial move occurs because `val.first` has type `NotCopy`, which does not implement the `Copy` trait\n+   = note: borrow occurs due to deref coercion to `NotCopy`\n+note: deref defined here\n+  --> $DIR/move-deref-coercion.rs:17:5\n+   |\n+LL |     type Target = NotCopy;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "37032e73f1900c2a21bdfc55821ea77ed476fb52", "filename": "src/test/ui/no-capture-arc.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Ftest%2Fui%2Fno-capture-arc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Ftest%2Fui%2Fno-capture-arc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-capture-arc.stderr?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -1,5 +1,5 @@\n error[E0382]: borrow of moved value: `arc_v`\n-  --> $DIR/no-capture-arc.rs:14:18\n+  --> $DIR/no-capture-arc.rs:14:16\n    |\n LL |     let arc_v = Arc::new(v);\n    |         ----- move occurs because `arc_v` has type `Arc<Vec<i32>>`, which does not implement the `Copy` trait\n@@ -10,7 +10,14 @@ LL |         assert_eq!((*arc_v)[3], 4);\n    |                      ----- variable moved due to use in closure\n ...\n LL |     assert_eq!((*arc_v)[2], 3);\n-   |                  ^^^^^ value borrowed here after move\n+   |                ^^^^^^^^ value borrowed here after move\n+   |\n+   = note: borrow occurs due to deref coercion to `Vec<i32>`\n+note: deref defined here\n+  --> $SRC_DIR/alloc/src/sync.rs:LL:COL\n+   |\n+LL |     type Target = T;\n+   |     ^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "6f37d4c9d869125a8ea59a314edebf5f1577efae", "filename": "src/test/ui/no-reuse-move-arc.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Ftest%2Fui%2Fno-reuse-move-arc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4e4485a052857e5dd32ea29ceb7b1a8223e83cc/src%2Ftest%2Fui%2Fno-reuse-move-arc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-reuse-move-arc.stderr?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -1,5 +1,5 @@\n error[E0382]: borrow of moved value: `arc_v`\n-  --> $DIR/no-reuse-move-arc.rs:12:18\n+  --> $DIR/no-reuse-move-arc.rs:12:16\n    |\n LL |     let arc_v = Arc::new(v);\n    |         ----- move occurs because `arc_v` has type `Arc<Vec<i32>>`, which does not implement the `Copy` trait\n@@ -10,7 +10,14 @@ LL |         assert_eq!((*arc_v)[3], 4);\n    |                      ----- variable moved due to use in closure\n ...\n LL |     assert_eq!((*arc_v)[2], 3);\n-   |                  ^^^^^ value borrowed here after move\n+   |                ^^^^^^^^ value borrowed here after move\n+   |\n+   = note: borrow occurs due to deref coercion to `Vec<i32>`\n+note: deref defined here\n+  --> $SRC_DIR/alloc/src/sync.rs:LL:COL\n+   |\n+LL |     type Target = T;\n+   |     ^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "8777a6b1e8834899f51b7e09cc9b8d85b2417110", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=f4e4485a052857e5dd32ea29ceb7b1a8223e83cc", "patch": "@@ -1 +1 @@\n-Subproject commit 875e0123259b0b6299903fe4aea0a12ecde9324f\n+Subproject commit 8777a6b1e8834899f51b7e09cc9b8d85b2417110"}]}