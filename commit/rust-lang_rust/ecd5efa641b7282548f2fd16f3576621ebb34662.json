{"sha": "ecd5efa641b7282548f2fd16f3576621ebb34662", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjZDVlZmE2NDFiNzI4MjU0OGYyZmQxNmYzNTc2NjIxZWJiMzQ2NjI=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-02T02:01:12Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-06T22:18:06Z"}, "message": "Show usages of query cycles and correctly shift queries in a cycle", "tree": {"sha": "8a9e77366c2f158bd54ac254aaff4308ed79cb8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a9e77366c2f158bd54ac254aaff4308ed79cb8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecd5efa641b7282548f2fd16f3576621ebb34662", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecd5efa641b7282548f2fd16f3576621ebb34662", "html_url": "https://github.com/rust-lang/rust/commit/ecd5efa641b7282548f2fd16f3576621ebb34662", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecd5efa641b7282548f2fd16f3576621ebb34662/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bb5d35659b6d8579007f49db09aa1d35782b834", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bb5d35659b6d8579007f49db09aa1d35782b834", "html_url": "https://github.com/rust-lang/rust/commit/4bb5d35659b6d8579007f49db09aa1d35782b834"}], "stats": {"total": 91, "additions": 61, "deletions": 30}, "files": [{"sha": "d5bf3856bc43256240ee5d4e3a3a2515d9714285", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 61, "deletions": 30, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ecd5efa641b7282548f2fd16f3576621ebb34662/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd5efa641b7282548f2fd16f3576621ebb34662/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=ecd5efa641b7282548f2fd16f3576621ebb34662", "patch": "@@ -326,19 +326,17 @@ fn connected_to_root<'tcx>(\n     query: Lrc<QueryJob<'tcx>>,\n     visited: &mut FxHashSet<*const QueryJob<'tcx>>\n ) -> bool {\n-    // This query is connected to the root (it has no query parent), return true\n-    if query.parent.is_none() {\n-        return true;\n-    }\n-\n     // We already visited this or we're deliberately ignoring it\n     if visited.contains(&query.as_ptr()) {\n         return false;\n     }\n \n-    visited.insert(query.as_ptr());\n+    // This query is connected to the root (it has no query parent), return true\n+    if query.parent.is_none() {\n+        return true;\n+    }\n \n-    let mut connected = false;\n+    visited.insert(query.as_ptr());\n \n     visit_waiters(query, |_, successor| {\n         if connected_to_root(successor, visited) {\n@@ -349,6 +347,28 @@ fn connected_to_root<'tcx>(\n     }).is_some()\n }\n \n+// Deterministically pick an query from a list\n+#[cfg(parallel_queries)]\n+fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n+    tcx: TyCtxt<'_, 'tcx, '_>,\n+    queries: &'a [T],\n+    f: F\n+) -> &'a T {\n+    // Deterministically pick an entry point\n+    // FIXME: Sort this instead\n+    let mut hcx = tcx.create_stable_hashing_context();\n+    queries.iter().min_by_key(|v| {\n+        let (span, query) = f(v);\n+        let mut stable_hasher = StableHasher::<u64>::new();\n+        query.info.query.hash_stable(&mut hcx, &mut stable_hasher);\n+        // Prefer entry points which have valid spans for nicer error messages\n+        // We add an integer to the tuple ensuring that entry points\n+        // with valid spans are picked first\n+        let span_cmp = if span == DUMMY_SP { 1 } else { 0 };\n+        (span_cmp, stable_hasher.finish())\n+    }).unwrap()\n+}\n+\n /// Looks for query cycles starting from the last query in `jobs`.\n /// If a cycle is found, all queries in the cycle is removed from `jobs` and\n /// the function return true.\n@@ -388,41 +408,52 @@ fn remove_cycle<'tcx>(\n \n         // Find the queries in the cycle which are\n         // connected to queries outside the cycle\n-        let entry_points = stack.iter().filter_map(|query| {\n-            // Mark all the other queries in the cycle as already visited\n-            let mut visited = FxHashSet::from_iter(stack.iter().filter_map(|q| {\n-                if q.1.as_ptr() != query.1.as_ptr() {\n-                    Some(q.1.as_ptr())\n-                } else {\n+        let entry_points: Vec<_> = stack.iter().filter_map(|(span, query)| {\n+            if query.parent.is_none() {\n+                // This query is connected to the root (it has no query parent)\n+                Some((*span, query.clone(), None))\n+            } else {\n+                let mut waiters = Vec::new();\n+                // Find all the direct waiters who lead to the root\n+                visit_waiters(query.clone(), |span, waiter| {\n+                    // Mark all the other queries in the cycle as already visited\n+                    let mut visited = FxHashSet::from_iter(stack.iter().map(|q| q.1.as_ptr()));\n+\n+                    if connected_to_root(waiter.clone(), &mut visited) {\n+                        waiters.push((span, waiter));\n+                    }\n+\n                     None\n+                });\n+                if waiters.is_empty() {\n+                    None\n+                } else {\n+                    // Deterministically pick one of the waiters to show to the user\n+                    let waiter = pick_query(tcx, &waiters, |s| s.clone()).clone();\n+                    Some((*span, query.clone(), Some(waiter)))\n                 }\n-            }));\n-\n-            if connected_to_root(query.1.clone(), &mut visited) {\n-                Some(query.1.clone())\n-            } else {\n-                None\n             }\n-        });\n+        }).collect();\n+\n+        let entry_points: Vec<(Span, Lrc<QueryJob<'tcx>>, Option<(Span, Lrc<QueryJob<'tcx>>)>)>\n+         = entry_points;\n \n         // Deterministically pick an entry point\n-        // FIXME: Sort this instead\n-        let mut hcx = tcx.create_stable_hashing_context();\n-        let entry_point = entry_points.min_by_key(|q| {\n-            let mut stable_hasher = StableHasher::<u64>::new();\n-            q.info.query.hash_stable(&mut hcx, &mut stable_hasher);\n-            stable_hasher.finish()\n-        }).unwrap().as_ptr();\n+        let (_, entry_point, usage) = pick_query(tcx, &entry_points, |e| (e.0, e.1.clone()));\n \n         // Shift the stack so that our entry point is first\n-        let entry_point_pos = stack.iter().position(|(_, query)| query.as_ptr() == entry_point);\n+        let entry_point_pos = stack.iter().position(|(_, query)| {\n+            query.as_ptr() == entry_point.as_ptr()\n+        });\n         if let Some(pos) = entry_point_pos {\n-            stack.rotate_right(pos);\n+            stack.rotate_left(pos);\n         }\n \n+        let usage = usage.as_ref().map(|(span, query)| (*span, query.info.query.clone()));\n+\n         // Create the cycle error\n         let mut error = CycleError {\n-            usage: None,\n+            usage,\n             cycle: stack.iter().map(|&(s, ref q)| QueryInfo {\n                 span: s,\n                 query: q.info.query.clone(),"}]}