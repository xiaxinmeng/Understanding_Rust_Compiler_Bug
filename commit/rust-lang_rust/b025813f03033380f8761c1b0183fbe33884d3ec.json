{"sha": "b025813f03033380f8761c1b0183fbe33884d3ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMjU4MTNmMDMwMzMzODBmODc2MWMxYjAxODNmYmUzMzg4NGQzZWM=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-11-12T17:28:55Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-11-12T17:41:36Z"}, "message": "Handle empty matches cleanly", "tree": {"sha": "080f7fe026c993821991d4bb530f50a72e1be224", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/080f7fe026c993821991d4bb530f50a72e1be224"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b025813f03033380f8761c1b0183fbe33884d3ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b025813f03033380f8761c1b0183fbe33884d3ec", "html_url": "https://github.com/rust-lang/rust/commit/b025813f03033380f8761c1b0183fbe33884d3ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b025813f03033380f8761c1b0183fbe33884d3ec/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "257ed899c86acf6b4ee0f6dc9d6cfc9eb98e35a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/257ed899c86acf6b4ee0f6dc9d6cfc9eb98e35a5", "html_url": "https://github.com/rust-lang/rust/commit/257ed899c86acf6b4ee0f6dc9d6cfc9eb98e35a5"}], "stats": {"total": 149, "additions": 78, "deletions": 71}, "files": [{"sha": "f3fa0ec5fb7074097a82023eec981d991153a5c6", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b025813f03033380f8761c1b0183fbe33884d3ec/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b025813f03033380f8761c1b0183fbe33884d3ec/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=b025813f03033380f8761c1b0183fbe33884d3ec", "patch": "@@ -1392,13 +1392,12 @@ impl<'tcx> Usefulness<'tcx> {\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n-        is_top_level: bool,\n     ) -> Self {\n         match self {\n             UsefulWithWitness(witnesses) => {\n                 let new_witnesses = if ctor.is_wildcard() {\n                     let missing_ctors = MissingConstructors::new(pcx);\n-                    let new_patterns = missing_ctors.report_patterns(pcx, is_top_level);\n+                    let new_patterns = missing_ctors.report_patterns(pcx);\n                     witnesses\n                         .into_iter()\n                         .flat_map(|witness| {\n@@ -1454,6 +1453,9 @@ struct PatCtxt<'a, 'p, 'tcx> {\n     ty: Ty<'tcx>,\n     /// Span of the current pattern under investigation.\n     span: Span,\n+    /// Whether the current pattern is the whole pattern as found in a match arm, or if it's a\n+    /// subpattern.\n+    is_top_level: bool,\n }\n \n /// A witness of non-exhaustiveness for error reporting, represented\n@@ -1585,11 +1587,12 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n             let is_declared_nonexhaustive = cx.is_foreign_non_exhaustive_enum(pcx.ty);\n \n             // If `exhaustive_patterns` is disabled and our scrutinee is an empty enum, we treat it\n-            // as though it had an \"unknown\" constructor to avoid exposing its emptyness. Note that\n-            // an empty match will still be considered exhaustive because that case is handled\n-            // separately in `check_match`.\n-            let is_secretly_empty =\n-                def.variants.is_empty() && !cx.tcx.features().exhaustive_patterns;\n+            // as though it had an \"unknown\" constructor to avoid exposing its emptyness. The\n+            // exception is if the pattern is at the top level, because we want empty matches to be\n+            // considered exhaustive.\n+            let is_secretly_empty = def.variants.is_empty()\n+                && !cx.tcx.features().exhaustive_patterns\n+                && !pcx.is_top_level;\n \n             if is_secretly_empty || is_declared_nonexhaustive {\n                 vec![NonExhaustive]\n@@ -1635,6 +1638,13 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n             let max = size.truncate(u128::MAX);\n             vec![make_range(0, max)]\n         }\n+        // If `exhaustive_patterns` is disabled and our scrutinee is the never type, we cannot\n+        // expose its emptyness. The exception is if the pattern is at the top level, because we\n+        // want empty matches to be considered exhaustive.\n+        ty::Never if !cx.tcx.features().exhaustive_patterns && !pcx.is_top_level => {\n+            vec![NonExhaustive]\n+        }\n+        ty::Never => vec![],\n         _ if cx.is_uninhabited(pcx.ty) => vec![],\n         ty::Adt(..) | ty::Tuple(..) | ty::Ref(..) => vec![Single],\n         // This type is one for which we cannot list constructors, like `str` or `f64`.\n@@ -2012,11 +2022,7 @@ impl<'tcx> MissingConstructors<'tcx> {\n \n     /// List the patterns corresponding to the missing constructors. In some cases, instead of\n     /// listing all constructors of a given type, we prefer to simply report a wildcard.\n-    fn report_patterns<'p>(\n-        &self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n-        is_top_level: bool,\n-    ) -> SmallVec<[Pat<'tcx>; 1]> {\n+    fn report_patterns<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Pat<'tcx>; 1]> {\n         // There are 2 ways we can report a witness here.\n         // Commonly, we can report all the \"free\"\n         // constructors as witnesses, e.g., if we have:\n@@ -2044,7 +2050,7 @@ impl<'tcx> MissingConstructors<'tcx> {\n         // `used_ctors` is empty.\n         // The exception is: if we are at the top-level, for example in an empty match, we\n         // sometimes prefer reporting the list of constructors instead of just `_`.\n-        let report_when_all_missing = is_top_level && !IntRange::is_integral(pcx.ty);\n+        let report_when_all_missing = pcx.is_top_level && !IntRange::is_integral(pcx.ty);\n         if self.used_ctors.is_empty() && !report_when_all_missing {\n             // All constructors are unused. Report only a wildcard\n             // rather than each individual constructor.\n@@ -2200,7 +2206,7 @@ crate fn is_useful<'p, 'tcx>(\n \n     // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476).\n     let ty = matrix.heads().next().map(|r| r.ty).unwrap_or(v.head().ty);\n-    let pcx = PatCtxt { cx, matrix, ty, span: v.head().span };\n+    let pcx = PatCtxt { cx, matrix, ty, span: v.head().span, is_top_level };\n \n     debug!(\"is_useful_expand_first_col: ty={:#?}, expanding {:#?}\", pcx.ty, v.head());\n \n@@ -2215,7 +2221,7 @@ crate fn is_useful<'p, 'tcx>(\n             let v = v.pop_head_constructor(&ctor_wild_subpatterns);\n             let usefulness =\n                 is_useful(pcx.cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n-            usefulness.apply_constructor(pcx, &ctor, &ctor_wild_subpatterns, is_top_level)\n+            usefulness.apply_constructor(pcx, &ctor, &ctor_wild_subpatterns)\n         })\n         .find(|result| result.is_useful())\n         .unwrap_or(NotUseful);"}, {"sha": "c6fd7bcbf90dff4dff42a73e84e3dab7da000829", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b025813f03033380f8761c1b0183fbe33884d3ec/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b025813f03033380f8761c1b0183fbe33884d3ec/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=b025813f03033380f8761c1b0183fbe33884d3ec", "patch": "@@ -439,24 +439,6 @@ fn check_exhaustive<'p, 'tcx>(\n     hir_id: HirId,\n     is_empty_match: bool,\n ) {\n-    // In the absence of the `exhaustive_patterns` feature, empty matches are not detected by\n-    // `is_useful` to exhaustively match uninhabited types, so we manually check here.\n-    if is_empty_match && !cx.tcx.features().exhaustive_patterns {\n-        let scrutinee_is_visibly_uninhabited = match scrut_ty.kind() {\n-            ty::Never => true,\n-            ty::Adt(def, _) => {\n-                def.is_enum()\n-                    && def.variants.is_empty()\n-                    && !cx.is_foreign_non_exhaustive_enum(scrut_ty)\n-            }\n-            _ => false,\n-        };\n-        if scrutinee_is_visibly_uninhabited {\n-            // If the type *is* uninhabited, an empty match is vacuously exhaustive.\n-            return;\n-        }\n-    }\n-\n     let witnesses = match check_not_useful(cx, scrut_ty, matrix, hir_id) {\n         Ok(_) => return,\n         Err(err) => err,"}, {"sha": "835df1f551b13b65c7ace4e3dd830f2bc6662026", "filename": "src/test/ui/pattern/usefulness/match-empty.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b025813f03033380f8761c1b0183fbe33884d3ec/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b025813f03033380f8761c1b0183fbe33884d3ec/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.rs?ref=b025813f03033380f8761c1b0183fbe33884d3ec", "patch": "@@ -44,22 +44,20 @@ macro_rules! match_false {\n fn foo(x: Foo) {\n     match x {} // ok\n     match x {\n-        _ => {}, // Not detected as unreachable, see #55123.\n+        _ => {}, //~ ERROR unreachable pattern\n     }\n     match x {\n-    //~^ ERROR non-exhaustive patterns: `_` not covered\n-        _ if false => {}, // Not detected as unreachable nor exhaustive.\n+        _ if false => {}, //~ ERROR unreachable pattern\n     }\n }\n \n fn never(x: !) {\n     match x {} // ok\n     match x {\n-        _ => {}, // Not detected as unreachable.\n+        _ => {}, //~ ERROR unreachable pattern\n     }\n     match x {\n-    //~^ ERROR non-exhaustive patterns: `_` not covered\n-        _ if false => {}, // Not detected as unreachable nor exhaustive.\n+        _ if false => {}, //~ ERROR unreachable pattern\n     }\n }\n "}, {"sha": "af666b3a9218d69d133137fb598512ba6c6da7a0", "filename": "src/test/ui/pattern/usefulness/match-empty.stderr", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b025813f03033380f8761c1b0183fbe33884d3ec/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b025813f03033380f8761c1b0183fbe33884d3ec/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.stderr?ref=b025813f03033380f8761c1b0183fbe33884d3ec", "patch": "@@ -1,26 +1,35 @@\n-error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/match-empty.rs:49:11\n+error: unreachable pattern\n+  --> $DIR/match-empty.rs:47:9\n    |\n-LL | enum Foo {}\n-   | ----------- `Foo` defined here\n-...\n-LL |     match x {\n-   |           ^ pattern `_` not covered\n+LL |         _ => {},\n+   |         ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `Foo`\n+note: the lint level is defined here\n+  --> $DIR/match-empty.rs:3:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n \n-error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/match-empty.rs:60:11\n+error: unreachable pattern\n+  --> $DIR/match-empty.rs:50:9\n    |\n-LL |     match x {\n-   |           ^ pattern `_` not covered\n+LL |         _ if false => {},\n+   |         ^\n+\n+error: unreachable pattern\n+  --> $DIR/match-empty.rs:57:9\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `!`\n+LL |         _ => {},\n+   |         ^\n+\n+error: unreachable pattern\n+  --> $DIR/match-empty.rs:60:9\n+   |\n+LL |         _ if false => {},\n+   |         ^\n \n error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n-  --> $DIR/match-empty.rs:77:18\n+  --> $DIR/match-empty.rs:75:18\n    |\n LL |     match_empty!(0u8);\n    |                  ^^^\n@@ -29,7 +38,7 @@ LL |     match_empty!(0u8);\n    = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct` is non-empty\n-  --> $DIR/match-empty.rs:79:18\n+  --> $DIR/match-empty.rs:77:18\n    |\n LL | struct NonEmptyStruct(bool);\n    | ---------------------------- `NonEmptyStruct` defined here\n@@ -41,7 +50,7 @@ LL |     match_empty!(NonEmptyStruct(true));\n    = note: the matched value is of type `NonEmptyStruct`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n-  --> $DIR/match-empty.rs:81:18\n+  --> $DIR/match-empty.rs:79:18\n    |\n LL | / union NonEmptyUnion1 {\n LL | |     foo: (),\n@@ -55,7 +64,7 @@ LL |       match_empty!((NonEmptyUnion1 { foo: () }));\n    = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n-  --> $DIR/match-empty.rs:83:18\n+  --> $DIR/match-empty.rs:81:18\n    |\n LL | / union NonEmptyUnion2 {\n LL | |     foo: (),\n@@ -70,7 +79,7 @@ LL |       match_empty!((NonEmptyUnion2 { foo: () }));\n    = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n-  --> $DIR/match-empty.rs:85:18\n+  --> $DIR/match-empty.rs:83:18\n    |\n LL | / enum NonEmptyEnum1 {\n LL | |     Foo(bool),\n@@ -87,7 +96,7 @@ LL |       match_empty!(NonEmptyEnum1::Foo(true));\n    = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n-  --> $DIR/match-empty.rs:87:18\n+  --> $DIR/match-empty.rs:85:18\n    |\n LL | / enum NonEmptyEnum2 {\n LL | |     Foo(bool),\n@@ -108,7 +117,7 @@ LL |       match_empty!(NonEmptyEnum2::Foo(true));\n    = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n-  --> $DIR/match-empty.rs:89:18\n+  --> $DIR/match-empty.rs:87:18\n    |\n LL | / enum NonEmptyEnum5 {\n LL | |     V1, V2, V3, V4, V5,\n@@ -122,7 +131,7 @@ LL |       match_empty!(NonEmptyEnum5::V1);\n    = note: the matched value is of type `NonEmptyEnum5`\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/match-empty.rs:92:18\n+  --> $DIR/match-empty.rs:90:18\n    |\n LL |     match_false!(0u8);\n    |                  ^^^ pattern `_` not covered\n@@ -131,7 +140,7 @@ LL |     match_false!(0u8);\n    = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyStruct(_)` not covered\n-  --> $DIR/match-empty.rs:94:18\n+  --> $DIR/match-empty.rs:92:18\n    |\n LL | struct NonEmptyStruct(bool);\n    | ---------------------------- `NonEmptyStruct` defined here\n@@ -143,7 +152,7 @@ LL |     match_false!(NonEmptyStruct(true));\n    = note: the matched value is of type `NonEmptyStruct`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n-  --> $DIR/match-empty.rs:96:18\n+  --> $DIR/match-empty.rs:94:18\n    |\n LL | / union NonEmptyUnion1 {\n LL | |     foo: (),\n@@ -157,7 +166,7 @@ LL |       match_false!((NonEmptyUnion1 { foo: () }));\n    = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n-  --> $DIR/match-empty.rs:98:18\n+  --> $DIR/match-empty.rs:96:18\n    |\n LL | / union NonEmptyUnion2 {\n LL | |     foo: (),\n@@ -172,7 +181,7 @@ LL |       match_false!((NonEmptyUnion2 { foo: () }));\n    = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n-  --> $DIR/match-empty.rs:100:18\n+  --> $DIR/match-empty.rs:98:18\n    |\n LL | / enum NonEmptyEnum1 {\n LL | |     Foo(bool),\n@@ -189,7 +198,7 @@ LL |       match_false!(NonEmptyEnum1::Foo(true));\n    = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n-  --> $DIR/match-empty.rs:102:18\n+  --> $DIR/match-empty.rs:100:18\n    |\n LL | / enum NonEmptyEnum2 {\n LL | |     Foo(bool),\n@@ -210,7 +219,7 @@ LL |       match_false!(NonEmptyEnum2::Foo(true));\n    = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n-  --> $DIR/match-empty.rs:104:18\n+  --> $DIR/match-empty.rs:102:18\n    |\n LL | / enum NonEmptyEnum5 {\n LL | |     V1, V2, V3, V4, V5,\n@@ -223,6 +232,6 @@ LL |       match_false!(NonEmptyEnum5::V1);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum5`\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 18 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}, {"sha": "9b52c5b59918e98a8f01cbca61952d754b03d636", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum_same_crate_empty_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b025813f03033380f8761c1b0183fbe33884d3ec/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b025813f03033380f8761c1b0183fbe33884d3ec/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.rs?ref=b025813f03033380f8761c1b0183fbe33884d3ec", "patch": "@@ -25,7 +25,7 @@ pub enum EmptyNonExhaustiveEnum {}\n fn empty_non_exhaustive(x: EmptyNonExhaustiveEnum) {\n     match x {}\n     match x {\n-        _ => {} // not detected as unreachable\n+        _ => {}, //~ ERROR unreachable pattern\n     }\n }\n "}, {"sha": "07582e0ce32b9c18de828706beb966b7845b677a", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum_same_crate_empty_match.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b025813f03033380f8761c1b0183fbe33884d3ec/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b025813f03033380f8761c1b0183fbe33884d3ec/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr?ref=b025813f03033380f8761c1b0183fbe33884d3ec", "patch": "@@ -1,3 +1,15 @@\n+error: unreachable pattern\n+  --> $DIR/enum_same_crate_empty_match.rs:28:9\n+   |\n+LL |         _ => {},\n+   |         ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/enum_same_crate_empty_match.rs:1:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n error[E0004]: non-exhaustive patterns: `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/enum_same_crate_empty_match.rs:33:11\n    |\n@@ -42,6 +54,6 @@ LL |       match NormalEnum::Unit {}\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NormalEnum`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}]}