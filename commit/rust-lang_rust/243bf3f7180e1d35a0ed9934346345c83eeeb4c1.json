{"sha": "243bf3f7180e1d35a0ed9934346345c83eeeb4c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0M2JmM2Y3MTgwZTFkMzVhMGVkOTkzNDM0NjM0NWM4M2VlZWI0YzE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-21T18:12:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-04T14:14:38Z"}, "message": "rename \"free region\" to \"universally quantified region\"\n\nThis has been bugging me. All the regions appear free in the source;\nthe real difference is that some of them are universally quantified\n(those in the function signature) and some are existentially\nquantified (those for which we are inferring values).", "tree": {"sha": "40064cf2f0893ea43626e7c3c7e00eb3b723d0cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40064cf2f0893ea43626e7c3c7e00eb3b723d0cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/243bf3f7180e1d35a0ed9934346345c83eeeb4c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/243bf3f7180e1d35a0ed9934346345c83eeeb4c1", "html_url": "https://github.com/rust-lang/rust/commit/243bf3f7180e1d35a0ed9934346345c83eeeb4c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/243bf3f7180e1d35a0ed9934346345c83eeeb4c1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa813f74a21ae21a4491667e7201319017f4093e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa813f74a21ae21a4491667e7201319017f4093e", "html_url": "https://github.com/rust-lang/rust/commit/fa813f74a21ae21a4491667e7201319017f4093e"}], "stats": {"total": 163, "additions": 88, "deletions": 75}, "files": [{"sha": "804f5e2687597521cddac9ea77566c12ce8d4aae", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/243bf3f7180e1d35a0ed9934346345c83eeeb4c1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/243bf3f7180e1d35a0ed9934346345c83eeeb4c1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=243bf3f7180e1d35a0ed9934346345c83eeeb4c1", "patch": "@@ -26,8 +26,8 @@ use self::mir_util::PassWhere;\n \n mod constraint_generation;\n mod subtype_constraint_generation;\n-mod free_regions;\n-use self::free_regions::FreeRegions;\n+mod universal_regions;\n+use self::universal_regions::UniversalRegions;\n \n pub(crate) mod region_infer;\n use self::region_infer::RegionInferenceContext;\n@@ -42,14 +42,14 @@ pub(in borrow_check) fn replace_regions_in_mir<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     def_id: DefId,\n     mir: &mut Mir<'tcx>,\n-) -> FreeRegions<'tcx> {\n+) -> UniversalRegions<'tcx> {\n     // Compute named region information.\n-    let free_regions = free_regions::free_regions(infcx, def_id);\n+    let universal_regions = universal_regions::universal_regions(infcx, def_id);\n \n     // Replace all regions with fresh inference variables.\n-    renumber::renumber_mir(infcx, &free_regions, mir);\n+    renumber::renumber_mir(infcx, &universal_regions, mir);\n \n-    free_regions\n+    universal_regions\n }\n \n /// Computes the (non-lexical) regions from the input MIR.\n@@ -58,7 +58,7 @@ pub(in borrow_check) fn replace_regions_in_mir<'cx, 'gcx, 'tcx>(\n pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     def_id: DefId,\n-    free_regions: FreeRegions<'tcx>,\n+    universal_regions: UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n     flow_inits: &mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n@@ -71,8 +71,13 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     // Create the region inference context, taking ownership of the region inference\n     // data that was contained in `infcx`.\n     let var_origins = infcx.take_region_var_origins();\n-    let mut regioncx = RegionInferenceContext::new(var_origins, &free_regions, mir);\n-    subtype_constraint_generation::generate(&mut regioncx, &free_regions, mir, constraint_sets);\n+    let mut regioncx = RegionInferenceContext::new(var_origins, &universal_regions, mir);\n+    subtype_constraint_generation::generate(\n+        &mut regioncx,\n+        &universal_regions,\n+        mir,\n+        constraint_sets,\n+    );\n \n     // Compute what is live where.\n     let liveness = &LivenessResults {\n@@ -178,8 +183,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n                 writeln!(out, \"            | Live variables at {:?}: {}\", location, s)?;\n             }\n \n-            PassWhere::AfterLocation(_) |\n-            PassWhere::AfterCFG => {}\n+            PassWhere::AfterLocation(_) | PassWhere::AfterCFG => {}\n         }\n         Ok(())\n     });"}, {"sha": "26561329ae92420c7073938392620ff3994ad8b3", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/243bf3f7180e1d35a0ed9934346345c83eeeb4c1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/243bf3f7180e1d35a0ed9934346345c83eeeb4c1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=243bf3f7180e1d35a0ed9934346345c83eeeb4c1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::free_regions::FreeRegions;\n+use super::universal_regions::UniversalRegions;\n use rustc::infer::InferCtxt;\n use rustc::infer::RegionVariableOrigin;\n use rustc::infer::NLLRegionVariableOrigin;\n@@ -33,8 +33,8 @@ pub struct RegionInferenceContext<'tcx> {\n \n     /// The liveness constraints added to each region. For most\n     /// regions, these start out empty and steadily grow, though for\n-    /// each free region R they start out containing the entire CFG\n-    /// and `end(R)`.\n+    /// each universally quantified region R they start out containing\n+    /// the entire CFG and `end(R)`.\n     ///\n     /// In this `BitMatrix` representation, the rows are the region\n     /// variables and the columns are the free regions and MIR locations.\n@@ -52,7 +52,10 @@ pub struct RegionInferenceContext<'tcx> {\n     /// the free regions.)\n     point_indices: BTreeMap<Location, usize>,\n \n-    num_free_regions: usize,\n+    /// Number of universally quantified regions. This is used to\n+    /// determine the meaning of the bits in `inferred_values` and\n+    /// friends.\n+    num_universal_regions: usize,\n \n     free_region_map: &'tcx FreeRegionMap<'tcx>,\n }\n@@ -92,10 +95,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n     /// of those will be constant regions representing the free\n-    /// regions defined in `free_regions`.\n-    pub fn new(var_origins: VarOrigins, free_regions: &FreeRegions<'tcx>, mir: &Mir<'tcx>) -> Self {\n+    /// regions defined in `universal_regions`.\n+    pub fn new(\n+        var_origins: VarOrigins,\n+        universal_regions: &UniversalRegions<'tcx>,\n+        mir: &Mir<'tcx>,\n+    ) -> Self {\n         let num_region_variables = var_origins.len();\n-        let num_free_regions = free_regions.indices.len();\n+        let num_universal_regions = universal_regions.indices.len();\n \n         let mut num_points = 0;\n         let mut point_indices = BTreeMap::new();\n@@ -106,7 +113,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     block,\n                     statement_index,\n                 };\n-                point_indices.insert(location, num_free_regions + num_points);\n+                point_indices.insert(location, num_universal_regions + num_points);\n                 num_points += 1;\n             }\n         }\n@@ -121,25 +128,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             definitions,\n             liveness_constraints: BitMatrix::new(\n                 num_region_variables,\n-                num_free_regions + num_points,\n+                num_universal_regions + num_points,\n             ),\n             inferred_values: None,\n             constraints: Vec::new(),\n             point_indices,\n-            num_free_regions,\n-            free_region_map: free_regions.free_region_map,\n+            num_universal_regions,\n+            free_region_map: universal_regions.free_region_map,\n         };\n \n-        result.init_free_regions(free_regions);\n+        result.init_universal_regions(universal_regions);\n \n         result\n     }\n \n-    /// Initializes the region variables for each free region\n-    /// (lifetime parameter). The first N variables always correspond\n-    /// to the free regions appearing in the function signature (both\n-    /// named and anonymous) and where clauses. This function iterates\n-    /// over those regions and initializes them with minimum values.\n+    /// Initializes the region variables for each universally\n+    /// quantified region (lifetime parameter). The first N variables\n+    /// always correspond to the regions appearing in the function\n+    /// signature (both named and anonymous) and where clauses. This\n+    /// function iterates over those regions and initializes them with\n+    /// minimum values.\n     ///\n     /// For example:\n     ///\n@@ -154,13 +162,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// and (b) any free regions that it outlives, which in this case\n     /// is just itself. R1 (`'b`) in contrast also outlives `'a` and\n     /// hence contains R0 and R1.\n-    fn init_free_regions(&mut self, free_regions: &FreeRegions<'tcx>) {\n-        let FreeRegions {\n+    fn init_universal_regions(&mut self, universal_regions: &UniversalRegions<'tcx>) {\n+        let UniversalRegions {\n             indices,\n             free_region_map: _,\n-        } = free_regions;\n+        } = universal_regions;\n \n-        // For each free region X:\n+        // For each universally quantified region X:\n         for (free_region, &variable) in indices {\n             // These should be free-region variables.\n             assert!(match self.definitions[variable].origin {\n@@ -218,7 +226,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         matrix: &BitMatrix,\n         r: RegionVid,\n-        s: RegionVid\n+        s: RegionVid,\n     ) -> bool {\n         matrix.contains(r.index(), s.index())\n     }\n@@ -240,7 +248,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        for fr in (0 .. self.num_free_regions).map(RegionVid::new) {\n+        for fr in (0..self.num_universal_regions).map(RegionVid::new) {\n             if self.region_contains_region_in_matrix(inferred_values, r, fr) {\n                 result.push_str(&format!(\"{}{:?}\", sep, fr));\n                 sep = \", \";\n@@ -287,9 +295,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Find the minimal regions that can solve the constraints. This is infallible.\n         self.propagate_constraints(mir);\n \n-        // Now, see whether any of the constraints were too strong. In particular,\n-        // we want to check for a case where a free region exceeded its bounds.\n-        // Consider:\n+        // Now, see whether any of the constraints were too strong. In\n+        // particular, we want to check for a case where a universally\n+        // quantified region exceeded its bounds.  Consider:\n         //\n         //     fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n         //\n@@ -300,7 +308,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // have no evidence that `'b` outlives `'a`, so we want to report\n         // an error.\n \n-        // The free regions are always found in a prefix of the full list.\n+        // The universal regions are always found in a prefix of the\n+        // full list.\n         let free_region_definitions = self.definitions\n             .iter_enumerated()\n             .take_while(|(_, fr_definition)| fr_definition.name.is_some());\n@@ -322,7 +331,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // Find every region `o` such that `fr: o`\n         // (because `fr` includes `end(o)`).\n-        for outlived_fr in fr_value.take_while(|&i| i < self.num_free_regions) {\n+        for outlived_fr in fr_value.take_while(|&i| i < self.num_universal_regions) {\n             // `fr` includes `end(fr)`, that's not especially\n             // interesting.\n             if fr.index() == outlived_fr {\n@@ -451,11 +460,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // If we reach the END point in the graph, then copy\n                 // over any skolemized end points in the `from_region`\n                 // and make sure they are included in the `to_region`.\n-                let free_region_indices = inferred_values\n+                let universal_region_indices = inferred_values\n                     .iter(from_region.index())\n-                    .take_while(|&i| i < self.num_free_regions)\n+                    .take_while(|&i| i < self.num_universal_regions)\n                     .collect::<Vec<_>>();\n-                for fr in &free_region_indices {\n+                for fr in &universal_region_indices {\n                     changed |= inferred_values.add(to_region.index(), *fr);\n                 }\n             } else {\n@@ -523,7 +532,7 @@ impl<'tcx> RegionDefinition<'tcx> {\n     fn new(origin: RegionVariableOrigin) -> Self {\n         // Create a new region definition. Note that, for free\n         // regions, these fields get updated later in\n-        // `init_free_regions`.\n+        // `init_universal_regions`.\n         Self { origin, name: None }\n     }\n }"}, {"sha": "371419da0244871fd4d6114ca53296eda0024180", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/243bf3f7180e1d35a0ed9934346345c83eeeb4c1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/243bf3f7180e1d35a0ed9934346345c83eeeb4c1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=243bf3f7180e1d35a0ed9934346345c83eeeb4c1", "patch": "@@ -16,18 +16,18 @@ use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n use super::ToRegionVid;\n-use super::free_regions::FreeRegions;\n+use super::universal_regions::UniversalRegions;\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n pub fn renumber_mir<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    free_regions: &FreeRegions<'tcx>,\n+    universal_regions: &UniversalRegions<'tcx>,\n     mir: &mut Mir<'tcx>,\n ) {\n     // Create inference variables for each of the free regions\n     // declared on the function signature.\n-    let free_region_inference_vars = (0..free_regions.indices.len())\n+    let free_region_inference_vars = (0..universal_regions.indices.len())\n         .map(RegionVid::new)\n         .map(|vid_expected| {\n             let r = infcx.next_nll_region_var(NLLRegionVariableOrigin::FreeRegion);\n@@ -37,12 +37,12 @@ pub fn renumber_mir<'a, 'gcx, 'tcx>(\n         .collect();\n \n     debug!(\"renumber_mir()\");\n-    debug!(\"renumber_mir: free_regions={:#?}\", free_regions);\n+    debug!(\"renumber_mir: universal_regions={:#?}\", universal_regions);\n     debug!(\"renumber_mir: mir.arg_count={:?}\", mir.arg_count);\n \n     let mut visitor = NLLVisitor {\n         infcx,\n-        free_regions,\n+        universal_regions,\n         free_region_inference_vars,\n         arg_count: mir.arg_count,\n     };\n@@ -51,7 +51,7 @@ pub fn renumber_mir<'a, 'gcx, 'tcx>(\n \n struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    free_regions: &'a FreeRegions<'tcx>,\n+    universal_regions: &'a UniversalRegions<'tcx>,\n     free_region_inference_vars: IndexVec<RegionVid, ty::Region<'tcx>>,\n     arg_count: usize,\n }\n@@ -76,16 +76,16 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n \n     /// Renumbers the regions appearing in `value`, but those regions\n     /// are expected to be free regions from the function signature.\n-    fn renumber_free_regions<T>(&mut self, value: &T) -> T\n+    fn renumber_universal_regions<T>(&mut self, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        debug!(\"renumber_free_regions(value={:?})\", value);\n+        debug!(\"renumber_universal_regions(value={:?})\", value);\n \n         self.infcx\n             .tcx\n             .fold_regions(value, &mut false, |region, _depth| {\n-                let index = self.free_regions.indices[&region];\n+                let index = self.universal_regions.indices[&region];\n                 self.free_region_inference_vars[index]\n             })\n     }\n@@ -112,7 +112,7 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n \n         let old_ty = *ty;\n         *ty = if is_arg {\n-            self.renumber_free_regions(&old_ty)\n+            self.renumber_universal_regions(&old_ty)\n         } else {\n             self.renumber_regions(ty_context, &old_ty)\n         };"}, {"sha": "dbae40be6fe1da1a15a9a5a1a5801b96b5cbc0f5", "filename": "src/librustc_mir/borrow_check/nll/subtype_constraint_generation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/243bf3f7180e1d35a0ed9934346345c83eeeb4c1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/243bf3f7180e1d35a0ed9934346345c83eeeb4c1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs?ref=243bf3f7180e1d35a0ed9934346345c83eeeb4c1", "patch": "@@ -15,7 +15,7 @@ use rustc::ty;\n use transform::type_check::MirTypeckRegionConstraints;\n use transform::type_check::OutlivesSet;\n \n-use super::free_regions::FreeRegions;\n+use super::universal_regions::UniversalRegions;\n use super::region_infer::RegionInferenceContext;\n \n /// When the MIR type-checker executes, it validates all the types in\n@@ -25,20 +25,20 @@ use super::region_infer::RegionInferenceContext;\n /// them into the NLL `RegionInferenceContext`.\n pub(super) fn generate<'tcx>(\n     regioncx: &mut RegionInferenceContext<'tcx>,\n-    free_regions: &FreeRegions<'tcx>,\n+    universal_regions: &UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n     constraints: &MirTypeckRegionConstraints<'tcx>,\n ) {\n     SubtypeConstraintGenerator {\n         regioncx,\n-        free_regions,\n+        universal_regions,\n         mir,\n     }.generate(constraints);\n }\n \n struct SubtypeConstraintGenerator<'cx, 'tcx: 'cx> {\n     regioncx: &'cx mut RegionInferenceContext<'tcx>,\n-    free_regions: &'cx FreeRegions<'tcx>,\n+    universal_regions: &'cx UniversalRegions<'tcx>,\n     mir: &'cx Mir<'tcx>,\n }\n \n@@ -102,11 +102,11 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n         // Every region that we see in the constraints came from the\n         // MIR or from the parameter environment. If the former, it\n         // will be a region variable.  If the latter, it will be in\n-        // the set of free regions *somewhere*.\n+        // the set of universal regions *somewhere*.\n         if let ty::ReVar(vid) = r {\n             *vid\n         } else {\n-            self.free_regions.indices[&r]\n+            self.universal_regions.indices[&r]\n         }\n     }\n }"}, {"sha": "3be95a114c3bc287dd010f92dd76c9dc9533b487", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "renamed", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/243bf3f7180e1d35a0ed9934346345c83eeeb4c1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/243bf3f7180e1d35a0ed9934346345c83eeeb4c1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=243bf3f7180e1d35a0ed9934346345c83eeeb4c1", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Code to extract the free regions declared on a function and the\n-//! relationships between them. For example:\n+//! Code to extract the universally quantified regions declared on a\n+//! function and the relationships between them. For example:\n //!\n //! ```\n //! fn foo<'a, 'b, 'c: 'b>() { }\n@@ -31,22 +31,22 @@ use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n #[derive(Debug)]\n-pub struct FreeRegions<'tcx> {\n-    /// Given a free region defined on this function (either early- or\n-    /// late-bound), this maps it to its internal region index. When\n-    /// the region context is created, the first N variables will be\n-    /// created based on these indices.\n+pub struct UniversalRegions<'tcx> {\n+    /// Given a universally quantified region defined on this function\n+    /// (either early- or late-bound), this maps it to its internal\n+    /// region index. When the region context is created, the first N\n+    /// variables will be created based on these indices.\n     pub indices: FxHashMap<ty::Region<'tcx>, RegionVid>,\n \n-    /// The map from the typeck tables telling us how to relate free regions.\n+    /// The map from the typeck tables telling us how to relate universal regions.\n     pub free_region_map: &'tcx FreeRegionMap<'tcx>,\n }\n \n-pub fn free_regions<'a, 'gcx, 'tcx>(\n+pub fn universal_regions<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     item_def_id: DefId,\n-) -> FreeRegions<'tcx> {\n-    debug!(\"free_regions(item_def_id={:?})\", item_def_id);\n+) -> UniversalRegions<'tcx> {\n+    debug!(\"universal_regions(item_def_id={:?})\", item_def_id);\n \n     let mut indices = FxHashMap();\n \n@@ -76,15 +76,15 @@ pub fn free_regions<'a, 'gcx, 'tcx>(\n             }\n         });\n \n-    debug!(\"free_regions: indices={:#?}\", indices);\n+    debug!(\"universal_regions: indices={:#?}\", indices);\n \n-    FreeRegions { indices, free_region_map: &tables.free_region_map }\n+    UniversalRegions { indices, free_region_map: &tables.free_region_map }\n }\n \n fn insert_free_region<'tcx>(\n-    free_regions: &mut FxHashMap<ty::Region<'tcx>, RegionVid>,\n+    universal_regions: &mut FxHashMap<ty::Region<'tcx>, RegionVid>,\n     region: ty::Region<'tcx>,\n ) {\n-    let next = RegionVid::new(free_regions.len());\n-    free_regions.entry(region).or_insert(next);\n+    let next = RegionVid::new(universal_regions.len());\n+    universal_regions.entry(region).or_insert(next);\n }", "previous_filename": "src/librustc_mir/borrow_check/nll/free_regions.rs"}]}