{"sha": "b22556a6f818845cd400ad58065a83916ba591a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMjU1NmE2ZjgxODg0NWNkNDAwYWQ1ODA2NWE4MzkxNmJhNTkxYTc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-07T03:09:32Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-10T06:56:53Z"}, "message": "core: Convert to rustdoc", "tree": {"sha": "7282020da3c5a9250161aa6efe254f9be12ac822", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7282020da3c5a9250161aa6efe254f9be12ac822"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b22556a6f818845cd400ad58065a83916ba591a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b22556a6f818845cd400ad58065a83916ba591a7", "html_url": "https://github.com/rust-lang/rust/commit/b22556a6f818845cd400ad58065a83916ba591a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b22556a6f818845cd400ad58065a83916ba591a7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0521971b1b9a3203c250591991092a445b50586", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0521971b1b9a3203c250591991092a445b50586", "html_url": "https://github.com/rust-lang/rust/commit/a0521971b1b9a3203c250591991092a445b50586"}], "stats": {"total": 3189, "additions": 1075, "deletions": 2114}, "files": [{"sha": "4ceb384d7aad587964e6237bc0867b292428b7f3", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 18, "deletions": 41, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -10,55 +10,36 @@ export from_str, to_str, all_values, to_bit;\n #[doc = \"The type of boolean logic values\"]\n type t = bool;\n \n-#[doc(\n-  brief = \"Negation/Inverse\"\n-)]\n+#[doc = \"Negation/Inverse\"]\n pure fn not(v: t) -> t { !v }\n \n-#[doc(\n-  brief = \"Conjunction\"\n-)]\n+#[doc = \"Conjunction\"]\n pure fn and(a: t, b: t) -> t { a && b }\n \n-#[doc(\n-  brief = \"Disjunction\"\n-)]\n+#[doc = \"Disjunction\"]\n pure fn or(a: t, b: t) -> t { a || b }\n \n-#[doc(\n-  brief = \"Exclusive or, i.e. `or(and(a, not(b)), and(not(a), b))`\"\n-)]\n+#[doc = \"Exclusive or, i.e. `or(and(a, not(b)), and(not(a), b))`\"]\n pure fn xor(a: t, b: t) -> t { (a && !b) || (!a && b) }\n \n-#[doc(\n-  brief = \"Implication in the logic, i.e. from `a` follows `b`\"\n-)]\n+#[doc = \"Implication in the logic, i.e. from `a` follows `b`\"]\n pure fn implies(a: t, b: t) -> t { !a || b }\n \n-#[doc(\n-  brief = \"true if truth values `a` and `b` \\\n-           are indistinguishable in the logic\"\n-)]\n+#[doc = \"\n+true if truth values `a` and `b` are indistinguishable in the logic\n+\"]\n pure fn eq(a: t, b: t) -> bool { a == b }\n \n-#[doc(\n-  brief = \"true if truth values `a` and `b` are distinguishable in the logic\"\n-)]\n+#[doc = \"true if truth values `a` and `b` are distinguishable in the logic\"]\n pure fn ne(a: t, b: t) -> bool { a != b }\n \n-#[doc(\n-  brief = \"true if `v` represents truth in the logic\"\n-)]\n+#[doc = \"true if `v` represents truth in the logic\"]\n pure fn is_true(v: t) -> bool { v }\n \n-#[doc(\n-  brief = \"true if `v` represents falsehood in the logic\"\n-)]\n+#[doc = \"true if `v` represents falsehood in the logic\"]\n pure fn is_false(v: t) -> bool { !v }\n \n-#[doc(\n-  brief = \"Parse logic value from `s`\"\n-)]\n+#[doc = \"Parse logic value from `s`\"]\n pure fn from_str(s: str) -> option<t> {\n     alt check s {\n       \"true\" { some(true) }\n@@ -67,23 +48,19 @@ pure fn from_str(s: str) -> option<t> {\n     }\n }\n \n-#[doc(\n-  brief = \"Convert `v` into a string\"\n-)]\n+#[doc = \"Convert `v` into a string\"]\n pure fn to_str(v: t) -> str { if v { \"true\" } else { \"false\" } }\n \n-#[doc(\n-  brief = \"Iterates over all truth values by passing them to `blk` \\\n-           in an unspecified order\"\n-)]\n+#[doc = \"\n+Iterates over all truth values by passing them to `blk` in an unspecified\n+order\n+\"]\n fn all_values(blk: fn(v: t)) {\n     blk(true);\n     blk(false);\n }\n \n-#[doc(\n-  brief = \"converts truth value to an 8 bit byte\"\n-)]\n+#[doc = \"converts truth value to an 8 bit byte\"]\n pure fn to_bit(v: t) -> u8 { if v { 1u8 } else { 0u8 } }\n \n #[test]"}, {"sha": "28323f49ff01ded16a134e045a52d6fe8c7930f1", "filename": "src/libcore/box.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbox.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,9 +1,9 @@\n+#[doc = \"Operations on shared box types\"];\n+\n export ptr_eq;\n \n-#[doc(\n-  brief = \"Determine if two shared boxes point to the same object\"\n-)]\n pure fn ptr_eq<T>(a: @T, b: @T) -> bool unchecked {\n+    #[doc = \"Determine if two shared boxes point to the same object\"];\n     ptr::addr_of(*a) == ptr::addr_of(*b)\n }\n "}, {"sha": "a06669dfe0353e949bb8786742d042ba322bcd89", "filename": "src/libcore/char.rs", "status": "modified", "additions": 43, "deletions": 38, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -45,66 +45,72 @@ import is_XID_start = unicode::derived_property::XID_Start;\n import is_XID_continue = unicode::derived_property::XID_Continue;\n \n \n-#[doc(\n-  brief = \"Indicates whether a character is in lower case, defined \\\n-           in terms of the Unicode General Category 'Ll'.\"\n-)]\n+#[doc = \"\n+Indicates whether a character is in lower case, defined\n+in terms of the Unicode General Category 'Ll'\n+\"]\n pure fn is_lowercase(c: char) -> bool {\n     ret unicode::general_category::Ll(c);\n }\n \n-#[doc(\n-  brief = \"Indicates whether a character is in upper case, defined \\\n-           in terms of the Unicode General Category 'Lu'.\"\n-)]\n+#[doc = \"\n+Indicates whether a character is in upper case, defined\n+in terms of the Unicode General Category 'Lu'.\n+\"]\n pure fn is_uppercase(c: char) -> bool {\n     ret unicode::general_category::Lu(c);\n }\n \n-#[doc(\n-  brief = \"Indicates whether a character is whitespace, defined in \\\n-           terms of the Unicode General Categories 'Zs', 'Zl', 'Zp' \\\n-           additional 'Cc'-category control codes in the range [0x09, 0x0d]\"\n-)]\n+#[doc = \"\n+Indicates whether a character is whitespace, defined in\n+terms of the Unicode General Categories 'Zs', 'Zl', 'Zp'\n+additional 'Cc'-category control codes in the range [0x09, 0x0d]\n+\"]\n pure fn is_whitespace(c: char) -> bool {\n     ret ('\\x09' <= c && c <= '\\x0d')\n         || unicode::general_category::Zs(c)\n         || unicode::general_category::Zl(c)\n         || unicode::general_category::Zp(c);\n }\n \n-#[doc(\n-  brief = \"Indicates whether a character is alphanumeric, defined \\\n-            in terms of the Unicode General Categories 'Nd', \\\n-            'Nl', 'No' and the Derived Core Property 'Alphabetic'.\"\n-)]\n+#[doc = \"\n+Indicates whether a character is alphanumeric, defined\n+in terms of the Unicode General Categories 'Nd',\n+'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n+\"]\n pure fn is_alphanumeric(c: char) -> bool {\n     ret unicode::derived_property::Alphabetic(c) ||\n         unicode::general_category::Nd(c) ||\n         unicode::general_category::Nl(c) ||\n         unicode::general_category::No(c);\n }\n \n-#[doc( brief = \"Indicates whether the character is an ASCII character\" )]\n+#[doc = \"Indicates whether the character is an ASCII character\"]\n pure fn is_ascii(c: char) -> bool {\n    c - ('\\x7F' & c) == '\\x00'\n }\n \n-#[doc( brief = \"Indicates whether the character is numeric (Nd, Nl, or No)\" )]\n+#[doc = \"Indicates whether the character is numeric (Nd, Nl, or No)\"]\n pure fn is_digit(c: char) -> bool {\n     ret unicode::general_category::Nd(c) ||\n         unicode::general_category::Nl(c) ||\n         unicode::general_category::No(c);\n }\n \n-#[doc(\n-  brief = \"Convert a char to the corresponding digit. \\\n-           Safety note: This function fails if `c` is not a valid char\",\n-  return = \"If `c` is between '0' and '9', the corresponding value \\\n-            between 0 and 9. If `c` is 'a' or 'A', 10. If `c` is \\\n-            'b' or 'B', 11, etc. Returns none if the char does not \\\n-            refer to a digit in the given radix.\"\n-)]\n+#[doc = \"\n+Convert a char to the corresponding digit.\n+\n+# Safety note\n+\n+This function fails if `c` is not a valid char\n+\n+# Return value\n+\n+If `c` is between '0' and '9', the corresponding value\n+between 0 and 9. If `c` is 'a' or 'A', 10. If `c` is\n+'b' or 'B', 11, etc. Returns none if the char does not\n+refer to a digit in the given radix.\n+\"]\n pure fn to_digit(c: char, radix: uint) -> option<uint> {\n     let val = alt c {\n       '0' to '9' { c as uint - ('0' as uint) }\n@@ -119,9 +125,7 @@ pure fn to_digit(c: char, radix: uint) -> option<uint> {\n /*\n  FIXME: works only on ASCII\n */\n-#[doc(\n-  brief = \"Convert a char to the corresponding lower case.\"\n-)]\n+#[doc = \"Convert a char to the corresponding lower case.\"]\n pure fn to_lower(c: char) -> char {\n     alt c {\n       'A' to 'Z' { ((c as u8) + 32u8) as char }\n@@ -132,20 +136,21 @@ pure fn to_lower(c: char) -> char {\n /*\n  FIXME: works only on ASCII\n */\n-#[doc(\n-  brief = \"Convert a char to the corresponding upper case.\"\n-)]\n+#[doc = \"Convert a char to the corresponding upper case.\"]\n pure fn to_upper(c: char) -> char {\n     alt c {\n       'a' to 'z' { ((c as u8) - 32u8) as char }\n       _ { c }\n     }\n }\n \n-#[doc(\n-  brief =  \"Compare two chars.\",\n-  return = \"-1 if a<b, 0 if a==b, +1 if a>b\"\n-)]\n+#[doc = \"\n+Compare two chars\n+\n+# Return value\n+\n+-1 if a < b, 0 if a == b, +1 if a > b\n+\"]\n pure fn cmp(a: char, b: char) -> int {\n     ret  if b > a { -1 }\n     else if b < a { 1 }"}, {"sha": "413144aff697ed1160398be5bccd56fc89033a67", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 44, "deletions": 50, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,6 +1,5 @@\n-#[doc(\n-  brief = \"Communication between tasks\",\n-  desc  = \"\n+#[doc = \"\n+Communication between tasks\n \n Communication between tasks is facilitated by ports (in the receiving\n task), and channels (in the sending task). Any number of channels may\n@@ -11,15 +10,19 @@ vectors, strings, and records, tags, tuples and unique boxes (`~T`)\n thereof. Most notably, shared boxes (`@T`) may not be transmitted\n across channels.\n \n-Example:\n+# Example\n \n-    let p = comm::port();\n-    task::spawn(comm::chan(p), fn (c: chan<str>) {\n-        comm::send(c, \\\"Hello, World\\\");\n-    });\n-    io::println(comm::recv(p));\n+~~~\n+let po = comm::port();\n+let ch = comm::chan(po);\n \n-\")];\n+task::spawn {||\n+    comm::send(ch, \\\"Hello, World\\\");\n+});\n+\n+io::println(comm::recv(p));\n+~~~\n+\"];\n \n import sys;\n import task;\n@@ -65,18 +68,16 @@ type port_id = int;\n \n // It's critical that this only have one variant, so it has a record\n // layout, and will work in the rust_task structure in task.rs.\n-#[doc(\n-  brief = \"A communication endpoint that can send messages. \\\n-           Channels send messages to ports.\",\n-  desc = \"Each channel is bound to a port when the channel is \\\n-          constructed, so the destination port for a channel \\\n-          must exist before the channel itself. \\\n-          Channels are weak: a channel does not keep the port it \\\n-          is bound to alive. If a channel attempts to send data \\\n-          to a dead port that data will be silently dropped. \\\n-          Channels may be duplicated and themselves transmitted \\\n-          over other channels.\"\n-)]\n+#[doc = \"\n+A communication endpoint that can send messages\n+\n+Each channel is bound to a port when the channel is constructed, so\n+the destination port for a channel must exist before the channel\n+itself.  Channels are weak: a channel does not keep the port it is\n+bound to alive. If a channel attempts to send data to a dead port that\n+data will be silently dropped.  Channels may be duplicated and\n+themselves transmitted over other channels.\n+\"]\n enum chan<T: send> {\n     chan_t(task_id, port_id)\n }\n@@ -104,21 +105,19 @@ resource port_ptr<T: send>(po: *rust_port) {\n     rustrt::del_port(po);\n }\n \n-#[doc(\n-  brief = \"A communication endpoint that can receive messages. \\\n-           Ports receive messages from channels.\",\n-  desc = \"Each port has a unique per-task identity and may not \\\n-          be replicated or transmitted. If a port value is \\\n-          copied, both copies refer to the same port. \\\n-          Ports may be associated with multiple <chan>s.\"\n-)]\n+#[doc = \"\n+A communication endpoint that can receive messages\n+\n+Each port has a unique per-task identity and may not be replicated or\n+transmitted. If a port value is copied, both copies refer to the same\n+port.  Ports may be associated with multiple `chan`s.\n+\"]\n enum port<T: send> { port_t(@port_ptr<T>) }\n \n-#[doc(\n-  brief = \"Sends data over a channel. The sent data is moved \\\n-           into the channel, whereupon the caller loses \\\n-           access to it.\"\n-)]\n+#[doc = \"\n+Sends data over a channel. The sent data is moved into the channel,\n+whereupon the caller loses access to it.\n+\"]\n fn send<T: send>(ch: chan<T>, -data: T) {\n     let chan_t(t, p) = ch;\n     let res = rustrt::chan_id_send(sys::get_type_desc::<T>(), t, p, data);\n@@ -129,23 +128,18 @@ fn send<T: send>(ch: chan<T>, -data: T) {\n     task::yield();\n }\n \n-#[doc(\n-  brief = \"Constructs a port.\"\n-)]\n+#[doc = \"Constructs a port\"]\n fn port<T: send>() -> port<T> {\n     port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>())))\n }\n \n-#[doc(\n-  brief = \"Receive from a port. \\\n-           If no data is available on the port then the task will \\\n-           block until data becomes available.\"\n-)]\n+#[doc = \"\n+Receive from a port.  If no data is available on the port then the\n+task will block until data becomes available.\n+\"]\n fn recv<T: send>(p: port<T>) -> T { recv_(***p) }\n \n-#[doc(\n-  brief = \"Receive on a raw port pointer\"\n-)]\n+#[doc = \"Receive on a raw port pointer\"]\n fn recv_<T: send>(p: *rust_port) -> T {\n     // FIXME: Due to issue 1185 we can't use a return pointer when\n     // calling C code, and since we can't create our own return\n@@ -218,10 +212,10 @@ fn peek<T: send>(p: port<T>) -> bool {\n     rustrt::rust_port_size(***p) != 0u as ctypes::size_t\n }\n \n-#[doc(\n-  brief = \"Constructs a channel. The channel is bound to the \\\n-           port used to construct it.\"\n-)]\n+#[doc = \"\n+Constructs a channel. The channel is bound to the port used to\n+construct it.\n+\"]\n fn chan<T: send>(p: port<T>) -> chan<T> {\n     chan_t(rustrt::get_task_id(), rustrt::get_port_id(***p))\n }"}, {"sha": "4edea85dd5338f6521e805c9627579f17a6e8432", "filename": "src/libcore/core.rc", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -10,9 +10,8 @@\n // Don't link to core. We are core.\n #[no_core];\n \n-#[doc(\n-    brief = \"The Rust core library\",\n-    desc = \"\n+#[doc = \"\n+The Rust core library\n \n The core library provides functionality that is closely tied to the Rust\n built-in types and runtime services, or that is used in nearly every\n@@ -24,9 +23,8 @@ as though the user had written the following:\n     use core;\n     import core::*;\n \n-This behavior can be disabled with the `no_core` crate attribute.\"\n-\n-)];\n+This behavior can be disabled with the `no_core` crate attribute.\n+\"];\n \n export int, i8, i16, i32, i64;\n export uint, u8, u16, u32, u64;"}, {"sha": "f83065ff5013d9a7d80b34e55b538142882fc5ab", "filename": "src/libcore/core.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -40,13 +40,11 @@ mod std {\n     import std::test;\n }\n \n-/*\n-Function: unreachable\n-\n+#[doc = \"\n A standard function to use to indicate unreachable code. Because the\n function is guaranteed to fail typestate will correctly identify\n any code paths following the appearance of this function as unreachable.\n-*/\n+\"]\n fn unreachable() -> ! {\n     fail \"Internal error: entered unreachable code\";\n }"}, {"sha": "009ce986631c637de1ac08acc764af458ceb8d41", "filename": "src/libcore/ctypes.rs", "status": "modified", "additions": 33, "deletions": 63, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fctypes.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -19,103 +19,73 @@ export enum;\n #[doc = \"A signed integer with the same size as a C `char`.\"]\n type c_char = i8;\n \n-#[doc(\n-  brief = \"A signed integer with the same size as a C `int`.\"\n-)]\n+#[doc = \"A signed integer with the same size as a C `int`.\"]\n type c_int = i32;\n \n-#[doc(\n-  brief = \"An unsigned integer with the same size as a C `unsigned int`.\"\n-)]\n+#[doc = \"An unsigned integer with the same size as a C `unsigned int`.\"]\n type c_uint = u32;\n \n-#[doc(\n-  brief = \"A signed integer with the same size as a C `long`.\"\n-)]\n+#[doc = \"A signed integer with the same size as a C `long`.\"]\n type long = int;\n \n-#[doc(\n-  brief = \"A signed integer with the same size as a C `long long`.\"\n-)]\n+#[doc = \"A signed integer with the same size as a C `long long`.\"]\n type longlong = i64;\n \n-#[doc(\n-  brief = \"A signed integer with the same size as a C `unsigned int`.\"\n-)]\n+#[doc = \"A signed integer with the same size as a C `unsigned int`.\"]\n type unsigned = u32;\n \n-#[doc(\n-  brief = \"A signed integer with the same size as a C `unsigned long`.\"\n-)]\n+#[doc = \"A signed integer with the same size as a C `unsigned long`.\"]\n type ulong = uint;\n \n-#[doc(\n-  brief = \"A signed integer with the same size as a C `unsigned long long`.\"\n-)]\n+#[doc = \"A signed integer with the same size as a C `unsigned long long`.\"]\n type ulonglong = u64;\n \n-#[doc(\n-  brief = \"A signed integer with the same size as a pointer. \\\n-           This is guaranteed to always be the same type as a \\\n-            Rust `int`.\"\n-)]\n+#[doc = \"\n+A signed integer with the same size as a pointer.  This is guaranteed\n+to always be the same type as a Rust `int`.\n+\"]\n type intptr_t = uint; // FIXME: int\n \n-#[doc(\n-  brief = \"An unsigned integer with the same size as a pointer. \\\n-           This is guaranteed to always be the same type as a Rust \\\n-           `uint`.\"\n-)]\n+#[doc = \"\n+An unsigned integer with the same size as a pointer.  This is\n+guaranteed to always be the same type as a Rust `uint`.\n+\"]\n type uintptr_t = uint;\n type uint32_t = u32;\n \n-#[doc(\n-  brief = \"A type, a pointer to which can be used as C `void *`.\",\n-  desc = \"The void type cannot be constructed or destructured, \\\n-         but using pointers to this type when interoperating \\\n-         with C void pointers can help in documentation.\"\n-)]\n+#[doc = \"\n+A type, a pointer to which can be used as C `void *`.\n+\n+The void type cannot be constructed or destructured, but using\n+pointers to this type when interoperating with C void pointers can\n+help in documentation.\n+\"]\n enum void {}\n \n-#[doc(\n-  brief = \"A float value with the same size as a C `float`.\"\n-)]\n+#[doc = \"A float value with the same size as a C `float`.\"]\n type c_float = f32;\n \n-#[doc(\n-  brief = \"A float value with the same size as a C `double`.\"\n-)]\n+#[doc = \"A float value with the same size as a C `double`.\"]\n type c_double = f64;\n \n-#[doc(\n-  brief = \"An unsigned integer corresponding to the C `size_t`.\"\n-)]\n+#[doc = \"An unsigned integer corresponding to the C `size_t`.\"]\n type size_t = uint;\n \n-#[doc(\n-  brief = \"A signed integer corresponding to the C `ssize_t`.\"\n-)]\n+#[doc = \"A signed integer corresponding to the C `ssize_t`.\"]\n type ssize_t = int;\n \n-#[doc(\n-  brief = \"An unsigned integer corresponding to the C `off_t`.\"\n-)]\n+#[doc = \"An unsigned integer corresponding to the C `off_t`.\"]\n type off_t = uint;\n \n-#[doc(\n-  brief = \"A type that can be used for C file descriptors.\"\n-)]\n+#[doc = \"A type that can be used for C file descriptors.\"]\n type fd_t = i32;      // not actually a C type, but should be.\n \n-#[doc(\n-  brief = \"A type for representing process ID's, corresponding to C `pid_t`.\"\n-)]\n+#[doc = \"A type for representing process ID's, corresponding to C `pid_t`.\"]\n type pid_t = i32;\n \n-#[doc(\n-  brief = \"An unsigned integer with the same size as a C enum. \\\n-           enum is implementation-defined, but is 32-bits in \\\n-           practice\"\n-)]\n+#[doc = \"\n+An unsigned integer with the same size as a C enum.  enum is\n+implementation-defined, but is 32-bits in practice\n+\"]\n type enum = u32;\n "}, {"sha": "175c93a3409f2eea11185d2672d2cf4f908ba86a", "filename": "src/libcore/either.rs", "status": "modified", "additions": 44, "deletions": 74, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,75 +1,53 @@\n-/*\n-Module: either\n+#[doc = \"A type that represents one of two alternatives\"];\n \n-A type that represents one of two alternatives\n-*/\n-\n-\n-/*\n-Tag: t\n-\n-The either type\n-*/\n+#[doc = \"The either type\"]\n enum t<T, U> {\n-    /* Variant: left */\n     left(T),\n-    /* Variant: right */\n     right(U)\n }\n \n-/* Section: Operations */\n+fn either<T, U, V>(f_left: fn(T) -> V,\n+                   f_right: fn(U) -> V, value: t<T, U>) -> V {\n+    #[doc = \"\n+    Applies a function based on the given either value\n \n-/*\n-Function: either\n+    If `value` is left(T) then `f_left` is applied to its contents, if `value`\n+    is right(U) then `f_right` is applied to its contents, and the result is\n+    returned.\n+    \"];\n \n-Applies a function based on the given either value\n-\n-If `value` is left(T) then `f_left` is applied to its contents, if\n-`value` is right(U) then `f_right` is applied to its contents, and\n-the result is returned.\n-*/\n-fn either<T, U,\n-          V>(f_left: fn(T) -> V, f_right: fn(U) -> V, value: t<T, U>) ->\n-   V {\n     alt value { left(l) { f_left(l) } right(r) { f_right(r) } }\n }\n \n-/*\n-Function: lefts\n-\n-Extracts from a vector of either all the left values.\n-*/\n fn lefts<T: copy, U>(eithers: [t<T, U>]) -> [T] {\n+    #[doc = \"Extracts from a vector of either all the left values\"];\n+\n     let mut result: [T] = [];\n     for elt: t<T, U> in eithers {\n         alt elt { left(l) { result += [l]; } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n-/*\n-Function: rights\n-\n-Extracts from a vector of either all the right values\n-*/\n fn rights<T, U: copy>(eithers: [t<T, U>]) -> [U] {\n+    #[doc = \"Extracts from a vector of either all the right values\"];\n+\n     let mut result: [U] = [];\n     for elt: t<T, U> in eithers {\n         alt elt { right(r) { result += [r]; } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n-/*\n-Function: partition\n-\n-Extracts from a vector of either all the left values and right values\n-\n-Returns a structure containing a vector of left values and a vector of\n-right values.\n-*/\n fn partition<T: copy, U: copy>(eithers: [t<T, U>])\n     -> {lefts: [T], rights: [U]} {\n+    #[doc = \"\n+    Extracts from a vector of either all the left values and right values\n+\n+    Returns a structure containing a vector of left values and a vector of\n+    right values.\n+    \"];\n+\n     let mut lefts: [T] = [];\n     let mut rights: [U] = [];\n     for elt: t<T, U> in eithers {\n@@ -78,59 +56,41 @@ fn partition<T: copy, U: copy>(eithers: [t<T, U>])\n     ret {lefts: lefts, rights: rights};\n }\n \n-/*\n-Function: flip\n-\n-Flips between left and right of a given either\n-*/\n pure fn flip<T: copy, U: copy>(eith: t<T, U>) -> t<U, T> {\n+    #[doc = \"Flips between left and right of a given either\"];\n+\n     alt eith {\n       right(r) { left(r) }\n       left(l) { right(l) }\n     }\n }\n \n-/*\n-Function: to_result\n-\n-Converts either::t to a result::t, making the \"right\" choice\n-an ok result, and the \"left\" choice a fail\n-*/\n pure fn to_result<T: copy, U: copy>(eith: t<T, U>) -> result::t<U, T> {\n+    #[doc = \"\n+    Converts either::t to a result::t\n+\n+    Converts an `either` type to a `result` type, making the \\\"right\\\" choice\n+    an ok result, and the \\\"left\\\" choice a fail\n+    \"];\n+\n     alt eith {\n       right(r) { result::ok(r) }\n       left(l) { result::err(l) }\n     }\n }\n \n-/*\n-Function: is_left\n-\n-Checks whether the given value is a left\n-*/\n pure fn is_left<T, U>(eith: t<T, U>) -> bool {\n+    #[doc = \"Checks whether the given value is a left\"];\n+\n     alt eith { left(_) { true } _ { false } }\n }\n \n-/*\n-Function: is_right\n-\n-Checks whether the given value is a right\n-*/\n pure fn is_right<T, U>(eith: t<T, U>) -> bool {\n+    #[doc = \"Checks whether the given value is a right\"];\n+\n     alt eith { right(_) { true } _ { false } }\n }\n \n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//\n-\n #[test]\n fn test_either_left() {\n     let val = left(10);\n@@ -223,3 +183,13 @@ fn test_partition_empty() {\n     assert (vec::len(result.lefts) == 0u);\n     assert (vec::len(result.rights) == 0u);\n }\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "85a74ba6ed5852a28ddf64020dcb308ab786e0af", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,3 +1,5 @@\n+#[doc(hidden)];\n+\n /*\n Syntax Extension: fmt\n "}, {"sha": "3e3a172ba81e51f23540d67e5a6f277a749c95cf", "filename": "src/libcore/f32.rs", "status": "modified", "additions": 34, "deletions": 67, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff32.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -58,56 +58,49 @@ pure fn gt(x: f32, y: f32) -> bool { ret x > y; }\n // FIXME replace the predicates below with llvm intrinsics or calls\n // to the libmath macros in the rust runtime for performance\n \n-#[doc(\n-  brief = \"Returns true if `x` is a positive number, including +0.0f320 \\\n-           and +Infinity.\"\n-)]\n+#[doc = \"\n+Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n+\"]\n pure fn is_positive(x: f32) -> bool\n     { ret x > 0.0f32 || (1.0f32/x) == infinity; }\n \n-#[doc(\n-  brief = \"Returns true if `x` is a negative number, including -0.0f320 \\\n-           and -Infinity.\"\n-)]\n+#[doc = \"\n+Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n+\"]\n pure fn is_negative(x: f32) -> bool\n     { ret x < 0.0f32 || (1.0f32/x) == neg_infinity; }\n \n-#[doc(\n-  brief = \"Returns true if `x` is a negative number, including \\\n-           -0.0f320 and -Infinity. (This is the same as \\\n-           `f32::negative`.)\"\n-)]\n+#[doc = \"\n+Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n+\n+This is the same as `f32::is_negative`.\n+\"]\n pure fn is_nonpositive(x: f32) -> bool {\n   ret x < 0.0f32 || (1.0f32/x) == neg_infinity;\n }\n \n-#[doc(\n-  brief = \"Returns true if `x` is a positive number, \\\n-           including +0.0f320 and +Infinity. (This is \\\n-           the same as `f32::positive`.)\"\n-)]\n+#[doc = \"\n+Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n+\n+This is the same as `f32::is_positive`.)\n+\"]\n pure fn is_nonnegative(x: f32) -> bool {\n   ret x > 0.0f32 || (1.0f32/x) == infinity;\n }\n \n-#[doc(\n-  brief = \"Returns true if `x` is a zero number \\\n-  (positive or negative zero)\"\n-)]\n+#[doc = \"\n+Returns true if `x` is a zero number (positive or negative zero)\n+\"]\n pure fn is_zero(x: f32) -> bool {\n     ret x == 0.0f32 || x == -0.0f32;\n }\n \n-#[doc(\n-  brief = \"Returns true if `x`is an infinite number\"\n-)]\n+#[doc = \"Returns true if `x`is an infinite number\"]\n pure fn is_infinite(x: f32) -> bool {\n     ret x == infinity || x == neg_infinity;\n }\n \n-#[doc(\n-  brief = \"Returns true if `x`is a finite number\"\n-)]\n+#[doc = \"Returns true if `x`is a finite number\"]\n pure fn is_finite(x: f32) -> bool {\n     ret !(is_NaN(x) || is_infinite(x));\n }\n@@ -118,69 +111,43 @@ pure fn is_finite(x: f32) -> bool {\n mod consts {\n \n     // FIXME replace with mathematical constants from cmath\n-    #[doc(\n-      brief = \"Archimedes' constant\"\n-    )]\n+    #[doc = \"Archimedes' constant\"]\n     const pi: f32 = 3.14159265358979323846264338327950288_f32;\n \n-    #[doc(\n-      brief = \"pi/2.0\"\n-    )]\n+    #[doc = \"pi/2.0\"]\n     const frac_pi_2: f32 = 1.57079632679489661923132169163975144_f32;\n \n-    #[doc(\n-      brief = \"pi/4.0\"\n-    )]\n+    #[doc = \"pi/4.0\"]\n     const frac_pi_4: f32 = 0.785398163397448309615660845819875721_f32;\n \n-    #[doc(\n-      brief = \"1.0/pi\"\n-    )]\n+    #[doc = \"1.0/pi\"]\n     const frac_1_pi: f32 = 0.318309886183790671537767526745028724_f32;\n \n-    #[doc(\n-      brief = \"2.0/pi\"\n-    )]\n+    #[doc = \"2.0/pi\"]\n     const frac_2_pi: f32 = 0.636619772367581343075535053490057448_f32;\n \n-    #[doc(\n-      brief = \"2.0/sqrt(pi)\"\n-    )]\n+    #[doc = \"2.0/sqrt(pi)\"]\n     const frac_2_sqrtpi: f32 = 1.12837916709551257389615890312154517_f32;\n \n-    #[doc(\n-      brief = \"sqrt(2.0)\"\n-    )]\n+    #[doc = \"sqrt(2.0)\"]\n     const sqrt2: f32 = 1.41421356237309504880168872420969808_f32;\n \n-    #[doc(\n-      brief = \"1.0/sqrt(2.0)\"\n-    )]\n+    #[doc = \"1.0/sqrt(2.0)\"]\n     const frac_1_sqrt2: f32 = 0.707106781186547524400844362104849039_f32;\n \n-    #[doc(\n-      brief = \"Euler's number\"\n-    )]\n+    #[doc = \"Euler's number\"]\n     const e: f32 = 2.71828182845904523536028747135266250_f32;\n \n-    #[doc(\n-      brief = \"log2(e)\"\n-    )]\n+    #[doc = \"log2(e)\"]\n     const log2_e: f32 = 1.44269504088896340735992468100189214_f32;\n \n-    #[doc(\n-      brief = \"log10(e)\"\n-    )]\n+    #[doc = \"log10(e)\"]\n     const log10_e: f32 = 0.434294481903251827651128918916605082_f32;\n \n-    #[doc(\n-      brief = \"ln(2.0)\"\n-    )]\n+    #[doc = \"ln(2.0)\"]\n     const ln_2: f32 = 0.693147180559945309417232121458176568_f32;\n \n-    #[doc(\n-      brief = \"ln(10.0)\"\n-    )]\n+    #[doc = \"ln(10.0)\"]\n     const ln_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n "}, {"sha": "214fcc80188b650f5751d6bc119bbc198aa6adc3", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 32, "deletions": 67, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -76,56 +76,47 @@ pure fn ge(x: f64, y: f64) -> bool { ret x >= y; }\n \n pure fn gt(x: f64, y: f64) -> bool { ret x > y; }\n \n-#[doc(\n-  brief = \"Returns true if `x` is a positive number, including \\\n-           +0.0f640 and +Infinity.\"\n-)]\n+#[doc = \"\n+Returns true if `x` is a positive number, including +0.0f640 and +Infinity.\n+\"]\n pure fn is_positive(x: f64) -> bool\n     { ret x > 0.0f64 || (1.0f64/x) == infinity; }\n \n-#[doc(\n-  brief = \"Returns true if `x` is a negative number, including \\\n-           -0.0f640 and -Infinity.\"\n-)]\n+#[doc = \"\n+Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n+\"]\n pure fn is_negative(x: f64) -> bool\n     { ret x < 0.0f64 || (1.0f64/x) == neg_infinity; }\n \n-#[doc(\n-  brief = \"Returns true if `x` is a negative number, including \\\n-           -0.0f640 and -Infinity. (This is the same as \\\n-           `f64::negative`.)\"\n-)]\n+#[doc = \"\n+Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n+\n+This is the same as `f64::is_negative`.\n+\"]\n pure fn is_nonpositive(x: f64) -> bool {\n   ret x < 0.0f64 || (1.0f64/x) == neg_infinity;\n }\n \n-#[doc(\n-  brief = \"Returns true if `x` is a positive number, including \\\n-           +0.0f640 and +Infinity.(This is the same as \\\n-           `f64::positive`.)\"\n-)]\n+#[doc = \"\n+Returns true if `x` is a positive number, including +0.0f640 and +Infinity\n+\n+This is the same as `f64::positive`.\n+\"]\n pure fn is_nonnegative(x: f64) -> bool {\n   ret x > 0.0f64 || (1.0f64/x) == infinity;\n }\n \n-#[doc(\n-  brief = \"Returns true if `x` is a zero number (positive or \\\n-           negative zero)\"\n-)]\n+#[doc = \"Returns true if `x` is a zero number (positive or negative zero)\"]\n pure fn is_zero(x: f64) -> bool {\n     ret x == 0.0f64 || x == -0.0f64;\n }\n \n-#[doc(\n-  brief = \"Returns true if `x`is an infinite number.\"\n-)]\n+#[doc = \"Returns true if `x`is an infinite number\"]\n pure fn is_infinite(x: f64) -> bool {\n     ret x == infinity || x == neg_infinity;\n }\n \n-#[doc(\n-  brief = \"Returns true if `x`is a finite number.\"\n-)]\n+#[doc = \"Returns true if `x`is a finite number\"]\n pure fn is_finite(x: f64) -> bool {\n     ret !(is_NaN(x) || is_infinite(x));\n }\n@@ -137,69 +128,43 @@ mod consts {\n \n     // FIXME replace with mathematical constants from cmath\n \n-    #[doc(\n-      brief = \"Archimedes' constant\"\n-    )]\n+    #[doc = \"Archimedes' constant\"]\n     const pi: f64 = 3.14159265358979323846264338327950288_f64;\n \n-    #[doc(\n-      brief = \"pi/2.0\"\n-    )]\n+    #[doc = \"pi/2.0\"]\n     const frac_pi_2: f64 = 1.57079632679489661923132169163975144_f64;\n \n-    #[doc(\n-      brief = \"pi/4.0\"\n-    )]\n+    #[doc = \"pi/4.0\"]\n     const frac_pi_4: f64 = 0.785398163397448309615660845819875721_f64;\n \n-    #[doc(\n-      brief = \"1.0/pi\"\n-    )]\n+    #[doc = \"1.0/pi\"]\n     const frac_1_pi: f64 = 0.318309886183790671537767526745028724_f64;\n \n-    #[doc(\n-      brief = \"2.0/pi\"\n-    )]\n+    #[doc = \"2.0/pi\"]\n     const frac_2_pi: f64 = 0.636619772367581343075535053490057448_f64;\n \n-    #[doc(\n-      brief = \"2.0/sqrt(pi)\"\n-    )]\n+    #[doc = \"2.0/sqrt(pi)\"]\n     const frac_2_sqrtpi: f64 = 1.12837916709551257389615890312154517_f64;\n \n-    #[doc(\n-      brief = \"sqrt(2.0)\"\n-    )]\n+    #[doc = \"sqrt(2.0)\"]\n     const sqrt2: f64 = 1.41421356237309504880168872420969808_f64;\n \n-    #[doc(\n-      brief = \"1.0/sqrt(2.0)\"\n-    )]\n+    #[doc = \"1.0/sqrt(2.0)\"]\n     const frac_1_sqrt2: f64 = 0.707106781186547524400844362104849039_f64;\n \n-    #[doc(\n-      brief = \"Euler's number\"\n-    )]\n+    #[doc = \"Euler's number\"]\n     const e: f64 = 2.71828182845904523536028747135266250_f64;\n \n-    #[doc(\n-      brief = \"log2(e)\"\n-    )]\n+    #[doc = \"log2(e)\"]\n     const log2_e: f64 = 1.44269504088896340735992468100189214_f64;\n \n-    #[doc(\n-      brief = \"log10(e)\"\n-    )]\n+    #[doc = \"log10(e)\"]\n     const log10_e: f64 = 0.434294481903251827651128918916605082_f64;\n \n-    #[doc(\n-      brief = \"ln(2.0)\"\n-    )]\n+    #[doc = \"ln(2.0)\"]\n     const ln_2: f64 = 0.693147180559945309417232121458176568_f64;\n \n-    #[doc(\n-      brief = \"ln(10.0)\"\n-    )]\n+    #[doc = \"ln(10.0)\"]\n     const ln_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n "}, {"sha": "aec7fd8b0ed64ed43552063c6eb1a8a3c79a91d8", "filename": "src/libcore/float.rs", "status": "modified", "additions": 45, "deletions": 55, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,9 +1,5 @@\n #[doc = \"Operations and constants for `float`\"];\n \n-/*\n-Module: float\n-*/\n-\n // FIXME find out why these have to be exported explicitly\n \n export to_str_common, to_str_exact, to_str, from_str;\n@@ -36,17 +32,15 @@ type t = float;\n  * Section: String Conversions\n  */\n \n-/*\n-Function: to_str_common\n-\n+#[doc = \"\n Converts a float to a string\n \n-Parameters:\n+# Arguments\n \n-num - The float value\n-digits - The number of significant digits\n-exact - Whether to enforce the exact number of significant digits\n-*/\n+* num - The float value\n+* digits - The number of significant digits\n+* exact - Whether to enforce the exact number of significant digits\n+\"]\n fn to_str_common(num: float, digits: uint, exact: bool) -> str {\n     if is_NaN(num) { ret \"NaN\"; }\n     let mut (num, accum) = if num < 0.0 { (-num, \"-\") } else { (num, \"\") };\n@@ -69,17 +63,15 @@ fn to_str_common(num: float, digits: uint, exact: bool) -> str {\n \n }\n \n-/*\n-Function: to_str\n-\n-Converts a float to a string with exactly the number of provided significant\n-digits\n+#[doc = \"\n+Converts a float to a string with exactly the number of\n+provided significant digits\n \n-Parameters:\n+# Arguments\n \n-num - The float value\n-digits - The number of significant digits\n-*/\n+* num - The float value\n+* digits - The number of significant digits\n+\"]\n fn to_str_exact(num: float, digits: uint) -> str {\n     to_str_common(num, digits, true)\n }\n@@ -90,47 +82,45 @@ fn test_to_str_exact_do_decimal() {\n     assert s == \"5.0000\";\n }\n \n-/*\n-Function: to_str\n \n-Converts a float to a string with a maximum number of significant digits\n+#[doc = \"\n+Converts a float to a string with a maximum number of\n+significant digits\n \n-Parameters:\n+# Arguments\n \n-num - The float value\n-digits - The number of significant digits\n-*/\n+* num - The float value\n+* digits - The number of significant digits\n+\"]\n fn to_str(num: float, digits: uint) -> str {\n     to_str_common(num, digits, false)\n }\n \n-/*\n-Function: from_str\n-\n+#[doc = \"\n Convert a string to a float\n \n This function accepts strings such as\n-* \"3.14\"\n-* \"+3.14\", equivalent to \"3.14\"\n-* \"-3.14\"\n-* \"2.5E10\", or equivalently, \"2.5e10\"\n-* \"2.5E-10\"\n-* \"\", or, equivalently, \".\" (understood as 0)\n-* \"5.\"\n-* \".5\", or, equivalently,  \"0.5\"\n+\n+* '3.14'\n+* '+3.14', equivalent to '3.14'\n+* '-3.14'\n+* '2.5E10', or equivalently, '2.5e10'\n+* '2.5E-10'\n+* '', or, equivalently, '.' (understood as 0)\n+* '5.'\n+* '.5', or, equivalently,  '0.5'\n \n Leading and trailing whitespace are ignored.\n \n-Parameters:\n+# Arguments\n \n-num - A string\n+* num - A string\n \n-Returns:\n+# Return value\n \n-none if the string did not represent a valid number.\n-Otherwise, some(n) where n is the floating-point\n-number represented by [num].\n-*/\n+`none` if the string did not represent a valid number.  Otherwise, `some(n)`\n+where `n` is the floating-point number represented by `[num]`.\n+\"]\n fn from_str(num: str) -> option<float> {\n    let mut pos = 0u;               //Current byte position in the string.\n                                    //Used to walk the string in O(n).\n@@ -256,18 +246,18 @@ fn from_str(num: str) -> option<float> {\n  * Section: Arithmetics\n  */\n \n-/*\n-Function: pow_with_uint\n+#[doc = \"\n+Compute the exponentiation of an integer by another integer as a float\n+\n+# Arguments\n \n-Compute the exponentiation of an integer by another integer as a float.\n+* x - The base\n+* pow - The exponent\n \n-Parameters:\n-x - The base.\n-pow - The exponent.\n+# Return value\n \n-Returns:\n-<NaN> of both `x` and `pow` are `0u`, otherwise `x^pow`.\n-*/\n+`NaN` if both `x` and `pow` are `0u`, otherwise `x^pow`\n+\"]\n fn pow_with_uint(base: uint, pow: uint) -> float {\n    if base == 0u {\n       if pow == 0u {"}, {"sha": "faf5cca0e6c36f4e29f80892f285cb89e27ac3c8", "filename": "src/libcore/future.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,14 +1,14 @@\n #[doc = \"\n-\n A type representing values that may be computed concurrently and\n operations for working with them.\n \n-Example:\n-\n-> let delayed_fib = future::spawn {|| fib(5000) };\n-> make_a_sandwitch();\n-> io::println(#fmt(\\\"fib(5000) = %?\\\", delayed_fib.get()))\n+# Example\n \n+~~~\n+let delayed_fib = future::spawn {|| fib(5000) };\n+make_a_sandwitch();\n+io::println(#fmt(\\\"fib(5000) = %?\\\", delayed_fib.get()))\n+~~~\n \"];\n \n export future;\n@@ -45,10 +45,10 @@ impl future<A:send> for future<A> {\n \n fn from_value<A>(+val: A) -> future<A> {\n     #[doc = \"\n+    Create a future from a value\n \n-    Create a future from a value. The value is immediately available\n-    and calling `get` later will not block.\n-\n+    The value is immediately available and calling `get` later will\n+    not block.\n     \"];\n \n     future({\n@@ -58,11 +58,10 @@ fn from_value<A>(+val: A) -> future<A> {\n \n fn from_port<A:send>(-port: comm::port<A>) -> future<A> {\n     #[doc = \"\n+    Create a future from a port\n \n-    Create a future from a port. The first time that the value is\n-    requested the task will block waiting for the result to be\n-    received on the port.\n-\n+    The first time that the value is requested the task will block\n+    waiting for the result to be received on the port.\n     \"];\n \n     from_fn {||\n@@ -72,12 +71,11 @@ fn from_port<A:send>(-port: comm::port<A>) -> future<A> {\n \n fn from_fn<A>(f: fn@() -> A) -> future<A> {\n     #[doc = \"\n+    Create a future from a function.\n \n-    Create a future from a function. The first time that the value is\n-    requested it will be retreived by calling the function.\n-\n-    Note that this function is a local function. It is not spawned into\n-    another task.\n+    The first time that the value is requested it will be retreived by\n+    calling the function.  Note that this function is a local\n+    function. It is not spawned into another task.\n     \"];\n \n     future({\n@@ -87,10 +85,10 @@ fn from_fn<A>(f: fn@() -> A) -> future<A> {\n \n fn spawn<A:send>(+blk: fn~() -> A) -> future<A> {\n     #[doc = \"\n+    Create a future from a unique closure.\n \n-    Create a future from a unique closure. The closure will be run\n-    in a new task and its result used as the value of the future.\n-\n+    The closure will be run in a new task and its result used as the\n+    value of the future.\n     \"];\n \n     let mut po = comm::port();"}, {"sha": "b0e918fdd99f79f97540e98a2aa23ec086f9535f", "filename": "src/libcore/int.rs", "status": "modified", "additions": 11, "deletions": 78, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,25 +1,11 @@\n #[doc = \"Operations and constants for `int`\"];\n \n-/*\n-Module: int\n-*/\n-\n-/*\n-Const: min_value\n-\n-The minumum value of an integer\n-*/\n #[cfg(target_arch=\"x86\")]\n const min_value: int = -1 << 31;\n \n #[cfg(target_arch=\"x86_64\")]\n const min_value: int = -1 << 63;\n \n-/*\n-Const: max_value\n-\n-The maximum value of an integer\n-*/\n // FIXME: Find another way to access the machine word size in a const expr\n #[cfg(target_arch=\"x86\")]\n const max_value: int = (-1 << 31)-1;\n@@ -30,80 +16,43 @@ const max_value: int = (-1 << 63)-1;\n pure fn min(x: int, y: int) -> int { if x < y { x } else { y } }\n pure fn max(x: int, y: int) -> int { if x > y { x } else { y } }\n \n-/* Function: add */\n pure fn add(x: int, y: int) -> int { ret x + y; }\n-\n-/* Function: sub */\n pure fn sub(x: int, y: int) -> int { ret x - y; }\n-\n-/* Function: mul */\n pure fn mul(x: int, y: int) -> int { ret x * y; }\n-\n-/* Function: div */\n pure fn div(x: int, y: int) -> int { ret x / y; }\n-\n-/* Function: rem */\n pure fn rem(x: int, y: int) -> int { ret x % y; }\n \n-/* Predicate: lt */\n pure fn lt(x: int, y: int) -> bool { ret x < y; }\n-\n-/* Predicate: le */\n pure fn le(x: int, y: int) -> bool { ret x <= y; }\n-\n-/* Predicate: eq */\n pure fn eq(x: int, y: int) -> bool { ret x == y; }\n-\n-/* Predicate: ne */\n pure fn ne(x: int, y: int) -> bool { ret x != y; }\n-\n-/* Predicate: ge */\n pure fn ge(x: int, y: int) -> bool { ret x >= y; }\n-\n-/* Predicate: gt */\n pure fn gt(x: int, y: int) -> bool { ret x > y; }\n \n-/* Predicate: positive */\n pure fn positive(x: int) -> bool { ret x > 0; }\n-\n-/* Predicate: negative */\n pure fn negative(x: int) -> bool { ret x < 0; }\n-\n-/* Predicate: nonpositive */\n pure fn nonpositive(x: int) -> bool { ret x <= 0; }\n-\n-/* Predicate: nonnegative */\n pure fn nonnegative(x: int) -> bool { ret x >= 0; }\n \n \n // FIXME: Make sure this works with negative integers.\n-/*\n-Function: hash\n-\n-Produce a uint suitable for use in a hash table\n-*/\n+#[doc = \"Produce a uint suitable for use in a hash table\"]\n fn hash(x: int) -> uint { ret x as uint; }\n \n-/*\n-Function: range\n-\n-Iterate over the range [`lo`..`hi`)\n-*/\n+#[doc = \"Iterate over the range `[lo..hi)`\"]\n fn range(lo: int, hi: int, it: fn(int)) {\n     let mut i = lo;\n     while i < hi { it(i); i += 1; }\n }\n \n-/*\n-Function: parse_buf\n-\n+#[doc = \"\n Parse a buffer of bytes\n \n-Parameters:\n+# Arguments\n \n-buf - A byte buffer\n-radix - The base of the number\n-*/\n+* buf - A byte buffer\n+* radix - The base of the number\n+\"]\n fn parse_buf(buf: [u8], radix: uint) -> option<int> {\n     if vec::len(buf) == 0u { ret none; }\n     let mut i = vec::len(buf) - 1u;\n@@ -127,37 +76,21 @@ fn parse_buf(buf: [u8], radix: uint) -> option<int> {\n     fail;\n }\n \n-/*\n-Function: from_str\n-\n-Parse a string to an int\n-*/\n+#[doc = \"Parse a string to an int\"]\n fn from_str(s: str) -> option<int> { parse_buf(str::bytes(s), 10u) }\n \n-/*\n-Function: to_str\n-\n-Convert to a string in a given base\n-*/\n+#[doc = \"Convert to a string in a given base\"]\n fn to_str(n: int, radix: uint) -> str {\n     assert (0u < radix && radix <= 16u);\n     ret if n < 0 {\n             \"-\" + uint::to_str(-n as uint, radix)\n         } else { uint::to_str(n as uint, radix) };\n }\n \n-/*\n-Function: str\n-\n-Convert to a string\n-*/\n+#[doc = \"Convert to a string\"]\n fn str(i: int) -> str { ret to_str(i, 10u); }\n \n-/*\n-Function: pow\n-\n-Returns `base` raised to the power of `exponent`\n-*/\n+#[doc = \"Returns `base` raised to the power of `exponent`\"]\n fn pow(base: int, exponent: uint) -> int {\n     if exponent == 0u { ret 1; } //Not mathemtically true if [base == 0]\n     if base     == 0  { ret 0; }"}, {"sha": "48e3fcc2ff24384cb6b479f5958775a1b1407cce", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -13,14 +13,13 @@ fn console_on() {\n     rustrt::rust_log_console_on();\n }\n \n-#[doc(\n-    brief =\n-    \"Turns off logging to stdout globally\",\n-    desc =\n-    \"Turns off the console unless the user has overridden the \\\n-     runtime environment's logging spec, e.g. by setting \\\n-     the RUST_LOG environment variable\"\n-)]\n+#[doc = \"\n+Turns off logging to stdout globally\n+\n+Turns off the console unless the user has overridden the\n+runtime environment's logging spec, e.g. by setting\n+the RUST_LOG environment variable\n+\"]\n fn console_off() {\n     rustrt::rust_log_console_off();\n }\n\\ No newline at end of file"}, {"sha": "9e14091a5329ad14169d9f3158d8c3bf5d52c8a8", "filename": "src/libcore/math.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmath.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,19 +1,13 @@\n-// Generic functions that have been defined for all numeric types\n-//\n-// (may very well go away again soon)\n+#[doc = \"\n+Generic functions that have been defined for all numeric types\n \n-/*\n-Function: min\n+(may very well go away again soon)\n+\"];\n \n-Returns the minimum of two values\n-*/\n+#[doc = \"Returns the minimum of two values\"]\n pure fn min<T: copy>(x: T, y: T) -> T { if x < y { x } else { y} }\n \n-/*\n-Function: max\n-\n-Returns the maximum of two values\n-*/\n+#[doc = \"Returns the maximum of two values\"]\n pure fn max<T: copy>(x: T, y: T) -> T { if x < y { y } else { x } }\n \n #[test]"}, {"sha": "47e407e49524da7707bfabf919bb271e3bfb22bd", "filename": "src/libcore/option.rs", "status": "modified", "additions": 40, "deletions": 64, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,107 +1,83 @@\n-/*\n-Module: option\n+#[doc = \"\n+Operations on the ubiquitous `option` type.\n \n-Represents the presence or absence of a value.\n+Type `option` represents an optional value.\n \n-Every option<T> value can either be some(T) or none. Where in other languages\n-you might use a nullable type, in Rust you would use an option type.\n-*/\n+Every `option<T>` value can either be `some(T)` or `none`. Where in other\n+languages you might use a nullable type, in Rust you would use an option type.\n+\"];\n \n-/*\n-Tag: t\n-\n-The option type\n-*/\n+#[doc = \"The option type\"]\n enum t<T> {\n-    /* Variant: none */\n     none,\n-    /* Variant: some */\n     some(T),\n }\n \n-/* Section: Operations */\n-\n-/*\n-Function: get\n+pure fn get<T: copy>(opt: t<T>) -> T {\n+    #[doc = \"\n+    Gets the value out of an option\n \n-Gets the value out of an option\n+    # Failure\n \n-Failure:\n+    Fails if the value equals `none`\n+    \"];\n \n-Fails if the value equals `none`.\n-*/\n-pure fn get<T: copy>(opt: t<T>) -> T {\n     alt opt { some(x) { ret x; } none { fail \"option none\"; } }\n }\n \n-/*\n-*/\n fn map<T, U: copy>(opt: t<T>, f: fn(T) -> U) -> t<U> {\n+    #[doc = \"Maps a `some` value from one type to another\"];\n+\n     alt opt { some(x) { some(f(x)) } none { none } }\n }\n \n-/*\n-Function: chain\n-\n-Update an optional value by optionally running its content through a function\n-that returns an option.\n-*/\n fn chain<T, U>(opt: t<T>, f: fn(T) -> t<U>) -> t<U> {\n+    #[doc = \"\n+    Update an optional value by optionally running its content through a\n+    function that returns an option.\n+    \"];\n+\n     alt opt { some(x) { f(x) } none { none } }\n }\n \n-/*\n-Function: is_none\n-\n-Returns true if the option equals none\n-*/\n pure fn is_none<T>(opt: t<T>) -> bool {\n+    #[doc = \"Returns true if the option equals `none`\"];\n+\n     alt opt { none { true } some(_) { false } }\n }\n \n-/*\n-Function: is_some\n-\n-Returns true if the option contains some value\n-*/\n-pure fn is_some<T>(opt: t<T>) -> bool { !is_none(opt) }\n+pure fn is_some<T>(opt: t<T>) -> bool {\n+    #[doc = \"Returns true if the option contains some value\"];\n \n-/*\n-Function: from_maybe\n+    !is_none(opt)\n+}\n \n-Returns the contained value or a default\n-*/\n pure fn from_maybe<T: copy>(def: T, opt: t<T>) -> T {\n+    #[doc = \"Returns the contained value or a default\"];\n+\n     alt opt { some(x) { x } none { def } }\n }\n \n-/*\n-Function: maybe\n-\n-Applies a function to the contained value or returns a default\n-*/\n fn maybe<T, U: copy>(def: U, opt: t<T>, f: fn(T) -> U) -> U {\n+    #[doc = \"Applies a function to the contained value or returns a default\"];\n+\n     alt opt { none { def } some(t) { f(t) } }\n }\n \n-// FIXME: Can be defined in terms of the above when/if we have const bind.\n-/*\n-Function: may\n-\n-Performs an operation on the contained value or does nothing\n-*/\n fn may<T>(opt: t<T>, f: fn(T)) {\n-    alt opt { none {/* nothing */ } some(t) { f(t); } }\n-}\n+    #[doc = \"Performs an operation on the contained value or does nothing\"];\n \n-/*\n-Function: unwrap\n+    alt opt { none { } some(t) { f(t); } }\n+}\n \n-Moves a value out of an option type and returns it. Useful primarily\n-for getting strings, vectors and unique pointers out of option types\n-without copying them.\n-*/\n fn unwrap<T>(-opt: t<T>) -> T unsafe {\n+    #[doc = \"\n+    Moves a value out of an option type and returns it.\n+\n+    Useful primarily for getting strings, vectors and unique pointers out of\n+    option types without copying them.\n+    \"];\n+\n     let addr = alt opt {\n       some(x) { ptr::addr_of(x) }\n       none { fail \"option none\" }"}, {"sha": "42d74e4a94c437a79532a64f222f8e5065559b35", "filename": "src/libcore/os.rs", "status": "modified", "additions": 30, "deletions": 56, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,18 +1,20 @@\n-// Higher-level interfaces to libc::* functions and operating system services.\n-//\n-// In general these take and return rust types, use rust idioms (enums,\n-// closures, vectors) rather than C idioms, and do more extensive safety\n-// checks.\n-//\n-// This module is not meant to only contain 1:1 mappings to libc entries; any\n-// os-interface code that is reasonably useful and broadly applicable can go\n-// here. Including utility routines that merely build on other os code.\n-//\n-// We assume the general case is that users do not care, and do not want to\n-// be made to care, which operating system they are on. While they may want\n-// to special case various special cases -- and so we will not _hide_ the\n-// facts of which OS the user is on -- they should be given the opportunity\n-// to write OS-ignorant code by default.\n+#[doc = \"\n+Higher-level interfaces to libc::* functions and operating system services.\n+\n+In general these take and return rust types, use rust idioms (enums,\n+closures, vectors) rather than C idioms, and do more extensive safety\n+checks.\n+\n+This module is not meant to only contain 1:1 mappings to libc entries; any\n+os-interface code that is reasonably useful and broadly applicable can go\n+here. Including utility routines that merely build on other os code.\n+\n+We assume the general case is that users do not care, and do not want to\n+be made to care, which operating system they are on. While they may want\n+to special case various special cases -- and so we will not _hide_ the\n+facts of which OS the user is on -- they should be given the opportunity\n+to write OS-ignorant code by default.\n+\"];\n \n import libc::{c_char, c_void, c_int, c_uint, size_t, ssize_t,\n               mode_t, pid_t, FILE};\n@@ -327,21 +329,19 @@ fn self_exe_path() -> option<path> {\n }\n \n \n-/*\n-Function: homedir\n-\n+#[doc = \"\n Returns the path to the user's home directory, if known.\n \n-On Unix, returns the value of the \"HOME\" environment variable if it is set and\n+On Unix, returns the value of the 'HOME' environment variable if it is set and\n not equal to the empty string.\n \n-On Windows, returns the value of the \"HOME\" environment variable if it is set\n+On Windows, returns the value of the 'HOME' environment variable if it is set\n and not equal to the empty string. Otherwise, returns the value of the\n-\"USERPROFILE\" environment variable if it is set and not equal to the empty\n+'USERPROFILE' environment variable if it is set and not equal to the empty\n string.\n \n Otherwise, homedir returns option::none.\n-*/\n+\"]\n fn homedir() -> option<path> {\n     ret alt getenv(\"HOME\") {\n         some(p) {\n@@ -377,22 +377,14 @@ fn homedir() -> option<path> {\n \n \n \n-/*\n-Function: path_is_dir\n-\n-Indicates whether a path represents a directory.\n-*/\n+#[doc = \"Indicates whether a path represents a directory\"]\n fn path_is_dir(p: path) -> bool {\n     str::as_buf(p) {|buf|\n         rustrt::rust_path_is_dir(buf) != 0 as c_int\n     }\n }\n \n-/*\n-Function: path_exists\n-\n-Indicates whether a path exists.\n-*/\n+#[doc = \"Indicates whether a path exists\"]\n fn path_exists(p: path) -> bool {\n     str::as_buf(p) {|buf|\n         rustrt::rust_path_exists(buf) != 0 as c_int\n@@ -401,15 +393,13 @@ fn path_exists(p: path) -> bool {\n \n // FIXME: under Windows, we should prepend the current drive letter to paths\n // that start with a slash.\n-/*\n-Function: make_absolute\n-\n+#[doc = \"\n Convert a relative path to an absolute path\n \n If the given path is relative, return it prepended with the current working\n directory. If the given path is already an absolute path, return it\n as is.\n-*/\n+\"]\n // NB: this is here rather than in path because it is a form of environment\n // querying; what it does depends on the process working directory, not just\n // the input paths.\n@@ -422,11 +412,7 @@ fn make_absolute(p: path) -> path {\n }\n \n \n-/*\n-Function: make_dir\n-\n-Creates a directory at the specified path.\n-*/\n+#[doc = \"Creates a directory at the specified path\"]\n fn make_dir(p: path, mode: c_int) -> bool {\n     ret mkdir(p, mode);\n \n@@ -453,11 +439,7 @@ fn make_dir(p: path, mode: c_int) -> bool {\n     }\n }\n \n-/*\n-Function: list_dir\n-\n-Lists the contents of a directory.\n-*/\n+#[doc = \"Lists the contents of a directory\"]\n fn list_dir(p: path) -> [str] {\n \n     #[cfg(target_os = \"linux\")]\n@@ -485,11 +467,7 @@ fn list_dir(p: path) -> [str] {\n     ret full_paths;\n }\n \n-/*\n-Function: remove_dir\n-\n-Removes a directory at the specified path.\n-*/\n+#[doc = \"Removes a directory at the specified path\"]\n fn remove_dir(p: path) -> bool {\n    ret rmdir(p);\n \n@@ -538,11 +516,7 @@ fn change_dir(p: path) -> bool {\n     }\n }\n \n-/*\n-Function: remove_file\n-\n-Deletes an existing file.\n-*/\n+#[doc = \"Deletes an existing file\"]\n fn remove_file(p: path) -> bool {\n     ret unlink(p);\n "}, {"sha": "4e0d64b6d44ddcf37f1158e812a0812a241d2cb7", "filename": "src/libcore/path.rs", "status": "modified", "additions": 26, "deletions": 53, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,8 +1,4 @@\n-/*\n-Module: path\n-\n-Path data type and helper functions.\n-*/\n+#[doc = \"Path data type and helper functions\"]\n \n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n@@ -18,14 +14,12 @@ mod consts {\n     const alt_path_sep: char = '\\\\';\n }\n \n-/*\n-Function: path_is_absolute\n-\n+#[doc = \"\n Indicates whether a path is absolute.\n \n-A path is considered absolute if it begins at the filesystem root (\"/\") or,\n+A path is considered absolute if it begins at the filesystem root (\\\"/\\\") or,\n on Windows, begins with a drive letter.\n-*/\n+\"]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"linux\")]\n@@ -43,19 +37,11 @@ fn path_is_absolute(p: str) -> bool {\n \n \n \n-/*\n-Function: path_sep\n-\n-Get the default path separator for the host platform\n-*/\n+#[doc = \"Get the default path separator for the host platform\"]\n fn path_sep() -> str { ret str::from_char(consts::path_sep); }\n \n // FIXME: This type should probably be constrained\n-/*\n-Type: path\n-\n-A path or fragment of a filesystem path\n-*/\n+#[doc = \"A path or fragment of a filesystem path\"]\n type path = str;\n \n fn split_dirname_basename (pp: path) -> {dirname: str, basename: str} {\n@@ -70,47 +56,40 @@ fn split_dirname_basename (pp: path) -> {dirname: str, basename: str} {\n     }\n }\n \n-/*\n-Function: dirname\n-\n+#[doc = \"\n Get the directory portion of a path\n \n Returns all of the path up to, but excluding, the final path separator.\n-The dirname of \"/usr/share\" will be \"/usr\", but the dirname of\n-\"/usr/share/\" is \"/usr/share\".\n+The dirname of \\\"/usr/share\\\" will be \\\"/usr\\\", but the dirname of\n+\\\"/usr/share/\\\" is \\\"/usr/share\\\".\n \n-If the path is not prefixed with a directory, then \".\" is returned.\n-*/\n+If the path is not prefixed with a directory, then \\\".\\\" is returned.\n+\"]\n fn dirname(pp: path) -> path {\n     ret split_dirname_basename(pp).dirname;\n }\n \n-/*\n-Function: basename\n-\n+#[doc = \"\n Get the file name portion of a path\n \n Returns the portion of the path after the final path separator.\n-The basename of \"/usr/share\" will be \"share\". If there are no\n+The basename of \\\"/usr/share\\\" will be \\\"share\\\". If there are no\n path separators in the path then the returned path is identical to\n the provided path. If an empty path is provided or the path ends\n with a path separator then an empty path is returned.\n-*/\n+\"]\n fn basename(pp: path) -> path {\n     ret split_dirname_basename(pp).basename;\n }\n \n // FIXME: Need some typestate to avoid bounds check when len(pre) == 0\n-/*\n-Function: connect\n-\n+#[doc = \"\n Connects to path segments\n \n Given paths `pre` and `post, removes any trailing path separator on `pre` and\n any leading path separator on `post`, and returns the concatenation of the two\n with a single path separator between them.\n-*/\n-\n+\"]\n fn connect(pre: path, post: path) -> path unsafe {\n     let mut pre_ = pre;\n     let mut post_ = post;\n@@ -122,13 +101,11 @@ fn connect(pre: path, post: path) -> path unsafe {\n     ret pre_ + path_sep() + post_;\n }\n \n-/*\n-Function: connect_many\n-\n+#[doc = \"\n Connects a vector of path segments into a single path.\n \n Inserts path separators as needed.\n-*/\n+\"]\n fn connect_many(paths: [path]) -> path {\n     ret if vec::len(paths) == 1u {\n         paths[0]\n@@ -138,31 +115,29 @@ fn connect_many(paths: [path]) -> path {\n     }\n }\n \n-/*\n-Function: split\n-\n+#[doc = \"\n Split a path into it's individual components\n \n Splits a given path by path separators and returns a vector containing\n each piece of the path. On Windows, if the path is absolute then\n the first element of the returned vector will be the drive letter\n followed by a colon.\n-*/\n+\"]\n fn split(p: path) -> [path] {\n     str::split_nonempty(p, {|c|\n         c == consts::path_sep || c == consts::alt_path_sep\n     })\n }\n \n-/*\n-Function: splitext\n+#[doc = \"\n+Split a path into the part before the extension and the extension\n \n Split a path into a pair of strings with the first element being the filename\n without the extension and the second being either empty or the file extension\n including the period. Leading periods in the basename are ignored.  If the\n path includes directory components then they are included in the filename part\n of the result pair.\n-*/\n+\"]\n fn splitext(p: path) -> (str, str) {\n     if str::is_empty(p) { (\"\", \"\") }\n     else {\n@@ -204,13 +179,11 @@ fn splitext(p: path) -> (str, str) {\n     }\n }\n \n-/*\n-Function: normalize\n-\n-Removes extra \".\" and \"..\" entries from paths.\n+#[doc = \"\n+Removes extra '.' and '..' entries from paths\n \n Does not follow symbolic links.\n-*/\n+\"]\n fn normalize(p: path) -> path {\n     let s = split(p);\n     let s = strip_dots(s);"}, {"sha": "9377940243daa6424f2aed04bc30ac37c7a74940", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 16, "deletions": 39, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,8 +1,5 @@\n-/*\n-Module: ptr\n+#[doc = \"Unsafe pointer utility functions\"]\n \n-Unsafe pointer utility functions\n-*/\n #[abi = \"rust-intrinsic\"]\n native mod rusti {\n     fn addr_of<T>(val: T) -> *T;\n@@ -11,70 +8,50 @@ native mod rusti {\n     fn memmove<T>(dst: *T, src: *T, count: ctypes::uintptr_t);\n }\n \n-/*\n-Function: addr_of\n-\n-Get an unsafe pointer to a value\n-*/\n+#[doc = \"Get an unsafe pointer to a value\"]\n #[inline(always)]\n fn addr_of<T>(val: T) -> *T { ret rusti::addr_of(val); }\n \n-/*\n-Function: mut_addr_of\n-\n-Get an unsafe mutable pointer to a value\n-*/\n+#[doc = \"Get an unsafe mutable pointer to a value\"]\n #[inline(always)]\n fn mut_addr_of<T>(val: T) -> *mutable T unsafe {\n     ret unsafe::reinterpret_cast(rusti::addr_of(val));\n }\n \n-/*\n-Function: offset\n-\n-Calculate the offset from a pointer\n-*/\n+#[doc = \"Calculate the offset from a pointer\"]\n #[inline(always)]\n fn offset<T>(ptr: *T, count: uint) -> *T {\n     ret rusti::ptr_offset(ptr, count);\n }\n \n-/*\n-Function: mut_offset\n-\n-Calculate the offset from a mutable pointer\n-*/\n+#[doc = \"Calculate the offset from a mutable pointer\"]\n #[inline(always)]\n fn mut_offset<T>(ptr: *mutable T, count: uint) -> *mutable T {\n     ret rusti::ptr_offset(ptr as *T, count) as *mutable T;\n }\n \n \n-/*\n-Function: null\n-\n-Create an unsafe null pointer\n-*/\n+#[doc = \"Create an unsafe null pointer\"]\n #[inline(always)]\n fn null<T>() -> *T unsafe { ret unsafe::reinterpret_cast(0u); }\n \n-/*\n-Function: memcpy\n+#[doc = \"\n+Copies data from one location to another\n \n-Copies data from one src to dst that is not overlapping each other.\n-Count is the number of elements to copy and not the number of bytes.\n-*/\n+Copies `count` elements (not bytes) from `src` to `dst`. The source\n+and destination may not overlap.\n+\"]\n #[inline(always)]\n unsafe fn memcpy<T>(dst: *T, src: *T, count: uint) {\n     rusti::memcpy(dst, src, count);\n }\n \n-/*\n-Function: memmove\n+#[doc = \"\n+Copies data from one location to another\n \n-Copies data from one src to dst, overlap between the two pointers may occur.\n-Count is the number of elements to copy and not the number of bytes.\n-*/\n+Copies `count` elements (not bytes) from `src` to `dst`. The source\n+and destination may overlap.\n+\"]\n #[inline(always)]\n unsafe fn memmove<T>(dst: *T, src: *T, count: uint)  {\n     rusti::memmove(dst, src, count);"}, {"sha": "b3c01f62f9d82bedbf8802233d59dd3aaefc3f9b", "filename": "src/libcore/result.rs", "status": "modified", "additions": 25, "deletions": 54, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,42 +1,20 @@\n-/*\n-Module: result\n+#[doc = \"A type representing either success or failure\"];\n \n-A type representing either success or failure\n-*/\n-\n-/* Section: Types */\n-\n-/*\n-Tag: t\n-\n-The result type\n-*/\n+#[doc = \"The result type\"]\n enum t<T, U> {\n-    /*\n-    Variant: ok\n-\n-    Contains the result value\n-    */\n+    #[doc = \"Contains the successful result value\"]\n     ok(T),\n-    /*\n-    Variant: err\n-\n-    Contains the error value\n-    */\n+    #[doc = \"Contains the error value\"]\n     err(U)\n }\n \n-/* Section: Operations */\n-\n-/*\n-Function: get\n-\n+#[doc = \"\n Get the value out of a successful result\n \n-Failure:\n+# Failure\n \n If the result is an error\n-*/\n+\"]\n fn get<T: copy, U>(res: t<T, U>) -> T {\n     alt res {\n       ok(t) { t }\n@@ -48,15 +26,13 @@ fn get<T: copy, U>(res: t<T, U>) -> T {\n     }\n }\n \n-/*\n-Function: get_err\n-\n+#[doc = \"\n Get the value out of an error result\n \n-Failure:\n+# Failure\n \n If the result is not an error\n-*/\n+\"]\n fn get_err<T, U: copy>(res: t<T, U>) -> U {\n     alt res {\n       err(u) { u }\n@@ -66,50 +42,45 @@ fn get_err<T, U: copy>(res: t<T, U>) -> U {\n     }\n }\n \n-/*\n-Function: success\n-\n-Returns true if the result is <ok>\n-*/\n+#[doc = \"Returns true if the result is `ok`\"]\n pure fn success<T, U>(res: t<T, U>) -> bool {\n     alt res {\n       ok(_) { true }\n       err(_) { false }\n     }\n }\n \n-/*\n-Function: failure\n-\n-Returns true if the result is <error>\n-*/\n+#[doc = \"Returns true if the result is `error`\"]\n pure fn failure<T, U>(res: t<T, U>) -> bool {\n     !success(res)\n }\n \n+#[doc = \"\n+Convert to the `either` type\n+\n+`ok` result variants are converted to `either::right` variants, `err`\n+result variants are converted to `either::left`.\n+\"]\n pure fn to_either<T: copy, U: copy>(res: t<U, T>) -> either::t<T, U> {\n     alt res {\n       ok(res) { either::right(res) }\n       err(fail_) { either::left(fail_) }\n     }\n }\n \n-/*\n-Function: chain\n-\n+#[doc = \"\n Call a function based on a previous result\n \n-If `res` is <ok> then the value is extracted and passed to `op` whereupon\n-`op`s result is returned. if `res` is <err> then it is immediately returned.\n+If `res` is `ok` then the value is extracted and passed to `op` whereupon\n+`op`s result is returned. if `res` is `err` then it is immediately returned.\n This function can be used to compose the results of two functions.\n \n Example:\n \n-> let res = chain(read_file(file), { |buf|\n->   ok(parse_buf(buf))\n-> })\n-\n-*/\n+    let res = chain(read_file(file)) { |buf|\n+        ok(parse_buf(buf))\n+    }\n+\"]\n fn chain<T, U: copy, V: copy>(res: t<T, V>, op: fn(T) -> t<U, V>)\n     -> t<U, V> {\n     alt res {"}, {"sha": "52f342c81d520191f33893ce924f94c56c8723f0", "filename": "src/libcore/str.rs", "status": "modified", "additions": 326, "deletions": 480, "changes": 806, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,13 +1,11 @@\n-/*\n-Module: str\n-\n+#[doc = \"\n String manipulation\n \n-Strings are a packed UTF-8 representation of text, stored as null terminated\n-buffers of u8 bytes.  Strings should be indexed in bytes, for efficiency,\n-but UTF-8 unsafe operations should be avoided.\n-For some heavy-duty uses, try std::rope.\n-*/\n+Strings are a packed UTF-8 representation of text, stored as null\n+terminated buffers of u8 bytes.  Strings should be indexed in bytes,\n+for efficiency, but UTF-8 unsafe operations should be avoided.  For\n+some heavy-duty uses, try std::rope.\n+\"];\n \n export\n    // Creating a string\n@@ -110,21 +108,25 @@ native mod rustrt {\n Section: Creating a string\n */\n \n-/*\n-Function: from_bytes\n+#[doc = \"\n+Convert a vector of bytes to a UTF-8 string\n \n-Convert a vector of bytes to a UTF-8 string.  Fails if invalid UTF-8.\n-*/\n+# Failure\n+\n+Fails if invalid UTF-8\n+\"]\n fn from_bytes(vv: [u8]) -> str unsafe {\n    assert is_utf8(vv);\n    ret unsafe::from_bytes(vv);\n }\n \n-/*\n-Function: from_byte\n+#[doc = \"\n+Convert a byte to a UTF-8 string\n \n-Convert a byte to a UTF-8 string.  Fails if invalid UTF-8.\n-*/\n+# Failure\n+\n+Fails if invalid UTF-8\n+\"]\n fn from_byte(b: u8) -> str unsafe {\n     assert b < 128u8;\n     let mut v = [b, 0u8];\n@@ -133,11 +135,7 @@ fn from_byte(b: u8) -> str unsafe {\n     s\n }\n \n-/*\n-Function: push_char\n-\n-Appends a character at the end of a string.\n-*/\n+#[doc = \"Appends a character at the end of a string\"]\n fn push_char(&s: str, ch: char) unsafe {\n     let code = ch as uint;\n     if code < max_one_b {\n@@ -170,34 +168,22 @@ fn push_char(&s: str, ch: char) unsafe {\n     }\n }\n \n-/*\n-Function: from_char\n-\n-Convert a char to a string\n-*/\n+#[doc = \"Convert a char to a string\"]\n fn from_char(ch: char) -> str {\n     let mut buf = \"\";\n     push_char(buf, ch);\n     ret buf;\n }\n \n-/*\n-Function: from_chars\n-\n-Convert a vector of chars to a string\n-*/\n+#[doc = \"Convert a vector of chars to a string\"]\n fn from_chars(chs: [char]) -> str {\n     let mut buf = \"\";\n     reserve(buf, chs.len());\n     for ch in chs { push_char(buf, ch); }\n     ret buf;\n }\n \n-/*\n-Function: from_cstr\n-\n-Create a Rust string from a null-terminated C string\n-*/\n+#[doc = \"Create a Rust string from a null-terminated C string\"]\n fn from_cstr(cstr: sbuf) -> str unsafe {\n     let mut curr = cstr, i = 0u;\n     while *curr != 0u8 {\n@@ -207,11 +193,7 @@ fn from_cstr(cstr: sbuf) -> str unsafe {\n     ret from_cstr_len(cstr, i);\n }\n \n-/*\n-Function: from_cstr_len\n-\n-Create a Rust string from a C string of the given length\n-*/\n+#[doc = \"Create a Rust string from a C string of the given length\"]\n fn from_cstr_len(cstr: sbuf, len: uint) -> str unsafe {\n     let mut buf: [u8] = [];\n     vec::reserve(buf, len + 1u);\n@@ -225,22 +207,16 @@ fn from_cstr_len(cstr: sbuf, len: uint) -> str unsafe {\n     ret s;\n }\n \n-/*\n-Function: concat\n-\n-Concatenate a vector of strings\n-*/\n+#[doc = \"Concatenate a vector of strings\"]\n fn concat(v: [str]) -> str {\n     let mut s: str = \"\";\n     for ss: str in v { s += ss; }\n     ret s;\n }\n \n-/*\n-Function: connect\n-\n+#[doc = \"\n Concatenate a vector of strings, placing a given separator between each\n-*/\n+\"]\n fn connect(v: [str], sep: str) -> str {\n     let mut s = \"\", first = true;\n     for ss: str in v {\n@@ -254,14 +230,13 @@ fn connect(v: [str], sep: str) -> str {\n Section: Adding to and removing from a string\n */\n \n-/*\n-Function: pop_char\n+#[doc = \"\n+Remove the final character from a string and return it\n \n-Remove the final character from a string and return it.\n+# Failure\n \n-Failure:\n-If the string does not contain any characters.\n-*/\n+If the string does not contain any characters\n+\"]\n fn pop_char(&s: str) -> char {\n     let end = len(s);\n     assert end > 0u;\n@@ -270,33 +245,23 @@ fn pop_char(&s: str) -> char {\n     ret ch;\n }\n \n-/*\n-Function: shift_char\n-\n-Remove the first character from a string and return it.\n+#[doc = \"\n+Remove the first character from a string and return it\n \n-Failure:\n+# Failure\n \n-If the string does not contain any characters.\n-*/\n+If the string does not contain any characters\n+\"]\n fn shift_char(&s: str) -> char unsafe {\n     let {ch, next} = char_range_at(s, 0u);\n     s = unsafe::slice_bytes(s, next, len(s));\n     ret ch;\n }\n \n-/*\n-Function: unshift_char\n-\n-Prepend a char to a string\n-*/\n+#[doc = \"Prepend a char to a string\"]\n fn unshift_char(&s: str, ch: char) { s = from_char(ch) + s; }\n \n-/*\n-Function: trim_left\n-\n-Returns a string with leading whitespace removed.\n-*/\n+#[doc = \"Returns a string with leading whitespace removed\"]\n fn trim_left(+s: str) -> str {\n     alt find(s, {|c| !char::is_whitespace(c)}) {\n       none { \"\" }\n@@ -307,11 +272,7 @@ fn trim_left(+s: str) -> str {\n     }\n }\n \n-/*\n-Function: trim_right\n-\n-Returns a string with trailing whitespace removed.\n-*/\n+#[doc = \"Returns a string with trailing whitespace removed\"]\n fn trim_right(+s: str) -> str {\n     alt rfind(s, {|c| !char::is_whitespace(c)}) {\n       none { \"\" }\n@@ -323,32 +284,23 @@ fn trim_right(+s: str) -> str {\n     }\n }\n \n-/*\n-Function: trim\n-\n-Returns a string with leading and trailing whitespace removed\n-*/\n+#[doc = \"Returns a string with leading and trailing whitespace removed\"]\n fn trim(+s: str) -> str { trim_left(trim_right(s)) }\n \n /*\n Section: Transforming strings\n */\n \n-/*\n-Function: bytes\n+#[doc = \"\n+Converts a string to a vector of bytes\n \n-Converts a string to a vector of bytes. The result vector is not\n-null-terminated.\n-*/\n+The result vector is not null-terminated.\n+\"]\n fn bytes(s: str) -> [u8] unsafe {\n     as_bytes(s) { |v| vec::slice(v, 0u, vec::len(v) - 1u) }\n }\n \n-/*\n-Function: chars\n-\n-Convert a string to a vector of characters\n-*/\n+#[doc = \"Convert a string to a vector of characters\"]\n fn chars(s: str) -> [char] {\n     let mut buf = [], i = 0u;\n     let len = len(s);\n@@ -360,48 +312,48 @@ fn chars(s: str) -> [char] {\n     ret buf;\n }\n \n-/*\n-Function: substr\n+#[doc = \"\n+Take a substring of another.\n \n-Take a substring of another. Returns a string containing `n`\n-characters starting at byte offset `begin`.\n-*/\n+Returns a string containing `n` characters starting at byte offset\n+`begin`.\n+\"]\n fn substr(s: str, begin: uint, n: uint) -> str {\n     slice(s, begin, begin + count_bytes(s, begin, n))\n }\n \n-// Function: slice\n-//\n-// Return a slice of the given string from the byte range [`begin`..`end`)\n-// or else fail when `begin` and `end` do not point to valid characters or\n-// beyond the last character of the string\n+#[doc = \"\n+Returns a slice of the given string from the byte range [`begin`..`end`)\n+\n+Fails when `begin` and `end` do not point to valid characters or\n+beyond the last character of the string\n+\"]\n fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n     assert is_char_boundary(s, begin);\n     assert is_char_boundary(s, end);\n     unsafe::slice_bytes(s, begin, end)\n }\n \n-// Function: split_char\n-//\n-// Splits a string into substrings at each occurrence of a given\n-// character\n+#[doc = \"\n+Splits a string into substrings at each occurrence of a given character\n+\"]\n fn split_char(s: str, sep: char) -> [str] {\n     split_char_inner(s, sep, len(s), true)\n }\n \n-// Function: splitn_char\n-//\n-// Splits a string into substrings at each occurrence of a given\n-// character up to 'count' times\n-//\n-// The byte must be a valid UTF-8/ASCII byte\n+#[doc = \"\n+Splits a string into substrings at each occurrence of a given\n+character up to 'count' times\n+\n+The byte must be a valid UTF-8/ASCII byte\n+\"]\n fn splitn_char(s: str, sep: char, count: uint) -> [str] {\n     split_char_inner(s, sep, count, true)\n }\n \n-// Function: split_char_nonempty\n-//\n-// Like `split_char`, but omits empty strings from the returned vector.\n+#[doc = \"\n+Like `split_char`, but omits empty strings from the returned vector\n+\"]\n fn split_char_nonempty(s: str, sep: char) -> [str] {\n     split_char_inner(s, sep, len(s), false)\n }\n@@ -432,28 +384,20 @@ fn split_char_inner(s: str, sep: char, count: uint, allow_empty: bool)\n }\n \n \n-/*\n-Function: split\n-\n-Splits a string into substrings using a character function\n-*/\n+#[doc = \"Splits a string into substrings using a character function\"]\n fn split(s: str, sepfn: fn(char) -> bool) -> [str] {\n     split_inner(s, sepfn, len(s), true)\n }\n \n-/*\n-Function: splitn\n-\n+#[doc = \"\n Splits a string into substrings using a character function, cutting at\n-most [count] times.\n-*/\n+most `count` times.\n+\"]\n fn splitn(s: str, sepfn: fn(char) -> bool, count: uint) -> [str] {\n     split_inner(s, sepfn, count, true)\n }\n \n-// Function: split_nonempty\n-//\n-// Like `split`, but omits empty strings from the returned vector.\n+#[doc = \"Like `split`, but omits empty strings from the returned vector\"]\n fn split_nonempty(s: str, sepfn: fn(char) -> bool) -> [str] {\n     split_inner(s, sepfn, len(s), false)\n }\n@@ -516,14 +460,15 @@ fn iter_between_matches(s: str, sep: str, f: fn(uint, uint)) {\n     f(last_end, len(s));\n }\n \n-/*\n-Function: split_str\n-\n+#[doc = \"\n Splits a string into a vector of the substrings separated by a given string\n \n-Note that this has recently been changed.  For example:\n->  assert [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\")\n-*/\n+# Example\n+\n+~~~\n+assert [\\\"\\\", \\\"XXX\\\", \\\"YYY\\\", \\\"\\\"] == split_str(\\\".XXX.YYY.\\\", \\\".\\\")\n+~~~\n+\"]\n fn split_str(s: str, sep: str) -> [str] {\n     let mut result = [];\n     iter_between_matches(s, sep) {|from, to|\n@@ -542,20 +487,15 @@ fn split_str_nonempty(s: str, sep: str) -> [str] {\n     result\n }\n \n-/*\n-Function: lines\n-\n-Splits a string into a vector of the substrings\n-separated by LF ('\\n')\n-*/\n+#[doc = \"\n+Splits a string into a vector of the substrings separated by LF ('\\n')\n+\"]\n fn lines(s: str) -> [str] { split_char(s, '\\n') }\n \n-/*\n-Function: lines_any\n-\n-Splits a string into a vector of the substrings\n-separated by LF ('\\n') and/or CR LF ('\\r\\n')\n-*/\n+#[doc = \"\n+Splits a string into a vector of the substrings separated by LF ('\\n')\n+and/or CR LF ('\\r\\n')\n+\"]\n fn lines_any(s: str) -> [str] {\n     vec::map(lines(s), {|s|\n         let l = len(s);\n@@ -567,49 +507,36 @@ fn lines_any(s: str) -> [str] {\n     })\n }\n \n-/*\n-Function: words\n-\n-Splits a string into a vector of the substrings\n-separated by whitespace\n-*/\n+#[doc = \"\n+Splits a string into a vector of the substrings separated by whitespace\n+\"]\n fn words(s: str) -> [str] {\n     split_nonempty(s, {|c| char::is_whitespace(c)})\n }\n \n-/*\n-Function: to_lower\n-\n-Convert a string to lowercase\n-*/\n+#[doc = \"Convert a string to lowercase\"]\n fn to_lower(s: str) -> str {\n     map(s, char::to_lower)\n }\n \n-/*\n-Function: to_upper\n-\n-Convert a string to uppercase\n-*/\n+#[doc = \"Convert a string to uppercase\"]\n fn to_upper(s: str) -> str {\n     map(s, char::to_upper)\n }\n \n-/*\n-Function: replace\n-\n+#[doc = \"\n Replace all occurances of one string with another\n \n-Parameters:\n+# Arguments\n \n-s - The string containing substrings to replace\n-from - The string to replace\n-to - The replacement string\n+* s - The string containing substrings to replace\n+* from - The string to replace\n+* to - The replacement string\n \n-Returns:\n+# Return value\n \n The original string with all occurances of `from` replaced with `to`\n-*/\n+\"]\n fn replace(s: str, from: str, to: str) -> str unsafe {\n     let mut result = \"\", first = true;\n     iter_between_matches(s, from) {|start, end|\n@@ -623,25 +550,13 @@ fn replace(s: str, from: str, to: str) -> str unsafe {\n Section: Comparing strings\n */\n \n-/*\n-Function: eq\n-\n-Bytewise string equality\n-*/\n+#[doc = \"Bytewise string equality\"]\n pure fn eq(&&a: str, &&b: str) -> bool { a == b }\n \n-/*\n-Function: le\n-\n-Bytewise less than or equal\n-*/\n+#[doc = \"Bytewise less than or equal\"]\n pure fn le(&&a: str, &&b: str) -> bool { a <= b }\n \n-/*\n-Function: hash\n-\n-String hash function\n-*/\n+#[doc = \"String hash function\"]\n fn hash(&&s: str) -> uint {\n     // djb hash.\n     // FIXME: replace with murmur.\n@@ -654,43 +569,31 @@ fn hash(&&s: str) -> uint {\n Section: Iterating through strings\n */\n \n-/*\n-Function: all\n-\n-Return true if a predicate matches all characters or\n-if the string contains no characters\n-*/\n+#[doc = \"\n+Return true if a predicate matches all characters or if the string\n+contains no characters\n+\"]\n fn all(s: str, it: fn(char) -> bool) -> bool {\n     all_between(s, 0u, len(s), it)\n }\n \n-/*\n-Function: any\n-\n-Return true if a predicate matches any character\n-(and false if it matches none or there are no characters)\n-*/\n+#[doc = \"\n+Return true if a predicate matches any character (and false if it\n+matches none or there are no characters)\n+\"]\n fn any(ss: str, pred: fn(char) -> bool) -> bool {\n     !all(ss, {|cc| !pred(cc)})\n }\n \n-/*\n-Function: map\n-\n-Apply a function to each character\n-*/\n+#[doc = \"Apply a function to each character\"]\n fn map(ss: str, ff: fn(char) -> char) -> str {\n     let mut result = \"\";\n     reserve(result, len(ss));\n     chars_iter(ss) {|cc| str::push_char(result, ff(cc));}\n     result\n }\n \n-/*\n-Function: bytes_iter\n-\n-Iterate over the bytes in a string\n-*/\n+#[doc = \"Iterate over the bytes in a string\"]\n fn bytes_iter(ss: str, it: fn(u8)) {\n     let mut pos = 0u;\n     let len = len(ss);\n@@ -701,11 +604,7 @@ fn bytes_iter(ss: str, it: fn(u8)) {\n     }\n }\n \n-/*\n-Function: chars_iter\n-\n-Iterate over the characters in a string\n-*/\n+#[doc = \"Iterate over the characters in a string\"]\n fn chars_iter(s: str, it: fn(char)) {\n     let mut pos = 0u;\n     let len = len(s);\n@@ -716,40 +615,27 @@ fn chars_iter(s: str, it: fn(char)) {\n     }\n }\n \n-/*\n-Function: split_char_iter\n-\n-Apply a function to each substring after splitting\n-by character\n-*/\n+#[doc = \"\n+Apply a function to each substring after splitting by character\n+\"]\n fn split_char_iter(ss: str, cc: char, ff: fn(&&str)) {\n    vec::iter(split_char(ss, cc), ff)\n }\n \n-/*\n-Function: splitn_char_iter\n-\n-Apply a function to each substring after splitting\n-by character, up to `count` times\n-*/\n+#[doc = \"\n+Apply a function to each substring after splitting by character, up to\n+`count` times\n+\"]\n fn splitn_char_iter(ss: str, sep: char, count: uint, ff: fn(&&str)) unsafe {\n    vec::iter(splitn_char(ss, sep, count), ff)\n }\n \n-/*\n-Function: words_iter\n-\n-Apply a function to each word\n-*/\n+#[doc = \"Apply a function to each word\"]\n fn words_iter(ss: str, ff: fn(&&str)) {\n     vec::iter(words(ss), ff)\n }\n \n-/*\n-Function: lines_iter\n-\n-Apply a function to each lines (by '\\n')\n-*/\n+#[doc = \"Apply a function to each lines (by '\\n')\"]\n fn lines_iter(ss: str, ff: fn(&&str)) {\n     vec::iter(lines(ss), ff)\n }\n@@ -758,26 +644,25 @@ fn lines_iter(ss: str, ff: fn(&&str)) {\n Section: Searching\n */\n \n-// Function: find_char\n-//\n-// Returns the byte index of the first matching char\n-// (as option some/none)\n+#[doc = \"\n+Returns the byte index of the first matching char (as option some/none)\n+\"]\n fn find_char(s: str, c: char) -> option<uint> {\n     find_char_between(s, c, 0u, len(s))\n }\n \n-// Function: find_char_from\n-//\n-// Returns the byte index of the first matching char\n-// (as option some/none), starting from `start`\n+#[doc = \"\n+Returns the byte index of the first matching char as option\n+some/none), starting from `start`\n+\"]\n fn find_char_from(s: str, c: char, from: uint) -> option<uint> {\n     find_char_between(s, c, from, len(s))\n }\n \n-// Function: find_char_between\n-//\n-// Returns the byte index of the first matching char\n-// (as option some/none), between `start` and `end`\n+#[doc = \"\n+Returns the byte index of the first matching char (as option\n+some/none), between `start` and `end`\n+\"]\n fn find_char_between(s: str, c: char, start: uint, end: uint)\n     -> option<uint> {\n     if c < 128u as char {\n@@ -795,27 +680,26 @@ fn find_char_between(s: str, c: char, start: uint, end: uint)\n     }\n }\n \n-// Function: rfind_char\n-//\n-// Returns the byte index of the last matching char\n-// (as option some/none)\n+#[doc = \"\n+Returns the byte index of the last matching char as option some/none)\n+\"]\n fn rfind_char(s: str, c: char) -> option<uint> {\n     rfind_char_between(s, c, len(s), 0u)\n }\n \n-// Function: rfind_char_from\n-//\n-// Returns the byte index of the last matching char\n-// (as option some/none), starting from `start`\n+#[doc = \"\n+Returns the byte index of the last matching char (as option\n+some/none), starting from `start`\n+\"]\n fn rfind_char_from(s: str, c: char, start: uint) -> option<uint> {\n     rfind_char_between(s, c, start, 0u)\n }\n \n-// Function: rfind_char_between\n-//\n-// Returns the byte index of the last matching char (as option\n-// some/none), between from `start` and `end` (start must be greater\n-// than or equal to end)\n+#[doc = \"\n+Returns the byte index of the last matching char (as option\n+some/none), between from `start` and `end` (start must be greater\n+than or equal to end)\n+\"]\n fn rfind_char_between(s: str, c: char, start: uint, end: uint)\n     -> option<uint> {\n     if c < 128u as char {\n@@ -833,26 +717,26 @@ fn rfind_char_between(s: str, c: char, start: uint, end: uint)\n     }\n }\n \n-// Function: find\n-//\n-// Returns, as an option, the first character that passes the given\n-// predicate\n+#[doc = \"\n+Returns, as an option, the first character that passes the given\n+predicate\n+\"]\n fn find(s: str, f: fn(char) -> bool) -> option<uint> {\n     find_between(s, 0u, len(s), f)\n }\n \n-// Function: find_from\n-//\n-// Returns, as an option, the first character that passes the given\n-// predicate, starting at byte offset `start`\n+#[doc = \"\n+Returns, as an option, the first character that passes the given\n+predicate, starting at byte offset `start`\n+\"]\n fn find_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n     find_between(s, start, len(s), f)\n }\n \n-// Function: find_between\n-//\n-// Returns, as an option, the first character that passes the given\n-// predicate, between byte offsets `start` and `end`\n+#[doc = \"\n+Returns, as an option, the first character that passes the given\n+predicate, between byte offsets `start` and `end`\n+\"]\n fn find_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n     -> option<uint> {\n     assert start <= end;\n@@ -867,27 +751,27 @@ fn find_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n     ret none;\n }\n \n-// Function: rfind\n-//\n-// Returns, as an option, the last character in the string that passes\n-// the given predicate\n+#[doc = \"\n+Returns, as an option, the last character in the string that passes\n+the given predicate\n+\"]\n fn rfind(s: str, f: fn(char) -> bool) -> option<uint> {\n     rfind_between(s, len(s), 0u, f)\n }\n \n-// Function: rfind_from\n-//\n-// Returns, as an option, the last character that passes the given\n-// predicate, up until byte offset `start`\n+#[doc = \"\n+Returns, as an option, the last character that passes the given\n+predicate, up until byte offset `start`\n+\"]\n fn rfind_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n \n-// Function: rfind_between\n-//\n-// Returns, as an option, the last character that passes the given\n-// predicate, between byte offsets `start` and `end` (`start` must be\n-// greater than or equal to `end`)\n+#[doc = \"\n+Returns, as an option, the last character that passes the given\n+predicate, between byte offsets `start` and `end` (`start` must be\n+greater than or equal to `end`)\n+\"]\n fn rfind_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n     -> option<uint> {\n     assert start >= end;\n@@ -909,27 +793,27 @@ fn match_at(haystack: str, needle: str, at: uint) -> bool {\n     ret true;\n }\n \n-//Function: find_str\n-//\n-// Find the byte position of the first instance of one string\n-// within another, or return option::none\n+#[doc = \"\n+Find the byte position of the first instance of one string\n+within another, or return `option::none`\n+\"]\n fn find_str(haystack: str, needle: str) -> option<uint> {\n     find_str_between(haystack, needle, 0u, len(haystack))\n }\n \n-//Function: find_str_from\n-//\n-// Find the byte position of the first instance of one string\n-// within another, or return option::none\n+#[doc = \"\n+Find the byte position of the first instance of one string\n+within another, or return `option::none`\n+\"]\n fn find_str_from(haystack: str, needle: str, start: uint)\n   -> option<uint> {\n     find_str_between(haystack, needle, start, len(haystack))\n }\n \n-//Function: find_str_between\n-//\n-// Find the byte position of the first instance of one string\n-// within another, or return option::none\n+#[doc = \"\n+Find the byte position of the first instance of one string\n+within another, or return `option::none`\n+\"]\n fn find_str_between(haystack: str, needle: str, start: uint, end:uint)\n   -> option<uint> {\n     // FIXME: Boyer-Moore should be significantly faster\n@@ -947,45 +831,41 @@ fn find_str_between(haystack: str, needle: str, start: uint, end:uint)\n     ret none;\n }\n \n-/*\n-Function: contains\n-\n+#[doc = \"\n Returns true if one string contains another\n \n-Parameters:\n+# Arguments\n \n-haystack - The string to look in\n-needle - The string to look for\n-*/\n+* haystack - The string to look in\n+* needle - The string to look for\n+\"]\n fn contains(haystack: str, needle: str) -> bool {\n     option::is_some(find_str(haystack, needle))\n }\n \n-/*\n-Function: starts_with\n-\n+#[doc = \"\n Returns true if one string starts with another\n \n-Parameters:\n+# Arguments\n \n-haystack - The string to look in\n-needle - The string to look for\n-*/\n+* haystack - The string to look in\n+* needle - The string to look for\n+\"]\n fn starts_with(haystack: str, needle: str) -> bool unsafe {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n     else { match_at(haystack, needle, 0u) }\n }\n \n-/*\n-Function: ends_with\n-\n+#[doc = \"\n Returns true if one string ends with another\n \n-haystack - The string to look in\n-needle - The string to look for\n-*/\n+# Arguments\n+\n+* haystack - The string to look in\n+* needle - The string to look for\n+\"]\n fn ends_with(haystack: str, needle: str) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n@@ -997,64 +877,44 @@ fn ends_with(haystack: str, needle: str) -> bool {\n Section: String properties\n */\n \n-/*\n-Function: is_ascii\n-\n-Determines if a string contains only ASCII characters\n-*/\n+#[doc = \"Determines if a string contains only ASCII characters\"]\n fn is_ascii(s: str) -> bool {\n     let mut i: uint = len(s);\n     while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { ret false; } }\n     ret true;\n }\n \n-/*\n-Predicate: is_empty\n-\n-Returns true if the string has length 0\n-*/\n+#[doc = \"Returns true if the string has length 0\"]\n pure fn is_empty(s: str) -> bool { for c: u8 in s { ret false; } ret true; }\n \n-/*\n-Predicate: is_not_empty\n-\n-Returns true if the string has length greater than 0\n-*/\n+#[doc = \"Returns true if the string has length greater than 0\"]\n pure fn is_not_empty(s: str) -> bool { !is_empty(s) }\n \n-/*\n-Function: is_whitespace\n-\n+#[doc = \"\n Returns true if the string contains only whitespace\n-*/\n+\n+Whitespace characters are determined by `char::is_whitespace`\n+\"]\n fn is_whitespace(s: str) -> bool {\n     ret all(s, char::is_whitespace);\n }\n \n-\n-// Function: len\n-//\n-// Returns the string length/size in bytes\n-// not counting the null terminator\n+#[doc = \"\n+Returns the string length/size in bytes not counting the null terminator\n+\"]\n pure fn len(s: str) -> uint unsafe {\n     let repr: *vec::unsafe::vec_repr = ::unsafe::reinterpret_cast(s);\n     (*repr).fill - 1u\n }\n \n-// Function: char_len\n-//\n-// Returns the number of characters that a string holds\n+#[doc = \"Returns the number of characters that a string holds\"]\n fn char_len(s: str) -> uint { count_chars(s, 0u, len(s)) }\n \n /*\n Section: Misc\n */\n \n-/*\n-Function: is_utf8\n-\n-Determines if a vector of bytes contains valid UTF-8\n-*/\n+#[doc = \"Determines if a vector of bytes contains valid UTF-8\"]\n fn is_utf8(v: [const u8]) -> bool {\n     let mut i = 0u;\n     let total = vec::len::<u8>(v);\n@@ -1072,7 +932,6 @@ fn is_utf8(v: [const u8]) -> bool {\n     ret true;\n }\n \n-\n fn is_utf16(v: [const u16]) -> bool {\n     let len = v.len();\n     let mut i = 0u;\n@@ -1148,19 +1007,19 @@ fn from_utf16(v: [const u16]) -> str {\n }\n \n \n-/*\n-Function: count_chars\n-\n+#[doc = \"\n As char_len but for a slice of a string\n \n-Parameters:\n- s           - A valid string\n- start       - The position inside `s` where to start counting in bytes.\n- end         - The position where to stop counting\n+# Arguments\n \n-Returns:\n- The number of Unicode characters in `s` between the given indices.\n-*/\n+* s - A valid string\n+* start - The position inside `s` where to start counting in bytes\n+* end - The position where to stop counting\n+\n+# Return value\n+\n+The number of Unicode characters in `s` between the given indices.\n+\"]\n fn count_chars(s: str, start: uint, end: uint) -> uint {\n     assert is_char_boundary(s, start);\n     assert is_char_boundary(s, end);\n@@ -1173,10 +1032,9 @@ fn count_chars(s: str, start: uint, end: uint) -> uint {\n     ret len;\n }\n \n-// Function count_bytes\n-//\n-// Counts the number of bytes taken by the `n` in `s` starting from\n-// `start`.\n+#[doc = \"\n+Counts the number of bytes taken by the `n` in `s` starting from `start`.\n+\"]\n fn count_bytes(s: str, start: uint, n: uint) -> uint {\n     assert is_char_boundary(s, start);\n     let mut end = start, cnt = n;\n@@ -1190,12 +1048,9 @@ fn count_bytes(s: str, start: uint, n: uint) -> uint {\n     end - start\n }\n \n-/*\n-Function: utf8_char_width\n-\n+#[doc = \"\n Given a first byte, determine how many bytes are in this UTF-8 character\n-\n-*/\n+\"]\n pure fn utf8_char_width(b: u8) -> uint {\n     let byte: uint = b as uint;\n     if byte < 128u { ret 1u; }\n@@ -1208,61 +1063,63 @@ pure fn utf8_char_width(b: u8) -> uint {\n     ret 6u;\n }\n \n-/*\n-Function is_char_boundary\n-\n+#[doc = \"\n Returns false if the index points into the middle of a multi-byte\n character sequence.\n-*/\n+\"]\n pure fn is_char_boundary(s: str, index: uint) -> bool {\n     if index == len(s) { ret true; }\n     let b = s[index];\n     ret b < 128u8 || b >= 192u8;\n }\n \n-/*\n-Function: char_range_at\n-\n+#[doc = \"\n Pluck a character out of a string and return the index of the next character.\n+\n This function can be used to iterate over the unicode characters of a string.\n \n-Example:\n-> let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-> let i = 0u;\n-> while i < str::len(s) {\n->    let {ch, next} = str::char_range_at(s, i);\n->    std::io::println(#fmt(\"%u: %c\",i,ch));\n->    i = next;\n-> }\n+# Example\n+\n+~~~\n+let s = \\\"\u4e2d\u534eVi\u1ec7t Nam\\\";\n+let i = 0u;\n+while i < str::len(s) {\n+    let {ch, next} = str::char_range_at(s, i);\n+    std::io::println(#fmt(\\\"%u: %c\\\",i,ch));\n+    i = next;\n+}\n+~~~\n \n-Example output:\n+# Example output\n \n-      0: \u4e2d\n-      3: \u534e\n-      6: V\n-      7: i\n-      8: \u1ec7\n-      11: t\n-      12:\n-      13: N\n-      14: a\n-      15: m\n+~~~\n+0: \u4e2d\n+3: \u534e\n+6: V\n+7: i\n+8: \u1ec7\n+11: t\n+12:\n+13: N\n+14: a\n+15: m\n+~~~\n \n-Parameters:\n+# Arguments\n \n-s - The string\n-i - The byte offset of the char to extract\n+* s - The string\n+* i - The byte offset of the char to extract\n \n-Returns:\n+# Return value\n \n A record {ch: char, next: uint} containing the char value and the byte\n index of the next unicode character.\n \n-Failure:\n+# Failure\n \n If `i` is greater than or equal to the length of the string.\n If `i` is not the index of the beginning of a valid UTF-8 character.\n-*/\n+\"]\n fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n@@ -1285,17 +1142,14 @@ fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n     ret {ch: val as char, next: i};\n }\n \n-/*\n-Function: char_at\n-\n-Pluck a character out of a string\n-*/\n+#[doc = \"Pluck a character out of a string\"]\n fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n \n-// Function: char_range_at_reverse\n-//\n-// Given a byte position and a str, return the previous char and its position\n-// This function can be used to iterate over a unicode string in reverse.\n+#[doc = \"\n+Given a byte position and a str, return the previous char and its position\n+\n+This function can be used to iterate over a unicode string in reverse.\n+\"]\n fn char_range_at_reverse(ss: str, start: uint) -> {ch: char, prev: uint} {\n     let mut prev = start;\n \n@@ -1311,28 +1165,28 @@ fn char_range_at_reverse(ss: str, start: uint) -> {ch: char, prev: uint} {\n     ret {ch:ch, prev:prev};\n }\n \n-/*\n-Function: all_between\n-\n+#[doc = \"\n Loop through a substring, char by char\n \n-Parameters:\n-s           - A string to traverse. It may be empty.\n-start       - The byte offset at which to start in the string.\n-end         - The end of the range to traverse\n-it          - A block to execute with each consecutive character of `s`.\n-Return `true` to continue, `false` to stop.\n+# Safety note\n+\n+* This function does not check whether the substring is valid.\n+* This function fails if `byte_offset` or `byte_len` do not\n+  represent valid positions inside `s`\n+\n+# Arguments\n \n-Returns:\n+* s - A string to traverse. It may be empty.\n+* start - The byte offset at which to start in the string.\n+* end - The end of the range to traverse\n+* it - A block to execute with each consecutive character of `s`.\n+       Return `true` to continue, `false` to stop.\n+\n+# Return value\n \n `true` If execution proceeded correctly, `false` if it was interrupted,\n that is if `it` returned `false` at any point.\n-\n-Safety note:\n-- This function does not check whether the substring is valid.\n-- This function fails if `byte_offset` or `byte_len` do not\n- represent valid positions inside `s`\n- */\n+\"]\n fn all_between(s: str, start: uint, end: uint, it: fn(char) -> bool) -> bool {\n     assert is_char_boundary(s, start);\n     let mut i = start;\n@@ -1362,56 +1216,51 @@ const tag_five_b: uint = 248u;\n const max_five_b: uint = 67108864u;\n const tag_six_b: uint = 252u;\n \n-/*\n-Function: as_bytes\n \n-Work with the byte buffer of a string. Allows for unsafe manipulation\n-of strings, which is useful for native interop.\n+#[doc = \"\n+Work with the byte buffer of a string.\n \n-Example:\n+Allows for unsafe manipulation of strings, which is useful for native\n+interop.\n \n-> let i = str::as_bytes(\"Hello World\") { |bytes| vec::len(bytes) };\n+# Example\n \n-*/\n+~~~\n+let i = str::as_bytes(\\\"Hello World\\\") { |bytes| vec::len(bytes) };\n+~~~\n+\"]\n fn as_bytes<T>(s: str, f: fn([u8]) -> T) -> T unsafe {\n     let mut v: [u8] = ::unsafe::reinterpret_cast(s);\n     let r = f(v);\n     ::unsafe::leak(v);\n     r\n }\n \n-/*\n-Function: as_buf\n-\n-Work with the byte buffer of a string. Allows for unsafe manipulation\n-of strings, which is useful for native interop.\n+#[doc = \"\n+Work with the byte buffer of a string.\n \n-Example:\n+Allows for unsafe manipulation of strings, which is useful for native\n+interop.\n \n-> let s = str::as_buf(\"PATH\", { |path_buf| libc::getenv(path_buf) });\n+# Example\n \n-*/\n+```\n+let s = str::as_buf(\\\"PATH\\\", { |path_buf| libc::getenv(path_buf) });\n+```\n+\"]\n fn as_buf<T>(s: str, f: fn(sbuf) -> T) -> T unsafe {\n     as_bytes(s) { |v| vec::as_buf(v, f) }\n }\n \n-/*\n-Type: sbuf\n-\n-An unsafe buffer of bytes.\n-*/\n+#[doc = \"An unsafe buffer of bytes\"]\n type sbuf = *u8;\n \n-// Function: reserve\n-//\n-// Allocate more memory for a string, up to `nn` + 1 bytes\n+#[doc = \"Allocate more memory for a string, up to `nn` + 1 bytes\"]\n fn reserve(&ss: str, nn: uint) {\n     rustrt::str_reserve_shared(ss, nn);\n }\n \n-// Module: unsafe\n-//\n-// These functions may create invalid UTF-8 strings and eat your baby.\n+#[doc = \"These functions may create invalid UTF-8 strings and eat your baby\"]\n mod unsafe {\n    export\n       // FIXME: stop exporting several of these\n@@ -1424,34 +1273,35 @@ mod unsafe {\n       shift_byte,\n       set_len;\n \n-   // Function: unsafe::from_bytes\n-   //\n-   // Converts a vector of bytes to a string. Does not verify that the\n-   // vector contains valid UTF-8.\n+   #[doc = \"\n+   Converts a vector of bytes to a string.\n+\n+   Does not verify that the vector contains valid UTF-8.\n+   \"]\n    unsafe fn from_bytes(v: [const u8]) -> str unsafe {\n        let mut vcopy: [u8] = v + [0u8];\n        let scopy: str = ::unsafe::reinterpret_cast(vcopy);\n        ::unsafe::leak(vcopy);\n        ret scopy;\n    }\n \n-   // Function: unsafe::from_byte\n-   //\n-   // Converts a byte to a string. Does not verify that the byte is\n-   // valid UTF-8.\n-   unsafe fn from_byte(u: u8) -> str { unsafe::from_bytes([u]) }\n+   #[doc = \"\n+   Converts a byte to a string.\n \n-   /*\n-   Function: slice_bytes\n+   Does not verify that the byte is valid UTF-8.\n+   \"]\n+   unsafe fn from_byte(u: u8) -> str { unsafe::from_bytes([u]) }\n \n+   #[doc = \"\n    Takes a bytewise (not UTF-8) slice from a string.\n+\n    Returns the substring from [`begin`..`end`).\n \n-   Failure:\n+   # Failure\n \n-   - If begin is greater than end.\n-   - If end is greater than the length of the string.\n-   */\n+   If begin is greater than end.\n+   If end is greater than the length of the string.\n+   \"]\n    unsafe fn slice_bytes(s: str, begin: uint, end: uint) -> str unsafe {\n        assert (begin <= end);\n        assert (end <= len(s));\n@@ -1463,23 +1313,19 @@ mod unsafe {\n        ret s;\n    }\n \n-   // Function: push_byte\n-   //\n-   // Appends a byte to a string. (Not UTF-8 safe).\n+   #[doc = \"Appends a byte to a string. (Not UTF-8 safe).\"]\n    unsafe fn push_byte(&s: str, b: u8) {\n        rustrt::rust_str_push(s, b);\n    }\n \n-   // Function: push_bytes\n-   //\n-   // Appends a vector of bytes to a string. (Not UTF-8 safe).\n+   #[doc = \"Appends a vector of bytes to a string. (Not UTF-8 safe).\"]\n    unsafe fn push_bytes(&s: str, bytes: [u8]) {\n        for byte in bytes { rustrt::rust_str_push(s, byte); }\n    }\n \n-   // Function: pop_byte\n-   //\n-   // Removes the last byte from a string and returns it.  (Not UTF-8 safe).\n+   #[doc = \"\n+   Removes the last byte from a string and returns it. (Not UTF-8 safe).\n+   \"]\n    unsafe fn pop_byte(&s: str) -> u8 unsafe {\n        let len = len(s);\n        assert (len > 0u);\n@@ -1488,9 +1334,9 @@ mod unsafe {\n        ret b;\n    }\n \n-   // Function: shift_byte\n-   //\n-   // Removes the first byte from a string and returns it. (Not UTF-8 safe).\n+   #[doc = \"\n+   Removes the first byte from a string and returns it. (Not UTF-8 safe).\n+   \"]\n    unsafe fn shift_byte(&s: str) -> u8 unsafe {\n        let len = len(s);\n        assert (len > 0u);"}, {"sha": "b05022c1985f3255eee8a109772b53144fc2f22b", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 18, "deletions": 37, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,8 +1,5 @@\n-/*\n-Module: sys\n+#[doc = \"Misc low level stuff\"]\n \n-Misc low level stuff\n-*/\n enum type_desc = {\n     first_param: **ctypes::c_int,\n     size: ctypes::size_t,\n@@ -31,48 +28,32 @@ native mod rusti {\n     fn frame_address(n: ctypes::c_uint) -> ctypes::uintptr_t;\n }\n \n-/*\n-Function: get_type_desc\n+#[doc = \"\n+Returns a pointer to a type descriptor.\n \n-Returns a pointer to a type descriptor. Useful for calling certain\n-function in the Rust runtime or otherwise performing dark magick.\n-*/\n+Useful for calling certain function in the Rust runtime or otherwise\n+performing dark magick.\n+\"]\n fn get_type_desc<T>() -> *type_desc {\n     ret rusti::get_type_desc::<T>();\n }\n \n-/*\n-Function: last_os_error\n-\n-Get a string representing the platform-dependent last error\n-*/\n+#[doc = \"Get a string representing the platform-dependent last error\"]\n fn last_os_error() -> str {\n     rustrt::last_os_error()\n }\n \n-/*\n-Function: size_of\n-\n-Returns the size of a type\n-*/\n+#[doc = \"Returns the size of a type\"]\n fn size_of<T>() -> uint unsafe {\n     ret (*get_type_desc::<T>()).size;\n }\n \n-/*\n-Function: align_of\n-\n-Returns the alignment of a type\n-*/\n+#[doc = \"Returns the alignment of a type\"]\n fn align_of<T>() -> uint unsafe {\n     ret (*get_type_desc::<T>()).align;\n }\n \n-/*\n-Function: refcount\n-\n-Returns the refcount of a shared box\n-*/\n+#[doc = \"Returns the refcount of a shared box\"]\n fn refcount<T>(t: @T) -> uint {\n     ret rustrt::refcount::<T>(t);\n }\n@@ -81,14 +62,14 @@ fn log_str<T>(t: T) -> str {\n     rustrt::shape_log_str(get_type_desc::<T>(), t)\n }\n \n-#[doc(\n-    brief = \"Sets the process exit code\",\n-    desc = \"Sets the exit code returned by the process if all supervised \\\n-            tasks terminate successfully (without failing). If the current \\\n-            root task fails and is supervised by the scheduler then any \\\n-            user-specified exit status is ignored and the process exits \\\n-            with the default failure status.\"\n-)]\n+#[doc = \"\n+Sets the process exit code\n+\n+Sets the exit code returned by the process if all supervised tasks terminate\n+successfully (without failing). If the current root task fails and is\n+supervised by the scheduler then any user-specified exit status is ignored and\n+the process exits with the default failure status\n+\"]\n fn set_exit_status(code: int) {\n     rustrt::rust_set_exit_status(code as ctypes::intptr_t);\n }"}, {"sha": "322b43e223d6da6caf6f0646f058e023ed9c1432", "filename": "src/libcore/task.rs", "status": "modified", "additions": 18, "deletions": 47, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,5 +1,4 @@\n #[doc = \"\n-\n Task management.\n \n An executing Rust program consists of a tree of tasks, each with their own\n@@ -14,12 +13,13 @@ process.\n \n Tasks may execute in parallel and are scheduled automatically by the runtime.\n \n-Example:\n-\n-    spawn {||\n-        log(error, \\\"Hello, World!\\\");\n-    }\n+# Example\n \n+~~~\n+spawn {||\n+    log(error, \\\"Hello, World!\\\");\n+}\n+~~~\n \"];\n \n export task;\n@@ -58,26 +58,20 @@ export get_task;\n enum task = task_id;\n \n #[doc = \"\n-\n Indicates the manner in which a task exited.\n \n A task that completes without failing and whose supervised children complete\n without failing is considered to exit successfully.\n \n FIXME: This description does not indicate the current behavior for linked\n failure.\n-\n \"]\n enum task_result {\n     success,\n     failure,\n }\n \n-#[doc = \"\n-\n-A message type for notifying of task lifecycle events\n-\n-\"]\n+#[doc = \"A message type for notifying of task lifecycle events\"]\n enum notification {\n     #[doc = \"Sent when a task exits with the task handle and result\"]\n     exit(task, task_result)\n@@ -96,10 +90,9 @@ enum sched_mode {\n }\n \n #[doc = \"\n-\n Scheduler configuration options\n \n-Fields:\n+# Fields\n \n * sched_mode - The operating mode of the scheduler\n \n@@ -110,18 +103,16 @@ Fields:\n     appropriate for running code written in languages like C. By default these\n     native stacks have unspecified size, but with this option their size can\n     be precisely specified.\n-\n \"]\n type sched_opts = {\n     mode: sched_mode,\n     native_stack_size: option<uint>,\n };\n \n #[doc = \"\n-\n Task configuration options\n \n-Fields:\n+# Fields\n \n * supervise - Do not propagate failure to the parent task\n \n@@ -152,11 +143,9 @@ type task_opts = {\n };\n \n #[doc = \"\n-\n The task builder type.\n \n Provides detailed control over the properties and behavior of new tasks.\n-\n \"]\n // NB: Builders are designed to be single-use because they do stateful\n // things that get weird when reusing - e.g. if you create a result future\n@@ -176,12 +165,10 @@ enum task_builder = {\n \n fn default_task_opts() -> task_opts {\n     #[doc = \"\n-\n     The default task options\n \n     By default all tasks are supervised by their parent, are spawned\n     into the same scheduler, and do not post lifecycle notifications.\n-\n     \"];\n \n     {\n@@ -211,7 +198,6 @@ fn get_opts(builder: task_builder) -> task_opts {\n \n fn set_opts(builder: task_builder, opts: task_opts) {\n     #[doc = \"\n-\n     Set the task_opts associated with a task_builder\n \n     To update a single option use a pattern like the following:\n@@ -220,15 +206,13 @@ fn set_opts(builder: task_builder, opts: task_opts) {\n             supervise: false\n             with get_opts(builder)\n         });\n-\n     \"];\n \n     builder.opts = opts;\n }\n \n fn add_wrapper(builder: task_builder, gen_body: fn@(+fn~()) -> fn~()) {\n     #[doc = \"\n-\n     Add a wrapper to the body of the spawned task.\n \n     Before the task is spawned it is passed through a 'body generator'\n@@ -239,7 +223,6 @@ fn add_wrapper(builder: task_builder, gen_body: fn@(+fn~()) -> fn~()) {\n     This function augments the current body generator with a new body\n     generator by applying the task body which results from the\n     existing body generator to the new body generator.\n-\n     \"];\n \n     let prev_gen_body = builder.gen_body;\n@@ -249,20 +232,18 @@ fn add_wrapper(builder: task_builder, gen_body: fn@(+fn~()) -> fn~()) {\n }\n \n fn run(-builder: task_builder, +f: fn~()) {\n-    #[doc(desc = \"\n-\n+    #[doc = \"\n     Creates and exucutes a new child task\n \n     Sets up a new task with its own call stack and schedules it to run\n     the provided unique closure. The task has the properties and behavior\n     specified by `builder`.\n \n-    \", failure = \"\n+    # Failure\n \n     When spawning into a new scheduler, the number of threads requested\n     must be greater than zero.\n-\n-    \")];\n+    \"];\n \n     let body = builder.gen_body(f);\n     spawn_raw(builder.opts, body);\n@@ -273,7 +254,6 @@ fn run(-builder: task_builder, +f: fn~()) {\n \n fn future_result(builder: task_builder) -> future::future<task_result> {\n     #[doc = \"\n-\n     Get a future representing the exit status of the task.\n \n     Taking the value of the future will block until the child task terminates.\n@@ -283,7 +263,6 @@ fn future_result(builder: task_builder) -> future::future<task_result> {\n     builder. If additional tasks are spawned with the same builder\n     then a new result future must be obtained prior to spawning each\n     task.\n-\n     \"];\n \n     // FIXME (1087, 1857): Once linked failure and notification are\n@@ -332,7 +311,6 @@ fn unsupervise(builder: task_builder) {\n fn run_listener<A:send>(-builder: task_builder,\n                         +f: fn~(comm::port<A>)) -> comm::chan<A> {\n     #[doc = \"\n-\n     Runs a new task while providing a channel from the parent to the child\n \n     Sets up a communication channel from the current task to the new\n@@ -362,7 +340,6 @@ fn run_listener<A:send>(-builder: task_builder,\n \n fn spawn(+f: fn~()) {\n     #[doc = \"\n-\n     Creates and exucutes a new child task\n \n     Sets up a new task with its own call stack and schedules it to run\n@@ -376,7 +353,6 @@ fn spawn(+f: fn~()) {\n \n fn spawn_listener<A:send>(+f: fn~(comm::port<A>)) -> comm::chan<A> {\n     #[doc = \"\n-\n     Runs a new task while providing a channel from the parent to the child\n \n     Sets up a communication channel from the current task to the new\n@@ -399,27 +375,24 @@ fn spawn_listener<A:send>(+f: fn~(comm::port<A>)) -> comm::chan<A> {\n         // Likewise, the parent has both a 'po' and 'ch'\n \n     This function is equivalent to `run_listener(mk_task_builder(), f)`.\n-\n     \"];\n \n     run_listener(mk_task_builder(), f)\n }\n \n fn spawn_sched(mode: sched_mode, +f: fn~()) {\n-    #[doc(desc = \"\n-\n+    #[doc = \"\n     Creates a new scheduler and executes a task on it\n \n     Tasks subsequently spawned by that task will also execute on\n     the new scheduler. When there are no more tasks to execute the\n     scheduler terminates.\n \n-    \", failure = \"\n+    # Failure\n \n     In manual threads mode the number of threads requested must be\n     greater than zero.\n-\n-    \")];\n+    \"];\n \n     let mut builder = mk_task_builder();\n     set_opts(builder, {\n@@ -433,18 +406,16 @@ fn spawn_sched(mode: sched_mode, +f: fn~()) {\n }\n \n fn try<T:send>(+f: fn~() -> T) -> result::t<T,()> {\n-    #[doc(desc = \"\n-\n+    #[doc = \"\n     Execute a function in another task and return either the return value\n     of the function or result::err.\n \n-    \", return = \"\n+    # Return value\n \n     If the function executed successfully then try returns result::ok\n     containing the value returned by the function. If the function fails\n     then try returns result::err containing nil.\n-\n-    \")];\n+    \"];\n \n     let po = comm::port();\n     let ch = comm::chan(po);"}, {"sha": "2f92ae08f0e74a4c7390e896bd07199f76d43d2b", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,7 +1,3 @@\n-/*\n-Module: tuple\n-*/\n-\n fn first<T:copy, U:copy>(pair: (T, U)) -> T {\n     let (t, _) = pair;\n     ret t;"}, {"sha": "da60b7a5a1dd0776cec8d145f36328d757de3668", "filename": "src/libcore/u32.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu32.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,64 +1,25 @@\n #[doc = \"Operations and constants for `u32`\"];\n \n-/*\n-Module: u32\n-*/\n-\n-/*\n-Const: min_value\n-\n-Return the minimal value for a u32\n-*/\n const min_value: u32 = 0u32;\n-\n-/*\n-Const: max_value\n-\n-Return the maximal value for a u32\n-*/\n const max_value: u32 = 0u32 - 1u32;\n \n pure fn min(x: u32, y: u32) -> u32 { if x < y { x } else { y } }\n pure fn max(x: u32, y: u32) -> u32 { if x > y { x } else { y } }\n \n-/* Function: add */\n pure fn add(x: u32, y: u32) -> u32 { ret x + y; }\n-\n-/* Function: sub */\n pure fn sub(x: u32, y: u32) -> u32 { ret x - y; }\n-\n-/* Function: mul */\n pure fn mul(x: u32, y: u32) -> u32 { ret x * y; }\n-\n-/* Function: div */\n pure fn div(x: u32, y: u32) -> u32 { ret x / y; }\n-\n-/* Function: rem */\n pure fn rem(x: u32, y: u32) -> u32 { ret x % y; }\n \n-/* Predicate: lt */\n pure fn lt(x: u32, y: u32) -> bool { ret x < y; }\n-\n-/* Predicate: le */\n pure fn le(x: u32, y: u32) -> bool { ret x <= y; }\n-\n-/* Predicate: eq */\n pure fn eq(x: u32, y: u32) -> bool { ret x == y; }\n-\n-/* Predicate: ne */\n pure fn ne(x: u32, y: u32) -> bool { ret x != y; }\n-\n-/* Predicate: ge */\n pure fn ge(x: u32, y: u32) -> bool { ret x >= y; }\n-\n-/* Predicate: gt */\n pure fn gt(x: u32, y: u32) -> bool { ret x > y; }\n \n-/*\n-Function: range\n-\n-Iterate over the range [`lo`..`hi`)\n-*/\n+#[doc = \"Iterate over the range [`lo`..`hi`)\"]\n fn range(lo: u32, hi: u32, it: fn(u32)) {\n     let mut i = lo;\n     while i < hi { it(i); i += 1u32; }"}, {"sha": "6907ad5fe03698029a5e677e55207e76303b3595", "filename": "src/libcore/u64.rs", "status": "modified", "additions": 4, "deletions": 55, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu64.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,74 +1,31 @@\n #[doc = \"Operations and constants for `u64`\"];\n \n-/*\n-Module: u64\n-*/\n-\n-/*\n-Const: min_value\n-\n-Return the minimal value for a u64\n-*/\n const min_value: u64 = 0u64;\n-\n-/*\n-Const: max_value\n-\n-Return the maximal value for a u64\n-*/\n const max_value: u64 = 0u64 - 1u64;\n \n pure fn min(x: u64, y: u64) -> u64 { if x < y { x } else { y } }\n pure fn max(x: u64, y: u64) -> u64 { if x > y { x } else { y } }\n \n-/* Function: add */\n pure fn add(x: u64, y: u64) -> u64 { ret x + y; }\n-\n-/* Function: sub */\n pure fn sub(x: u64, y: u64) -> u64 { ret x - y; }\n-\n-/* Function: mul */\n pure fn mul(x: u64, y: u64) -> u64 { ret x * y; }\n-\n-/* Function: div */\n pure fn div(x: u64, y: u64) -> u64 { ret x / y; }\n-\n-/* Function: rem */\n pure fn rem(x: u64, y: u64) -> u64 { ret x % y; }\n \n-/* Predicate: lt */\n pure fn lt(x: u64, y: u64) -> bool { ret x < y; }\n-\n-/* Predicate: le */\n pure fn le(x: u64, y: u64) -> bool { ret x <= y; }\n-\n-/* Predicate: eq */\n pure fn eq(x: u64, y: u64) -> bool { ret x == y; }\n-\n-/* Predicate: ne */\n pure fn ne(x: u64, y: u64) -> bool { ret x != y; }\n-\n-/* Predicate: ge */\n pure fn ge(x: u64, y: u64) -> bool { ret x >= y; }\n-\n-/* Predicate: gt */\n pure fn gt(x: u64, y: u64) -> bool { ret x > y; }\n \n-/*\n-Function: range\n-\n-Iterate over the range [`lo`..`hi`)\n-*/\n+#[doc = \"Iterate over the range [`lo`..`hi`)\"]\n fn range(lo: u64, hi: u64, it: fn(u64)) {\n     let mut i = lo;\n     while i < hi { it(i); i += 1u64; }\n }\n \n-/*\n-Function: to_str\n-\n-Convert to a string in a given base\n-*/\n+#[doc = \"Convert to a string in a given base\"]\n fn to_str(n: u64, radix: uint) -> str {\n     assert (0u < radix && radix <= 16u);\n \n@@ -105,18 +62,10 @@ fn to_str(n: u64, radix: uint) -> str {\n     ret s;\n }\n \n-/*\n-Function: str\n-\n-Convert to a string\n-*/\n+#[doc = \"Convert to a string\"]\n fn str(n: u64) -> str { ret to_str(n, 10u); }\n \n-/*\n-Function: from_str\n-\n-Parse a string as an unsigned integer.\n-*/\n+#[doc = \"Parse a string as an unsigned integer.\"]\n fn from_str(buf: str, radix: u64) -> option<u64> {\n     if str::len(buf) == 0u { ret none; }\n     let mut i = str::len(buf) - 1u;"}, {"sha": "397d78572a3a7ede987261383801926856544864", "filename": "src/libcore/u8.rs", "status": "modified", "additions": 4, "deletions": 41, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu8.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,64 +1,27 @@\n #[doc = \"Operations and constants for `u8`\"];\n \n-/*\n-Module: u8\n-*/\n-\n-/*\n-Const: min_value\n-\n-The minumum value of a u8.\n-*/\n const min_value: u8 = 0u8;\n-\n-/*\n-Const: max_value\n-\n-The maximum value of a u8.\n-*/\n const max_value: u8 = 0u8 - 1u8;\n \n-/* Function: add */\n-pure fn add(x: u8, y: u8) -> u8 { ret x + y; }\n+pure fn min(x: u8, y: u8) -> u8 { if x < y { x } else { y } }\n+pure fn max(x: u8, y: u8) -> u8 { if x > y { x } else { y } }\n \n-/* Function: sub */\n+pure fn add(x: u8, y: u8) -> u8 { ret x + y; }\n pure fn sub(x: u8, y: u8) -> u8 { ret x - y; }\n-\n-/* Function: mul */\n pure fn mul(x: u8, y: u8) -> u8 { ret x * y; }\n-\n-/* Function: div */\n pure fn div(x: u8, y: u8) -> u8 { ret x / y; }\n-\n-/* Function: rem */\n pure fn rem(x: u8, y: u8) -> u8 { ret x % y; }\n \n-/* Predicate: lt */\n pure fn lt(x: u8, y: u8) -> bool { ret x < y; }\n-\n-/* Predicate: le */\n pure fn le(x: u8, y: u8) -> bool { ret x <= y; }\n-\n-/* Predicate: eq */\n pure fn eq(x: u8, y: u8) -> bool { ret x == y; }\n-\n-/* Predicate: ne */\n pure fn ne(x: u8, y: u8) -> bool { ret x != y; }\n-\n-/* Predicate: ge */\n pure fn ge(x: u8, y: u8) -> bool { ret x >= y; }\n-\n-/* Predicate: gt */\n pure fn gt(x: u8, y: u8) -> bool { ret x > y; }\n \n-/* Predicate: is_ascii */\n pure fn is_ascii(x: u8) -> bool { ret 0u8 == x & 128u8; }\n \n-/*\n-Function: range\n-\n-Iterate over the range [`lo`..`hi`)\n-*/\n+#[doc = \"Iterate over the range [`lo`..`hi`)\"]\n fn range(lo: u8, hi: u8, it: fn(u8)) {\n     let mut i = lo;\n     while i < hi { it(i); i += 1u8; }"}, {"sha": "8e57eab7ea7769d5cc975c8ff6107c8709fba348", "filename": "src/libcore/uint.rs", "status": "modified", "additions": 63, "deletions": 140, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,158 +1,103 @@\n #[doc = \"Operations and constants for `uint`\"];\n \n-/*\n-Module: uint\n-*/\n-\n-/*\n-Const: min_value\n-\n-Return the minimal value for an uint.\n-\n-This is always 0\n-*/\n const min_value: uint = 0u;\n-\n-/*\n-Const: max_value\n-\n-Return the maximal value for an uint.\n-\n-This is 2^wordsize - 1\n-*/\n const max_value: uint = 0u - 1u;\n \n-/*\n-Function: min\n-*/\n-pure fn min(x: uint, y: uint) -> uint {\n-    if x < y { x } else { y }\n-}\n-\n-/*\n-Function: max\n-*/\n-pure fn max(x: uint, y: uint) -> uint {\n-    if x > y { x } else { y }\n-}\n+pure fn min(x: uint, y: uint) -> uint { if x < y { x } else { y } }\n+pure fn max(x: uint, y: uint) -> uint { if x > y { x } else { y } }\n \n-/* Function: add */\n pure fn add(x: uint, y: uint) -> uint { ret x + y; }\n-\n-/* Function: sub */\n pure fn sub(x: uint, y: uint) -> uint { ret x - y; }\n-\n-/* Function: mul */\n pure fn mul(x: uint, y: uint) -> uint { ret x * y; }\n-\n-/* Function: div */\n pure fn div(x: uint, y: uint) -> uint { ret x / y; }\n \n-/* Function: div_ceil\n+pure fn rem(x: uint, y: uint) -> uint { ret x % y; }\n+pure fn lt(x: uint, y: uint) -> bool { ret x < y; }\n+pure fn le(x: uint, y: uint) -> bool { ret x <= y; }\n+pure fn eq(x: uint, y: uint) -> bool { ret x == y; }\n+pure fn ne(x: uint, y: uint) -> bool { ret x != y; }\n+pure fn ge(x: uint, y: uint) -> bool { ret x >= y; }\n+pure fn gt(x: uint, y: uint) -> bool { ret x > y; }\n+\n+\n+#[doc = \"\n+Divide two numbers, return the result, rounded up.\n \n-   Divide two numbers, return the result, rounded up.\n+# Arguments\n \n-   Parameters:\n-   x - an integer\n-   y - an integer distinct from 0u\n+* x - an integer\n+* y - an integer distinct from 0u\n \n-   Return:\n-    The smallest integer `q` such that `x/y <= q`.\n-*/\n+# Return value\n+\n+The smallest integer `q` such that `x/y <= q`.\n+\"]\n pure fn div_ceil(x: uint, y: uint) -> uint {\n     let div = div(x, y);\n     if x % y == 0u { ret div;}\n     else { ret div + 1u; }\n }\n \n-/* Function: div_ceil\n+#[doc = \"\n+Divide two numbers, return the result, rounded to the closest integer.\n+\n+# Arguments\n \n-   Divide two numbers, return the result, rounded to the closest integer.\n+* x - an integer\n+* y - an integer distinct from 0u\n \n-   Parameters:\n-   x - an integer\n-   y - an integer distinct from 0u\n+# Return value\n \n-   Return:\n-    The integer `q` closest to `x/y`.\n-*/\n+The integer `q` closest to `x/y`.\n+\"]\n pure fn div_round(x: uint, y: uint) -> uint {\n     let div = div(x, y);\n     if x % y * 2u  < y { ret div;}\n     else { ret div + 1u; }\n }\n \n-/* Function: div_ceil\n-\n-   Divide two numbers, return the result, rounded down.\n+#[doc = \"\n+Divide two numbers, return the result, rounded down.\n \n-   Parameters:\n-   x - an integer\n-   y - an integer distinct from 0u\n+Note: This is the same function as `div`.\n \n-   Note: This is the same function as `div`.\n+# Arguments\n \n-   Return:\n-    The smallest integer `q` such that `x/y <= q`. This\n-   is either `x/y` or `x/y + 1`.\n-*/\n-pure fn div_floor(x: uint, y: uint) -> uint { ret x / y; }\n-\n-/* Function: rem */\n-pure fn rem(x: uint, y: uint) -> uint { ret x % y; }\n-\n-/* Predicate: lt */\n-pure fn lt(x: uint, y: uint) -> bool { ret x < y; }\n-\n-/* Predicate: le */\n-pure fn le(x: uint, y: uint) -> bool { ret x <= y; }\n-\n-/* Predicate: eq */\n-pure fn eq(x: uint, y: uint) -> bool { ret x == y; }\n-\n-/* Predicate: ne */\n-pure fn ne(x: uint, y: uint) -> bool { ret x != y; }\n-\n-/* Predicate: ge */\n-pure fn ge(x: uint, y: uint) -> bool { ret x >= y; }\n+* x - an integer\n+* y - an integer distinct from 0u\n \n-/* Predicate: gt */\n-pure fn gt(x: uint, y: uint) -> bool { ret x > y; }\n+# Return value\n \n-/*\n-Function: hash\n+The smallest integer `q` such that `x/y <= q`. This\n+is either `x/y` or `x/y + 1`.\n+\"]\n+pure fn div_floor(x: uint, y: uint) -> uint { ret x / y; }\n \n-Produce a uint suitable for use in a hash table\n-*/\n+#[doc = \"Produce a uint suitable for use in a hash table\"]\n fn hash(x: uint) -> uint { ret x; }\n \n-/*\n-Function: range\n-\n-Iterate over the range [`lo`..`hi`)\n-*/\n+#[doc = \"Iterate over the range [`lo`..`hi`)\"]\n #[inline(always)]\n fn range(lo: uint, hi: uint, it: fn(uint)) {\n     let mut i = lo;\n     while i < hi { it(i); i += 1u; }\n }\n \n-/*\n-Function: iterate\n-\n+#[doc = \"\n Iterate over the range [`lo`..`hi`), or stop when requested\n \n-Parameters:\n-lo - The integer at which to start the loop (included)\n-hi - The integer at which to stop the loop (excluded)\n-it - A block to execute with each consecutive integer of the range.\n-Return `true` to continue, `false` to stop.\n+# Arguments\n+\n+* lo - The integer at which to start the loop (included)\n+* hi - The integer at which to stop the loop (excluded)\n+* it - A block to execute with each consecutive integer of the range.\n+       Return `true` to continue, `false` to stop.\n \n-Returns:\n+# Return value\n \n `true` If execution proceeded correctly, `false` if it was interrupted,\n that is if `it` returned `false` at any point.\n-*/\n+\"]\n fn iterate(lo: uint, hi: uint, it: fn(uint) -> bool) -> bool {\n     let mut i = lo;\n     while i < hi {\n@@ -162,11 +107,7 @@ fn iterate(lo: uint, hi: uint, it: fn(uint) -> bool) -> bool {\n     ret true;\n }\n \n-/*\n-Function: next_power_of_two\n-\n-Returns the smallest power of 2 greater than or equal to `n`\n-*/\n+#[doc = \"Returns the smallest power of 2 greater than or equal to `n`\"]\n fn next_power_of_two(n: uint) -> uint {\n     let halfbits: uint = sys::size_of::<uint>() * 4u;\n     let mut tmp: uint = n - 1u;\n@@ -175,20 +116,18 @@ fn next_power_of_two(n: uint) -> uint {\n     ret tmp + 1u;\n }\n \n-/*\n-Function: parse_buf\n-\n+#[doc = \"\n Parse a buffer of bytes\n \n-Parameters:\n+# Arguments\n \n-buf - A byte buffer\n-radix - The base of the number\n+* buf - A byte buffer\n+* radix - The base of the number\n \n-Failure:\n+# Failure\n \n-buf must not be empty\n-*/\n+`buf` must not be empty\n+\"]\n fn parse_buf(buf: [u8], radix: uint) -> option<uint> {\n     if vec::len(buf) == 0u { ret none; }\n     let mut i = vec::len(buf) - 1u;\n@@ -206,18 +145,10 @@ fn parse_buf(buf: [u8], radix: uint) -> option<uint> {\n     fail;\n }\n \n-/*\n-Function: from_str\n-\n-Parse a string to an int\n-*/\n+#[doc = \"Parse a string to an int\"]\n fn from_str(s: str) -> option<uint> { parse_buf(str::bytes(s), 10u) }\n \n-/*\n-Function: to_str\n-\n-Convert to a string in a given base\n-*/\n+#[doc = \"Convert to a string in a given base\"]\n fn to_str(num: uint, radix: uint) -> str {\n     let mut n = num;\n     assert (0u < radix && radix <= 16u);\n@@ -254,18 +185,10 @@ fn to_str(num: uint, radix: uint) -> str {\n     ret s1;\n }\n \n-/*\n-Function: str\n-\n-Convert to a string\n-*/\n+#[doc = \"Convert to a string\"]\n fn str(i: uint) -> str { ret to_str(i, 10u); }\n \n-/*\n-Function: compl\n-\n-Computes the bitwise complement.\n-*/\n+#[doc = \"Computes the bitwise complement\"]\n fn compl(i: uint) -> uint {\n     max_value ^ i\n }"}, {"sha": "de120b8cc78ad2fa0b81cdbe6b459767af329c59", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -2565,6 +2565,7 @@ mod general_category {\n \n }\n mod derived_property {\n+    #[doc = \"Check if a character has the alphabetic unicode property\"]\n     pure fn Alphabetic(c: char) -> bool {\n         ret alt c {\n               '\\x41' to '\\x5a'"}, {"sha": "c7ba9ffe154a65a4d488e19652d48417b3683cda", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,8 +1,4 @@\n-/*\n-Module: unsafe\n-\n-Unsafe operations\n-*/\n+#[doc = \"Unsafe operations\"];\n \n export reinterpret_cast, leak;\n \n@@ -12,11 +8,9 @@ native mod rusti {\n     fn leak<T>(-thing: T);\n }\n \n-/*\n-Function: reinterpret_cast\n-\n+#[doc = \"\n Casts the value at `src` to U. The two types must have the same length.\n-*/\n+\"]\n #[inline(always)]\n unsafe fn reinterpret_cast<T, U>(src: T) -> U {\n     let t1 = sys::get_type_desc::<T>();\n@@ -27,16 +21,14 @@ unsafe fn reinterpret_cast<T, U>(src: T) -> U {\n     ret rusti::cast(src);\n }\n \n-/*\n-Function: leak\n-\n-Move `thing` into the void.\n+#[doc =\"\n+Move a thing into the void\n \n The leak function will take ownership of the provided value but neglect\n to run any required cleanup or memory-management operations on it. This\n can be used for various acts of magick, particularly when using\n reinterpret_cast on managed pointer types.\n-*/\n+\"]\n #[inline(always)]\n unsafe fn leak<T>(-thing: T) { rusti::leak(thing); }\n "}, {"sha": "e5bc29b52956447e22954973c4733450885c58f0", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 150, "deletions": 403, "changes": 553, "blob_url": "https://github.com/rust-lang/rust/blob/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22556a6f818845cd400ad58065a83916ba591a7/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=b22556a6f818845cd400ad58065a83916ba591a7", "patch": "@@ -1,7 +1,3 @@\n-/*\n-Module: vec\n-*/\n-\n import option::{some, none};\n import uint::next_power_of_two;\n import ptr::addr_of;\n@@ -21,74 +17,49 @@ native mod rustrt {\n                               count: ctypes::size_t) -> [T];\n }\n \n-/*\n-Type: init_op\n-\n-A function used to initialize the elements of a vector.\n-*/\n+#[doc = \"A function used to initialize the elements of a vector\"]\n type init_op<T> = fn(uint) -> T;\n \n-\n-/*\n-Predicate: is_empty\n-\n-Returns true if a vector contains no elements.\n-*/\n+#[doc = \"Returns true if a vector contains no elements\"]\n pure fn is_empty<T>(v: [const T]) -> bool {\n     // FIXME: This would be easier if we could just call len\n     for t: T in v { ret false; }\n     ret true;\n }\n \n-/*\n-Predicate: is_not_empty\n-\n-Returns true if a vector contains some elements.\n-*/\n+#[doc = \"Returns true if a vector contains some elements\"]\n pure fn is_not_empty<T>(v: [const T]) -> bool { ret !is_empty(v); }\n \n-/*\n-Predicate: same_length\n-\n-Returns true if two vectors have the same length\n-*/\n+#[doc = \"Returns true if two vectors have the same length\"]\n pure fn same_length<T, U>(xs: [const T], ys: [const U]) -> bool {\n     vec::len(xs) == vec::len(ys)\n }\n \n-/*\n-Function: reserve\n-\n+#[doc = \"\n Reserves capacity for `n` elements in the given vector.\n \n If the capacity for `v` is already equal to or greater than the requested\n capacity, then no action is taken.\n \n-Parameters:\n+# Arguments\n \n-v - A vector\n-n - The number of elements to reserve space for\n-*/\n+* v - A vector\n+* n - The number of elements to reserve space for\n+\"]\n fn reserve<T>(&v: [const T], n: uint) {\n     rustrt::vec_reserve_shared(sys::get_type_desc::<T>(), v, n);\n }\n \n-/*\n-Function: len\n-\n-Returns the length of a vector\n-*/\n+#[doc = \"Returns the length of a vector\"]\n #[inline(always)]\n pure fn len<T>(v: [const T]) -> uint { unchecked { rusti::vec_len(v) } }\n \n-/*\n-Function: init_fn\n-\n+#[doc = \"\n Creates and initializes an immutable vector.\n \n Creates an immutable vector of size `n_elts` and initializes the elements\n to the value returned by the function `op`.\n-*/\n+\"]\n fn init_fn<T>(n_elts: uint, op: init_op<T>) -> [T] {\n     let mut v = [];\n     reserve(v, n_elts);\n@@ -97,14 +68,12 @@ fn init_fn<T>(n_elts: uint, op: init_op<T>) -> [T] {\n     ret v;\n }\n \n-/*\n-Function: init_elt\n-\n+#[doc = \"\n Creates and initializes an immutable vector.\n \n Creates an immutable vector of size `n_elts` and initializes the elements\n to the value `t`.\n-*/\n+\"]\n fn init_elt<T: copy>(n_elts: uint, t: T) -> [T] {\n     let mut v = [];\n     reserve(v, n_elts);\n@@ -115,22 +84,14 @@ fn init_elt<T: copy>(n_elts: uint, t: T) -> [T] {\n \n // FIXME: Possible typestate postcondition:\n // len(result) == len(v) (needs issue #586)\n-/*\n-\n-\n-Produces a mutable vector from an immutable vector.\n-*/\n+#[doc = \"Produces a mutable vector from an immutable vector.\"]\n fn to_mut<T>(+v: [T]) -> [mutable T] unsafe {\n     let r = ::unsafe::reinterpret_cast(v);\n     ::unsafe::leak(v);\n     r\n }\n \n-/*\n-Function: from_mut\n-\n-Produces an immutable vector from a mutable vector.\n-*/\n+#[doc = \"Produces an immutable vector from a mutable vector.\"]\n fn from_mut<T>(+v: [mutable T]) -> [T] unsafe {\n     let r = ::unsafe::reinterpret_cast(v);\n     ::unsafe::leak(v);\n@@ -139,79 +100,46 @@ fn from_mut<T>(+v: [mutable T]) -> [T] unsafe {\n \n // Accessors\n \n-/*\n-Function: head\n-\n-Returns the first element of a vector\n-\n-Predicates:\n-<is_not_empty> (v)\n-*/\n+#[doc = \"Returns the first element of a vector\"]\n pure fn head<T: copy>(v: [const T]) -> T { v[0] }\n \n-/*\n-Function: tail\n-\n-Returns all but the first element of a vector\n-*/\n+#[doc = \"Returns all but the first element of a vector\"]\n fn tail<T: copy>(v: [const T]) -> [T] {\n     ret slice(v, 1u, len(v));\n }\n \n-/*\n-Function tail_n\n-\n-Returns all but the first N elements of a vector\n-*/\n-\n+#[doc = \"Returns all but the first `n` elements of a vector\"]\n fn tail_n<T: copy>(v: [const T], n: uint) -> [T] {\n     slice(v, n, len(v))\n }\n \n // FIXME: This name is sort of confusing next to init_fn, etc\n // but this is the name haskell uses for this function,\n // along with head/tail/last.\n-/*\n-Function: init\n-\n-Returns all but the last elemnt of a vector\n-\n-Preconditions:\n-`v` is not empty\n-*/\n+#[doc = \"Returns all but the last elemnt of a vector\"]\n fn init<T: copy>(v: [const T]) -> [T] {\n     assert len(v) != 0u;\n     slice(v, 0u, len(v) - 1u)\n }\n \n-/*\n-Function: last\n-\n+#[doc = \"\n Returns the last element of a `v`, failing if the vector is empty.\n-\n-*/\n+\"]\n pure fn last<T: copy>(v: [const T]) -> T {\n     if len(v) == 0u { fail \"last_unsafe: empty vector\" }\n     v[len(v) - 1u]\n }\n \n-/*\n-Function: last_opt\n-\n+#[doc = \"\n Returns some(x) where `x` is the last element of a vector `v`,\n or none if the vector is empty.\n-\n-*/\n+\"]\n pure fn last_opt<T: copy>(v: [const T]) -> option<T> {\n-    if len(v) == 0u { ret none; }\n+   if len(v) == 0u { ret none; }\n     some(v[len(v) - 1u])\n }\n \n-/*\n-Function: slice\n-\n-Returns a copy of the elements from [`start`..`end`) from `v`.\n-*/\n+#[doc = \"Returns a copy of the elements from [`start`..`end`) from `v`.\"]\n fn slice<T: copy>(v: [const T], start: uint, end: uint) -> [T] {\n     assert (start <= end);\n     assert (end <= len(v));\n@@ -222,11 +150,9 @@ fn slice<T: copy>(v: [const T], start: uint, end: uint) -> [T] {\n     ret result;\n }\n \n-/*\n-Function: split\n-\n+#[doc = \"\n Split the vector `v` by applying each element against the predicate `f`.\n-*/\n+\"]\n fn split<T: copy>(v: [const T], f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n@@ -246,12 +172,10 @@ fn split<T: copy>(v: [const T], f: fn(T) -> bool) -> [[T]] {\n     result\n }\n \n-/*\n-Function: splitn\n-\n+#[doc = \"\n Split the vector `v` by applying each element against the predicate `f` up\n to `n` times.\n-*/\n+\"]\n fn splitn<T: copy>(v: [const T], n: uint, f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n@@ -274,12 +198,10 @@ fn splitn<T: copy>(v: [const T], n: uint, f: fn(T) -> bool) -> [[T]] {\n     result\n }\n \n-/*\n-Function: rsplit\n-\n+#[doc = \"\n Reverse split the vector `v` by applying each element against the predicate\n `f`.\n-*/\n+\"]\n fn rsplit<T: copy>(v: [const T], f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n@@ -299,12 +221,10 @@ fn rsplit<T: copy>(v: [const T], f: fn(T) -> bool) -> [[T]] {\n     reversed(result)\n }\n \n-/*\n-Function: rsplitn\n-\n+#[doc = \"\n Reverse split the vector `v` by applying each element against the predicate\n `f` up to `n times.\n-*/\n+\"]\n fn rsplitn<T: copy>(v: [const T], n: uint, f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n@@ -329,11 +249,7 @@ fn rsplitn<T: copy>(v: [const T], n: uint, f: fn(T) -> bool) -> [[T]] {\n \n // Mutators\n \n-/*\n-Function: shift\n-\n-Removes the first element from a vector and return it\n-*/\n+#[doc = \"Removes the first element from a vector and return it\"]\n fn shift<T: copy>(&v: [const T]) -> T {\n     let ln = len::<T>(v);\n     assert (ln > 0u);\n@@ -342,11 +258,7 @@ fn shift<T: copy>(&v: [const T]) -> T {\n     ret e;\n }\n \n-/*\n-Function: pop\n-\n-Remove the last element from a vector and return it\n-*/\n+#[doc = \"Remove the last element from a vector and return it\"]\n fn pop<T>(&v: [const T]) -> T unsafe {\n     let ln = len(v);\n     assert ln > 0u;\n@@ -356,67 +268,56 @@ fn pop<T>(&v: [const T]) -> T unsafe {\n     val\n }\n \n-/*\n-Function: push\n-\n-Append an element to a vector\n-*/\n+#[doc = \"Append an element to a vector\"]\n fn push<T: copy>(&v: [const T], initval: T) {\n     v += [initval];\n }\n \n-// TODO: More.\n-\n \n // Appending\n \n-/*\n-Function: grow\n-\n+#[doc = \"\n Expands a vector in place, initializing the new elements to a given value\n \n-Parameters:\n+# Arguments\n \n-v - The vector to grow\n-n - The number of elements to add\n-initval - The value for the new elements\n-*/\n+* v - The vector to grow\n+* n - The number of elements to add\n+* initval - The value for the new elements\n+\"]\n fn grow<T: copy>(&v: [const T], n: uint, initval: T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let mut i: uint = 0u;\n     while i < n { v += [initval]; i += 1u; }\n }\n \n-/*\n-Function: grow_fn\n-\n-Expands a vector in place, initializing the new elements to the result of a\n-function\n+#[doc = \"\n+Expands a vector in place, initializing the new elements to the result of\n+a function\n \n Function `init_op` is called `n` times with the values [0..`n`)\n \n-Parameters:\n+# Arguments\n \n-v - The vector to grow\n-n - The number of elements to add\n-init_op - A function to call to retreive each appended element's value\n-*/\n+* v - The vector to grow\n+* n - The number of elements to add\n+* init_op - A function to call to retreive each appended element's\n+            value\n+\"]\n fn grow_fn<T>(&v: [const T], n: uint, op: init_op<T>) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let mut i: uint = 0u;\n     while i < n { v += [op(i)]; i += 1u; }\n }\n \n-/*\n-Function: grow_set\n-\n+#[doc = \"\n Sets the value of a vector element at a given index, growing the vector as\n needed\n \n Sets the element at position `index` to `val`. If `index` is past the end\n of the vector, expands the vector by replicating `initval` to fill the\n intervening space.\n-*/\n+\"]\n fn grow_set<T: copy>(&v: [mutable T], index: uint, initval: T, val: T) {\n     if index >= len(v) { grow(v, index - len(v) + 1u, initval); }\n     v[index] = val;\n@@ -425,23 +326,19 @@ fn grow_set<T: copy>(&v: [mutable T], index: uint, initval: T, val: T) {\n \n // Functional utilities\n \n-/*\n-Function: map\n-\n+#[doc =\"\n Apply a function to each element of a vector and return the results\n-*/\n+\"]\n fn map<T, U>(v: [T], f: fn(T) -> U) -> [U] {\n     let mut result = [];\n     reserve(result, len(v));\n     for elem: T in v { result += [f(elem)]; }\n     ret result;\n }\n \n-/*\n-Function: map2\n-\n+#[doc = \"\n Apply a function to each pair of elements and return the results\n-*/\n+\"]\n fn map2<T: copy, U: copy, V>(v0: [const T], v1: [const U],\n                              f: fn(T, U) -> V) -> [V] {\n     let v0_len = len(v0);\n@@ -452,14 +349,12 @@ fn map2<T: copy, U: copy, V>(v0: [const T], v1: [const U],\n     ret u;\n }\n \n-/*\n-Function: filter_map\n-\n+#[doc = \"\n Apply a function to each element of a vector and return the results\n \n If function `f` returns `none` then that element is excluded from\n the resulting vector.\n-*/\n+\"]\n fn filter_map<T: copy, U: copy>(v: [const T], f: fn(T) -> option<U>)\n     -> [U] {\n     let mut result = [];\n@@ -472,15 +367,13 @@ fn filter_map<T: copy, U: copy>(v: [const T], f: fn(T) -> option<U>)\n     ret result;\n }\n \n-/*\n-Function: filter\n-\n+#[doc = \"\n Construct a new vector from the elements of a vector for which some predicate\n holds.\n \n Apply function `f` to each element of `v` and return a vector containing\n only those elements for which `f` returned true.\n-*/\n+\"]\n fn filter<T: copy>(v: [T], f: fn(T) -> bool) -> [T] {\n     let mut result = [];\n     for elem: T in v {\n@@ -489,23 +382,20 @@ fn filter<T: copy>(v: [T], f: fn(T) -> bool) -> [T] {\n     ret result;\n }\n \n-/*\n-Function: concat\n+#[doc = \"\n+Concatenate a vector of vectors.\n \n-Concatenate a vector of vectors. Flattens a vector of vectors of T into\n-a single vector of T.\n-*/\n+Flattens a vector of vectors of T into a single vector of T.\n+\"]\n fn concat<T: copy>(v: [const [const T]]) -> [T] {\n     let mut new: [T] = [];\n     for inner: [T] in v { new += inner; }\n     ret new;\n }\n \n-/*\n-Function: connect\n-\n+#[doc = \"\n Concatenate a vector of vectors, placing a given separator between each\n-*/\n+\"]\n fn connect<T: copy>(v: [const [const T]], sep: T) -> [T] {\n     let mut new: [T] = [];\n     let mut first = true;\n@@ -516,11 +406,7 @@ fn connect<T: copy>(v: [const [const T]], sep: T) -> [T] {\n     ret new;\n }\n \n-/*\n-Function: foldl\n-\n-Reduce a vector from left to right\n-*/\n+#[doc = \"Reduce a vector from left to right\"]\n fn foldl<T: copy, U>(z: T, v: [const U], p: fn(T, U) -> T) -> T {\n     let mut accum = z;\n     iter(v) { |elt|\n@@ -529,11 +415,7 @@ fn foldl<T: copy, U>(z: T, v: [const U], p: fn(T, U) -> T) -> T {\n     ret accum;\n }\n \n-/*\n-Function: foldr\n-\n-Reduce a vector from right to left\n-*/\n+#[doc = \"Reduce a vector from right to left\"]\n fn foldr<T, U: copy>(v: [const T], z: U, p: fn(T, U) -> U) -> U {\n     let mut accum = z;\n     riter(v) { |elt|\n@@ -542,25 +424,21 @@ fn foldr<T, U: copy>(v: [const T], z: U, p: fn(T, U) -> U) -> U {\n     ret accum;\n }\n \n-/*\n-Function: any\n-\n+#[doc = \"\n Return true if a predicate matches any elements\n \n If the vector contains no elements then false is returned.\n-*/\n+\"]\n fn any<T>(v: [T], f: fn(T) -> bool) -> bool {\n     for elem: T in v { if f(elem) { ret true; } }\n     ret false;\n }\n \n-/*\n-Function: any2\n-\n+#[doc = \"\n Return true if a predicate matches any elements in both vectors.\n \n If the vectors contains no elements then false is returned.\n-*/\n+\"]\n fn any2<T, U>(v0: [const T], v1: [U], f: fn(T, U) -> bool) -> bool {\n     let v0_len = len(v0);\n     let v1_len = len(v1);\n@@ -572,25 +450,21 @@ fn any2<T, U>(v0: [const T], v1: [U], f: fn(T, U) -> bool) -> bool {\n     ret false;\n }\n \n-/*\n-Function: all\n-\n+#[doc = \"\n Return true if a predicate matches all elements\n \n If the vector contains no elements then true is returned.\n-*/\n+\"]\n fn all<T>(v: [T], f: fn(T) -> bool) -> bool {\n     for elem: T in v { if !f(elem) { ret false; } }\n     ret true;\n }\n \n-/*\n-Function: all2\n-\n+#[doc = \"\n Return true if a predicate matches all elements in both vectors.\n \n If the vectors are not the same size then false is returned.\n-*/\n+\"]\n fn all2<T, U>(v0: [const T], v1: [const U], f: fn(T, U) -> bool) -> bool {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { ret false; }\n@@ -599,117 +473,88 @@ fn all2<T, U>(v0: [const T], v1: [const U], f: fn(T, U) -> bool) -> bool {\n     ret true;\n }\n \n-/*\n-Function: contains\n-\n-Return true if a vector contains an element with the given value\n-*/\n+#[doc = \"Return true if a vector contains an element with the given value\"]\n fn contains<T>(v: [const T], x: T) -> bool {\n     for elt: T in v { if x == elt { ret true; } }\n     ret false;\n }\n \n-/*\n-Function: count\n-\n-Returns the number of elements that are equal to a given value\n-*/\n+#[doc = \"Returns the number of elements that are equal to a given value\"]\n fn count<T>(v: [const T], x: T) -> uint {\n     let mut cnt = 0u;\n     for elt: T in v { if x == elt { cnt += 1u; } }\n     ret cnt;\n }\n \n-/*\n-Function: find\n-\n+#[doc = \"\n Search for the first element that matches a given predicate\n \n Apply function `f` to each element of `v`, starting from the first.\n When function `f` returns true then an option containing the element\n is returned. If `f` matches no elements then none is returned.\n-*/\n+\"]\n fn find<T: copy>(v: [const T], f: fn(T) -> bool) -> option<T> {\n     find_from(v, 0u, len(v), f)\n }\n \n-/*\n-Function: find_from\n-\n+#[doc = \"\n Search for the first element that matches a given predicate within a range\n \n Apply function `f` to each element of `v` within the range [`start`, `end`).\n When function `f` returns true then an option containing the element\n is returned. If `f` matches no elements then none is returned.\n-*/\n+\"]\n fn find_from<T: copy>(v: [const T], start: uint, end: uint,\n                       f: fn(T) -> bool) -> option<T> {\n     option::map(position_from(v, start, end, f)) { |i| v[i] }\n }\n \n-/*\n-Function: rfind\n-\n+#[doc = \"\n Search for the last element that matches a given predicate\n \n Apply function `f` to each element of `v` in reverse order. When function `f`\n returns true then an option containing the element is returned. If `f`\n matches no elements then none is returned.\n-*/\n+\"]\n fn rfind<T: copy>(v: [const T], f: fn(T) -> bool) -> option<T> {\n     rfind_from(v, 0u, len(v), f)\n }\n \n-/*\n-Function: rfind_from\n-\n+#[doc = \"\n Search for the last element that matches a given predicate within a range\n \n Apply function `f` to each element of `v` in reverse order within the range\n [`start`, `end`). When function `f` returns true then an option containing\n the element is returned. If `f` matches no elements then none is returned.\n-*/\n+\"]\n fn rfind_from<T: copy>(v: [const T], start: uint, end: uint,\n                        f: fn(T) -> bool) -> option<T> {\n     option::map(rposition_from(v, start, end, f)) { |i| v[i] }\n }\n \n-/*\n-Function: position_elt\n-\n-Find the first index containing a matching value\n-\n-Returns:\n-\n-option::some(uint) - The first index containing a matching value\n-option::none - No elements matched\n-*/\n+#[doc = \"Find the first index containing a matching value\"]\n fn position_elt<T>(v: [const T], x: T) -> option<uint> {\n     position(v) { |y| x == y }\n }\n \n-/*\n-Function: position\n-\n+#[doc = \"\n Find the first index matching some predicate\n \n Apply function `f` to each element of `v`.  When function `f` returns true\n then an option containing the index is returned. If `f` matches no elements\n then none is returned.\n-*/\n+\"]\n fn position<T>(v: [const T], f: fn(T) -> bool) -> option<uint> {\n     position_from(v, 0u, len(v), f)\n }\n \n-/*\n-Function: position_from\n-\n+#[doc = \"\n Find the first index matching some predicate within a range\n \n Apply function `f` to each element of `v` between the range [`start`, `end`).\n When function `f` returns true then an option containing the index is\n returned. If `f` matches no elements then none is returned.\n-*/\n+\"]\n fn position_from<T>(v: [const T], start: uint, end: uint,\n                     f: fn(T) -> bool) -> option<uint> {\n     assert start <= end;\n@@ -719,42 +564,29 @@ fn position_from<T>(v: [const T], start: uint, end: uint,\n     ret none;\n }\n \n-/*\n-Function: rposition_elt\n-\n-Find the last index containing a matching value\n-\n-Returns:\n-\n-option::some(uint) - The last index containing a matching value\n-option::none - No elements matched\n-*/\n+#[doc = \"Find the last index containing a matching value\"]\n fn rposition_elt<T>(v: [const T], x: T) -> option<uint> {\n     rposition(v) { |y| x == y }\n }\n \n-/*\n-Function: rposition\n-\n+#[doc = \"\n Find the last index matching some predicate\n \n Apply function `f` to each element of `v` in reverse order.  When function\n `f` returns true then an option containing the index is returned. If `f`\n matches no elements then none is returned.\n-*/\n+\"]\n fn rposition<T>(v: [const T], f: fn(T) -> bool) -> option<uint> {\n     rposition_from(v, 0u, len(v), f)\n }\n \n-/*\n-Function: rposition_from\n-\n+#[doc = \"\n Find the last index matching some predicate within a range\n \n Apply function `f` to each element of `v` in reverse order between the range\n [`start`, `end`). When function `f` returns true then an option containing\n the index is returned. If `f` matches no elements then none is returned.\n-*/\n+\"]\n fn rposition_from<T>(v: [const T], start: uint, end: uint,\n                      f: fn(T) -> bool) -> option<uint> {\n     assert start <= end;\n@@ -771,34 +603,26 @@ fn rposition_from<T>(v: [const T], start: uint, end: uint,\n // saying the two result lists have the same length -- or, could\n // return a nominal record with a constraint saying that, instead of\n // returning a tuple (contingent on issue #869)\n-/*\n-Function: unzip\n-\n+#[doc = \"\n Convert a vector of pairs into a pair of vectors\n \n Returns a tuple containing two vectors where the i-th element of the first\n vector contains the first element of the i-th tuple of the input vector,\n and the i-th element of the second vector contains the second element\n of the i-th tuple of the input vector.\n-*/\n+\"]\n fn unzip<T: copy, U: copy>(v: [const (T, U)]) -> ([T], [U]) {\n     let mut as = [], bs = [];\n     for (a, b) in v { as += [a]; bs += [b]; }\n     ret (as, bs);\n }\n \n-/*\n-Function: zip\n-\n+#[doc = \"\n Convert two vectors to a vector of pairs\n \n Returns a vector of tuples, where the i-th tuple contains contains the\n i-th elements from each of the input vectors.\n-\n-Preconditions:\n-\n-<same_length> (v, u)\n-*/\n+\"]\n fn zip<T: copy, U: copy>(v: [const T], u: [const U]) -> [(T, U)] {\n     let mut zipped = [];\n     let sz = len(v);\n@@ -808,37 +632,28 @@ fn zip<T: copy, U: copy>(v: [const T], u: [const U]) -> [(T, U)] {\n     ret zipped;\n }\n \n-/*\n-Function: swap\n-\n+#[doc = \"\n Swaps two elements in a vector\n \n-Parameters:\n-v - The input vector\n-a - The index of the first element\n-b - The index of the second element\n-*/\n+# Arguments\n+\n+* v  The input vector\n+* a - The index of the first element\n+* b - The index of the second element\n+\"]\n fn swap<T>(v: [mutable T], a: uint, b: uint) {\n     v[a] <-> v[b];\n }\n \n-/*\n-Function: reverse\n-\n-Reverse the order of elements in a vector, in place\n-*/\n+#[doc = \"Reverse the order of elements in a vector, in place\"]\n fn reverse<T>(v: [mutable T]) {\n     let mut i: uint = 0u;\n     let ln = len::<T>(v);\n     while i < ln / 2u { v[i] <-> v[ln - i - 1u]; i += 1u; }\n }\n \n \n-/*\n-Function: reversed\n-\n-Returns a vector with the order of elements reversed\n-*/\n+#[doc = \"Returns a vector with the order of elements reversed\"]\n fn reversed<T: copy>(v: [const T]) -> [T] {\n     let mut rs: [T] = [];\n     let mut i = len::<T>(v);\n@@ -849,11 +664,7 @@ fn reversed<T: copy>(v: [const T]) -> [T] {\n }\n \n // FIXME: Seems like this should take char params. Maybe belongs in char\n-/*\n-Function: enum_chars\n-\n-Returns a vector containing a range of chars\n-*/\n+#[doc = \"Returns a vector containing a range of chars\"]\n fn enum_chars(start: u8, end: u8) -> [char] {\n     assert start < end;\n     let mut i = start;\n@@ -863,11 +674,7 @@ fn enum_chars(start: u8, end: u8) -> [char] {\n }\n \n // FIXME: Probably belongs in uint. Compare to uint::range\n-/*\n-Function: enum_uints\n-\n-Returns a vector containing a range of uints\n-*/\n+#[doc = \"Returns a vector containing a range of uints\"]\n fn enum_uints(start: uint, end: uint) -> [uint] {\n     assert start < end;\n     let mut i = start;\n@@ -876,15 +683,12 @@ fn enum_uints(start: uint, end: uint) -> [uint] {\n     ret r;\n }\n \n-/*\n-Function: iter\n-\n+#[doc = \"\n Iterates over a vector\n \n Iterates over vector `v` and, for each element, calls function `f` with the\n element's value.\n-\n-*/\n+\"]\n #[inline(always)]\n fn iter<T>(v: [const T], f: fn(T)) {\n     unsafe {\n@@ -898,54 +702,42 @@ fn iter<T>(v: [const T], f: fn(T)) {\n     }\n }\n \n-/*\n-Function: iter2\n-\n-Iterates over two vectors in parallel\n-\n-*/\n+#[doc = \"Iterates over two vectors in parallel\"]\n #[inline]\n fn iter2<U, T>(v: [ U], v2: [const T], f: fn(U, T)) {\n     let mut i = 0;\n     for elt in v { f(elt, v2[i]); i += 1; }\n }\n \n-/*\n-Function: iteri\n-\n+#[doc = \"\n Iterates over a vector's elements and indexes\n \n Iterates over vector `v` and, for each element, calls function `f` with the\n element's value and index.\n-*/\n+\"]\n #[inline(always)]\n fn iteri<T>(v: [const T], f: fn(uint, T)) {\n     let mut i = 0u;\n     let l = len(v);\n     while i < l { f(i, v[i]); i += 1u; }\n }\n \n-/*\n-Function: riter\n-\n+#[doc = \"\n Iterates over a vector in reverse\n \n Iterates over vector `v` and, for each element, calls function `f` with the\n element's value.\n-\n-*/\n+\"]\n fn riter<T>(v: [const T], f: fn(T)) {\n     riteri(v) { |_i, v| f(v) }\n }\n \n-/*\n-Function: riteri\n-\n+#[doc =\"\n Iterates over a vector's elements and indexes in reverse\n \n Iterates over vector `v` and, for each element, calls function `f` with the\n element's value and index.\n-*/\n+\"]\n fn riteri<T>(v: [const T], f: fn(uint, T)) {\n     let mut i = len(v);\n     while 0u < i {\n@@ -954,16 +746,16 @@ fn riteri<T>(v: [const T], f: fn(uint, T)) {\n     };\n }\n \n-/*\n-Function: permute\n+#[doc = \"\n+Iterate over all permutations of vector `v`.\n \n-Iterate over all permutations of vector `v`.  Permutations are produced in\n-lexicographic order with respect to the order of elements in `v` (so if `v`\n-is sorted then the permutations are lexicographically sorted).\n+Permutations are produced in lexicographic order with respect to the order of\n+elements in `v` (so if `v` is sorted then the permutations are\n+lexicographically sorted).\n \n The total number of permutations produced is `len(v)!`.  If `v` contains\n repeated elements, then some permutations are repeated.\n-*/\n+\"]\n fn permute<T: copy>(v: [T], put: fn([T])) {\n   let ln = len(v);\n   if ln == 0u {\n@@ -996,13 +788,12 @@ fn windowed <TT: copy> (nn: uint, xx: [const TT]) -> [[TT]] {\n    ret ww;\n }\n \n-/*\n-Function: as_buf\n-\n-Work with the buffer of a vector. Allows for unsafe manipulation\n-of vector contents, which is useful for native interop.\n+#[doc = \"\n+Work with the buffer of a vector.\n \n-*/\n+Allows for unsafe manipulation of vector contents, which is useful for native\n+interop.\n+\"]\n fn as_buf<E,T>(v: [const E], f: fn(*E) -> T) -> T unsafe {\n     let buf = unsafe::to_ptr(v); f(buf)\n }\n@@ -1016,74 +807,58 @@ impl vec_len<T> for [T] {\n     fn len() -> uint { len(self) }\n }\n \n-/*\n-Module: unsafe\n-*/\n mod unsafe {\n     type vec_repr = {mutable fill: uint, mutable alloc: uint, data: u8};\n \n-    /*\n-    Function: from_buf\n-\n+    #[doc = \"\n     Constructs a vector from an unsafe pointer to a buffer\n \n-    Parameters:\n+    # Arguments\n \n-    ptr - An unsafe pointer to a buffer of `T`\n-    elts - The number of elements in the buffer\n-    */\n+    * ptr - An unsafe pointer to a buffer of `T`\n+    * elts - The number of elements in the buffer\n+    \"]\n     #[inline(always)]\n     unsafe fn from_buf<T>(ptr: *T, elts: uint) -> [T] {\n         ret rustrt::vec_from_buf_shared(sys::get_type_desc::<T>(),\n                                         ptr, elts);\n     }\n \n-    /*\n-    Function: set_len\n-\n+    #[doc = \"\n     Sets the length of a vector\n \n     This well explicitly set the size of the vector, without actually\n     modifing its buffers, so it is up to the caller to ensure that\n     the vector is actually the specified size.\n-    */\n+    \"]\n     #[inline(always)]\n     unsafe fn set_len<T>(&v: [const T], new_len: uint) {\n         let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         (**repr).fill = new_len * sys::size_of::<T>();\n     }\n \n-    /*\n-    Function: to_ptr\n-\n+    #[doc = \"\n     Returns an unsafe pointer to the vector's buffer\n \n     The caller must ensure that the vector outlives the pointer this\n     function returns, or else it will end up pointing to garbage.\n \n     Modifying the vector may cause its buffer to be reallocated, which\n     would also make any pointers to it invalid.\n-    */\n+    \"]\n     #[inline(always)]\n     unsafe fn to_ptr<T>(v: [const T]) -> *T {\n         let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         ret ::unsafe::reinterpret_cast(addr_of((**repr).data));\n     }\n }\n \n-/*\n-Module: u8\n-*/\n mod u8 {\n     export cmp;\n     export lt, le, eq, ne, ge, gt;\n     export hash;\n \n-    /*\n-    Function cmp\n-\n-    Bytewise string comparison\n-    */\n+    #[doc = \"Bytewise string comparison\"]\n     pure fn cmp(&&a: [u8], &&b: [u8]) -> int unsafe {\n         let a_len = len(a);\n         let b_len = len(b);\n@@ -1102,53 +877,25 @@ mod u8 {\n         }\n     }\n \n-    /*\n-    Function: lt\n-\n-    Bytewise less than or equal\n-    */\n+    #[doc = \"Bytewise less than or equal\"]\n     pure fn lt(&&a: [u8], &&b: [u8]) -> bool { cmp(a, b) < 0 }\n \n-    /*\n-    Function: le\n-\n-    Bytewise less than or equal\n-    */\n+    #[doc = \"Bytewise less than or equal\"]\n     pure fn le(&&a: [u8], &&b: [u8]) -> bool { cmp(a, b) <= 0 }\n \n-    /*\n-    Function: eq\n-\n-    Bytewise equality\n-    */\n+    #[doc = \"Bytewise equality\"]\n     pure fn eq(&&a: [u8], &&b: [u8]) -> bool unsafe { cmp(a, b) == 0 }\n \n-    /*\n-    Function: ne\n-\n-    Bytewise inequality\n-    */\n+    #[doc = \"Bytewise inequality\"]\n     pure fn ne(&&a: [u8], &&b: [u8]) -> bool unsafe { cmp(a, b) != 0 }\n \n-    /*\n-    Function: ge\n-\n-    Bytewise greater than or equal\n-    */\n+    #[doc =\"Bytewise greater than or equal\"]\n     pure fn ge(&&a: [u8], &&b: [u8]) -> bool { cmp(a, b) >= 0 }\n \n-    /*\n-    Function: gt\n-\n-    Bytewise greater than\n-    */\n+    #[doc = \"Bytewise greater than\"]\n     pure fn gt(&&a: [u8], &&b: [u8]) -> bool { cmp(a, b) > 0 }\n \n-    /*\n-    Function: hash\n-\n-    String hash function\n-    */\n+    #[doc = \"String hash function\"]\n     fn hash(&&s: [u8]) -> uint {\n         // djb hash.\n         // FIXME: replace with murmur."}]}