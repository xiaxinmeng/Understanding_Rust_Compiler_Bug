{"sha": "d8aecc19d8e2d82f57e525116302455dca34016d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4YWVjYzE5ZDhlMmQ4MmY1N2U1MjUxMTYzMDI0NTVkY2EzNDAxNmQ=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-20T22:41:46Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-20T22:41:46Z"}, "message": "Remove step.rs", "tree": {"sha": "f5c61f9297f8fd3955c8d87cae0714be351999bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5c61f9297f8fd3955c8d87cae0714be351999bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8aecc19d8e2d82f57e525116302455dca34016d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8aecc19d8e2d82f57e525116302455dca34016d", "html_url": "https://github.com/rust-lang/rust/commit/d8aecc19d8e2d82f57e525116302455dca34016d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8aecc19d8e2d82f57e525116302455dca34016d/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9c2242050cd18f10573400ea50073f5dc8153b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9c2242050cd18f10573400ea50073f5dc8153b0", "html_url": "https://github.com/rust-lang/rust/commit/e9c2242050cd18f10573400ea50073f5dc8153b0"}], "stats": {"total": 1820, "additions": 0, "deletions": 1820}, "files": [{"sha": "a1b26f44b7de132317834581a4fdddf1eaf05188", "filename": "src/bootstrap/step.rs", "status": "removed", "additions": 0, "deletions": 1820, "changes": 1820, "blob_url": "https://github.com/rust-lang/rust/blob/e9c2242050cd18f10573400ea50073f5dc8153b0/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c2242050cd18f10573400ea50073f5dc8153b0/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=e9c2242050cd18f10573400ea50073f5dc8153b0", "patch": "@@ -1,1820 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Definition of steps of the build system.\n-//!\n-//! This is where some of the real meat of rustbuild is located, in how we\n-//! define targets and the dependencies amongst them. This file can sort of be\n-//! viewed as just defining targets in a makefile which shell out to predefined\n-//! functions elsewhere about how to execute the target.\n-//!\n-//! The primary function here you're likely interested in is the `build_rules`\n-//! function. This will create a `Rules` structure which basically just lists\n-//! everything that rustbuild can do. Each rule has a human-readable name, a\n-//! path associated with it, some dependencies, and then a closure of how to\n-//! actually perform the rule.\n-//!\n-//! All steps below are defined in self-contained units, so adding a new target\n-//! to the build system should just involve adding the meta information here\n-//! along with the actual implementation elsewhere. You can find more comments\n-//! about how to define rules themselves below.\n-\n-use std::collections::{BTreeMap, HashSet, HashMap};\n-use std::mem;\n-use std::path::PathBuf;\n-use std::process;\n-\n-use check::{self, TestKind};\n-use compile;\n-use dist;\n-use doc;\n-use flags::Subcommand;\n-use install;\n-use native;\n-use {Compiler, Build, Mode};\n-\n-pub fn run(build: &Build) {\n-    let rules = build_rules(build);\n-    let steps = rules.plan();\n-    rules.run(&steps);\n-}\n-\n-pub fn build_rules<'a>(build: &'a Build) -> Rules {\n-    let mut rules = Rules::new(build);\n-\n-    // This is the first rule that we're going to define for rustbuild, which is\n-    // used to compile LLVM itself. All rules are added through the `rules`\n-    // structure created above and are configured through a builder-style\n-    // interface.\n-    //\n-    // First up we see the `build` method. This represents a rule that's part of\n-    // the top-level `build` subcommand. For example `./x.py build` is what this\n-    // is associating with. Note that this is normally only relevant if you flag\n-    // a rule as `default`, which we'll talk about later.\n-    //\n-    // Next up we'll see two arguments to this method:\n-    //\n-    // * `llvm` - this is the \"human readable\" name of this target. This name is\n-    //            not accessed anywhere outside this file itself (e.g. not in\n-    //            the CLI nor elsewhere in rustbuild). The purpose of this is to\n-    //            easily define dependencies between rules. That is, other rules\n-    //            will depend on this with the name \"llvm\".\n-    // * `src/llvm` - this is the relevant path to the rule that we're working\n-    //                with. This path is the engine behind how commands like\n-    //                `./x.py build src/llvm` work. This should typically point\n-    //                to the relevant component, but if there's not really a\n-    //                path to be assigned here you can pass something like\n-    //                `path/to/nowhere` to ignore it.\n-    //\n-    // After we create the rule with the `build` method we can then configure\n-    // various aspects of it. For example this LLVM rule uses `.host(true)` to\n-    // flag that it's a rule only for host targets. In other words, LLVM isn't\n-    // compiled for targets configured through `--target` (e.g. those we're just\n-    // building a standard library for).\n-    //\n-    // Next up the `dep` method will add a dependency to this rule. The closure\n-    // is yielded the step that represents executing the `llvm` rule itself\n-    // (containing information like stage, host, target, ...) and then it must\n-    // return a target that the step depends on. Here LLVM is actually\n-    // interesting where a cross-compiled LLVM depends on the host LLVM, but\n-    // otherwise it has no dependencies.\n-    //\n-    // To handle this we do a bit of dynamic dispatch to see what the dependency\n-    // is. If we're building a LLVM for the build triple, then we don't actually\n-    // have any dependencies! To do that we return a dependency on the `Step::noop()`\n-    // target which does nothing.\n-    //\n-    // If we're build a cross-compiled LLVM, however, we need to assemble the\n-    // libraries from the previous compiler. This step has the same name as\n-    // ours (llvm) but we want it for a different target, so we use the\n-    // builder-style methods on `Step` to configure this target to the build\n-    // triple.\n-    //\n-    // Finally, to finish off this rule, we define how to actually execute it.\n-    // That logic is all defined in the `native` module so we just delegate to\n-    // the relevant function there. The argument to the closure passed to `run`\n-    // is a `Step` (defined below) which encapsulates information like the\n-    // stage, target, host, etc.\n-    rules.build(\"llvm\", \"src/llvm\")\n-         .host(true)\n-         .dep(move |s| {\n-             if s.target == build.build {\n-                 Step::noop()\n-             } else {\n-                 s.target(&build.build)\n-             }\n-         })\n-         .run(move |s| native::llvm(build, s.target));\n-\n-    // Ok! After that example rule  that's hopefully enough to explain what's\n-    // going on here. You can check out the API docs below and also see a bunch\n-    // more examples of rules directly below as well.\n-\n-    // the compiler with no target libraries ready to go\n-    rules.build(\"rustc\", \"src/rustc\")\n-         .dep(|s| s.name(\"create-sysroot\").target(s.host))\n-         .dep(move |s| {\n-             if s.stage == 0 {\n-                 Step::noop()\n-             } else {\n-                 s.name(\"librustc\")\n-                  .host(&build.build)\n-                  .stage(s.stage - 1)\n-             }\n-         })\n-         .run(move |s| compile::assemble_rustc(build, s.stage, s.target));\n-\n-    // Helper for loading an entire DAG of crates, rooted at `name`\n-    let krates = |name: &str| {\n-        let mut ret = Vec::new();\n-        let mut list = vec![name];\n-        let mut visited = HashSet::new();\n-        while let Some(krate) = list.pop() {\n-            let default = krate == name;\n-            let krate = &build.crates[krate];\n-            let path = krate.path.strip_prefix(&build.src)\n-                // This handles out of tree paths\n-                .unwrap_or(&krate.path);\n-            ret.push((krate, path.to_str().unwrap(), default));\n-            for dep in krate.deps.iter() {\n-                if visited.insert(dep) && dep != \"build_helper\" {\n-                    list.push(dep);\n-                }\n-            }\n-        }\n-        ret\n-    };\n-\n-    // ========================================================================\n-    // Crate compilations\n-    //\n-    // Tools used during the build system but not shipped\n-    rules.build(\"create-sysroot\", \"path/to/nowhere\")\n-         .run(move |s| compile::create_sysroot(build, &s.compiler()));\n-\n-    // These rules are \"pseudo rules\" that don't actually do any work\n-    // themselves, but represent a complete sysroot with the relevant compiler\n-    // linked into place.\n-    //\n-    // That is, depending on \"libstd\" means that when the rule is completed then\n-    // the `stage` sysroot for the compiler `host` will be available with a\n-    // standard library built for `target` linked in place. Not all rules need\n-    // the compiler itself to be available, just the standard library, so\n-    // there's a distinction between the two.\n-    rules.build(\"libstd\", \"src/libstd\")\n-         .dep(|s| s.name(\"rustc\").target(s.host))\n-         .dep(|s| s.name(\"libstd-link\"));\n-    rules.build(\"libtest\", \"src/libtest\")\n-         .dep(|s| s.name(\"libstd\"))\n-         .dep(|s| s.name(\"libtest-link\"))\n-         .default(true);\n-    rules.build(\"librustc\", \"src/librustc\")\n-         .dep(|s| s.name(\"libtest\"))\n-         .dep(|s| s.name(\"librustc-link\"))\n-         .host(true)\n-         .default(true);\n-\n-    // Helper method to define the rules to link a crate into its place in the\n-    // sysroot.\n-    //\n-    // The logic here is a little subtle as there's a few cases to consider.\n-    // Not all combinations of (stage, host, target) actually require something\n-    // to be compiled, but rather libraries could get propagated from a\n-    // different location. For example:\n-    //\n-    // * Any crate with a `host` that's not the build triple will not actually\n-    //   compile something. A different `host` means that the build triple will\n-    //   actually compile the libraries, and then we'll copy them over from the\n-    //   build triple to the `host` directory.\n-    //\n-    // * Some crates aren't even compiled by the build triple, but may be copied\n-    //   from previous stages. For example if we're not doing a full bootstrap\n-    //   then we may just depend on the stage1 versions of libraries to be\n-    //   available to get linked forward.\n-    //\n-    // * Finally, there are some cases, however, which do indeed comiple crates\n-    //   and link them into place afterwards.\n-    //\n-    // The rule definition below mirrors these three cases. The `dep` method\n-    // calculates the correct dependency which either comes from stage1, a\n-    // different compiler, or from actually building the crate itself (the `dep`\n-    // rule). The `run` rule then mirrors these three cases and links the cases\n-    // forward into the compiler sysroot specified from the correct location.\n-    fn crate_rule<'a, 'b>(build: &'a Build,\n-                          rules: &'b mut Rules<'a>,\n-                          krate: &'a str,\n-                          dep: &'a str,\n-                          link: fn(&Build, &Compiler, &Compiler, &str))\n-                          -> RuleBuilder<'a, 'b> {\n-        let mut rule = rules.build(&krate, \"path/to/nowhere\");\n-        rule.dep(move |s| {\n-                if build.force_use_stage1(&s.compiler(), s.target) {\n-                    s.host(&build.build).stage(1)\n-                } else if s.host == build.build {\n-                    s.name(dep)\n-                } else {\n-                    s.host(&build.build)\n-                }\n-            })\n-            .run(move |s| {\n-                if build.force_use_stage1(&s.compiler(), s.target) {\n-                    link(build,\n-                         &s.stage(1).host(&build.build).compiler(),\n-                         &s.compiler(),\n-                         s.target)\n-                } else if s.host == build.build {\n-                    link(build, &s.compiler(), &s.compiler(), s.target)\n-                } else {\n-                    link(build,\n-                         &s.host(&build.build).compiler(),\n-                         &s.compiler(),\n-                         s.target)\n-                }\n-            });\n-            rule\n-    }\n-\n-    // Similar to the `libstd`, `libtest`, and `librustc` rules above, except\n-    // these rules only represent the libraries being available in the sysroot,\n-    // not the compiler itself. This is done as not all rules need a compiler in\n-    // the sysroot, but may just need the libraries.\n-    //\n-    // All of these rules use the helper definition above.\n-    crate_rule(build,\n-               &mut rules,\n-               \"libstd-link\",\n-               \"build-crate-std\",\n-               compile::std_link)\n-        .dep(|s| s.name(\"startup-objects\"))\n-        .dep(|s| s.name(\"create-sysroot\").target(s.host));\n-    crate_rule(build,\n-               &mut rules,\n-               \"libtest-link\",\n-               \"build-crate-test\",\n-               compile::test_link)\n-        .dep(|s| s.name(\"libstd-link\"));\n-    crate_rule(build,\n-               &mut rules,\n-               \"librustc-link\",\n-               \"build-crate-rustc-main\",\n-               compile::rustc_link)\n-        .dep(|s| s.name(\"libtest-link\"));\n-\n-    for (krate, path, _default) in krates(\"std\") {\n-        rules.build(&krate.build_step, path)\n-             .dep(|s| s.name(\"startup-objects\"))\n-             .dep(move |s| s.name(\"rustc\").host(&build.build).target(s.host))\n-             .run(move |s| compile::std(build, s.target, &s.compiler()));\n-    }\n-    for (krate, path, _default) in krates(\"test\") {\n-        rules.build(&krate.build_step, path)\n-             .dep(|s| s.name(\"libstd-link\"))\n-             .run(move |s| compile::test(build, s.target, &s.compiler()));\n-    }\n-    for (krate, path, _default) in krates(\"rustc-main\") {\n-        rules.build(&krate.build_step, path)\n-             .dep(|s| s.name(\"libtest-link\"))\n-             .dep(move |s| s.name(\"llvm\").host(&build.build).stage(0))\n-             .dep(|s| s.name(\"may-run-build-script\"))\n-             .run(move |s| compile::rustc(build, s.target, &s.compiler()));\n-    }\n-\n-    // Crates which have build scripts need to rely on this rule to ensure that\n-    // the necessary prerequisites for a build script are linked and located in\n-    // place.\n-    rules.build(\"may-run-build-script\", \"path/to/nowhere\")\n-         .dep(move |s| {\n-             s.name(\"libstd-link\")\n-              .host(&build.build)\n-              .target(&build.build)\n-         });\n-    rules.build(\"startup-objects\", \"src/rtstartup\")\n-         .dep(|s| s.name(\"create-sysroot\").target(s.host))\n-         .run(move |s| compile::build_startup_objects(build, &s.compiler(), s.target));\n-\n-    // ========================================================================\n-    // Test targets\n-    //\n-    // Various unit tests and tests suites we can run\n-    {\n-        let mut suite = |name, path, mode, dir| {\n-            rules.test(name, path)\n-                 .dep(|s| s.name(\"libtest\"))\n-                 .dep(|s| s.name(\"tool-compiletest\").target(s.host).stage(0))\n-                 .dep(|s| s.name(\"test-helpers\"))\n-                 .dep(|s| s.name(\"remote-copy-libs\"))\n-                 .default(mode != \"pretty\") // pretty tests don't run everywhere\n-                 .run(move |s| {\n-                     check::compiletest(build, &s.compiler(), s.target, mode, dir)\n-                 });\n-        };\n-\n-        suite(\"check-ui\", \"src/test/ui\", \"ui\", \"ui\");\n-        suite(\"check-rpass\", \"src/test/run-pass\", \"run-pass\", \"run-pass\");\n-        suite(\"check-cfail\", \"src/test/compile-fail\", \"compile-fail\", \"compile-fail\");\n-        suite(\"check-pfail\", \"src/test/parse-fail\", \"parse-fail\", \"parse-fail\");\n-        suite(\"check-rfail\", \"src/test/run-fail\", \"run-fail\", \"run-fail\");\n-        suite(\"check-rpass-valgrind\", \"src/test/run-pass-valgrind\",\n-              \"run-pass-valgrind\", \"run-pass-valgrind\");\n-        suite(\"check-mir-opt\", \"src/test/mir-opt\", \"mir-opt\", \"mir-opt\");\n-        if build.config.codegen_tests {\n-            suite(\"check-codegen\", \"src/test/codegen\", \"codegen\", \"codegen\");\n-        }\n-        suite(\"check-codegen-units\", \"src/test/codegen-units\", \"codegen-units\",\n-              \"codegen-units\");\n-        suite(\"check-incremental\", \"src/test/incremental\", \"incremental\",\n-              \"incremental\");\n-    }\n-\n-    if build.build.contains(\"msvc\") {\n-        // nothing to do for debuginfo tests\n-    } else {\n-        rules.test(\"check-debuginfo-lldb\", \"src/test/debuginfo-lldb\")\n-             .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"tool-compiletest\").target(s.host).stage(0))\n-             .dep(|s| s.name(\"test-helpers\"))\n-             .dep(|s| s.name(\"debugger-scripts\"))\n-             .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n-                                         \"debuginfo-lldb\", \"debuginfo\"));\n-        rules.test(\"check-debuginfo-gdb\", \"src/test/debuginfo-gdb\")\n-             .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"tool-compiletest\").target(s.host).stage(0))\n-             .dep(|s| s.name(\"test-helpers\"))\n-             .dep(|s| s.name(\"debugger-scripts\"))\n-             .dep(|s| s.name(\"remote-copy-libs\"))\n-             .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n-                                         \"debuginfo-gdb\", \"debuginfo\"));\n-        let mut rule = rules.test(\"check-debuginfo\", \"src/test/debuginfo\");\n-        rule.default(true);\n-        if build.build.contains(\"apple\") {\n-            rule.dep(|s| s.name(\"check-debuginfo-lldb\"));\n-        } else {\n-            rule.dep(|s| s.name(\"check-debuginfo-gdb\"));\n-        }\n-    }\n-\n-    rules.test(\"debugger-scripts\", \"src/etc/lldb_batchmode.py\")\n-         .run(move |s| dist::debugger_scripts(build, &build.sysroot(&s.compiler()),\n-                                         s.target));\n-\n-    {\n-        let mut suite = |name, path, mode, dir| {\n-            rules.test(name, path)\n-                 .dep(|s| s.name(\"librustc\"))\n-                 .dep(|s| s.name(\"test-helpers\"))\n-                 .dep(|s| s.name(\"tool-compiletest\").target(s.host).stage(0))\n-                 .default(mode != \"pretty\")\n-                 .host(true)\n-                 .run(move |s| {\n-                     check::compiletest(build, &s.compiler(), s.target, mode, dir)\n-                 });\n-        };\n-\n-        suite(\"check-ui-full\", \"src/test/ui-fulldeps\", \"ui\", \"ui-fulldeps\");\n-        suite(\"check-rpass-full\", \"src/test/run-pass-fulldeps\",\n-              \"run-pass\", \"run-pass-fulldeps\");\n-        suite(\"check-rfail-full\", \"src/test/run-fail-fulldeps\",\n-              \"run-fail\", \"run-fail-fulldeps\");\n-        suite(\"check-cfail-full\", \"src/test/compile-fail-fulldeps\",\n-              \"compile-fail\", \"compile-fail-fulldeps\");\n-        suite(\"check-rmake\", \"src/test/run-make\", \"run-make\", \"run-make\");\n-        suite(\"check-rustdoc\", \"src/test/rustdoc\", \"rustdoc\", \"rustdoc\");\n-        suite(\"check-pretty\", \"src/test/pretty\", \"pretty\", \"pretty\");\n-        suite(\"check-pretty-rpass\", \"src/test/run-pass/pretty\", \"pretty\",\n-              \"run-pass\");\n-        suite(\"check-pretty-rfail\", \"src/test/run-fail/pretty\", \"pretty\",\n-              \"run-fail\");\n-        suite(\"check-pretty-valgrind\", \"src/test/run-pass-valgrind/pretty\", \"pretty\",\n-              \"run-pass-valgrind\");\n-        suite(\"check-pretty-rpass-full\", \"src/test/run-pass-fulldeps/pretty\",\n-              \"pretty\", \"run-pass-fulldeps\");\n-        suite(\"check-pretty-rfail-full\", \"src/test/run-fail-fulldeps/pretty\",\n-              \"pretty\", \"run-fail-fulldeps\");\n-    }\n-\n-    for (krate, path, _default) in krates(\"std\") {\n-        rules.test(&krate.test_step, path)\n-             .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"remote-copy-libs\"))\n-             .run(move |s| check::krate(build, &s.compiler(), s.target,\n-                                        Mode::Libstd, TestKind::Test,\n-                                        Some(&krate.name)));\n-    }\n-    rules.test(\"check-std-all\", \"path/to/nowhere\")\n-         .dep(|s| s.name(\"libtest\"))\n-         .dep(|s| s.name(\"remote-copy-libs\"))\n-         .default(true)\n-         .run(move |s| check::krate(build, &s.compiler(), s.target,\n-                                    Mode::Libstd, TestKind::Test, None));\n-\n-    // std benchmarks\n-    for (krate, path, _default) in krates(\"std\") {\n-        rules.bench(&krate.bench_step, path)\n-             .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"remote-copy-libs\"))\n-             .run(move |s| check::krate(build, &s.compiler(), s.target,\n-                                        Mode::Libstd, TestKind::Bench,\n-                                        Some(&krate.name)));\n-    }\n-    rules.bench(\"bench-std-all\", \"path/to/nowhere\")\n-         .dep(|s| s.name(\"libtest\"))\n-         .dep(|s| s.name(\"remote-copy-libs\"))\n-         .default(true)\n-         .run(move |s| check::krate(build, &s.compiler(), s.target,\n-                                    Mode::Libstd, TestKind::Bench, None));\n-\n-    for (krate, path, _default) in krates(\"test\") {\n-        rules.test(&krate.test_step, path)\n-             .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"remote-copy-libs\"))\n-             .run(move |s| check::krate(build, &s.compiler(), s.target,\n-                                        Mode::Libtest, TestKind::Test,\n-                                        Some(&krate.name)));\n-    }\n-    rules.test(\"check-test-all\", \"path/to/nowhere\")\n-         .dep(|s| s.name(\"libtest\"))\n-         .dep(|s| s.name(\"remote-copy-libs\"))\n-         .default(true)\n-         .run(move |s| check::krate(build, &s.compiler(), s.target,\n-                                    Mode::Libtest, TestKind::Test, None));\n-    for (krate, path, _default) in krates(\"rustc-main\") {\n-        rules.test(&krate.test_step, path)\n-             .dep(|s| s.name(\"librustc\"))\n-             .dep(|s| s.name(\"remote-copy-libs\"))\n-             .host(true)\n-             .run(move |s| check::krate(build, &s.compiler(), s.target,\n-                                        Mode::Librustc, TestKind::Test,\n-                                        Some(&krate.name)));\n-    }\n-    rules.test(\"check-rustc-all\", \"path/to/nowhere\")\n-         .dep(|s| s.name(\"librustc\"))\n-         .dep(|s| s.name(\"remote-copy-libs\"))\n-         .default(true)\n-         .host(true)\n-         .run(move |s| check::krate(build, &s.compiler(), s.target,\n-                                    Mode::Librustc, TestKind::Test, None));\n-\n-    rules.test(\"check-linkchecker\", \"src/tools/linkchecker\")\n-         .dep(|s| s.name(\"tool-linkchecker\").stage(0))\n-         .dep(|s| s.name(\"default:doc\"))\n-         .default(build.config.docs)\n-         .host(true)\n-         .run(move |s| check::linkcheck(build, s.target));\n-    rules.test(\"check-cargotest\", \"src/tools/cargotest\")\n-         .dep(|s| s.name(\"tool-cargotest\").stage(0))\n-         .dep(|s| s.name(\"librustc\"))\n-         .host(true)\n-         .run(move |s| check::cargotest(build, s.stage, s.target));\n-    rules.test(\"check-cargo\", \"src/tools/cargo\")\n-         .dep(|s| s.name(\"tool-cargo\"))\n-         .host(true)\n-         .run(move |s| check::cargo(build, s.stage, s.target));\n-    rules.test(\"check-rls\", \"src/tools/rls\")\n-         .dep(|s| s.name(\"tool-rls\"))\n-         .host(true)\n-         .run(move |s| check::rls(build, s.stage, s.target));\n-    rules.test(\"check-tidy\", \"src/tools/tidy\")\n-         .dep(|s| s.name(\"tool-tidy\").stage(0))\n-         .default(true)\n-         .host(true)\n-         .only_build(true)\n-         .run(move |s| check::tidy(build, s.target));\n-    rules.test(\"check-error-index\", \"src/tools/error_index_generator\")\n-         .dep(|s| s.name(\"libstd\"))\n-         .dep(|s| s.name(\"tool-error-index\").host(s.host).stage(0))\n-         .default(true)\n-         .host(true)\n-         .run(move |s| check::error_index(build, &s.compiler()));\n-    rules.test(\"check-docs\", \"src/doc\")\n-         .dep(|s| s.name(\"libtest\"))\n-         .default(true)\n-         .host(true)\n-         .run(move |s| check::docs(build, &s.compiler()));\n-    rules.test(\"check-distcheck\", \"distcheck\")\n-         .dep(|s| s.name(\"dist-plain-source-tarball\"))\n-         .dep(|s| s.name(\"dist-src\"))\n-         .run(move |_| check::distcheck(build));\n-\n-    rules.build(\"test-helpers\", \"src/rt/rust_test_helpers.c\")\n-         .run(move |s| native::test_helpers(build, s.target));\n-    rules.build(\"openssl\", \"path/to/nowhere\")\n-         .run(move |s| native::openssl(build, s.target));\n-\n-    // Some test suites are run inside emulators or on remote devices, and most\n-    // of our test binaries are linked dynamically which means we need to ship\n-    // the standard library and such to the emulator ahead of time. This step\n-    // represents this and is a dependency of all test suites.\n-    //\n-    // Most of the time this step is a noop (the `check::emulator_copy_libs`\n-    // only does work if necessary). For some steps such as shipping data to\n-    // QEMU we have to build our own tools so we've got conditional dependencies\n-    // on those programs as well. Note that the remote test client is built for\n-    // the build target (us) and the server is built for the target.\n-    rules.test(\"remote-copy-libs\", \"path/to/nowhere\")\n-         .dep(|s| s.name(\"libtest\"))\n-         .dep(move |s| {\n-             if build.remote_tested(s.target) {\n-                s.name(\"tool-remote-test-client\").target(s.host).stage(0)\n-             } else {\n-                 Step::noop()\n-             }\n-         })\n-         .dep(move |s| {\n-             if build.remote_tested(s.target) {\n-                s.name(\"tool-remote-test-server\")\n-             } else {\n-                 Step::noop()\n-             }\n-         })\n-         .run(move |s| check::remote_copy_libs(build, &s.compiler(), s.target));\n-\n-    rules.test(\"check-bootstrap\", \"src/bootstrap\")\n-         .default(true)\n-         .host(true)\n-         .only_build(true)\n-         .run(move |_| check::bootstrap(build));\n-\n-    // ========================================================================\n-    // Build tools\n-    //\n-    // Tools used during the build system but not shipped\n-    rules.build(\"tool-rustbook\", \"src/tools/rustbook\")\n-         .dep(|s| s.name(\"maybe-clean-tools\"))\n-         .dep(|s| s.name(\"librustc-tool\"))\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"rustbook\"));\n-    rules.build(\"tool-error-index\", \"src/tools/error_index_generator\")\n-         .dep(|s| s.name(\"maybe-clean-tools\"))\n-         .dep(|s| s.name(\"librustc-tool\"))\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"error_index_generator\"));\n-    rules.build(\"tool-unstable-book-gen\", \"src/tools/unstable-book-gen\")\n-         .dep(|s| s.name(\"maybe-clean-tools\"))\n-         .dep(|s| s.name(\"libstd-tool\"))\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"unstable-book-gen\"));\n-    rules.build(\"tool-tidy\", \"src/tools/tidy\")\n-         .dep(|s| s.name(\"maybe-clean-tools\"))\n-         .dep(|s| s.name(\"libstd-tool\"))\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"tidy\"));\n-    rules.build(\"tool-linkchecker\", \"src/tools/linkchecker\")\n-         .dep(|s| s.name(\"maybe-clean-tools\"))\n-         .dep(|s| s.name(\"libstd-tool\"))\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"linkchecker\"));\n-    rules.build(\"tool-cargotest\", \"src/tools/cargotest\")\n-         .dep(|s| s.name(\"maybe-clean-tools\"))\n-         .dep(|s| s.name(\"libstd-tool\"))\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"cargotest\"));\n-    rules.build(\"tool-compiletest\", \"src/tools/compiletest\")\n-         .dep(|s| s.name(\"maybe-clean-tools\"))\n-         .dep(|s| s.name(\"libtest-tool\"))\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"compiletest\"));\n-    rules.build(\"tool-build-manifest\", \"src/tools/build-manifest\")\n-         .dep(|s| s.name(\"maybe-clean-tools\"))\n-         .dep(|s| s.name(\"libstd-tool\"))\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"build-manifest\"));\n-    rules.build(\"tool-remote-test-server\", \"src/tools/remote-test-server\")\n-         .dep(|s| s.name(\"maybe-clean-tools\"))\n-         .dep(|s| s.name(\"libstd-tool\"))\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-server\"));\n-    rules.build(\"tool-remote-test-client\", \"src/tools/remote-test-client\")\n-         .dep(|s| s.name(\"maybe-clean-tools\"))\n-         .dep(|s| s.name(\"libstd-tool\"))\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-client\"));\n-    rules.build(\"tool-rust-installer\", \"src/tools/rust-installer\")\n-         .dep(|s| s.name(\"maybe-clean-tools\"))\n-         .dep(|s| s.name(\"libstd-tool\"))\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"rust-installer\"));\n-    rules.build(\"tool-cargo\", \"src/tools/cargo\")\n-         .host(true)\n-         .default(build.config.extended)\n-         .dep(|s| s.name(\"maybe-clean-tools\"))\n-         .dep(|s| s.name(\"libstd-tool\"))\n-         .dep(|s| s.stage(0).host(s.target).name(\"openssl\"))\n-         .dep(move |s| {\n-             // Cargo depends on procedural macros, which requires a full host\n-             // compiler to be available, so we need to depend on that.\n-             s.name(\"librustc-link\")\n-              .target(&build.build)\n-              .host(&build.build)\n-         })\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"cargo\"));\n-    rules.build(\"tool-rls\", \"src/tools/rls\")\n-         .host(true)\n-         .default(build.config.extended)\n-         .dep(|s| s.name(\"librustc-tool\"))\n-         .dep(|s| s.stage(0).host(s.target).name(\"openssl\"))\n-         .dep(move |s| {\n-             // rls, like cargo, uses procedural macros\n-             s.name(\"librustc-link\")\n-              .target(&build.build)\n-              .host(&build.build)\n-         })\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"rls\"));\n-\n-    // \"pseudo rule\" which represents completely cleaning out the tools dir in\n-    // one stage. This needs to happen whenever a dependency changes (e.g.\n-    // libstd, libtest, librustc) and all of the tool compilations above will\n-    // be sequenced after this rule.\n-    rules.build(\"maybe-clean-tools\", \"path/to/nowhere\")\n-         .after(\"librustc-tool\")\n-         .after(\"libtest-tool\")\n-         .after(\"libstd-tool\");\n-\n-    rules.build(\"librustc-tool\", \"path/to/nowhere\")\n-         .dep(|s| s.name(\"librustc\"))\n-         .run(move |s| compile::maybe_clean_tools(build, s.stage, s.target, Mode::Librustc));\n-    rules.build(\"libtest-tool\", \"path/to/nowhere\")\n-         .dep(|s| s.name(\"libtest\"))\n-         .run(move |s| compile::maybe_clean_tools(build, s.stage, s.target, Mode::Libtest));\n-    rules.build(\"libstd-tool\", \"path/to/nowhere\")\n-         .dep(|s| s.name(\"libstd\"))\n-         .run(move |s| compile::maybe_clean_tools(build, s.stage, s.target, Mode::Libstd));\n-\n-    // ========================================================================\n-    // Documentation targets\n-    rules.doc(\"doc-book\", \"src/doc/book\")\n-         .dep(move |s| {\n-             s.name(\"tool-rustbook\")\n-              .host(&build.build)\n-              .target(&build.build)\n-              .stage(0)\n-         })\n-         .default(build.config.docs)\n-         .run(move |s| doc::book(build, s.target, \"book\"));\n-    rules.doc(\"doc-nomicon\", \"src/doc/nomicon\")\n-         .dep(move |s| {\n-             s.name(\"tool-rustbook\")\n-              .host(&build.build)\n-              .target(&build.build)\n-              .stage(0)\n-         })\n-         .default(build.config.docs)\n-         .run(move |s| doc::rustbook(build, s.target, \"nomicon\"));\n-    rules.doc(\"doc-reference\", \"src/doc/reference\")\n-         .dep(move |s| {\n-             s.name(\"tool-rustbook\")\n-              .host(&build.build)\n-              .target(&build.build)\n-              .stage(0)\n-         })\n-         .default(build.config.docs)\n-         .run(move |s| doc::rustbook(build, s.target, \"reference\"));\n-    rules.doc(\"doc-unstable-book\", \"src/doc/unstable-book\")\n-         .dep(move |s| {\n-             s.name(\"tool-rustbook\")\n-              .host(&build.build)\n-              .target(&build.build)\n-              .stage(0)\n-         })\n-         .dep(move |s| s.name(\"doc-unstable-book-gen\"))\n-         .default(build.config.docs)\n-         .run(move |s| doc::rustbook_src(build,\n-                                         s.target,\n-                                         \"unstable-book\",\n-                                         &build.md_doc_out(s.target)));\n-    rules.doc(\"doc-standalone\", \"src/doc\")\n-         .dep(move |s| {\n-             s.name(\"rustc\")\n-              .host(&build.build)\n-              .target(&build.build)\n-              .stage(0)\n-         })\n-         .default(build.config.docs)\n-         .run(move |s| doc::standalone(build, s.target));\n-    rules.doc(\"doc-error-index\", \"src/tools/error_index_generator\")\n-         .dep(move |s| s.name(\"tool-error-index\").target(&build.build).stage(0))\n-         .dep(move |s| s.name(\"librustc-link\"))\n-         .default(build.config.docs)\n-         .host(true)\n-         .run(move |s| doc::error_index(build, s.target));\n-    rules.doc(\"doc-unstable-book-gen\", \"src/tools/unstable-book-gen\")\n-         .dep(move |s| {\n-             s.name(\"tool-unstable-book-gen\")\n-              .host(&build.build)\n-              .target(&build.build)\n-              .stage(0)\n-         })\n-         .dep(move |s| s.name(\"libstd-link\"))\n-         .default(build.config.docs)\n-         .host(true)\n-         .run(move |s| doc::unstable_book_gen(build, s.target));\n-    for (krate, path, default) in krates(\"std\") {\n-        rules.doc(&krate.doc_step, path)\n-             .dep(|s| s.name(\"libstd-link\"))\n-             .default(default && build.config.docs)\n-             .run(move |s| doc::std(build, s.stage, s.target));\n-    }\n-    for (krate, path, default) in krates(\"test\") {\n-        rules.doc(&krate.doc_step, path)\n-             .dep(|s| s.name(\"libtest-link\"))\n-             // Needed so rustdoc generates relative links to std.\n-             .dep(|s| s.name(\"doc-crate-std\"))\n-             .default(default && build.config.compiler_docs)\n-             .run(move |s| doc::test(build, s.stage, s.target));\n-    }\n-    for (krate, path, default) in krates(\"rustc-main\") {\n-        rules.doc(&krate.doc_step, path)\n-             .dep(|s| s.name(\"librustc-link\"))\n-             // Needed so rustdoc generates relative links to std.\n-             .dep(|s| s.name(\"doc-crate-std\"))\n-             .host(true)\n-             .default(default && build.config.docs)\n-             .run(move |s| doc::rustc(build, s.stage, s.target));\n-    }\n-\n-    // ========================================================================\n-    // Distribution targets\n-    rules.dist(\"dist-rustc\", \"src/librustc\")\n-         .dep(move |s| s.name(\"rustc\").host(&build.build))\n-         .host(true)\n-         .only_host_build(true)\n-         .default(true)\n-         .dep(move |s| tool_rust_installer(build, s))\n-         .run(move |s| dist::rustc(build, s.stage, s.target));\n-    rules.dist(\"dist-std\", \"src/libstd\")\n-         .dep(move |s| {\n-             // We want to package up as many target libraries as possible\n-             // for the `rust-std` package, so if this is a host target we\n-             // depend on librustc and otherwise we just depend on libtest.\n-             if build.config.host.iter().any(|t| t == s.target) {\n-                 s.name(\"librustc-link\")\n-             } else {\n-                 s.name(\"libtest-link\")\n-             }\n-         })\n-         .default(true)\n-         .only_host_build(true)\n-         .dep(move |s| tool_rust_installer(build, s))\n-         .run(move |s| dist::std(build, &s.compiler(), s.target));\n-    rules.dist(\"dist-mingw\", \"path/to/nowhere\")\n-         .default(true)\n-         .only_host_build(true)\n-         .dep(move |s| tool_rust_installer(build, s))\n-         .run(move |s| {\n-             if s.target.contains(\"pc-windows-gnu\") {\n-                 dist::mingw(build, s.target)\n-             }\n-         });\n-    rules.dist(\"dist-plain-source-tarball\", \"src\")\n-         .default(build.config.rust_dist_src)\n-         .host(true)\n-         .only_build(true)\n-         .only_host_build(true)\n-         .dep(move |s| tool_rust_installer(build, s))\n-         .run(move |_| dist::plain_source_tarball(build));\n-    rules.dist(\"dist-src\", \"src\")\n-         .default(true)\n-         .host(true)\n-         .only_build(true)\n-         .only_host_build(true)\n-         .dep(move |s| tool_rust_installer(build, s))\n-         .run(move |_| dist::rust_src(build));\n-    rules.dist(\"dist-docs\", \"src/doc\")\n-         .default(true)\n-         .only_host_build(true)\n-         .dep(|s| s.name(\"default:doc\"))\n-         .dep(move |s| tool_rust_installer(build, s))\n-         .run(move |s| dist::docs(build, s.stage, s.target));\n-    rules.dist(\"dist-analysis\", \"analysis\")\n-         .default(build.config.extended)\n-         .dep(|s| s.name(\"dist-std\"))\n-         .only_host_build(true)\n-         .dep(move |s| tool_rust_installer(build, s))\n-         .run(move |s| dist::analysis(build, &s.compiler(), s.target));\n-    rules.dist(\"dist-rls\", \"rls\")\n-         .host(true)\n-         .only_host_build(true)\n-         .dep(|s| s.name(\"tool-rls\"))\n-         .dep(move |s| tool_rust_installer(build, s))\n-         .run(move |s| dist::rls(build, s.stage, s.target));\n-    rules.dist(\"dist-cargo\", \"cargo\")\n-         .host(true)\n-         .only_host_build(true)\n-         .dep(|s| s.name(\"tool-cargo\"))\n-         .dep(move |s| tool_rust_installer(build, s))\n-         .run(move |s| dist::cargo(build, s.stage, s.target));\n-    rules.dist(\"dist-extended\", \"extended\")\n-         .default(build.config.extended)\n-         .host(true)\n-         .only_host_build(true)\n-         .dep(|d| d.name(\"dist-std\"))\n-         .dep(|d| d.name(\"dist-rustc\"))\n-         .dep(|d| d.name(\"dist-mingw\"))\n-         .dep(|d| d.name(\"dist-docs\"))\n-         .dep(|d| d.name(\"dist-cargo\"))\n-         .dep(|d| d.name(\"dist-rls\"))\n-         .dep(|d| d.name(\"dist-analysis\"))\n-         .dep(move |s| tool_rust_installer(build, s))\n-         .run(move |s| dist::extended(build, s.stage, s.target));\n-\n-    rules.dist(\"dist-sign\", \"hash-and-sign\")\n-         .host(true)\n-         .only_build(true)\n-         .only_host_build(true)\n-         .dep(move |s| s.name(\"tool-build-manifest\").target(&build.build).stage(0))\n-         .run(move |_| dist::hash_and_sign(build));\n-\n-    rules.install(\"install-docs\", \"src/doc\")\n-         .default(build.config.docs)\n-         .only_host_build(true)\n-         .dep(|s| s.name(\"dist-docs\"))\n-         .run(move |s| install::Installer::new(build).install_docs(s.stage, s.target));\n-    rules.install(\"install-std\", \"src/libstd\")\n-         .default(true)\n-         .only_host_build(true)\n-         .dep(|s| s.name(\"dist-std\"))\n-         .run(move |s| install::Installer::new(build).install_std(s.stage));\n-    rules.install(\"install-cargo\", \"cargo\")\n-         .default(build.config.extended)\n-         .host(true)\n-         .only_host_build(true)\n-         .dep(|s| s.name(\"dist-cargo\"))\n-         .run(move |s| install::Installer::new(build).install_cargo(s.stage, s.target));\n-    rules.install(\"install-rls\", \"rls\")\n-         .default(build.config.extended)\n-         .host(true)\n-         .only_host_build(true)\n-         .dep(|s| s.name(\"dist-rls\"))\n-         .run(move |s| install::Installer::new(build).install_rls(s.stage, s.target));\n-    rules.install(\"install-analysis\", \"analysis\")\n-         .default(build.config.extended)\n-         .only_host_build(true)\n-         .dep(|s| s.name(\"dist-analysis\"))\n-         .run(move |s| install::Installer::new(build).install_analysis(s.stage, s.target));\n-    rules.install(\"install-src\", \"src\")\n-         .default(build.config.extended)\n-         .host(true)\n-         .only_build(true)\n-         .only_host_build(true)\n-         .dep(|s| s.name(\"dist-src\"))\n-         .run(move |s| install::Installer::new(build).install_src(s.stage));\n-    rules.install(\"install-rustc\", \"src/librustc\")\n-         .default(true)\n-         .host(true)\n-         .only_host_build(true)\n-         .dep(|s| s.name(\"dist-rustc\"))\n-         .run(move |s| install::Installer::new(build).install_rustc(s.stage, s.target));\n-\n-    rules.verify();\n-    return rules;\n-\n-    /// Helper to depend on a stage0 build-only rust-installer tool.\n-    fn tool_rust_installer<'a>(build: &'a Build, step: &Step<'a>) -> Step<'a> {\n-        step.name(\"tool-rust-installer\")\n-            .host(&build.build)\n-            .target(&build.build)\n-            .stage(0)\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n-struct Step<'a> {\n-    /// Human readable name of the rule this step is executing. Possible names\n-    /// are all defined above in `build_rules`.\n-    name: &'a str,\n-\n-    /// The stage this step is executing in. This is typically 0, 1, or 2.\n-    stage: u32,\n-\n-    /// This step will likely involve a compiler, and the target that compiler\n-    /// itself is built for is called the host, this variable. Typically this is\n-    /// the target of the build machine itself.\n-    host: &'a str,\n-\n-    /// The target that this step represents generating. If you're building a\n-    /// standard library for a new suite of targets, for example, this'll be set\n-    /// to those targets.\n-    target: &'a str,\n-}\n-\n-impl<'a> Step<'a> {\n-    fn noop() -> Step<'a> {\n-        Step { name: \"\", stage: 0, host: \"\", target: \"\" }\n-    }\n-\n-    /// Creates a new step which is the same as this, except has a new name.\n-    fn name(&self, name: &'a str) -> Step<'a> {\n-        Step { name: name, ..*self }\n-    }\n-\n-    /// Creates a new step which is the same as this, except has a new stage.\n-    fn stage(&self, stage: u32) -> Step<'a> {\n-        Step { stage: stage, ..*self }\n-    }\n-\n-    /// Creates a new step which is the same as this, except has a new host.\n-    fn host(&self, host: &'a str) -> Step<'a> {\n-        Step { host: host, ..*self }\n-    }\n-\n-    /// Creates a new step which is the same as this, except has a new target.\n-    fn target(&self, target: &'a str) -> Step<'a> {\n-        Step { target: target, ..*self }\n-    }\n-\n-    /// Returns the `Compiler` structure that this step corresponds to.\n-    fn compiler(&self) -> Compiler<'a> {\n-        Compiler::new(self.stage, self.host)\n-    }\n-}\n-\n-struct Rule<'a> {\n-    /// The human readable name of this target, defined in `build_rules`.\n-    name: &'a str,\n-\n-    /// The path associated with this target, used in the `./x.py` driver for\n-    /// easy and ergonomic specification of what to do.\n-    path: &'a str,\n-\n-    /// The \"kind\" of top-level command that this rule is associated with, only\n-    /// relevant if this is a default rule.\n-    kind: Kind,\n-\n-    /// List of dependencies this rule has. Each dependency is a function from a\n-    /// step that's being executed to another step that should be executed.\n-    deps: Vec<Box<Fn(&Step<'a>) -> Step<'a> + 'a>>,\n-\n-    /// How to actually execute this rule. Takes a step with contextual\n-    /// information and then executes it.\n-    run: Box<Fn(&Step<'a>) + 'a>,\n-\n-    /// Whether or not this is a \"default\" rule. That basically means that if\n-    /// you run, for example, `./x.py test` whether it's included or not.\n-    default: bool,\n-\n-    /// Whether or not this is a \"host\" rule, or in other words whether this is\n-    /// only intended for compiler hosts and not for targets that are being\n-    /// generated.\n-    host: bool,\n-\n-    /// Whether this rule is only for steps where the host is the build triple,\n-    /// not anything in hosts or targets.\n-    only_host_build: bool,\n-\n-    /// Whether this rule is only for the build triple, not anything in hosts or\n-    /// targets.\n-    only_build: bool,\n-\n-    /// A list of \"order only\" dependencies. This rules does not actually\n-    /// depend on these rules, but if they show up in the dependency graph then\n-    /// this rule must be executed after all these rules.\n-    after: Vec<&'a str>,\n-}\n-\n-#[derive(PartialEq)]\n-enum Kind {\n-    Build,\n-    Test,\n-    Bench,\n-    Dist,\n-    Doc,\n-    Install,\n-}\n-\n-impl<'a> Rule<'a> {\n-    fn new(name: &'a str, path: &'a str, kind: Kind) -> Rule<'a> {\n-        Rule {\n-            name: name,\n-            deps: Vec::new(),\n-            run: Box::new(|_| ()),\n-            path: path,\n-            kind: kind,\n-            default: false,\n-            host: false,\n-            only_host_build: false,\n-            only_build: false,\n-            after: Vec::new(),\n-        }\n-    }\n-}\n-\n-/// Builder pattern returned from the various methods on `Rules` which will add\n-/// the rule to the internal list on `Drop`.\n-struct RuleBuilder<'a: 'b, 'b> {\n-    rules: &'b mut Rules<'a>,\n-    rule: Rule<'a>,\n-}\n-\n-impl<'a, 'b> RuleBuilder<'a, 'b> {\n-    fn dep<F>(&mut self, f: F) -> &mut Self\n-        where F: Fn(&Step<'a>) -> Step<'a> + 'a,\n-    {\n-        self.rule.deps.push(Box::new(f));\n-        self\n-    }\n-\n-    fn after(&mut self, step: &'a str) -> &mut Self {\n-        self.rule.after.push(step);\n-        self\n-    }\n-\n-    fn run<F>(&mut self, f: F) -> &mut Self\n-        where F: Fn(&Step<'a>) + 'a,\n-    {\n-        self.rule.run = Box::new(f);\n-        self\n-    }\n-\n-    fn default(&mut self, default: bool) -> &mut Self {\n-        self.rule.default = default;\n-        self\n-    }\n-\n-    fn host(&mut self, host: bool) -> &mut Self {\n-        self.rule.host = host;\n-        self\n-    }\n-\n-    fn only_build(&mut self, only_build: bool) -> &mut Self {\n-        self.rule.only_build = only_build;\n-        self\n-    }\n-\n-    fn only_host_build(&mut self, only_host_build: bool) -> &mut Self {\n-        self.rule.only_host_build = only_host_build;\n-        self\n-    }\n-}\n-\n-impl<'a, 'b> Drop for RuleBuilder<'a, 'b> {\n-    fn drop(&mut self) {\n-        let rule = mem::replace(&mut self.rule, Rule::new(\"\", \"\", Kind::Build));\n-        let prev = self.rules.rules.insert(rule.name, rule);\n-        if let Some(prev) = prev {\n-            panic!(\"duplicate rule named: {}\", prev.name);\n-        }\n-    }\n-}\n-\n-pub struct Rules<'a> {\n-    build: &'a Build,\n-    sbuild: Step<'a>,\n-    rules: BTreeMap<&'a str, Rule<'a>>,\n-}\n-\n-impl<'a> Rules<'a> {\n-    fn new(build: &'a Build) -> Rules<'a> {\n-        Rules {\n-            build: build,\n-            sbuild: Step {\n-                stage: build.flags.stage.unwrap_or(2),\n-                target: &build.build,\n-                host: &build.build,\n-                name: \"\",\n-            },\n-            rules: BTreeMap::new(),\n-        }\n-    }\n-\n-    /// Creates a new rule of `Kind::Build` with the specified human readable\n-    /// name and path associated with it.\n-    ///\n-    /// The builder returned should be configured further with information such\n-    /// as how to actually run this rule.\n-    fn build<'b>(&'b mut self, name: &'a str, path: &'a str)\n-                 -> RuleBuilder<'a, 'b> {\n-        self.rule(name, path, Kind::Build)\n-    }\n-\n-    /// Same as `build`, but for `Kind::Test`.\n-    fn test<'b>(&'b mut self, name: &'a str, path: &'a str)\n-                -> RuleBuilder<'a, 'b> {\n-        self.rule(name, path, Kind::Test)\n-    }\n-\n-    /// Same as `build`, but for `Kind::Bench`.\n-    fn bench<'b>(&'b mut self, name: &'a str, path: &'a str)\n-                -> RuleBuilder<'a, 'b> {\n-        self.rule(name, path, Kind::Bench)\n-    }\n-\n-    /// Same as `build`, but for `Kind::Doc`.\n-    fn doc<'b>(&'b mut self, name: &'a str, path: &'a str)\n-               -> RuleBuilder<'a, 'b> {\n-        self.rule(name, path, Kind::Doc)\n-    }\n-\n-    /// Same as `build`, but for `Kind::Dist`.\n-    fn dist<'b>(&'b mut self, name: &'a str, path: &'a str)\n-                -> RuleBuilder<'a, 'b> {\n-        self.rule(name, path, Kind::Dist)\n-    }\n-\n-    /// Same as `build`, but for `Kind::Install`.\n-    fn install<'b>(&'b mut self, name: &'a str, path: &'a str)\n-                -> RuleBuilder<'a, 'b> {\n-        self.rule(name, path, Kind::Install)\n-    }\n-\n-    fn rule<'b>(&'b mut self,\n-                name: &'a str,\n-                path: &'a str,\n-                kind: Kind) -> RuleBuilder<'a, 'b> {\n-        RuleBuilder {\n-            rules: self,\n-            rule: Rule::new(name, path, kind),\n-        }\n-    }\n-\n-    /// Verify the dependency graph defined by all our rules are correct, e.g.\n-    /// everything points to a valid something else.\n-    fn verify(&self) {\n-        for rule in self.rules.values() {\n-            for dep in rule.deps.iter() {\n-                let dep = dep(&self.sbuild.name(rule.name));\n-                if self.rules.contains_key(&dep.name) || dep.name.starts_with(\"default:\") {\n-                    continue\n-                }\n-                if dep == Step::noop() {\n-                    continue\n-                }\n-                panic!(\"\\\n-\n-invalid rule dependency graph detected, was a rule added and maybe typo'd?\n-\n-    `{}` depends on `{}` which does not exist\n-\n-\", rule.name, dep.name);\n-            }\n-        }\n-    }\n-\n-    pub fn get_help(&self, command: &str) -> Option<String> {\n-        let kind = match command {\n-            \"build\" => Kind::Build,\n-            \"doc\" => Kind::Doc,\n-            \"test\" => Kind::Test,\n-            \"bench\" => Kind::Bench,\n-            \"dist\" => Kind::Dist,\n-            \"install\" => Kind::Install,\n-            _ => return None,\n-        };\n-        let rules = self.rules.values().filter(|r| r.kind == kind);\n-        let rules = rules.filter(|r| !r.path.contains(\"nowhere\"));\n-        let mut rules = rules.collect::<Vec<_>>();\n-        rules.sort_by_key(|r| r.path);\n-\n-        let mut help_string = String::from(\"Available paths:\\n\");\n-        for rule in rules {\n-            help_string.push_str(format!(\"    ./x.py {} {}\\n\", command, rule.path).as_str());\n-        }\n-        Some(help_string)\n-    }\n-\n-    /// Construct the top-level build steps that we're going to be executing,\n-    /// given the subcommand that our build is performing.\n-    fn plan(&self) -> Vec<Step<'a>> {\n-        // Ok, the logic here is pretty subtle, and involves quite a few\n-        // conditionals. The basic idea here is to:\n-        //\n-        // 1. First, filter all our rules to the relevant ones. This means that\n-        //    the command specified corresponds to one of our `Kind` variants,\n-        //    and we filter all rules based on that.\n-        //\n-        // 2. Next, we determine which rules we're actually executing. If a\n-        //    number of path filters were specified on the command line we look\n-        //    for those, otherwise we look for anything tagged `default`.\n-        //    Here we also compute the priority of each rule based on how early\n-        //    in the command line the matching path filter showed up.\n-        //\n-        // 3. Finally, we generate some steps with host and target information.\n-        //\n-        // The last step is by far the most complicated and subtle. The basic\n-        // thinking here is that we want to take the cartesian product of\n-        // specified hosts and targets and build rules with that. The list of\n-        // hosts and targets, if not specified, come from the how this build was\n-        // configured. If the rule we're looking at is a host-only rule the we\n-        // ignore the list of targets and instead consider the list of hosts\n-        // also the list of targets.\n-        //\n-        // Once the host and target lists are generated we take the cartesian\n-        // product of the two and then create a step based off them. Note that\n-        // the stage each step is associated was specified with the `--step`\n-        // flag on the command line.\n-        let (kind, paths) = match self.build.flags.cmd {\n-            Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n-            Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n-            Subcommand::Test { ref paths, .. } => (Kind::Test, &paths[..]),\n-            Subcommand::Bench { ref paths, .. } => (Kind::Bench, &paths[..]),\n-            Subcommand::Dist { ref paths } => (Kind::Dist, &paths[..]),\n-            Subcommand::Install { ref paths } => (Kind::Install, &paths[..]),\n-            Subcommand::Clean => panic!(),\n-        };\n-\n-        let mut rules: Vec<_> = self.rules.values().filter_map(|rule| {\n-            if rule.kind != kind {\n-                return None;\n-            }\n-\n-            if paths.len() == 0 && rule.default {\n-                Some((rule, 0))\n-            } else {\n-                paths.iter()\n-                     .position(|path| path.ends_with(rule.path))\n-                     .map(|priority| (rule, priority))\n-            }\n-        }).collect();\n-\n-        if rules.is_empty() &&\n-           !paths.get(0).unwrap_or(&PathBuf::new())\n-                 .ends_with(\"nonexistent/path/to/trigger/cargo/metadata\") {\n-            println!(\"\\nNothing to run...\\n\");\n-            process::exit(1);\n-        }\n-\n-        rules.sort_by_key(|&(_, priority)| priority);\n-\n-        rules.into_iter().flat_map(|(rule, _)| {\n-            let hosts = if rule.only_host_build || rule.only_build {\n-                self.build.build_slice()\n-            } else {\n-                &self.build.hosts\n-            };\n-            // Determine the actual targets participating in this rule.\n-            // NOTE: We should keep the full projection from build triple to\n-            // the hosts for the dist steps, now that the hosts array above is\n-            // truncated to avoid duplication of work in that case. Therefore\n-            // the original non-shadowed hosts array is used below.\n-            let arr = if rule.host {\n-                // If --target was specified but --host wasn't specified,\n-                // don't run any host-only tests.\n-                if self.build.flags.host.len() > 0 {\n-                    &self.build.hosts\n-                } else if self.build.flags.target.len() > 0 {\n-                    &[]\n-                } else if rule.only_build {\n-                    self.build.build_slice()\n-                } else {\n-                    &self.build.hosts\n-                }\n-            } else {\n-                &self.build.targets\n-            };\n-\n-            hosts.iter().flat_map(move |host| {\n-                arr.iter().map(move |target| {\n-                    self.sbuild.name(rule.name).target(target).host(host)\n-                })\n-            })\n-        }).collect()\n-    }\n-\n-    /// Execute all top-level targets indicated by `steps`.\n-    ///\n-    /// This will take the list returned by `plan` and then execute each step\n-    /// along with all required dependencies as it goes up the chain.\n-    fn run(&self, steps: &[Step<'a>]) {\n-        self.build.verbose(\"bootstrap top targets:\");\n-        for step in steps.iter() {\n-            self.build.verbose(&format!(\"\\t{:?}\", step));\n-        }\n-\n-        // Using `steps` as the top-level targets, make a topological ordering\n-        // of what we need to do.\n-        let order = self.expand(steps);\n-\n-        // Print out what we're doing for debugging\n-        self.build.verbose(\"bootstrap build plan:\");\n-        for step in order.iter() {\n-            self.build.verbose(&format!(\"\\t{:?}\", step));\n-        }\n-\n-        // And finally, iterate over everything and execute it.\n-        for step in order.iter() {\n-            if self.build.flags.keep_stage.map_or(false, |s| step.stage <= s) {\n-                self.build.verbose(&format!(\"keeping step {:?}\", step));\n-                continue;\n-            }\n-            self.build.verbose(&format!(\"executing step {:?}\", step));\n-            (self.rules[step.name].run)(step);\n-        }\n-\n-        // Check for postponed failures from `test --no-fail-fast`.\n-        let failures = self.build.delayed_failures.get();\n-        if failures > 0 {\n-            println!(\"\\n{} command(s) did not execute successfully.\\n\", failures);\n-            process::exit(1);\n-        }\n-    }\n-\n-    /// From the top level targets `steps` generate a topological ordering of\n-    /// all steps needed to run those steps.\n-    fn expand(&self, steps: &[Step<'a>]) -> Vec<Step<'a>> {\n-        // First up build a graph of steps and their dependencies. The `nodes`\n-        // map is a map from step to a unique number. The `edges` map is a\n-        // map from these unique numbers to a list of other numbers,\n-        // representing dependencies.\n-        let mut nodes = HashMap::new();\n-        nodes.insert(Step::noop(), 0);\n-        let mut edges = HashMap::new();\n-        edges.insert(0, HashSet::new());\n-        for step in steps {\n-            self.build_graph(step.clone(), &mut nodes, &mut edges);\n-        }\n-\n-        // Now that we've built up the actual dependency graph, draw more\n-        // dependency edges to satisfy the `after` dependencies field for each\n-        // rule.\n-        self.satisfy_after_deps(&nodes, &mut edges);\n-\n-        // And finally, perform a topological sort to return a list of steps to\n-        // execute.\n-        let mut order = Vec::new();\n-        let mut visited = HashSet::new();\n-        visited.insert(0);\n-        let idx_to_node = nodes.iter().map(|p| (*p.1, p.0)).collect::<HashMap<_, _>>();\n-        for idx in 0..nodes.len() {\n-            self.topo_sort(idx, &idx_to_node, &edges, &mut visited, &mut order);\n-        }\n-        order\n-    }\n-\n-    /// Builds the dependency graph rooted at `step`.\n-    ///\n-    /// The `nodes` and `edges` maps are filled out according to the rule\n-    /// described by `step.name`.\n-    fn build_graph(&self,\n-                   step: Step<'a>,\n-                   nodes: &mut HashMap<Step<'a>, usize>,\n-                   edges: &mut HashMap<usize, HashSet<usize>>) -> usize {\n-        use std::collections::hash_map::Entry;\n-\n-        let idx = nodes.len();\n-        match nodes.entry(step.clone()) {\n-            Entry::Vacant(e) => { e.insert(idx); }\n-            Entry::Occupied(e) => return *e.get(),\n-        }\n-\n-        let mut deps = Vec::new();\n-        for dep in self.rules[step.name].deps.iter() {\n-            let dep = dep(&step);\n-            if dep.name.starts_with(\"default:\") {\n-                let kind = match &dep.name[8..] {\n-                    \"doc\" => Kind::Doc,\n-                    \"dist\" => Kind::Dist,\n-                    kind => panic!(\"unknown kind: `{}`\", kind),\n-                };\n-                let host = self.build.config.host.iter().any(|h| h == dep.target);\n-                let rules = self.rules.values().filter(|r| r.default);\n-                for rule in rules.filter(|r| r.kind == kind && (!r.host || host)) {\n-                    deps.push(self.build_graph(dep.name(rule.name), nodes, edges));\n-                }\n-            } else {\n-                deps.push(self.build_graph(dep, nodes, edges));\n-            }\n-        }\n-\n-        edges.entry(idx).or_insert(HashSet::new()).extend(deps);\n-        idx\n-    }\n-\n-    /// Given a dependency graph with a finished list of `nodes`, fill out more\n-    /// dependency `edges`.\n-    ///\n-    /// This is the step which satisfies all `after` listed dependencies in\n-    /// `Rule` above.\n-    fn satisfy_after_deps(&self,\n-                          nodes: &HashMap<Step<'a>, usize>,\n-                          edges: &mut HashMap<usize, HashSet<usize>>) {\n-        // Reverse map from the name of a step to the node indices that it\n-        // appears at.\n-        let mut name_to_idx = HashMap::new();\n-        for (step, &idx) in nodes {\n-            name_to_idx.entry(step.name).or_insert(Vec::new()).push(idx);\n-        }\n-\n-        for (step, idx) in nodes {\n-            if *step == Step::noop() {\n-                continue\n-            }\n-            for after in self.rules[step.name].after.iter() {\n-                // This is the critical piece of an `after` dependency. If the\n-                // dependency isn't actually in our graph then no edge is drawn,\n-                // only if it's already present do we draw the edges.\n-                if let Some(idxs) = name_to_idx.get(after) {\n-                    edges.get_mut(idx).unwrap()\n-                         .extend(idxs.iter().cloned());\n-                }\n-            }\n-        }\n-    }\n-\n-    fn topo_sort(&self,\n-                 cur: usize,\n-                 nodes: &HashMap<usize, &Step<'a>>,\n-                 edges: &HashMap<usize, HashSet<usize>>,\n-                 visited: &mut HashSet<usize>,\n-                 order: &mut Vec<Step<'a>>) {\n-        if !visited.insert(cur) {\n-            return\n-        }\n-        for dep in edges[&cur].iter() {\n-            self.topo_sort(*dep, nodes, edges, visited, order);\n-        }\n-        order.push(nodes[&cur].clone());\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::env;\n-\n-    use Build;\n-    use config::Config;\n-    use flags::Flags;\n-\n-    fn build(args: &[&str],\n-             extra_host: &[&str],\n-             extra_target: &[&str]) -> Build {\n-        build_(args, extra_host, extra_target, true)\n-    }\n-\n-    fn build_(args: &[&str],\n-              extra_host: &[&str],\n-              extra_target: &[&str],\n-              docs: bool) -> Build {\n-        let mut args = args.iter().map(|s| s.to_string()).collect::<Vec<_>>();\n-        args.push(\"--build\".to_string());\n-        args.push(\"A\".to_string());\n-        let flags = Flags::parse(&args);\n-\n-        let mut config = Config::default();\n-        config.docs = docs;\n-        config.build = \"A\".to_string();\n-        config.host = vec![config.build.clone()];\n-        config.host.extend(extra_host.iter().map(|s| s.to_string()));\n-        config.target = config.host.clone();\n-        config.target.extend(extra_target.iter().map(|s| s.to_string()));\n-\n-        let mut build = Build::new(flags, config);\n-        let cwd = env::current_dir().unwrap();\n-        build.crates.insert(\"std\".to_string(), ::Crate {\n-            name: \"std\".to_string(),\n-            deps: Vec::new(),\n-            path: cwd.join(\"src/std\"),\n-            doc_step: \"doc-crate-std\".to_string(),\n-            build_step: \"build-crate-std\".to_string(),\n-            test_step: \"test-crate-std\".to_string(),\n-            bench_step: \"bench-crate-std\".to_string(),\n-            version: String::new(),\n-        });\n-        build.crates.insert(\"test\".to_string(), ::Crate {\n-            name: \"test\".to_string(),\n-            deps: Vec::new(),\n-            path: cwd.join(\"src/test\"),\n-            doc_step: \"doc-crate-test\".to_string(),\n-            build_step: \"build-crate-test\".to_string(),\n-            test_step: \"test-crate-test\".to_string(),\n-            bench_step: \"bench-crate-test\".to_string(),\n-            version: String::new(),\n-        });\n-        build.crates.insert(\"rustc-main\".to_string(), ::Crate {\n-            name: \"rustc-main\".to_string(),\n-            deps: Vec::new(),\n-            version: String::new(),\n-            path: cwd.join(\"src/rustc-main\"),\n-            doc_step: \"doc-crate-rustc-main\".to_string(),\n-            build_step: \"build-crate-rustc-main\".to_string(),\n-            test_step: \"test-crate-rustc-main\".to_string(),\n-            bench_step: \"bench-crate-rustc-main\".to_string(),\n-        });\n-        return build\n-    }\n-\n-    #[test]\n-    fn dist_baseline() {\n-        let build = build(&[\"dist\"], &[], &[]);\n-        let rules = super::build_rules(&build);\n-        let plan = rules.plan();\n-        println!(\"rules: {:#?}\", plan);\n-        assert!(plan.iter().all(|s| s.stage == 2));\n-        assert!(plan.iter().all(|s| s.host == \"A\" ));\n-        assert!(plan.iter().all(|s| s.target == \"A\" ));\n-\n-        let step = super::Step {\n-            name: \"\",\n-            stage: 2,\n-            host: &build.build,\n-            target: &build.build,\n-        };\n-\n-        assert!(plan.contains(&step.name(\"dist-docs\")));\n-        assert!(plan.contains(&step.name(\"dist-mingw\")));\n-        assert!(plan.contains(&step.name(\"dist-rustc\")));\n-        assert!(plan.contains(&step.name(\"dist-std\")));\n-        assert!(plan.contains(&step.name(\"dist-src\")));\n-    }\n-\n-    #[test]\n-    fn dist_with_targets() {\n-        let build = build(&[\"dist\"], &[], &[\"B\"]);\n-        let rules = super::build_rules(&build);\n-        let plan = rules.plan();\n-        println!(\"rules: {:#?}\", plan);\n-        assert!(plan.iter().all(|s| s.stage == 2));\n-        assert!(plan.iter().all(|s| s.host == \"A\" ));\n-\n-        let step = super::Step {\n-            name: \"\",\n-            stage: 2,\n-            host: &build.build,\n-            target: &build.build,\n-        };\n-\n-        assert!(plan.contains(&step.name(\"dist-docs\")));\n-        assert!(plan.contains(&step.name(\"dist-mingw\")));\n-        assert!(plan.contains(&step.name(\"dist-rustc\")));\n-        assert!(plan.contains(&step.name(\"dist-std\")));\n-        assert!(plan.contains(&step.name(\"dist-src\")));\n-\n-        assert!(plan.contains(&step.target(\"B\").name(\"dist-docs\")));\n-        assert!(plan.contains(&step.target(\"B\").name(\"dist-mingw\")));\n-        assert!(!plan.contains(&step.target(\"B\").name(\"dist-rustc\")));\n-        assert!(plan.contains(&step.target(\"B\").name(\"dist-std\")));\n-        assert!(!plan.contains(&step.target(\"B\").name(\"dist-src\")));\n-    }\n-\n-    #[test]\n-    fn dist_with_hosts() {\n-        let build = build(&[\"dist\"], &[\"B\"], &[]);\n-        let rules = super::build_rules(&build);\n-        let plan = rules.plan();\n-        println!(\"rules: {:#?}\", plan);\n-        assert!(plan.iter().all(|s| s.stage == 2));\n-\n-        let step = super::Step {\n-            name: \"\",\n-            stage: 2,\n-            host: &build.build,\n-            target: &build.build,\n-        };\n-\n-        assert!(!plan.iter().any(|s| s.host == \"B\"));\n-\n-        assert!(plan.contains(&step.name(\"dist-docs\")));\n-        assert!(plan.contains(&step.name(\"dist-mingw\")));\n-        assert!(plan.contains(&step.name(\"dist-rustc\")));\n-        assert!(plan.contains(&step.name(\"dist-std\")));\n-        assert!(plan.contains(&step.name(\"dist-src\")));\n-\n-        assert!(plan.contains(&step.target(\"B\").name(\"dist-docs\")));\n-        assert!(plan.contains(&step.target(\"B\").name(\"dist-mingw\")));\n-        assert!(plan.contains(&step.target(\"B\").name(\"dist-rustc\")));\n-        assert!(plan.contains(&step.target(\"B\").name(\"dist-std\")));\n-        assert!(!plan.contains(&step.target(\"B\").name(\"dist-src\")));\n-    }\n-\n-    #[test]\n-    fn dist_with_targets_and_hosts() {\n-        let build = build(&[\"dist\"], &[\"B\"], &[\"C\"]);\n-        let rules = super::build_rules(&build);\n-        let plan = rules.plan();\n-        println!(\"rules: {:#?}\", plan);\n-        assert!(plan.iter().all(|s| s.stage == 2));\n-\n-        let step = super::Step {\n-            name: \"\",\n-            stage: 2,\n-            host: &build.build,\n-            target: &build.build,\n-        };\n-\n-        assert!(!plan.iter().any(|s| s.host == \"B\"));\n-        assert!(!plan.iter().any(|s| s.host == \"C\"));\n-\n-        assert!(plan.contains(&step.name(\"dist-docs\")));\n-        assert!(plan.contains(&step.name(\"dist-mingw\")));\n-        assert!(plan.contains(&step.name(\"dist-rustc\")));\n-        assert!(plan.contains(&step.name(\"dist-std\")));\n-        assert!(plan.contains(&step.name(\"dist-src\")));\n-\n-        assert!(plan.contains(&step.target(\"B\").name(\"dist-docs\")));\n-        assert!(plan.contains(&step.target(\"B\").name(\"dist-mingw\")));\n-        assert!(plan.contains(&step.target(\"B\").name(\"dist-rustc\")));\n-        assert!(plan.contains(&step.target(\"B\").name(\"dist-std\")));\n-        assert!(!plan.contains(&step.target(\"B\").name(\"dist-src\")));\n-\n-        assert!(plan.contains(&step.target(\"C\").name(\"dist-docs\")));\n-        assert!(plan.contains(&step.target(\"C\").name(\"dist-mingw\")));\n-        assert!(!plan.contains(&step.target(\"C\").name(\"dist-rustc\")));\n-        assert!(plan.contains(&step.target(\"C\").name(\"dist-std\")));\n-        assert!(!plan.contains(&step.target(\"C\").name(\"dist-src\")));\n-    }\n-\n-    #[test]\n-    fn dist_target_with_target_flag() {\n-        let build = build(&[\"dist\", \"--target=C\"], &[\"B\"], &[\"C\"]);\n-        let rules = super::build_rules(&build);\n-        let plan = rules.plan();\n-        println!(\"rules: {:#?}\", plan);\n-        assert!(plan.iter().all(|s| s.stage == 2));\n-\n-        let step = super::Step {\n-            name: \"\",\n-            stage: 2,\n-            host: &build.build,\n-            target: &build.build,\n-        };\n-\n-        assert!(!plan.iter().any(|s| s.target == \"A\"));\n-        assert!(!plan.iter().any(|s| s.target == \"B\"));\n-        assert!(!plan.iter().any(|s| s.host == \"B\"));\n-        assert!(!plan.iter().any(|s| s.host == \"C\"));\n-\n-        assert!(plan.contains(&step.target(\"C\").name(\"dist-docs\")));\n-        assert!(plan.contains(&step.target(\"C\").name(\"dist-mingw\")));\n-        assert!(!plan.contains(&step.target(\"C\").name(\"dist-rustc\")));\n-        assert!(plan.contains(&step.target(\"C\").name(\"dist-std\")));\n-        assert!(!plan.contains(&step.target(\"C\").name(\"dist-src\")));\n-    }\n-\n-    #[test]\n-    fn dist_host_with_target_flag() {\n-        let build = build(&[\"dist\", \"--host=B\", \"--target=B\"], &[\"B\"], &[\"C\"]);\n-        let rules = super::build_rules(&build);\n-        let plan = rules.plan();\n-        println!(\"rules: {:#?}\", plan);\n-        assert!(plan.iter().all(|s| s.stage == 2));\n-\n-        let step = super::Step {\n-            name: \"\",\n-            stage: 2,\n-            host: &build.build,\n-            target: &build.build,\n-        };\n-\n-        assert!(!plan.iter().any(|s| s.target == \"A\"));\n-        assert!(!plan.iter().any(|s| s.target == \"C\"));\n-        assert!(!plan.iter().any(|s| s.host == \"B\"));\n-        assert!(!plan.iter().any(|s| s.host == \"C\"));\n-\n-        assert!(plan.contains(&step.target(\"B\").name(\"dist-docs\")));\n-        assert!(plan.contains(&step.target(\"B\").name(\"dist-mingw\")));\n-        assert!(plan.contains(&step.target(\"B\").name(\"dist-rustc\")));\n-        assert!(plan.contains(&step.target(\"B\").name(\"dist-std\")));\n-        assert!(plan.contains(&step.target(\"B\").name(\"dist-src\")));\n-\n-        let all = rules.expand(&plan);\n-        println!(\"all rules: {:#?}\", all);\n-        assert!(!all.contains(&step.name(\"rustc\")));\n-        assert!(!all.contains(&step.name(\"build-crate-test\").stage(1)));\n-\n-        // all stage0 compiles should be for the build target, A\n-        for step in all.iter().filter(|s| s.stage == 0) {\n-            if !step.name.contains(\"build-crate\") {\n-                continue\n-            }\n-            println!(\"step: {:?}\", step);\n-            assert!(step.host != \"B\");\n-            assert!(step.target != \"B\");\n-            assert!(step.host != \"C\");\n-            assert!(step.target != \"C\");\n-        }\n-    }\n-\n-    #[test]\n-    fn build_default() {\n-        let build = build(&[\"build\"], &[\"B\"], &[\"C\"]);\n-        let rules = super::build_rules(&build);\n-        let plan = rules.plan();\n-        println!(\"rules: {:#?}\", plan);\n-        assert!(plan.iter().all(|s| s.stage == 2));\n-\n-        let step = super::Step {\n-            name: \"\",\n-            stage: 2,\n-            host: &build.build,\n-            target: &build.build,\n-        };\n-\n-        // rustc built for all for of (A, B) x (A, B)\n-        assert!(plan.contains(&step.name(\"librustc\")));\n-        assert!(plan.contains(&step.target(\"B\").name(\"librustc\")));\n-        assert!(plan.contains(&step.host(\"B\").target(\"A\").name(\"librustc\")));\n-        assert!(plan.contains(&step.host(\"B\").target(\"B\").name(\"librustc\")));\n-\n-        // rustc never built for C\n-        assert!(!plan.iter().any(|s| {\n-            s.name.contains(\"rustc\") && (s.host == \"C\" || s.target == \"C\")\n-        }));\n-\n-        // test built for everything\n-        assert!(plan.contains(&step.name(\"libtest\")));\n-        assert!(plan.contains(&step.target(\"B\").name(\"libtest\")));\n-        assert!(plan.contains(&step.host(\"B\").target(\"A\").name(\"libtest\")));\n-        assert!(plan.contains(&step.host(\"B\").target(\"B\").name(\"libtest\")));\n-        assert!(plan.contains(&step.host(\"A\").target(\"C\").name(\"libtest\")));\n-        assert!(plan.contains(&step.host(\"B\").target(\"C\").name(\"libtest\")));\n-\n-        let all = rules.expand(&plan);\n-        println!(\"all rules: {:#?}\", all);\n-        assert!(all.contains(&step.name(\"rustc\")));\n-        assert!(all.contains(&step.name(\"libstd\")));\n-    }\n-\n-    #[test]\n-    fn build_filtered() {\n-        let build = build(&[\"build\", \"--target=C\"], &[\"B\"], &[\"C\"]);\n-        let rules = super::build_rules(&build);\n-        let plan = rules.plan();\n-        println!(\"rules: {:#?}\", plan);\n-        assert!(plan.iter().all(|s| s.stage == 2));\n-\n-        assert!(!plan.iter().any(|s| s.name.contains(\"rustc\")));\n-        assert!(plan.iter().all(|s| {\n-            !s.name.contains(\"test\") || s.target == \"C\"\n-        }));\n-    }\n-\n-    #[test]\n-    fn test_default() {\n-        let build = build(&[\"test\"], &[], &[]);\n-        let rules = super::build_rules(&build);\n-        let plan = rules.plan();\n-        println!(\"rules: {:#?}\", plan);\n-        assert!(plan.iter().all(|s| s.stage == 2));\n-        assert!(plan.iter().all(|s| s.host == \"A\"));\n-        assert!(plan.iter().all(|s| s.target == \"A\"));\n-\n-        assert!(plan.iter().any(|s| s.name.contains(\"-ui\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"cfail\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"cfail-full\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"codegen-units\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"debuginfo\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"docs\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"error-index\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"incremental\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"linkchecker\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"mir-opt\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"pfail\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"rfail\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"rfail-full\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"rmake\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"rpass\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"rpass-full\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"rustc-all\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"rustdoc\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"std-all\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"test-all\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"tidy\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"valgrind\")));\n-    }\n-\n-    #[test]\n-    fn test_with_a_target() {\n-        let build = build(&[\"test\", \"--target=C\"], &[], &[\"C\"]);\n-        let rules = super::build_rules(&build);\n-        let plan = rules.plan();\n-        println!(\"rules: {:#?}\", plan);\n-        assert!(plan.iter().all(|s| s.stage == 2));\n-        assert!(plan.iter().all(|s| s.host == \"A\"));\n-        assert!(plan.iter().all(|s| s.target == \"C\"));\n-\n-        assert!(plan.iter().any(|s| s.name.contains(\"-ui\")));\n-        assert!(!plan.iter().any(|s| s.name.contains(\"ui-full\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"cfail\")));\n-        assert!(!plan.iter().any(|s| s.name.contains(\"cfail-full\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"codegen-units\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"debuginfo\")));\n-        assert!(!plan.iter().any(|s| s.name.contains(\"docs\")));\n-        assert!(!plan.iter().any(|s| s.name.contains(\"error-index\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"incremental\")));\n-        assert!(!plan.iter().any(|s| s.name.contains(\"linkchecker\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"mir-opt\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"pfail\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"rfail\")));\n-        assert!(!plan.iter().any(|s| s.name.contains(\"rfail-full\")));\n-        assert!(!plan.iter().any(|s| s.name.contains(\"rmake\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"rpass\")));\n-        assert!(!plan.iter().any(|s| s.name.contains(\"rpass-full\")));\n-        assert!(!plan.iter().any(|s| s.name.contains(\"rustc-all\")));\n-        assert!(!plan.iter().any(|s| s.name.contains(\"rustdoc\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"std-all\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"test-all\")));\n-        assert!(!plan.iter().any(|s| s.name.contains(\"tidy\")));\n-        assert!(plan.iter().any(|s| s.name.contains(\"valgrind\")));\n-    }\n-\n-    #[test]\n-    fn test_disable_docs() {\n-        let build = build_(&[\"test\"], &[], &[], false);\n-        let rules = super::build_rules(&build);\n-        let plan = rules.plan();\n-        println!(\"rules: {:#?}\", plan);\n-        assert!(!plan.iter().any(|s| {\n-            s.name.contains(\"doc-\") || s.name.contains(\"default:doc\")\n-        }));\n-        // none of the dependencies should be a doc rule either\n-        assert!(!plan.iter().any(|s| {\n-            rules.rules[s.name].deps.iter().any(|dep| {\n-                let dep = dep(&rules.sbuild.name(s.name));\n-                dep.name.contains(\"doc-\") || dep.name.contains(\"default:doc\")\n-            })\n-        }));\n-    }\n-}"}]}