{"sha": "b84044acfff3635dd1f01a83f6cee08610e11889", "node_id": "C_kwDOAAsO6NoAKGI4NDA0NGFjZmZmMzYzNWRkMWYwMWE4M2Y2Y2VlMDg2MTBlMTE4ODk", "commit": {"author": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-11-01T01:36:04Z"}, "committer": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-11-01T01:36:04Z"}, "message": "Review comments and more tests", "tree": {"sha": "af1d3470c25c65765e8391e03375f18145a64637", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af1d3470c25c65765e8391e03375f18145a64637"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b84044acfff3635dd1f01a83f6cee08610e11889", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b84044acfff3635dd1f01a83f6cee08610e11889", "html_url": "https://github.com/rust-lang/rust/commit/b84044acfff3635dd1f01a83f6cee08610e11889", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b84044acfff3635dd1f01a83f6cee08610e11889/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9e14af7f0e63e9788c7d78c0dfc7d99d8f67f9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9e14af7f0e63e9788c7d78c0dfc7d99d8f67f9a", "html_url": "https://github.com/rust-lang/rust/commit/f9e14af7f0e63e9788c7d78c0dfc7d99d8f67f9a"}], "stats": {"total": 185, "additions": 174, "deletions": 11}, "files": [{"sha": "36dbc04d0a6f524ebce7d6f664d568ce720ac98e", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 66, "deletions": 3, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b84044acfff3635dd1f01a83f6cee08610e11889/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84044acfff3635dd1f01a83f6cee08610e11889/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=b84044acfff3635dd1f01a83f6cee08610e11889", "patch": "@@ -266,6 +266,16 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n /// Require that the user writes as where clauses on GATs the implicit\n /// outlives bounds involving trait parameters in trait functions and\n /// lifetimes passed as GAT substs. See `self-outlives-lint` test.\n+///\n+/// This trait will be our running example. We are currently WF checking the `Item` item...\n+///\n+/// ```rust\n+/// trait LendingIterator {\n+///   type Item<'me>; // <-- WF checking this trait item\n+///\n+///   fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;\n+/// }\n+/// ```\n fn check_gat_where_clauses(\n     tcx: TyCtxt<'_>,\n     trait_item: &hir::TraitItem<'_>,\n@@ -282,28 +292,56 @@ fn check_gat_where_clauses(\n         return;\n     }\n     let associated_items: &ty::AssocItems<'_> = tcx.associated_items(encl_trait_def_id);\n-    let mut clauses = FxHashSet::default();\n+    let mut clauses: Option<FxHashSet<ty::Predicate<'_>>> = None;\n     // For every function in this trait...\n+    // In our example, this would be the `next` method\n     for item in\n         associated_items.in_definition_order().filter(|item| matches!(item.kind, ty::AssocKind::Fn))\n     {\n+        // The clauses we that we would require from this function\n+        let mut function_clauses = FxHashSet::default();\n+\n         let id = hir::HirId::make_owner(item.def_id.expect_local());\n         let param_env = tcx.param_env(item.def_id.expect_local());\n \n         let sig = tcx.fn_sig(item.def_id);\n+        // Get the signature using placeholders. In our example, this would\n+        // convert the late-bound 'a into a free region.\n         let sig = tcx.liberate_late_bound_regions(item.def_id, sig);\n+        // Collect the arguments that are given to this GAT in the return type\n+        // of  the function signature. In our example, the GAT in the return\n+        // type is `<Self as LendingIterator>::Item<'a>`, so 'a and Self are arguments.\n         let mut visitor = GATSubstCollector {\n             tcx,\n             gat: trait_item.def_id.to_def_id(),\n             regions: FxHashSet::default(),\n             types: FxHashSet::default(),\n         };\n         sig.output().visit_with(&mut visitor);\n+\n+        // If both regions and types are empty, then this GAT isn't in the\n+        // return type, and we shouldn't try to do clause analysis\n+        // (particularly, doing so would end up with an empty set of clauses,\n+        // since the current method would require none, and we take the\n+        // intersection of requirements of all methods)\n+        if visitor.types.is_empty() && visitor.regions.is_empty() {\n+            continue;\n+        }\n+\n+        // The types we can assume to be well-formed. In our example, this\n+        // would be &'a mut Self, from the first argument.\n         let mut wf_tys = FxHashSet::default();\n         wf_tys.extend(sig.inputs());\n \n+        // For each region argument (e.g., 'a in our example), check for a\n+        // relationship to the type arguments (e.g., Self). If there is an\n+        // outlives relationship (`Self: 'a`), then we want to ensure that is\n+        // reflected in a where clause on the GAT itself.\n         for (region, region_idx) in &visitor.regions {\n             for (ty, ty_idx) in &visitor.types {\n+                // Unfortunately, we have to use a new `InferCtxt` for each\n+                // pair, because region constraints get added and solved there,\n+                // and we need to test each pair individually.\n                 tcx.infer_ctxt().enter(|infcx| {\n                     let mut outlives_environment = OutlivesEnvironment::new(param_env);\n                     outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id, DUMMY_SP);\n@@ -328,6 +366,7 @@ fn check_gat_where_clauses(\n                         Some(tcx.lifetimes.re_root_empty),\n                         param_env,\n                     );\n+                    // In our example, requires that Self: 'a\n                     outlives.type_must_outlive(origin, sup_type, sub_region);\n \n                     let errors = infcx.resolve_regions(\n@@ -338,37 +377,57 @@ fn check_gat_where_clauses(\n \n                     debug!(?errors, \"errors\");\n \n+                    // If we were able to prove that Self: 'a without an error,\n+                    // it must be because of the implied or explicit bounds...\n                     if errors.is_empty() {\n                         debug!(?ty_idx, ?region_idx);\n                         debug!(\"required clause: {} must outlive {}\", ty, region);\n+                        // Translate into the generic parameters of the GAT. In\n+                        // our example, the type was Self, which will also be\n+                        // Self in the GAT.\n                         let ty_param = generics.param_at(*ty_idx, tcx);\n                         let ty_param = tcx.mk_ty(ty::Param(ty::ParamTy {\n                             index: ty_param.index,\n                             name: ty_param.name,\n                         }));\n+                        // Same for the region. In our example, 'a corresponds\n+                        // to the 'me parameter.\n                         let region_param = generics.param_at(*region_idx, tcx);\n                         let region_param =\n                             tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n                                 def_id: region_param.def_id,\n                                 index: region_param.index,\n                                 name: region_param.name,\n                             }));\n+                        // The predicate we expect to see. (In our example,\n+                        // `Self: 'me`.)\n                         let clause = ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n                             ty_param,\n                             region_param,\n                         ));\n                         let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n-                        clauses.insert(clause);\n+                        function_clauses.insert(clause);\n                     }\n                 });\n             }\n         }\n+\n+        match clauses.as_mut() {\n+            Some(clauses) => {\n+                clauses.drain_filter(|p| !function_clauses.contains(p));\n+            }\n+            None => {\n+                clauses = Some(function_clauses);\n+            }\n+        }\n     }\n \n     // If there are any missing clauses, emit an error\n+    let mut clauses = clauses.unwrap_or_default();\n     debug!(?clauses);\n     if !clauses.is_empty() {\n-        let written_predicates: ty::GenericPredicates<'_> = tcx.predicates_of(trait_item.def_id);\n+        let written_predicates: ty::GenericPredicates<'_> =\n+            tcx.explicit_predicates_of(trait_item.def_id);\n         let clauses: Vec<_> = clauses\n             .drain_filter(|clause| {\n                 written_predicates.predicates.iter().find(|p| &p.0 == clause).is_none()\n@@ -402,6 +461,10 @@ fn check_gat_where_clauses(\n     }\n }\n \n+/// TypeVisitor that looks for uses of GATs like\n+/// `<P0 as Trait<P1..Pn>>::GAT<Pn..Pm>` and adds the arguments `P0..Pm` into\n+/// the two vectors, `regions` and `types` (depending on their kind). For each\n+/// parameter `Pi` also track the index `i`.\n struct GATSubstCollector<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     gat: DefId,"}, {"sha": "4de850384e7bbb28768aa98a0af5f4304cdfac41", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b84044acfff3635dd1f01a83f6cee08610e11889/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84044acfff3635dd1f01a83f6cee08610e11889/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs?ref=b84044acfff3635dd1f01a83f6cee08610e11889", "patch": "@@ -2,6 +2,8 @@\n \n // check-fail\n \n+use std::fmt::Debug;\n+\n // We have a `&'a self`, so we need a `Self: 'a`\n trait Iterable {\n     type Item<'x>;\n@@ -100,4 +102,70 @@ impl Des3 for () {\n }\n */\n \n+// Similar case to before, except with GAT.\n+trait NoGat<'a> {\n+    type Bar;\n+    fn method(&'a self) -> Self::Bar;\n+}\n+\n+// Lifetime is not on function; except `Self: 'a`\n+trait TraitLifetime<'a> {\n+    type Bar<'b>;\n+    //~^ Missing required bounds\n+    fn method(&'a self) -> Self::Bar<'a>;\n+}\n+\n+// Like above, but we have a where clause that can prove what we want\n+trait TraitLifetimeWhere<'a> where Self: 'a {\n+    type Bar<'b>;\n+    //~^ Missing required bounds\n+    fn method(&'a self) -> Self::Bar<'a>;\n+}\n+\n+// Explicit bound instead of implicit; we want to still error\n+trait ExplicitBound {\n+    type Bar<'b>;\n+    //~^ Missing required bounds\n+    fn method<'b>(&self, token: &'b ()) -> Self::Bar<'b> where Self: 'b;\n+}\n+\n+// The use of the GAT here is not in the return, we don't want to error\n+trait NotInReturn {\n+    type Bar<'b>;\n+    fn method<'b>(&'b self) where Self::Bar<'b>: Debug;\n+}\n+\n+// We obviously error for `Iterator`, but we should also error for `Item`\n+trait IterableTwo {\n+    type Item<'a>;\n+    type Iterator<'a>: Iterator<Item = Self::Item<'a>>;\n+    //~^ Missing required bounds\n+    fn iter<'a>(&'a self) -> Self::Iterator<'a>;\n+}\n+\n+// We also should report region outlives clauses\n+trait RegionOutlives {\n+    type Bar<'a, 'b>;\n+    //~^ Missing required bounds\n+    fn foo<'x, 'y>(&self, input: &'x &'y ()) -> Self::Bar<'x, 'y>;\n+}\n+\n+/*\n+impl Foo for () {\n+    type Bar<'a, 'b> = &'a &'b ();\n+    fn foo<'x, 'y>(&self, input: &'x &'y ()) -> Self::Bar<'x, 'y> {\n+        input\n+    }\n+}\n+*/\n+\n+// If there are multiple methods that return the GAT, require a set of clauses\n+// that can be satisfied by *all* methods\n+trait MultipleMethods {\n+    type Bar<'me>;\n+\n+    fn gimme<'a>(&'a self) -> Self::Bar<'a>;\n+    fn gimme_default(&self) -> Self::Bar<'static>;\n+}\n+\n fn main() {}"}, {"sha": "acccbf24319c05f306f0b4ff8999bdf5f98405c1", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.stderr", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b84044acfff3635dd1f01a83f6cee08610e11889/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b84044acfff3635dd1f01a83f6cee08610e11889/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr?ref=b84044acfff3635dd1f01a83f6cee08610e11889", "patch": "@@ -1,58 +1,90 @@\n error: Missing required bounds on Item\n-  --> $DIR/self-outlives-lint.rs:7:5\n+  --> $DIR/self-outlives-lint.rs:9:5\n    |\n LL |     type Item<'x>;\n    |     ^^^^^^^^^^^^^-\n    |                  |\n    |                  help: add the required where clauses: `where Self: 'x`\n \n error: Missing required bounds on Out\n-  --> $DIR/self-outlives-lint.rs:23:5\n+  --> $DIR/self-outlives-lint.rs:25:5\n    |\n LL |     type Out<'x>;\n    |     ^^^^^^^^^^^^-\n    |                 |\n    |                 help: add the required where clauses: `where T: 'x`\n \n error: Missing required bounds on Out\n-  --> $DIR/self-outlives-lint.rs:37:5\n+  --> $DIR/self-outlives-lint.rs:39:5\n    |\n LL |     type Out<'x>;\n    |     ^^^^^^^^^^^^-\n    |                 |\n    |                 help: add the required where clauses: `where T: 'x`\n \n error: Missing required bounds on Out\n-  --> $DIR/self-outlives-lint.rs:44:5\n+  --> $DIR/self-outlives-lint.rs:46:5\n    |\n LL |     type Out<'x, 'y>;\n    |     ^^^^^^^^^^^^^^^^-\n    |                     |\n    |                     help: add the required where clauses: `where U: 'y, T: 'x`\n \n error: Missing required bounds on Out\n-  --> $DIR/self-outlives-lint.rs:59:5\n+  --> $DIR/self-outlives-lint.rs:61:5\n    |\n LL |     type Out<'x, D>;\n    |     ^^^^^^^^^^^^^^^-\n    |                    |\n    |                    help: add the required where clauses: `where D: 'x`\n \n error: Missing required bounds on Out\n-  --> $DIR/self-outlives-lint.rs:75:5\n+  --> $DIR/self-outlives-lint.rs:77:5\n    |\n LL |     type Out<'x, D>;\n    |     ^^^^^^^^^^^^^^^-\n    |                    |\n    |                    help: add the required where clauses: `where D: 'x`\n \n error: Missing required bounds on Out\n-  --> $DIR/self-outlives-lint.rs:90:5\n+  --> $DIR/self-outlives-lint.rs:92:5\n    |\n LL |     type Out<'x, D>;\n    |     ^^^^^^^^^^^^^^^-\n    |                    |\n    |                    help: add the required where clauses: `where D: 'x`\n \n-error: aborting due to 7 previous errors\n+error: Missing required bounds on Bar\n+  --> $DIR/self-outlives-lint.rs:113:5\n+   |\n+LL |     type Bar<'b>;\n+   |     ^^^^^^^^^^^^-\n+   |                 |\n+   |                 help: add the required where clauses: `where Self: 'b, Self: 'a`\n+\n+error: Missing required bounds on Bar\n+  --> $DIR/self-outlives-lint.rs:120:5\n+   |\n+LL |     type Bar<'b>;\n+   |     ^^^^^^^^^^^^-\n+   |                 |\n+   |                 help: add the required where clauses: `where Self: 'b, Self: 'a`\n+\n+error: Missing required bounds on Bar\n+  --> $DIR/self-outlives-lint.rs:127:5\n+   |\n+LL |     type Bar<'b>;\n+   |     ^^^^^^^^^^^^-\n+   |                 |\n+   |                 help: add the required where clauses: `where Self: 'b`\n+\n+error: Missing required bounds on Iterator\n+  --> $DIR/self-outlives-lint.rs:141:5\n+   |\n+LL |     type Iterator<'a>: Iterator<Item = Self::Item<'a>>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |                                                       |\n+   |                                                       help: add the required where clauses: `where Self: 'a`\n+\n+error: aborting due to 11 previous errors\n "}]}