{"sha": "aa91ef0cf814a35037bc562fa37c51549fcf2984", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhOTFlZjBjZjgxNGEzNTAzN2JjNTYyZmEzN2M1MTU0OWZjZjI5ODQ=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-03T21:38:59Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-04T20:20:06Z"}, "message": "new_mark -> apply_mark, new_rename -> apply_rename", "tree": {"sha": "9eaec0dff2ffc7a3756934c1997a4a1210cf6643", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9eaec0dff2ffc7a3756934c1997a4a1210cf6643"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa91ef0cf814a35037bc562fa37c51549fcf2984", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa91ef0cf814a35037bc562fa37c51549fcf2984", "html_url": "https://github.com/rust-lang/rust/commit/aa91ef0cf814a35037bc562fa37c51549fcf2984", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa91ef0cf814a35037bc562fa37c51549fcf2984/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8cd7f7c6df3581df92c2dc51ca23770f468de40", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8cd7f7c6df3581df92c2dc51ca23770f468de40", "html_url": "https://github.com/rust-lang/rust/commit/b8cd7f7c6df3581df92c2dc51ca23770f468de40"}], "stats": {"total": 58, "additions": 29, "deletions": 29}, "files": [{"sha": "31226a620ea8b798ecd2823687b92a3a509c3a96", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa91ef0cf814a35037bc562fa37c51549fcf2984/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa91ef0cf814a35037bc562fa37c51549fcf2984/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=aa91ef0cf814a35037bc562fa37c51549fcf2984", "patch": "@@ -852,7 +852,7 @@ impl<'a> Folder for IdentRenamer<'a> {\n     fn fold_ident(&mut self, id: Ident) -> Ident {\n         Ident {\n             name: id.name,\n-            ctxt: mtwt::new_renames(self.renames, id.ctxt),\n+            ctxt: mtwt::apply_renames(self.renames, id.ctxt),\n         }\n     }\n }\n@@ -870,7 +870,7 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n         match pat.node {\n             ast::PatIdent(binding_mode, Spanned{span: ref sp, node: id}, ref sub) => {\n                 let new_ident = Ident{name: id.name,\n-                                      ctxt: mtwt::new_renames(self.renames, id.ctxt)};\n+                                      ctxt: mtwt::apply_renames(self.renames, id.ctxt)};\n                 let new_node =\n                     ast::PatIdent(binding_mode,\n                                   Spanned{span: self.new_span(*sp), node: new_ident},\n@@ -990,15 +990,15 @@ impl Folder for Marker {\n     fn fold_ident(&mut self, id: Ident) -> Ident {\n         ast::Ident {\n             name: id.name,\n-            ctxt: mtwt::new_mark(self.mark, id.ctxt)\n+            ctxt: mtwt::apply_mark(self.mark, id.ctxt)\n         }\n     }\n     fn fold_mac(&mut self, m: &ast::Mac) -> ast::Mac {\n         let macro = match m.node {\n             MacInvocTT(ref path, ref tts, ctxt) => {\n                 MacInvocTT(self.fold_path(path),\n                            fold_tts(tts.as_slice(), self),\n-                           mtwt::new_mark(self.mark, ctxt))\n+                           mtwt::apply_mark(self.mark, ctxt))\n             }\n         };\n         Spanned {"}, {"sha": "18466e381a58ba2d5d4baa0984037ae35da5ae60", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/aa91ef0cf814a35037bc562fa37c51549fcf2984/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa91ef0cf814a35037bc562fa37c51549fcf2984/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=aa91ef0cf814a35037bc562fa37c51549fcf2984", "patch": "@@ -58,12 +58,12 @@ pub enum SyntaxContext_ {\n pub type RenameList = Vec<(Ident, Name)>;\n \n /// Extend a syntax context with a given mark\n-pub fn new_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n-    with_sctable(|table| new_mark_internal(m, ctxt, table))\n+pub fn apply_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n+    with_sctable(|table| apply_mark_internal(m, ctxt, table))\n }\n \n // Extend a syntax context with a given mark and sctable (explicit memoization)\n-fn new_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxContext {\n+fn apply_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxContext {\n     let key = (ctxt, m);\n     let new_ctxt = |_: &(SyntaxContext, Mrk)|\n                    idx_push(&mut *table.table.borrow_mut(), Mark(m, ctxt));\n@@ -72,13 +72,13 @@ fn new_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxCont\n }\n \n /// Extend a syntax context with a given rename\n-pub fn new_rename(id: Ident, to:Name,\n+pub fn apply_rename(id: Ident, to:Name,\n                   ctxt: SyntaxContext) -> SyntaxContext {\n-    with_sctable(|table| new_rename_internal(id, to, ctxt, table))\n+    with_sctable(|table| apply_rename_internal(id, to, ctxt, table))\n }\n \n // Extend a syntax context with a given rename and sctable (explicit memoization)\n-fn new_rename_internal(id: Ident,\n+fn apply_rename_internal(id: Ident,\n                        to: Name,\n                        ctxt: SyntaxContext,\n                        table: &SCTable) -> SyntaxContext {\n@@ -93,10 +93,10 @@ fn new_rename_internal(id: Ident,\n // if these rename lists get long, it would make sense\n // to consider memoizing this fold. This may come up\n // when we add hygiene to item names.\n-pub fn new_renames(renames: &RenameList, ctxt: SyntaxContext) -> SyntaxContext {\n+pub fn apply_renames(renames: &RenameList, ctxt: SyntaxContext) -> SyntaxContext {\n     renames.iter().fold(ctxt, |ctxt, &(from, to)| {\n-            new_rename(from, to, ctxt)\n-        })\n+        apply_rename(from, to, ctxt)\n+    })\n }\n \n /// Fetch the SCTable from TLS, create one if it doesn't yet exist.\n@@ -277,8 +277,8 @@ fn xor_push(marks: &mut Vec<Mrk>, mark: Mrk) {\n #[cfg(test)]\n mod tests {\n     use ast::{EMPTY_CTXT, Ident, Mrk, Name, SyntaxContext};\n-    use super::{resolve, xor_push, new_mark_internal, new_sctable_internal};\n-    use super::{new_rename_internal, new_renames, marksof_internal, resolve_internal};\n+    use super::{resolve, xor_push, apply_mark_internal, new_sctable_internal};\n+    use super::{apply_rename_internal, apply_renames, marksof_internal, resolve_internal};\n     use super::{SCTable, EmptyCtxt, Mark, Rename, IllegalCtxt};\n     use std::collections::HashMap;\n \n@@ -319,8 +319,8 @@ mod tests {\n         -> SyntaxContext {\n         tscs.iter().rev().fold(tail, |tail : SyntaxContext, tsc : &TestSC|\n                   {match *tsc {\n-                      M(mrk) => new_mark_internal(mrk,tail,table),\n-                      R(ident,name) => new_rename_internal(ident,name,tail,table)}})\n+                      M(mrk) => apply_mark_internal(mrk,tail,table),\n+                      R(ident,name) => apply_rename_internal(ident,name,tail,table)}})\n     }\n \n     // gather a SyntaxContext back into a vector of TestSCs\n@@ -365,7 +365,7 @@ mod tests {\n     fn unfold_marks(mrks: Vec<Mrk> , tail: SyntaxContext, table: &SCTable)\n                     -> SyntaxContext {\n         mrks.iter().rev().fold(tail, |tail:SyntaxContext, mrk:&Mrk|\n-                   {new_mark_internal(*mrk,tail,table)})\n+                   {apply_mark_internal(*mrk,tail,table)})\n     }\n \n     #[test] fn unfold_marks_test() {\n@@ -397,13 +397,13 @@ mod tests {\n         // rename where stop doesn't match:\n         { let chain = vec!(M(9),\n                         R(id(name1,\n-                             new_mark_internal (4, EMPTY_CTXT,&mut t)),\n+                             apply_mark_internal (4, EMPTY_CTXT,&mut t)),\n                           100101102),\n                         M(14));\n          let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n          assert_eq! (marksof_internal (ans, stopname, &t), vec!(9,14));}\n         // rename where stop does match\n-        { let name1sc = new_mark_internal(4, EMPTY_CTXT, &mut t);\n+        { let name1sc = apply_mark_internal(4, EMPTY_CTXT, &mut t);\n          let chain = vec!(M(9),\n                        R(id(name1, name1sc),\n                          stopname),\n@@ -427,7 +427,7 @@ mod tests {\n         { let sc = unfold_test_sc(vec!(R(id(50,EMPTY_CTXT),51),M(12)),EMPTY_CTXT,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),a);}\n         // - rename where names do match, but marks don't\n-        { let sc1 = new_mark_internal(1,EMPTY_CTXT,&mut t);\n+        { let sc1 = apply_mark_internal(1,EMPTY_CTXT,&mut t);\n          let sc = unfold_test_sc(vec!(R(id(a,sc1),50),\n                                    M(1),\n                                    M(2)),\n@@ -450,11 +450,11 @@ mod tests {\n                                   EMPTY_CTXT,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 51); }\n         // the simplest double-rename:\n-        { let a_to_a50 = new_rename_internal(id(a,EMPTY_CTXT),50,EMPTY_CTXT,&mut t);\n-         let a50_to_a51 = new_rename_internal(id(a,a_to_a50),51,a_to_a50,&mut t);\n+        { let a_to_a50 = apply_rename_internal(id(a,EMPTY_CTXT),50,EMPTY_CTXT,&mut t);\n+         let a50_to_a51 = apply_rename_internal(id(a,a_to_a50),51,a_to_a50,&mut t);\n          assert_eq!(resolve_internal(id(a,a50_to_a51),&mut t, &mut rt),51);\n          // mark on the outside doesn't stop rename:\n-         let sc = new_mark_internal(9,a50_to_a51,&mut t);\n+         let sc = apply_mark_internal(9,a50_to_a51,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),51);\n          // but mark on the inside does:\n          let a50_to_a51_b = unfold_test_sc(vec!(R(id(a,a_to_a50),51),\n@@ -474,10 +474,10 @@ mod tests {\n     #[test]\n     fn hashing_tests () {\n         let mut t = new_sctable_internal();\n-        assert_eq!(new_mark_internal(12,EMPTY_CTXT,&mut t),2);\n-        assert_eq!(new_mark_internal(13,EMPTY_CTXT,&mut t),3);\n+        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),2);\n+        assert_eq!(apply_mark_internal(13,EMPTY_CTXT,&mut t),3);\n         // using the same one again should result in the same index:\n-        assert_eq!(new_mark_internal(12,EMPTY_CTXT,&mut t),2);\n+        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),2);\n         // I'm assuming that the rename table will behave the same....\n     }\n \n@@ -498,7 +498,7 @@ mod tests {\n     fn new_resolves_test() {\n         let renames = vec!((Ident{name:23,ctxt:EMPTY_CTXT},24),\n                            (Ident{name:29,ctxt:EMPTY_CTXT},29));\n-        let new_ctxt1 = new_renames(&renames,EMPTY_CTXT);\n+        let new_ctxt1 = apply_renames(&renames,EMPTY_CTXT);\n         assert_eq!(resolve(Ident{name:23,ctxt:new_ctxt1}),24);\n         assert_eq!(resolve(Ident{name:29,ctxt:new_ctxt1}),29);\n     }"}, {"sha": "dcf37e37ff0a786f0bc40882052ec6efac5bf7d9", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa91ef0cf814a35037bc562fa37c51549fcf2984/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa91ef0cf814a35037bc562fa37c51549fcf2984/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=aa91ef0cf814a35037bc562fa37c51549fcf2984", "patch": "@@ -765,7 +765,7 @@ mod test {\n     use ext::mtwt;\n \n     fn mark_ident(id : ast::Ident, m : ast::Mrk) -> ast::Ident {\n-        ast::Ident{name:id.name,ctxt:mtwt::new_mark(m,id.ctxt)}\n+        ast::Ident{name:id.name,ctxt:mtwt::apply_mark(m,id.ctxt)}\n     }\n \n     #[test] fn mtwt_token_eq_test() {"}]}