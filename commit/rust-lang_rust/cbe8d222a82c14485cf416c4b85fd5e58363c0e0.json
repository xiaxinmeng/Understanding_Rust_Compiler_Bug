{"sha": "cbe8d222a82c14485cf416c4b85fd5e58363c0e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiZThkMjIyYTgyYzE0NDg1Y2Y0MTZjNGI4NWZkNWU1ODM2M2MwZTA=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-02-21T05:56:09Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-02-21T06:00:43Z"}, "message": "Implement sha-1 in standard library. Closes #228", "tree": {"sha": "2242c55ef08cab1d754b2ebe02c6f86bd33ccc88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2242c55ef08cab1d754b2ebe02c6f86bd33ccc88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbe8d222a82c14485cf416c4b85fd5e58363c0e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbe8d222a82c14485cf416c4b85fd5e58363c0e0", "html_url": "https://github.com/rust-lang/rust/commit/cbe8d222a82c14485cf416c4b85fd5e58363c0e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbe8d222a82c14485cf416c4b85fd5e58363c0e0/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0c7439d777bbb967be7a67fa11096aaf540fe9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0c7439d777bbb967be7a67fa11096aaf540fe9f", "html_url": "https://github.com/rust-lang/rust/commit/b0c7439d777bbb967be7a67fa11096aaf540fe9f"}], "stats": {"total": 400, "additions": 400, "deletions": 0}, "files": [{"sha": "8be969aa5966a49eb3de174fe95c06a659904063", "filename": "src/lib/sha1.rs", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/cbe8d222a82c14485cf416c4b85fd5e58363c0e0/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe8d222a82c14485cf416c4b85fd5e58363c0e0/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=cbe8d222a82c14485cf416c4b85fd5e58363c0e0", "patch": "@@ -0,0 +1,284 @@\n+/*\n+ * A SHA-1 implementation derived from Paul E. Jones's reference\n+ * implementation, which is written for clarity, not speed. At some\n+ * point this will want to be rewritten.\n+ */\n+\n+import std._vec;\n+import std._str;\n+\n+export sha1;\n+export mk_sha1;\n+\n+state type sha1 = state obj {\n+                        // Provide message input as bytes\n+                        fn input(&vec[u8]);\n+\n+                        // Provide message input as string\n+                        fn input_str(&str);\n+\n+                        // Read the digest as a vector of 20 bytes. After\n+                        // calling this no further input may provided\n+                        // until reset is called\n+                        fn result() -> vec[u8];\n+\n+                        // Reset the sha1 state for reuse. This is called\n+                        // automatically during construction\n+                        fn reset();\n+};\n+\n+// Some unexported constants\n+const uint digest_buf_len = 5;\n+const uint msg_block_len = 64;\n+\n+// Builds a sha1 object\n+fn mk_sha1() -> sha1 {\n+\n+    state type sha1state = rec(vec[mutable u32] h,\n+                               mutable u32 len_low,\n+                               mutable u32 len_high,\n+                               vec[mutable u8] msg_block,\n+                               mutable uint msg_block_idx,\n+                               mutable bool computed);\n+\n+    impure fn add_input(&sha1state st, &vec[u8] msg) {\n+        // FIXME: Should be typestate precondition\n+        check (!st.computed);\n+\n+        for (u8 element in msg) {\n+            st.msg_block.(st.msg_block_idx) = element;\n+            st.msg_block_idx += 1u;\n+\n+            st.len_low += 8u32;\n+            if (st.len_low == 0u32) {\n+                st.len_high += 1u32;\n+                if (st.len_high == 0u32) {\n+                    // FIXME: Need better failure mode\n+                    fail;\n+                }\n+            }\n+\n+            if (st.msg_block_idx == msg_block_len) {\n+                process_msg_block(st);\n+            }\n+        }\n+    }\n+\n+    impure fn process_msg_block(&sha1state st) {\n+\n+        // FIXME: Make precondition\n+        check (_vec.len[mutable u32](st.h) == digest_buf_len);\n+\n+        // Constants\n+        auto k = vec(0x5A827999u32,\n+                     0x6ED9EBA1u32,\n+                     0x8F1BBCDCu32,\n+                     0xCA62C1D6u32);\n+\n+        let int t; // Loop counter\n+        let vec[mutable u32] w = _vec.init_elt[mutable u32](0u32, 80u);\n+\n+        // Initialize the first 16 words of the vector w\n+        t = 0;\n+        while (t < 16) {\n+            w.(t) = (st.msg_block.(t * 4) as u32) << 24u32;\n+            w.(t) = w.(t) | ((st.msg_block.(t * 4 + 1) as u32) << 16u32);\n+            w.(t) = w.(t) | ((st.msg_block.(t * 4 + 2) as u32) << 8u32);\n+            w.(t) = w.(t) | (st.msg_block.(t * 4 + 3) as u32);\n+            t += 1;\n+        }\n+\n+        // Initialize the rest of vector w\n+        while (t < 80) {\n+            auto val = w.(t-3) ^ w.(t-8) ^ w.(t-14) ^ w.(t-16);\n+            w.(t) = circular_shift(1u32, val);\n+            t += 1;\n+        }\n+\n+        auto a = st.h.(0);\n+        auto b = st.h.(1);\n+        auto c = st.h.(2);\n+        auto d = st.h.(3);\n+        auto e = st.h.(4);\n+\n+        let u32 temp;\n+\n+        t = 0;\n+        while (t < 20) {\n+            temp = circular_shift(5u32, a)\n+                + ((b & c) | ((~b) & d)) + e + w.(t) + k.(0);\n+            e = d;\n+            d = c;\n+            c = circular_shift(30u32, b);\n+            b = a;\n+            a = temp;\n+            t += 1;\n+        }\n+\n+        while (t < 40) {\n+            temp = circular_shift(5u32, a)\n+                + (b ^ c ^ d) + e + w.(t) + k.(1);\n+            e = d;\n+            d = c;\n+            c = circular_shift(30u32, b);\n+            b = a;\n+            a = temp;\n+            t += 1;\n+        }\n+\n+        while (t < 60) {\n+            temp = circular_shift(5u32, a)\n+                + ((b & c) | (b & d) | (c & d)) + e + w.(t) + k.(2);\n+            e = d;\n+            d = c;\n+            c = circular_shift(30u32, b);\n+            b = a;\n+            a = temp;\n+            t += 1;\n+        }\n+\n+        while (t < 80) {\n+            temp = circular_shift(5u32, a)\n+                + (b ^ c ^ d) + e + w.(t) + k.(3);\n+            e = d;\n+            d = c;\n+            c = circular_shift(30u32, b);\n+            b = a;\n+            a = temp;\n+            t += 1;\n+        }\n+\n+        st.h.(0) = st.h.(0) + a;\n+        st.h.(1) = st.h.(1) + b;\n+        st.h.(2) = st.h.(2) + c;\n+        st.h.(3) = st.h.(3) + d;\n+        st.h.(4) = st.h.(4) + e;\n+\n+        st.msg_block_idx = 0u;\n+    }\n+\n+    fn circular_shift(u32 bits, u32 word) -> u32 {\n+        // FIXME: This is a workaround for a rustboot\n+        // \"unrecognized quads\" codegen bug\n+        auto bits_hack = bits;\n+        ret (word << bits_hack) | (word >> (32u32 - bits));\n+    }\n+\n+    impure fn mk_result(&sha1state st) -> vec[u8] {\n+        if (!st.computed) {\n+            pad_msg(st);\n+            st.computed = true;\n+        }\n+\n+        let vec[u8] res = vec();\n+        for (u32 hpart in st.h) {\n+            res += (hpart >> 24u32) & 0xFFu32 as u8;\n+            res += (hpart >> 16u32) & 0xFFu32 as u8;\n+            res += (hpart >> 8u32) & 0xFFu32 as u8;\n+            res += hpart & 0xFFu32 as u8;\n+        }\n+        ret res;\n+    }\n+\n+    /*\n+     * According to the standard, the message must be padded to an even\n+     * 512 bits.  The first padding bit must be a '1'.  The last 64 bits\n+     * represent the length of the original message.  All bits in between\n+     * should be 0.  This function will pad the message according to those\n+     * rules by filling the message_block array accordingly.  It will also\n+     * call ProcessMessageBlock() appropriately.  When it returns, it\n+     * can be assumed that the message digest has been computed.\n+     */\n+    impure fn pad_msg(&sha1state st) {\n+        // FIXME: Should be a precondition\n+        check (_vec.len[mutable u8](st.msg_block) == msg_block_len);\n+\n+        /*\n+         * Check to see if the current message block is too small to hold\n+         * the initial padding bits and length.  If so, we will pad the\n+         * block, process it, and then continue padding into a second block.\n+         */\n+        if (st.msg_block_idx > 55u) {\n+            st.msg_block.(st.msg_block_idx) = 0x80u8;\n+            st.msg_block_idx += 1u;\n+\n+            while (st.msg_block_idx < msg_block_len) {\n+                st.msg_block.(st.msg_block_idx) = 0u8;\n+                st.msg_block_idx += 1u;\n+            }\n+\n+            process_msg_block(st);\n+        } else {\n+            st.msg_block.(st.msg_block_idx) = 0x80u8;\n+            st.msg_block_idx += 1u;\n+        }\n+\n+        while (st.msg_block_idx < 56u) {\n+            st.msg_block.(st.msg_block_idx) = 0u8;\n+            st.msg_block_idx += 1u;\n+        }\n+\n+        // Store the message length as the last 8 octets\n+        st.msg_block.(56) = (st.len_high >> 24u32) & 0xFFu32 as u8;\n+        st.msg_block.(57) = (st.len_high >> 16u32) & 0xFFu32 as u8;\n+        st.msg_block.(58) = (st.len_high >> 8u32) & 0xFFu32 as u8;\n+        st.msg_block.(59) = st.len_high & 0xFFu32 as u8;\n+        st.msg_block.(60) = (st.len_low >> 24u32) & 0xFFu32 as u8;\n+        st.msg_block.(61) = (st.len_low >> 16u32) & 0xFFu32 as u8;\n+        st.msg_block.(62) = (st.len_low >> 8u32) & 0xFFu32 as u8;\n+        st.msg_block.(63) = st.len_low & 0xFFu32 as u8;\n+\n+        process_msg_block(st);\n+    }\n+\n+    state obj sha1(sha1state st) {\n+\n+        fn reset() {\n+            // FIXME: Should be typestate precondition\n+            check (_vec.len[mutable u32](st.h) == digest_buf_len);\n+\n+            st.len_low = 0u32;\n+            st.len_high = 0u32;\n+            st.msg_block_idx = 0u;\n+\n+            st.h.(0) = 0x67452301u32;\n+            st.h.(1) = 0xEFCDAB89u32;\n+            st.h.(2) = 0x98BADCFEu32;\n+            st.h.(3) = 0x10325476u32;\n+            st.h.(4) = 0xC3D2E1F0u32;\n+\n+            st.computed = false;\n+        }\n+\n+        fn input(&vec[u8] msg) {\n+            add_input(st, msg);\n+        }\n+\n+        fn input_str(&str msg) {\n+            add_input(st, _str.bytes(msg));\n+        }\n+\n+        fn result() -> vec[u8] {\n+            ret mk_result(st);\n+        }\n+    }\n+\n+    auto st = rec(h = _vec.init_elt[mutable u32](0u32, digest_buf_len),\n+                  mutable len_low = 0u32,\n+                  mutable len_high = 0u32,\n+                  msg_block = _vec.init_elt[mutable u8](0u8, msg_block_len),\n+                  mutable msg_block_idx = 0u,\n+                  mutable computed = false);\n+    auto sh = sha1(st);\n+    sh.reset();\n+    ret sh;\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "3500c4b3d52507227a4cef5950a4d34516ccb9e1", "filename": "src/lib/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbe8d222a82c14485cf416c4b85fd5e58363c0e0/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cbe8d222a82c14485cf416c4b85fd5e58363c0e0/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=cbe8d222a82c14485cf416c4b85fd5e58363c0e0", "patch": "@@ -57,6 +57,7 @@ mod dbg;\n mod bitv;\n mod sort;\n mod path;\n+mod sha1;\n \n // Local Variables:\n // mode: rust;"}, {"sha": "57e3cdc856b6d95b9e1d80d0522495044c7af5e4", "filename": "src/test/run-pass/lib-sha1.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/cbe8d222a82c14485cf416c4b85fd5e58363c0e0/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe8d222a82c14485cf416c4b85fd5e58363c0e0/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sha1.rs?ref=cbe8d222a82c14485cf416c4b85fd5e58363c0e0", "patch": "@@ -0,0 +1,115 @@\n+// -*- rust -*-\n+\n+use std;\n+\n+import std.sha1;\n+import std._vec;\n+import std._str;\n+\n+fn main() {\n+\n+    type test = rec(str input, vec[u8] output);\n+\n+    fn a_million_letter_a() -> str {\n+        auto i = 0;\n+        auto res = \"\";\n+        while (i < 100000) {\n+            res += \"aaaaaaaaaa\";\n+            i += 1;\n+        }\n+        ret res;\n+    }\n+\n+    // Test messages from FIPS 180-1\n+    let vec[test] fips_180_1_tests =\n+        vec(\n+            rec(input = \"abc\",\n+                output = vec(0xA9u8, 0x99u8, 0x3Eu8, 0x36u8, 0x47u8,\n+                             0x06u8, 0x81u8, 0x6Au8, 0xBAu8, 0x3Eu8,\n+                             0x25u8, 0x71u8, 0x78u8, 0x50u8, 0xC2u8,\n+                             0x6Cu8, 0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8)\n+                ),\n+            rec(input = \"abcdbcdecdefdefgefghfghighij\"\n+                      + \"hijkijkljklmklmnlmnomnopnopq\",\n+                output = vec(0x84u8, 0x98u8, 0x3Eu8, 0x44u8, 0x1Cu8,\n+                             0x3Bu8, 0xD2u8, 0x6Eu8, 0xBAu8, 0xAEu8,\n+                             0x4Au8, 0xA1u8, 0xF9u8, 0x51u8, 0x29u8,\n+                             0xE5u8, 0xE5u8, 0x46u8, 0x70u8, 0xF1u8)\n+                )\n+            // FIXME: This test is disabled because it takes some\n+            // minutes to run under rustboot+valgrind. It may be\n+            // possible to reenable once things are more optimized.\n+            /*,\n+            rec(input = a_million_letter_a(),\n+                output = vec(0x34u8, 0xAAu8, 0x97u8, 0x3Cu8, 0xD4u8,\n+                             0xC4u8, 0xDAu8, 0xA4u8, 0xF6u8, 0x1Eu8,\n+                             0xEBu8, 0x2Bu8, 0xDBu8, 0xADu8, 0x27u8,\n+                             0x31u8, 0x65u8, 0x34u8, 0x01u8, 0x6Fu8)\n+                )\n+            */\n+            );\n+\n+    // Examples from wikipedia\n+    let vec[test] wikipedia_tests =\n+        vec(\n+            rec(input = \"The quick brown fox jumps over the lazy dog\",\n+                output = vec(0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8, 0x7au8,\n+                             0x2du8, 0x28u8, 0xfcu8, 0xedu8, 0x84u8,\n+                             0x9eu8, 0xe1u8, 0xbbu8, 0x76u8, 0xe7u8,\n+                             0x39u8, 0x1bu8, 0x93u8, 0xebu8, 0x12u8)\n+                ),\n+            rec(input = \"The quick brown fox jumps over the lazy cog\",\n+                output = vec(0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8, 0xd2u8,\n+                             0x5eu8, 0x1bu8, 0x3au8, 0xfau8, 0xd3u8,\n+                             0xe8u8, 0x5au8, 0x0bu8, 0xd1u8, 0x7du8,\n+                             0x9bu8, 0x10u8, 0x0du8, 0xb4u8, 0xb3u8)\n+                )\n+            );\n+\n+    auto tests = fips_180_1_tests + wikipedia_tests;\n+\n+    fn check_vec_eq(vec[u8] v0, vec[u8] v1) {\n+        check (_vec.len[u8](v0) == _vec.len[u8](v1));\n+        auto len = _vec.len[u8](v0);\n+        auto i = 0u;\n+        while (i < len) {\n+            auto a = v0.(i);\n+            auto b = v1.(i);\n+            check (a == b);\n+            i += 1u;\n+        }\n+    }\n+\n+    // Test that it works when accepting the message all at once\n+    auto sh = sha1.mk_sha1();\n+    for (test t in tests) {\n+        sh.input_str(t.input);\n+        auto out = sh.result();\n+        check_vec_eq(t.output, out);\n+        sh.reset();\n+    }\n+\n+    // Test that it works when accepting the message in pieces\n+    for (test t in tests) {\n+        auto len = _str.byte_len(t.input);\n+        auto left = len;\n+        while (left > 0u) {\n+            auto take = (left + 1u) / 2u;\n+            sh.input_str(_str.substr(t.input, len - left, take));\n+            left = left - take;\n+        }\n+        auto out = sh.result();\n+        check_vec_eq(t.output, out);\n+        sh.reset();\n+    }\n+}\n+\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}]}