{"sha": "651106462c357b71a4ca2c02ba2bfedfc38b0035", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MTEwNjQ2MmMzNTdiNzFhNGNhMmMwMmJhMmJmZWRmYzM4YjAwMzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-09T20:16:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-09T20:16:19Z"}, "message": "auto merge of #17127 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "79cd7984fb470f273f5907c579a2db5f71296c7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79cd7984fb470f273f5907c579a2db5f71296c7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/651106462c357b71a4ca2c02ba2bfedfc38b0035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/651106462c357b71a4ca2c02ba2bfedfc38b0035", "html_url": "https://github.com/rust-lang/rust/commit/651106462c357b71a4ca2c02ba2bfedfc38b0035", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/651106462c357b71a4ca2c02ba2bfedfc38b0035/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b625d43f8fd2e9a800ca8a419f7d3f5f52604205", "url": "https://api.github.com/repos/rust-lang/rust/commits/b625d43f8fd2e9a800ca8a419f7d3f5f52604205", "html_url": "https://github.com/rust-lang/rust/commit/b625d43f8fd2e9a800ca8a419f7d3f5f52604205"}, {"sha": "e5abe15ff55212c60fc4acc9bfc2bc79038507b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5abe15ff55212c60fc4acc9bfc2bc79038507b8", "html_url": "https://github.com/rust-lang/rust/commit/e5abe15ff55212c60fc4acc9bfc2bc79038507b8"}], "stats": {"total": 1019, "additions": 671, "deletions": 348}, "files": [{"sha": "6cdbfadf637984824963c5f46b779810d7462178", "filename": "configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/configure", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -707,7 +707,7 @@ then\n             | cut -d ' ' -f 2)\n \n         case $CFG_CLANG_VERSION in\n-            (3.0svn | 3.0 | 3.1* | 3.2* | 3.3* | 3.4* | 3.5* )\n+            (3.0svn | 3.0 | 3.1* | 3.2* | 3.3* | 3.4* | 3.5* | 3.6*)\n             step_msg \"found ok version of CLANG: $CFG_CLANG_VERSION\"\n             if [ -z \"$CC\" ]\n             then"}, {"sha": "6d0fd54cd4c135ea281a68f46306744fef6d23ea", "filename": "src/doc/guide.md", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -520,10 +520,8 @@ error: aborting due to previous error\n Could not compile `hello_world`.\n ```\n \n-Rust will not let us use a value that has not been initialized. So why let us\n-declare a binding without initializing it? You'd think our first example would\n-have errored. Well, Rust is smarter than that. Before we get to that, let's talk\n-about this stuff we've added to `println!`.\n+Rust will not let us use a value that has not been initialized. Next, let's\n+talk about this stuff we've added to `println!`.\n \n If you include two curly braces (`{}`, some call them moustaches...) in your\n string to print, Rust will interpret this as a request to interpolate some sort\n@@ -538,12 +536,6 @@ format in a more detailed manner, there are a [wide number of options\n available](std/fmt/index.html). For now, we'll just stick to the default:\n integers aren't very complicated to print.\n \n-So, we've cleared up all of the confusion around bindings, with one exception:\n-why does Rust let us declare a variable binding without an initial value if we\n-must initialize the binding before we use it? And how does it know that we have\n-or have not initialized the binding? For that, we need to learn our next\n-concept: `if`.\n-\n # If\n \n Rust's take on `if` is not particularly complex, but it's much more like the\n@@ -582,7 +574,6 @@ if x == 5i {\n \n This is all pretty standard. However, you can also do this:\n \n-\n ```\n let x = 5i;\n "}, {"sha": "eb97a75e7660b0ef192a99a1c2662980666c4a2c", "filename": "src/doc/rust.md", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -3290,17 +3290,19 @@ between `_` and `..` is that the pattern `C(_)` is only type-correct if `C` has\n exactly one argument, while the pattern `C(..)` is type-correct for any enum\n variant `C`, regardless of how many arguments `C` has.\n \n-Used inside a vector pattern, `..` stands for any number of elements. This\n-wildcard can be used at most once for a given vector, which implies that it\n-cannot be used to specifically match elements that are at an unknown distance\n-from both ends of a vector, like `[.., 42, ..]`. If followed by a variable name,\n-it will bind the corresponding slice to the variable. Example:\n+Used inside a vector pattern, `..` stands for any number of elements, when the\n+`advanced_slice_patterns` feature gate is turned on. This wildcard can be used\n+at most once for a given vector, which implies that it cannot be used to\n+specifically match elements that are at an unknown distance from both ends of a\n+vector, like `[.., 42, ..]`.  If followed by a variable name, it will bind the\n+corresponding slice to the variable.  Example:\n \n ~~~~\n+# #![feature(advanced_slice_patterns)]\n fn is_symmetric(list: &[uint]) -> bool {\n     match list {\n         [] | [_]                   => true,\n-        [x, ..inside, y] if x == y => is_symmetric(inside),\n+        [x, inside.., y] if x == y => is_symmetric(inside),\n         _                          => false\n     }\n }"}, {"sha": "0e5a624b273336953726d98ac298e62ed0fef6e2", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -1707,7 +1707,7 @@ let score = match numbers {\n     [] => 0,\n     [a] => a * 10,\n     [a, b] => a * 6 + b * 4,\n-    [a, b, c, ..rest] => a * 5 + b * 3 + c * 2 + rest.len() as int\n+    [a, b, c, rest..] => a * 5 + b * 3 + c * 2 + rest.len() as int\n };\n ~~~~\n "}, {"sha": "328a2ff6c9408704ff5dca0950bd22edf80e5368", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -43,12 +43,15 @@\n     \"libsync/mpmc_bounded_queue.rs\", # BSD\n     \"libsync/mpsc_intrusive.rs\", # BSD\n     \"test/bench/shootout-binarytrees.rs\", # BSD\n+    \"test/bench/shootout-chameneos-redux.rs\", # BSD\n     \"test/bench/shootout-fannkuch-redux.rs\", # BSD\n     \"test/bench/shootout-k-nucleotide.rs\", # BSD\n     \"test/bench/shootout-mandelbrot.rs\", # BSD\n     \"test/bench/shootout-meteor.rs\", # BSD\n+    \"test/bench/shootout-nbody.rs\", # BSD\n     \"test/bench/shootout-pidigits.rs\", # BSD\n     \"test/bench/shootout-regex-dna.rs\", # BSD\n+    \"test/bench/shootout-reverse-complement.rs\", # BSD\n     \"test/bench/shootout-threadring.rs\", # BSD\n ]\n "}, {"sha": "ee3fd6ad0eb0db0f5a909c3b41ed799bc9a929f6", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -509,6 +509,7 @@ mod tests {\n     use self::test::Bencher;\n     use super::{Arena, TypedArena};\n \n+    #[allow(dead_code)]\n     struct Point {\n         x: int,\n         y: int,\n@@ -564,6 +565,7 @@ mod tests {\n         })\n     }\n \n+    #[allow(dead_code)]\n     struct Noncopy {\n         string: String,\n         array: Vec<int>,"}, {"sha": "36edd913de2f83367e452bf7023499926619bb9c", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -864,6 +864,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_tailn() {\n         let mut a = vec![11i, 12, 13];\n         let b: &[int] = &[11, 12, 13];\n@@ -875,6 +876,7 @@ mod tests {\n \n     #[test]\n     #[should_fail]\n+    #[allow(deprecated)]\n     fn test_tailn_empty() {\n         let a: Vec<int> = vec![];\n         a.tailn(2);\n@@ -909,6 +911,7 @@ mod tests {\n \n     #[test]\n     #[should_fail]\n+    #[allow(deprecated)]\n     fn test_initn_empty() {\n         let a: Vec<int> = vec![];\n         a.as_slice().initn(2);\n@@ -1466,6 +1469,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_unshift() {\n         let mut x = vec![1i, 2, 3];\n         x.unshift(0);\n@@ -2079,6 +2083,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_shift_ref() {\n         let mut x: &[int] = [1, 2, 3, 4, 5];\n         let h = x.shift_ref();\n@@ -2092,6 +2097,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_pop_ref() {\n         let mut x: &[int] = [1, 2, 3, 4, 5];\n         let h = x.pop_ref();\n@@ -2171,6 +2177,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_mut_shift_ref() {\n         let mut x: &mut [int] = [1, 2, 3, 4, 5];\n         let h = x.mut_shift_ref();\n@@ -2184,6 +2191,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_mut_pop_ref() {\n         let mut x: &mut [int] = [1, 2, 3, 4, 5];\n         let h = x.mut_pop_ref();\n@@ -2441,7 +2449,7 @@ mod bench {\n         b.iter(|| {\n             v.sort();\n         });\n-        b.bytes = (v.len() * mem::size_of_val(v.get(0))) as u64;\n+        b.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n     }\n \n     type BigSortable = (u64,u64,u64,u64);\n@@ -2485,6 +2493,6 @@ mod bench {\n         b.iter(|| {\n             v.sort();\n         });\n-        b.bytes = (v.len() * mem::size_of_val(v.get(0))) as u64;\n+        b.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n     }\n }"}, {"sha": "89b2f9cc853b8cdc881f365ccc5bf4447aa5e731", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -2185,7 +2185,7 @@ pub type Iterate<'a, T> = Unfold<'a, T, IterateState<'a, T>>;\n /// Creates a new iterator that produces an infinite sequence of\n /// repeated applications of the given function `f`.\n #[allow(visible_private_types)]\n-pub fn iterate<'a, T: Clone>(f: |T|: 'a -> T, seed: T) -> Iterate<'a, T> {\n+pub fn iterate<'a, T: Clone>(seed: T, f: |T|: 'a -> T) -> Iterate<'a, T> {\n     Unfold::new((f, Some(seed), true), |st| {\n         let &(ref mut f, ref mut val, ref mut first) = st;\n         if *first {"}, {"sha": "94febf0363594d543ba05658d2a154e67c3273ac", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -55,6 +55,8 @@\n  *\n  */\n \n+use kinds::Sized;\n+\n /**\n  *\n  * The `Drop` trait is used to run some code when a value goes out of scope. This\n@@ -700,7 +702,7 @@ pub trait IndexMut<Index,Result> {\n  * ```\n  */\n #[lang=\"deref\"]\n-pub trait Deref<Result> {\n+pub trait Deref<Sized? Result> {\n     /// The method called to dereference a value\n     fn deref<'a>(&'a self) -> &'a Result;\n }\n@@ -740,7 +742,7 @@ pub trait Deref<Result> {\n  * ```\n  */\n #[lang=\"deref_mut\"]\n-pub trait DerefMut<Result>: Deref<Result> {\n+pub trait DerefMut<Sized? Result>: Deref<Result> {\n     /// The method called to mutably dereference a value\n     fn deref_mut<'a>(&'a mut self) -> &'a mut Result;\n }"}, {"sha": "9656a6caba08c845d5037d32138609e8a7b16eb7", "filename": "src/libcoretest/any.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibcoretest%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibcoretest%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fany.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -51,61 +51,61 @@ fn any_owning() {\n }\n \n #[test]\n-fn any_as_ref() {\n+fn any_downcast_ref() {\n     let a = &5u as &Any;\n \n-    match a.as_ref::<uint>() {\n+    match a.downcast_ref::<uint>() {\n         Some(&5) => {}\n         x => fail!(\"Unexpected value {}\", x)\n     }\n \n-    match a.as_ref::<Test>() {\n+    match a.downcast_ref::<Test>() {\n         None => {}\n         x => fail!(\"Unexpected value {}\", x)\n     }\n }\n \n #[test]\n-fn any_as_mut() {\n+fn any_downcast_mut() {\n     let mut a = 5u;\n     let mut b = box 7u;\n \n     let a_r = &mut a as &mut Any;\n     let tmp: &mut uint = &mut *b;\n     let b_r = tmp as &mut Any;\n \n-    match a_r.as_mut::<uint>() {\n+    match a_r.downcast_mut::<uint>() {\n         Some(x) => {\n             assert_eq!(*x, 5u);\n             *x = 612;\n         }\n         x => fail!(\"Unexpected value {}\", x)\n     }\n \n-    match b_r.as_mut::<uint>() {\n+    match b_r.downcast_mut::<uint>() {\n         Some(x) => {\n             assert_eq!(*x, 7u);\n             *x = 413;\n         }\n         x => fail!(\"Unexpected value {}\", x)\n     }\n \n-    match a_r.as_mut::<Test>() {\n+    match a_r.downcast_mut::<Test>() {\n         None => (),\n         x => fail!(\"Unexpected value {}\", x)\n     }\n \n-    match b_r.as_mut::<Test>() {\n+    match b_r.downcast_mut::<Test>() {\n         None => (),\n         x => fail!(\"Unexpected value {}\", x)\n     }\n \n-    match a_r.as_mut::<uint>() {\n+    match a_r.downcast_mut::<uint>() {\n         Some(&612) => {}\n         x => fail!(\"Unexpected value {}\", x)\n     }\n \n-    match b_r.as_mut::<uint>() {\n+    match b_r.downcast_mut::<uint>() {\n         Some(&413) => {}\n         x => fail!(\"Unexpected value {}\", x)\n     }\n@@ -121,11 +121,11 @@ fn any_fixed_vec() {\n \n \n #[bench]\n-fn bench_as_ref(b: &mut Bencher) {\n+fn bench_downcast_ref(b: &mut Bencher) {\n     b.iter(|| {\n         let mut x = 0i;\n         let mut y = &mut x as &mut Any;\n         test::black_box(&mut y);\n-        test::black_box(y.as_ref::<int>() == Some(&0));\n+        test::black_box(y.downcast_ref::<int>() == Some(&0));\n     });\n }"}, {"sha": "9b703a18caee9f4e26bbcab7dda168e7f88b1cd8", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -839,7 +839,7 @@ fn test_min_max_result() {\n \n #[test]\n fn test_iterate() {\n-    let mut it = iterate(|x| x * 2, 1u);\n+    let mut it = iterate(1u, |x| x * 2);\n     assert_eq!(it.next(), Some(1u));\n     assert_eq!(it.next(), Some(2u));\n     assert_eq!(it.next(), Some(4u));"}, {"sha": "6e5bf6e8f2dac572958afc8e9d2b9d774ee00eaf", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -131,6 +131,7 @@ fn test_or_else() {\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_option_while_some() {\n     let mut i = 0i;\n     Some(10i).while_some(|j| {\n@@ -184,6 +185,7 @@ fn test_unwrap_or_else() {\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_filtered() {\n     let some_stuff = Some(42i);\n     let modified_stuff = some_stuff.filtered(|&x| {x < 10});\n@@ -256,6 +258,7 @@ fn test_mutate() {\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_collect() {\n     let v: Option<Vec<int>> = collect(range(0i, 0)\n                                       .map(|_| Some(0i)));"}, {"sha": "dbc393967d3e583688d71c10e9263988d939e11f", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -69,6 +69,7 @@ pub fn test_impl_map_err() {\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_collect() {\n     let v: Result<Vec<int>, ()> = collect(range(0i, 0).map(|_| Ok::<int, ()>(0)));\n     assert!(v == Ok(vec![]));"}, {"sha": "7fe6f2dbf67d2bbb399275b038bdbcb7d6ccf414", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -568,6 +568,7 @@ pub fn repr_to_string<T>(t: &T) -> String {\n }\n \n #[cfg(test)]\n+#[allow(dead_code)]\n struct P {a: int, b: f64}\n \n #[test]"}, {"sha": "ea298f5e05f71ecfa97d8a7cb44c50f8b55cdd0c", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -632,9 +632,9 @@ mod tests {\n             id_name(n)\n         }\n         fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n-            match self.node_labels.get(*n) {\n-                &Some(ref l) => LabelStr(str::Slice(l.as_slice())),\n-                &None        => LabelStr(id_name(n).name()),\n+            match self.node_labels[*n] {\n+                Some(ref l) => LabelStr(str::Slice(l.as_slice())),\n+                None        => LabelStr(id_name(n).name()),\n             }\n         }\n         fn edge_label(&'a self, e: & &'a Edge) -> LabelText<'a> {"}, {"sha": "1075466d099f977de7375898b1e13298814f4d9e", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -1414,6 +1414,7 @@ mod test {\n         // Regression test that the `start` task entrypoint can\n         // contain dtors that use task resources\n         run(proc() {\n+            #[allow(dead_code)]\n             struct S { field: () }\n \n             impl Drop for S {"}, {"sha": "bc1d877dc547bc24370bb1ba0376334e84c64a7b", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -11,12 +11,10 @@\n //! Blocking posix-based file I/O\n \n use alloc::arc::Arc;\n-use libc::{c_int, c_void};\n-use libc;\n+use libc::{mod, c_int, c_void};\n use std::c_str::CString;\n use std::mem;\n-use std::rt::rtio;\n-use std::rt::rtio::IoResult;\n+use std::rt::rtio::{mod, IoResult};\n \n use io::{retry, keep_going};\n use io::util;\n@@ -55,7 +53,7 @@ impl FileDesc {\n         let ret = retry(|| unsafe {\n             libc::read(self.fd(),\n                        buf.as_mut_ptr() as *mut libc::c_void,\n-                       buf.len() as libc::size_t) as libc::c_int\n+                       buf.len() as libc::size_t)\n         });\n         if ret == 0 {\n             Err(util::eof())\n@@ -93,7 +91,7 @@ impl rtio::RtioFileStream for FileDesc {\n         match retry(|| unsafe {\n             libc::pread(self.fd(), buf.as_ptr() as *mut _,\n                         buf.len() as libc::size_t,\n-                        offset as libc::off_t) as libc::c_int\n+                        offset as libc::off_t)\n         }) {\n             -1 => Err(super::last_error()),\n             n => Ok(n as int)\n@@ -103,7 +101,7 @@ impl rtio::RtioFileStream for FileDesc {\n         super::mkerr_libc(retry(|| unsafe {\n             libc::pwrite(self.fd(), buf.as_ptr() as *const _,\n                          buf.len() as libc::size_t, offset as libc::off_t)\n-        } as c_int))\n+        }))\n     }\n     fn seek(&mut self, pos: i64, whence: rtio::SeekStyle) -> IoResult<u64> {\n         let whence = match whence {"}, {"sha": "7881e088388ca44a4bdde284ab9b000eaa1c4653", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -23,12 +23,11 @@\n \n #![allow(non_snake_case)]\n \n-use libc::c_int;\n-use libc;\n+use libc::{mod, c_int};\n use std::c_str::CString;\n use std::os;\n-use std::rt::rtio;\n-use std::rt::rtio::{IoResult, IoError};\n+use std::rt::rtio::{mod, IoResult, IoError};\n+use std::num;\n \n // Local re-exports\n pub use self::file::FileDesc;\n@@ -97,8 +96,8 @@ fn last_error() -> IoError {\n }\n \n // unix has nonzero values as errors\n-fn mkerr_libc(ret: libc::c_int) -> IoResult<()> {\n-    if ret != 0 {\n+fn mkerr_libc <Int: num::Zero>(ret: Int) -> IoResult<()> {\n+    if !ret.is_zero() {\n         Err(last_error())\n     } else {\n         Ok(())\n@@ -117,39 +116,33 @@ fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> {\n \n #[cfg(windows)]\n #[inline]\n-fn retry(f: || -> libc::c_int) -> libc::c_int {\n-    loop {\n-        match f() {\n-            -1 if os::errno() as int == libc::WSAEINTR as int => {}\n-            n => return n,\n-        }\n-    }\n-}\n+fn retry<I> (f: || -> I) -> I { f() } // PR rust-lang/rust/#17020\n \n #[cfg(unix)]\n #[inline]\n-fn retry(f: || -> libc::c_int) -> libc::c_int {\n+fn retry<I: PartialEq + num::One + Neg<I>> (f: || -> I) -> I {\n+    let minus_one = -num::one::<I>();\n     loop {\n-        match f() {\n-            -1 if os::errno() as int == libc::EINTR as int => {}\n-            n => return n,\n-        }\n+        let n = f();\n+        if n == minus_one && os::errno() == libc::EINTR as int { }\n+        else { return n }\n     }\n }\n \n+\n fn keep_going(data: &[u8], f: |*const u8, uint| -> i64) -> i64 {\n     let origamt = data.len();\n     let mut data = data.as_ptr();\n     let mut amt = origamt;\n     while amt > 0 {\n-        let ret = retry(|| f(data, amt) as libc::c_int);\n+        let ret = retry(|| f(data, amt));\n         if ret == 0 {\n             break\n         } else if ret != -1 {\n             amt -= ret as uint;\n             data = unsafe { data.offset(ret as int) };\n         } else {\n-            return ret as i64;\n+            return ret;\n         }\n     }\n     return (origamt - amt) as i64;"}, {"sha": "ba951cdef26b92272ffd13449660e5470f805b4e", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -13,8 +13,7 @@ use libc;\n use std::mem;\n use std::ptr;\n use std::rt::mutex;\n-use std::rt::rtio;\n-use std::rt::rtio::{IoResult, IoError};\n+use std::rt::rtio::{mod, IoResult, IoError};\n use std::sync::atomic;\n \n use super::{retry, keep_going};\n@@ -988,9 +987,7 @@ pub fn write<T>(fd: sock_t,\n                 write(false, inner, len)\n             });\n         } else {\n-            ret = retry(|| {\n-                write(false, buf.as_ptr(), buf.len()) as libc::c_int\n-            }) as i64;\n+            ret = retry(|| { write(false, buf.as_ptr(), buf.len()) });\n             if ret > 0 { written = ret as uint; }\n         }\n     }\n@@ -1017,7 +1014,7 @@ pub fn write<T>(fd: sock_t,\n             let _guard = lock();\n             let ptr = buf.slice_from(written).as_ptr();\n             let len = buf.len() - written;\n-            match retry(|| write(deadline.is_some(), ptr, len) as libc::c_int) {\n+            match retry(|| write(deadline.is_some(), ptr, len)) {\n                 -1 if util::wouldblock() => {}\n                 -1 => return Err(os::last_error()),\n                 n => { written += n as uint; }"}, {"sha": "c97f9513fc34a66ac61bc19b43f290d87f1be98f", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -1978,10 +1978,10 @@ mod biguint_tests {\n     #[test]\n     fn test_checked_add() {\n         for elm in sum_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigUint::from_slice(a_vec);\n+            let b = BigUint::from_slice(b_vec);\n+            let c = BigUint::from_slice(c_vec);\n \n             assert!(a.checked_add(&b).unwrap() == c);\n             assert!(b.checked_add(&a).unwrap() == c);\n@@ -1991,10 +1991,10 @@ mod biguint_tests {\n     #[test]\n     fn test_checked_sub() {\n         for elm in sum_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigUint::from_slice(a_vec);\n+            let b = BigUint::from_slice(b_vec);\n+            let c = BigUint::from_slice(c_vec);\n \n             assert!(c.checked_sub(&a).unwrap() == b);\n             assert!(c.checked_sub(&b).unwrap() == a);\n@@ -2011,21 +2011,21 @@ mod biguint_tests {\n     #[test]\n     fn test_checked_mul() {\n         for elm in mul_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigUint::from_slice(a_vec);\n+            let b = BigUint::from_slice(b_vec);\n+            let c = BigUint::from_slice(c_vec);\n \n             assert!(a.checked_mul(&b).unwrap() == c);\n             assert!(b.checked_mul(&a).unwrap() == c);\n         }\n \n         for elm in div_rem_quadruples.iter() {\n-            let (aVec, bVec, cVec, dVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n-            let d = BigUint::from_slice(dVec);\n+            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n+            let a = BigUint::from_slice(a_vec);\n+            let b = BigUint::from_slice(b_vec);\n+            let c = BigUint::from_slice(c_vec);\n+            let d = BigUint::from_slice(d_vec);\n \n             assert!(a == b.checked_mul(&c).unwrap() + d);\n             assert!(a == c.checked_mul(&b).unwrap() + d);\n@@ -2035,10 +2035,10 @@ mod biguint_tests {\n     #[test]\n     fn test_checked_div() {\n         for elm in mul_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigUint::from_slice(a_vec);\n+            let b = BigUint::from_slice(b_vec);\n+            let c = BigUint::from_slice(c_vec);\n \n             if !a.is_zero() {\n                 assert!(c.checked_div(&a).unwrap() == b);\n@@ -2651,10 +2651,10 @@ mod bigint_tests {\n     #[test]\n     fn test_checked_add() {\n         for elm in sum_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigInt::from_slice(Plus, aVec);\n-            let b = BigInt::from_slice(Plus, bVec);\n-            let c = BigInt::from_slice(Plus, cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigInt::from_slice(Plus, a_vec);\n+            let b = BigInt::from_slice(Plus, b_vec);\n+            let c = BigInt::from_slice(Plus, c_vec);\n \n             assert!(a.checked_add(&b).unwrap() == c);\n             assert!(b.checked_add(&a).unwrap() == c);\n@@ -2670,10 +2670,10 @@ mod bigint_tests {\n     #[test]\n     fn test_checked_sub() {\n         for elm in sum_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigInt::from_slice(Plus, aVec);\n-            let b = BigInt::from_slice(Plus, bVec);\n-            let c = BigInt::from_slice(Plus, cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigInt::from_slice(Plus, a_vec);\n+            let b = BigInt::from_slice(Plus, b_vec);\n+            let c = BigInt::from_slice(Plus, c_vec);\n \n             assert!(c.checked_sub(&a).unwrap() == b);\n             assert!(c.checked_sub(&b).unwrap() == a);\n@@ -2689,10 +2689,10 @@ mod bigint_tests {\n     #[test]\n     fn test_checked_mul() {\n         for elm in mul_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigInt::from_slice(Plus, aVec);\n-            let b = BigInt::from_slice(Plus, bVec);\n-            let c = BigInt::from_slice(Plus, cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigInt::from_slice(Plus, a_vec);\n+            let b = BigInt::from_slice(Plus, b_vec);\n+            let c = BigInt::from_slice(Plus, c_vec);\n \n             assert!(a.checked_mul(&b).unwrap() == c);\n             assert!(b.checked_mul(&a).unwrap() == c);\n@@ -2702,11 +2702,11 @@ mod bigint_tests {\n         }\n \n         for elm in div_rem_quadruples.iter() {\n-            let (aVec, bVec, cVec, dVec) = *elm;\n-            let a = BigInt::from_slice(Plus, aVec);\n-            let b = BigInt::from_slice(Plus, bVec);\n-            let c = BigInt::from_slice(Plus, cVec);\n-            let d = BigInt::from_slice(Plus, dVec);\n+            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n+            let a = BigInt::from_slice(Plus, a_vec);\n+            let b = BigInt::from_slice(Plus, b_vec);\n+            let c = BigInt::from_slice(Plus, c_vec);\n+            let d = BigInt::from_slice(Plus, d_vec);\n \n             assert!(a == b.checked_mul(&c).unwrap() + d);\n             assert!(a == c.checked_mul(&b).unwrap() + d);\n@@ -2715,10 +2715,10 @@ mod bigint_tests {\n     #[test]\n     fn test_checked_div() {\n         for elm in mul_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigInt::from_slice(Plus, aVec);\n-            let b = BigInt::from_slice(Plus, bVec);\n-            let c = BigInt::from_slice(Plus, cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigInt::from_slice(Plus, a_vec);\n+            let b = BigInt::from_slice(Plus, b_vec);\n+            let c = BigInt::from_slice(Plus, c_vec);\n \n             if !a.is_zero() {\n                 assert!(c.checked_div(&a).unwrap() == b);"}, {"sha": "6171a9946b6085702a0328a00074b91c0bdf0660", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -1047,10 +1047,7 @@ mod tests {\n \n     use serialize::{Encodable, Decodable};\n \n-    use std::io::{IoError, IoResult, SeekStyle};\n-    use std::io;\n     use std::option::{None, Option, Some};\n-    use std::slice;\n \n     #[test]\n     fn test_vuint_at() {"}, {"sha": "2ab7a6c52fac3283faebd2f2528f225cdb127fbf", "filename": "src/librlibc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrlibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrlibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrlibc%2Flib.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -108,8 +108,6 @@ pub unsafe extern \"C\" fn memcmp(s1: *const u8, s2: *const u8, n: uint) -> i32 {\n \n #[cfg(test)]\n mod test {\n-    use core::option::{Some, None};\n-    use core::iter::Iterator;\n     use core::collections::Collection;\n     use core::str::StrSlice;\n     use core::slice::{MutableSlice, ImmutableSlice};"}, {"sha": "c83b81660d58fb296231cd22d37bb74673c6512b", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -69,6 +69,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"rustc_diagnostic_macros\", Active),\n     (\"unboxed_closures\", Active),\n     (\"import_shadowing\", Active),\n+    (\"advanced_slice_patterns\", Active),\n \n     // if you change this list without updating src/doc/rust.md, cmr will be sad\n \n@@ -364,6 +365,20 @@ impl<'a> Visitor<()> for Context<'a> {\n         }\n     }\n \n+    fn visit_pat(&mut self, pattern: &ast::Pat, (): ()) {\n+        match pattern.node {\n+            ast::PatVec(_, Some(_), ref last) if !last.is_empty() => {\n+                self.gate_feature(\"advanced_slice_patterns\",\n+                                  pattern.span,\n+                                  \"multiple-element slice matches anywhere \\\n+                                   but at the end of a slice (e.g. \\\n+                                   `[0, ..xs, 0]` are experimental\")\n+            }\n+            _ => {}\n+        }\n+        visit::walk_pat(self, pattern, ())\n+    }\n+\n     fn visit_fn(&mut self,\n                 fn_kind: &visit::FnKind,\n                 fn_decl: &ast::FnDecl,"}, {"sha": "63e93d266c7703a9f9f96464725d1cffba339e7d", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -96,7 +96,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n \n         // Add a special __test module to the crate that will contain code\n         // generated for the test harness\n-        let (mod_, reexport) = mk_test_module(&self.cx, &self.cx.reexport_test_harness_main);\n+        let (mod_, reexport) = mk_test_module(&mut self.cx);\n         folded.module.items.push(mod_);\n         match reexport {\n             Some(re) => folded.module.view_items.push(re),\n@@ -378,8 +378,7 @@ fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     }\n }\n \n-fn mk_test_module(cx: &TestCtxt, reexport_test_harness_main: &Option<InternedString>)\n-                  -> (Gc<ast::Item>, Option<ast::ViewItem>) {\n+fn mk_test_module(cx: &mut TestCtxt) -> (Gc<ast::Item>, Option<ast::ViewItem>) {\n     // Link to test crate\n     let view_items = vec!(mk_std(cx));\n \n@@ -388,7 +387,7 @@ fn mk_test_module(cx: &TestCtxt, reexport_test_harness_main: &Option<InternedStr\n \n     // The synthesized main function which will call the console test runner\n     // with our list of tests\n-    let mainfn = (quote_item!(&cx.ext_cx,\n+    let mainfn = (quote_item!(&mut cx.ext_cx,\n         pub fn main() {\n             #![main]\n             use std::slice::Slice;\n@@ -412,7 +411,7 @@ fn mk_test_module(cx: &TestCtxt, reexport_test_harness_main: &Option<InternedStr\n         vis: ast::Public,\n         span: DUMMY_SP,\n     };\n-    let reexport = reexport_test_harness_main.as_ref().map(|s| {\n+    let reexport = cx.reexport_test_harness_main.as_ref().map(|s| {\n         // building `use <ident> = __test::main`\n         let reexport_ident = token::str_to_ident(s.get());\n "}, {"sha": "721e5f296e2e7b7f218d9de42d96ea1b189c6550", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -172,33 +172,24 @@ impl LintPass for TypeLimits {\n             ast::ExprLit(lit) => {\n                 match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n                     ty::ty_int(t) => {\n-                        let int_type = if t == ast::TyI {\n-                            cx.sess().targ_cfg.int_type\n-                        } else { t };\n-                        let (min, max) = int_ty_range(int_type);\n-                        let mut lit_val: i64 = match lit.node {\n+                        match lit.node {\n                             ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n                             ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n-                                if v > i64::MAX as u64{\n+                                let int_type = if t == ast::TyI {\n+                                    cx.sess().targ_cfg.int_type\n+                                } else { t };\n+                                let (min, max) = int_ty_range(int_type);\n+                                let negative = self.negated_expr_id == e.id;\n+\n+                                if (negative && v > (min.abs() as u64)) ||\n+                                   (!negative && v > (max.abs() as u64)) {\n                                     cx.span_lint(TYPE_OVERFLOW, e.span,\n                                                  \"literal out of range for its type\");\n                                     return;\n                                 }\n-                                v as i64\n-                            }\n-                            ast::LitInt(v, ast::SignedIntLit(_, ast::Minus)) |\n-                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Minus)) => {\n-                                -(v as i64)\n                             }\n                             _ => fail!()\n                         };\n-                        if self.negated_expr_id == e.id {\n-                            lit_val *= -1;\n-                        }\n-                        if lit_val < min || lit_val > max {\n-                            cx.span_lint(TYPE_OVERFLOW, e.span,\n-                                         \"literal out of range for its type\");\n-                        }\n                     },\n                     ty::ty_uint(t) => {\n                         let uint_type = if t == ast::TyU {"}, {"sha": "b7597b50b4906b76e2c20763087381c1f798712f", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -1951,15 +1951,15 @@ fn roundtrip(in_item: Option<Gc<ast::Item>>) {\n #[test]\n fn test_basic() {\n     let cx = mk_ctxt();\n-    roundtrip(quote_item!(cx,\n+    roundtrip(quote_item!(&cx,\n         fn foo() {}\n     ));\n }\n /* NOTE: When there's a snapshot, update this (yay quasiquoter!)\n #[test]\n fn test_smalltalk() {\n     let cx = mk_ctxt();\n-    roundtrip(quote_item!(cx,\n+    roundtrip(quote_item!(&cx,\n         fn foo() -> int { 3 + 4 } // first smalltalk program ever executed.\n     ));\n }\n@@ -1968,7 +1968,7 @@ fn test_smalltalk() {\n #[test]\n fn test_more() {\n     let cx = mk_ctxt();\n-    roundtrip(quote_item!(cx,\n+    roundtrip(quote_item!(&cx,\n         fn foo(x: uint, y: uint) -> uint {\n             let z = x + y;\n             return z;\n@@ -1987,7 +1987,7 @@ fn test_simplification() {\n     ).unwrap();\n     let item_in = e::IIItemRef(&*item);\n     let item_out = simplify_ast(item_in);\n-    let item_exp = ast::IIItem(quote_item!(cx,\n+    let item_exp = ast::IIItem(quote_item!(&cx,\n         fn new_int_alist<B>() -> alist<int, B> {\n             return alist {eq_fn: eq_int, data: Vec::new()};\n         }"}, {"sha": "605c90a49c6674a375a6611e3199a819a8e7b4f5", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -500,42 +500,44 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n                                         \"target type not found for const cast\")\n                 });\n \n-        let base = eval_const_expr_partial(tcx, &**base);\n-        match base {\n-            Err(_) => base,\n-            Ok(val) => {\n-                match ty::get(ety).sty {\n-                    ty::ty_float(_) => {\n-                        match val {\n-                            const_bool(b) => Ok(const_float(b as f64)),\n-                            const_uint(u) => Ok(const_float(u as f64)),\n-                            const_int(i) => Ok(const_float(i as f64)),\n-                            const_float(f) => Ok(const_float(f)),\n-                            _ => Err(\"can't cast this type to float\".to_string()),\n-                        }\n+        macro_rules! define_casts(\n+            ($val:ident, {\n+                $($ty_pat:pat => (\n+                    $intermediate_ty:ty,\n+                    $const_type:ident,\n+                    $target_ty:ty\n+                )),*\n+            }) => (match ty::get(ety).sty {\n+                $($ty_pat => {\n+                    match $val {\n+                        const_bool(b) => Ok($const_type(b as $intermediate_ty as $target_ty)),\n+                        const_uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n+                        const_int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n+                        const_float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),\n+                        _ => Err(concat!(\n+                            \"can't cast this type to \", stringify!($const_type)\n+                        ).to_string())\n                     }\n-                    ty::ty_uint(_) => {\n-                        match val {\n-                            const_bool(b) => Ok(const_uint(b as u64)),\n-                            const_uint(u) => Ok(const_uint(u)),\n-                            const_int(i) => Ok(const_uint(i as u64)),\n-                            const_float(f) => Ok(const_uint(f as u64)),\n-                            _ => Err(\"can't cast this type to uint\".to_string()),\n-                        }\n-                    }\n-                    ty::ty_int(_) => {\n-                        match val {\n-                            const_bool(b) => Ok(const_int(b as i64)),\n-                            const_uint(u) => Ok(const_int(u as i64)),\n-                            const_int(i) => Ok(const_int(i)),\n-                            const_float(f) => Ok(const_int(f as i64)),\n-                            _ => Err(\"can't cast this type to int\".to_string()),\n-                        }\n-                    }\n-                    _ => Err(\"can't cast this type\".to_string())\n-                }\n-            }\n-        }\n+                },)*\n+                _ => Err(\"can't cast this type\".to_string())\n+            })\n+        )\n+\n+        eval_const_expr_partial(tcx, &**base)\n+            .and_then(|val| define_casts!(val, {\n+                ty::ty_int(ast::TyI) => (int, const_int, i64),\n+                ty::ty_int(ast::TyI8) => (i8, const_int, i64),\n+                ty::ty_int(ast::TyI16) => (i16, const_int, i64),\n+                ty::ty_int(ast::TyI32) => (i32, const_int, i64),\n+                ty::ty_int(ast::TyI64) => (i64, const_int, i64),\n+                ty::ty_uint(ast::TyU) => (uint, const_uint, u64),\n+                ty::ty_uint(ast::TyU8) => (u8, const_uint, u64),\n+                ty::ty_uint(ast::TyU16) => (u16, const_uint, u64),\n+                ty::ty_uint(ast::TyU32) => (u32, const_uint, u64),\n+                ty::ty_uint(ast::TyU64) => (u64, const_uint, u64),\n+                ty::ty_float(ast::TyF32) => (f32, const_float, f64),\n+                ty::ty_float(ast::TyF64) => (f64, const_float, f64)\n+            }))\n       }\n       ExprPath(_) => {\n           match lookup_const(tcx, e) {"}, {"sha": "e8b0afa98c2d0487c78f0f2d54ae4e0f5a723adb", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -199,6 +199,15 @@ fn check_item(cx: &mut Context, item: &Item) {\n                                     cx,\n                                     item.span,\n                                     &*trait_ref);\n+\n+                                let trait_def = ty::lookup_trait_def(cx.tcx, trait_ref.def_id);\n+                                for (ty, type_param_def) in trait_ref.substs.types\n+                                                                  .iter()\n+                                                                  .zip(trait_def.generics\n+                                                                                .types\n+                                                                                .iter()) {\n+                                    check_typaram_bounds(cx, item.span, *ty, type_param_def);\n+                                }\n                             }\n                         }\n                     }"}, {"sha": "854b8b9ba77112337d729054f7676badf65ef1e3", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -1549,18 +1549,13 @@ impl<'a> Resolver<'a> {\n                             PathListMod { .. } => Some(item.span),\n                             _ => None\n                         }).collect::<Vec<Span>>();\n-                        match mod_spans.as_slice() {\n-                            [first, second, ..other] => {\n-                                self.resolve_error(first,\n-                                    \"`mod` import can only appear once in the list\");\n-                                self.session.span_note(second,\n-                                        \"another `mod` import appears here\");\n-                                for &other_span in other.iter() {\n-                                    self.session.span_note(other_span,\n-                                        \"another `mod` import appears here\");\n-                                }\n-                            },\n-                            [_] | [] => ()\n+                        if mod_spans.len() > 1 {\n+                            self.resolve_error(mod_spans[0],\n+                                \"`mod` import can only appear once in the list\");\n+                            for other_span in mod_spans.iter().skip(1) {\n+                                self.session.span_note(*other_span,\n+                                    \"another `mod` import appears here\");\n+                            }\n                         }\n \n                         for source_item in source_items.iter() {\n@@ -3936,6 +3931,7 @@ impl<'a> Resolver<'a> {\n                                                                item.id,\n                                                                ItemRibKind),\n                                              |this| {\n+                    this.resolve_type_parameters(&generics.ty_params);\n                     visit::walk_item(this, item, ());\n                 });\n             }"}, {"sha": "c08401375ca7dc441f9b0c579c990eebd1275b3a", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -769,6 +769,10 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             }\n \n             rcx.visit_expr(&**head, ());\n+            type_of_node_must_outlive(rcx,\n+                                      infer::AddrOf(expr.span),\n+                                      head.id,\n+                                      ty::ReScope(expr.id));\n \n             let repeating_scope = rcx.set_repeating_scope(body.id);\n             rcx.visit_block(&**body, ());"}, {"sha": "d1d76734941e8b68cac3fde546cd8f00bd02a144", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -488,7 +488,9 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n                                  generics: &ast::Generics,\n                                  thing: &'static str) {\n     for ty_param in generics.ty_params.iter() {\n-        for bound in ty_param.bounds.iter() {\n+        let bounds = ty_param.bounds.iter();\n+        let mut bounds = bounds.chain(ty_param.unbound.iter());\n+        for bound in bounds {\n             match *bound {\n                 ast::TraitTyParamBound(..) | ast::UnboxedFnTyParamBound(..) => {\n                     // According to accepted RFC #XXX, we should\n@@ -1076,9 +1078,10 @@ fn add_unsized_bound(ccx: &CrateCtxt,\n                      desc: &str,\n                      span: Span) {\n     let kind_id = ccx.tcx.lang_items.require(SizedTraitLangItem);\n+\n     match unbound {\n         &Some(ast::TraitTyParamBound(ref tpb)) => {\n-            // #FIXME(8559) currently requires the unbound to be built-in.\n+            // FIXME(#8559) currently requires the unbound to be built-in.\n             let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, tpb);\n             match kind_id {\n                 Ok(kind_id) if trait_def_id != kind_id => {"}, {"sha": "86f56660d3a64ed3bbaa6e59b972959ce031f395", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -153,35 +153,25 @@ local_data_key!(test_idx: Cell<uint>)\n local_data_key!(pub playground_krate: Option<String>)\n \n pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n-    extern fn block(ob: *mut hoedown_buffer, text: *const hoedown_buffer,\n+    extern fn block(ob: *mut hoedown_buffer, orig_text: *const hoedown_buffer,\n                     lang: *const hoedown_buffer, opaque: *mut libc::c_void) {\n         unsafe {\n-            if text.is_null() { return }\n+            if orig_text.is_null() { return }\n \n             let opaque = opaque as *mut hoedown_html_renderer_state;\n             let my_opaque: &MyOpaque = &*((*opaque).opaque as *const MyOpaque);\n-            slice::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n+            slice::raw::buf_as_slice((*orig_text).data, (*orig_text).size as uint,\n+                                     |text| {\n                 let origtext = str::from_utf8(text).unwrap();\n                 debug!(\"docblock: ==============\\n{}\\n=======\", text);\n-                let mut lines = origtext.lines().filter(|l| {\n-                    stripped_filtered_line(*l).is_none()\n-                });\n-                let text = lines.collect::<Vec<&str>>().connect(\"\\n\");\n-\n-                let buf = hoedown_buffer {\n-                    data: text.as_bytes().as_ptr(),\n-                    size: text.len() as libc::size_t,\n-                    asize: text.len() as libc::size_t,\n-                    unit: 0,\n-                };\n                 let rendered = if lang.is_null() {\n                     false\n                 } else {\n                     slice::raw::buf_as_slice((*lang).data,\n                                            (*lang).size as uint, |rlang| {\n                         let rlang = str::from_utf8(rlang).unwrap();\n                         if LangString::parse(rlang).notrust {\n-                            (my_opaque.dfltblk)(ob, &buf, lang,\n+                            (my_opaque.dfltblk)(ob, orig_text, lang,\n                                                 opaque as *mut libc::c_void);\n                             true\n                         } else {\n@@ -190,6 +180,10 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                     })\n                 };\n \n+                let mut lines = origtext.lines().filter(|l| {\n+                    stripped_filtered_line(*l).is_none()\n+                });\n+                let text = lines.collect::<Vec<&str>>().connect(\"\\n\");\n                 if !rendered {\n                     let mut s = String::new();\n                     let id = playground_krate.get().map(|krate| {"}, {"sha": "5e0004f2a2a3e04861cf4d1f8d6b5c1bff09bb03", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -671,7 +671,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_new_fail() {\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n+        let _c_str = unsafe { CString::new(ptr::null(), false) };\n     }\n \n     #[test]"}, {"sha": "3d42b91fef17eb817a56cee8073ef8e8b9b3e7de", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -662,7 +662,7 @@ mod test {\n     #[test]\n     fn block_and_wake() {\n         let task = box Task::new();\n-        let mut task = BlockedTask::block(task).wake().unwrap();\n+        let task = BlockedTask::block(task).wake().unwrap();\n         task.drop();\n     }\n }"}, {"sha": "733bc593922dedf32f399b21240bfee1843823d8", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -2128,7 +2128,15 @@ impl ::Decoder<DecoderError> for Decoder {\n         let mut obj = try!(expect!(self.pop(), Object));\n \n         let value = match obj.pop(&name.to_string()) {\n-            None => return Err(MissingFieldError(name.to_string())),\n+            None => {\n+                // Add a Null and try to parse it as an Option<_>\n+                // to get None as a default value.\n+                self.stack.push(Null);\n+                match f(self) {\n+                    Ok(x) => x,\n+                    Err(_) => return Err(MissingFieldError(name.to_string())),\n+                }\n+            },\n             Some(json) => {\n                 self.stack.push(json);\n                 try!(f(self))\n@@ -2167,6 +2175,7 @@ impl ::Decoder<DecoderError> for Decoder {\n     }\n \n     fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> DecodeResult<T>) -> DecodeResult<T> {\n+        debug!(\"read_option()\");\n         match self.pop() {\n             Null => f(self, false),\n             value => { self.stack.push(value); f(self, true) }\n@@ -2372,6 +2381,33 @@ mod tests {\n     use std::{i64, u64, f32, f64, io};\n     use std::collections::TreeMap;\n \n+    #[deriving(Decodable, Eq, PartialEq, Show)]\n+    struct OptionData {\n+        opt: Option<uint>,\n+    }\n+\n+    #[test]\n+    fn test_decode_option_none() {\n+        let s =\"{}\";\n+        let obj: OptionData = super::decode(s).unwrap();\n+        assert_eq!(obj, OptionData { opt: None });\n+    }\n+\n+    #[test]\n+    fn test_decode_option_some() {\n+        let s = \"{ \\\"opt\\\": 10 }\";\n+        let obj: OptionData = super::decode(s).unwrap();\n+        assert_eq!(obj, OptionData { opt: Some(10u) });\n+    }\n+\n+    #[test]\n+    fn test_decode_option_malformed() {\n+        check_err::<OptionData>(\"{ \\\"opt\\\": [] }\",\n+                                ExpectedError(\"Number\".to_string(), \"[]\".to_string()));\n+        check_err::<OptionData>(\"{ \\\"opt\\\": false }\",\n+                                ExpectedError(\"Number\".to_string(), \"false\".to_string()));\n+    }\n+\n     #[deriving(PartialEq, Encodable, Decodable, Show)]\n     enum Animal {\n         Dog,"}, {"sha": "cb4d33049d84fcb5e191ca45f3a6c7af3cc5c180", "filename": "src/libsync/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fspsc_queue.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -298,7 +298,7 @@ mod test {\n \n     use native;\n \n-    use super::{queue, Queue};\n+    use super::{queue};\n \n     #[test]\n     fn smoke() {"}, {"sha": "808e671f868d3a7d573a9fe8adf2fcc4d8c6ad4f", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -766,7 +766,9 @@ fn expand_wrapper(cx: &ExtCtxt,\n         cx.view_use_glob(sp, ast::Inherited, ids_ext(path))\n     }).collect();\n \n-    let stmt_let_ext_cx = cx.stmt_let(sp, false, id_ext(\"ext_cx\"), cx_expr);\n+    // Explicitly borrow to avoid moving from the invoker (#16992)\n+    let cx_expr_borrow = cx.expr_addr_of(sp, cx.expr_deref(sp, cx_expr));\n+    let stmt_let_ext_cx = cx.stmt_let(sp, false, id_ext(\"ext_cx\"), cx_expr_borrow);\n \n     cx.expr_block(cx.block_all(sp, uses, vec!(stmt_let_ext_cx), Some(expr)))\n }"}, {"sha": "ec6fd013d08aef274a6081217f87774831ad56ac", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -35,6 +35,7 @@ pub enum ObsoleteSyntax {\n     ObsoleteManagedType,\n     ObsoleteManagedExpr,\n     ObsoleteImportRenaming,\n+    ObsoleteSubsliceMatch,\n }\n \n pub trait ParserObsoleteMethods {\n@@ -87,6 +88,10 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n             ObsoleteImportRenaming => (\n                 \"`use foo = bar` syntax\",\n                 \"write `use bar as foo` instead\"\n+            ),\n+            ObsoleteSubsliceMatch => (\n+                \"subslice match syntax\",\n+                \"instead of `..xs`, write `xs..` in a pattern\"\n             )\n         };\n "}, {"sha": "6aff1152f7e1d18c032cf958ad1fe64c46fd1ef3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -2858,43 +2858,42 @@ impl<'a> Parser<'a> {\n         let mut before_slice = true;\n \n         while self.token != token::RBRACKET {\n-            if first { first = false; }\n-            else { self.expect(&token::COMMA); }\n+            if first {\n+                first = false;\n+            } else {\n+                self.expect(&token::COMMA);\n+            }\n \n-            let mut is_slice = false;\n             if before_slice {\n                 if self.token == token::DOTDOT {\n                     self.bump();\n-                    is_slice = true;\n-                    before_slice = false;\n-                }\n-            }\n \n-            if is_slice {\n-                if self.token == token::COMMA || self.token == token::RBRACKET {\n-                    slice = Some(box(GC) ast::Pat {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: PatWild(PatWildMulti),\n-                        span: self.span,\n-                    })\n-                } else {\n-                    let subpat = self.parse_pat();\n-                    match *subpat {\n-                        ast::Pat { node: PatIdent(_, _, _), .. } => {\n-                            slice = Some(subpat);\n-                        }\n-                        ast::Pat { span, .. } => self.span_fatal(\n-                            span, \"expected an identifier or nothing\"\n-                        )\n+                    if self.token == token::COMMA ||\n+                            self.token == token::RBRACKET {\n+                        slice = Some(box(GC) ast::Pat {\n+                            id: ast::DUMMY_NODE_ID,\n+                            node: PatWild(PatWildMulti),\n+                            span: self.span,\n+                        });\n+                        before_slice = false;\n+                    } else {\n+                        let _ = self.parse_pat();\n+                        let span = self.span;\n+                        self.obsolete(span, ObsoleteSubsliceMatch);\n                     }\n+                    continue\n                 }\n+            }\n+\n+            let subpat = self.parse_pat();\n+            if before_slice && self.token == token::DOTDOT {\n+                self.bump();\n+                slice = Some(subpat);\n+                before_slice = false;\n+            } else if before_slice {\n+                before.push(subpat);\n             } else {\n-                let subpat = self.parse_pat();\n-                if before_slice {\n-                    before.push(subpat);\n-                } else {\n-                    after.push(subpat);\n-                }\n+                after.push(subpat);\n             }\n         }\n \n@@ -3065,7 +3064,11 @@ impl<'a> Parser<'a> {\n             // These expressions are limited to literals (possibly\n             // preceded by unary-minus) or identifiers.\n             let val = self.parse_literal_maybe_minus();\n-            if self.eat(&token::DOTDOT) {\n+            if self.token == token::DOTDOT &&\n+                    self.look_ahead(1, |t| {\n+                        *t != token::COMMA && *t != token::RBRACKET\n+                    }) {\n+                self.bump();\n                 let end = if is_ident_or_path(&self.token) {\n                     let path = self.parse_path(LifetimeAndTypesWithColons)\n                                    .path;\n@@ -3106,7 +3109,10 @@ impl<'a> Parser<'a> {\n                 }\n             });\n \n-            if self.look_ahead(1, |t| *t == token::DOTDOT) {\n+            if self.look_ahead(1, |t| *t == token::DOTDOT) &&\n+                    self.look_ahead(2, |t| {\n+                        *t != token::COMMA && *t != token::RBRACKET\n+                    }) {\n                 let start = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n                 self.eat(&token::DOTDOT);\n                 let end = self.parse_expr_res(RESTRICT_NO_BAR_OP);"}, {"sha": "eaeb6aaab8a75134d2cc159eb30e8b023caa6ff3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -1912,13 +1912,13 @@ impl<'a> State<'a> {\n                                    |s, p| s.print_pat(&**p)));\n                 for p in slice.iter() {\n                     if !before.is_empty() { try!(self.word_space(\",\")); }\n+                    try!(self.print_pat(&**p));\n                     match **p {\n                         ast::Pat { node: ast::PatWild(ast::PatWildMulti), .. } => {\n                             // this case is handled by print_pat\n                         }\n                         _ => try!(word(&mut self.s, \"..\")),\n                     }\n-                    try!(self.print_pat(&**p));\n                     if !after.is_empty() { try!(self.word_space(\",\")); }\n                 }\n                 try!(self.commasep(Inconsistent,"}, {"sha": "09dc8166908d92061944c4783888630f777fe38b", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -527,7 +527,6 @@ mod uuidtest {\n     use super::{Uuid, VariantMicrosoft, VariantNCS, VariantRFC4122,\n                 Version1Mac, Version2Dce, Version3Md5, Version4Random,\n                 Version5Sha1};\n-    use std::io::MemWriter;\n     use std::rand;\n \n     #[test]\n@@ -798,7 +797,6 @@ mod uuidtest {\n     #[test]\n     fn test_serialize_round_trip() {\n         use serialize::json;\n-        use serialize::{Encodable, Decodable};\n \n         let u = Uuid::new_v4();\n         let s = json::encode(&u);\n@@ -809,7 +807,7 @@ mod uuidtest {\n     #[test]\n     fn test_bad_decode() {\n         use serialize::json;\n-        use serialize::{Encodable, Decodable};\n+        use serialize::{Decodable};\n \n         let js_good = json::String(\"a1a2a3a4a5a6a7a8a1a2a3a4a5a6a7a8\".to_string());\n         let js_bad1 = json::String(\"a1a2a3a4a5a6a7a8a1a2a3a4a5a6a7ah\".to_string());"}, {"sha": "05ecb9def9b5c10e4dcbfde22012cbb20787cd95", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -1,12 +1,42 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n+// The Computer Language Benchmarks Game\n+// http://benchmarksgame.alioth.debian.org/\n //\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+// contributed by the Rust Project Developers\n+\n+// Copyright (c) 2012-2014 The Rust Project Developers\n+//\n+// All rights reserved.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions\n+// are met:\n+//\n+// - Redistributions of source code must retain the above copyright\n+//   notice, this list of conditions and the following disclaimer.\n+//\n+// - Redistributions in binary form must reproduce the above copyright\n+//   notice, this list of conditions and the following disclaimer in\n+//   the documentation and/or other materials provided with the\n+//   distribution.\n+//\n+// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n+//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n+//   names of its contributors may be used to endorse or promote\n+//   products derived from this software without specific prior\n+//   written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+// OF THE POSSIBILITY OF SUCH DAMAGE.\n \n // no-pretty-expanded\n "}, {"sha": "9e30a5124771929c3610057ee0f5136746b85d6b", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -1,12 +1,42 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n+// The Computer Language Benchmarks Game\n+// http://benchmarksgame.alioth.debian.org/\n //\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+// contributed by the Rust Project Developers\n+\n+// Copyright (c) 2011-2014 The Rust Project Developers\n+//\n+// All rights reserved.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions\n+// are met:\n+//\n+// - Redistributions of source code must retain the above copyright\n+//   notice, this list of conditions and the following disclaimer.\n+//\n+// - Redistributions in binary form must reproduce the above copyright\n+//   notice, this list of conditions and the following disclaimer in\n+//   the documentation and/or other materials provided with the\n+//   distribution.\n+//\n+// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n+//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n+//   names of its contributors may be used to endorse or promote\n+//   products derived from this software without specific prior\n+//   written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+// OF THE POSSIBILITY OF SUCH DAMAGE.\n \n static PI: f64 = 3.141592653589793;\n static SOLAR_MASS: f64 = 4.0 * PI * PI;"}, {"sha": "52defe6a2767d5d2bee768e4061a4b5fcda16697", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -1,12 +1,42 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n+// The Computer Language Benchmarks Game\n+// http://benchmarksgame.alioth.debian.org/\n //\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+// contributed by the Rust Project Developers\n+\n+// Copyright (c) 2013-2014 The Rust Project Developers\n+//\n+// All rights reserved.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions\n+// are met:\n+//\n+// - Redistributions of source code must retain the above copyright\n+//   notice, this list of conditions and the following disclaimer.\n+//\n+// - Redistributions in binary form must reproduce the above copyright\n+//   notice, this list of conditions and the following disclaimer in\n+//   the documentation and/or other materials provided with the\n+//   distribution.\n+//\n+// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n+//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n+//   names of its contributors may be used to endorse or promote\n+//   products derived from this software without specific prior\n+//   written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+// OF THE POSSIBILITY OF SUCH DAMAGE.\n \n // ignore-pretty very bad with line comments\n // ignore-android doesn't terminate?"}, {"sha": "600c0ac801b7e0700001fa3185f6b828880afd34", "filename": "src/test/compile-fail/borrowck-for-loop-head-linkage.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let mut vector = vec![1u, 2];\n+    for &x in vector.iter() {\n+        let cap = vector.capacity();\n+        vector.grow(cap, &0u);      //~ ERROR cannot borrow\n+        *vector.get_mut(1u) = 5u;   //~ ERROR cannot borrow\n+    }\n+}\n+"}, {"sha": "d3c6a280e8c2a2dcabd6c582f56b758f47599250", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -25,7 +25,7 @@ pub fn main() {\n     );\n     let x: &[Foo] = x.as_slice();\n     match x {\n-        [_, ..tail] => {\n+        [_, tail..] => {\n             match tail {\n                 [Foo { string: a }, //~ ERROR cannot move out of dereference of `&`-pointer\n                  Foo { string: b }] => {"}, {"sha": "d256b033298ed988d7d6b292eaaed6b426b2cfdf", "filename": "src/test/compile-fail/borrowck-vec-pattern-element-loan.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(advanced_slice_patterns)]\n+\n fn a<'a>() -> &'a [int] {\n     let vec = vec!(1, 2, 3, 4);\n     let vec: &[int] = vec.as_slice(); //~ ERROR does not live long enough\n     let tail = match vec {\n-        [_, ..tail] => tail,\n+        [_, tail..] => tail,\n         _ => fail!(\"a\")\n     };\n     tail\n@@ -22,7 +24,7 @@ fn b<'a>() -> &'a [int] {\n     let vec = vec!(1, 2, 3, 4);\n     let vec: &[int] = vec.as_slice(); //~ ERROR does not live long enough\n     let init = match vec {\n-        [..init, _] => init,\n+        [init.., _] => init,\n         _ => fail!(\"b\")\n     };\n     init\n@@ -32,7 +34,7 @@ fn c<'a>() -> &'a [int] {\n     let vec = vec!(1, 2, 3, 4);\n     let vec: &[int] = vec.as_slice(); //~ ERROR does not live long enough\n     let slice = match vec {\n-        [_, ..slice, _] => slice,\n+        [_, slice.., _] => slice,\n         _ => fail!(\"c\")\n     };\n     slice"}, {"sha": "cc1dbc81955435b7aab2029a2b0c3ff4d54c7660", "filename": "src/test/compile-fail/borrowck-vec-pattern-loan-from-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -12,7 +12,7 @@ fn a() {\n     let mut v = vec!(1, 2, 3);\n     let vb: &mut [int] = v.as_mut_slice();\n     match vb {\n-        [_a, ..tail] => {\n+        [_a, tail..] => {\n             v.push(tail[0] + tail[1]); //~ ERROR cannot borrow\n         }\n         _ => {}"}, {"sha": "cb8762f44fb7932ceef6283b1648635788e741cf", "filename": "src/test/compile-fail/borrowck-vec-pattern-move-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     let mut a = [1i, 2, 3, 4];\n     let t = match a {\n-        [1, 2, ..tail] => tail,\n+        [1, 2, tail..] => tail,\n         _ => unreachable!()\n     };\n     a[0] = 0; //~ ERROR cannot assign to `a[..]` because it is borrowed"}, {"sha": "2eec788785605183711b9cbaa8802d2e7e41f058", "filename": "src/test/compile-fail/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(advanced_slice_patterns)]\n \n fn a() {\n     let mut vec = [box 1i, box 2, box 3];\n@@ -22,7 +23,7 @@ fn b() {\n     let mut vec = vec!(box 1i, box 2, box 3);\n     let vec: &mut [Box<int>] = vec.as_mut_slice();\n     match vec {\n-        [.._b] => {\n+        [_b..] => {\n             vec[0] = box 4; //~ ERROR cannot assign\n         }\n     }\n@@ -33,7 +34,7 @@ fn c() {\n     let vec: &mut [Box<int>] = vec.as_mut_slice();\n     match vec {\n         [_a,         //~ ERROR cannot move out\n-         .._b] => {  //~^ NOTE attempting to move value to here\n+         _b..] => {  //~^ NOTE attempting to move value to here\n \n             // Note: `_a` is *moved* here, but `b` is borrowing,\n             // hence illegal.\n@@ -50,7 +51,7 @@ fn d() {\n     let mut vec = vec!(box 1i, box 2, box 3);\n     let vec: &mut [Box<int>] = vec.as_mut_slice();\n     match vec {\n-        [.._a,     //~ ERROR cannot move out\n+        [_a..,     //~ ERROR cannot move out\n          _b] => {} //~ NOTE attempting to move value to here\n         _ => {}\n     }"}, {"sha": "2c9cf7d1b65be0abf147be7a86b1e360afb9a0f9", "filename": "src/test/compile-fail/borrowck-vec-pattern-tail-element-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -12,7 +12,7 @@ fn a<'a>() -> &'a int {\n     let vec = vec!(1, 2, 3, 4);\n     let vec: &[int] = vec.as_slice(); //~ ERROR `vec` does not live long enough\n     let tail = match vec {\n-        [_a, ..tail] => &tail[0],\n+        [_a, tail..] => &tail[0],\n         _ => fail!(\"foo\")\n     };\n     tail"}, {"sha": "97d593d310e139714e5c10e3d00a5f166e244c16", "filename": "src/test/compile-fail/feature-gate-advanced-slice-features.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Ffeature-gate-advanced-slice-features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Ffeature-gate-advanced-slice-features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-advanced-slice-features.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x = [ 1i, 2, 3, 4, 5 ];\n+    match x {\n+        [ xs.., 4, 5 ] => {}    //~ ERROR multiple-element slice matches\n+        [ 1, xs.., 5 ] => {}    //~ ERROR multiple-element slice matches\n+        [ 1, 2, xs.. ] => {}    // OK without feature gate\n+    }\n+}\n+"}, {"sha": "8b52324848bf4409d101d22347823ff9f7e44209", "filename": "src/test/compile-fail/generic-lifetime-trait-impl.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fgeneric-lifetime-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fgeneric-lifetime-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-lifetime-trait-impl.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This code used to produce an ICE on the definition of trait Bar\n+// with the following message:\n+//\n+// Type parameter out of range when substituting in region 'a (root\n+// type=fn(Self) -> 'astr) (space=FnSpace, index=0)\n+//\n+// Regression test for issue #16218.\n+\n+trait Bar<'a> {}\n+\n+trait Foo<'a> {\n+    fn bar<'a, T: Bar<'a>>(self) -> &'a str;\n+}\n+\n+impl<'a> Foo<'a> for &'a str {\n+    fn bar<T: Bar<'a>>(self) -> &'a str { fail!() } //~ ERROR lifetime\n+}\n+\n+fn main() {\n+}"}, {"sha": "4522b536ffd347eea776c924d58506608f00b6f4", "filename": "src/test/compile-fail/issue-12369.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fissue-12369.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fissue-12369.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12369.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     let v: int = match sl.as_slice() {\n         [] => 0,\n         [a,b,c] => 3,\n-        [a, ..rest] => a,\n-        [10,a, ..rest] => 10 //~ ERROR: unreachable pattern\n+        [a, rest..] => a,\n+        [10,a, rest..] => 10 //~ ERROR: unreachable pattern\n     };\n }"}, {"sha": "26866cbbc6033c85e5de3a9536caf879226b0491", "filename": "src/test/compile-fail/issue-12567.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fissue-12567.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fissue-12567.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12567.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -11,10 +11,10 @@\n fn match_vecs<'a, T>(l1: &'a [T], l2: &'a [T]) {\n     match (l1, l2) {\n         ([], []) => println!(\"both empty\"),\n-        ([], [hd, ..tl]) | ([hd, ..tl], []) => println!(\"one empty\"),\n+        ([], [hd, tl..]) | ([hd, tl..], []) => println!(\"one empty\"),\n         //~^ ERROR: cannot move out of dereference\n         //~^^ ERROR: cannot move out of dereference\n-        ([hd1, ..tl1], [hd2, ..tl2]) => println!(\"both nonempty\"),\n+        ([hd1, tl1..], [hd2, tl2..]) => println!(\"both nonempty\"),\n         //~^ ERROR: cannot move out of dereference\n         //~^^ ERROR: cannot move out of dereference\n     }"}, {"sha": "81b186a2998a83c00be2bdcf17af837ee44c074e", "filename": "src/test/compile-fail/lint-type-overflow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Flint-type-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Flint-type-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-overflow.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -49,6 +49,7 @@ fn main() {\n     let x = -2147483649_i32; //~ error: literal out of range for its type\n \n     let x = 9223372036854775808_i64; //~ error: literal out of range for its type\n+    let x = -9223372036854775808_i64; // should be OK\n     let x = 18446744073709551615_i64; //~ error: literal out of range for its type\n \n     let x = -3.40282348e+38_f32; //~ error: literal out of range for its type"}, {"sha": "51e83c14aa0082686c1fd2c56969aeb67d381d86", "filename": "src/test/compile-fail/match-vec-invalid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fmatch-vec-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fmatch-vec-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-invalid.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     let a = Vec::new();\n     match a {\n-        [1, ..tail, ..tail] => {}, //~ ERROR: unexpected token: `..`\n+        [1, tail.., tail..] => {}, //~ ERROR: expected `,`, found `..`\n         _ => ()\n     }\n }"}, {"sha": "a85ce660e8b1ffc08302b5a7bb2f2b06edf47075", "filename": "src/test/compile-fail/match-vec-unreachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -31,7 +31,7 @@ fn main() {\n     let x: Vec<char> = vec!('a', 'b', 'c');\n     let x: &[char] = x.as_slice();\n     match x {\n-        ['a', 'b', 'c', .._tail] => {}\n+        ['a', 'b', 'c', _tail..] => {}\n         ['a', 'b', 'c'] => {} //~ ERROR unreachable pattern\n         _ => {}\n     }"}, {"sha": "ae5f40d4874c991def4b70f6cf134d4b8925afe9", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -38,14 +38,14 @@ fn main() {\n     let vec = vec!(Some(42i), None, Some(21i));\n     let vec: &[Option<int>] = vec.as_slice();\n     match vec { //~ ERROR non-exhaustive patterns: `[]` not covered\n-        [Some(..), None, ..tail] => {}\n-        [Some(..), Some(..), ..tail] => {}\n+        [Some(..), None, tail..] => {}\n+        [Some(..), Some(..), tail..] => {}\n         [None] => {}\n     }\n     let vec = vec!(1i);\n     let vec: &[int] = vec.as_slice();\n     match vec {\n-        [_, ..tail] => (),\n+        [_, tail..] => (),\n         [] => ()\n     }\n     let vec = vec!(0.5f32);\n@@ -59,10 +59,10 @@ fn main() {\n     let vec = vec!(Some(42i), None, Some(21i));\n     let vec: &[Option<int>] = vec.as_slice();\n     match vec {\n-        [Some(..), None, ..tail] => {}\n-        [Some(..), Some(..), ..tail] => {}\n-        [None, None, ..tail] => {}\n-        [None, Some(..), ..tail] => {}\n+        [Some(..), None, tail..] => {}\n+        [Some(..), Some(..), tail..] => {}\n+        [None, None, tail..] => {}\n+        [None, Some(..), tail..] => {}\n         [Some(_)] => {}\n         [None] => {}\n         [] => {}"}, {"sha": "b7ff3a18fcf7a3a19cf30b01a0328c9fc1655cc7", "filename": "src/test/compile-fail/non-exhaustive-pattern-witness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n+#![feature(advanced_slice_patterns, struct_variant)]\n \n struct Foo {\n     first: bool,\n@@ -63,7 +63,7 @@ fn vectors_with_nested_enums() {\n         [Second(true), First] => (),\n         [Second(true), Second(true)] => (),\n         [Second(false), _] => (),\n-        [_, _, ..tail, _] => ()\n+        [_, _, tail.., _] => ()\n     }\n }\n "}, {"sha": "f71afeb1b308f5f15080de2913b6f2570e11e63c", "filename": "src/test/compile-fail/unsized3.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized3.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -57,20 +57,18 @@ fn f9<Sized? X>(x1: Box<S<X>>, x2: Box<E<X>>) {\n     //~^ ERROR instantiating a type parameter with an incompatible type\n }\n \n-// I would like these to fail eventually.\n-/*\n // impl - bounded\n trait T1<Z: T> {\n }\n struct S3<Sized? Y>;\n-impl<Sized? X: T> T1<X> for S3<X> { //ERROR instantiating a type parameter with an incompatible type\n+impl<Sized? X: T> T1<X> for S3<X> { //~ ERROR instantiating a type parameter with an incompatible\n }\n \n // impl - unbounded\n trait T2<Z> {\n }\n-impl<Sized? X> T2<X> for S3<X> { //ERROR instantiating a type parameter with an incompatible type `X\n-*/\n+impl<Sized? X> T2<X> for S3<X> { //~ ERROR instantiating a type parameter with an incompatible type\n+}\n \n // impl - struct\n trait T3<Sized? Z> {"}, {"sha": "6330aac2d8b75878cd1d65be252213c07e97828c", "filename": "src/test/compile-fail/vec-matching-obsolete-syntax.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fvec-matching-obsolete-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Fcompile-fail%2Fvec-matching-obsolete-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-matching-obsolete-syntax.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x = [1i, 2, 3];\n+    match x {\n+        [a, b, ..c] => {    //~ ERROR obsolete syntax\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+            let expected: &[_] = &[3];\n+            assert_eq!(c, expected);\n+        }\n+    }\n+}\n+"}, {"sha": "563b8394963256d224474d4c54ec8f50a117b1d2", "filename": "src/test/run-pass-fulldeps/issue-16992.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass-fulldeps%2Fissue-16992.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass-fulldeps%2Fissue-16992.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-16992.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty\n+// ignore-android\n+\n+#![feature(quote)]\n+\n+extern crate syntax;\n+\n+use syntax::ext::base::ExtCtxt;\n+\n+#[allow(dead_code)]\n+fn foobar(cx: &mut ExtCtxt) {\n+    quote_expr!(cx, 1i);\n+    quote_expr!(cx, 2i);\n+}\n+\n+fn main() { }"}, {"sha": "b39f03a93c9fee75c56c9948dd5510d3ed2288fe", "filename": "src/test/run-pass/borrowck-trait-lifetime.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fborrowck-trait-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fborrowck-trait-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-trait-lifetime.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test verifies that casting from the same lifetime on a value\n+// to the same lifetime on a trait succeeds. See issue #10766.\n+\n+#![allow(dead_code)]\n+fn main() {\n+    trait T {}\n+\n+    fn f<'a, V: T>(v: &'a V) -> &'a T {\n+        v as &'a T\n+    }\n+}"}, {"sha": "206ab0dfeb2d06074568c2fde5c1150e2e7e08c3", "filename": "src/test/run-pass/for-loop-does-not-borrow-iterators.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b625d43f8fd2e9a800ca8a419f7d3f5f52604205/src%2Ftest%2Frun-pass%2Ffor-loop-does-not-borrow-iterators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b625d43f8fd2e9a800ca8a419f7d3f5f52604205/src%2Ftest%2Frun-pass%2Ffor-loop-does-not-borrow-iterators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-loop-does-not-borrow-iterators.rs?ref=b625d43f8fd2e9a800ca8a419f7d3f5f52604205", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// The `for` loop use to keep a mutable borrow when executing its body,\n-// making it impossible to re-use the iterator as follows.\n-// https://github.com/rust-lang/rust/issues/8372\n-//\n-// This was fixed in https://github.com/rust-lang/rust/pull/15809\n-\n-pub fn main() {\n-    let mut for_loop_values = Vec::new();\n-    let mut explicit_next_call_values = Vec::new();\n-\n-    let mut iter = range(1i, 10);\n-    for i in iter {\n-        for_loop_values.push(i);\n-        explicit_next_call_values.push(iter.next());\n-    }\n-\n-    assert_eq!(for_loop_values, vec![1, 3, 5, 7, 9]);\n-    assert_eq!(explicit_next_call_values, vec![Some(2), Some(4), Some(6), Some(8), None]);\n-}"}, {"sha": "1c87b6dad8970abffcbdd4f03cbd4b9df2bdb98a", "filename": "src/test/run-pass/ignore-all-the-things.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fignore-all-the-things.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fignore-all-the-things.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fignore-all-the-things.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(advanced_slice_patterns)]\n+\n struct Foo(int, int, int, int);\n struct Bar{a: int, b: int, c: int, d: int}\n "}, {"sha": "1709321a71cfdaa76f64f93a90abfad8012c2a8c", "filename": "src/test/run-pass/issue-15080.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15080.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -14,11 +14,11 @@ fn main() {\n     let mut result = vec!();\n     loop {\n         x = match x {\n-            [1, n, 3, ..rest] => {\n+            [1, n, 3, rest..] => {\n                 result.push(n);\n                 rest\n             }\n-            [n, ..rest] => {\n+            [n, rest..] => {\n                 result.push(n);\n                 rest\n             }"}, {"sha": "c6c9e8004558cce19afae47a568bd14ef69e7e5f", "filename": "src/test/run-pass/issue-15104.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fissue-15104.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fissue-15104.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15104.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -16,6 +16,6 @@ fn count_members(v: &[uint]) -> uint {\n     match v {\n         []         => 0,\n         [_]        => 1,\n-        [_x, ..xs] => 1 + count_members(xs)\n+        [_x, xs..] => 1 + count_members(xs)\n     }\n }"}, {"sha": "e346148691d863689bdd19c1d84cfc2014918797", "filename": "src/test/run-pass/issue-17074.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fissue-17074.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fissue-17074.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17074.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static X: u64 = -1 as u16 as u64;\n+static Y: u64 = -1 as u32 as u64;\n+\n+fn main() {\n+    assert_eq!(match 1 {\n+        X => unreachable!(),\n+        Y => unreachable!(),\n+        _ => 1i\n+    }, 1);\n+}"}, {"sha": "666847517efdeda568d337a45d628f586e46fb20", "filename": "src/test/run-pass/issue-7784.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7784.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(advanced_slice_patterns)]\n+\n fn foo<T: Add<T, T> + Clone>([x, y, z]: [T, ..3]) -> (T, T, T) {\n     (x.clone(), x.clone() + y.clone(), x + y + z)\n }\n@@ -29,7 +31,7 @@ fn main() {\n     assert_eq!(d, \"baz\");\n \n     let out = bar(\"baz\", \"foo\");\n-    let [a, ..xs, d] = out;\n+    let [a, xs.., d] = out;\n     assert_eq!(a, \"baz\");\n     assert!(xs == [\"foo\", \"foo\"]);\n     assert_eq!(d, \"baz\");"}, {"sha": "ae4fd1f1993b7227ebcded4fa9c28e999972dacb", "filename": "src/test/run-pass/match-vec-alternatives.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(advanced_slice_patterns)]\n+\n fn match_vecs<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n     match (l1, l2) {\n         ([], []) => \"both empty\","}, {"sha": "55d89d4e4f689d124bc7017f12934c1894863479", "filename": "src/test/run-pass/unboxed-closures-unique-type-id.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// This code used to produce the following ICE:\n+//\n+//    error: internal compiler error: get_unique_type_id_of_type() -\n+//    unexpected type: closure,\n+//    ty_unboxed_closure(syntax::ast::DefId{krate: 0u32, node: 66u32},\n+//    ReScope(63u32))\n+//\n+// This is a regression test for issue #17021.\n+\n+#![feature(unboxed_closures, overloaded_calls)]\n+\n+use std::ptr;\n+\n+pub fn replace_map<'a, T, F>(src: &mut T, prod: F)\n+where F: |: T| -> T {\n+    unsafe { *src = prod(ptr::read(src as *mut T as *const T)); }\n+}\n+\n+pub fn main() {\n+    let mut a = 7u;\n+    let b = &mut a;\n+    replace_map(b, |: x: uint| x * 2);\n+    assert_eq!(*b, 14u);\n+}"}, {"sha": "141d6c88dd96108607083019bdceb5d4cf6928b7", "filename": "src/test/run-pass/unsized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Funsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Funsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -24,6 +24,7 @@ struct S1<Sized? X>;\n enum E<Sized? X> {}\n impl <Sized? X> T1 for S1<X> {}\n fn f<Sized? X>() {}\n+type TT<Sized? T> = T;\n \n pub fn main() {\n }"}, {"sha": "a1a14823ff5955b5923d6d6021bd4c7d903c3959", "filename": "src/test/run-pass/vec-matching-fixed.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fvec-matching-fixed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fvec-matching-fixed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-fixed.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(advanced_slice_patterns)]\n+\n fn a() {\n     let x = [1i, 2, 3];\n     match x {"}, {"sha": "63914a8df31cdc52e7474c5ce18646d45dd45d9f", "filename": "src/test/run-pass/vec-matching-fold.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(advanced_slice_patterns)]\n+\n fn foldl<T,U:Clone>(values: &[T],\n                     initial: U,\n                     function: |partial: U, element: &T| -> U)\n                     -> U {\n     match values {\n-        [ref head, ..tail] =>\n+        [ref head, tail..] =>\n             foldl(tail, function(initial, head), function),\n         [] => initial.clone()\n     }\n@@ -24,7 +26,7 @@ fn foldr<T,U:Clone>(values: &[T],\n                     function: |element: &T, partial: U| -> U)\n                     -> U {\n     match values {\n-        [..head, ref tail] =>\n+        [head.., ref tail] =>\n             foldr(head, function(tail, initial), function),\n         [] => initial.clone()\n     }"}, {"sha": "a140399447b3bcbb99837f04b8f433a9eed021da", "filename": "src/test/run-pass/vec-matching-legal-tail-element-borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -13,7 +13,7 @@ pub fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     if !x.is_empty() {\n         let el = match x {\n-            [1, ..ref tail] => &tail[0],\n+            [1, ref tail..] => &tail[0],\n             _ => unreachable!()\n         };\n         println!(\"{}\", *el);"}, {"sha": "187d97f483ddaa6ff787ac23cff471f0b4089018", "filename": "src/test/run-pass/vec-matching.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(advanced_slice_patterns)]\n+\n fn a() {\n     let x = [1i];\n     match x {\n@@ -20,23 +22,23 @@ fn a() {\n fn b() {\n     let x = [1i, 2, 3];\n     match x {\n-        [a, b, ..c] => {\n+        [a, b, c..] => {\n             assert_eq!(a, 1);\n             assert_eq!(b, 2);\n             let expected: &[_] = &[3];\n             assert_eq!(c, expected);\n         }\n     }\n     match x {\n-        [..a, b, c] => {\n+        [a.., b, c] => {\n             let expected: &[_] = &[1];\n             assert_eq!(a, expected);\n             assert_eq!(b, 2);\n             assert_eq!(c, 3);\n         }\n     }\n     match x {\n-        [a, ..b, c] => {\n+        [a, b.., c] => {\n             assert_eq!(a, 1);\n             let expected: &[_] = &[2];\n             assert_eq!(b, expected);"}, {"sha": "a1a222549a086a10913365612ec7d78a17bffabf", "filename": "src/test/run-pass/vec-tail-matching.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651106462c357b71a4ca2c02ba2bfedfc38b0035/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs?ref=651106462c357b71a4ca2c02ba2bfedfc38b0035", "patch": "@@ -20,14 +20,14 @@ pub fn main() {\n         Foo { string: \"baz\".to_string() }\n     ];\n     match x {\n-        [ref first, ..tail] => {\n+        [ref first, tail..] => {\n             assert!(first.string == \"foo\".to_string());\n             assert_eq!(tail.len(), 2);\n             assert!(tail[0].string == \"bar\".to_string());\n             assert!(tail[1].string == \"baz\".to_string());\n \n             match tail {\n-                [Foo { .. }, _, Foo { .. }, .. _tail] => {\n+                [Foo { .. }, _, Foo { .. }, _tail..] => {\n                     unreachable!();\n                 }\n                 [Foo { string: ref a }, Foo { string: ref b }] => {"}]}