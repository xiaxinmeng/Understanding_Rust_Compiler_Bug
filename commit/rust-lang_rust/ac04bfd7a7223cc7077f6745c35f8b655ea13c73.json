{"sha": "ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "node_id": "C_kwDOAAsO6NoAKGFjMDRiZmQ3YTcyMjNjYzcwNzdmNjc0NWMzNWY4YjY1NWVhMTNjNzM", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-02-26T12:34:41Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-06T17:39:09Z"}, "message": "Add `View Mir` command and fix some bugs", "tree": {"sha": "fb993abefdda7f7673b7b715199119335eea4e1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb993abefdda7f7673b7b715199119335eea4e1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "html_url": "https://github.com/rust-lang/rust/commit/ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a25710b0c01cc523b0f3732ca68321ac107a0ebe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a25710b0c01cc523b0f3732ca68321ac107a0ebe", "html_url": "https://github.com/rust-lang/rust/commit/a25710b0c01cc523b0f3732ca68321ac107a0ebe"}], "stats": {"total": 998, "additions": 876, "deletions": 122}, "files": [{"sha": "304c78767f129a679b845318bd61889c75b4c490", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -18,7 +18,7 @@ use crate::{\n     chalk_db,\n     consteval::ConstEvalError,\n     method_resolution::{InherentImpls, TraitImpls, TyFingerprint},\n-    mir::{MirBody, MirLowerError},\n+    mir::{BorrowckResult, MirBody, MirLowerError},\n     Binders, CallableDefId, Const, FnDefId, GenericArg, ImplTraitId, InferenceResult, Interner,\n     PolyFnSig, QuantifiedWhereClause, ReturnTypeImplTraits, Substitution, TraitRef, Ty, TyDefId,\n     ValueTyDefId,\n@@ -38,6 +38,9 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::cycle(crate::mir::mir_body_recover)]\n     fn mir_body(&self, def: DefWithBodyId) -> Result<Arc<MirBody>, MirLowerError>;\n \n+    #[salsa::invoke(crate::mir::borrowck_query)]\n+    fn borrowck(&self, def: DefWithBodyId) -> Result<Arc<BorrowckResult>, MirLowerError>;\n+\n     #[salsa::invoke(crate::lower::ty_query)]\n     #[salsa::cycle(crate::lower::ty_recover)]\n     fn ty(&self, def: TyDefId) -> Binders<Ty>;"}, {"sha": "bd3eccfe43dab6d88df9362dadc46e18b291fa60", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -531,6 +531,7 @@ fn render_const_scalar(\n             hir_def::AdtId::UnionId(u) => write!(f, \"{}\", f.db.union_data(u).name),\n             hir_def::AdtId::EnumId(_) => f.write_str(\"<enum-not-supported>\"),\n         },\n+        chalk_ir::TyKind::FnDef(..) => ty.hir_fmt(f),\n         _ => f.write_str(\"<not-supported>\"),\n     }\n }"}, {"sha": "c18a34a19208ad14058d8c31f1e8725ae5934fb6", "filename": "crates/hir-ty/src/mir.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -1,6 +1,6 @@\n //! MIR definitions and implementation\n \n-use std::iter;\n+use std::{fmt::Display, iter};\n \n use crate::{\n     infer::PointerCast, Const, ConstScalar, InferenceResult, Interner, MemoryMap, Substitution, Ty,\n@@ -14,8 +14,10 @@ use la_arena::{Arena, ArenaMap, Idx, RawIdx};\n \n mod eval;\n mod lower;\n-pub mod borrowck;\n+mod borrowck;\n+mod pretty;\n \n+pub use borrowck::{borrowck_query, BorrowckResult, MutabilityReason};\n pub use eval::{interpret_mir, pad16, Evaluator, MirEvalError};\n pub use lower::{lower_to_mir, mir_body_query, mir_body_recover, MirLowerError};\n use smallvec::{smallvec, SmallVec};\n@@ -32,13 +34,7 @@ fn return_slot() -> LocalId {\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct Local {\n-    pub mutability: Mutability,\n-    //pub local_info: Option<Box<LocalInfo>>,\n-    //pub internal: bool,\n-    //pub is_block_tail: Option<BlockTailInfo>,\n     pub ty: Ty,\n-    //pub user_ty: Option<Box<UserTypeProjections>>,\n-    //pub source_info: SourceInfo,\n }\n \n /// An operand in MIR represents a \"value\" in Rust, the definition of which is undecided and part of\n@@ -564,6 +560,30 @@ pub enum BinOp {\n     Offset,\n }\n \n+impl Display for BinOp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.write_str(match self {\n+            BinOp::Add => \"+\",\n+            BinOp::Sub => \"-\",\n+            BinOp::Mul => \"*\",\n+            BinOp::Div => \"/\",\n+            BinOp::Rem => \"%\",\n+            BinOp::BitXor => \"^\",\n+            BinOp::BitAnd => \"&\",\n+            BinOp::BitOr => \"|\",\n+            BinOp::Shl => \"<<\",\n+            BinOp::Shr => \">>\",\n+            BinOp::Eq => \"==\",\n+            BinOp::Lt => \"<\",\n+            BinOp::Le => \"<=\",\n+            BinOp::Ne => \"!=\",\n+            BinOp::Ge => \">=\",\n+            BinOp::Gt => \">\",\n+            BinOp::Offset => \"`offset`\",\n+        })\n+    }\n+}\n+\n impl From<hir_def::expr::ArithOp> for BinOp {\n     fn from(value: hir_def::expr::ArithOp) -> Self {\n         match value {\n@@ -822,10 +842,9 @@ pub struct MirBody {\n     pub owner: DefWithBodyId,\n     pub arg_count: usize,\n     pub binding_locals: ArenaMap<BindingId, LocalId>,\n+    pub param_locals: Vec<LocalId>,\n }\n \n-impl MirBody {}\n-\n fn const_as_usize(c: &Const) -> usize {\n     try_const_usize(c).unwrap() as usize\n }"}, {"sha": "7bd0f888b30555539bbe60f30ede41ec117bcb2e", "filename": "crates/hir-ty/src/mir/borrowck.rs", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -1,22 +1,43 @@\n //! MIR borrow checker, which is used in diagnostics like `unused_mut`\n \n // Currently it is an ad-hoc implementation, only useful for mutability analysis. Feel free to remove all of these\n-// and implement a proper borrow checker.\n+// if needed for implementing a proper borrow checker.\n \n+use std::sync::Arc;\n+\n+use hir_def::DefWithBodyId;\n use la_arena::ArenaMap;\n use stdx::never;\n \n+use crate::db::HirDatabase;\n+\n use super::{\n-    BasicBlockId, BorrowKind, LocalId, MirBody, MirSpan, Place, ProjectionElem, Rvalue,\n-    StatementKind, Terminator,\n+    BasicBlockId, BorrowKind, LocalId, MirBody, MirLowerError, MirSpan, Place, ProjectionElem,\n+    Rvalue, StatementKind, Terminator,\n };\n \n-#[derive(Debug)]\n-pub enum Mutability {\n-    Mut { span: MirSpan },\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+/// Stores spans which implies that the local should be mutable.\n+pub enum MutabilityReason {\n+    Mut { spans: Vec<MirSpan> },\n     Not,\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct BorrowckResult {\n+    pub mir_body: Arc<MirBody>,\n+    pub mutability_of_locals: ArenaMap<LocalId, MutabilityReason>,\n+}\n+\n+pub fn borrowck_query(\n+    db: &dyn HirDatabase,\n+    def: DefWithBodyId,\n+) -> Result<Arc<BorrowckResult>, MirLowerError> {\n+    let body = db.mir_body(def)?;\n+    let r = BorrowckResult { mutability_of_locals: mutability_of_locals(&body), mir_body: body };\n+    Ok(Arc::new(r))\n+}\n+\n fn is_place_direct(lvalue: &Place) -> bool {\n     !lvalue.projection.iter().any(|x| *x == ProjectionElem::Deref)\n }\n@@ -116,49 +137,49 @@ fn ever_initialized_map(body: &MirBody) -> ArenaMap<BasicBlockId, ArenaMap<Local\n             }\n         }\n     }\n-    for (b, block) in body.basic_blocks.iter() {\n-        for statement in &block.statements {\n-            if let StatementKind::Assign(p, _) = &statement.kind {\n-                if p.projection.len() == 0 {\n-                    let l = p.local;\n-                    if !result[b].contains_idx(l) {\n-                        result[b].insert(l, false);\n-                        dfs(body, b, l, &mut result);\n-                    }\n-                }\n-            }\n+    for &l in &body.param_locals {\n+        result[body.start_block].insert(l, true);\n+        dfs(body, body.start_block, l, &mut result);\n+    }\n+    for l in body.locals.iter().map(|x| x.0) {\n+        if !result[body.start_block].contains_idx(l) {\n+            result[body.start_block].insert(l, false);\n+            dfs(body, body.start_block, l, &mut result);\n         }\n     }\n     result\n }\n \n-pub fn mutability_of_locals(body: &MirBody) -> ArenaMap<LocalId, Mutability> {\n-    let mut result: ArenaMap<LocalId, Mutability> =\n-        body.locals.iter().map(|x| (x.0, Mutability::Not)).collect();\n+fn mutability_of_locals(body: &MirBody) -> ArenaMap<LocalId, MutabilityReason> {\n+    let mut result: ArenaMap<LocalId, MutabilityReason> =\n+        body.locals.iter().map(|x| (x.0, MutabilityReason::Not)).collect();\n+    let mut push_mut_span = |local, span| match &mut result[local] {\n+        MutabilityReason::Mut { spans } => spans.push(span),\n+        x @ MutabilityReason::Not => *x = MutabilityReason::Mut { spans: vec![span] },\n+    };\n     let ever_init_maps = ever_initialized_map(body);\n-    for (block_id, ever_init_map) in ever_init_maps.iter() {\n-        let mut ever_init_map = ever_init_map.clone();\n+    for (block_id, mut ever_init_map) in ever_init_maps.into_iter() {\n         let block = &body.basic_blocks[block_id];\n         for statement in &block.statements {\n             match &statement.kind {\n                 StatementKind::Assign(place, value) => {\n                     match place_case(place) {\n                         ProjectionCase::Direct => {\n                             if ever_init_map.get(place.local).copied().unwrap_or_default() {\n-                                result[place.local] = Mutability::Mut { span: statement.span };\n+                                push_mut_span(place.local, statement.span);\n                             } else {\n                                 ever_init_map.insert(place.local, true);\n                             }\n                         }\n                         ProjectionCase::DirectPart => {\n                             // Partial initialization is not supported, so it is definitely `mut`\n-                            result[place.local] = Mutability::Mut { span: statement.span };\n+                            push_mut_span(place.local, statement.span);\n                         }\n                         ProjectionCase::Indirect => (),\n                     }\n                     if let Rvalue::Ref(BorrowKind::Mut { .. }, p) = value {\n                         if is_place_direct(p) {\n-                            result[p.local] = Mutability::Mut { span: statement.span };\n+                            push_mut_span(p.local, statement.span);\n                         }\n                     }\n                 }\n@@ -189,7 +210,7 @@ pub fn mutability_of_locals(body: &MirBody) -> ArenaMap<LocalId, Mutability> {\n             Terminator::Call { destination, .. } => {\n                 if destination.projection.len() == 0 {\n                     if ever_init_map.get(destination.local).copied().unwrap_or_default() {\n-                        result[destination.local] = Mutability::Mut { span: MirSpan::Unknown };\n+                        push_mut_span(destination.local, MirSpan::Unknown);\n                     } else {\n                         ever_init_map.insert(destination.local, true);\n                     }"}, {"sha": "e89e16079d66ac2ca43f2d4ee1ee0c6323f6281f", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -16,7 +16,7 @@ use hir_def::{\n use la_arena::ArenaMap;\n \n use crate::{\n-    consteval::ConstEvalError, db::HirDatabase, infer::TypeMismatch,\n+    consteval::ConstEvalError, db::HirDatabase, display::HirDisplay, infer::TypeMismatch,\n     inhabitedness::is_ty_uninhabited_from, layout::layout_of_ty, mapping::ToChalk, utils::generics,\n     Adjust, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n };\n@@ -46,6 +46,7 @@ pub enum MirLowerError {\n     LayoutError(LayoutError),\n     IncompleteExpr,\n     UnresolvedName(String),\n+    RecordLiteralWithoutPath,\n     UnresolvedMethod,\n     UnresolvedField,\n     MissingFunctionDefinition,\n@@ -88,7 +89,7 @@ impl MirLowerCtx<'_> {\n         if matches!(ty.kind(Interner), TyKind::Slice(_) | TyKind::Dyn(_)) {\n             not_supported!(\"unsized temporaries\");\n         }\n-        Ok(self.result.locals.alloc(Local { mutability: Mutability::Not, ty }))\n+        Ok(self.result.locals.alloc(Local { ty }))\n     }\n \n     fn lower_expr_as_place(&self, expr_id: ExprId) -> Option<Place> {\n@@ -251,27 +252,37 @@ impl MirLowerCtx<'_> {\n         match &self.body.exprs[expr_id] {\n             Expr::Missing => Err(MirLowerError::IncompleteExpr),\n             Expr::Path(p) => {\n-                let unresolved_name = || MirLowerError::UnresolvedName(\"\".to_string());\n+                let unresolved_name = || MirLowerError::UnresolvedName(p.display(self.db).to_string());\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n                 let pr = resolver\n                     .resolve_path_in_value_ns(self.db.upcast(), p.mod_path())\n                     .ok_or_else(unresolved_name)?;\n                 let pr = match pr {\n                     ResolveValueResult::ValueNs(v) => v,\n                     ResolveValueResult::Partial(..) => {\n-                        return match self\n+                        if let Some(assoc) = self\n                             .infer\n                             .assoc_resolutions_for_expr(expr_id)\n-                            .ok_or_else(unresolved_name)?\n-                            .0\n-                            //.ok_or(ConstEvalError::SemanticError(\"unresolved assoc item\"))?\n                         {\n-                            hir_def::AssocItemId::ConstId(c) => {\n-                                self.lower_const(c, current, place, expr_id.into())?;\n-                                Ok(Some(current))\n-                            },\n-                            _ => return Err(unresolved_name()),\n-                        };\n+                            match assoc.0 {\n+                                hir_def::AssocItemId::ConstId(c) => {\n+                                    self.lower_const(c, current, place, expr_id.into())?;\n+                                    return Ok(Some(current))\n+                                },\n+                                _ => not_supported!(\"associated functions and types\"),\n+                            }\n+                        } else if let Some(variant) = self\n+                            .infer\n+                            .variant_resolution_for_expr(expr_id)\n+                        {\n+                            match variant {\n+                                VariantId::EnumVariantId(e) => ValueNs::EnumVariantId(e),\n+                                VariantId::StructId(s) => ValueNs::StructId(s),\n+                                VariantId::UnionId(_) => return Err(MirLowerError::ImplementationError(\"Union variant as path\")),\n+                            }\n+                        } else {\n+                            return Err(unresolved_name());\n+                        }\n                     }\n                 };\n                 match pr {\n@@ -597,11 +608,14 @@ impl MirLowerCtx<'_> {\n                 Ok(None)\n             }\n             Expr::Yield { .. } => not_supported!(\"yield\"),\n-            Expr::RecordLit { fields, .. } => {\n+            Expr::RecordLit { fields, path, .. } => {\n                 let variant_id = self\n                     .infer\n                     .variant_resolution_for_expr(expr_id)\n-                    .ok_or_else(|| MirLowerError::UnresolvedName(\"\".to_string()))?;\n+                    .ok_or_else(|| match path {\n+                        Some(p) => MirLowerError::UnresolvedName(p.display(self.db).to_string()),\n+                        None => MirLowerError::RecordLiteralWithoutPath,\n+                    })?;\n                 let subst = match self.expr_ty(expr_id).kind(Interner) {\n                     TyKind::Adt(_, s) => s.clone(),\n                     _ => not_supported!(\"Non ADT record literal\"),\n@@ -1437,17 +1451,17 @@ pub fn lower_to_mir(\n         basic_blocks.alloc(BasicBlock { statements: vec![], terminator: None, is_cleanup: false });\n     let mut locals = Arena::new();\n     // 0 is return local\n-    locals.alloc(Local { mutability: Mutability::Mut, ty: infer[root_expr].clone() });\n+    locals.alloc(Local { ty: infer[root_expr].clone() });\n     let mut binding_locals: ArenaMap<BindingId, LocalId> = ArenaMap::new();\n-    let param_locals: ArenaMap<PatId, LocalId> = if let DefWithBodyId::FunctionId(fid) = owner {\n+    // 1 to param_len is for params\n+    let param_locals: Vec<LocalId> = if let DefWithBodyId::FunctionId(fid) = owner {\n         let substs = TyBuilder::placeholder_subst(db, fid);\n         let callable_sig = db.callable_item_signature(fid.into()).substitute(Interner, &substs);\n-        // 1 to param_len is for params\n         body.params\n             .iter()\n             .zip(callable_sig.params().iter())\n             .map(|(&x, ty)| {\n-                let local_id = locals.alloc(Local { mutability: Mutability::Not, ty: ty.clone() });\n+                let local_id = locals.alloc(Local { ty: ty.clone() });\n                 if let Pat::Bind { id, subpat: None } = body[x] {\n                     if matches!(\n                         body.bindings[id].mode,\n@@ -1456,29 +1470,27 @@ pub fn lower_to_mir(\n                         binding_locals.insert(id, local_id);\n                     }\n                 }\n-                (x, local_id)\n+                local_id\n             })\n             .collect()\n     } else {\n         if !body.params.is_empty() {\n             return Err(MirLowerError::TypeError(\"Unexpected parameter for non function body\"));\n         }\n-        ArenaMap::new()\n+        vec![]\n     };\n     // and then rest of bindings\n     for (id, _) in body.bindings.iter() {\n         if !binding_locals.contains_idx(id) {\n-            binding_locals.insert(\n-                id,\n-                locals.alloc(Local { mutability: Mutability::Not, ty: infer[id].clone() }),\n-            );\n+            binding_locals.insert(id, locals.alloc(Local { ty: infer[id].clone() }));\n         }\n     }\n     let mir = MirBody {\n         basic_blocks,\n         locals,\n         start_block,\n         binding_locals,\n+        param_locals,\n         owner,\n         arg_count: body.params.len(),\n     };\n@@ -1492,17 +1504,17 @@ pub fn lower_to_mir(\n         discr_temp: None,\n     };\n     let mut current = start_block;\n-    for &param in &body.params {\n+    for (&param, local) in body.params.iter().zip(ctx.result.param_locals.clone().into_iter()) {\n         if let Pat::Bind { id, .. } = body[param] {\n-            if param_locals[param] == ctx.result.binding_locals[id] {\n+            if local == ctx.result.binding_locals[id] {\n                 continue;\n             }\n         }\n         let r = ctx.pattern_match(\n             current,\n             None,\n-            param_locals[param].into(),\n-            ctx.result.locals[param_locals[param]].ty.clone(),\n+            local.into(),\n+            ctx.result.locals[local].ty.clone(),\n             param,\n             BindingAnnotation::Unannotated,\n         )?;"}, {"sha": "ffc08b7e346c7f1007c15c18f4d28bb720fa0b0b", "filename": "crates/hir-ty/src/mir/pretty.rs", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -0,0 +1,348 @@\n+//! A pretty-printer for MIR.\n+\n+use std::fmt::{Display, Write};\n+\n+use hir_def::{body::Body, expr::BindingId};\n+use hir_expand::name::Name;\n+use la_arena::ArenaMap;\n+\n+use crate::{\n+    db::HirDatabase,\n+    display::HirDisplay,\n+    mir::{PlaceElem, ProjectionElem, StatementKind, Terminator},\n+};\n+\n+use super::{\n+    AggregateKind, BasicBlockId, BorrowKind, LocalId, MirBody, Operand, Place, Rvalue, UnOp,\n+};\n+\n+impl MirBody {\n+    pub fn pretty_print(&self, db: &dyn HirDatabase) -> String {\n+        let hir_body = db.body(self.owner);\n+        let mut ctx = MirPrettyCtx::new(self, &hir_body, db);\n+        ctx.for_body();\n+        ctx.result\n+    }\n+}\n+\n+struct MirPrettyCtx<'a> {\n+    body: &'a MirBody,\n+    hir_body: &'a Body,\n+    db: &'a dyn HirDatabase,\n+    result: String,\n+    ident: String,\n+    local_to_binding: ArenaMap<LocalId, BindingId>,\n+}\n+\n+macro_rules! w {\n+    ($dst:expr, $($arg:tt)*) => {\n+        { let _ = write!($dst, $($arg)*); }\n+    };\n+}\n+\n+macro_rules! wln {\n+    ($dst:expr) => {\n+        { let _ = writeln!($dst); }\n+    };\n+    ($dst:expr, $($arg:tt)*) => {\n+        { let _ = writeln!($dst, $($arg)*); }\n+    };\n+}\n+\n+impl Write for MirPrettyCtx<'_> {\n+    fn write_str(&mut self, s: &str) -> std::fmt::Result {\n+        let mut it = s.split('\\n'); // note: `.lines()` is wrong here\n+        self.write(it.next().unwrap_or_default());\n+        for line in it {\n+            self.write_line();\n+            self.write(line);\n+        }\n+        Ok(())\n+    }\n+}\n+\n+enum LocalName {\n+    Unknown(LocalId),\n+    Binding(Name, LocalId),\n+}\n+\n+impl Display for LocalName {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            LocalName::Unknown(l) => write!(f, \"_{}\", u32::from(l.into_raw())),\n+            LocalName::Binding(n, l) => write!(f, \"{n}_{}\", u32::from(l.into_raw())),\n+        }\n+    }\n+}\n+\n+impl<'a> MirPrettyCtx<'a> {\n+    fn for_body(&mut self) {\n+        self.with_block(|this| {\n+            this.locals();\n+            wln!(this);\n+            this.blocks();\n+        });\n+    }\n+\n+    fn with_block(&mut self, f: impl FnOnce(&mut MirPrettyCtx<'_>)) {\n+        self.ident += \"    \";\n+        wln!(self, \"{{\");\n+        f(self);\n+        for _ in 0..4 {\n+            self.result.pop();\n+            self.ident.pop();\n+        }\n+        wln!(self, \"}}\");\n+    }\n+\n+    fn new(body: &'a MirBody, hir_body: &'a Body, db: &'a dyn HirDatabase) -> Self {\n+        let local_to_binding = body.binding_locals.iter().map(|(x, y)| (*y, x)).collect();\n+        MirPrettyCtx {\n+            body,\n+            db,\n+            result: String::new(),\n+            ident: String::new(),\n+            local_to_binding,\n+            hir_body,\n+        }\n+    }\n+\n+    fn write_line(&mut self) {\n+        self.result.push('\\n');\n+        self.result += &self.ident;\n+    }\n+\n+    fn write(&mut self, line: &str) {\n+        self.result += line;\n+    }\n+\n+    fn locals(&mut self) {\n+        for (id, local) in self.body.locals.iter() {\n+            wln!(self, \"let {}: {};\", self.local_name(id), local.ty.display(self.db));\n+        }\n+    }\n+\n+    fn local_name(&self, local: LocalId) -> LocalName {\n+        match self.local_to_binding.get(local) {\n+            Some(b) => LocalName::Binding(self.hir_body.bindings[*b].name.clone(), local),\n+            None => LocalName::Unknown(local),\n+        }\n+    }\n+\n+    fn basic_block_id(&self, basic_block_id: BasicBlockId) -> String {\n+        format!(\"'bb{}\", u32::from(basic_block_id.into_raw()))\n+    }\n+\n+    fn blocks(&mut self) {\n+        for (id, block) in self.body.basic_blocks.iter() {\n+            wln!(self);\n+            w!(self, \"{}: \", self.basic_block_id(id));\n+            self.with_block(|this| {\n+                for statement in &block.statements {\n+                    match &statement.kind {\n+                        StatementKind::Assign(l, r) => {\n+                            this.place(l);\n+                            w!(this, \" = \");\n+                            this.rvalue(r);\n+                            wln!(this, \";\");\n+                        }\n+                        StatementKind::StorageDead(p) => {\n+                            wln!(this, \"StorageDead({})\", this.local_name(*p));\n+                        }\n+                        StatementKind::StorageLive(p) => {\n+                            wln!(this, \"StorageLive({})\", this.local_name(*p));\n+                        }\n+                        StatementKind::Deinit(p) => {\n+                            w!(this, \"Deinit(\");\n+                            this.place(p);\n+                            wln!(this, \");\");\n+                        }\n+                        StatementKind::Nop => wln!(this, \"Nop;\"),\n+                    }\n+                }\n+                match &block.terminator {\n+                    Some(terminator) => match terminator {\n+                        Terminator::Goto { target } => {\n+                            wln!(this, \"goto 'bb{};\", u32::from(target.into_raw()))\n+                        }\n+                        Terminator::SwitchInt { discr, targets } => {\n+                            w!(this, \"switch \");\n+                            this.operand(discr);\n+                            w!(this, \" \");\n+                            this.with_block(|this| {\n+                                for (c, b) in targets.iter() {\n+                                    wln!(this, \"{c} => {},\", this.basic_block_id(b));\n+                                }\n+                                wln!(this, \"_ => {},\", this.basic_block_id(targets.otherwise()));\n+                            });\n+                        }\n+                        Terminator::Call { func, args, destination, target, .. } => {\n+                            w!(this, \"Call \");\n+                            this.with_block(|this| {\n+                                w!(this, \"func: \");\n+                                this.operand(func);\n+                                wln!(this, \",\");\n+                                w!(this, \"args: [\");\n+                                this.operand_list(args);\n+                                wln!(this, \"],\");\n+                                w!(this, \"destination: \");\n+                                this.place(destination);\n+                                wln!(this, \",\");\n+                                w!(this, \"target: \");\n+                                match target {\n+                                    Some(t) => w!(this, \"{}\", this.basic_block_id(*t)),\n+                                    None => w!(this, \"<unreachable>\"),\n+                                }\n+                                wln!(this, \",\");\n+                            });\n+                        }\n+                        _ => wln!(this, \"{:?};\", terminator),\n+                    },\n+                    None => wln!(this, \"<no-terminator>;\"),\n+                }\n+            })\n+        }\n+    }\n+\n+    fn place(&mut self, p: &Place) {\n+        fn f(this: &mut MirPrettyCtx<'_>, local: LocalId, projections: &[PlaceElem]) {\n+            let Some((last, head)) = projections.split_last() else {\n+                // no projection\n+                w!(this, \"{}\", this.local_name(local));\n+                return;\n+            };\n+            match last {\n+                ProjectionElem::Deref => {\n+                    w!(this, \"(*\");\n+                    f(this, local, head);\n+                    w!(this, \")\");\n+                }\n+                ProjectionElem::Field(field) => {\n+                    let variant_data = field.parent.variant_data(this.db.upcast());\n+                    let name = &variant_data.fields()[field.local_id].name;\n+                    match field.parent {\n+                        hir_def::VariantId::EnumVariantId(e) => {\n+                            w!(this, \"(\");\n+                            f(this, local, head);\n+                            let variant_name =\n+                                &this.db.enum_data(e.parent).variants[e.local_id].name;\n+                            w!(this, \" as {}).{}\", variant_name, name);\n+                        }\n+                        hir_def::VariantId::StructId(_) | hir_def::VariantId::UnionId(_) => {\n+                            f(this, local, head);\n+                            w!(this, \".{name}\");\n+                        }\n+                    }\n+                }\n+                ProjectionElem::TupleField(x) => {\n+                    f(this, local, head);\n+                    w!(this, \".{}\", x);\n+                }\n+                ProjectionElem::Index(l) => {\n+                    f(this, local, head);\n+                    w!(this, \"[{}]\", this.local_name(*l));\n+                }\n+                x => {\n+                    f(this, local, head);\n+                    w!(this, \".{:?}\", x);\n+                }\n+            }\n+        }\n+        f(self, p.local, &p.projection);\n+    }\n+\n+    fn operand(&mut self, r: &Operand) {\n+        match r {\n+            Operand::Copy(p) | Operand::Move(p) => {\n+                // MIR at the time of writing doesn't have difference between move and copy, so we show them\n+                // equally. Feel free to change it.\n+                self.place(p);\n+            }\n+            Operand::Constant(c) => w!(self, \"Const({})\", c.display(self.db)),\n+        }\n+    }\n+\n+    fn rvalue(&mut self, r: &Rvalue) {\n+        match r {\n+            Rvalue::Use(op) => self.operand(op),\n+            Rvalue::Ref(r, p) => {\n+                match r {\n+                    BorrowKind::Shared => w!(self, \"&\"),\n+                    BorrowKind::Shallow => w!(self, \"&shallow \"),\n+                    BorrowKind::Unique => w!(self, \"&uniq \"),\n+                    BorrowKind::Mut { .. } => w!(self, \"&mut \"),\n+                }\n+                self.place(p);\n+            }\n+            Rvalue::Aggregate(AggregateKind::Tuple(_), x) => {\n+                w!(self, \"(\");\n+                self.operand_list(x);\n+                w!(self, \")\");\n+            }\n+            Rvalue::Aggregate(AggregateKind::Array(_), x) => {\n+                w!(self, \"[\");\n+                self.operand_list(x);\n+                w!(self, \"]\");\n+            }\n+            Rvalue::Aggregate(AggregateKind::Adt(_, _), x) => {\n+                w!(self, \"Adt(\");\n+                self.operand_list(x);\n+                w!(self, \")\");\n+            }\n+            Rvalue::Aggregate(AggregateKind::Union(_, _), x) => {\n+                w!(self, \"Union(\");\n+                self.operand_list(x);\n+                w!(self, \")\");\n+            }\n+            Rvalue::Len(p) => {\n+                w!(self, \"Len(\");\n+                self.place(p);\n+                w!(self, \")\");\n+            }\n+            Rvalue::Cast(ck, op, ty) => {\n+                w!(self, \"Discriminant({ck:?}\");\n+                self.operand(op);\n+                w!(self, \"{})\", ty.display(self.db));\n+            }\n+            Rvalue::CheckedBinaryOp(b, o1, o2) => {\n+                self.operand(o1);\n+                w!(self, \" {b} \");\n+                self.operand(o2);\n+            }\n+            Rvalue::UnaryOp(u, o) => {\n+                let u = match u {\n+                    UnOp::Not => \"!\",\n+                    UnOp::Neg => \"-\",\n+                };\n+                w!(self, \"{u} \");\n+                self.operand(o);\n+            }\n+            Rvalue::Discriminant(p) => {\n+                w!(self, \"Discriminant(\");\n+                self.place(p);\n+                w!(self, \")\");\n+            }\n+            Rvalue::ShallowInitBox(op, _) => {\n+                w!(self, \"ShallowInitBox(\");\n+                self.operand(op);\n+                w!(self, \")\");\n+            }\n+            Rvalue::CopyForDeref(p) => {\n+                w!(self, \"CopyForDeref(\");\n+                self.place(p);\n+                w!(self, \")\");\n+            }\n+        }\n+    }\n+\n+    fn operand_list(&mut self, x: &[Operand]) {\n+        let mut it = x.iter();\n+        if let Some(first) = it.next() {\n+            self.operand(first);\n+            for op in it {\n+                w!(self, \", \");\n+                self.operand(op);\n+            }\n+        }\n+    }\n+}"}, {"sha": "e84f5ebb366151a65c3269b3cc84977aec9390f1", "filename": "crates/hir/src/has_source.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fhir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fhir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fhas_source.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -10,8 +10,8 @@ use hir_expand::InFile;\n use syntax::ast;\n \n use crate::{\n-    db::HirDatabase, Adt, Const, Enum, Field, FieldSource, Function, Impl, LifetimeParam, Macro,\n-    Module, Static, Struct, Trait, TraitAlias, TypeAlias, TypeOrConstParam, Union, Variant,\n+    db::HirDatabase, Adt, Const, Enum, Field, FieldSource, Function, Impl, LifetimeParam,\n+    LocalSource, Macro, Module, Static, Struct, Trait, TypeAlias, TraitAlias, TypeOrConstParam, Union, Variant,\n };\n \n pub trait HasSource {\n@@ -178,3 +178,11 @@ impl HasSource for LifetimeParam {\n         Some(child_source.map(|it| it[self.id.local_id].clone()))\n     }\n }\n+\n+impl HasSource for LocalSource {\n+    type Ast = Either<ast::IdentPat, ast::SelfParam>;\n+\n+    fn source(self, _: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n+        Some(self.source)\n+    }\n+}"}, {"sha": "248f4ff85898ca3e8b9f3954ad427c19f8a07b62", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -1327,6 +1327,15 @@ impl DefWithBody {\n         body.pretty_print(db.upcast(), self.id())\n     }\n \n+    /// A textual representation of the MIR of this def's body for debugging purposes.\n+    pub fn debug_mir(self, db: &dyn HirDatabase) -> String {\n+        let body = db.mir_body(self.id());\n+        match body {\n+            Ok(body) => body.pretty_print(db),\n+            Err(e) => format!(\"error:\\n{e:?}\"),\n+        }\n+    }\n+\n     pub fn diagnostics(self, db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>) {\n         let krate = self.module(db).id.krate();\n \n@@ -1502,32 +1511,35 @@ impl DefWithBody {\n \n         let hir_body = db.body(self.into());\n \n-        if let Ok(mir_body) = db.mir_body(self.into()) {\n-            let mol = mir::borrowck::mutability_of_locals(&mir_body);\n+        if let Ok(borrowck_result) = db.borrowck(self.into()) {\n+            let mir_body = &borrowck_result.mir_body;\n+            let mol = &borrowck_result.mutability_of_locals;\n             for (binding_id, _) in hir_body.bindings.iter() {\n                 let need_mut = &mol[mir_body.binding_locals[binding_id]];\n                 let local = Local { parent: self.into(), binding_id };\n                 match (need_mut, local.is_mut(db)) {\n-                    (mir::borrowck::Mutability::Mut { .. }, true)\n-                    | (mir::borrowck::Mutability::Not, false) => (),\n-                    (mir::borrowck::Mutability::Mut { span }, false) => {\n-                        let span: InFile<SyntaxNodePtr> = match span {\n-                            mir::MirSpan::ExprId(e) => match source_map.expr_syntax(*e) {\n-                                Ok(s) => s.map(|x| x.into()),\n-                                Err(_) => continue,\n-                            },\n-                            mir::MirSpan::PatId(p) => match source_map.pat_syntax(*p) {\n-                                Ok(s) => s.map(|x| match x {\n-                                    Either::Left(e) => e.into(),\n-                                    Either::Right(e) => e.into(),\n-                                }),\n-                                Err(_) => continue,\n-                            },\n-                            mir::MirSpan::Unknown => continue,\n-                        };\n-                        acc.push(NeedMut { local, span }.into());\n+                    (mir::MutabilityReason::Mut { .. }, true)\n+                    | (mir::MutabilityReason::Not, false) => (),\n+                    (mir::MutabilityReason::Mut { spans }, false) => {\n+                        for span in spans {\n+                            let span: InFile<SyntaxNodePtr> = match span {\n+                                mir::MirSpan::ExprId(e) => match source_map.expr_syntax(*e) {\n+                                    Ok(s) => s.map(|x| x.into()),\n+                                    Err(_) => continue,\n+                                },\n+                                mir::MirSpan::PatId(p) => match source_map.pat_syntax(*p) {\n+                                    Ok(s) => s.map(|x| match x {\n+                                        Either::Left(e) => e.into(),\n+                                        Either::Right(e) => e.into(),\n+                                    }),\n+                                    Err(_) => continue,\n+                                },\n+                                mir::MirSpan::Unknown => continue,\n+                            };\n+                            acc.push(NeedMut { local, span }.into());\n+                        }\n                     }\n-                    (mir::borrowck::Mutability::Not, true) => acc.push(UnusedMut { local }.into()),\n+                    (mir::MutabilityReason::Not, true) => acc.push(UnusedMut { local }.into()),\n                 }\n             }\n         }\n@@ -2519,6 +2531,10 @@ impl LocalSource {\n         self.source.file_id.original_file(db.upcast())\n     }\n \n+    pub fn name(&self) -> Option<ast::Name> {\n+        self.source.value.name()\n+    }\n+\n     pub fn syntax(&self) -> &SyntaxNode {\n         self.source.value.syntax()\n     }"}, {"sha": "f710211c8cb0f0ed977af7b86d4c5574ed5b57c0", "filename": "crates/ide-db/src/rename.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fide-db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fide-db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Frename.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -121,8 +121,7 @@ impl Definition {\n             Definition::Trait(it) => name_range(it, sema),\n             Definition::TraitAlias(it) => name_range(it, sema),\n             Definition::TypeAlias(it) => name_range(it, sema),\n-            // A local might be `self` or have multiple definitons like `let (a | a) = 2`, so it should be handled as a special case\n-            Definition::Local(_) => return None,\n+            Definition::Local(it) => name_range(it.primary_source(sema.db), sema),\n             Definition::GenericParam(generic_param) => match generic_param {\n                 hir::GenericParam::LifetimeParam(lifetime_param) => {\n                     let src = lifetime_param.source(sema.db)?;"}, {"sha": "4f5d958354d282e772e76f0f05ec665146276320", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 234, "deletions": 23, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -1,31 +1,85 @@\n-use crate::{Diagnostic, DiagnosticsContext, Severity};\n+use ide_db::source_change::SourceChange;\n+use syntax::{AstNode, SyntaxKind, SyntaxNode, SyntaxToken, T};\n+use text_edit::TextEdit;\n+\n+use crate::{fix, Diagnostic, DiagnosticsContext, Severity};\n \n // Diagnostic: need-mut\n //\n // This diagnostic is triggered on mutating an immutable variable.\n pub(crate) fn need_mut(ctx: &DiagnosticsContext<'_>, d: &hir::NeedMut) -> Diagnostic {\n+    let fixes = (|| {\n+        if d.local.is_ref(ctx.sema.db) {\n+            // There is no simple way to add `mut` to `ref x` and `ref mut x`\n+            return None;\n+        }\n+        let file_id = d.span.file_id.file_id()?;\n+        let mut edit_builder = TextEdit::builder();\n+        let use_range = d.span.value.text_range();\n+        for source in d.local.sources(ctx.sema.db) {\n+            let Some(ast) = source.name() else { continue };\n+            edit_builder.insert(ast.syntax().text_range().start(), \"mut \".to_string());\n+        }\n+        let edit = edit_builder.finish();\n+        Some(vec![fix(\n+            \"remove_mut\",\n+            \"Remove unnecessary `mut`\",\n+            SourceChange::from_text_edit(file_id, edit),\n+            use_range,\n+        )])\n+    })();\n     Diagnostic::new(\n         \"need-mut\",\n         format!(\"cannot mutate immutable variable `{}`\", d.local.name(ctx.sema.db)),\n         ctx.sema.diagnostics_display_range(d.span.clone()).range,\n     )\n+    .with_fixes(fixes)\n }\n \n // Diagnostic: unused-mut\n //\n // This diagnostic is triggered when a mutable variable isn't actually mutated.\n pub(crate) fn unused_mut(ctx: &DiagnosticsContext<'_>, d: &hir::UnusedMut) -> Diagnostic {\n+    let ast = d.local.primary_source(ctx.sema.db).syntax_ptr();\n+    let fixes = (|| {\n+        let file_id = ast.file_id.file_id()?;\n+        let mut edit_builder = TextEdit::builder();\n+        let use_range = ast.value.text_range();\n+        for source in d.local.sources(ctx.sema.db) {\n+            let ast = source.syntax();\n+            let Some(mut_token) = token(ast, T![mut]) else { continue };\n+            edit_builder.delete(mut_token.text_range());\n+            if let Some(token) = mut_token.next_token() {\n+                if token.kind() == SyntaxKind::WHITESPACE {\n+                    edit_builder.delete(token.text_range());\n+                }\n+            }\n+        }\n+        let edit = edit_builder.finish();\n+        Some(vec![fix(\n+            \"remove_mut\",\n+            \"Remove unnecessary `mut`\",\n+            SourceChange::from_text_edit(file_id, edit),\n+            use_range,\n+        )])\n+    })();\n+    let ast = d.local.primary_source(ctx.sema.db).syntax_ptr();\n     Diagnostic::new(\n         \"unused-mut\",\n         \"remove this `mut`\",\n-        ctx.sema.diagnostics_display_range(d.local.primary_source(ctx.sema.db).syntax_ptr()).range,\n+        ctx.sema.diagnostics_display_range(ast).range,\n     )\n     .severity(Severity::WeakWarning)\n+    .with_fixes(fixes)\n+}\n+\n+pub(super) fn token(parent: &SyntaxNode, kind: SyntaxKind) -> Option<SyntaxToken> {\n+    parent.children_with_tokens().filter_map(|it| it.into_token()).find(|it| it.kind() == kind)\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::tests::check_diagnostics;\n+    use crate::tests::{check_diagnostics, check_fix};\n \n     #[test]\n     fn unused_mut_simple() {\n@@ -34,7 +88,7 @@ mod tests {\n fn f(_: i32) {}\n fn main() {\n     let mut x = 2;\n-      //^^^^^ weak: remove this `mut`\n+      //^^^^^ \ud83d\udca1 weak: remove this `mut`\n     f(x);\n }\n \"#,\n@@ -64,14 +118,152 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn multiple_errors_for_single_variable() {\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x = 2;\n+    x = 10;\n+  //^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    x = 5;\n+  //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    &mut x;\n+  //^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unused_mut_fix() {\n+        check_fix(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mu$0t x = 2;\n+    f(x);\n+}\n+\"#,\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x = 2;\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_fix(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let ((mu$0t x, _) | (_, mut x)) = (2, 3);\n+    f(x);\n+}\n+\"#,\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let ((x, _) | (_, x)) = (2, 3);\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn need_mut_fix() {\n+        check_fix(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x = 2;\n+    x$0 = 5;\n+    f(x);\n+}\n+\"#,\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x = 2;\n+    x = 5;\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_fix(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let ((x, _) | (_, x)) = (2, 3);\n+    x =$0 4;\n+    f(x);\n+}\n+\"#,\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let ((mut x, _) | (_, mut x)) = (2, 3);\n+    x = 4;\n+    f(x);\n+}\n+\"#,\n+        );\n+\n+        check_fix(\n+            r#\"\n+struct Foo(i32);\n+\n+impl Foo {\n+    fn foo(self) {\n+        self = Fo$0o(5);\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Foo(i32);\n+\n+impl Foo {\n+    fn foo(mut self) {\n+        self = Foo(5);\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn need_mut_fix_not_applicable_on_ref() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let ref x = 2;\n+    x = &5;\n+  //^^^^^^ error: cannot mutate immutable variable `x`\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let ref mut x = 2;\n+    x = &mut 5;\n+  //^^^^^^^^^^ error: cannot mutate immutable variable `x`\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn field_mutate() {\n         check_diagnostics(\n             r#\"\n fn f(_: i32) {}\n fn main() {\n     let mut x = (2, 7);\n-      //^^^^^ weak: remove this `mut`\n+      //^^^^^ \ud83d\udca1 weak: remove this `mut`\n     f(x.1);\n }\n \"#,\n@@ -92,7 +284,7 @@ fn f(_: i32) {}\n fn main() {\n     let x = (2, 7);\n     x.0 = 5;\n-  //^^^^^^^ error: cannot mutate immutable variable `x`\n+  //^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n     f(x.1);\n }\n \"#,\n@@ -105,7 +297,7 @@ fn main() {\n             r#\"\n fn main() {\n     let mut x = &mut 2;\n-      //^^^^^ weak: remove this `mut`\n+      //^^^^^ \ud83d\udca1 weak: remove this `mut`\n     *x = 5;\n }\n \"#,\n@@ -115,7 +307,7 @@ fn main() {\n fn main() {\n     let x = 2;\n     &mut x;\n-  //^^^^^^ error: cannot mutate immutable variable `x`\n+  //^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n }\n \"#,\n         );\n@@ -124,7 +316,7 @@ fn main() {\n fn main() {\n     let x_own = 2;\n     let ref mut x_ref = x_own;\n-      //^^^^^^^^^^^^^ error: cannot mutate immutable variable `x_own`\n+      //^^^^^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x_own`\n }\n \"#,\n         );\n@@ -137,7 +329,7 @@ impl Foo {\n fn main() {\n     let x = Foo;\n     x.method(2);\n-  //^ error: cannot mutate immutable variable `x`\n+  //^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n }\n \"#,\n         );\n@@ -150,9 +342,9 @@ fn main() {\n fn main() {\n     match (2, 3) {\n         (x, mut y) => {\n-          //^^^^^ weak: remove this `mut`\n+          //^^^^^ \ud83d\udca1 weak: remove this `mut`\n             x = 7;\n-          //^^^^^ error: cannot mutate immutable variable `x`\n+          //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n         }\n     }\n }\n@@ -171,7 +363,7 @@ fn main() {\n fn main() {\n     return;\n     let mut x = 2;\n-      //^^^^^ weak: remove this `mut`\n+      //^^^^^ \ud83d\udca1 weak: remove this `mut`\n     &mut x;\n }\n \"#,\n@@ -181,7 +373,7 @@ fn main() {\n fn main() {\n     loop {}\n     let mut x = 2;\n-      //^^^^^ weak: remove this `mut`\n+      //^^^^^ \ud83d\udca1 weak: remove this `mut`\n     &mut x;\n }\n \"#,\n@@ -202,7 +394,7 @@ fn main(b: bool) {\n         g();\n     }\n     let mut x = 2;\n-      //^^^^^ weak: remove this `mut`\n+      //^^^^^ \ud83d\udca1 weak: remove this `mut`\n     &mut x;\n }\n \"#,\n@@ -216,7 +408,7 @@ fn main(b: bool) {\n         return;\n     }\n     let mut x = 2;\n-      //^^^^^ weak: remove this `mut`\n+      //^^^^^ \ud83d\udca1 weak: remove this `mut`\n     &mut x;\n }\n \"#,\n@@ -230,7 +422,7 @@ fn main(b: bool) {\n fn f(_: i32) {}\n fn main() {\n     let mut x;\n-      //^^^^^ weak: remove this `mut`\n+      //^^^^^ \ud83d\udca1 weak: remove this `mut`\n     x = 5;\n     f(x);\n }\n@@ -241,7 +433,7 @@ fn main() {\n fn f(_: i32) {}\n fn main(b: bool) {\n     let mut x;\n-      //^^^^^ weak: remove this `mut`\n+      //^^^^^ \ud83d\udca1 weak: remove this `mut`\n     if b {\n         x = 1;\n     } else {\n@@ -260,7 +452,7 @@ fn main(b: bool) {\n         x = 1;\n     }\n     x = 3;\n-  //^^^^^ error: cannot mutate immutable variable `x`\n+  //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n     f(x);\n }\n \"#,\n@@ -272,7 +464,7 @@ fn main() {\n     let x;\n     loop {\n         x = 1;\n-      //^^^^^ error: cannot mutate immutable variable `x`\n+      //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n         f(x);\n     }\n }\n@@ -284,18 +476,37 @@ fn f(_: i32) {}\n fn main() {\n     loop {\n         let mut x = 1;\n-          //^^^^^ weak: remove this `mut`\n+          //^^^^^ \ud83d\udca1 weak: remove this `mut`\n         f(x);\n         if let mut y = 2 {\n-             //^^^^^ weak: remove this `mut`\n+             //^^^^^ \ud83d\udca1 weak: remove this `mut`\n             f(y);\n         }\n         match 3 {\n             mut z => f(z),\n-          //^^^^^ weak: remove this `mut`\n+          //^^^^^ \ud83d\udca1 weak: remove this `mut`\n         }\n     }\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn function_arguments_are_initialized() {\n+        check_diagnostics(\n+            r#\"\n+fn f(mut x: i32) {\n+   //^^^^^ \ud83d\udca1 weak: remove this `mut`\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(x: i32) {\n+   x = 5;\n+ //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+}\n \"#,\n         );\n     }"}, {"sha": "078b66dd3955f2fd4604ca81dcba912e44bb918f", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -55,6 +55,7 @@ mod syntax_tree;\n mod typing;\n mod view_crate_graph;\n mod view_hir;\n+mod view_mir;\n mod view_item_tree;\n mod shuffle_crate_graph;\n \n@@ -308,6 +309,10 @@ impl Analysis {\n         self.with_db(|db| view_hir::view_hir(db, position))\n     }\n \n+    pub fn view_mir(&self, position: FilePosition) -> Cancellable<String> {\n+        self.with_db(|db| view_mir::view_mir(db, position))\n+    }\n+\n     pub fn view_item_tree(&self, file_id: FileId) -> Cancellable<String> {\n         self.with_db(|db| view_item_tree::view_item_tree(db, file_id))\n     }"}, {"sha": "e10c463810220e4d8970086cf2432dcdd7863d94", "filename": "crates/ide/src/rename.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -353,6 +353,11 @@ mod tests {\n     fn check(new_name: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n         let ra_fixture_after = &trim_indent(ra_fixture_after);\n         let (analysis, position) = fixture::position(ra_fixture_before);\n+        if !ra_fixture_after.starts_with(\"error: \") {\n+            if let Err(err) = analysis.prepare_rename(position).unwrap() {\n+                panic!(\"Prepare rename to '{new_name}' was failed: {err}\")\n+            }\n+        }\n         let rename_result = analysis\n             .rename(position, new_name)\n             .unwrap_or_else(|err| panic!(\"Rename to '{new_name}' was cancelled: {err}\"));\n@@ -1709,6 +1714,23 @@ fn foo(bar: i32) -> Foo {\n         );\n     }\n \n+    #[test]\n+    fn test_rename_local_simple() {\n+        check(\n+            \"i\",\n+            r#\"\n+fn foo(bar$0: i32) -> i32 {\n+    bar\n+}\n+\"#,\n+            r#\"\n+fn foo(i: i32) -> i32 {\n+    i\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_rename_local_put_init_shorthand() {\n         cov_mark::check!(test_rename_local_put_init_shorthand);"}, {"sha": "a36aba58bc0ed81e9a89a30578acf31fac4ee473", "filename": "crates/ide/src/view_mir.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fide%2Fsrc%2Fview_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fide%2Fsrc%2Fview_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fview_mir.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -0,0 +1,29 @@\n+use hir::{DefWithBody, Semantics};\n+use ide_db::base_db::FilePosition;\n+use ide_db::RootDatabase;\n+use syntax::{algo::find_node_at_offset, ast, AstNode};\n+\n+// Feature: View Mir\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **rust-analyzer: View Mir**\n+// |===\n+pub(crate) fn view_mir(db: &RootDatabase, position: FilePosition) -> String {\n+    body_mir(db, position).unwrap_or_else(|| \"Not inside a function body\".to_string())\n+}\n+\n+fn body_mir(db: &RootDatabase, position: FilePosition) -> Option<String> {\n+    let sema = Semantics::new(db);\n+    let source_file = sema.parse(position.file_id);\n+\n+    let item = find_node_at_offset::<ast::Item>(source_file.syntax(), position.offset)?;\n+    let def: DefWithBody = match item {\n+        ast::Item::Fn(it) => sema.to_def(&it)?.into(),\n+        ast::Item::Const(it) => sema.to_def(&it)?.into(),\n+        ast::Item::Static(it) => sema.to_def(&it)?.into(),\n+        _ => return None,\n+    };\n+    Some(def.debug_mir(db))\n+}"}, {"sha": "32ac9a42dec33c99ca4905b94a3ccd9e4458868f", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -134,6 +134,16 @@ pub(crate) fn handle_view_hir(\n     Ok(res)\n }\n \n+pub(crate) fn handle_view_mir(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::TextDocumentPositionParams,\n+) -> Result<String> {\n+    let _p = profile::span(\"handle_view_mir\");\n+    let position = from_proto::file_position(&snap, params)?;\n+    let res = snap.analysis.view_mir(position)?;\n+    Ok(res)\n+}\n+\n pub(crate) fn handle_view_file_text(\n     snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentIdentifier,"}, {"sha": "c7b513db981ea1607d23ae3ce9e8e54190fdb0b0", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -74,6 +74,14 @@ impl Request for ViewHir {\n     const METHOD: &'static str = \"rust-analyzer/viewHir\";\n }\n \n+pub enum ViewMir {}\n+\n+impl Request for ViewMir {\n+    type Params = lsp_types::TextDocumentPositionParams;\n+    type Result = String;\n+    const METHOD: &'static str = \"rust-analyzer/viewMir\";\n+}\n+\n pub enum ViewFileText {}\n \n impl Request for ViewFileText {"}, {"sha": "d2797690669a36bf95b05ad4dec710207381e446", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -634,6 +634,7 @@ impl GlobalState {\n             .on::<lsp_ext::AnalyzerStatus>(handlers::handle_analyzer_status)\n             .on::<lsp_ext::SyntaxTree>(handlers::handle_syntax_tree)\n             .on::<lsp_ext::ViewHir>(handlers::handle_view_hir)\n+            .on::<lsp_ext::ViewMir>(handlers::handle_view_mir)\n             .on::<lsp_ext::ViewFileText>(handlers::handle_view_file_text)\n             .on::<lsp_ext::ViewCrateGraph>(handlers::handle_view_crate_graph)\n             .on::<lsp_ext::ViewItemTree>(handlers::handle_view_item_tree)"}, {"sha": "3e43df2d0d52b57f5024c1133e71fd5ecb63187b", "filename": "crates/syntax/src/ast/traits.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -134,3 +134,5 @@ impl Iterator for AttrDocCommentIter {\n         })\n     }\n }\n+\n+impl<A: HasName, B: HasName> HasName for Either<A, B> {}"}, {"sha": "de1422032088f536ff065d068cd2a62a59dd9aad", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -1,5 +1,5 @@\n <!---\n-lsp_ext.rs hash: d87477896dfe41d4\n+lsp_ext.rs hash: 37f31ae648632897\n \n If you need to change the above hash to make the test pass, please check if you\n need to adjust this doc as well and ping this issue:\n@@ -527,6 +527,17 @@ Primarily for debugging, but very useful for all people working on rust-analyzer\n Returns a textual representation of the HIR of the function containing the cursor.\n For debugging or when working on rust-analyzer itself.\n \n+## View Mir\n+\n+**Method:** `rust-analyzer/viewMir`\n+\n+**Request:** `TextDocumentPositionParams`\n+\n+**Response:** `string`\n+\n+Returns a textual representation of the MIR of the function containing the cursor.\n+For debugging or when working on rust-analyzer itself.\n+\n ## View File Text\n \n **Method:** `rust-analyzer/viewFileText`"}, {"sha": "90f7b9074c858a55d3a8dc01d85b2e0de7dff1a4", "filename": "editors/code/package.json", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -114,6 +114,11 @@\n                 \"title\": \"View Hir\",\n                 \"category\": \"rust-analyzer (debug command)\"\n             },\n+            {\n+                \"command\": \"rust-analyzer.viewMir\",\n+                \"title\": \"View Mir\",\n+                \"category\": \"rust-analyzer (debug command)\"\n+            },\n             {\n                 \"command\": \"rust-analyzer.viewFileText\",\n                 \"title\": \"View File Text (as seen by the server)\","}, {"sha": "70b91fe7dc87f40bb8c465f618954fcab392193e", "filename": "editors/code/src/commands.ts", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/editors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/editors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands.ts?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -405,12 +405,11 @@ export function syntaxTree(ctx: CtxInit): Cmd {\n     };\n }\n \n-// Opens the virtual file that will show the HIR of the function containing the cursor position\n-//\n-// The contents of the file come from the `TextDocumentContentProvider`\n-export function viewHir(ctx: CtxInit): Cmd {\n+function viewHirOrMir(ctx: CtxInit, xir: \"hir\" | \"mir\"): Cmd {\n+    const viewXir = xir === \"hir\" ? \"viewHir\" : \"viewMir\";\n+    const requestType = xir === \"hir\" ? ra.viewHir : ra.viewMir;\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n-        readonly uri = vscode.Uri.parse(\"rust-analyzer-hir://viewHir/hir.rs\");\n+        readonly uri = vscode.Uri.parse(`rust-analyzer-${xir}://${viewXir}/${xir}.rs`);\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n         constructor() {\n             vscode.workspace.onDidChangeTextDocument(\n@@ -452,7 +451,7 @@ export function viewHir(ctx: CtxInit): Cmd {\n                 ),\n                 position: client.code2ProtocolConverter.asPosition(rustEditor.selection.active),\n             };\n-            return client.sendRequest(ra.viewHir, params, ct);\n+            return client.sendRequest(requestType, params, ct);\n         }\n \n         get onDidChange(): vscode.Event<vscode.Uri> {\n@@ -461,7 +460,7 @@ export function viewHir(ctx: CtxInit): Cmd {\n     })();\n \n     ctx.pushExtCleanup(\n-        vscode.workspace.registerTextDocumentContentProvider(\"rust-analyzer-hir\", tdcp)\n+        vscode.workspace.registerTextDocumentContentProvider(`rust-analyzer-${xir}`, tdcp)\n     );\n \n     return async () => {\n@@ -474,6 +473,20 @@ export function viewHir(ctx: CtxInit): Cmd {\n     };\n }\n \n+// Opens the virtual file that will show the HIR of the function containing the cursor position\n+//\n+// The contents of the file come from the `TextDocumentContentProvider`\n+export function viewHir(ctx: CtxInit): Cmd {\n+    return viewHirOrMir(ctx, \"hir\");\n+}\n+\n+// Opens the virtual file that will show the MIR of the function containing the cursor position\n+//\n+// The contents of the file come from the `TextDocumentContentProvider`\n+export function viewMir(ctx: CtxInit): Cmd {\n+    return viewHirOrMir(ctx, \"mir\");\n+}\n+\n export function viewFileText(ctx: CtxInit): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n         readonly uri = vscode.Uri.parse(\"rust-analyzer-file-text://viewFileText/file.rs\");"}, {"sha": "400cd207d41b0a3a0541ddeaa015bdc1c5e78025", "filename": "editors/code/src/lsp_ext.ts", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -59,6 +59,9 @@ export const viewFileText = new lc.RequestType<lc.TextDocumentIdentifier, string\n export const viewHir = new lc.RequestType<lc.TextDocumentPositionParams, string, void>(\n     \"rust-analyzer/viewHir\"\n );\n+export const viewMir = new lc.RequestType<lc.TextDocumentPositionParams, string, void>(\n+    \"rust-analyzer/viewMir\"\n+);\n export const viewItemTree = new lc.RequestType<ViewItemTreeParams, string, void>(\n     \"rust-analyzer/viewItemTree\"\n );"}, {"sha": "1eb01f30c1e194228e0dc16862a3b9a9c3f147b6", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -158,6 +158,7 @@ function createCommands(): Record<string, CommandFactory> {\n         parentModule: { enabled: commands.parentModule },\n         syntaxTree: { enabled: commands.syntaxTree },\n         viewHir: { enabled: commands.viewHir },\n+        viewMir: { enabled: commands.viewMir },\n         viewFileText: { enabled: commands.viewFileText },\n         viewItemTree: { enabled: commands.viewItemTree },\n         viewCrateGraph: { enabled: commands.viewCrateGraph },"}, {"sha": "7fff2b09c97b5e8effdf0e53ad004e39403e7555", "filename": "lib/la-arena/src/map.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/lib%2Fla-arena%2Fsrc%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac04bfd7a7223cc7077f6745c35f8b655ea13c73/lib%2Fla-arena%2Fsrc%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fla-arena%2Fsrc%2Fmap.rs?ref=ac04bfd7a7223cc7077f6745c35f8b655ea13c73", "patch": "@@ -94,6 +94,12 @@ impl<T, V> ArenaMap<Idx<T>, V> {\n             .filter_map(|(idx, o)| Some((Self::from_idx(idx), o.as_mut()?)))\n     }\n \n+    /// Returns an iterator over the arena indexes and values in the map.\n+    // FIXME: Implement `IntoIterator` trait.\n+    pub fn into_iter(self) -> impl Iterator<Item = (Idx<T>, V)> {\n+        self.v.into_iter().enumerate().filter_map(|(idx, o)| Some((Self::from_idx(idx), o?)))\n+    }\n+\n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n     pub fn entry(&mut self, idx: Idx<T>) -> Entry<'_, Idx<T>, V> {\n         let idx = Self::to_idx(idx);"}]}