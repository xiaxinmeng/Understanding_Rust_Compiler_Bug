{"sha": "1e931918c844e73882bc67ad35ce4314526795d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlOTMxOTE4Yzg0NGU3Mzg4MmJjNjdhZDM1Y2U0MzE0NTI2Nzk1ZDM=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2014-06-05T19:07:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-10T00:46:27Z"}, "message": "Moved integer trait and functions to submodule", "tree": {"sha": "cf14a5426fcd48a7224e4b6dc1307b2aa5be02e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf14a5426fcd48a7224e4b6dc1307b2aa5be02e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e931918c844e73882bc67ad35ce4314526795d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e931918c844e73882bc67ad35ce4314526795d3", "html_url": "https://github.com/rust-lang/rust/commit/1e931918c844e73882bc67ad35ce4314526795d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e931918c844e73882bc67ad35ce4314526795d3/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d42cc130f9eaaa4b35944854c3ba34ae98d6361e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d42cc130f9eaaa4b35944854c3ba34ae98d6361e", "html_url": "https://github.com/rust-lang/rust/commit/d42cc130f9eaaa4b35944854c3ba34ae98d6361e"}], "stats": {"total": 819, "additions": 418, "deletions": 401}, "files": [{"sha": "d958d40d3d114c435179bb67e25741367bbe5d89", "filename": "src/libnum/integer.rs", "status": "added", "additions": 411, "deletions": 0, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/1e931918c844e73882bc67ad35ce4314526795d3/src%2Flibnum%2Finteger.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e931918c844e73882bc67ad35ce4314526795d3/src%2Flibnum%2Finteger.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Finteger.rs?ref=1e931918c844e73882bc67ad35ce4314526795d3", "patch": "@@ -0,0 +1,411 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Integer trait and functions\n+\n+pub trait Integer: Num + PartialOrd\n+                 + Div<Self, Self>\n+                 + Rem<Self, Self> {\n+    /// Simultaneous truncated integer division and modulus\n+    #[inline]\n+    fn div_rem(&self, other: &Self) -> (Self, Self) {\n+        (*self / *other, *self % *other)\n+    }\n+\n+    /// Floored integer division\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// # use num::Integer;\n+    /// assert!(( 8i).div_floor(& 3) ==  2);\n+    /// assert!(( 8i).div_floor(&-3) == -3);\n+    /// assert!((-8i).div_floor(& 3) == -3);\n+    /// assert!((-8i).div_floor(&-3) ==  2);\n+    ///\n+    /// assert!(( 1i).div_floor(& 2) ==  0);\n+    /// assert!(( 1i).div_floor(&-2) == -1);\n+    /// assert!((-1i).div_floor(& 2) == -1);\n+    /// assert!((-1i).div_floor(&-2) ==  0);\n+    /// ~~~\n+    fn div_floor(&self, other: &Self) -> Self;\n+\n+    /// Floored integer modulo, satisfying:\n+    ///\n+    /// ~~~\n+    /// # use num::Integer;\n+    /// # let n = 1i; let d = 1i;\n+    /// assert!(n.div_floor(&d) * d + n.mod_floor(&d) == n)\n+    /// ~~~\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// # use num::Integer;\n+    /// assert!(( 8i).mod_floor(& 3) ==  2);\n+    /// assert!(( 8i).mod_floor(&-3) == -1);\n+    /// assert!((-8i).mod_floor(& 3) ==  1);\n+    /// assert!((-8i).mod_floor(&-3) == -2);\n+    ///\n+    /// assert!(( 1i).mod_floor(& 2) ==  1);\n+    /// assert!(( 1i).mod_floor(&-2) == -1);\n+    /// assert!((-1i).mod_floor(& 2) ==  1);\n+    /// assert!((-1i).mod_floor(&-2) == -1);\n+    /// ~~~\n+    fn mod_floor(&self, other: &Self) -> Self;\n+\n+    /// Simultaneous floored integer division and modulus\n+    fn div_mod_floor(&self, other: &Self) -> (Self, Self) {\n+        (self.div_floor(other), self.mod_floor(other))\n+    }\n+\n+    /// Greatest Common Divisor (GCD)\n+    fn gcd(&self, other: &Self) -> Self;\n+\n+    /// Lowest Common Multiple (LCM)\n+    fn lcm(&self, other: &Self) -> Self;\n+\n+    /// Returns `true` if `other` divides evenly into `self`\n+    fn divides(&self, other: &Self) -> bool;\n+\n+    /// Returns `true` if the number is even\n+    fn is_even(&self) -> bool;\n+\n+    /// Returns `true` if the number is odd\n+    fn is_odd(&self) -> bool;\n+}\n+\n+/// Simultaneous integer division and modulus\n+#[inline] pub fn div_rem<T: Integer>(x: T, y: T) -> (T, T) { x.div_rem(&y) }\n+/// Floored integer division\n+#[inline] pub fn div_floor<T: Integer>(x: T, y: T) -> T { x.div_floor(&y) }\n+/// Floored integer modulus\n+#[inline] pub fn mod_floor<T: Integer>(x: T, y: T) -> T { x.mod_floor(&y) }\n+/// Simultaneous floored integer division and modulus\n+#[inline] pub fn div_mod_floor<T: Integer>(x: T, y: T) -> (T, T) { x.div_mod_floor(&y) }\n+\n+/// Calculates the Greatest Common Divisor (GCD) of the number and `other`. The\n+/// result is always positive.\n+#[inline(always)] pub fn gcd<T: Integer>(x: T, y: T) -> T { x.gcd(&y) }\n+/// Calculates the Lowest Common Multiple (LCM) of the number and `other`.\n+#[inline(always)] pub fn lcm<T: Integer>(x: T, y: T) -> T { x.lcm(&y) }\n+\n+macro_rules! impl_integer_for_int {\n+    ($T:ty, $test_mod:ident) => (\n+        impl Integer for $T {\n+            /// Floored integer division\n+            #[inline]\n+            fn div_floor(&self, other: &$T) -> $T {\n+                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n+                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n+                match self.div_rem(other) {\n+                    (d, r) if (r > 0 && *other < 0)\n+                           || (r < 0 && *other > 0) => d - 1,\n+                    (d, _)                          => d,\n+                }\n+            }\n+\n+            /// Floored integer modulo\n+            #[inline]\n+            fn mod_floor(&self, other: &$T) -> $T {\n+                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n+                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n+                match *self % *other {\n+                    r if (r > 0 && *other < 0)\n+                      || (r < 0 && *other > 0) => r + *other,\n+                    r                          => r,\n+                }\n+            }\n+\n+            /// Calculates `div_floor` and `mod_floor` simultaneously\n+            #[inline]\n+            fn div_mod_floor(&self, other: &$T) -> ($T,$T) {\n+                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n+                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n+                match self.div_rem(other) {\n+                    (d, r) if (r > 0 && *other < 0)\n+                           || (r < 0 && *other > 0) => (d - 1, r + *other),\n+                    (d, r)                          => (d, r),\n+                }\n+            }\n+\n+            /// Calculates the Greatest Common Divisor (GCD) of the number and\n+            /// `other`. The result is always positive.\n+            #[inline]\n+            fn gcd(&self, other: &$T) -> $T {\n+                // Use Euclid's algorithm\n+                let mut m = *self;\n+                let mut n = *other;\n+                while m != 0 {\n+                    let temp = m;\n+                    m = n % temp;\n+                    n = temp;\n+                }\n+                n.abs()\n+            }\n+\n+            /// Calculates the Lowest Common Multiple (LCM) of the number and\n+            /// `other`.\n+            #[inline]\n+            fn lcm(&self, other: &$T) -> $T {\n+                // should not have to recalculate abs\n+                ((*self * *other) / self.gcd(other)).abs()\n+            }\n+\n+            /// Returns `true` if the number can be divided by `other` without\n+            /// leaving a remainder\n+            #[inline]\n+            fn divides(&self, other: &$T) -> bool { *self % *other == 0 }\n+\n+            /// Returns `true` if the number is divisible by `2`\n+            #[inline]\n+            fn is_even(&self) -> bool { self & 1 == 0 }\n+\n+            /// Returns `true` if the number is not divisible by `2`\n+            #[inline]\n+            fn is_odd(&self) -> bool { !self.is_even() }\n+        }\n+\n+        #[cfg(test)]\n+        mod $test_mod {\n+            use Integer;\n+\n+            /// Checks that the division rule holds for:\n+            ///\n+            /// - `n`: numerator (dividend)\n+            /// - `d`: denominator (divisor)\n+            /// - `qr`: quotient and remainder\n+            #[cfg(test)]\n+            fn test_division_rule((n,d): ($T,$T), (q,r): ($T,$T)) {\n+                assert_eq!(d * q + r, n);\n+            }\n+\n+            #[test]\n+            fn test_div_rem() {\n+                fn test_nd_dr(nd: ($T,$T), qr: ($T,$T)) {\n+                    let (n,d) = nd;\n+                    let separate_div_rem = (n / d, n % d);\n+                    let combined_div_rem = n.div_rem(&d);\n+\n+                    assert_eq!(separate_div_rem, qr);\n+                    assert_eq!(combined_div_rem, qr);\n+\n+                    test_division_rule(nd, separate_div_rem);\n+                    test_division_rule(nd, combined_div_rem);\n+                }\n+\n+                test_nd_dr(( 8,  3), ( 2,  2));\n+                test_nd_dr(( 8, -3), (-2,  2));\n+                test_nd_dr((-8,  3), (-2, -2));\n+                test_nd_dr((-8, -3), ( 2, -2));\n+\n+                test_nd_dr(( 1,  2), ( 0,  1));\n+                test_nd_dr(( 1, -2), ( 0,  1));\n+                test_nd_dr((-1,  2), ( 0, -1));\n+                test_nd_dr((-1, -2), ( 0, -1));\n+            }\n+\n+            #[test]\n+            fn test_div_mod_floor() {\n+                fn test_nd_dm(nd: ($T,$T), dm: ($T,$T)) {\n+                    let (n,d) = nd;\n+                    let separate_div_mod_floor = (n.div_floor(&d), n.mod_floor(&d));\n+                    let combined_div_mod_floor = n.div_mod_floor(&d);\n+\n+                    assert_eq!(separate_div_mod_floor, dm);\n+                    assert_eq!(combined_div_mod_floor, dm);\n+\n+                    test_division_rule(nd, separate_div_mod_floor);\n+                    test_division_rule(nd, combined_div_mod_floor);\n+                }\n+\n+                test_nd_dm(( 8,  3), ( 2,  2));\n+                test_nd_dm(( 8, -3), (-3, -1));\n+                test_nd_dm((-8,  3), (-3,  1));\n+                test_nd_dm((-8, -3), ( 2, -2));\n+\n+                test_nd_dm(( 1,  2), ( 0,  1));\n+                test_nd_dm(( 1, -2), (-1, -1));\n+                test_nd_dm((-1,  2), (-1,  1));\n+                test_nd_dm((-1, -2), ( 0, -1));\n+            }\n+\n+            #[test]\n+            fn test_gcd() {\n+                assert_eq!((10 as $T).gcd(&2), 2 as $T);\n+                assert_eq!((10 as $T).gcd(&3), 1 as $T);\n+                assert_eq!((0 as $T).gcd(&3), 3 as $T);\n+                assert_eq!((3 as $T).gcd(&3), 3 as $T);\n+                assert_eq!((56 as $T).gcd(&42), 14 as $T);\n+                assert_eq!((3 as $T).gcd(&-3), 3 as $T);\n+                assert_eq!((-6 as $T).gcd(&3), 3 as $T);\n+                assert_eq!((-4 as $T).gcd(&-2), 2 as $T);\n+            }\n+\n+            #[test]\n+            fn test_lcm() {\n+                assert_eq!((1 as $T).lcm(&0), 0 as $T);\n+                assert_eq!((0 as $T).lcm(&1), 0 as $T);\n+                assert_eq!((1 as $T).lcm(&1), 1 as $T);\n+                assert_eq!((-1 as $T).lcm(&1), 1 as $T);\n+                assert_eq!((1 as $T).lcm(&-1), 1 as $T);\n+                assert_eq!((-1 as $T).lcm(&-1), 1 as $T);\n+                assert_eq!((8 as $T).lcm(&9), 72 as $T);\n+                assert_eq!((11 as $T).lcm(&5), 55 as $T);\n+            }\n+\n+            #[test]\n+            fn test_even() {\n+                assert_eq!((-4 as $T).is_even(), true);\n+                assert_eq!((-3 as $T).is_even(), false);\n+                assert_eq!((-2 as $T).is_even(), true);\n+                assert_eq!((-1 as $T).is_even(), false);\n+                assert_eq!((0 as $T).is_even(), true);\n+                assert_eq!((1 as $T).is_even(), false);\n+                assert_eq!((2 as $T).is_even(), true);\n+                assert_eq!((3 as $T).is_even(), false);\n+                assert_eq!((4 as $T).is_even(), true);\n+            }\n+\n+            #[test]\n+            fn test_odd() {\n+                assert_eq!((-4 as $T).is_odd(), false);\n+                assert_eq!((-3 as $T).is_odd(), true);\n+                assert_eq!((-2 as $T).is_odd(), false);\n+                assert_eq!((-1 as $T).is_odd(), true);\n+                assert_eq!((0 as $T).is_odd(), false);\n+                assert_eq!((1 as $T).is_odd(), true);\n+                assert_eq!((2 as $T).is_odd(), false);\n+                assert_eq!((3 as $T).is_odd(), true);\n+                assert_eq!((4 as $T).is_odd(), false);\n+            }\n+        }\n+    )\n+}\n+\n+impl_integer_for_int!(i8,   test_integer_i8)\n+impl_integer_for_int!(i16,  test_integer_i16)\n+impl_integer_for_int!(i32,  test_integer_i32)\n+impl_integer_for_int!(i64,  test_integer_i64)\n+impl_integer_for_int!(int,  test_integer_int)\n+\n+macro_rules! impl_integer_for_uint {\n+    ($T:ty, $test_mod:ident) => (\n+        impl Integer for $T {\n+            /// Unsigned integer division. Returns the same result as `div` (`/`).\n+            #[inline]\n+            fn div_floor(&self, other: &$T) -> $T { *self / *other }\n+\n+            /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n+            #[inline]\n+            fn mod_floor(&self, other: &$T) -> $T { *self % *other }\n+\n+            /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n+            #[inline]\n+            fn gcd(&self, other: &$T) -> $T {\n+                // Use Euclid's algorithm\n+                let mut m = *self;\n+                let mut n = *other;\n+                while m != 0 {\n+                    let temp = m;\n+                    m = n % temp;\n+                    n = temp;\n+                }\n+                n\n+            }\n+\n+            /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n+            #[inline]\n+            fn lcm(&self, other: &$T) -> $T {\n+                (*self * *other) / self.gcd(other)\n+            }\n+\n+            /// Returns `true` if the number can be divided by `other` without leaving a remainder\n+            #[inline]\n+            fn divides(&self, other: &$T) -> bool { *self % *other == 0 }\n+\n+            /// Returns `true` if the number is divisible by `2`\n+            #[inline]\n+            fn is_even(&self) -> bool { self & 1 == 0 }\n+\n+            /// Returns `true` if the number is not divisible by `2`\n+            #[inline]\n+            fn is_odd(&self) -> bool { !self.is_even() }\n+        }\n+\n+        #[cfg(test)]\n+        mod $test_mod {\n+            use Integer;\n+\n+            #[test]\n+            fn test_div_mod_floor() {\n+                assert_eq!((10 as $T).div_floor(&(3 as $T)), 3 as $T);\n+                assert_eq!((10 as $T).mod_floor(&(3 as $T)), 1 as $T);\n+                assert_eq!((10 as $T).div_mod_floor(&(3 as $T)), (3 as $T, 1 as $T));\n+                assert_eq!((5 as $T).div_floor(&(5 as $T)), 1 as $T);\n+                assert_eq!((5 as $T).mod_floor(&(5 as $T)), 0 as $T);\n+                assert_eq!((5 as $T).div_mod_floor(&(5 as $T)), (1 as $T, 0 as $T));\n+                assert_eq!((3 as $T).div_floor(&(7 as $T)), 0 as $T);\n+                assert_eq!((3 as $T).mod_floor(&(7 as $T)), 3 as $T);\n+                assert_eq!((3 as $T).div_mod_floor(&(7 as $T)), (0 as $T, 3 as $T));\n+            }\n+\n+            #[test]\n+            fn test_gcd() {\n+                assert_eq!((10 as $T).gcd(&2), 2 as $T);\n+                assert_eq!((10 as $T).gcd(&3), 1 as $T);\n+                assert_eq!((0 as $T).gcd(&3), 3 as $T);\n+                assert_eq!((3 as $T).gcd(&3), 3 as $T);\n+                assert_eq!((56 as $T).gcd(&42), 14 as $T);\n+            }\n+\n+            #[test]\n+            fn test_lcm() {\n+                assert_eq!((1 as $T).lcm(&0), 0 as $T);\n+                assert_eq!((0 as $T).lcm(&1), 0 as $T);\n+                assert_eq!((1 as $T).lcm(&1), 1 as $T);\n+                assert_eq!((8 as $T).lcm(&9), 72 as $T);\n+                assert_eq!((11 as $T).lcm(&5), 55 as $T);\n+                assert_eq!((99 as $T).lcm(&17), 1683 as $T);\n+            }\n+\n+            #[test]\n+            fn test_divides() {\n+                assert!((6 as $T).divides(&(6 as $T)));\n+                assert!((6 as $T).divides(&(3 as $T)));\n+                assert!((6 as $T).divides(&(1 as $T)));\n+            }\n+\n+            #[test]\n+            fn test_even() {\n+                assert_eq!((0 as $T).is_even(), true);\n+                assert_eq!((1 as $T).is_even(), false);\n+                assert_eq!((2 as $T).is_even(), true);\n+                assert_eq!((3 as $T).is_even(), false);\n+                assert_eq!((4 as $T).is_even(), true);\n+            }\n+\n+            #[test]\n+            fn test_odd() {\n+                assert_eq!((0 as $T).is_odd(), false);\n+                assert_eq!((1 as $T).is_odd(), true);\n+                assert_eq!((2 as $T).is_odd(), false);\n+                assert_eq!((3 as $T).is_odd(), true);\n+                assert_eq!((4 as $T).is_odd(), false);\n+            }\n+        }\n+    )\n+}\n+\n+impl_integer_for_uint!(u8,   test_integer_u8)\n+impl_integer_for_uint!(u16,  test_integer_u16)\n+impl_integer_for_uint!(u32,  test_integer_u32)\n+impl_integer_for_uint!(u64,  test_integer_u64)\n+impl_integer_for_uint!(uint, test_integer_uint)"}, {"sha": "709882c87cedb970b3be3f693517592507fefd77", "filename": "src/libnum/lib.rs", "status": "modified", "additions": 7, "deletions": 401, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/1e931918c844e73882bc67ad35ce4314526795d3/src%2Flibnum%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e931918c844e73882bc67ad35ce4314526795d3/src%2Flibnum%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Flib.rs?ref=1e931918c844e73882bc67ad35ce4314526795d3", "patch": "@@ -57,406 +57,12 @@\n \n extern crate rand;\n \n+pub use bigint::{BigInt, BigUint};\n+pub use rational::{Rational, BigRational};\n+pub use complex::Complex;\n+pub use integer::Integer;\n+\n pub mod bigint;\n-pub mod rational;\n pub mod complex;\n-\n-pub trait Integer: Num + PartialOrd\n-                 + Div<Self, Self>\n-                 + Rem<Self, Self> {\n-    /// Simultaneous truncated integer division and modulus\n-    #[inline]\n-    fn div_rem(&self, other: &Self) -> (Self, Self) {\n-        (*self / *other, *self % *other)\n-    }\n-\n-    /// Floored integer division\n-    ///\n-    /// # Examples\n-    ///\n-    /// ~~~\n-    /// # use num::Integer;\n-    /// assert!(( 8i).div_floor(& 3) ==  2);\n-    /// assert!(( 8i).div_floor(&-3) == -3);\n-    /// assert!((-8i).div_floor(& 3) == -3);\n-    /// assert!((-8i).div_floor(&-3) ==  2);\n-    ///\n-    /// assert!(( 1i).div_floor(& 2) ==  0);\n-    /// assert!(( 1i).div_floor(&-2) == -1);\n-    /// assert!((-1i).div_floor(& 2) == -1);\n-    /// assert!((-1i).div_floor(&-2) ==  0);\n-    /// ~~~\n-    fn div_floor(&self, other: &Self) -> Self;\n-\n-    /// Floored integer modulo, satisfying:\n-    ///\n-    /// ~~~\n-    /// # use num::Integer;\n-    /// # let n = 1i; let d = 1i;\n-    /// assert!(n.div_floor(&d) * d + n.mod_floor(&d) == n)\n-    /// ~~~\n-    ///\n-    /// # Examples\n-    ///\n-    /// ~~~\n-    /// # use num::Integer;\n-    /// assert!(( 8i).mod_floor(& 3) ==  2);\n-    /// assert!(( 8i).mod_floor(&-3) == -1);\n-    /// assert!((-8i).mod_floor(& 3) ==  1);\n-    /// assert!((-8i).mod_floor(&-3) == -2);\n-    ///\n-    /// assert!(( 1i).mod_floor(& 2) ==  1);\n-    /// assert!(( 1i).mod_floor(&-2) == -1);\n-    /// assert!((-1i).mod_floor(& 2) ==  1);\n-    /// assert!((-1i).mod_floor(&-2) == -1);\n-    /// ~~~\n-    fn mod_floor(&self, other: &Self) -> Self;\n-\n-    /// Simultaneous floored integer division and modulus\n-    fn div_mod_floor(&self, other: &Self) -> (Self, Self) {\n-        (self.div_floor(other), self.mod_floor(other))\n-    }\n-\n-    /// Greatest Common Divisor (GCD)\n-    fn gcd(&self, other: &Self) -> Self;\n-\n-    /// Lowest Common Multiple (LCM)\n-    fn lcm(&self, other: &Self) -> Self;\n-\n-    /// Returns `true` if `other` divides evenly into `self`\n-    fn divides(&self, other: &Self) -> bool;\n-\n-    /// Returns `true` if the number is even\n-    fn is_even(&self) -> bool;\n-\n-    /// Returns `true` if the number is odd\n-    fn is_odd(&self) -> bool;\n-}\n-\n-/// Simultaneous integer division and modulus\n-#[inline] pub fn div_rem<T: Integer>(x: T, y: T) -> (T, T) { x.div_rem(&y) }\n-/// Floored integer division\n-#[inline] pub fn div_floor<T: Integer>(x: T, y: T) -> T { x.div_floor(&y) }\n-/// Floored integer modulus\n-#[inline] pub fn mod_floor<T: Integer>(x: T, y: T) -> T { x.mod_floor(&y) }\n-/// Simultaneous floored integer division and modulus\n-#[inline] pub fn div_mod_floor<T: Integer>(x: T, y: T) -> (T, T) { x.div_mod_floor(&y) }\n-\n-/// Calculates the Greatest Common Divisor (GCD) of the number and `other`. The\n-/// result is always positive.\n-#[inline(always)] pub fn gcd<T: Integer>(x: T, y: T) -> T { x.gcd(&y) }\n-/// Calculates the Lowest Common Multiple (LCM) of the number and `other`.\n-#[inline(always)] pub fn lcm<T: Integer>(x: T, y: T) -> T { x.lcm(&y) }\n-\n-macro_rules! impl_integer_for_int {\n-    ($T:ty, $test_mod:ident) => (\n-        impl Integer for $T {\n-            /// Floored integer division\n-            #[inline]\n-            fn div_floor(&self, other: &$T) -> $T {\n-                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n-                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-                match self.div_rem(other) {\n-                    (d, r) if (r > 0 && *other < 0)\n-                           || (r < 0 && *other > 0) => d - 1,\n-                    (d, _)                          => d,\n-                }\n-            }\n-\n-            /// Floored integer modulo\n-            #[inline]\n-            fn mod_floor(&self, other: &$T) -> $T {\n-                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n-                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-                match *self % *other {\n-                    r if (r > 0 && *other < 0)\n-                      || (r < 0 && *other > 0) => r + *other,\n-                    r                          => r,\n-                }\n-            }\n-\n-            /// Calculates `div_floor` and `mod_floor` simultaneously\n-            #[inline]\n-            fn div_mod_floor(&self, other: &$T) -> ($T,$T) {\n-                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n-                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-                match self.div_rem(other) {\n-                    (d, r) if (r > 0 && *other < 0)\n-                           || (r < 0 && *other > 0) => (d - 1, r + *other),\n-                    (d, r)                          => (d, r),\n-                }\n-            }\n-\n-            /// Calculates the Greatest Common Divisor (GCD) of the number and\n-            /// `other`. The result is always positive.\n-            #[inline]\n-            fn gcd(&self, other: &$T) -> $T {\n-                // Use Euclid's algorithm\n-                let mut m = *self;\n-                let mut n = *other;\n-                while m != 0 {\n-                    let temp = m;\n-                    m = n % temp;\n-                    n = temp;\n-                }\n-                n.abs()\n-            }\n-\n-            /// Calculates the Lowest Common Multiple (LCM) of the number and\n-            /// `other`.\n-            #[inline]\n-            fn lcm(&self, other: &$T) -> $T {\n-                // should not have to recalculate abs\n-                ((*self * *other) / self.gcd(other)).abs()\n-            }\n-\n-            /// Returns `true` if the number can be divided by `other` without\n-            /// leaving a remainder\n-            #[inline]\n-            fn divides(&self, other: &$T) -> bool { *self % *other == 0 }\n-\n-            /// Returns `true` if the number is divisible by `2`\n-            #[inline]\n-            fn is_even(&self) -> bool { self & 1 == 0 }\n-\n-            /// Returns `true` if the number is not divisible by `2`\n-            #[inline]\n-            fn is_odd(&self) -> bool { !self.is_even() }\n-        }\n-\n-        #[cfg(test)]\n-        mod $test_mod {\n-            use Integer;\n-\n-            /// Checks that the division rule holds for:\n-            ///\n-            /// - `n`: numerator (dividend)\n-            /// - `d`: denominator (divisor)\n-            /// - `qr`: quotient and remainder\n-            #[cfg(test)]\n-            fn test_division_rule((n,d): ($T,$T), (q,r): ($T,$T)) {\n-                assert_eq!(d * q + r, n);\n-            }\n-\n-            #[test]\n-            fn test_div_rem() {\n-                fn test_nd_dr(nd: ($T,$T), qr: ($T,$T)) {\n-                    let (n,d) = nd;\n-                    let separate_div_rem = (n / d, n % d);\n-                    let combined_div_rem = n.div_rem(&d);\n-\n-                    assert_eq!(separate_div_rem, qr);\n-                    assert_eq!(combined_div_rem, qr);\n-\n-                    test_division_rule(nd, separate_div_rem);\n-                    test_division_rule(nd, combined_div_rem);\n-                }\n-\n-                test_nd_dr(( 8,  3), ( 2,  2));\n-                test_nd_dr(( 8, -3), (-2,  2));\n-                test_nd_dr((-8,  3), (-2, -2));\n-                test_nd_dr((-8, -3), ( 2, -2));\n-\n-                test_nd_dr(( 1,  2), ( 0,  1));\n-                test_nd_dr(( 1, -2), ( 0,  1));\n-                test_nd_dr((-1,  2), ( 0, -1));\n-                test_nd_dr((-1, -2), ( 0, -1));\n-            }\n-\n-            #[test]\n-            fn test_div_mod_floor() {\n-                fn test_nd_dm(nd: ($T,$T), dm: ($T,$T)) {\n-                    let (n,d) = nd;\n-                    let separate_div_mod_floor = (n.div_floor(&d), n.mod_floor(&d));\n-                    let combined_div_mod_floor = n.div_mod_floor(&d);\n-\n-                    assert_eq!(separate_div_mod_floor, dm);\n-                    assert_eq!(combined_div_mod_floor, dm);\n-\n-                    test_division_rule(nd, separate_div_mod_floor);\n-                    test_division_rule(nd, combined_div_mod_floor);\n-                }\n-\n-                test_nd_dm(( 8,  3), ( 2,  2));\n-                test_nd_dm(( 8, -3), (-3, -1));\n-                test_nd_dm((-8,  3), (-3,  1));\n-                test_nd_dm((-8, -3), ( 2, -2));\n-\n-                test_nd_dm(( 1,  2), ( 0,  1));\n-                test_nd_dm(( 1, -2), (-1, -1));\n-                test_nd_dm((-1,  2), (-1,  1));\n-                test_nd_dm((-1, -2), ( 0, -1));\n-            }\n-\n-            #[test]\n-            fn test_gcd() {\n-                assert_eq!((10 as $T).gcd(&2), 2 as $T);\n-                assert_eq!((10 as $T).gcd(&3), 1 as $T);\n-                assert_eq!((0 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((3 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((56 as $T).gcd(&42), 14 as $T);\n-                assert_eq!((3 as $T).gcd(&-3), 3 as $T);\n-                assert_eq!((-6 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((-4 as $T).gcd(&-2), 2 as $T);\n-            }\n-\n-            #[test]\n-            fn test_lcm() {\n-                assert_eq!((1 as $T).lcm(&0), 0 as $T);\n-                assert_eq!((0 as $T).lcm(&1), 0 as $T);\n-                assert_eq!((1 as $T).lcm(&1), 1 as $T);\n-                assert_eq!((-1 as $T).lcm(&1), 1 as $T);\n-                assert_eq!((1 as $T).lcm(&-1), 1 as $T);\n-                assert_eq!((-1 as $T).lcm(&-1), 1 as $T);\n-                assert_eq!((8 as $T).lcm(&9), 72 as $T);\n-                assert_eq!((11 as $T).lcm(&5), 55 as $T);\n-            }\n-\n-            #[test]\n-            fn test_even() {\n-                assert_eq!((-4 as $T).is_even(), true);\n-                assert_eq!((-3 as $T).is_even(), false);\n-                assert_eq!((-2 as $T).is_even(), true);\n-                assert_eq!((-1 as $T).is_even(), false);\n-                assert_eq!((0 as $T).is_even(), true);\n-                assert_eq!((1 as $T).is_even(), false);\n-                assert_eq!((2 as $T).is_even(), true);\n-                assert_eq!((3 as $T).is_even(), false);\n-                assert_eq!((4 as $T).is_even(), true);\n-            }\n-\n-            #[test]\n-            fn test_odd() {\n-                assert_eq!((-4 as $T).is_odd(), false);\n-                assert_eq!((-3 as $T).is_odd(), true);\n-                assert_eq!((-2 as $T).is_odd(), false);\n-                assert_eq!((-1 as $T).is_odd(), true);\n-                assert_eq!((0 as $T).is_odd(), false);\n-                assert_eq!((1 as $T).is_odd(), true);\n-                assert_eq!((2 as $T).is_odd(), false);\n-                assert_eq!((3 as $T).is_odd(), true);\n-                assert_eq!((4 as $T).is_odd(), false);\n-            }\n-        }\n-    )\n-}\n-\n-impl_integer_for_int!(i8,   test_integer_i8)\n-impl_integer_for_int!(i16,  test_integer_i16)\n-impl_integer_for_int!(i32,  test_integer_i32)\n-impl_integer_for_int!(i64,  test_integer_i64)\n-impl_integer_for_int!(int,  test_integer_int)\n-\n-macro_rules! impl_integer_for_uint {\n-    ($T:ty, $test_mod:ident) => (\n-        impl Integer for $T {\n-            /// Unsigned integer division. Returns the same result as `div` (`/`).\n-            #[inline]\n-            fn div_floor(&self, other: &$T) -> $T { *self / *other }\n-\n-            /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n-            #[inline]\n-            fn mod_floor(&self, other: &$T) -> $T { *self % *other }\n-\n-            /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n-            #[inline]\n-            fn gcd(&self, other: &$T) -> $T {\n-                // Use Euclid's algorithm\n-                let mut m = *self;\n-                let mut n = *other;\n-                while m != 0 {\n-                    let temp = m;\n-                    m = n % temp;\n-                    n = temp;\n-                }\n-                n\n-            }\n-\n-            /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n-            #[inline]\n-            fn lcm(&self, other: &$T) -> $T {\n-                (*self * *other) / self.gcd(other)\n-            }\n-\n-            /// Returns `true` if the number can be divided by `other` without leaving a remainder\n-            #[inline]\n-            fn divides(&self, other: &$T) -> bool { *self % *other == 0 }\n-\n-            /// Returns `true` if the number is divisible by `2`\n-            #[inline]\n-            fn is_even(&self) -> bool { self & 1 == 0 }\n-\n-            /// Returns `true` if the number is not divisible by `2`\n-            #[inline]\n-            fn is_odd(&self) -> bool { !self.is_even() }\n-        }\n-\n-        #[cfg(test)]\n-        mod $test_mod {\n-            use Integer;\n-\n-            #[test]\n-            fn test_div_mod_floor() {\n-                assert_eq!((10 as $T).div_floor(&(3 as $T)), 3 as $T);\n-                assert_eq!((10 as $T).mod_floor(&(3 as $T)), 1 as $T);\n-                assert_eq!((10 as $T).div_mod_floor(&(3 as $T)), (3 as $T, 1 as $T));\n-                assert_eq!((5 as $T).div_floor(&(5 as $T)), 1 as $T);\n-                assert_eq!((5 as $T).mod_floor(&(5 as $T)), 0 as $T);\n-                assert_eq!((5 as $T).div_mod_floor(&(5 as $T)), (1 as $T, 0 as $T));\n-                assert_eq!((3 as $T).div_floor(&(7 as $T)), 0 as $T);\n-                assert_eq!((3 as $T).mod_floor(&(7 as $T)), 3 as $T);\n-                assert_eq!((3 as $T).div_mod_floor(&(7 as $T)), (0 as $T, 3 as $T));\n-            }\n-\n-            #[test]\n-            fn test_gcd() {\n-                assert_eq!((10 as $T).gcd(&2), 2 as $T);\n-                assert_eq!((10 as $T).gcd(&3), 1 as $T);\n-                assert_eq!((0 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((3 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((56 as $T).gcd(&42), 14 as $T);\n-            }\n-\n-            #[test]\n-            fn test_lcm() {\n-                assert_eq!((1 as $T).lcm(&0), 0 as $T);\n-                assert_eq!((0 as $T).lcm(&1), 0 as $T);\n-                assert_eq!((1 as $T).lcm(&1), 1 as $T);\n-                assert_eq!((8 as $T).lcm(&9), 72 as $T);\n-                assert_eq!((11 as $T).lcm(&5), 55 as $T);\n-                assert_eq!((99 as $T).lcm(&17), 1683 as $T);\n-            }\n-\n-            #[test]\n-            fn test_divides() {\n-                assert!((6 as $T).divides(&(6 as $T)));\n-                assert!((6 as $T).divides(&(3 as $T)));\n-                assert!((6 as $T).divides(&(1 as $T)));\n-            }\n-\n-            #[test]\n-            fn test_even() {\n-                assert_eq!((0 as $T).is_even(), true);\n-                assert_eq!((1 as $T).is_even(), false);\n-                assert_eq!((2 as $T).is_even(), true);\n-                assert_eq!((3 as $T).is_even(), false);\n-                assert_eq!((4 as $T).is_even(), true);\n-            }\n-\n-            #[test]\n-            fn test_odd() {\n-                assert_eq!((0 as $T).is_odd(), false);\n-                assert_eq!((1 as $T).is_odd(), true);\n-                assert_eq!((2 as $T).is_odd(), false);\n-                assert_eq!((3 as $T).is_odd(), true);\n-                assert_eq!((4 as $T).is_odd(), false);\n-            }\n-        }\n-    )\n-}\n-\n-impl_integer_for_uint!(u8,   test_integer_u8)\n-impl_integer_for_uint!(u16,  test_integer_u16)\n-impl_integer_for_uint!(u32,  test_integer_u32)\n-impl_integer_for_uint!(u64,  test_integer_u64)\n-impl_integer_for_uint!(uint, test_integer_uint)\n+pub mod integer;\n+pub mod rational;"}]}