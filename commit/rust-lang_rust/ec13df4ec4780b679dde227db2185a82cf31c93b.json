{"sha": "ec13df4ec4780b679dde227db2185a82cf31c93b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjMTNkZjRlYzQ3ODBiNjc5ZGRlMjI3ZGIyMTg1YTgyY2YzMWM5M2I=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-19T12:54:21Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-27T09:56:42Z"}, "message": "Add fast futex-based thread parker for Linux.", "tree": {"sha": "d979638c4aea0d94a7fd817af7496d2ba1f3d220", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d979638c4aea0d94a7fd817af7496d2ba1f3d220"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec13df4ec4780b679dde227db2185a82cf31c93b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec13df4ec4780b679dde227db2185a82cf31c93b", "html_url": "https://github.com/rust-lang/rust/commit/ec13df4ec4780b679dde227db2185a82cf31c93b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec13df4ec4780b679dde227db2185a82cf31c93b/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1464fc3a0cb2b8a92c54357fcff7c632b334cb29", "url": "https://api.github.com/repos/rust-lang/rust/commits/1464fc3a0cb2b8a92c54357fcff7c632b334cb29", "html_url": "https://github.com/rust-lang/rust/commit/1464fc3a0cb2b8a92c54357fcff7c632b334cb29"}], "stats": {"total": 354, "additions": 231, "deletions": 123}, "files": [{"sha": "14cfa958e5e534ce7ef371ab194f570a81c6156f", "filename": "library/std/src/thread/parker/generic.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/ec13df4ec4780b679dde227db2185a82cf31c93b/library%2Fstd%2Fsrc%2Fthread%2Fparker%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec13df4ec4780b679dde227db2185a82cf31c93b/library%2Fstd%2Fsrc%2Fthread%2Fparker%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fparker%2Fgeneric.rs?ref=ec13df4ec4780b679dde227db2185a82cf31c93b", "patch": "@@ -0,0 +1,119 @@\n+//! Parker implementaiton based on a Mutex and Condvar.\n+\n+use crate::sync::atomic::AtomicUsize;\n+use crate::sync::atomic::Ordering::SeqCst;\n+use crate::sync::{Condvar, Mutex};\n+use crate::time::Duration;\n+\n+const EMPTY: usize = 0;\n+const PARKED: usize = 1;\n+const NOTIFIED: usize = 2;\n+\n+pub struct Parker {\n+    state: AtomicUsize,\n+    lock: Mutex<()>,\n+    cvar: Condvar,\n+}\n+\n+impl Parker {\n+    pub fn new() -> Self {\n+        Parker { state: AtomicUsize::new(EMPTY), lock: Mutex::new(()), cvar: Condvar::new() }\n+    }\n+\n+    // This implementaiton doesn't require `unsafe`, but other implementations\n+    // may assume this is only called by the thread that owns the Parker.\n+    pub unsafe fn park(&self) {\n+        // If we were previously notified then we consume this notification and\n+        // return quickly.\n+        if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n+            return;\n+        }\n+\n+        // Otherwise we need to coordinate going to sleep\n+        let mut m = self.lock.lock().unwrap();\n+        match self.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n+            Ok(_) => {}\n+            Err(NOTIFIED) => {\n+                // We must read here, even though we know it will be `NOTIFIED`.\n+                // This is because `unpark` may have been called again since we read\n+                // `NOTIFIED` in the `compare_exchange` above. We must perform an\n+                // acquire operation that synchronizes with that `unpark` to observe\n+                // any writes it made before the call to unpark. To do that we must\n+                // read from the write it made to `state`.\n+                let old = self.state.swap(EMPTY, SeqCst);\n+                assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n+                return;\n+            } // should consume this notification, so prohibit spurious wakeups in next park.\n+            Err(_) => panic!(\"inconsistent park state\"),\n+        }\n+        loop {\n+            m = self.cvar.wait(m).unwrap();\n+            match self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst) {\n+                Ok(_) => return, // got a notification\n+                Err(_) => {}     // spurious wakeup, go back to sleep\n+            }\n+        }\n+    }\n+\n+    // This implementaiton doesn't require `unsafe`, but other implementations\n+    // may assume this is only called by the thread that owns the Parker.\n+    pub unsafe fn park_timeout(&self, dur: Duration) {\n+        // Like `park` above we have a fast path for an already-notified thread, and\n+        // afterwards we start coordinating for a sleep.\n+        // return quickly.\n+        if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n+            return;\n+        }\n+        let m = self.lock.lock().unwrap();\n+        match self.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n+            Ok(_) => {}\n+            Err(NOTIFIED) => {\n+                // We must read again here, see `park`.\n+                let old = self.state.swap(EMPTY, SeqCst);\n+                assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n+                return;\n+            } // should consume this notification, so prohibit spurious wakeups in next park.\n+            Err(_) => panic!(\"inconsistent park_timeout state\"),\n+        }\n+\n+        // Wait with a timeout, and if we spuriously wake up or otherwise wake up\n+        // from a notification we just want to unconditionally set the state back to\n+        // empty, either consuming a notification or un-flagging ourselves as\n+        // parked.\n+        let (_m, _result) = self.cvar.wait_timeout(m, dur).unwrap();\n+        match self.state.swap(EMPTY, SeqCst) {\n+            NOTIFIED => {} // got a notification, hurray!\n+            PARKED => {}   // no notification, alas\n+            n => panic!(\"inconsistent park_timeout state: {}\", n),\n+        }\n+    }\n+\n+    pub fn unpark(&self) {\n+        // To ensure the unparked thread will observe any writes we made\n+        // before this call, we must perform a release operation that `park`\n+        // can synchronize with. To do that we must write `NOTIFIED` even if\n+        // `state` is already `NOTIFIED`. That is why this must be a swap\n+        // rather than a compare-and-swap that returns if it reads `NOTIFIED`\n+        // on failure.\n+        match self.state.swap(NOTIFIED, SeqCst) {\n+            EMPTY => return,    // no one was waiting\n+            NOTIFIED => return, // already unparked\n+            PARKED => {}        // gotta go wake someone up\n+            _ => panic!(\"inconsistent state in unpark\"),\n+        }\n+\n+        // There is a period between when the parked thread sets `state` to\n+        // `PARKED` (or last checked `state` in the case of a spurious wake\n+        // up) and when it actually waits on `cvar`. If we were to notify\n+        // during this period it would be ignored and then when the parked\n+        // thread went to sleep it would never wake up. Fortunately, it has\n+        // `lock` locked at this stage so we can acquire `lock` to wait until\n+        // it is ready to receive the notification.\n+        //\n+        // Releasing `lock` before the call to `notify_one` means that when the\n+        // parked thread wakes it doesn't get woken only to have to wait for us\n+        // to release `lock`.\n+        drop(self.lock.lock().unwrap());\n+        self.cvar.notify_one()\n+    }\n+}"}, {"sha": "05142b88c73fa0454682876501bce2b2b6de3acf", "filename": "library/std/src/thread/parker/linux.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/ec13df4ec4780b679dde227db2185a82cf31c93b/library%2Fstd%2Fsrc%2Fthread%2Fparker%2Flinux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec13df4ec4780b679dde227db2185a82cf31c93b/library%2Fstd%2Fsrc%2Fthread%2Fparker%2Flinux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fparker%2Flinux.rs?ref=ec13df4ec4780b679dde227db2185a82cf31c93b", "patch": "@@ -0,0 +1,105 @@\n+use crate::sync::atomic::AtomicI32;\n+use crate::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n+use crate::time::Duration;\n+\n+const PARKED: i32 = -1;\n+const EMPTY: i32 = 0;\n+const NOTIFIED: i32 = 1;\n+\n+pub struct Parker {\n+    state: AtomicI32,\n+}\n+\n+impl Parker {\n+    #[inline]\n+    pub const fn new() -> Self {\n+        Parker { state: AtomicI32::new(EMPTY) }\n+    }\n+\n+    // Assumes this is only called by the thread that owns the Parker,\n+    // which means that `self.state != PARKED`.\n+    pub unsafe fn park(&self) {\n+        // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n+        // first case.\n+        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n+            return;\n+        }\n+        loop {\n+            // Wait for something to happen, assuming it's still set to PARKED.\n+            futex_wait(&self.state, PARKED, None);\n+            // Change NOTIFIED=>EMPTY and return in that case.\n+            if self.state.compare_and_swap(NOTIFIED, EMPTY, Acquire) == NOTIFIED {\n+                return;\n+            } else {\n+                // Spurious wake up. We loop to try again.\n+            }\n+        }\n+    }\n+\n+    // Assumes this is only called by the thread that owns the Parker,\n+    // which means that `self.state != PARKED`.\n+    pub unsafe fn park_timeout(&self, timeout: Duration) {\n+        // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n+        // first case.\n+        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n+            return;\n+        }\n+        // Wait for something to happen, assuming it's still set to PARKED.\n+        futex_wait(&self.state, PARKED, Some(timeout));\n+        // This is not just a store, because we need to establish a\n+        // release-acquire ordering with unpark().\n+        if self.state.swap(EMPTY, Acquire) == NOTIFIED {\n+            // Woke up because of unpark().\n+        } else {\n+            // Timeout or spurious wake up.\n+            // We return either way, because we can't easily tell if it was the\n+            // timeout or not.\n+        }\n+    }\n+\n+    pub fn unpark(&self) {\n+        // Change PARKED=>NOTIFIED, EMPTY=>NOTIFIED, or NOTIFIED=>NOTIFIED, and\n+        // wake the thread in the first case.\n+        //\n+        // Note that even NOTIFIED=>NOTIFIED results in a write. This is on\n+        // purpose, to make sure every unpark() has a release-acquire ordering\n+        // with park().\n+        if self.state.swap(NOTIFIED, Release) == PARKED {\n+            futex_wake(&self.state);\n+        }\n+    }\n+}\n+\n+fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) {\n+    let timespec;\n+    let timespec_ptr = match timeout {\n+        Some(timeout) => {\n+            timespec = libc::timespec {\n+                tv_sec: timeout.as_secs() as _,\n+                tv_nsec: timeout.subsec_nanos() as _,\n+            };\n+            &timespec as *const libc::timespec\n+        }\n+        None => crate::ptr::null(),\n+    };\n+    unsafe {\n+        libc::syscall(\n+            libc::SYS_futex,\n+            futex as *const AtomicI32,\n+            libc::FUTEX_WAIT | libc::FUTEX_PRIVATE_FLAG,\n+            expected,\n+            timespec_ptr,\n+        );\n+    }\n+}\n+\n+fn futex_wake(futex: &AtomicI32) {\n+    unsafe {\n+        libc::syscall(\n+            libc::SYS_futex,\n+            futex as *const AtomicI32,\n+            libc::FUTEX_WAKE | libc::FUTEX_PRIVATE_FLAG,\n+            1,\n+        );\n+    }\n+}"}, {"sha": "4dc5e1aa271eec32fa88ac8f981bb6186a2028e2", "filename": "library/std/src/thread/parker/mod.rs", "status": "modified", "additions": 7, "deletions": 123, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/ec13df4ec4780b679dde227db2185a82cf31c93b/library%2Fstd%2Fsrc%2Fthread%2Fparker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec13df4ec4780b679dde227db2185a82cf31c93b/library%2Fstd%2Fsrc%2Fthread%2Fparker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fparker%2Fmod.rs?ref=ec13df4ec4780b679dde227db2185a82cf31c93b", "patch": "@@ -1,125 +1,9 @@\n-//! Parker implementaiton based on a Mutex and Condvar.\n-//!\n-//! The implementation currently uses the trivial strategy of a Mutex+Condvar\n-//! with wakeup flag, which does not actually allow spurious wakeups. In the\n-//! future, this will be implemented in a more efficient way, perhaps along the lines of\n-//!   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n-//! or futuxes, and in either case may allow spurious wakeups.\n-\n-use crate::sync::atomic::AtomicUsize;\n-use crate::sync::atomic::Ordering::SeqCst;\n-use crate::sync::{Condvar, Mutex};\n-use crate::time::Duration;\n-\n-const EMPTY: usize = 0;\n-const PARKED: usize = 1;\n-const NOTIFIED: usize = 2;\n-\n-pub struct Parker {\n-    state: AtomicUsize,\n-    lock: Mutex<()>,\n-    cvar: Condvar,\n-}\n-\n-impl Parker {\n-    pub fn new() -> Self {\n-        Parker { state: AtomicUsize::new(EMPTY), lock: Mutex::new(()), cvar: Condvar::new() }\n-    }\n-\n-    // This implementaiton doesn't require `unsafe`, but other implementations\n-    // may assume this is only called by the thread that owns the Parker.\n-    pub unsafe fn park(&self) {\n-        // If we were previously notified then we consume this notification and\n-        // return quickly.\n-        if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n-            return;\n-        }\n-\n-        // Otherwise we need to coordinate going to sleep\n-        let mut m = self.lock.lock().unwrap();\n-        match self.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n-            Ok(_) => {}\n-            Err(NOTIFIED) => {\n-                // We must read here, even though we know it will be `NOTIFIED`.\n-                // This is because `unpark` may have been called again since we read\n-                // `NOTIFIED` in the `compare_exchange` above. We must perform an\n-                // acquire operation that synchronizes with that `unpark` to observe\n-                // any writes it made before the call to unpark. To do that we must\n-                // read from the write it made to `state`.\n-                let old = self.state.swap(EMPTY, SeqCst);\n-                assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n-                return;\n-            } // should consume this notification, so prohibit spurious wakeups in next park.\n-            Err(_) => panic!(\"inconsistent park state\"),\n-        }\n-        loop {\n-            m = self.cvar.wait(m).unwrap();\n-            match self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst) {\n-                Ok(_) => return, // got a notification\n-                Err(_) => {}     // spurious wakeup, go back to sleep\n-            }\n-        }\n-    }\n-\n-    // This implementaiton doesn't require `unsafe`, but other implementations\n-    // may assume this is only called by the thread that owns the Parker.\n-    pub unsafe fn park_timeout(&self, dur: Duration) {\n-        // Like `park` above we have a fast path for an already-notified thread, and\n-        // afterwards we start coordinating for a sleep.\n-        // return quickly.\n-        if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n-            return;\n-        }\n-        let m = self.lock.lock().unwrap();\n-        match self.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n-            Ok(_) => {}\n-            Err(NOTIFIED) => {\n-                // We must read again here, see `park`.\n-                let old = self.state.swap(EMPTY, SeqCst);\n-                assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n-                return;\n-            } // should consume this notification, so prohibit spurious wakeups in next park.\n-            Err(_) => panic!(\"inconsistent park_timeout state\"),\n-        }\n-\n-        // Wait with a timeout, and if we spuriously wake up or otherwise wake up\n-        // from a notification we just want to unconditionally set the state back to\n-        // empty, either consuming a notification or un-flagging ourselves as\n-        // parked.\n-        let (_m, _result) = self.cvar.wait_timeout(m, dur).unwrap();\n-        match self.state.swap(EMPTY, SeqCst) {\n-            NOTIFIED => {} // got a notification, hurray!\n-            PARKED => {}   // no notification, alas\n-            n => panic!(\"inconsistent park_timeout state: {}\", n),\n-        }\n-    }\n-\n-    pub fn unpark(&self) {\n-        // To ensure the unparked thread will observe any writes we made\n-        // before this call, we must perform a release operation that `park`\n-        // can synchronize with. To do that we must write `NOTIFIED` even if\n-        // `state` is already `NOTIFIED`. That is why this must be a swap\n-        // rather than a compare-and-swap that returns if it reads `NOTIFIED`\n-        // on failure.\n-        match self.state.swap(NOTIFIED, SeqCst) {\n-            EMPTY => return,    // no one was waiting\n-            NOTIFIED => return, // already unparked\n-            PARKED => {}        // gotta go wake someone up\n-            _ => panic!(\"inconsistent state in unpark\"),\n-        }\n-\n-        // There is a period between when the parked thread sets `state` to\n-        // `PARKED` (or last checked `state` in the case of a spurious wake\n-        // up) and when it actually waits on `cvar`. If we were to notify\n-        // during this period it would be ignored and then when the parked\n-        // thread went to sleep it would never wake up. Fortunately, it has\n-        // `lock` locked at this stage so we can acquire `lock` to wait until\n-        // it is ready to receive the notification.\n-        //\n-        // Releasing `lock` before the call to `notify_one` means that when the\n-        // parked thread wakes it doesn't get woken only to have to wait for us\n-        // to release `lock`.\n-        drop(self.lock.lock().unwrap());\n-        self.cvar.notify_one()\n+cfg_if::cfg_if! {\n+    if #[cfg(any(target_os = \"linux\", target_os = \"android\"))] {\n+        mod linux;\n+        pub use linux::Parker;\n+    } else {\n+        mod generic;\n+        pub use generic::Parker;\n     }\n }"}]}