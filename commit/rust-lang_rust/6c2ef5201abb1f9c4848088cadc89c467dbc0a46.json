{"sha": "6c2ef5201abb1f9c4848088cadc89c467dbc0a46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMmVmNTIwMWFiYjFmOWM0ODQ4MDg4Y2FkYzg5YzQ2N2RiYzBhNDY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-01-26T22:57:30Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-02-02T19:40:42Z"}, "message": "rustbuild: Build jemalloc and libbacktrace only once (take 2)", "tree": {"sha": "9666104df199c9bda2b25f8911d3e75cd8ab9b57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9666104df199c9bda2b25f8911d3e75cd8ab9b57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c2ef5201abb1f9c4848088cadc89c467dbc0a46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c2ef5201abb1f9c4848088cadc89c467dbc0a46", "html_url": "https://github.com/rust-lang/rust/commit/6c2ef5201abb1f9c4848088cadc89c467dbc0a46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c2ef5201abb1f9c4848088cadc89c467dbc0a46/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a2428fc880ba0486f12dd0b59ef6921eb74b9a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a2428fc880ba0486f12dd0b59ef6921eb74b9a4", "html_url": "https://github.com/rust-lang/rust/commit/1a2428fc880ba0486f12dd0b59ef6921eb74b9a4"}], "stats": {"total": 113, "additions": 60, "deletions": 53}, "files": [{"sha": "52944f36996fbb7018aa9021ad9ec470d901785d", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c2ef5201abb1f9c4848088cadc89c467dbc0a46/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2ef5201abb1f9c4848088cadc89c467dbc0a46/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=6c2ef5201abb1f9c4848088cadc89c467dbc0a46", "patch": "@@ -482,7 +482,8 @@ impl Build {\n         //\n         // These variables are primarily all read by\n         // src/bootstrap/bin/{rustc.rs,rustdoc.rs}\n-        cargo.env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n+        cargo.env(\"RUSTBUILD_NATIVE_DIR\", self.native_dir(target))\n+             .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n              .env(\"RUSTC_REAL\", self.compiler_path(compiler))\n              .env(\"RUSTC_STAGE\", stage.to_string())\n              .env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string())\n@@ -746,10 +747,15 @@ impl Build {\n         }\n     }\n \n+    /// Directory for libraries built from C/C++ code and shared between stages.\n+    fn native_dir(&self, target: &str) -> PathBuf {\n+        self.out.join(target).join(\"native\")\n+    }\n+\n     /// Root output directory for rust_test_helpers library compiled for\n     /// `target`\n     fn test_helpers_out(&self, target: &str) -> PathBuf {\n-        self.out.join(target).join(\"rust-test-helpers\")\n+        self.native_dir(target).join(\"rust-test-helpers\")\n     }\n \n     /// Adds the compiler's directory of dynamic libraries to `cmd`'s dynamic"}, {"sha": "7784584baf49db6519c378ed8546e2d7bc3859fa", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6c2ef5201abb1f9c4848088cadc89c467dbc0a46/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2ef5201abb1f9c4848088cadc89c467dbc0a46/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=6c2ef5201abb1f9c4848088cadc89c467dbc0a46", "patch": "@@ -88,6 +88,21 @@ pub fn output(cmd: &mut Command) -> String {\n     String::from_utf8(output.stdout).unwrap()\n }\n \n+pub fn rerun_if_changed_anything_in_dir(dir: &Path) {\n+    let mut stack = dir.read_dir().unwrap()\n+                       .map(|e| e.unwrap())\n+                       .filter(|e| &*e.file_name() != \".git\")\n+                       .collect::<Vec<_>>();\n+    while let Some(entry) = stack.pop() {\n+        let path = entry.path();\n+        if entry.file_type().unwrap().is_dir() {\n+            stack.extend(path.read_dir().unwrap().map(|e| e.unwrap()));\n+        } else {\n+            println!(\"cargo:rerun-if-changed={}\", path.display());\n+        }\n+    }\n+}\n+\n fn fail(s: &str) -> ! {\n     println!(\"\\n\\n{}\\n\\n\", s);\n     std::process::exit(1);"}, {"sha": "e08fc75e9ef6afb658b1a972d5b96784e0f8f4c7", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6c2ef5201abb1f9c4848088cadc89c467dbc0a46/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2ef5201abb1f9c4848088cadc89c467dbc0a46/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=6c2ef5201abb1f9c4848088cadc89c467dbc0a46", "patch": "@@ -13,20 +13,15 @@\n extern crate build_helper;\n extern crate gcc;\n \n-use std::env;\n+use std::{env, fs};\n use std::path::PathBuf;\n use std::process::Command;\n-use build_helper::run;\n+use build_helper::{run, rerun_if_changed_anything_in_dir};\n \n fn main() {\n     println!(\"cargo:rustc-cfg=cargobuild\");\n     println!(\"cargo:rerun-if-changed=build.rs\");\n \n-    let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n-    let host = env::var(\"HOST\").expect(\"HOST was not set\");\n-    let build_dir = PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n-    let src_dir = env::current_dir().unwrap();\n-\n     // FIXME: This is a hack to support building targets that don't\n     // support jemalloc alongside hosts that do. The jemalloc build is\n     // controlled by a feature of the std crate, and if that feature\n@@ -35,6 +30,7 @@ fn main() {\n     // that the feature set used by std is the same across all\n     // targets, which means we have to build the alloc_jemalloc crate\n     // for targets like emscripten, even if we don't use it.\n+    let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n     if target.contains(\"rumprun\") || target.contains(\"bitrig\") || target.contains(\"openbsd\") ||\n        target.contains(\"msvc\") || target.contains(\"emscripten\") || target.contains(\"fuchsia\") ||\n        target.contains(\"redox\") {\n@@ -57,6 +53,28 @@ fn main() {\n         return;\n     }\n \n+    let build_dir = env::var_os(\"RUSTBUILD_NATIVE_DIR\").unwrap_or(env::var_os(\"OUT_DIR\").unwrap());\n+    let build_dir = PathBuf::from(build_dir).join(\"jemalloc\");\n+    let _ = fs::create_dir_all(&build_dir);\n+\n+    if target.contains(\"windows\") {\n+        println!(\"cargo:rustc-link-lib=static=jemalloc\");\n+    } else {\n+        println!(\"cargo:rustc-link-lib=static=jemalloc_pic\");\n+    }\n+    println!(\"cargo:rustc-link-search=native={}/lib\", build_dir.display());\n+    if target.contains(\"android\") {\n+        println!(\"cargo:rustc-link-lib=gcc\");\n+    } else if !target.contains(\"windows\") && !target.contains(\"musl\") {\n+        println!(\"cargo:rustc-link-lib=pthread\");\n+    }\n+    if !cfg!(stage0) {\n+        return\n+    }\n+\n+    let host = env::var(\"HOST\").expect(\"HOST was not set\");\n+    let src_dir = env::current_dir().unwrap().join(\"../jemalloc\");\n+    rerun_if_changed_anything_in_dir(&src_dir);\n     let compiler = gcc::Config::new().get_compiler();\n     // only msvc returns None for ar so unwrap is okay\n     let ar = build_helper::cc2ar(compiler.path(), &target).unwrap();\n@@ -66,23 +84,8 @@ fn main() {\n         .collect::<Vec<_>>()\n         .join(\" \");\n \n-    let mut stack = src_dir.join(\"../jemalloc\")\n-        .read_dir()\n-        .unwrap()\n-        .map(|e| e.unwrap())\n-        .filter(|e| &*e.file_name() != \".git\")\n-        .collect::<Vec<_>>();\n-    while let Some(entry) = stack.pop() {\n-        let path = entry.path();\n-        if entry.file_type().unwrap().is_dir() {\n-            stack.extend(path.read_dir().unwrap().map(|e| e.unwrap()));\n-        } else {\n-            println!(\"cargo:rerun-if-changed={}\", path.display());\n-        }\n-    }\n-\n     let mut cmd = Command::new(\"sh\");\n-    cmd.arg(src_dir.join(\"../jemalloc/configure\")\n+    cmd.arg(src_dir.join(\"configure\")\n                    .to_str()\n                    .unwrap()\n                    .replace(\"C:\\\\\", \"/c/\")\n@@ -158,6 +161,7 @@ fn main() {\n     }\n \n     run(&mut cmd);\n+\n     let mut make = Command::new(build_helper::make(&host));\n     make.current_dir(&build_dir)\n         .arg(\"build_lib_static\");\n@@ -170,18 +174,6 @@ fn main() {\n \n     run(&mut make);\n \n-    if target.contains(\"windows\") {\n-        println!(\"cargo:rustc-link-lib=static=jemalloc\");\n-    } else {\n-        println!(\"cargo:rustc-link-lib=static=jemalloc_pic\");\n-    }\n-    println!(\"cargo:rustc-link-search=native={}/lib\", build_dir.display());\n-    if target.contains(\"android\") {\n-        println!(\"cargo:rustc-link-lib=gcc\");\n-    } else if !target.contains(\"windows\") && !target.contains(\"musl\") {\n-        println!(\"cargo:rustc-link-lib=pthread\");\n-    }\n-\n     // The pthread_atfork symbols is used by jemalloc on android but the really\n     // old android we're building on doesn't have them defined, so just make\n     // sure the symbols are available."}, {"sha": "faff0d1cb47b53ed16ecf3953a6c47450e9dea36", "filename": "src/libstd/build.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6c2ef5201abb1f9c4848088cadc89c467dbc0a46/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2ef5201abb1f9c4848088cadc89c467dbc0a46/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=6c2ef5201abb1f9c4848088cadc89c467dbc0a46", "patch": "@@ -13,11 +13,10 @@\n extern crate gcc;\n extern crate build_helper;\n \n-use std::env;\n+use std::{env, fs};\n use std::path::PathBuf;\n use std::process::Command;\n-\n-use build_helper::run;\n+use build_helper::{run, rerun_if_changed_anything_in_dir};\n \n fn main() {\n     println!(\"cargo:rustc-cfg=cargobuild\");\n@@ -66,24 +65,18 @@ fn main() {\n }\n \n fn build_libbacktrace(host: &str, target: &str) {\n-    let src_dir = env::current_dir().unwrap().join(\"../libbacktrace\");\n-    let build_dir = PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n+    let build_dir = env::var_os(\"RUSTBUILD_NATIVE_DIR\").unwrap_or(env::var_os(\"OUT_DIR\").unwrap());\n+    let build_dir = PathBuf::from(build_dir).join(\"libbacktrace\");\n+    let _ = fs::create_dir_all(&build_dir);\n \n     println!(\"cargo:rustc-link-lib=static=backtrace\");\n     println!(\"cargo:rustc-link-search=native={}/.libs\", build_dir.display());\n-\n-    let mut stack = src_dir.read_dir().unwrap()\n-                           .map(|e| e.unwrap())\n-                           .collect::<Vec<_>>();\n-    while let Some(entry) = stack.pop() {\n-        let path = entry.path();\n-        if entry.file_type().unwrap().is_dir() {\n-            stack.extend(path.read_dir().unwrap().map(|e| e.unwrap()));\n-        } else {\n-            println!(\"cargo:rerun-if-changed={}\", path.display());\n-        }\n+    if !cfg!(stage0) {\n+        return\n     }\n \n+    let src_dir = env::current_dir().unwrap().join(\"../libbacktrace\");\n+    rerun_if_changed_anything_in_dir(&src_dir);\n     let compiler = gcc::Config::new().get_compiler();\n     // only msvc returns None for ar so unwrap is okay\n     let ar = build_helper::cc2ar(compiler.path(), target).unwrap();\n@@ -105,6 +98,7 @@ fn build_libbacktrace(host: &str, target: &str) {\n                 .env(\"AR\", &ar)\n                 .env(\"RANLIB\", format!(\"{} s\", ar.display()))\n                 .env(\"CFLAGS\", cflags));\n+\n     run(Command::new(build_helper::make(host))\n                 .current_dir(&build_dir)\n                 .arg(format!(\"INCDIR={}\", src_dir.display()))"}]}