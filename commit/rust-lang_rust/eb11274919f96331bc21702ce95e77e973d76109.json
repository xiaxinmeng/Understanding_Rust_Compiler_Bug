{"sha": "eb11274919f96331bc21702ce95e77e973d76109", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMTEyNzQ5MTlmOTYzMzFiYzIxNzAyY2U5NWU3N2U5NzNkNzYxMDk=", "commit": {"author": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-06-12T21:15:44Z"}, "committer": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-06-12T21:15:44Z"}, "message": "Removing redundant libuv bindings", "tree": {"sha": "f6c1c6e4e8d1cc4b4d08d8057c1e65fa80fe60e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6c1c6e4e8d1cc4b4d08d8057c1e65fa80fe60e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb11274919f96331bc21702ce95e77e973d76109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb11274919f96331bc21702ce95e77e973d76109", "html_url": "https://github.com/rust-lang/rust/commit/eb11274919f96331bc21702ce95e77e973d76109", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb11274919f96331bc21702ce95e77e973d76109/comments", "author": null, "committer": null, "parents": [{"sha": "84d269592168b2e8ca9784ada5d86ea6cdb9de9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/84d269592168b2e8ca9784ada5d86ea6cdb9de9f", "html_url": "https://github.com/rust-lang/rust/commit/84d269592168b2e8ca9784ada5d86ea6cdb9de9f"}], "stats": {"total": 902, "additions": 0, "deletions": 902}, "files": [{"sha": "24bffd8d1cd2449afbbc3cd5e5dc63883a48721c", "filename": "src/libstd/rt/uvio.rs", "status": "removed", "additions": 0, "deletions": 459, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/84d269592168b2e8ca9784ada5d86ea6cdb9de9f/src%2Flibstd%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84d269592168b2e8ca9784ada5d86ea6cdb9de9f/src%2Flibstd%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuvio.rs?ref=84d269592168b2e8ca9784ada5d86ea6cdb9de9f", "patch": "@@ -1,459 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use option::*;\n-use result::*;\n-\n-use super::io::net::ip::IpAddr;\n-use super::uv::*;\n-use super::rtio::*;\n-use ops::Drop;\n-use old_iter::CopyableIter;\n-use cell::{Cell, empty_cell};\n-use cast::transmute;\n-use super::sched::{Scheduler, local_sched};\n-\n-#[cfg(test)] use container::Container;\n-#[cfg(test)] use uint;\n-#[cfg(test)] use unstable::run_in_bare_thread;\n-#[cfg(test)] use super::test::*;\n-\n-pub struct UvEventLoop {\n-    uvio: UvIoFactory\n-}\n-\n-pub impl UvEventLoop {\n-    fn new() -> UvEventLoop {\n-        UvEventLoop {\n-            uvio: UvIoFactory(Loop::new())\n-        }\n-    }\n-\n-    /// A convenience constructor\n-    fn new_scheduler() -> Scheduler {\n-        Scheduler::new(~UvEventLoop::new())\n-    }\n-}\n-\n-impl Drop for UvEventLoop {\n-    fn finalize(&self) {\n-        // XXX: Need mutable finalizer\n-        let this = unsafe {\n-            transmute::<&UvEventLoop, &mut UvEventLoop>(self)\n-        };\n-        this.uvio.uv_loop().close();\n-    }\n-}\n-\n-impl EventLoop for UvEventLoop {\n-\n-    fn run(&mut self) {\n-        self.uvio.uv_loop().run();\n-    }\n-\n-    fn callback(&mut self, f: ~fn()) {\n-        let mut idle_watcher =  IdleWatcher::new(self.uvio.uv_loop());\n-        do idle_watcher.start |idle_watcher, status| {\n-            assert!(status.is_none());\n-            let mut idle_watcher = idle_watcher;\n-            idle_watcher.stop();\n-            idle_watcher.close();\n-            f();\n-        }\n-    }\n-\n-    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject> {\n-        Some(&mut self.uvio)\n-    }\n-}\n-\n-#[test]\n-fn test_callback_run_once() {\n-    do run_in_bare_thread {\n-        let mut event_loop = UvEventLoop::new();\n-        let mut count = 0;\n-        let count_ptr: *mut int = &mut count;\n-        do event_loop.callback {\n-            unsafe { *count_ptr += 1 }\n-        }\n-        event_loop.run();\n-        assert!(count == 1);\n-    }\n-}\n-\n-pub struct UvIoFactory(Loop);\n-\n-pub impl UvIoFactory {\n-    fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n-        match self { &UvIoFactory(ref mut ptr) => ptr }\n-    }\n-}\n-\n-impl IoFactory for UvIoFactory {\n-    // Connect to an address and return a new stream\n-    // NB: This blocks the task waiting on the connection.\n-    // It would probably be better to return a future\n-    fn connect(&mut self, addr: IpAddr) -> Option<~StreamObject> {\n-        // Create a cell in the task to hold the result. We will fill\n-        // the cell before resuming the task.\n-        let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n-\n-        let scheduler = local_sched::take();\n-        assert!(scheduler.in_task_context());\n-\n-        // Block this task and take ownership, switch to scheduler context\n-        do scheduler.deschedule_running_task_and_then |task| {\n-\n-            rtdebug!(\"connect: entered scheduler context\");\n-            do local_sched::borrow |scheduler| {\n-                assert!(!scheduler.in_task_context());\n-            }\n-            let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n-            let task_cell = Cell(task);\n-\n-            // Wait for a connection\n-            do tcp_watcher.connect(addr) |stream_watcher, status| {\n-                rtdebug!(\"connect: in connect callback\");\n-                let maybe_stream = if status.is_none() {\n-                    rtdebug!(\"status is none\");\n-                    Some(~UvStream(stream_watcher))\n-                } else {\n-                    rtdebug!(\"status is some\");\n-                    stream_watcher.close(||());\n-                    None\n-                };\n-\n-                // Store the stream in the task's stack\n-                unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n-\n-                // Context switch\n-                let scheduler = local_sched::take();\n-                scheduler.resume_task_immediately(task_cell.take());\n-            }\n-        }\n-\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n-    }\n-\n-    fn bind(&mut self, addr: IpAddr) -> Option<~TcpListenerObject> {\n-        let mut watcher = TcpWatcher::new(self.uv_loop());\n-        watcher.bind(addr);\n-        return Some(~UvTcpListener(watcher));\n-    }\n-}\n-\n-pub struct UvTcpListener(TcpWatcher);\n-\n-impl UvTcpListener {\n-    fn watcher(&self) -> TcpWatcher {\n-        match self { &UvTcpListener(w) => w }\n-    }\n-\n-    fn close(&self) {\n-        // XXX: Need to wait until close finishes before returning\n-        self.watcher().as_stream().close(||());\n-    }\n-}\n-\n-impl Drop for UvTcpListener {\n-    fn finalize(&self) {\n-        // XXX: Again, this never gets called. Use .close() instead\n-        //self.watcher().as_stream().close(||());\n-    }\n-}\n-\n-impl TcpListener for UvTcpListener {\n-\n-    fn listen(&mut self) -> Option<~StreamObject> {\n-        rtdebug!(\"entering listen\");\n-        let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n-\n-        let server_tcp_watcher = self.watcher();\n-\n-        let scheduler = local_sched::take();\n-        assert!(scheduler.in_task_context());\n-\n-        do scheduler.deschedule_running_task_and_then |task| {\n-            let task_cell = Cell(task);\n-            let mut server_tcp_watcher = server_tcp_watcher;\n-            do server_tcp_watcher.listen |server_stream_watcher, status| {\n-                let maybe_stream = if status.is_none() {\n-                    let mut server_stream_watcher = server_stream_watcher;\n-                    let mut loop_ = loop_from_watcher(&server_stream_watcher);\n-                    let client_tcp_watcher = TcpWatcher::new(&mut loop_).as_stream();\n-                    // XXX: Needs to be surfaced in interface\n-                    server_stream_watcher.accept(client_tcp_watcher);\n-                    Some(~UvStream::new(client_tcp_watcher))\n-                } else {\n-                    None\n-                };\n-\n-                unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n-\n-                rtdebug!(\"resuming task from listen\");\n-                // Context switch\n-                let scheduler = local_sched::take();\n-                scheduler.resume_task_immediately(task_cell.take());\n-            }\n-        }\n-\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n-    }\n-}\n-\n-pub struct UvStream(StreamWatcher);\n-\n-impl UvStream {\n-    fn new(watcher: StreamWatcher) -> UvStream {\n-        UvStream(watcher)\n-    }\n-\n-    fn watcher(&self) -> StreamWatcher {\n-        match self { &UvStream(w) => w }\n-    }\n-\n-    // XXX: finalize isn't working for ~UvStream???\n-    fn close(&self) {\n-        // XXX: Need to wait until this finishes before returning\n-        self.watcher().close(||());\n-    }\n-}\n-\n-impl Drop for UvStream {\n-    fn finalize(&self) {\n-        rtdebug!(\"closing stream\");\n-        //self.watcher().close(||());\n-    }\n-}\n-\n-impl Stream for UvStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, ()> {\n-        let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Result<uint, ()>> = &result_cell;\n-\n-        let scheduler = local_sched::take();\n-        assert!(scheduler.in_task_context());\n-        let watcher = self.watcher();\n-        let buf_ptr: *&mut [u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |task| {\n-            rtdebug!(\"read: entered scheduler context\");\n-            do local_sched::borrow |scheduler| {\n-                assert!(!scheduler.in_task_context());\n-            }\n-            let mut watcher = watcher;\n-            let task_cell = Cell(task);\n-            // XXX: We shouldn't reallocate these callbacks every\n-            // call to read\n-            let alloc: AllocCallback = |_| unsafe {\n-                slice_to_uv_buf(*buf_ptr)\n-            };\n-            do watcher.read_start(alloc) |watcher, nread, _buf, status| {\n-\n-                // Stop reading so that no read callbacks are\n-                // triggered before the user calls `read` again.\n-                // XXX: Is there a performance impact to calling\n-                // stop here?\n-                let mut watcher = watcher;\n-                watcher.read_stop();\n-\n-                let result = if status.is_none() {\n-                    assert!(nread >= 0);\n-                    Ok(nread as uint)\n-                } else {\n-                    Err(())\n-                };\n-\n-                unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                let scheduler = local_sched::take();\n-                scheduler.resume_task_immediately(task_cell.take());\n-            }\n-        }\n-\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n-    }\n-\n-    fn write(&mut self, buf: &[u8]) -> Result<(), ()> {\n-        let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Result<(), ()>> = &result_cell;\n-        let scheduler = local_sched::take();\n-        assert!(scheduler.in_task_context());\n-        let watcher = self.watcher();\n-        let buf_ptr: *&[u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |task| {\n-            let mut watcher = watcher;\n-            let task_cell = Cell(task);\n-            let buf = unsafe { &*buf_ptr };\n-            // XXX: OMGCOPIES\n-            let buf = buf.to_vec();\n-            do watcher.write(buf) |_watcher, status| {\n-                let result = if status.is_none() {\n-                    Ok(())\n-                } else {\n-                    Err(())\n-                };\n-\n-                unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                let scheduler = local_sched::take();\n-                scheduler.resume_task_immediately(task_cell.take());\n-            }\n-        }\n-\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n-    }\n-}\n-\n-#[test]\n-fn test_simple_io_no_connect() {\n-    do run_in_newsched_task {\n-        let io = unsafe { local_sched::unsafe_borrow_io() };\n-        let addr = next_test_ip4();\n-        let maybe_chan = io.connect(addr);\n-        assert!(maybe_chan.is_none());\n-    }\n-}\n-\n-#[test]\n-fn test_simple_tcp_server_and_client() {\n-    do run_in_newsched_task {\n-        let addr = next_test_ip4();\n-\n-        // Start the server first so it's listening when we connect\n-        do spawntask_immediately {\n-            unsafe {\n-                let io = local_sched::unsafe_borrow_io();\n-                let mut listener = io.bind(addr).unwrap();\n-                let mut stream = listener.listen().unwrap();\n-                let mut buf = [0, .. 2048];\n-                let nread = stream.read(buf).unwrap();\n-                assert!(nread == 8);\n-                for uint::range(0, nread) |i| {\n-                    rtdebug!(\"%u\", buf[i] as uint);\n-                    assert!(buf[i] == i as u8);\n-                }\n-                stream.close();\n-                listener.close();\n-            }\n-        }\n-\n-        do spawntask_immediately {\n-            unsafe {\n-                let io = local_sched::unsafe_borrow_io();\n-                let mut stream = io.connect(addr).unwrap();\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.close();\n-            }\n-        }\n-    }\n-}\n-\n-#[test] #[ignore(reason = \"busted\")]\n-fn test_read_and_block() {\n-    do run_in_newsched_task {\n-        let addr = next_test_ip4();\n-\n-        do spawntask_immediately {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut listener = io.bind(addr).unwrap();\n-            let mut stream = listener.listen().unwrap();\n-            let mut buf = [0, .. 2048];\n-\n-            let expected = 32;\n-            let mut current = 0;\n-            let mut reads = 0;\n-\n-            while current < expected {\n-                let nread = stream.read(buf).unwrap();\n-                for uint::range(0, nread) |i| {\n-                    let val = buf[i] as uint;\n-                    assert!(val == current % 8);\n-                    current += 1;\n-                }\n-                reads += 1;\n-\n-                let scheduler = local_sched::take();\n-                // Yield to the other task in hopes that it\n-                // will trigger a read callback while we are\n-                // not ready for it\n-                do scheduler.deschedule_running_task_and_then |task| {\n-                    let task = Cell(task);\n-                    do local_sched::borrow |scheduler| {\n-                        scheduler.task_queue.push_back(task.take());\n-                    }\n-                }\n-            }\n-\n-            // Make sure we had multiple reads\n-            assert!(reads > 1);\n-\n-            stream.close();\n-            listener.close();\n-        }\n-\n-        do spawntask_immediately {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.connect(addr).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.close();\n-        }\n-\n-    }\n-}\n-\n-#[test]\n-fn test_read_read_read() {\n-    do run_in_newsched_task {\n-        let addr = next_test_ip4();\n-        static MAX: uint = 500000;\n-\n-        do spawntask_immediately {\n-            unsafe {\n-                let io = local_sched::unsafe_borrow_io();\n-                let mut listener = io.bind(addr).unwrap();\n-                let mut stream = listener.listen().unwrap();\n-                let buf = [1, .. 2048];\n-                let mut total_bytes_written = 0;\n-                while total_bytes_written < MAX {\n-                    stream.write(buf);\n-                    total_bytes_written += buf.len();\n-                }\n-                stream.close();\n-                listener.close();\n-            }\n-        }\n-\n-        do spawntask_immediately {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.connect(addr).unwrap();\n-            let mut buf = [0, .. 2048];\n-            let mut total_bytes_read = 0;\n-            while total_bytes_read < MAX {\n-                let nread = stream.read(buf).unwrap();\n-                rtdebug!(\"read %u bytes\", nread as uint);\n-                total_bytes_read += nread;\n-                for uint::range(0, nread) |i| {\n-                    assert!(buf[i] == 1);\n-                }\n-            }\n-            rtdebug!(\"read %u bytes total\", total_bytes_read as uint);\n-            stream.close();\n-        }\n-    }\n-}"}, {"sha": "0d298bde6b50875d04d565f66af17f2670707805", "filename": "src/libstd/rt/uvll.rs", "status": "removed", "additions": 0, "deletions": 443, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/84d269592168b2e8ca9784ada5d86ea6cdb9de9f/src%2Flibstd%2Frt%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84d269592168b2e8ca9784ada5d86ea6cdb9de9f/src%2Flibstd%2Frt%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuvll.rs?ref=84d269592168b2e8ca9784ada5d86ea6cdb9de9f", "patch": "@@ -1,443 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * Low-level bindings to the libuv library.\n- *\n- * This module contains a set of direct, 'bare-metal' wrappers around\n- * the libuv C-API.\n- *\n- * We're not bothering yet to redefine uv's structs as Rust structs\n- * because they are quite large and change often between versions.\n- * The maintenance burden is just too high. Instead we use the uv's\n- * `uv_handle_size` and `uv_req_size` to find the correct size of the\n- * structs and allocate them on the heap. This can be revisited later.\n- *\n- * There are also a collection of helper functions to ease interacting\n- * with the low-level API.\n- *\n- * As new functionality, existant in uv.h, is added to the rust stdlib,\n- * the mappings should be added in this module.\n- */\n-\n-#[allow(non_camel_case_types)]; // C types\n-\n-use libc::{size_t, c_int, c_uint, c_void, c_char, uintptr_t};\n-use libc::{malloc, free};\n-use prelude::*;\n-\n-pub struct uv_err_t {\n-    code: c_int,\n-    sys_errno_: c_int\n-}\n-\n-pub struct uv_buf_t {\n-    base: *u8,\n-    len: libc::size_t,\n-}\n-\n-pub type uv_handle_t = c_void;\n-pub type uv_loop_t = c_void;\n-pub type uv_idle_t = c_void;\n-pub type uv_tcp_t = c_void;\n-pub type uv_connect_t = c_void;\n-pub type uv_write_t = c_void;\n-pub type uv_async_t = c_void;\n-pub type uv_timer_t = c_void;\n-pub type uv_stream_t = c_void;\n-pub type uv_fs_t = c_void;\n-\n-pub type uv_idle_cb = *u8;\n-\n-pub type sockaddr_in = c_void;\n-pub type sockaddr_in6 = c_void;\n-\n-#[deriving(Eq)]\n-pub enum uv_handle_type {\n-    UV_UNKNOWN_HANDLE,\n-    UV_ASYNC,\n-    UV_CHECK,\n-    UV_FS_EVENT,\n-    UV_FS_POLL,\n-    UV_HANDLE,\n-    UV_IDLE,\n-    UV_NAMED_PIPE,\n-    UV_POLL,\n-    UV_PREPARE,\n-    UV_PROCESS,\n-    UV_STREAM,\n-    UV_TCP,\n-    UV_TIMER,\n-    UV_TTY,\n-    UV_UDP,\n-    UV_SIGNAL,\n-    UV_FILE,\n-    UV_HANDLE_TYPE_MAX\n-}\n-\n-#[deriving(Eq)]\n-pub enum uv_req_type {\n-    UV_UNKNOWN_REQ,\n-    UV_REQ,\n-    UV_CONNECT,\n-    UV_WRITE,\n-    UV_SHUTDOWN,\n-    UV_UDP_SEND,\n-    UV_FS,\n-    UV_WORK,\n-    UV_GETADDRINFO,\n-    UV_REQ_TYPE_MAX\n-}\n-\n-pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n-    assert!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n-    let size = rust_uv_handle_size(handle as uint);\n-    let p = malloc(size);\n-    assert!(p.is_not_null());\n-    return p;\n-}\n-\n-pub unsafe fn free_handle(v: *c_void) {\n-    free(v)\n-}\n-\n-pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n-    assert!(req != UV_UNKNOWN_REQ && req != UV_REQ_TYPE_MAX);\n-    let size = rust_uv_req_size(req as uint);\n-    let p = malloc(size);\n-    assert!(p.is_not_null());\n-    return p;\n-}\n-\n-pub unsafe fn free_req(v: *c_void) {\n-    free(v)\n-}\n-\n-#[test]\n-fn handle_sanity_check() {\n-    unsafe {\n-        assert!(UV_HANDLE_TYPE_MAX as uint == rust_uv_handle_type_max());\n-    }\n-}\n-\n-#[test]\n-fn request_sanity_check() {\n-    unsafe {\n-        assert!(UV_REQ_TYPE_MAX as uint == rust_uv_req_type_max());\n-    }\n-}\n-\n-pub unsafe fn loop_new() -> *c_void {\n-    return rust_uv_loop_new();\n-}\n-\n-pub unsafe fn loop_delete(loop_handle: *c_void) {\n-    rust_uv_loop_delete(loop_handle);\n-}\n-\n-pub unsafe fn run(loop_handle: *c_void) {\n-    rust_uv_run(loop_handle);\n-}\n-\n-pub unsafe fn close<T>(handle: *T, cb: *u8) {\n-    rust_uv_close(handle as *c_void, cb);\n-}\n-\n-pub unsafe fn walk(loop_handle: *c_void, cb: *u8, arg: *c_void) {\n-    rust_uv_walk(loop_handle, cb, arg);\n-}\n-\n-pub unsafe fn idle_new() -> *uv_idle_t {\n-    rust_uv_idle_new()\n-}\n-\n-pub unsafe fn idle_delete(handle: *uv_idle_t) {\n-    rust_uv_idle_delete(handle)\n-}\n-\n-pub unsafe fn idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int {\n-    rust_uv_idle_init(loop_handle, handle)\n-}\n-\n-pub unsafe fn idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int {\n-    rust_uv_idle_start(handle, cb)\n-}\n-\n-pub unsafe fn idle_stop(handle: *uv_idle_t) -> c_int {\n-    rust_uv_idle_stop(handle)\n-}\n-\n-pub unsafe fn tcp_init(loop_handle: *c_void, handle: *uv_tcp_t) -> c_int {\n-    return rust_uv_tcp_init(loop_handle, handle);\n-}\n-\n-// FIXME ref #2064\n-pub unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n-                          tcp_handle_ptr: *uv_tcp_t,\n-                          addr_ptr: *sockaddr_in,\n-                          after_connect_cb: *u8) -> c_int {\n-    return rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n-                                       after_connect_cb, addr_ptr);\n-}\n-// FIXME ref #2064\n-pub unsafe fn tcp_connect6(connect_ptr: *uv_connect_t,\n-                           tcp_handle_ptr: *uv_tcp_t,\n-                           addr_ptr: *sockaddr_in6,\n-                           after_connect_cb: *u8) -> c_int {\n-    return rust_uv_tcp_connect6(connect_ptr, tcp_handle_ptr,\n-                                        after_connect_cb, addr_ptr);\n-}\n-// FIXME ref #2064\n-pub unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in) -> c_int {\n-    return rust_uv_tcp_bind(tcp_server_ptr, addr_ptr);\n-}\n-// FIXME ref #2064\n-pub unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in6) -> c_int {\n-    return rust_uv_tcp_bind6(tcp_server_ptr, addr_ptr);\n-}\n-\n-pub unsafe fn tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in) -> c_int {\n-    return rust_uv_tcp_getpeername(tcp_handle_ptr, name);\n-}\n-\n-pub unsafe fn tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in6) ->c_int {\n-    return rust_uv_tcp_getpeername6(tcp_handle_ptr, name);\n-}\n-\n-pub unsafe fn listen<T>(stream: *T, backlog: c_int, cb: *u8) -> c_int {\n-    return rust_uv_listen(stream as *c_void, backlog, cb);\n-}\n-\n-pub unsafe fn accept(server: *c_void, client: *c_void) -> c_int {\n-    return rust_uv_accept(server as *c_void, client as *c_void);\n-}\n-\n-pub unsafe fn write<T>(req: *uv_write_t, stream: *T, buf_in: &[uv_buf_t], cb: *u8) -> c_int {\n-    let buf_ptr = vec::raw::to_ptr(buf_in);\n-    let buf_cnt = buf_in.len() as i32;\n-    return rust_uv_write(req as *c_void, stream as *c_void, buf_ptr, buf_cnt, cb);\n-}\n-pub unsafe fn read_start(stream: *uv_stream_t, on_alloc: *u8, on_read: *u8) -> c_int {\n-    return rust_uv_read_start(stream as *c_void, on_alloc, on_read);\n-}\n-\n-pub unsafe fn read_stop(stream: *uv_stream_t) -> c_int {\n-    return rust_uv_read_stop(stream as *c_void);\n-}\n-\n-pub unsafe fn last_error(loop_handle: *c_void) -> uv_err_t {\n-    return rust_uv_last_error(loop_handle);\n-}\n-\n-pub unsafe fn strerror(err: *uv_err_t) -> *c_char {\n-    return rust_uv_strerror(err);\n-}\n-pub unsafe fn err_name(err: *uv_err_t) -> *c_char {\n-    return rust_uv_err_name(err);\n-}\n-\n-pub unsafe fn async_init(loop_handle: *c_void, async_handle: *uv_async_t, cb: *u8) -> c_int {\n-    return rust_uv_async_init(loop_handle, async_handle, cb);\n-}\n-\n-pub unsafe fn async_send(async_handle: *uv_async_t) {\n-    return rust_uv_async_send(async_handle);\n-}\n-pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n-    let out_buf = uv_buf_t { base: ptr::null(), len: 0 as size_t };\n-    let out_buf_ptr = ptr::to_unsafe_ptr(&out_buf);\n-    rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n-    return out_buf;\n-}\n-\n-pub unsafe fn timer_init(loop_ptr: *c_void, timer_ptr: *uv_timer_t) -> c_int {\n-    return rust_uv_timer_init(loop_ptr, timer_ptr);\n-}\n-pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: uint,\n-                          repeat: uint) -> c_int {\n-    return rust_uv_timer_start(timer_ptr, cb, timeout as c_uint, repeat as c_uint);\n-}\n-pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> c_int {\n-    return rust_uv_timer_stop(timer_ptr);\n-}\n-\n-pub unsafe fn malloc_ip4_addr(ip: &str, port: int) -> *sockaddr_in {\n-    do str::as_c_str(ip) |ip_buf| {\n-        rust_uv_ip4_addrp(ip_buf as *u8, port as libc::c_int)\n-    }\n-}\n-pub unsafe fn malloc_ip6_addr(ip: &str, port: int) -> *sockaddr_in6 {\n-    do str::as_c_str(ip) |ip_buf| {\n-        rust_uv_ip6_addrp(ip_buf as *u8, port as libc::c_int)\n-    }\n-}\n-\n-pub unsafe fn free_ip4_addr(addr: *sockaddr_in) {\n-    rust_uv_free_ip4_addr(addr);\n-}\n-\n-pub unsafe fn free_ip6_addr(addr: *sockaddr_in6) {\n-    rust_uv_free_ip6_addr(addr);\n-}\n-\n-// data access helpers\n-pub unsafe fn get_loop_for_uv_handle<T>(handle: *T) -> *c_void {\n-    return rust_uv_get_loop_for_uv_handle(handle as *c_void);\n-}\n-pub unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t) -> *uv_stream_t {\n-    return rust_uv_get_stream_handle_from_connect_req(connect);\n-}\n-pub unsafe fn get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t {\n-    return rust_uv_get_stream_handle_from_write_req(write_req);\n-}\n-pub unsafe fn get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void {\n-    rust_uv_get_data_for_uv_loop(loop_ptr)\n-}\n-pub unsafe fn set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void) {\n-    rust_uv_set_data_for_uv_loop(loop_ptr, data);\n-}\n-pub unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *c_void {\n-    return rust_uv_get_data_for_uv_handle(handle as *c_void);\n-}\n-pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T, data: *U) {\n-    rust_uv_set_data_for_uv_handle(handle as *c_void, data as *c_void);\n-}\n-pub unsafe fn get_data_for_req<T>(req: *T) -> *c_void {\n-    return rust_uv_get_data_for_req(req as *c_void);\n-}\n-pub unsafe fn set_data_for_req<T, U>(req: *T, data: *U) {\n-    rust_uv_set_data_for_req(req as *c_void, data as *c_void);\n-}\n-pub unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n-    return rust_uv_get_base_from_buf(buf);\n-}\n-pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> size_t {\n-    return rust_uv_get_len_from_buf(buf);\n-}\n-pub unsafe fn malloc_buf_base_of(suggested_size: size_t) -> *u8 {\n-    return rust_uv_malloc_buf_base_of(suggested_size);\n-}\n-pub unsafe fn free_base_of_buf(buf: uv_buf_t) {\n-    rust_uv_free_base_of_buf(buf);\n-}\n-\n-pub unsafe fn get_last_err_info(uv_loop: *c_void) -> ~str {\n-    let err = last_error(uv_loop);\n-    let err_ptr = ptr::to_unsafe_ptr(&err);\n-    let err_name = str::raw::from_c_str(err_name(err_ptr));\n-    let err_msg = str::raw::from_c_str(strerror(err_ptr));\n-    return fmt!(\"LIBUV ERROR: name: %s msg: %s\",\n-                    err_name, err_msg);\n-}\n-\n-pub unsafe fn get_last_err_data(uv_loop: *c_void) -> uv_err_data {\n-    let err = last_error(uv_loop);\n-    let err_ptr = ptr::to_unsafe_ptr(&err);\n-    let err_name = str::raw::from_c_str(err_name(err_ptr));\n-    let err_msg = str::raw::from_c_str(strerror(err_ptr));\n-    uv_err_data { err_name: err_name, err_msg: err_msg }\n-}\n-\n-pub struct uv_err_data {\n-    err_name: ~str,\n-    err_msg: ~str,\n-}\n-\n-extern {\n-\n-    fn rust_uv_handle_size(type_: uintptr_t) -> size_t;\n-    fn rust_uv_req_size(type_: uintptr_t) -> size_t;\n-    fn rust_uv_handle_type_max() -> uintptr_t;\n-    fn rust_uv_req_type_max() -> uintptr_t;\n-\n-    // libuv public API\n-    fn rust_uv_loop_new() -> *c_void;\n-    fn rust_uv_loop_delete(lp: *c_void);\n-    fn rust_uv_run(loop_handle: *c_void);\n-    fn rust_uv_close(handle: *c_void, cb: *u8);\n-    fn rust_uv_walk(loop_handle: *c_void, cb: *u8, arg: *c_void);\n-\n-    fn rust_uv_idle_new() -> *uv_idle_t;\n-    fn rust_uv_idle_delete(handle: *uv_idle_t);\n-    fn rust_uv_idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int;\n-    fn rust_uv_idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int;\n-    fn rust_uv_idle_stop(handle: *uv_idle_t) -> c_int;\n-\n-    fn rust_uv_async_send(handle: *uv_async_t);\n-    fn rust_uv_async_init(loop_handle: *c_void,\n-                          async_handle: *uv_async_t,\n-                          cb: *u8) -> c_int;\n-    fn rust_uv_tcp_init(loop_handle: *c_void, handle_ptr: *uv_tcp_t) -> c_int;\n-    // FIXME ref #2604 .. ?\n-    fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8, len: size_t);\n-    fn rust_uv_last_error(loop_handle: *c_void) -> uv_err_t;\n-    // FIXME ref #2064\n-    fn rust_uv_strerror(err: *uv_err_t) -> *c_char;\n-    // FIXME ref #2064\n-    fn rust_uv_err_name(err: *uv_err_t) -> *c_char;\n-    fn rust_uv_ip4_addrp(ip: *u8, port: c_int) -> *sockaddr_in;\n-    fn rust_uv_ip6_addrp(ip: *u8, port: c_int) -> *sockaddr_in6;\n-    fn rust_uv_free_ip4_addr(addr: *sockaddr_in);\n-    fn rust_uv_free_ip6_addr(addr: *sockaddr_in6);\n-    fn rust_uv_ip4_name(src: *sockaddr_in, dst: *u8, size: size_t) -> c_int;\n-    fn rust_uv_ip6_name(src: *sockaddr_in6, dst: *u8, size: size_t) -> c_int;\n-    fn rust_uv_ip4_port(src: *sockaddr_in) -> c_uint;\n-    fn rust_uv_ip6_port(src: *sockaddr_in6) -> c_uint;\n-    // FIXME ref #2064\n-    fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n-                           tcp_handle_ptr: *uv_tcp_t,\n-                           after_cb: *u8,\n-                           addr: *sockaddr_in) -> c_int;\n-    // FIXME ref #2064\n-    fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t, addr: *sockaddr_in) -> c_int;\n-    // FIXME ref #2064\n-    fn rust_uv_tcp_connect6(connect_ptr: *uv_connect_t,\n-                            tcp_handle_ptr: *uv_tcp_t,\n-                            after_cb: *u8,\n-                            addr: *sockaddr_in6) -> c_int;\n-    // FIXME ref #2064\n-    fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t, addr: *sockaddr_in6) -> c_int;\n-    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t,\n-                               name: *sockaddr_in) -> c_int;\n-    fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t,\n-                                name: *sockaddr_in6) ->c_int;\n-    fn rust_uv_listen(stream: *c_void, backlog: c_int, cb: *u8) -> c_int;\n-    fn rust_uv_accept(server: *c_void, client: *c_void) -> c_int;\n-    fn rust_uv_write(req: *c_void,\n-                     stream: *c_void,\n-                     buf_in: *uv_buf_t,\n-                     buf_cnt: c_int,\n-                     cb: *u8) -> c_int;\n-    fn rust_uv_read_start(stream: *c_void,\n-                          on_alloc: *u8,\n-                          on_read: *u8) -> c_int;\n-    fn rust_uv_read_stop(stream: *c_void) -> c_int;\n-    fn rust_uv_timer_init(loop_handle: *c_void,\n-                          timer_handle: *uv_timer_t) -> c_int;\n-    fn rust_uv_timer_start(timer_handle: *uv_timer_t,\n-                           cb: *u8,\n-                           timeout: c_uint,\n-                           repeat: c_uint) -> c_int;\n-    fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n-\n-    fn rust_uv_malloc_buf_base_of(sug_size: size_t) -> *u8;\n-    fn rust_uv_free_base_of_buf(buf: uv_buf_t);\n-    fn rust_uv_get_stream_handle_from_connect_req(connect_req: *uv_connect_t) -> *uv_stream_t;\n-    fn rust_uv_get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t;\n-    fn rust_uv_get_loop_for_uv_handle(handle: *c_void) -> *c_void;\n-    fn rust_uv_get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void;\n-    fn rust_uv_set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void);\n-    fn rust_uv_get_data_for_uv_handle(handle: *c_void) -> *c_void;\n-    fn rust_uv_set_data_for_uv_handle(handle: *c_void, data: *c_void);\n-    fn rust_uv_get_data_for_req(req: *c_void) -> *c_void;\n-    fn rust_uv_set_data_for_req(req: *c_void, data: *c_void);\n-    fn rust_uv_get_base_from_buf(buf: uv_buf_t) -> *u8;\n-    fn rust_uv_get_len_from_buf(buf: uv_buf_t) -> size_t;\n-}"}]}