{"sha": "7aa66515f6e60cb7a85d3d6008f282e3099a2e9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhYTY2NTE1ZjZlNjBjYjdhODVkM2Q2MDA4ZjI4MmUzMDk5YTJlOWM=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-19T23:15:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-19T23:15:16Z"}, "message": "Rollup merge of #48902 - csmoe:refactor_BorrowckErrors_fn_self, r=nikomatsakis\n\nrefactor the `BorrowckErrors` trait to take `fn(self)`\n\nFixes #48783", "tree": {"sha": "00ba1255413b91689b94c0bcaa716f2dda357f62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00ba1255413b91689b94c0bcaa716f2dda357f62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7aa66515f6e60cb7a85d3d6008f282e3099a2e9c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJasESFCRBK7hj4Ov3rIwAAdHIIAG+GAp7rVsB24py+XNo3hhKj\n/6HkaEsbJLpy84ebw1aTmYHJECwlFNdgBGF81GwHfqIXO3JftdwcyLPZc/PqsF9c\n/z56VMV9vaUAH12+Jrn5f3jNtPF2ogJKN7XlAwVj8U7l6DH1wG/avSLjkwze+vzH\nzBcazJA8IG6c0CCPgAJ+jmE2lgR+07zTMzzixpg6xcLOrwhs/SU/PnLWnEsPXX0n\nwLYEcgLkKNf8HdxtpCoBT1MqK6YkFilKBSK28PkSnxBzDy3E1uxei0pOguVs1VLO\nHhuAigl8RRdC/VnD9wf1jgwBMcGuHtM21HUY8AnkyszQWsTXDzlXdvpMBr0hHpo=\n=/jcB\n-----END PGP SIGNATURE-----\n", "payload": "tree 00ba1255413b91689b94c0bcaa716f2dda357f62\nparent 49b584ce6025fd4a00f0b666b2e211a46d063f1b\nparent 55116243e708201918f4f8bc20182754b00f32fa\nauthor kennytm <kennytm@gmail.com> 1521501316 +0800\ncommitter GitHub <noreply@github.com> 1521501316 +0800\n\nRollup merge of #48902 - csmoe:refactor_BorrowckErrors_fn_self, r=nikomatsakis\n\nrefactor the `BorrowckErrors` trait to take `fn(self)`\n\nFixes #48783\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7aa66515f6e60cb7a85d3d6008f282e3099a2e9c", "html_url": "https://github.com/rust-lang/rust/commit/7aa66515f6e60cb7a85d3d6008f282e3099a2e9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7aa66515f6e60cb7a85d3d6008f282e3099a2e9c/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49b584ce6025fd4a00f0b666b2e211a46d063f1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/49b584ce6025fd4a00f0b666b2e211a46d063f1b", "html_url": "https://github.com/rust-lang/rust/commit/49b584ce6025fd4a00f0b666b2e211a46d063f1b"}, {"sha": "55116243e708201918f4f8bc20182754b00f32fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/55116243e708201918f4f8bc20182754b00f32fa", "html_url": "https://github.com/rust-lang/rust/commit/55116243e708201918f4f8bc20182754b00f32fa"}], "stats": {"total": 188, "additions": 94, "deletions": 94}, "files": [{"sha": "93d6247eeae47733af3b4f8833bbb248ceda400c", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7aa66515f6e60cb7a85d3d6008f282e3099a2e9c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa66515f6e60cb7a85d3d6008f282e3099a2e9c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=7aa66515f6e60cb7a85d3d6008f282e3099a2e9c", "patch": "@@ -253,28 +253,28 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     used_mut_nodes: RefCell<FxHashSet<HirId>>,\n }\n \n-impl<'b, 'tcx: 'b> BorrowckErrors for BorrowckCtxt<'b, 'tcx> {\n-    fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n-                                                         sp: S,\n-                                                         msg: &str,\n-                                                         code: DiagnosticId)\n-                                                         -> DiagnosticBuilder<'a>\n+impl<'a, 'b, 'tcx: 'b> BorrowckErrors<'a> for &'a BorrowckCtxt<'b, 'tcx> {\n+    fn struct_span_err_with_code<S: Into<MultiSpan>>(self,\n+                                                     sp: S,\n+                                                     msg: &str,\n+                                                     code: DiagnosticId)\n+                                                     -> DiagnosticBuilder<'a>\n     {\n         self.tcx.sess.struct_span_err_with_code(sp, msg, code)\n     }\n \n-    fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n-                                               sp: S,\n-                                               msg: &str)\n-                                               -> DiagnosticBuilder<'a>\n+    fn struct_span_err<S: Into<MultiSpan>>(self,\n+                                           sp: S,\n+                                           msg: &str)\n+                                           -> DiagnosticBuilder<'a>\n     {\n         self.tcx.sess.struct_span_err(sp, msg)\n     }\n \n-    fn cancel_if_wrong_origin<'a>(&'a self,\n-                                mut diag: DiagnosticBuilder<'a>,\n-                                o: Origin)\n-                                -> DiagnosticBuilder<'a>\n+    fn cancel_if_wrong_origin(self,\n+                              mut diag: DiagnosticBuilder<'a>,\n+                              o: Origin)\n+                              -> DiagnosticBuilder<'a>\n     {\n         if !o.should_emit_errors(self.tcx.borrowck_mode()) {\n             self.tcx.sess.diagnostic().cancel(&mut diag);"}, {"sha": "5e15348de5e718a76632bf2e11c1daeceb341e4b", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/7aa66515f6e60cb7a85d3d6008f282e3099a2e9c/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa66515f6e60cb7a85d3d6008f282e3099a2e9c/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=7aa66515f6e60cb7a85d3d6008f282e3099a2e9c", "patch": "@@ -52,44 +52,44 @@ impl Origin {\n     }\n }\n \n-pub trait BorrowckErrors {\n-    fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n-                                                         sp: S,\n-                                                         msg: &str,\n-                                                         code: DiagnosticId)\n-                                                         -> DiagnosticBuilder<'a>;\n-\n-    fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n-                                               sp: S,\n-                                               msg: &str)\n-                                               -> DiagnosticBuilder<'a>;\n+pub trait BorrowckErrors<'cx>: Sized + Copy {\n+    fn struct_span_err_with_code<S: Into<MultiSpan>>(self,\n+                                                     sp: S,\n+                                                     msg: &str,\n+                                                     code: DiagnosticId)\n+                                                     -> DiagnosticBuilder<'cx>;\n+\n+    fn struct_span_err<S: Into<MultiSpan>>(self,\n+                                           sp: S,\n+                                           msg: &str)\n+                                           -> DiagnosticBuilder<'cx>;\n \n     /// Cancels the given error if we shouldn't emit errors for a given\n     /// origin in the current mode.\n     ///\n     /// Always make sure that the error gets passed through this function\n     /// before you return it.\n-    fn cancel_if_wrong_origin<'a>(&'a self,\n-                                diag: DiagnosticBuilder<'a>,\n-                                o: Origin)\n-                                -> DiagnosticBuilder<'a>;\n+    fn cancel_if_wrong_origin(self,\n+                              diag: DiagnosticBuilder<'cx>,\n+                              o: Origin)\n+                              -> DiagnosticBuilder<'cx>;\n \n-    fn cannot_move_when_borrowed(&self, span: Span, desc: &str, o: Origin)\n-                                 -> DiagnosticBuilder<'_>\n+    fn cannot_move_when_borrowed(self, span: Span, desc: &str, o: Origin)\n+                                 -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, span, E0505,\n                                    \"cannot move out of `{}` because it is borrowed{OGN}\",\n                                    desc, OGN=o);\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_use_when_mutably_borrowed(&self,\n+    fn cannot_use_when_mutably_borrowed(self,\n                                         span: Span,\n                                         desc: &str,\n                                         borrow_span: Span,\n                                         borrow_desc: &str,\n                                         o: Origin)\n-                                        -> DiagnosticBuilder<'_>\n+                                        -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, span, E0503,\n                          \"cannot use `{}` because it was mutably borrowed{OGN}\",\n@@ -101,28 +101,28 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_act_on_uninitialized_variable(&self,\n+    fn cannot_act_on_uninitialized_variable(self,\n                                             span: Span,\n                                             verb: &str,\n                                             desc: &str,\n                                             o: Origin)\n-                                            -> DiagnosticBuilder\n+                                            -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, span, E0381,\n                                    \"{} of possibly uninitialized variable: `{}`{OGN}\",\n                                    verb, desc, OGN=o);\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_mutably_borrow_multiply(&self,\n+    fn cannot_mutably_borrow_multiply(self,\n                                       new_loan_span: Span,\n                                       desc: &str,\n                                       opt_via: &str,\n                                       old_loan_span: Span,\n                                       old_opt_via: &str,\n                                       old_load_end_span: Option<Span>,\n                                       o: Origin)\n-                                      -> DiagnosticBuilder\n+                                      -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, new_loan_span, E0499,\n                          \"cannot borrow `{}`{} as mutable more than once at a time{OGN}\",\n@@ -148,13 +148,13 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_uniquely_borrow_by_two_closures(&self,\n+    fn cannot_uniquely_borrow_by_two_closures(self,\n                                               new_loan_span: Span,\n                                               desc: &str,\n                                               old_loan_span: Span,\n                                               old_load_end_span: Option<Span>,\n                                               o: Origin)\n-                                              -> DiagnosticBuilder\n+                                              -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, new_loan_span, E0524,\n                          \"two closures require unique access to `{}` at the same time{OGN}\",\n@@ -173,7 +173,7 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_uniquely_borrow_by_one_closure(&self,\n+    fn cannot_uniquely_borrow_by_one_closure(self,\n                                              new_loan_span: Span,\n                                              desc_new: &str,\n                                              opt_via: &str,\n@@ -182,7 +182,7 @@ pub trait BorrowckErrors {\n                                              old_opt_via: &str,\n                                              previous_end_span: Option<Span>,\n                                              o: Origin)\n-                                             -> DiagnosticBuilder\n+                                             -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, new_loan_span, E0500,\n                          \"closure requires unique access to `{}` but {} is already borrowed{}{OGN}\",\n@@ -197,7 +197,7 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_reborrow_already_uniquely_borrowed(&self,\n+    fn cannot_reborrow_already_uniquely_borrowed(self,\n                                                  new_loan_span: Span,\n                                                  desc_new: &str,\n                                                  opt_via: &str,\n@@ -206,7 +206,7 @@ pub trait BorrowckErrors {\n                                                  old_opt_via: &str,\n                                                  previous_end_span: Option<Span>,\n                                                  o: Origin)\n-                                                 -> DiagnosticBuilder\n+                                                 -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, new_loan_span, E0501,\n                          \"cannot borrow `{}`{} as {} because previous closure \\\n@@ -222,7 +222,7 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_reborrow_already_borrowed(&self,\n+    fn cannot_reborrow_already_borrowed(self,\n                                         span: Span,\n                                         desc_new: &str,\n                                         msg_new: &str,\n@@ -233,7 +233,7 @@ pub trait BorrowckErrors {\n                                         msg_old: &str,\n                                         old_load_end_span: Option<Span>,\n                                         o: Origin)\n-                                        -> DiagnosticBuilder\n+                                        -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, span, E0502,\n                          \"cannot borrow `{}`{} as {} because {} is also borrowed as {}{}{OGN}\",\n@@ -246,8 +246,8 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign_to_borrowed(&self, span: Span, borrow_span: Span, desc: &str, o: Origin)\n-                                 -> DiagnosticBuilder\n+    fn cannot_assign_to_borrowed(self, span: Span, borrow_span: Span, desc: &str, o: Origin)\n+                                 -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, span, E0506,\n                          \"cannot assign to `{}` because it is borrowed{OGN}\",\n@@ -259,8 +259,8 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_move_into_closure(&self, span: Span, desc: &str, o: Origin)\n-                                -> DiagnosticBuilder\n+    fn cannot_move_into_closure(self, span: Span, desc: &str, o: Origin)\n+                                -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, span, E0504,\n                                    \"cannot move `{}` into closure because it is borrowed{OGN}\",\n@@ -269,8 +269,8 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_reassign_immutable(&self, span: Span, desc: &str, is_arg: bool, o: Origin)\n-                                 -> DiagnosticBuilder\n+    fn cannot_reassign_immutable(self, span: Span, desc: &str, is_arg: bool, o: Origin)\n+                                 -> DiagnosticBuilder<'cx>\n     {\n         let msg = if is_arg {\n             \"to immutable argument\"\n@@ -284,22 +284,22 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign(&self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder\n+    fn cannot_assign(self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, span, E0594,\n                                   \"cannot assign to {}{OGN}\",\n                                   desc, OGN=o);\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign_static(&self, span: Span, desc: &str, o: Origin)\n-                            -> DiagnosticBuilder\n+    fn cannot_assign_static(self, span: Span, desc: &str, o: Origin)\n+                            -> DiagnosticBuilder<'cx>\n     {\n         self.cannot_assign(span, &format!(\"immutable static item `{}`\", desc), o)\n     }\n \n-    fn cannot_move_out_of(&self, move_from_span: Span, move_from_desc: &str, o: Origin)\n-                          -> DiagnosticBuilder\n+    fn cannot_move_out_of(self, move_from_span: Span, move_from_desc: &str, o: Origin)\n+                          -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, move_from_span, E0507,\n                                        \"cannot move out of {}{OGN}\",\n@@ -311,12 +311,12 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_move_out_of_interior_noncopy(&self,\n+    fn cannot_move_out_of_interior_noncopy(self,\n                                            move_from_span: Span,\n                                            ty: ty::Ty,\n                                            is_index: bool,\n                                            o: Origin)\n-                                           -> DiagnosticBuilder\n+                                           -> DiagnosticBuilder<'cx>\n     {\n         let type_name = match (&ty.sty, is_index) {\n             (&ty::TyArray(_, _), true) => \"array\",\n@@ -332,11 +332,11 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_move_out_of_interior_of_drop(&self,\n+    fn cannot_move_out_of_interior_of_drop(self,\n                                            move_from_span: Span,\n                                            container_ty: ty::Ty,\n                                            o: Origin)\n-                                           -> DiagnosticBuilder\n+                                           -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, move_from_span, E0509,\n                                        \"cannot move out of type `{}`, \\\n@@ -347,13 +347,13 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_act_on_moved_value(&self,\n+    fn cannot_act_on_moved_value(self,\n                                  use_span: Span,\n                                  verb: &str,\n                                  optional_adverb_for_moved: &str,\n                                  moved_path: &str,\n                                  o: Origin)\n-                                 -> DiagnosticBuilder\n+                                 -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, use_span, E0382,\n                                    \"{} of {}moved value: `{}`{OGN}\",\n@@ -362,11 +362,11 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_partially_reinit_an_uninit_struct(&self,\n+    fn cannot_partially_reinit_an_uninit_struct(self,\n                                                 span: Span,\n                                                 uninit_path: &str,\n                                                 o: Origin)\n-                                                -> DiagnosticBuilder\n+                                                -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self,\n                                    span,\n@@ -377,35 +377,35 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn closure_cannot_assign_to_borrowed(&self,\n+    fn closure_cannot_assign_to_borrowed(self,\n                                          span: Span,\n                                          descr: &str,\n                                          o: Origin)\n-                                         -> DiagnosticBuilder\n+                                         -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, span, E0595, \"closure cannot assign to {}{OGN}\",\n                                    descr, OGN=o);\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_borrow_path_as_mutable(&self,\n+    fn cannot_borrow_path_as_mutable(self,\n                                      span: Span,\n                                      path: &str,\n                                      o: Origin)\n-                                     -> DiagnosticBuilder\n+                                     -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, span, E0596, \"cannot borrow {} as mutable{OGN}\",\n                                    path, OGN=o);\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_borrow_across_generator_yield(&self,\n+    fn cannot_borrow_across_generator_yield(self,\n                                             span: Span,\n                                             yield_span: Span,\n                                             o: Origin)\n-                                            -> DiagnosticBuilder\n+                                            -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self,\n                                        span,\n@@ -417,23 +417,23 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn path_does_not_live_long_enough(&self,\n+    fn path_does_not_live_long_enough(self,\n                                       span: Span,\n                                       path: &str,\n                                       o: Origin)\n-                                      -> DiagnosticBuilder\n+                                      -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, span, E0597, \"{} does not live long enough{OGN}\",\n                                    path, OGN=o);\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn lifetime_too_short_for_reborrow(&self,\n+    fn lifetime_too_short_for_reborrow(self,\n                                        span: Span,\n                                        path: &str,\n                                        o: Origin)\n-                                       -> DiagnosticBuilder\n+                                       -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, span, E0598,\n                                    \"lifetime of {} is too short to guarantee \\\n@@ -443,12 +443,12 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_act_on_capture_in_sharable_fn(&self,\n+    fn cannot_act_on_capture_in_sharable_fn(self,\n                                             span: Span,\n                                             bad_thing: &str,\n                                             help: (Span, &str),\n                                             o: Origin)\n-                                            -> DiagnosticBuilder\n+                                            -> DiagnosticBuilder<'cx>\n     {\n         let (help_span, help_msg) = help;\n         let mut err = struct_span_err!(self, span, E0387,\n@@ -459,11 +459,11 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign_into_immutable_reference(&self,\n+    fn cannot_assign_into_immutable_reference(self,\n                                               span: Span,\n                                               bad_thing: &str,\n                                               o: Origin)\n-                                              -> DiagnosticBuilder\n+                                              -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, span, E0389, \"{} in a `&` reference{OGN}\",\n                                        bad_thing, OGN=o);\n@@ -472,12 +472,12 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_capture_in_long_lived_closure(&self,\n+    fn cannot_capture_in_long_lived_closure(self,\n                                             closure_span: Span,\n                                             borrowed_path: &str,\n                                             capture_span: Span,\n                                             o: Origin)\n-                                            -> DiagnosticBuilder\n+                                            -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, closure_span, E0373,\n                                        \"closure may outlive the current function, \\\n@@ -491,28 +491,28 @@ pub trait BorrowckErrors {\n     }\n }\n \n-impl<'b, 'gcx, 'tcx> BorrowckErrors for TyCtxt<'b, 'gcx, 'tcx> {\n-    fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n-                                                         sp: S,\n-                                                         msg: &str,\n-                                                         code: DiagnosticId)\n-                                                         -> DiagnosticBuilder<'a>\n+impl<'cx, 'gcx, 'tcx> BorrowckErrors<'cx> for TyCtxt<'cx, 'gcx, 'tcx> {\n+    fn struct_span_err_with_code<S: Into<MultiSpan>>(self,\n+                                                     sp: S,\n+                                                     msg: &str,\n+                                                     code: DiagnosticId)\n+                                                     -> DiagnosticBuilder<'cx>\n     {\n         self.sess.struct_span_err_with_code(sp, msg, code)\n     }\n \n-    fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n-                                               sp: S,\n-                                               msg: &str)\n-                                               -> DiagnosticBuilder<'a>\n+    fn struct_span_err<S: Into<MultiSpan>>(self,\n+                                           sp: S,\n+                                           msg: &str)\n+                                           -> DiagnosticBuilder<'cx>\n     {\n         self.sess.struct_span_err(sp, msg)\n     }\n \n-    fn cancel_if_wrong_origin<'a>(&'a self,\n-                                mut diag: DiagnosticBuilder<'a>,\n-                                o: Origin)\n-                                -> DiagnosticBuilder<'a>\n+    fn cancel_if_wrong_origin(self,\n+                              mut diag: DiagnosticBuilder<'cx>,\n+                              o: Origin)\n+                              -> DiagnosticBuilder<'cx>\n     {\n         if !o.should_emit_errors(self.borrowck_mode()) {\n             self.sess.diagnostic().cancel(&mut diag);"}]}