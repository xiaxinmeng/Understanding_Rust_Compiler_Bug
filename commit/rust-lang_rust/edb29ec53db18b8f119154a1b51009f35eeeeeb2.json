{"sha": "edb29ec53db18b8f119154a1b51009f35eeeeeb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkYjI5ZWM1M2RiMThiOGYxMTkxNTRhMWI1MTAwOWYzNWVlZWVlYjI=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-19T22:52:21Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-19T22:52:21Z"}, "message": "futz with headers more", "tree": {"sha": "37aca1516c32fa80457ac5ecbe29c841addaaaaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37aca1516c32fa80457ac5ecbe29c841addaaaaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edb29ec53db18b8f119154a1b51009f35eeeeeb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edb29ec53db18b8f119154a1b51009f35eeeeeb2", "html_url": "https://github.com/rust-lang/rust/commit/edb29ec53db18b8f119154a1b51009f35eeeeeb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edb29ec53db18b8f119154a1b51009f35eeeeeb2/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d41c950c4e73dee4d5b44022186aa65e4323375", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d41c950c4e73dee4d5b44022186aa65e4323375", "html_url": "https://github.com/rust-lang/rust/commit/7d41c950c4e73dee4d5b44022186aa65e4323375"}], "stats": {"total": 94, "additions": 61, "deletions": 33}, "files": [{"sha": "a382e4edf54cf30fd2d9c3e4dd1745107f86a3cb", "filename": "concurrency.md", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/edb29ec53db18b8f119154a1b51009f35eeeeeb2/concurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/edb29ec53db18b8f119154a1b51009f35eeeeeb2/concurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/concurrency.md?ref=edb29ec53db18b8f119154a1b51009f35eeeeeb2", "patch": "@@ -1,16 +1,8 @@\n % Concurrency and Paralellism\n \n-```Not sure if I want this\n-Safe Rust features *a ton* of tooling to make concurrency and parallelism totally\n-safe, easy, and fearless. This is a case where we'll really just\n-[defer to TRPL][trpl-conc] for the basics.\n-\n-TL;DR: The `Send` and `Sync` traits in conjunction with Rust's ownership model and\n-normal generic bounds make using concurrent APIs really easy and painless for\n-a user of Safe Rust.\n-```\n \n-## Data Races and Race Conditions\n+\n+# Data Races and Race Conditions\n \n Safe Rust guarantees an absence of data races, which are defined as:\n \n@@ -77,7 +69,10 @@ if idx.load(Ordering::SeqCst) < data.len() {\n }\n ```\n \n-## Send and Sync\n+\n+\n+\n+# Send and Sync\n \n Not everything obeys inherited mutability, though. Some types allow you to multiply\n alias a location in memory while mutating it. Unless these types use synchronization\n@@ -153,7 +148,10 @@ into the collection.\n TODO: better explain what can or can't be Send or Sync. Sufficient to appeal\n only to data races?\n \n-## Atomics\n+\n+\n+\n+# Atomics\n \n Rust pretty blatantly just inherits LLVM's model for atomics, which in turn is\n largely based off of the C11 model for atomics. This is not due these models\n@@ -165,7 +163,10 @@ least, we can benefit from existing tooling and research around C's model.\n Trying to fully explain these models is fairly hopeless, so we're just going to\n drop that problem in LLVM's lap.\n \n-## Actually Doing Things Concurrently\n+\n+\n+\n+# Actually Doing Things Concurrently\n \n Rust as a language doesn't *really* have an opinion on how to do concurrency or\n parallelism. The standard library exposes OS threads and blocking sys-calls"}, {"sha": "110084824cfef36df34255db1b0763d8bcea049f", "filename": "data.md", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/edb29ec53db18b8f119154a1b51009f35eeeeeb2/data.md", "raw_url": "https://github.com/rust-lang/rust/raw/edb29ec53db18b8f119154a1b51009f35eeeeeb2/data.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/data.md?ref=edb29ec53db18b8f119154a1b51009f35eeeeeb2", "patch": "@@ -4,7 +4,10 @@ Low-level programming cares a lot about data layout. It's a big deal. It also pe\n influences the rest of the language, so we're going to start by digging into how data is\n represented in Rust.\n \n-## The rust repr\n+\n+\n+\n+# The rust repr\n \n Rust gives you the following ways to lay out composite data:\n \n@@ -124,7 +127,7 @@ In principle enums can use fairly elaborate algorithms to cache bits throughout\n with special constrained representations. As such it is *especially* desirable that we leave\n enum layout unspecified today.\n \n-## Dynamically Sized Types (DSTs)\n+# Dynamically Sized Types (DSTs)\n \n Rust also supports types without a statically known size. On the surface,\n this is a bit nonsensical: Rust must know the size of something in order to\n@@ -150,6 +153,9 @@ struct Foo {\n }\n ```\n \n+\n+\n+\n # Zero Sized Types (ZSTs)\n \n Rust actually allows types to be specified that occupy *no* space:\n@@ -182,6 +188,9 @@ consequence of types with no size. In particular, pointer offsets are no-ops, an\n standard allocators (including jemalloc, the one used by Rust) generally consider\n passing in `0` as Undefined Behaviour.\n \n+\n+\n+\n # Drop Flags\n \n For unfortunate legacy implementation reasons, Rust as of 1.0.0 will do a nasty trick to\n@@ -212,12 +221,17 @@ struct Foo {\n For details as to *why* this is done, and how to make it not happen, check out\n [SOME OTHER SECTION].\n \n-## Alternative representations\n+\n+\n+\n+# Alternative representations\n \n Rust allows you to specify alternative data layout strategies from the default Rust\n one.\n \n-### repr(C)\n+\n+\n+## repr(C)\n \n This is the most important `repr`. It has fairly simple intent: do what C does.\n The order, size, and alignment of fields is exactly what you would expect from\n@@ -241,14 +255,18 @@ still consumes a byte of space.\n \n * This is equivalent to repr(u32) for enums (see below)\n \n-### repr(packed)\n+\n+\n+## repr(packed)\n \n `repr(packed)` forces rust to strip any padding it would normally apply.\n This may improve the memory footprint of a type, but will have negative\n side-effects from \"field access is heavily penalized\" to \"completely breaks\n everything\" based on target platform.\n \n-### repr(u8), repr(u16), repr(u32), repr(u64)\n+\n+\n+## repr(u8), repr(u16), repr(u32), repr(u64)\n \n These specify the size to make a c-like enum (one which has no values in its variants).\n "}, {"sha": "7d3036fe5ec4266bf3145ad5e31d633458da2101", "filename": "intro.md", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/edb29ec53db18b8f119154a1b51009f35eeeeeb2/intro.md", "raw_url": "https://github.com/rust-lang/rust/raw/edb29ec53db18b8f119154a1b51009f35eeeeeb2/intro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/intro.md?ref=edb29ec53db18b8f119154a1b51009f35eeeeeb2", "patch": "@@ -7,7 +7,10 @@ Unsafe Rust. TURPL does not assume you have read TRPL, but does assume you know\n the basics of the language and systems programming. We will not explain the\n stack or heap, we will not explain the syntax.\n \n-## Sections\n+\n+\n+\n+# Sections\n \n * [Data Layout](data.html)\n * [Ownership and Lifetimes](lifetimes.html)\n@@ -16,7 +19,10 @@ stack or heap, we will not explain the syntax.\n * [Ownership-oriented resource management (RAII)](raii.html)\n * [Concurrency](concurrency.html)\n \n-## A Tale Of Two Languages\n+\n+\n+\n+# A Tale Of Two Languages\n \n Rust can be thought of as two different languages: Safe Rust, and Unsafe Rust.\n Any time someone opines the guarantees of Rust, they are almost surely talking about\n@@ -60,7 +66,10 @@ The fact that Rust is written with a healthy spoonful of Unsafe Rust is no diffe\n However it *does* mean that Rust doesn't need to fall back to the pervasive unsafety of\n C to do the nasty things that need to get done.\n \n-## What does `unsafe` mean?\n+\n+\n+\n+# What does `unsafe` mean?\n \n Rust tries to model memory safety through the `unsafe` keyword. Interestingly,\n the meaning of `unsafe` largely revolves around what"}, {"sha": "4be895ff429b5d4bb3ba3292dd79c9c888fbec27", "filename": "lifetimes.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/edb29ec53db18b8f119154a1b51009f35eeeeeb2/lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/edb29ec53db18b8f119154a1b51009f35eeeeeb2/lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lifetimes.md?ref=edb29ec53db18b8f119154a1b51009f35eeeeeb2", "patch": "@@ -7,7 +7,7 @@ language-design problem.\n \n \n \n-## The Tagged Union Problem\n+# The Tagged Union Problem\n \n The core of the lifetime and mutability system derives from a simple problem:\n internal pointers to tagged unions. For instance, consider the following code:\n@@ -68,7 +68,7 @@ For more details see Dan Grossman's Existential Types for Imperative Languages:\n \n \n \n-## Lifetimes\n+# Lifetimes\n \n Rust's static checks are managed by the *borrow checker* (borrowck), which tracks\n mutability and outstanding loans. This analysis can in principle be done without\n@@ -101,7 +101,7 @@ more than a local lint against incorrect usage of a value.\n \n \n \n-## Weird Lifetimes\n+# Weird Lifetimes\n \n Given the following code:\n \n@@ -150,7 +150,7 @@ a bug.\n \n \n \n-## Lifetime Elision\n+# Lifetime Elision\n \n In order to make common patterns more ergonomic, Rust allows lifetimes to be\n *elided* in function, impl, and type signatures.\n@@ -217,7 +217,7 @@ fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>          // expanded\n \n \n \n-## Unbounded Lifetimes\n+# Unbounded Lifetimes\n \n Unsafe code can often end up producing references or lifetimes out of thin air.\n Such lifetimes come into the world as *unbounded*. The most common source of this\n@@ -258,7 +258,7 @@ these are unstable due to their awkward nature and questionable utility.\n \n \n \n-## Higher-Rank Lifetimes\n+# Higher-Rank Lifetimes\n \n Generics in Rust generally allow types to be instantiated with arbitrary\n associated lifetimes, but this fixes the lifetimes they work with once\n@@ -328,7 +328,7 @@ maximally useful outside of the Fn traits.\n \n \n \n-## Subtyping and Variance\n+# Subtyping and Variance\n \n Although Rust doesn't have any notion of inheritance, it *does* include subtyping.\n In Rust, subtyping derives entirely from *lifetimes*. Since lifetimes are derived\n@@ -474,7 +474,7 @@ struct Foo<'a, 'b, A, B, C, D, E, F, G, H> {\n \n \n \n-## PhantomData\n+# PhantomData\n \n When working with unsafe code, we can often end up in a situation where\n types or lifetimes are logically associated with a struct, but not actually\n@@ -513,7 +513,7 @@ pub struct Iter<'a, T: 'a> {\n \n \n \n-## Dropck\n+# Dropck\n \n When a type is going out of scope, Rust will try to Drop it. Drop executes\n arbitrary code, and in fact allows us to \"smuggle\" arbitrary code execution\n@@ -557,7 +557,7 @@ standard library made a utility for itself called `Unique<T>` which:\n \n \n \n-## Splitting Lifetimes\n+# Splitting Lifetimes\n \n The mutual exclusion property of mutable references can be very limiting when\n working with a composite structure. Borrowck understands some basic stuff, but"}, {"sha": "76363030b8481535d7aab73392e170b8b807349b", "filename": "raii.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edb29ec53db18b8f119154a1b51009f35eeeeeb2/raii.md", "raw_url": "https://github.com/rust-lang/rust/raw/edb29ec53db18b8f119154a1b51009f35eeeeeb2/raii.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/raii.md?ref=edb29ec53db18b8f119154a1b51009f35eeeeeb2", "patch": "@@ -176,4 +176,4 @@ On balance this is an ok choice. Certainly if you're just getting started.\n In the future, we expect there to be a first-class way to announce that a field\n should be automatically dropped.\n \n-[uninit]:\n\\ No newline at end of file\n+[uninit]: uninitialized.html\n\\ No newline at end of file"}]}