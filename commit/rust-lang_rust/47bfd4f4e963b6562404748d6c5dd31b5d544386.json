{"sha": "47bfd4f4e963b6562404748d6c5dd31b5d544386", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3YmZkNGY0ZTk2M2I2NTYyNDA0NzQ4ZDZjNWRkMzFiNWQ1NDQzODY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-12T19:43:02Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-12T19:43:47Z"}, "message": "rustc: Refactor regions to handle nested functions properly and fix the subtyping relation", "tree": {"sha": "1064a656f0d8c765fb552e2c9c0e1ba89f4c796b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1064a656f0d8c765fb552e2c9c0e1ba89f4c796b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47bfd4f4e963b6562404748d6c5dd31b5d544386", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47bfd4f4e963b6562404748d6c5dd31b5d544386", "html_url": "https://github.com/rust-lang/rust/commit/47bfd4f4e963b6562404748d6c5dd31b5d544386", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47bfd4f4e963b6562404748d6c5dd31b5d544386/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "664d71f1f0c0e7ec70c6c521117bde95e027bfcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/664d71f1f0c0e7ec70c6c521117bde95e027bfcf", "html_url": "https://github.com/rust-lang/rust/commit/664d71f1f0c0e7ec70c6c521117bde95e027bfcf"}], "stats": {"total": 205, "additions": 100, "deletions": 105}, "files": [{"sha": "00943db35c64d458e6da796cf6198f0a2aff1983", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 87, "deletions": 68, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/47bfd4f4e963b6562404748d6c5dd31b5d544386/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47bfd4f4e963b6562404748d6c5dd31b5d544386/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=47bfd4f4e963b6562404748d6c5dd31b5d544386", "patch": "@@ -9,25 +9,26 @@ import syntax::{ast, visit};\n import std::map;\n import std::map::hashmap;\n \n-type region_map = {\n-    /* Mapping from a block to its parent block, if there is one. */\n-    parent_blocks: hashmap<ast::node_id,ast::node_id>,\n-    /* Mapping from a lambda to its parent function, if there is one. */\n-    parent_fns: hashmap<ast::node_id,ast::node_id>,\n-    /* Mapping from a region type in the AST to its resolved region. */\n-    ast_type_to_region: hashmap<ast::node_id,ty::region>,\n-    /* Mapping from a local variable to its containing block. */\n-    local_blocks: hashmap<ast::node_id,ast::node_id>\n-};\n-\n /* Represents the type of the most immediate parent node. */\n enum parent {\n     pa_item(ast::node_id),\n     pa_block(ast::node_id),\n-    pa_alt,\n+    pa_nested_fn(ast::node_id),\n     pa_crate\n }\n \n+type region_map = {\n+    /*\n+     * Mapping from blocks and function expression to their parent block or\n+     * function expression.\n+     */\n+    parents: hashmap<ast::node_id,ast::node_id>,\n+    /* Mapping from a region type in the AST to its resolved region. */\n+    ast_type_to_region: hashmap<ast::node_id,ty::region>,\n+    /* Mapping from a local variable to its containing block. */\n+    local_blocks: hashmap<ast::node_id,ast::node_id>,\n+};\n+\n type ctxt = {\n     sess: session,\n     def_map: resolve::def_map,\n@@ -43,18 +44,29 @@ type ctxt = {\n     mut queued_locals: [ast::node_id],\n \n     parent: parent,\n-    mut parent_fn: option<ast::node_id>\n+\n+    /* True if we're within the pattern part of an alt, false otherwise. */\n+    in_alt: bool\n };\n \n-// Returns true if `subblock` is equal to or is lexically nested inside\n-// `superblock` and false otherwise.\n-fn block_contains(region_map: @region_map, superblock: ast::node_id,\n-                  subblock: ast::node_id) -> bool {\n-    let subblock = subblock;\n-    while superblock != subblock {\n-        alt region_map.parent_blocks.find(subblock) {\n+fn region_to_scope(_region_map: @region_map, region: ty::region)\n+        -> ast::node_id {\n+    ret alt region {\n+        ty::re_caller(def_id) { def_id.node }\n+        ty::re_named(_) { fail \"TODO: named regions\" }\n+        ty::re_block(node_id) { node_id }\n+    };\n+}\n+\n+// Returns true if `subscope` is equal to or is lexically nested inside\n+// `superscope` and false otherwise.\n+fn scope_contains(region_map: @region_map, superscope: ast::node_id,\n+                  subscope: ast::node_id) -> bool {\n+    let subscope = subscope;\n+    while superscope != subscope {\n+        alt region_map.parents.find(subscope) {\n             none { ret false; }\n-            some(blk) { subblock = blk; }\n+            some(scope) { subscope = scope; }\n         }\n     }\n     ret true;\n@@ -68,24 +80,21 @@ fn resolve_ty(ty: @ast::ty, cx: ctxt, visitor: visit::vt<ctxt>) {\n                 ast::re_inferred {\n                     // We infer to the caller region if we're at item scope\n                     // and to the block region if we're at block scope.\n+                    //\n+                    // TODO: What do we do if we're in an alt?\n+\n                     alt cx.parent {\n-                        pa_item(item_id) {\n+                        pa_item(item_id) | pa_nested_fn(item_id) {\n                             let def_id = {crate: ast::local_crate,\n                                           node: item_id};\n                             region = ty::re_caller(def_id);\n                         }\n                         pa_block(block_id) {\n                             region = ty::re_block(block_id);\n                         }\n-                        pa_alt {\n-                            // FIXME: Need a design decision here.\n-                            cx.sess.span_bug(ty.span,\n-                                             \"what does & in an alt \" +\n-                                             \"resolve to?\");\n-                        }\n                         pa_crate {\n-                            cx.sess.span_bug(ty.span,\n-                                             \"region type outside item\");\n+                            cx.sess.span_bug(ty.span, \"inferred region at \" +\n+                                             \"crate level?!\");\n                         }\n                     }\n                 }\n@@ -97,16 +106,18 @@ fn resolve_ty(ty: @ast::ty, cx: ctxt, visitor: visit::vt<ctxt>) {\n                         some(def_id) { region = ty::re_named(def_id); }\n                         none {\n                             alt cx.parent {\n-                                pa_item(_) { /* ok; fall through */ }\n-                                pa_block(_) | pa_alt {\n+                                pa_item(_) | pa_nested_fn(_) {\n+                                    /* ok; fall through */\n+                                }\n+                                pa_block(_) {\n                                     cx.sess.span_err(ty.span,\n                                                      \"unknown region `\" +\n                                                      ident + \"`\");\n                                 }\n                                 pa_crate {\n-                                    cx.sess.span_bug(ty.span,\n-                                                     \"named region at \" +\n-                                                     \"crate scope?!\");\n+                                    cx.sess.span_bug(ty.span, \"named \" +\n+                                                     \"region at crate \" +\n+                                                     \"level?!\");\n                                 }\n                             }\n \n@@ -120,23 +131,23 @@ fn resolve_ty(ty: @ast::ty, cx: ctxt, visitor: visit::vt<ctxt>) {\n \n                 ast::re_self {\n                     // For blocks, \"self\" means \"the current block\".\n+                    //\n+                    // TODO: What do we do in an alt?\n+                    //\n+                    // FIXME: Doesn't work in type items.\n+\n                     alt cx.parent {\n-                        pa_item(_) {\n-                            cx.sess.span_unimpl(ty.span,\n-                                                \"'self' region for items\");\n+                        pa_item(item_id) | pa_nested_fn(item_id) {\n+                            let def_id = {crate: ast::local_crate,\n+                                          node: item_id};\n+                            region = ty::re_caller(def_id);\n                         }\n                         pa_block(block_id) {\n                             region = ty::re_block(block_id);\n                         }\n-                        pa_alt {\n-                            // FIXME: Need a design decision here.\n-                            cx.sess.span_bug(ty.span,\n-                                             \"what does &self. in an alt \" +\n-                                             \"resolve to?\");\n-                        }\n                         pa_crate {\n                             cx.sess.span_bug(ty.span,\n-                                             \"region type outside item\");\n+                                             \"region type outside item?!\");\n                         }\n                     }\n                 }\n@@ -151,28 +162,33 @@ fn resolve_ty(ty: @ast::ty, cx: ctxt, visitor: visit::vt<ctxt>) {\n     visit::visit_ty(ty, cx, visitor);\n }\n \n-fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n+fn record_parent(cx: ctxt, child_id: ast::node_id) {\n     alt cx.parent {\n-        pa_item(_) | pa_alt { /* no-op */ }\n-        pa_block(parent_block_id) {\n-            cx.region_map.parent_blocks.insert(blk.node.id, parent_block_id);\n+        pa_item(parent_id) | pa_block(parent_id) | pa_nested_fn(parent_id) {\n+            cx.region_map.parents.insert(child_id, parent_id);\n         }\n-        pa_crate { cx.sess.span_bug(blk.span, \"block outside item?!\"); }\n+        pa_crate { /* no-op */ }\n     }\n+}\n+\n+fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n+    // Record the parent of this block.\n+    record_parent(cx, blk.node.id);\n \n     // Resolve queued locals to this block.\n     for local_id in cx.queued_locals {\n         cx.region_map.local_blocks.insert(local_id, blk.node.id);\n     }\n \n+    // Descend.\n     let new_cx: ctxt = {parent: pa_block(blk.node.id),\n-                        mut queued_locals: [] with cx};\n+                        mut queued_locals: [],\n+                        in_alt: false with cx};\n     visit::visit_block(blk, new_cx, visitor);\n }\n \n fn resolve_arm(arm: ast::arm, cx: ctxt, visitor: visit::vt<ctxt>) {\n-    let new_cx: ctxt = {parent: pa_alt,\n-                        mut queued_locals: [] with cx};\n+    let new_cx: ctxt = {mut queued_locals: [], in_alt: true with cx};\n     visit::visit_arm(arm, new_cx, visitor);\n }\n \n@@ -190,15 +206,19 @@ fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n                      * containing block, depending on whether we're in an alt\n                      * or not.\n                      */\n-                    alt cx.parent {\n-                        pa_block(block_id) {\n-                            let local_blocks = cx.region_map.local_blocks;\n-                            local_blocks.insert(pat.id, block_id);\n-                        }\n-                        pa_alt {\n-                            vec::push(cx.queued_locals, pat.id);\n+                    if cx.in_alt {\n+                        vec::push(cx.queued_locals, pat.id);\n+                    } else {\n+                        alt cx.parent {\n+                            pa_block(block_id) {\n+                                let local_blocks = cx.region_map.local_blocks;\n+                                local_blocks.insert(pat.id, block_id);\n+                            }\n+                            _ {\n+                                cx.sess.span_bug(pat.span,\n+                                                 \"unexpected parent\");\n+                            }\n                         }\n-                        _ { cx.sess.span_bug(pat.span, \"unexpected parent\"); }\n                     }\n                 }\n             }\n@@ -212,9 +232,9 @@ fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n     alt expr.node {\n         ast::expr_fn(_, _, _, _) | ast::expr_fn_block(_, _) {\n-            let parent_fns = cx.region_map.parent_fns;\n-            parent_fns.insert(expr.id, option::get(cx.parent_fn));\n-            let new_cx = {parent_fn: some(expr.id) with cx};\n+            record_parent(cx, expr.id);\n+            let new_cx = {parent: pa_nested_fn(expr.id),\n+                          in_alt: false with cx};\n             visit::visit_expr(expr, new_cx, visitor);\n         }\n         _ { visit::visit_expr(expr, cx, visitor); }\n@@ -225,7 +245,7 @@ fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n     // Items create a new outer block scope as far as we're concerned.\n     let new_cx: ctxt = {names_in_scope: map::new_str_hash(),\n                         parent: pa_item(item.id),\n-                        parent_fn: some(item.id)\n+                        in_alt: false\n                         with cx};\n     visit::visit_item(item, new_cx, visitor);\n }\n@@ -234,14 +254,13 @@ fn resolve_crate(sess: session, def_map: resolve::def_map, crate: @ast::crate)\n         -> @region_map {\n     let cx: ctxt = {sess: sess,\n                     def_map: def_map,\n-                    region_map: @{parent_blocks: map::new_int_hash(),\n-                                  parent_fns: map::new_int_hash(),\n+                    region_map: @{parents: map::new_int_hash(),\n                                   ast_type_to_region: map::new_int_hash(),\n                                   local_blocks: map::new_int_hash()},\n                     names_in_scope: map::new_str_hash(),\n                     mut queued_locals: [],\n                     parent: pa_crate,\n-                    mut parent_fn: none};\n+                    in_alt: false};\n     let visitor = visit::mk_vt(@{\n         visit_block: resolve_block,\n         visit_item: resolve_item,"}, {"sha": "ef51a950df6619843ab31121995d02ab84d0829b", "filename": "src/rustc/middle/regionck.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/47bfd4f4e963b6562404748d6c5dd31b5d544386/src%2Frustc%2Fmiddle%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47bfd4f4e963b6562404748d6c5dd31b5d544386/src%2Frustc%2Fmiddle%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregionck.rs?ref=47bfd4f4e963b6562404748d6c5dd31b5d544386", "patch": "@@ -38,17 +38,12 @@ fn check_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n                             some(eb) { eb }\n                         };\n \n-                        let parent_blocks = cx.tcx.region_map.parent_blocks;\n-                        while enclosing_block_id != referent_block_id {\n-                            if parent_blocks.contains_key(referent_block_id) {\n-                                referent_block_id =\n-                                    parent_blocks.get(referent_block_id);\n-                            } else {\n-                                cx.tcx.sess.span_err(expr.span,\n-                                                     \"reference escapes \" +\n-                                                     \"its block\");\n-                                break;\n-                            }\n+                        if !region::scope_contains(cx.tcx.region_map,\n+                                                   referent_block_id,\n+                                                   enclosing_block_id) {\n+\n+                            cx.tcx.sess.span_err(expr.span, \"reference \" +\n+                                                 \"escapes its block\");\n                         }\n                     }\n                 }"}, {"sha": "10ed85dc6c5cecd5b341839daae10604476bc7d7", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 26, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/47bfd4f4e963b6562404748d6c5dd31b5d544386/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47bfd4f4e963b6562404748d6c5dd31b5d544386/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=47bfd4f4e963b6562404748d6c5dd31b5d544386", "patch": "@@ -1897,33 +1897,14 @@ mod unify {\n             }\n         }\n \n-        alt (super, sub) {\n-            (re_caller(_), re_caller(_)) {\n-                // FIXME: This is wrong w/r/t nested functions.\n-                ret some(super);\n-            }\n-            (re_caller(_), re_named(_)) | (re_named(_), re_caller(_)) {\n-                ret none;\n-            }\n-            (re_named(a), re_named(b)) {\n-                ret if a == b { some(super) } else { none }\n-            }\n-            (re_caller(_), re_block(_)) | (re_named(_), re_block(_)) {\n-                // FIXME: This is wrong w/r/t nested functions.\n-                ret some(super);\n-            }\n-            (re_block(_), re_caller(_)) | (re_block(_), re_named(_)) {\n-                ret none;\n-            }\n-            (re_block(superblock), re_block(subblock)) {\n-                if region::block_contains(cx.tcx.region_map, superblock,\n-                                          subblock) {\n-                    ret some(super);\n-                } else {\n-                    ret none;\n-                }\n-            }\n+        // Outer regions are subtypes of inner regions. (This is somewhat\n+        // surprising!)\n+        let superscope = region::region_to_scope(cx.tcx.region_map, super);\n+        let subscope = region::region_to_scope(cx.tcx.region_map, sub);\n+        if region::scope_contains(cx.tcx.region_map, subscope, superscope) {\n+            ret some(super);\n         }\n+        ret none;\n     }\n \n     fn unify_step(cx: @uctxt, expected: t, actual: t,"}]}