{"sha": "cf5f80c68d8e924a6a578e975cd92cc018a11983", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmNWY4MGM2OGQ4ZTkyNGE2YTU3OGU5NzVjZDkyY2MwMThhMTE5ODM=", "commit": {"author": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2016-11-23T15:19:22Z"}, "committer": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2016-12-14T17:28:24Z"}, "message": "Fix having multiple reprs on the same type.\n\nThis bug has applied to master for an indefinite period of time and is orthogonal to univariant layout optimization.", "tree": {"sha": "ff608626be72f9c7b3a07f41729c0f3fb0ebfd2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff608626be72f9c7b3a07f41729c0f3fb0ebfd2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf5f80c68d8e924a6a578e975cd92cc018a11983", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf5f80c68d8e924a6a578e975cd92cc018a11983", "html_url": "https://github.com/rust-lang/rust/commit/cf5f80c68d8e924a6a578e975cd92cc018a11983", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf5f80c68d8e924a6a578e975cd92cc018a11983/comments", "author": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74f5c61d288fdd925968aca49d1fd82f6e226ff8", "url": "https://api.github.com/repos/rust-lang/rust/commits/74f5c61d288fdd925968aca49d1fd82f6e226ff8", "html_url": "https://github.com/rust-lang/rust/commit/74f5c61d288fdd925968aca49d1fd82f6e226ff8"}], "stats": {"total": 178, "additions": 124, "deletions": 54}, "files": [{"sha": "f580730064c36436b09213d6ae0989c326135381", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 79, "deletions": 53, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/cf5f80c68d8e924a6a578e975cd92cc018a11983/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5f80c68d8e924a6a578e975cd92cc018a11983/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=cf5f80c68d8e924a6a578e975cd92cc018a11983", "patch": "@@ -416,7 +416,7 @@ impl Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u64 values above i64::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    pub fn repr_discr(tcx: TyCtxt, ty: Ty, hint: attr::ReprAttr, min: i64, max: i64)\n+    fn repr_discr(tcx: TyCtxt, ty: Ty, hints: &[attr::ReprAttr], min: i64, max: i64)\n                       -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n@@ -425,33 +425,44 @@ impl Integer {\n         let unsigned_fit = Integer::fit_unsigned(cmp::max(min as u64, max as u64));\n         let signed_fit = cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));\n \n-        let at_least = match hint {\n-            attr::ReprInt(ity) => {\n-                let discr = Integer::from_attr(&tcx.data_layout, ity);\n-                let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n-                if discr < fit {\n-                    bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n-                          discriminant range of enum `{}\", ty)\n+        let mut min_from_extern = None;\n+        let min_default = I8;\n+\n+        for &r in hints.iter() {\n+            match r {\n+                attr::ReprInt(ity) => {\n+                    let discr = Integer::from_attr(&tcx.data_layout, ity);\n+                    let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n+                    if discr < fit {\n+                        bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n+                              discriminant range of enum `{}\", ty)\n+                    }\n+                    return (discr, ity.is_signed());\n                 }\n-                return (discr, ity.is_signed());\n-            }\n-            attr::ReprExtern => {\n-                match &tcx.sess.target.target.arch[..] {\n-                    // WARNING: the ARM EABI has two variants; the one corresponding\n-                    // to `at_least == I32` appears to be used on Linux and NetBSD,\n-                    // but some systems may use the variant corresponding to no\n-                    // lower bound.  However, we don't run on those yet...?\n-                    \"arm\" => I32,\n-                    _ => I32,\n+                attr::ReprExtern => {\n+                    match &tcx.sess.target.target.arch[..] {\n+                        // WARNING: the ARM EABI has two variants; the one corresponding\n+                        // to `at_least == I32` appears to be used on Linux and NetBSD,\n+                        // but some systems may use the variant corresponding to no\n+                        // lower bound.  However, we don't run on those yet...?\n+                        \"arm\" => min_from_extern = Some(I32),\n+                        _ => min_from_extern = Some(I32),\n+                    }\n+                }\n+                attr::ReprAny => {},\n+                attr::ReprPacked => {\n+                    bug!(\"Integer::repr_discr: found #[repr(packed)] on enum `{}\", ty);\n+                }\n+                attr::ReprSimd => {\n+                    bug!(\"Integer::repr_discr: found #[repr(simd)] on enum `{}\", ty);\n                 }\n             }\n-            attr::ReprAny => I8,\n-            attr::ReprPacked => {\n-                bug!(\"Integer::repr_discr: found #[repr(packed)] on enum `{}\", ty);\n-            }\n-            attr::ReprSimd => {\n-                bug!(\"Integer::repr_discr: found #[repr(simd)] on enum `{}\", ty);\n-            }\n+        }\n+\n+        let at_least = if let Some(i) = min_from_extern {\n+            i\n+        } else {\n+            min_default\n         };\n \n         // If there are no negative values, we can use the unsigned fit.\n@@ -536,10 +547,11 @@ enum StructKind {\n }\n \n impl<'a, 'gcx, 'tcx> Struct {\n+    // FIXME(camlorn): reprs need a better representation to deal with multiple reprs on one type.\n     fn new(dl: &TargetDataLayout, fields: &Vec<&'a Layout>,\n-                  repr: attr::ReprAttr, kind: StructKind,\n+                  reprs: &[attr::ReprAttr], kind: StructKind,\n                   scapegoat: Ty<'gcx>) -> Result<Struct, LayoutError<'gcx>> {\n-        let packed = repr == attr::ReprPacked;\n+        let packed = reprs.contains(&attr::ReprPacked);\n         let mut ret = Struct {\n             align: if packed { dl.i8_align } else { dl.aggregate_align },\n             packed: packed,\n@@ -549,23 +561,37 @@ impl<'a, 'gcx, 'tcx> Struct {\n             min_size: Size::from_bytes(0),\n         };\n \n-        // 1-member and 2-member structs don't optimize.\n+        if fields.len() == 0 {return Ok(ret)};\n+\n+        // Anything with ReprExtern or ReprPacked doesn't optimize.\n+        // Neither do  1-member and 2-member structs.\n         // In addition, code in trans assume that 2-element structs can become pairs.\n         // It's easier to just short-circuit here.\n-        let can_optimize_struct = fields.len() > 2;\n+        let mut can_optimize = fields.len() > 2 || StructKind::EnumVariant == kind;\n+        if can_optimize {\n+            // This exhaustive match makes new reprs force the adder to modify this function.\n+            // Otherwise, things can silently break.\n+            // Note the inversion, return true to stop matching.\n+            can_optimize = !reprs.iter().any(|r| {\n+                match *r {\n+                    attr::ReprAny => false,\n+                    attr::ReprInt(_) => false,\n+                    attr::ReprExtern => true,\n+                    attr::ReprPacked => true,\n+                    attr::ReprSimd => bug!(\"Simd  vectors should be represented as a layout::Vector\")\n+                }\n+            });\n+        }\n \n-        let (optimize, sort_ascending) = match (repr, kind) {\n-            (attr::ReprAny, StructKind::AlwaysSizedUnivariant) => (can_optimize_struct, false),\n-            (attr::ReprAny, StructKind::MaybeUnsizedUnivariant) => (can_optimize_struct, true),\n-            (attr::ReprAny, StructKind::EnumVariant) => {\n+        let (optimize, sort_ascending) = match kind {\n+            StructKind::AlwaysSizedUnivariant => (can_optimize, false),\n+            StructKind::MaybeUnsizedUnivariant => (can_optimize, true),\n+            StructKind::EnumVariant => {\n                 assert!(fields.len() >= 1, \"Enum variants must have discriminants.\");\n-                (true, fields[0].size(dl).bytes() == 1)\n+                (can_optimize, fields[0].size(dl).bytes() == 1)\n             }\n-            _ => (false, false)\n         };\n \n-        if fields.len() == 0 {return Ok(ret)};\n-\n         ret.offsets = vec![Size::from_bytes(0); fields.len()];\n         let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n \n@@ -590,6 +616,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n             }\n         }\n \n+        // inverse_memory_index holds field indices by increasing memory offset.\n         // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n         // We now write field offsets to the corresponding offset slot;\n         // field 5 with offset 0 puts 0 in offsets[5].\n@@ -1021,7 +1048,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // The never type.\n             ty::TyNever => Univariant {\n-                variant: Struct::new(dl, &vec![], attr::ReprAny,\n+                variant: Struct::new(dl, &vec![], &[],\n                   StructKind::AlwaysSizedUnivariant, ty)?,\n                 non_zero: false\n             },\n@@ -1076,12 +1103,12 @@ impl<'a, 'gcx, 'tcx> Layout {\n             ty::TyFnDef(..) => {\n                 Univariant {\n                     variant: Struct::new(dl, &vec![],\n-                      attr::ReprAny, StructKind::AlwaysSizedUnivariant, ty)?,\n+                      &[], StructKind::AlwaysSizedUnivariant, ty)?,\n                     non_zero: false\n                 }\n             }\n             ty::TyDynamic(_) => {\n-                let mut unit = Struct::new(dl, &vec![], attr::ReprAny,\n+                let mut unit = Struct::new(dl, &vec![], &[],\n                   StructKind::AlwaysSizedUnivariant, ty)?;\n                 unit.sized = false;\n                 Univariant { variant: unit, non_zero: false }\n@@ -1093,7 +1120,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let st = Struct::new(dl,\n                     &tys.map(|ty| ty.layout(infcx))\n                       .collect::<Result<Vec<_>, _>>()?,\n-                    attr::ReprAny,\n+                    &[],\n                     StructKind::AlwaysSizedUnivariant, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n@@ -1104,7 +1131,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let st = Struct::new(dl,\n                     &tys.iter().map(|ty| ty.layout(infcx))\n                       .collect::<Result<Vec<_>, _>>()?,\n-                    attr::ReprAny, StructKind::AlwaysSizedUnivariant, ty)?;\n+                    &[], StructKind::AlwaysSizedUnivariant, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n \n@@ -1128,17 +1155,16 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // ADTs.\n             ty::TyAdt(def, substs) => {\n-                let hint = *tcx.lookup_repr_hints(def.did).get(0)\n-                    .unwrap_or(&attr::ReprAny);\n+                let hints = &tcx.lookup_repr_hints(def.did)[..];\n \n                 if def.variants.is_empty() {\n                     // Uninhabitable; represent as unit\n                     // (Typechecking will reject discriminant-sizing attrs.)\n-                    assert_eq!(hint, attr::ReprAny);\n+                    assert_eq!(hints.len(), 0);\n \n                     return success(Univariant {\n                         variant: Struct::new(dl, &vec![],\n-                          hint, StructKind::AlwaysSizedUnivariant, ty)?,\n+                          &hints[..], StructKind::AlwaysSizedUnivariant, ty)?,\n                         non_zero: false\n                     });\n                 }\n@@ -1153,7 +1179,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         if x > max { max = x; }\n                     }\n \n-                    let (discr, signed) = Integer::repr_discr(tcx, ty, hint, min, max);\n+                    let (discr, signed) = Integer::repr_discr(tcx, ty, &hints[..], min, max);\n                     return success(CEnum {\n                         discr: discr,\n                         signed: signed,\n@@ -1163,7 +1189,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     });\n                 }\n \n-                if !def.is_enum() || def.variants.len() == 1 && hint == attr::ReprAny {\n+                if !def.is_enum() || def.variants.len() == 1 && hints.len() == 0 {\n                     // Struct, or union, or univariant enum equivalent to a struct.\n                     // (Typechecking will reject discriminant-sizing attrs.)\n \n@@ -1190,7 +1216,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         un.extend(dl, fields.iter().map(|&f| Ok(f)), ty)?;\n                         UntaggedUnion { variants: un }\n                     } else {\n-                        let st = Struct::new(dl, &fields, hint,\n+                        let st = Struct::new(dl, &fields, &hints[..],\n                           kind, ty)?;\n                         let non_zero = Some(def.did) == tcx.lang_items.non_zero();\n                         Univariant { variant: st, non_zero: non_zero }\n@@ -1213,7 +1239,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()\n                 }).collect::<Vec<_>>();\n \n-                if variants.len() == 2 && hint == attr::ReprAny {\n+                if variants.len() == 2 && hints.len() == 0 {\n                     // Nullable pointer optimization\n                     for discr in 0..2 {\n                         let other_fields = variants[1 - discr].iter().map(|ty| {\n@@ -1245,7 +1271,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         let st = Struct::new(dl,\n                             &variants[discr].iter().map(|ty| ty.layout(infcx))\n                               .collect::<Result<Vec<_>, _>>()?,\n-                            hint, StructKind::AlwaysSizedUnivariant, ty)?;\n+                            &hints[..], StructKind::AlwaysSizedUnivariant, ty)?;\n \n                         // We have to fix the last element of path here.\n                         let mut i = *path.last().unwrap();\n@@ -1265,7 +1291,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 // The general case.\n                 let discr_max = (variants.len() - 1) as i64;\n                 assert!(discr_max >= 0);\n-                let (min_ity, _) = Integer::repr_discr(tcx, ty, hint, 0, discr_max);\n+                let (min_ity, _) = Integer::repr_discr(tcx, ty, &hints[..], 0, discr_max);\n \n                 let mut align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);\n@@ -1283,7 +1309,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     fields.insert(0, &discr);\n                     let st = Struct::new(dl,\n                         &fields,\n-                        hint, StructKind::EnumVariant, ty)?;\n+                        &hints[..], StructKind::EnumVariant, ty)?;\n                     // Find the first field we can't move later\n                     // to make room for a larger discriminant.\n                     // It is important to skip the first field."}, {"sha": "7c6740d4fde52c07474113abf7f2a4e1d9ba4f73", "filename": "src/test/run-pass/multiple-reprs.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cf5f80c68d8e924a6a578e975cd92cc018a11983/src%2Ftest%2Frun-pass%2Fmultiple-reprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5f80c68d8e924a6a578e975cd92cc018a11983/src%2Ftest%2Frun-pass%2Fmultiple-reprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmultiple-reprs.rs?ref=cf5f80c68d8e924a6a578e975cd92cc018a11983", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use std::mem::size_of;\n+\n+// The two enums that follow are designed so that bugs trigger layout optimization.\n+// Specifically, if either of the following reprs used here is not detected by the compiler,\n+// then the sizes will be wrong.\n+\n+#[repr(C, u8)]\n+enum E1 {\n+    A(u8, u16, u8),\n+    B(u8, u16, u8)\n+}\n+\n+#[repr(u8, C)]\n+enum E2 {\n+    A(u8, u16, u8),\n+    B(u8, u16, u8)\n+}\n+\n+// From pr 37429\n+pub const SIZEOF_QUERY:      usize = 21;\n+\n+#[repr(C,packed)]\n+pub struct p0f_api_query {\n+    pub magic: u32,\n+    pub addr_type: u8,\n+    pub addr: [u8; 16],\n+    \n+}\n+pub fn main() {\n+    assert_eq!(size_of::<E1>(), 6);\n+    assert_eq!(size_of::<E2>(), 6);\n+    assert_eq!(size_of::<p0f_api_query>(), 21);\n+}"}, {"sha": "bbb01eaaf46b9b43afbdbf4bdbf4c7ebfbf4aa61", "filename": "src/test/run-pass/type-sizes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf5f80c68d8e924a6a578e975cd92cc018a11983/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5f80c68d8e924a6a578e975cd92cc018a11983/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-sizes.rs?ref=cf5f80c68d8e924a6a578e975cd92cc018a11983", "patch": "@@ -26,7 +26,7 @@ enum e2 {\n     a(u32), b\n }\n \n-#[repr(u8)]\n+#[repr(C, u8)]\n enum e3 {\n     a([u16; 0], u8), b\n }"}]}