{"sha": "de38015e47c3d0c12995e378436a04a92844a0b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMzgwMTVlNDdjM2QwYzEyOTk1ZTM3ODQzNmEwNGE5Mjg0NGEwYjc=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2016-10-01T13:33:07Z"}, "committer": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2016-10-01T13:33:07Z"}, "message": "rustup", "tree": {"sha": "8f3b28510b42d3df9e6640719c0779fe1b3cad57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f3b28510b42d3df9e6640719c0779fe1b3cad57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de38015e47c3d0c12995e378436a04a92844a0b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de38015e47c3d0c12995e378436a04a92844a0b7", "html_url": "https://github.com/rust-lang/rust/commit/de38015e47c3d0c12995e378436a04a92844a0b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de38015e47c3d0c12995e378436a04a92844a0b7/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9680dbb100442c9bad2712972bb50097089023d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9680dbb100442c9bad2712972bb50097089023d", "html_url": "https://github.com/rust-lang/rust/commit/d9680dbb100442c9bad2712972bb50097089023d"}], "stats": {"total": 83, "additions": 35, "deletions": 48}, "files": [{"sha": "515b54e4bfd5f675058ddea885724d10b26f499f", "filename": "src/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de38015e47c3d0c12995e378436a04a92844a0b7/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de38015e47c3d0c12995e378436a04a92844a0b7/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=de38015e47c3d0c12995e378436a04a92844a0b7", "patch": "@@ -138,5 +138,5 @@ fn main() {\n         args.push(find_sysroot());\n     }\n \n-    rustc_driver::run_compiler(&args, &mut MiriCompilerCalls);\n+    rustc_driver::run_compiler(&args, &mut MiriCompilerCalls, None, None);\n }"}, {"sha": "722167a4175a0f3c3912a6ef45ca013a04a675d4", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 16, "deletions": 37, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/de38015e47c3d0c12995e378436a04a92844a0b7/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de38015e47c3d0c12995e378436a04a92844a0b7/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=de38015e47c3d0c12995e378436a04a92844a0b7", "patch": "@@ -73,23 +73,13 @@ pub struct Frame<'a, 'tcx: 'a> {\n     // Return pointer and local allocations\n     ////////////////////////////////////////////////////////////////////////////////\n \n-    /// A pointer for writing the return value of the current call if it's not a diverging call.\n-    pub return_ptr: Option<Pointer>,\n-\n     /// The block to return to when returning from the current stack frame\n     pub return_to_block: StackPopCleanup,\n \n     /// The list of locals for the current function, stored in order as\n-    /// `[arguments..., variables..., temporaries...]`. The variables begin at `self.var_offset`\n-    /// and the temporaries at `self.temp_offset`.\n+    /// `[return_ptr, arguments..., variables..., temporaries...]`.\n     pub locals: Vec<Pointer>,\n \n-    /// The offset of the first variable in `self.locals`.\n-    pub var_offset: usize,\n-\n-    /// The offset of the first temporary in `self.locals`.\n-    pub temp_offset: usize,\n-\n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -336,32 +326,26 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         span: codemap::Span,\n         mir: CachedMir<'a, 'tcx>,\n         substs: &'tcx Substs<'tcx>,\n-        return_ptr: Option<Pointer>,\n+        return_ptr: Pointer,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx, ()> {\n-        let arg_tys = mir.arg_decls.iter().map(|a| a.ty);\n-        let var_tys = mir.var_decls.iter().map(|v| v.ty);\n-        let temp_tys = mir.temp_decls.iter().map(|t| t.ty);\n-\n-        let num_args = mir.arg_decls.len();\n-        let num_vars = mir.var_decls.len();\n+        let local_tys = mir.local_decls.iter().map(|a| a.ty);\n \n         ::log_settings::settings().indentation += 1;\n \n-        let locals: EvalResult<'tcx, Vec<Pointer>> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n+        // directly change the first allocation (the return value) to *be* the allocation where the\n+        // caller stores the result\n+        let locals: EvalResult<'tcx, Vec<Pointer>> = iter::once(Ok(return_ptr)).chain(local_tys.skip(1).map(|ty| {\n             let size = self.type_size_with_substs(ty, substs);\n             let align = self.type_align_with_substs(ty, substs);\n             self.memory.allocate(size, align)\n-        }).collect();\n+        })).collect();\n \n         self.stack.push(Frame {\n             mir: mir.clone(),\n             block: mir::START_BLOCK,\n-            return_ptr: return_ptr,\n             return_to_block: return_to_block,\n             locals: locals?,\n-            var_offset: num_args,\n-            temp_offset: num_args + num_vars,\n             span: span,\n             def_id: def_id,\n             substs: substs,\n@@ -793,11 +777,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue> {\n         use rustc::mir::repr::Lvalue::*;\n         let ptr = match *lvalue {\n-            ReturnPointer => self.frame().return_ptr\n-                .expect(\"ReturnPointer used in a function with no return value\"),\n-            Arg(i) => self.frame().locals[i.index()],\n-            Var(i) => self.frame().locals[self.frame().var_offset + i.index()],\n-            Temp(i) => self.frame().locals[self.frame().temp_offset + i.index()],\n+            Local(i) => self.frame().locals[i.index()],\n \n             Static(def_id) => {\n                 let substs = subst::Substs::empty(self.tcx);\n@@ -1219,18 +1199,17 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     let return_ptr = ecx.alloc_ret_ptr(mir.return_ty, substs)\n         .expect(\"should at least be able to allocate space for the main function's return value\");\n \n-    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr), StackPopCleanup::None)\n+    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, return_ptr, StackPopCleanup::None)\n         .expect(\"could not allocate first stack frame\");\n \n-    if mir.arg_decls.len() == 2 {\n+    // FIXME: this is a horrible and wrong way to detect the start function, but overwriting the first two locals shouldn't do much\n+    if mir.local_decls.len() > 2 {\n         // start function\n-        let ptr_size = ecx.memory().pointer_size();\n-        let nargs = ecx.memory_mut().allocate(ptr_size, ptr_size).expect(\"can't allocate memory for nargs\");\n-        ecx.memory_mut().write_usize(nargs, 0).unwrap();\n-        let args = ecx.memory_mut().allocate(ptr_size, ptr_size).expect(\"can't allocate memory for arg pointer\");\n-        ecx.memory_mut().write_usize(args, 0).unwrap();\n-        ecx.frame_mut().locals[0] = nargs;\n-        ecx.frame_mut().locals[1] = args;\n+        let nargs = ecx.frame_mut().locals[1];\n+        let args = ecx.frame_mut().locals[2];\n+        // ignore errors, if the locals are too small this is not the start function\n+        let _ = ecx.memory_mut().write_usize(nargs, 0);\n+        let _ = ecx.memory_mut().write_usize(args, 0);\n     }\n \n     for _ in 0..step_limit {"}, {"sha": "77350504306b6134afa749a2648bf6b6d00b6cbd", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de38015e47c3d0c12995e378436a04a92844a0b7/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de38015e47c3d0c12995e378436a04a92844a0b7/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=de38015e47c3d0c12995e378436a04a92844a0b7", "patch": "@@ -134,7 +134,7 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n             } else {\n                 StackPopCleanup::None\n             };\n-            this.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr), cleanup)\n+            this.ecx.push_stack_frame(def_id, span, mir, substs, ptr, cleanup)\n         });\n     }\n     fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, ()>>(&mut self, f: F) {\n@@ -183,7 +183,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                                               constant.span,\n                                               mir,\n                                               this.substs,\n-                                              Some(return_ptr),\n+                                              return_ptr,\n                                               StackPopCleanup::Freeze(return_ptr.alloc_id))\n                 });\n             }"}, {"sha": "e0e6e3996c4006480209f6baac73ba9f67061a14", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de38015e47c3d0c12995e378436a04a92844a0b7/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de38015e47c3d0c12995e378436a04a92844a0b7/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=de38015e47c3d0c12995e378436a04a92844a0b7", "patch": "@@ -186,13 +186,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let mir = self.load_mir(resolved_def_id)?;\n                 let (return_ptr, return_to_block) = match destination {\n-                    Some((ptr, block)) => (Some(ptr), StackPopCleanup::Goto(block)),\n-                    None => (None, StackPopCleanup::None),\n+                    Some((ptr, block)) => (ptr, StackPopCleanup::Goto(block)),\n+                    None => (Pointer::never_ptr(), StackPopCleanup::None),\n                 };\n                 self.push_stack_frame(resolved_def_id, span, mir, resolved_substs, return_ptr, return_to_block)?;\n \n                 for (i, (arg_val, arg_ty)) in args.into_iter().enumerate() {\n-                    let dest = self.frame().locals[i];\n+                    // argument start at index 1, since index 0 is reserved for the return allocation\n+                    let dest = self.frame().locals[i + 1];\n                     self.write_value(arg_val, dest, arg_ty)?;\n                 }\n "}, {"sha": "da1214acfb8ad3ab5d9de1728ddd1b8dda4741b8", "filename": "src/memory.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/de38015e47c3d0c12995e378436a04a92844a0b7/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de38015e47c3d0c12995e378436a04a92844a0b7/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=de38015e47c3d0c12995e378436a04a92844a0b7", "patch": "@@ -56,10 +56,10 @@ impl Pointer {\n         self.alloc_id == ZST_ALLOC_ID\n     }\n     pub fn to_int<'tcx>(&self) -> EvalResult<'tcx, usize> {\n-        if self.points_to_zst() {\n-            Ok(self.offset)\n-        } else {\n-            Err(EvalError::ReadPointerAsBytes)\n+        match self.alloc_id {\n+            NEVER_ALLOC_ID |\n+            ZST_ALLOC_ID => Ok(self.offset),\n+            _ => Err(EvalError::ReadPointerAsBytes),\n         }\n     }\n     pub fn from_int(i: usize) -> Self {\n@@ -74,6 +74,12 @@ impl Pointer {\n             offset: 0,\n         }\n     }\n+    pub fn never_ptr() -> Self {\n+        Pointer {\n+            alloc_id: NEVER_ALLOC_ID,\n+            offset: 0,\n+        }\n+    }\n }\n \n #[derive(Debug, Clone, Hash, Eq, PartialEq)]\n@@ -115,14 +121,15 @@ pub struct Memory<'a, 'tcx> {\n }\n \n const ZST_ALLOC_ID: AllocId = AllocId(0);\n+const NEVER_ALLOC_ID: AllocId = AllocId(1);\n \n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn new(layout: &'a TargetDataLayout, max_memory: usize) -> Self {\n         Memory {\n             alloc_map: HashMap::new(),\n             functions: HashMap::new(),\n             function_alloc_cache: HashMap::new(),\n-            next_id: AllocId(1),\n+            next_id: AllocId(2),\n             layout: layout,\n             memory_size: max_memory,\n             memory_usage: 0,"}]}