{"sha": "80447c38aaf680f15c5bd37e154fb0bf01b68573", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwNDQ3YzM4YWFmNjgwZjE1YzViZDM3ZTE1NGZiMGJmMDFiNjg1NzM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-02T12:35:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-02T12:35:48Z"}, "message": "limit and clear cache obligations opportunistically\n\nKeep **all** the obligations for every projection is wasteful of\nmemory and compilation time. We only really care about those\nsubobligations that may inform the result of the projection (i.e., may\nhelp to resolve any inference variables that appear within).\nTherefore, we can clear the subobligations from the cache that don't\npotentially affect the result of the projection. On every cache hit,\nwe also take the opportunity to check if the type variables have been\nresolved *yet* and, if so, clear out the pending obligations.\n\nFixes #43613", "tree": {"sha": "999a7c069519728a1b49268d5975af4372da46f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/999a7c069519728a1b49268d5975af4372da46f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80447c38aaf680f15c5bd37e154fb0bf01b68573", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80447c38aaf680f15c5bd37e154fb0bf01b68573", "html_url": "https://github.com/rust-lang/rust/commit/80447c38aaf680f15c5bd37e154fb0bf01b68573", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80447c38aaf680f15c5bd37e154fb0bf01b68573/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed532c0d933aaae45e6804efc5936bea078bbaad", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed532c0d933aaae45e6804efc5936bea078bbaad", "html_url": "https://github.com/rust-lang/rust/commit/ed532c0d933aaae45e6804efc5936bea078bbaad"}], "stats": {"total": 119, "additions": 111, "deletions": 8}, "files": [{"sha": "d838b2226e863efbd030175baa6c150ef16c242c", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/80447c38aaf680f15c5bd37e154fb0bf01b68573/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80447c38aaf680f15c5bd37e154fb0bf01b68573/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=80447c38aaf680f15c5bd37e154fb0bf01b68573", "patch": "@@ -1160,6 +1160,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         value.fold_with(&mut r)\n     }\n \n+    /// Returns true if `T` contains unresolved type variables. In the\n+    /// process of visiting `T`, this will resolve (where possible)\n+    /// type variables in `T`, but it never constructs the final,\n+    /// resolved type, so it's more efficient than\n+    /// `resolve_type_vars_if_possible()`.\n+    pub fn any_unresolved_type_vars<T>(&self, value: &T) -> bool\n+        where T: TypeFoldable<'tcx>\n+    {\n+        let mut r = resolve::UnresolvedTypeFinder::new(self);\n+        value.visit_with(&mut r)\n+    }\n+\n     pub fn resolve_type_and_region_vars_if_possible<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {"}, {"sha": "10899e42afb819b74ad124db8506ca87a939f930", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/80447c38aaf680f15c5bd37e154fb0bf01b68573/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80447c38aaf680f15c5bd37e154fb0bf01b68573/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=80447c38aaf680f15c5bd37e154fb0bf01b68573", "patch": "@@ -10,7 +10,7 @@\n \n use super::{InferCtxt, FixupError, FixupResult};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::fold::TypeFolder;\n+use ty::fold::{TypeFolder, TypeVisitor};\n \n ///////////////////////////////////////////////////////////////////////////\n // OPPORTUNISTIC TYPE RESOLVER\n@@ -80,6 +80,43 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// UNRESOLVED TYPE FINDER\n+\n+/// The unresolved type **finder** walks your type and searches for\n+/// type variables that don't yet have a value. They get pushed into a\n+/// vector. It does not construct the fully resolved type (which might\n+/// involve some hashing and so forth).\n+pub struct UnresolvedTypeFinder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> UnresolvedTypeFinder<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        UnresolvedTypeFinder { infcx }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'gcx, 'tcx> {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        let t = self.infcx.shallow_resolve(t);\n+        if t.has_infer_types() {\n+            if let ty::TyInfer(_) = t.sty {\n+                // Since we called `shallow_resolve` above, this must\n+                // be an (as yet...) unresolved inference variable.\n+                true\n+            } else {\n+                // Otherwise, visit its contents.\n+                t.super_visit_with(self)\n+            }\n+        } else {\n+            // Micro-optimize: no inference types at all Can't have unresolved type\n+            // variables, no need to visit the contents.\n+            false\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // FULL TYPE RESOLUTION\n "}, {"sha": "242281a0c77263069bdc1ba25eda1fbe92f5ad9b", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 57, "deletions": 7, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/80447c38aaf680f15c5bd37e154fb0bf01b68573/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80447c38aaf680f15c5bd37e154fb0bf01b68573/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=80447c38aaf680f15c5bd37e154fb0bf01b68573", "patch": "@@ -25,7 +25,7 @@ use super::VtableImplData;\n use super::util;\n \n use hir::def_id::DefId;\n-use infer::InferOk;\n+use infer::{InferCtxt, InferOk};\n use infer::type_variable::TypeVariableOrigin;\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use syntax::ast;\n@@ -416,7 +416,8 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     // bounds. It might be the case that we want two distinct caches,\n     // or else another kind of cache entry.\n \n-    match infcx.projection_cache.borrow_mut().try_start(cache_key) {\n+    let cache_result = infcx.projection_cache.borrow_mut().try_start(cache_key);\n+    match cache_result {\n         Ok(()) => { }\n         Err(ProjectionCacheEntry::Ambiguous) => {\n             // If we found ambiguity the last time, that generally\n@@ -466,7 +467,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                                                     projection_ty);\n             selcx.infcx().report_overflow_error(&obligation, false);\n         }\n-        Err(ProjectionCacheEntry::NormalizedTy(ty)) => {\n+        Err(ProjectionCacheEntry::NormalizedTy(mut ty)) => {\n             // If we find the value in the cache, then return it along\n             // with the obligations that went along with it. Note\n             // that, when using a fulfillment context, these\n@@ -479,6 +480,14 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             debug!(\"opt_normalize_projection_type: \\\n                     found normalized ty `{:?}`\",\n                    ty);\n+\n+            // Once we have inferred everything we need to know, we\n+            // can ignore the `obligations` from that point on.\n+            if !infcx.any_unresolved_type_vars(&ty.value) {\n+                infcx.projection_cache.borrow_mut().complete(cache_key);\n+                ty.obligations = vec![];\n+            }\n+\n             return Some(ty);\n         }\n         Err(ProjectionCacheEntry::Error) => {\n@@ -527,7 +536,10 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                     obligations,\n                 }\n             };\n-            infcx.projection_cache.borrow_mut().insert_ty(cache_key, &result);\n+\n+            let cache_value = prune_cache_value_obligations(infcx, &result);\n+            infcx.projection_cache.borrow_mut().insert_ty(cache_key, cache_value);\n+\n             Some(result)\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n@@ -538,7 +550,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                 value: projected_ty,\n                 obligations: vec![]\n             };\n-            infcx.projection_cache.borrow_mut().insert_ty(cache_key, &result);\n+            infcx.projection_cache.borrow_mut().insert_ty(cache_key, result.clone());\n             Some(result)\n         }\n         Err(ProjectionTyError::TooManyCandidates) => {\n@@ -562,6 +574,44 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     }\n }\n \n+/// If there are unresolved type variables, then we need to include\n+/// any subobligations that bind them, at least until those type\n+/// variables are fully resolved.\n+fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                                                 result: &NormalizedTy<'tcx>)\n+                                                 -> NormalizedTy<'tcx> {\n+    if !infcx.any_unresolved_type_vars(&result.value) {\n+        return NormalizedTy { value: result.value, obligations: vec![] };\n+    }\n+\n+    let mut obligations: Vec<_> =\n+        result.obligations\n+              .iter()\n+              .filter(|obligation| match obligation.predicate {\n+                  // We found a `T: Foo<X = U>` predicate, let's check\n+                  // if `U` references any unresolved type\n+                  // variables. In principle, we only care if this\n+                  // projection can help resolve any of the type\n+                  // variables found in `result.value` -- but we just\n+                  // check for any type variables here, for fear of\n+                  // indirect obligations (e.g., we project to `?0`,\n+                  // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n+                  // ?0>`).\n+                  ty::Predicate::Projection(ref data) =>\n+                      !infcx.any_unresolved_type_vars(&data.ty()),\n+\n+                  // We are only interested in `T: Foo<X = U>` predicates, whre\n+                  // `U` references one of `unresolved_type_vars`. =)\n+                  _ => false,\n+              })\n+              .cloned()\n+              .collect();\n+\n+    obligations.shrink_to_fit();\n+\n+    NormalizedTy { value: result.value, obligations }\n+}\n+\n /// If we are projecting `<T as Trait>::Item`, but `T: Trait` does not\n /// hold. In various error cases, we cannot generate a valid\n /// normalized projection. Therefore, we create an inference variable\n@@ -1493,10 +1543,10 @@ impl<'tcx> ProjectionCache<'tcx> {\n     }\n \n     /// Indicates that `key` was normalized to `value`.\n-    fn insert_ty(&mut self, key: ProjectionCacheKey<'tcx>, value: &NormalizedTy<'tcx>) {\n+    fn insert_ty(&mut self, key: ProjectionCacheKey<'tcx>, value: NormalizedTy<'tcx>) {\n         debug!(\"ProjectionCacheEntry::insert_ty: adding cache entry: key={:?}, value={:?}\",\n                key, value);\n-        let fresh_key = self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value.clone()));\n+        let fresh_key = self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value));\n         assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n     }\n "}, {"sha": "1920cdb3f738f86fc1495334ce6f7b445ee80cc9", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80447c38aaf680f15c5bd37e154fb0bf01b68573/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80447c38aaf680f15c5bd37e154fb0bf01b68573/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=80447c38aaf680f15c5bd37e154fb0bf01b68573", "patch": "@@ -1017,6 +1017,10 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         // levels.\n         ty::Binder(self.0.projection_ty.trait_ref(tcx))\n     }\n+\n+    pub fn ty(&self) -> Binder<Ty<'tcx>> {\n+        Binder(self.skip_binder().ty) // preserves binding levels\n+    }\n }\n \n pub trait ToPolyTraitRef<'tcx> {"}]}