{"sha": "3d211248393686e0f73851fc7548f6605220fbe1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMjExMjQ4MzkzNjg2ZTBmNzM4NTFmYzc1NDhmNjYwNTIyMGZiZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-25T00:53:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-25T00:53:28Z"}, "message": "Auto merge of #59042 - ljedrz:HirIdification_rework_map, r=Zoxc\n\nHirIdification: rework Map\n\nThe next iteration of HirIdification (#57578).\n\n- remove `NodeId` from `Entry`\n- change `Map::map` to an `FxHashMap<HirId, Entry>`\n- base the `NodeId` `Map` methods on `HirId` ones (reverses the current state)\n- HirIdify `librustdoc` a little bit (some `NodeId` `Map` methods were converted to work on `HirId`s)\n\nThe second change might have performance implications, so I'd do a perf run to be sure it's fine; it simplifies the codebase and shouldn't have an impact as long as the `Map` searches are cached (which is now possible thanks to using `HirId`s).\n\nr? @Zoxc", "tree": {"sha": "3c84f4b67b3f51e8f17e0aafdcc77cdb6ed9775a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c84f4b67b3f51e8f17e0aafdcc77cdb6ed9775a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d211248393686e0f73851fc7548f6605220fbe1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d211248393686e0f73851fc7548f6605220fbe1", "html_url": "https://github.com/rust-lang/rust/commit/3d211248393686e0f73851fc7548f6605220fbe1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d211248393686e0f73851fc7548f6605220fbe1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e305df1846a6d985315917ae0c81b74af8b4e641", "url": "https://api.github.com/repos/rust-lang/rust/commits/e305df1846a6d985315917ae0c81b74af8b4e641", "html_url": "https://github.com/rust-lang/rust/commit/e305df1846a6d985315917ae0c81b74af8b4e641"}, {"sha": "37954df1a71b204174719f28c59be8b38fd439f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/37954df1a71b204174719f28c59be8b38fd439f0", "html_url": "https://github.com/rust-lang/rust/commit/37954df1a71b204174719f28c59be8b38fd439f0"}], "stats": {"total": 389, "additions": 184, "deletions": 205}, "files": [{"sha": "50bd89a1589645d688d15ff719d2366d51afeb14", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3d211248393686e0f73851fc7548f6605220fbe1/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d211248393686e0f73851fc7548f6605220fbe1/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=3d211248393686e0f73851fc7548f6605220fbe1", "patch": "@@ -8,8 +8,8 @@ use crate::ich::Fingerprint;\n use crate::middle::cstore::CrateStore;\n use crate::session::CrateDisambiguator;\n use crate::session::Session;\n-use std::iter::repeat;\n-use syntax::ast::{NodeId, CRATE_NODE_ID};\n+use crate::util::nodemap::FxHashMap;\n+use syntax::ast::NodeId;\n use syntax::source_map::SourceMap;\n use syntax_pos::Span;\n \n@@ -25,7 +25,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     source_map: &'a SourceMap,\n \n     /// The node map\n-    map: Vec<Option<Entry<'hir>>>,\n+    map: FxHashMap<HirId, Entry<'hir>>,\n     /// The parent of this node\n     parent_node: hir::HirId,\n \n@@ -145,7 +145,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         let mut collector = NodeCollector {\n             krate,\n             source_map: sess.source_map(),\n-            map: repeat(None).take(sess.current_node_id_count()).collect(),\n+            map: FxHashMap::with_capacity_and_hasher(sess.current_node_id_count(),\n+                Default::default()),\n             parent_node: hir::CRATE_HIR_ID,\n             current_signature_dep_index: root_mod_sig_dep_index,\n             current_full_dep_index: root_mod_full_dep_index,\n@@ -157,9 +158,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             hcx,\n             hir_body_nodes,\n         };\n-        collector.insert_entry(CRATE_NODE_ID, Entry {\n-            parent: CRATE_NODE_ID,\n-            parent_hir: hir::CRATE_HIR_ID,\n+        collector.insert_entry(hir::CRATE_HIR_ID, Entry {\n+            parent: hir::CRATE_HIR_ID,\n             dep_node: root_mod_sig_dep_index,\n             node: Node::Crate,\n         });\n@@ -171,7 +171,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                                                   crate_disambiguator: CrateDisambiguator,\n                                                   cstore: &dyn CrateStore,\n                                                   commandline_args_hash: u64)\n-                                                  -> (Vec<Option<Entry<'hir>>>, Svh)\n+                                                  -> (FxHashMap<HirId, Entry<'hir>>, Svh)\n     {\n         self.hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\n \n@@ -222,15 +222,14 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         (self.map, svh)\n     }\n \n-    fn insert_entry(&mut self, id: NodeId, entry: Entry<'hir>) {\n+    fn insert_entry(&mut self, id: HirId, entry: Entry<'hir>) {\n         debug!(\"hir_map: {:?} => {:?}\", id, entry);\n-        self.map[id.as_usize()] = Some(entry);\n+        self.map.insert(id, entry);\n     }\n \n     fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {\n         let entry = Entry {\n-            parent: self.hir_to_node_id[&self.parent_node],\n-            parent_hir: self.parent_node,\n+            parent: self.parent_node,\n             dep_node: if self.currently_in_body {\n                 self.current_full_dep_index\n             } else {\n@@ -239,12 +238,11 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             node,\n         };\n \n-        let node_id = self.hir_to_node_id[&hir_id];\n-\n         // Make sure that the DepNode of some node coincides with the HirId\n         // owner of that node.\n         if cfg!(debug_assertions) {\n-           assert_eq!(self.definitions.node_to_hir_id(node_id), hir_id);\n+            let node_id = self.hir_to_node_id[&hir_id];\n+            assert_eq!(self.definitions.node_to_hir_id(node_id), hir_id);\n \n             if hir_id.owner != self.current_dep_node_owner {\n                 let node_str = match self.definitions.opt_def_index(node_id) {\n@@ -277,7 +275,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             }\n         }\n \n-        self.insert_entry(node_id, entry);\n+        self.insert_entry(hir_id, entry);\n     }\n \n     fn with_parent<F: FnOnce(&mut Self)>("}, {"sha": "9e95f0acfeb794a7d59aa4da9765e31676111b5a", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 146, "deletions": 159, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/3d211248393686e0f73851fc7548f6605220fbe1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d211248393686e0f73851fc7548f6605220fbe1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=3d211248393686e0f73851fc7548f6605220fbe1", "patch": "@@ -11,7 +11,7 @@ use crate::middle::cstore::CrateStoreDyn;\n \n use rustc_target::spec::abi::Abi;\n use rustc_data_structures::svh::Svh;\n-use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n+use syntax::ast::{self, Name, NodeId};\n use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -38,14 +38,13 @@ pub const REGULAR_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n /// Represents an entry and its parent `NodeId`.\n #[derive(Copy, Clone, Debug)]\n pub struct Entry<'hir> {\n-    parent: NodeId,\n-    parent_hir: HirId,\n+    parent: HirId,\n     dep_node: DepNodeIndex,\n     node: Node<'hir>,\n }\n \n impl<'hir> Entry<'hir> {\n-    fn parent_node(self) -> Option<NodeId> {\n+    fn parent_node(self) -> Option<HirId> {\n         match self.node {\n             Node::Crate | Node::MacroDef(_) => None,\n             _ => Some(self.parent),\n@@ -183,7 +182,7 @@ pub struct Map<'hir> {\n     ///\n     /// Also, indexing is pretty quick when you've got a vector and\n     /// plain old integers.\n-    map: Vec<Option<Entry<'hir>>>,\n+    map: FxHashMap<HirId, Entry<'hir>>,\n \n     definitions: &'hir Definitions,\n \n@@ -200,17 +199,17 @@ impl<'hir> Map<'hir> {\n     /// read recorded). If the function just returns a DefId or\n     /// NodeId, no actual content was returned, so no read is needed.\n     pub fn read(&self, id: NodeId) {\n-        if let Some(entry) = self.map[id.as_usize()] {\n-            self.dep_graph.read_index(entry.dep_node);\n-        } else {\n-            bug!(\"called `HirMap::read()` with invalid `NodeId`: {:?}\", id)\n-        }\n+        let hir_id = self.node_to_hir_id(id);\n+        self.read_by_hir_id(hir_id);\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     pub fn read_by_hir_id(&self, hir_id: HirId) {\n-        let node_id = self.hir_to_node_id(hir_id);\n-        self.read(node_id);\n+        if let Some(entry) = self.map.get(&hir_id) {\n+            self.dep_graph.read_index(entry.dep_node);\n+        } else {\n+            bug!(\"called `HirMap::read()` with invalid `HirId`: {:?}\", hir_id)\n+        }\n     }\n \n     #[inline]\n@@ -242,18 +241,18 @@ impl<'hir> Map<'hir> {\n     #[inline]\n     pub fn local_def_id(&self, node: NodeId) -> DefId {\n         self.opt_local_def_id(node).unwrap_or_else(|| {\n+            let hir_id = self.node_to_hir_id(node);\n             bug!(\"local_def_id: no entry for `{}`, which has a map of `{:?}`\",\n-                 node, self.find_entry(node))\n+                 node, self.find_entry(hir_id))\n         })\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     #[inline]\n     pub fn local_def_id_from_hir_id(&self, hir_id: HirId) -> DefId {\n-        let node_id = self.hir_to_node_id(hir_id);\n-        self.opt_local_def_id(node_id).unwrap_or_else(|| {\n+        self.opt_local_def_id_from_hir_id(hir_id).unwrap_or_else(|| {\n             bug!(\"local_def_id_from_hir_id: no entry for `{:?}`, which has a map of `{:?}`\",\n-                 hir_id, self.find_entry(node_id))\n+                 hir_id, self.find_entry(hir_id))\n         })\n     }\n \n@@ -423,8 +422,8 @@ impl<'hir> Map<'hir> {\n         self.map.len()\n     }\n \n-    fn find_entry(&self, id: NodeId) -> Option<Entry<'hir>> {\n-        self.map.get(id.as_usize()).cloned().unwrap_or(None)\n+    fn find_entry(&self, id: HirId) -> Option<Entry<'hir>> {\n+        self.map.get(&id).cloned()\n     }\n \n     pub fn krate(&self) -> &'hir Crate {\n@@ -456,27 +455,26 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn fn_decl(&self, node_id: ast::NodeId) -> Option<FnDecl> {\n-        if let Some(entry) = self.find_entry(node_id) {\n-            entry.fn_decl().cloned()\n-        } else {\n-            bug!(\"no entry for node_id `{}`\", node_id)\n-        }\n+        let hir_id = self.node_to_hir_id(node_id);\n+        self.fn_decl_by_hir_id(hir_id)\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<FnDecl> {\n-        let node_id = self.hir_to_node_id(hir_id);\n-        self.fn_decl(node_id)\n+        if let Some(entry) = self.find_entry(hir_id) {\n+            entry.fn_decl().cloned()\n+        } else {\n+            bug!(\"no entry for hir_id `{}`\", hir_id)\n+        }\n     }\n \n     /// Returns the `NodeId` that corresponds to the definition of\n     /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n     pub fn body_owner(&self, BodyId { hir_id }: BodyId) -> NodeId {\n-        let node_id = self.hir_to_node_id(hir_id);\n-        let parent = self.get_parent_node(node_id);\n-        assert!(self.map[parent.as_usize()].map_or(false, |e| e.is_body_owner(hir_id)));\n-        parent\n+        let parent = self.get_parent_node_by_hir_id(hir_id);\n+        assert!(self.map.get(&parent).map_or(false, |e| e.is_body_owner(hir_id)));\n+        self.hir_to_node_id(parent)\n     }\n \n     pub fn body_owner_def_id(&self, id: BodyId) -> DefId {\n@@ -486,25 +484,25 @@ impl<'hir> Map<'hir> {\n     /// Given a `NodeId`, returns the `BodyId` associated with it,\n     /// if the node is a body owner, otherwise returns `None`.\n     pub fn maybe_body_owned_by(&self, id: NodeId) -> Option<BodyId> {\n-        if let Some(entry) = self.find_entry(id) {\n+        let hir_id = self.node_to_hir_id(id);\n+        self.maybe_body_owned_by_by_hir_id(hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn maybe_body_owned_by_by_hir_id(&self, hir_id: HirId) -> Option<BodyId> {\n+        if let Some(entry) = self.find_entry(hir_id) {\n             if self.dep_graph.is_fully_enabled() {\n-                let hir_id_owner = self.node_to_hir_id(id).owner;\n+                let hir_id_owner = hir_id.owner;\n                 let def_path_hash = self.definitions.def_path_hash(hir_id_owner);\n                 self.dep_graph.read(def_path_hash.to_dep_node(DepKind::HirBody));\n             }\n \n             entry.associated_body()\n         } else {\n-            bug!(\"no entry for id `{}`\", id)\n+            bug!(\"no entry for id `{}`\", hir_id)\n         }\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn maybe_body_owned_by_by_hir_id(&self, id: HirId) -> Option<BodyId> {\n-        let node_id = self.hir_to_node_id(id);\n-        self.maybe_body_owned_by(node_id)\n-    }\n-\n     /// Given a body owner's id, returns the `BodyId` associated with it.\n     pub fn body_owned_by(&self, id: HirId) -> BodyId {\n         self.maybe_body_owned_by_by_hir_id(id).unwrap_or_else(|| {\n@@ -514,7 +512,13 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn body_owner_kind(&self, id: NodeId) -> BodyOwnerKind {\n-        match self.get(id) {\n+        let hir_id = self.node_to_hir_id(id);\n+        self.body_owner_kind_by_hir_id(hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn body_owner_kind_by_hir_id(&self, id: HirId) -> BodyOwnerKind {\n+        match self.get_by_hir_id(id) {\n             Node::Item(&Item { node: ItemKind::Const(..), .. }) |\n             Node::TraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n             Node::ImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) |\n@@ -537,12 +541,6 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn body_owner_kind_by_hir_id(&self, id: HirId) -> BodyOwnerKind {\n-        let node_id = self.hir_to_node_id(id);\n-        self.body_owner_kind(node_id)\n-    }\n-\n     pub fn ty_param_owner(&self, id: HirId) -> HirId {\n         match self.get_by_hir_id(id) {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n@@ -579,11 +577,11 @@ impl<'hir> Map<'hir> {\n         &self.forest.krate.attrs\n     }\n \n-    pub fn get_module(&self, module: DefId) -> (&'hir Mod, Span, HirId) {\n-        let node_id = self.as_local_node_id(module).unwrap();\n-        let hir_id = self.node_to_hir_id(node_id);\n-        self.read(node_id);\n-        match self.find_entry(node_id).unwrap().node {\n+    pub fn get_module(&self, module: DefId) -> (&'hir Mod, Span, HirId)\n+    {\n+        let hir_id = self.as_local_hir_id(module).unwrap();\n+        self.read_by_hir_id(hir_id);\n+        match self.find_entry(hir_id).unwrap().node {\n             Node::Item(&Item {\n                 span,\n                 node: ItemKind::Mod(ref m),\n@@ -623,14 +621,15 @@ impl<'hir> Map<'hir> {\n     /// Retrieve the Node corresponding to `id`, panicking if it cannot\n     /// be found.\n     pub fn get(&self, id: NodeId) -> Node<'hir> {\n-        // read recorded by `find`\n-        self.find(id).unwrap_or_else(|| bug!(\"couldn't find node id {} in the AST map\", id))\n+        let hir_id = self.node_to_hir_id(id);\n+        self.get_by_hir_id(hir_id)\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     pub fn get_by_hir_id(&self, id: HirId) -> Node<'hir> {\n-        let node_id = self.hir_to_node_id(id);\n-        self.get(node_id)\n+        // read recorded by `find`\n+        self.find_by_hir_id(id).unwrap_or_else(||\n+            bug!(\"couldn't find hir id {} in the HIR map\", id))\n     }\n \n     pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n@@ -666,25 +665,25 @@ impl<'hir> Map<'hir> {\n \n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n     pub fn find(&self, id: NodeId) -> Option<Node<'hir>> {\n-        let result = self.find_entry(id).and_then(|entry| {\n+        let hir_id = self.node_to_hir_id(id);\n+        self.find_by_hir_id(hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn find_by_hir_id(&self, hir_id: HirId) -> Option<Node<'hir>> {\n+        let result = self.find_entry(hir_id).and_then(|entry| {\n             if let Node::Crate = entry.node {\n                 None\n             } else {\n                 Some(entry.node)\n             }\n         });\n         if result.is_some() {\n-            self.read(id);\n+            self.read_by_hir_id(hir_id);\n         }\n         result\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn find_by_hir_id(&self, hir_id: HirId) -> Option<Node<'hir>> {\n-        let node_id = self.hir_to_node_id(hir_id);\n-        self.find(node_id)\n-    }\n-\n     /// Similar to `get_parent`; returns the parent node-id, or own `id` if there is\n     /// no parent. Note that the parent may be `CRATE_NODE_ID`, which is not itself\n     /// present in the map -- so passing the return value of get_parent_node to\n@@ -696,20 +695,22 @@ impl<'hir> Map<'hir> {\n     /// from a node to the root of the ast (unless you get the same ID back here\n     /// that can happen if the ID is not in the map itself or is just weird).\n     pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n+        let hir_id = self.node_to_hir_id(id);\n+        let parent_hir_id = self.get_parent_node_by_hir_id(hir_id);\n+        self.hir_to_node_id(parent_hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_parent_node_by_hir_id(&self, hir_id: HirId) -> HirId {\n         if self.dep_graph.is_fully_enabled() {\n-            let hir_id_owner = self.node_to_hir_id(id).owner;\n+            let hir_id_owner = hir_id.owner;\n             let def_path_hash = self.definitions.def_path_hash(hir_id_owner);\n             self.dep_graph.read(def_path_hash.to_dep_node(DepKind::HirBody));\n         }\n \n-        self.find_entry(id).and_then(|x| x.parent_node()).unwrap_or(id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn get_parent_node_by_hir_id(&self, id: HirId) -> HirId {\n-        let node_id = self.hir_to_node_id(id);\n-        let parent_node_id = self.get_parent_node(node_id);\n-        self.node_to_hir_id(parent_node_id)\n+        self.find_entry(hir_id)\n+            .and_then(|x| x.parent_node())\n+            .unwrap_or(hir_id)\n     }\n \n     /// Check if the node is an argument. An argument is a local variable whose\n@@ -739,17 +740,17 @@ impl<'hir> Map<'hir> {\n     /// is not an error, since items in the crate module have the crate root as\n     /// parent.\n     fn walk_parent_nodes<F, F2>(&self,\n-                                start_id: NodeId,\n+                                start_id: HirId,\n                                 found: F,\n                                 bail_early: F2)\n-        -> Result<NodeId, NodeId>\n+        -> Result<HirId, HirId>\n         where F: Fn(&Node<'hir>) -> bool, F2: Fn(&Node<'hir>) -> bool\n     {\n         let mut id = start_id;\n         loop {\n-            let parent_node = self.get_parent_node(id);\n-            if parent_node == CRATE_NODE_ID {\n-                return Ok(CRATE_NODE_ID);\n+            let parent_node = self.get_parent_node_by_hir_id(id);\n+            if parent_node == CRATE_HIR_ID {\n+                return Ok(CRATE_HIR_ID);\n             }\n             if parent_node == id {\n                 return Err(id);\n@@ -816,18 +817,22 @@ impl<'hir> Map<'hir> {\n             }\n         };\n \n-        let node_id = self.hir_to_node_id(id);\n-        self.walk_parent_nodes(node_id, match_fn, match_non_returning_block)\n-            .ok()\n-            .map(|return_node_id| self.node_to_hir_id(return_node_id))\n+        self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n     }\n \n     /// Retrieves the `NodeId` for `id`'s parent item, or `id` itself if no\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n     pub fn get_parent(&self, id: NodeId) -> NodeId {\n-        match self.walk_parent_nodes(id, |node| match *node {\n+        let hir_id = self.node_to_hir_id(id);\n+        let parent_hir_id = self.get_parent_item(hir_id);\n+        self.hir_to_node_id(parent_hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n+        match self.walk_parent_nodes(hir_id, |node| match *node {\n             Node::Item(_) |\n             Node::ForeignItem(_) |\n             Node::TraitItem(_) |\n@@ -839,29 +844,22 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn get_parent_item(&self, id: HirId) -> HirId {\n-        let node_id = self.hir_to_node_id(id);\n-        let parent_node_id = self.get_parent(node_id);\n-        self.node_to_hir_id(parent_node_id)\n-    }\n-\n     /// Returns the `DefId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent(&self, id: NodeId) -> DefId {\n-        self.local_def_id(self.get_module_parent_node(id))\n+        let hir_id = self.node_to_hir_id(id);\n+        self.get_module_parent_by_hir_id(hir_id)\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     pub fn get_module_parent_by_hir_id(&self, id: HirId) -> DefId {\n-        let node_id = self.hir_to_node_id(id);\n-        self.get_module_parent(node_id)\n+        self.local_def_id_from_hir_id(self.get_module_parent_node(id))\n     }\n \n-    /// Returns the `NodeId` of `id`'s nearest module parent, or `id` itself if no\n+    /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n-    pub fn get_module_parent_node(&self, id: NodeId) -> NodeId {\n-        match self.walk_parent_nodes(id, |node| match *node {\n+    pub fn get_module_parent_node(&self, hir_id: HirId) -> HirId {\n+        match self.walk_parent_nodes(hir_id, |node| match *node {\n             Node::Item(&Item { node: ItemKind::Mod(_), .. }) => true,\n             _ => false,\n         }, |_| false) {\n@@ -874,8 +872,8 @@ impl<'hir> Map<'hir> {\n     /// FIXME: it is not clear to me that all items qualify as scopes -- statics\n     /// and associated types probably shouldn't, for example. Behavior in this\n     /// regard should be expected to be highly unstable.\n-    pub fn get_enclosing_scope(&self, id: NodeId) -> Option<NodeId> {\n-        self.walk_parent_nodes(id, |node| match *node {\n+    pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n+        self.walk_parent_nodes(hir_id, |node| match *node {\n             Node::Item(_) |\n             Node::ForeignItem(_) |\n             Node::TraitItem(_) |\n@@ -886,39 +884,37 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n-        self.local_def_id(self.get_parent(id))\n+        let hir_id = self.node_to_hir_id(id);\n+        self.get_parent_did_by_hir_id(hir_id)\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     pub fn get_parent_did_by_hir_id(&self, id: HirId) -> DefId {\n-        let node_id = self.hir_to_node_id(id);\n-        self.get_parent_did(node_id)\n+        self.local_def_id_from_hir_id(self.get_parent_item(id))\n     }\n \n     pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n-        let parent = self.get_parent(id);\n+        let hir_id = self.node_to_hir_id(id);\n+        self.get_foreign_abi_by_hir_id(hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_foreign_abi_by_hir_id(&self, hir_id: HirId) -> Abi {\n+        let parent = self.get_parent_item(hir_id);\n         if let Some(entry) = self.find_entry(parent) {\n             if let Entry {\n                 node: Node::Item(Item { node: ItemKind::ForeignMod(ref nm), .. }), .. } = entry\n             {\n-                self.read(id); // reveals some of the content of a node\n+                self.read_by_hir_id(hir_id); // reveals some of the content of a node\n                 return nm.abi;\n             }\n         }\n-        bug!(\"expected foreign mod or inlined parent, found {}\", self.node_to_string(parent))\n-    }\n-\n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn get_foreign_abi_by_hir_id(&self, id: HirId) -> Abi {\n-        let node_id = self.hir_to_node_id(id);\n-        self.get_foreign_abi(node_id)\n+        bug!(\"expected foreign mod or inlined parent, found {}\", self.hir_to_string(parent))\n     }\n \n     pub fn expect_item(&self, id: NodeId) -> &'hir Item {\n-        match self.find(id) { // read recorded by `find`\n-            Some(Node::Item(item)) => item,\n-            _ => bug!(\"expected item, found {}\", self.node_to_string(id))\n-        }\n+        let hir_id = self.node_to_hir_id(id);\n+        self.expect_item_by_hir_id(hir_id)\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n@@ -973,21 +969,27 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn expect_expr(&self, id: NodeId) -> &'hir Expr {\n-        match self.find(id) { // read recorded by find\n-            Some(Node::Expr(expr)) => expr,\n-            _ => bug!(\"expected expr, found {}\", self.node_to_string(id))\n-        }\n+        let hir_id = self.node_to_hir_id(id);\n+        self.expect_expr_by_hir_id(hir_id)\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     pub fn expect_expr_by_hir_id(&self, id: HirId) -> &'hir Expr {\n-        let node_id = self.hir_to_node_id(id);\n-        self.expect_expr(node_id)\n+        match self.find_by_hir_id(id) { // read recorded by find\n+            Some(Node::Expr(expr)) => expr,\n+            _ => bug!(\"expected expr, found {}\", self.hir_to_string(id))\n+        }\n     }\n \n     /// Returns the name associated with the given NodeId's AST.\n     pub fn name(&self, id: NodeId) -> Name {\n-        match self.get(id) {\n+        let hir_id = self.node_to_hir_id(id);\n+        self.name_by_hir_id(hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn name_by_hir_id(&self, id: HirId) -> Name {\n+        match self.get_by_hir_id(id) {\n             Node::Item(i) => i.ident.name,\n             Node::ForeignItem(fi) => fi.ident.name,\n             Node::ImplItem(ii) => ii.ident.name,\n@@ -997,21 +999,21 @@ impl<'hir> Map<'hir> {\n             Node::Lifetime(lt) => lt.name.ident().name,\n             Node::GenericParam(param) => param.name.ident().name,\n             Node::Binding(&Pat { node: PatKind::Binding(_, _, l, _), .. }) => l.name,\n-            Node::Ctor(..) => self.name(self.get_parent(id)),\n-            _ => bug!(\"no name for {}\", self.node_to_string(id))\n+            Node::Ctor(..) => self.name_by_hir_id(self.get_parent_item(id)),\n+            _ => bug!(\"no name for {}\", self.hir_to_string(id))\n         }\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn name_by_hir_id(&self, id: HirId) -> Name {\n-        let node_id = self.hir_to_node_id(id);\n-        self.name(node_id)\n-    }\n-\n     /// Given a node ID, get a list of attributes associated with the AST\n     /// corresponding to the Node ID\n     pub fn attrs(&self, id: NodeId) -> &'hir [ast::Attribute] {\n-        self.read(id); // reveals attributes on the node\n+        let hir_id = self.node_to_hir_id(id);\n+        self.attrs_by_hir_id(hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn attrs_by_hir_id(&self, id: HirId) -> &'hir [ast::Attribute] {\n+        self.read_by_hir_id(id); // reveals attributes on the node\n         let attrs = match self.find_entry(id).map(|entry| entry.node) {\n             Some(Node::Local(l)) => Some(&l.attrs[..]),\n             Some(Node::Item(i)) => Some(&i.attrs[..]),\n@@ -1025,19 +1027,13 @@ impl<'hir> Map<'hir> {\n             Some(Node::GenericParam(param)) => Some(&param.attrs[..]),\n             // Unit/tuple structs/variants take the attributes straight from\n             // the struct/variant definition.\n-            Some(Node::Ctor(..)) => return self.attrs(self.get_parent(id)),\n+            Some(Node::Ctor(..)) => return self.attrs_by_hir_id(self.get_parent_item(id)),\n             Some(Node::Crate) => Some(&self.forest.krate.attrs[..]),\n             _ => None\n         };\n         attrs.unwrap_or(&[])\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn attrs_by_hir_id(&self, id: HirId) -> &'hir [ast::Attribute] {\n-        let node_id = self.hir_to_node_id(id);\n-        self.attrs(node_id)\n-    }\n-\n     /// Returns an iterator that yields the node id's with paths that\n     /// match `parts`.  (Requires `parts` is non-empty.)\n     ///\n@@ -1051,13 +1047,19 @@ impl<'hir> Map<'hir> {\n             map: self,\n             item_name: parts.last().unwrap(),\n             in_which: &parts[..parts.len() - 1],\n-            idx: CRATE_NODE_ID,\n+            idx: ast::CRATE_NODE_ID,\n         }\n     }\n \n     pub fn span(&self, id: NodeId) -> Span {\n-        self.read(id); // reveals span from node\n-        match self.find_entry(id).map(|entry| entry.node) {\n+        let hir_id = self.node_to_hir_id(id);\n+        self.span_by_hir_id(hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn span_by_hir_id(&self, hir_id: HirId) -> Span {\n+        self.read_by_hir_id(hir_id); // reveals span from node\n+        match self.find_entry(hir_id).map(|entry| entry.node) {\n             Some(Node::Item(item)) => item.span,\n             Some(Node::ForeignItem(foreign_item)) => foreign_item.span,\n             Some(Node::TraitItem(trait_method)) => trait_method.span,\n@@ -1073,7 +1075,9 @@ impl<'hir> Map<'hir> {\n             Some(Node::Binding(pat)) => pat.span,\n             Some(Node::Pat(pat)) => pat.span,\n             Some(Node::Block(block)) => block.span,\n-            Some(Node::Ctor(..)) => match self.find(self.get_parent_node(id)) {\n+            Some(Node::Ctor(..)) => match self.find_by_hir_id(\n+                self.get_parent_node_by_hir_id(hir_id))\n+            {\n                 Some(Node::Item(item)) => item.span,\n                 Some(Node::Variant(variant)) => variant.span,\n                 _ => unreachable!(),\n@@ -1087,16 +1091,10 @@ impl<'hir> Map<'hir> {\n             Some(Node::Local(local)) => local.span,\n             Some(Node::MacroDef(macro_def)) => macro_def.span,\n             Some(Node::Crate) => self.forest.krate.span,\n-            None => bug!(\"hir::map::Map::span: id not in map: {:?}\", id),\n+            None => bug!(\"hir::map::Map::span: id not in map: {:?}\", hir_id),\n         }\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn span_by_hir_id(&self, id: HirId) -> Span {\n-        let node_id = self.hir_to_node_id(id);\n-        self.span(node_id)\n-    }\n-\n     pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n         self.as_local_node_id(id).map(|id| self.span(id))\n     }\n@@ -1201,7 +1199,8 @@ impl<'a, 'hir> Iterator for NodesMatchingSuffix<'a, 'hir> {\n                 return None;\n             }\n             self.idx = NodeId::from_u32(self.idx.as_u32() + 1);\n-            let name = match self.map.find_entry(idx).map(|entry| entry.node) {\n+            let hir_idx = self.map.node_to_hir_id(idx);\n+            let name = match self.map.find_entry(hir_idx).map(|entry| entry.node) {\n                 Some(Node::Item(n)) => n.name(),\n                 Some(Node::ForeignItem(n)) => n.name(),\n                 Some(Node::TraitItem(n)) => n.name(),\n@@ -1259,18 +1258,6 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n         )\n     };\n \n-    if log_enabled!(::log::Level::Debug) {\n-        // This only makes sense for ordered stores; note the\n-        // enumerate to count the number of entries.\n-        let (entries_less_1, _) = map.iter().filter_map(|x| *x).enumerate().last()\n-            .expect(\"AST map was empty after folding?\");\n-\n-        let entries = entries_less_1 + 1;\n-        let vector_length = map.len();\n-        debug!(\"The AST map has {} entries with a maximum of {}: occupancy {:.1}%\",\n-              entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n-    }\n-\n     let map = Map {\n         forest,\n         dep_graph: forest.dep_graph.clone(),"}, {"sha": "702b6200a164bd614f6769360fed59064ba96381", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d211248393686e0f73851fc7548f6605220fbe1/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d211248393686e0f73851fc7548f6605220fbe1/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=3d211248393686e0f73851fc7548f6605220fbe1", "patch": "@@ -1827,6 +1827,7 @@ fn check_mod_privacy<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n         empty_tables: &empty_tables,\n     };\n     let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n+\n     intravisit::walk_mod(&mut visitor, module, hir_id);\n \n     // Check privacy of explicitly written types and traits as well as"}, {"sha": "bf9324606b570a198158ea1b11842f448800c3bf", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d211248393686e0f73851fc7548f6605220fbe1/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d211248393686e0f73851fc7548f6605220fbe1/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=3d211248393686e0f73851fc7548f6605220fbe1", "patch": "@@ -166,15 +166,6 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Like the function of the same name on the HIR map, but skips calling it on fake DefIds.\n     /// (This avoids a slice-index-out-of-bounds panic.)\n-    pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n-        if self.all_fake_def_ids.borrow().contains(&def_id) {\n-            None\n-        } else {\n-            self.tcx.hir().as_local_node_id(def_id)\n-        }\n-    }\n-\n-    // FIXME(@ljedrz): remove the NodeId variant\n     pub fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n         if self.all_fake_def_ids.borrow().contains(&def_id) {\n             None"}, {"sha": "902414bd8fdb94d2dff568980d14607a0bafc87b", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3d211248393686e0f73851fc7548f6605220fbe1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d211248393686e0f73851fc7548f6605220fbe1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=3d211248393686e0f73851fc7548f6605220fbe1", "patch": "@@ -38,7 +38,7 @@ pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n \n struct LinkCollector<'a, 'tcx> {\n     cx: &'a DocContext<'tcx>,\n-    mod_ids: Vec<ast::NodeId>,\n+    mod_ids: Vec<hir::HirId>,\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n@@ -55,7 +55,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                path_str: &str,\n                ns: Namespace,\n                current_item: &Option<String>,\n-               parent_id: Option<ast::NodeId>)\n+               parent_id: Option<hir::HirId>)\n         -> Result<(Def, Option<String>), ()>\n     {\n         let cx = self.cx;\n@@ -64,8 +64,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         // path.\n         if let Some(id) = parent_id.or(self.mod_ids.last().cloned()) {\n             // FIXME: `with_scope` requires the `NodeId` of a module.\n+            let node_id = cx.tcx.hir().hir_to_node_id(id);\n             let result = cx.enter_resolver(|resolver| {\n-                resolver.with_scope(id, |resolver| {\n+                resolver.with_scope(node_id, |resolver| {\n                     resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns == ValueNS)\n                 })\n             });\n@@ -127,7 +128,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             }\n \n             // FIXME: `with_scope` requires the `NodeId` of a module.\n-            let ty = cx.enter_resolver(|resolver| resolver.with_scope(id, |resolver| {\n+            let node_id = cx.tcx.hir().hir_to_node_id(id);\n+            let ty = cx.enter_resolver(|resolver| resolver.with_scope(node_id, |resolver| {\n                     resolver.resolve_str_path_error(DUMMY_SP, &path, false)\n             }))?;\n             match ty.def {\n@@ -216,11 +218,11 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         };\n \n         // FIXME: get the resolver to work with non-local resolve scopes.\n-        let parent_node = self.cx.as_local_node_id(item.def_id).and_then(|node_id| {\n+        let parent_node = self.cx.as_local_hir_id(item.def_id).and_then(|hir_id| {\n             // FIXME: this fails hard for impls in non-module scope, but is necessary for the\n             // current `resolve()` implementation.\n-            match self.cx.tcx.hir().get_module_parent_node(node_id) {\n-                id if id != node_id => Some(id),\n+            match self.cx.tcx.hir().get_module_parent_node(hir_id) {\n+                id if id != hir_id => Some(id),\n                 _ => None,\n             }\n         });\n@@ -239,9 +241,9 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                 } else {\n                     match parent_node.or(self.mod_ids.last().cloned()) {\n-                        Some(parent) if parent != ast::CRATE_NODE_ID => {\n+                        Some(parent) if parent != hir::CRATE_HIR_ID => {\n                             // FIXME: can we pull the parent module's name from elsewhere?\n-                            Some(self.cx.tcx.hir().name(parent).to_string())\n+                            Some(self.cx.tcx.hir().name_by_hir_id(parent).to_string())\n                         }\n                         _ => None,\n                     }\n@@ -258,7 +260,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         };\n \n         if item.is_mod() && item.attrs.inner_docs {\n-            self.mod_ids.push(self.cx.tcx.hir().hir_to_node_id(item_hir_id.unwrap()));\n+            self.mod_ids.push(item_hir_id.unwrap());\n         }\n \n         let cx = self.cx;\n@@ -392,7 +394,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         }\n \n         if item.is_mod() && !item.attrs.inner_docs {\n-            self.mod_ids.push(self.cx.tcx.hir().hir_to_node_id(item_hir_id.unwrap()));\n+            self.mod_ids.push(item_hir_id.unwrap());\n         }\n \n         if item.is_mod() {"}, {"sha": "badf37c96710361d1cd316574a0862e50ed9fc2b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d211248393686e0f73851fc7548f6605220fbe1/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d211248393686e0f73851fc7548f6605220fbe1/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=3d211248393686e0f73851fc7548f6605220fbe1", "patch": "@@ -31,7 +31,7 @@ pub struct RustdocVisitor<'a, 'tcx> {\n     pub module: Module,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub cx: &'a core::DocContext<'tcx>,\n-    view_item_stack: FxHashSet<ast::NodeId>,\n+    view_item_stack: FxHashSet<hir::HirId>,\n     inlining: bool,\n     /// Are the current module and all of its parents public?\n     inside_public_path: bool,\n@@ -44,7 +44,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     ) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is re-exported, terminate all recursion.\n         let mut stack = FxHashSet::default();\n-        stack.insert(ast::CRATE_NODE_ID);\n+        stack.insert(hir::CRATE_HIR_ID);\n         RustdocVisitor {\n             module: Module::new(None),\n             attrs: hir::HirVec::new(),\n@@ -271,13 +271,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                           om: &mut Module,\n                           please_inline: bool) -> bool {\n \n-        fn inherits_doc_hidden(cx: &core::DocContext<'_>, mut node: ast::NodeId) -> bool {\n+        fn inherits_doc_hidden(cx: &core::DocContext<'_>, mut node: hir::HirId) -> bool {\n             while let Some(id) = cx.tcx.hir().get_enclosing_scope(node) {\n                 node = id;\n-                if cx.tcx.hir().attrs(node).lists(\"doc\").has_word(\"hidden\") {\n+                if cx.tcx.hir().attrs_by_hir_id(node).lists(\"doc\").has_word(\"hidden\") {\n                     return true;\n                 }\n-                if node == ast::CRATE_NODE_ID {\n+                if node == hir::CRATE_HIR_ID {\n                     break;\n                 }\n             }\n@@ -326,21 +326,21 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false\n         }\n \n-        let def_node_id = match tcx.hir().as_local_node_id(def_did) {\n+        let def_hir_id = match tcx.hir().as_local_hir_id(def_did) {\n             Some(n) => n, None => return false\n         };\n \n         let is_private = !self.cx.renderinfo.borrow().access_levels.is_public(def_did);\n-        let is_hidden = inherits_doc_hidden(self.cx, def_node_id);\n+        let is_hidden = inherits_doc_hidden(self.cx, def_hir_id);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n         if (!please_inline && !is_private && !is_hidden) || is_no_inline {\n             return false\n         }\n \n-        if !self.view_item_stack.insert(def_node_id) { return false }\n+        if !self.view_item_stack.insert(def_hir_id) { return false }\n \n-        let ret = match tcx.hir().get(def_node_id) {\n+        let ret = match tcx.hir().get_by_hir_id(def_hir_id) {\n             Node::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {\n@@ -373,7 +373,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             }\n             _ => false,\n         };\n-        self.view_item_stack.remove(&def_node_id);\n+        self.view_item_stack.remove(&def_hir_id);\n         ret\n     }\n "}]}