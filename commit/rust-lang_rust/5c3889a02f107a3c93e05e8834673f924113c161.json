{"sha": "5c3889a02f107a3c93e05e8834673f924113c161", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMzg4OWEwMmYxMDdhM2M5M2UwNWU4ODM0NjczZjkyNDExM2MxNjE=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-29T23:44:16Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-06T17:42:38Z"}, "message": "Contracts work well enough to do the message ring benchmark, and it's really fast.\n\nFixing old-style vector, and xfail-prettying th contracts test because the pretty printer is unhappy.", "tree": {"sha": "11f5318413b295737c413808bd8ed40e0bfb8748", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11f5318413b295737c413808bd8ed40e0bfb8748"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c3889a02f107a3c93e05e8834673f924113c161", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c3889a02f107a3c93e05e8834673f924113c161", "html_url": "https://github.com/rust-lang/rust/commit/5c3889a02f107a3c93e05e8834673f924113c161", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c3889a02f107a3c93e05e8834673f924113c161/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d35435fac4f44d21bdeb529e525adce67838e04", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d35435fac4f44d21bdeb529e525adce67838e04", "html_url": "https://github.com/rust-lang/rust/commit/5d35435fac4f44d21bdeb529e525adce67838e04"}], "stats": {"total": 327, "additions": 327, "deletions": 0}, "files": [{"sha": "035be3d5d5d52b32ed096be9bbd491d19de0fd22", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c3889a02f107a3c93e05e8834673f924113c161/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3889a02f107a3c93e05e8834673f924113c161/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=5c3889a02f107a3c93e05e8834673f924113c161", "patch": "@@ -1163,6 +1163,7 @@ pure fn unpack_mut_slice<T,U>(s: &[mut T],\n impl extensions<T: copy> for ~[T] {\n     #[inline(always)]\n     pure fn +(rhs: &[const T]) -> ~[T] {\n+he pretty printer is unhappy.\n         append(self, rhs)\n     }\n }"}, {"sha": "2802fec90e1dfd9849dbf48c949549dff1715cad", "filename": "src/test/bench/msgsend-ring-contracts.rs", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/5c3889a02f107a3c93e05e8834673f924113c161/src%2Ftest%2Fbench%2Fmsgsend-ring-contracts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3889a02f107a3c93e05e8834673f924113c161/src%2Ftest%2Fbench%2Fmsgsend-ring-contracts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-contracts.rs?ref=5c3889a02f107a3c93e05e8834673f924113c161", "patch": "@@ -0,0 +1,326 @@\n+// This test creates a bunch of tasks that simultaneously send to each\n+// other in a ring. The messages should all be basically\n+// independent. It's designed to hammer the global kernel lock, so\n+// that things will look really good once we get that lock out of the\n+// message path.\n+\n+// This version uses semi-automatically compiled channel contracts.\n+\n+// xfail-pretty\n+\n+import future::future;\n+\n+use std;\n+import std::time;\n+\n+import ring::server::recv;\n+\n+mod pipes {\n+    // Runtime support for pipes.\n+\n+    import unsafe::{forget, reinterpret_cast};\n+\n+    enum state {\n+        empty,\n+        full,\n+        blocked,\n+        terminated\n+    }\n+\n+    type packet<T: send> = {\n+        mut state: state,\n+        mut blocked_task: option<task::task>,\n+        mut payload: option<T>\n+    };\n+\n+    fn packet<T: send>() -> *packet<T> unsafe {\n+        let p: *packet<T> = unsafe::transmute(~{\n+            mut state: empty,\n+            mut blocked_task: none::<task::task>,\n+            mut payload: none::<T>\n+        });\n+        p\n+    }\n+\n+    #[abi = \"rust-intrinsic\"]\n+    native mod rusti {\n+        fn atomic_xchng(&dst: int, src: int) -> int;\n+        fn atomic_xchng_acq(&dst: int, src: int) -> int;\n+        fn atomic_xchng_rel(&dst: int, src: int) -> int;\n+    }\n+\n+    // We should consider moving this to core::unsafe, although I\n+    // suspect graydon would want us to use void pointers instead.\n+    unsafe fn uniquify<T>(x: *T) -> ~T {\n+        unsafe { unsafe::reinterpret_cast(x) }\n+    }\n+\n+    fn swap_state_acq(&dst: state, src: state) -> state {\n+        unsafe {\n+            reinterpret_cast(rusti::atomic_xchng_acq(\n+                *(ptr::mut_addr_of(dst) as *mut int),\n+                src as int))\n+        }\n+    }\n+\n+    fn swap_state_rel(&dst: state, src: state) -> state {\n+        unsafe {\n+            reinterpret_cast(rusti::atomic_xchng_rel(\n+                *(ptr::mut_addr_of(dst) as *mut int),\n+                src as int))\n+        }\n+    }\n+\n+    fn send<T: send>(-p: send_packet<T>, -payload: T) {\n+        let p = p.unwrap();\n+        let p = unsafe { uniquify(p) };\n+        assert (*p).payload == none;\n+        (*p).payload <- some(payload);\n+        let old_state = swap_state_rel((*p).state, full);\n+        alt old_state {\n+          empty {\n+            // Yay, fastpath.\n+\n+            // The receiver will eventually clean this up.\n+            unsafe { forget(p); }\n+          }\n+          full { fail \"duplicate send\" }\n+          blocked {\n+            // FIXME: once the target will actually block, tell the\n+            // scheduler to wake it up.\n+\n+            // The receiver will eventually clean this up.\n+            unsafe { forget(p); }\n+          }\n+          terminated {\n+            // The receiver will never receive this. Rely on drop_glue\n+            // to clean everything up.\n+          }\n+        }\n+    }\n+\n+    fn recv<T: send>(-p: recv_packet<T>) -> option<T> {\n+        let p = p.unwrap();\n+        let p = unsafe { uniquify(p) };\n+        loop {\n+            let old_state = swap_state_acq((*p).state,\n+                                           blocked);\n+            alt old_state {\n+              empty | blocked { task::yield(); }\n+              full {\n+                let mut payload = none;\n+                payload <-> (*p).payload;\n+                ret some(option::unwrap(payload))\n+              }\n+              terminated {\n+                assert old_state == terminated;\n+                ret none;\n+              }\n+            }\n+        }\n+    }\n+\n+    fn sender_terminate<T: send>(p: *packet<T>) {\n+        let p = unsafe { uniquify(p) };\n+        alt swap_state_rel((*p).state, terminated) {\n+          empty | blocked {\n+            // The receiver will eventually clean up.\n+            unsafe { forget(p) }\n+          }\n+          full {\n+            // This is impossible\n+            fail \"you dun goofed\"\n+          }\n+          terminated {\n+            // I have to clean up, use drop_glue\n+          }\n+        }\n+    }\n+\n+    fn receiver_terminate<T: send>(p: *packet<T>) {\n+        let p = unsafe { uniquify(p) };\n+        alt swap_state_rel((*p).state, terminated) {\n+          empty {\n+            // the sender will clean up\n+            unsafe { forget(p) }\n+          }\n+          blocked {\n+            // this shouldn't happen.\n+            fail \"terminating a blocked packet\"\n+          }\n+          terminated | full {\n+            // I have to clean up, use drop_glue\n+          }\n+        }\n+    }\n+\n+    class send_packet<T: send> {\n+        let mut p: option<*packet<T>>;\n+        new(p: *packet<T>) {\n+            //#error(\"take send %?\", p);\n+            self.p = some(p);\n+        }\n+        drop {\n+            //if self.p != none {\n+            //    #error(\"drop send %?\", option::get(self.p));\n+            //}\n+            if self.p != none {\n+                let mut p = none;\n+                p <-> self.p;\n+                sender_terminate(option::unwrap(p))\n+            }\n+        }\n+        fn unwrap() -> *packet<T> {\n+            let mut p = none;\n+            p <-> self.p;\n+            option::unwrap(p)\n+        }\n+    }\n+\n+    class recv_packet<T: send> {\n+        let mut p: option<*packet<T>>;\n+        new(p: *packet<T>) {\n+            //#error(\"take recv %?\", p);\n+            self.p = some(p);\n+        }\n+        drop {\n+            //if self.p != none {\n+            //    #error(\"drop recv %?\", option::get(self.p));\n+            //}\n+            if self.p != none {\n+                let mut p = none;\n+                p <-> self.p;\n+                receiver_terminate(option::unwrap(p))\n+            }\n+        }\n+        fn unwrap() -> *packet<T> {\n+            let mut p = none;\n+            p <-> self.p;\n+            option::unwrap(p)\n+        }\n+    }\n+\n+    fn entangle<T: send>() -> (send_packet<T>, recv_packet<T>) {\n+        let p = packet();\n+        (send_packet(p), recv_packet(p))\n+    }\n+}\n+\n+// This module was generated by the pipe compiler.\n+mod ring {\n+    fn init() -> (client::num, server::num) { pipes::entangle() }\n+    enum num { num(uint, server::num), }\n+    mod client {\n+        fn num(-pipe: num, x_0: uint) -> num {\n+            let (c, s) = pipes::entangle();\n+            let message = ring::num(x_0, s);\n+            pipes::send(pipe, message);\n+            c\n+        }\n+        type num = pipes::send_packet<ring::num>;\n+    }\n+    mod server {\n+        impl recv for num {\n+            fn recv() -> extern fn(-num) -> ring::num {\n+                fn recv(-pipe: num) -> ring::num {\n+                    option::unwrap(pipes::recv(pipe))\n+                }\n+                recv\n+            }\n+        }\n+        type num = pipes::recv_packet<ring::num>;\n+    }\n+}\n+\n+fn macros() {\n+    #macro[\n+        [#recv[chan],\n+         chan.recv()(chan)]\n+    ];\n+\n+    #macro[\n+        [#move[x],\n+         unsafe { let y <- *ptr::addr_of(x); y }]\n+    ];\n+}\n+\n+fn thread_ring(i: uint,\n+               count: uint,\n+               +num_chan: ring::client::num,\n+               +num_port: ring::server::num) {\n+    let mut num_chan <- some(num_chan);\n+    let mut num_port <- some(num_port);\n+    // Send/Receive lots of messages.\n+    for uint::range(0u, count) {|j|\n+        //#error(\"task %?, iter %?\", i, j);\n+        let mut num_chan2 = none;\n+        let mut num_port2 = none;\n+        num_chan2 <-> num_chan;\n+        num_port2 <-> num_port;\n+        num_chan = some(ring::client::num(option::unwrap(num_chan2), i * j));\n+        let port = option::unwrap(num_port2);\n+        alt (#recv(port)) {\n+          ring::num(_n, p) {\n+            //log(error, _n);\n+            num_port = some(#move(p));\n+          }\n+        }\n+    };\n+}\n+\n+fn main(args: [str]/~) {\n+    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n+        [\"\", \"100\", \"10000\"]/~\n+    } else if args.len() <= 1u {\n+        [\"\", \"100\", \"1000\"]/~\n+    } else {\n+        copy args\n+    }; \n+\n+    let num_tasks = option::get(uint::from_str(args[1]));\n+    let msg_per_task = option::get(uint::from_str(args[2]));\n+\n+    let (num_chan, num_port) = ring::init();\n+    let mut num_chan = some(num_chan);\n+\n+    let start = time::precise_time_s();\n+\n+    // create the ring\n+    let mut futures = []/~;\n+\n+    for uint::range(1u, num_tasks) {|i|\n+        //#error(\"spawning %?\", i);\n+        let (new_chan, num_port) = ring::init();\n+        let num_chan2 = ~mut none;\n+        *num_chan2 <-> num_chan;\n+        let num_port = ~mut some(num_port);\n+        futures += [future::spawn {|move num_chan2, move num_port|\n+            let mut num_chan = none;\n+            num_chan <-> *num_chan2;\n+            let mut num_port1 = none;\n+            num_port1 <-> *num_port;\n+            thread_ring(i, msg_per_task,\n+                        option::unwrap(num_chan),\n+                        option::unwrap(num_port1))\n+        }]/~;\n+        num_chan = some(new_chan);\n+    };\n+\n+    // do our iteration\n+    thread_ring(0u, msg_per_task, option::unwrap(num_chan), num_port);\n+\n+    // synchronize\n+    for futures.each {|f| f.get() };\n+\n+    let stop = time::precise_time_s();\n+\n+    // all done, report stats.\n+    let num_msgs = num_tasks * msg_per_task;\n+    let elapsed = (stop - start);\n+    let rate = (num_msgs as float) / elapsed;\n+\n+    io::println(#fmt(\"Sent %? messages in %? seconds\",\n+                     num_msgs, elapsed));\n+    io::println(#fmt(\"  %? messages / second\", rate));\n+    io::println(#fmt(\"  %? \u03bcs / message\", 1000000. / rate));\n+}"}]}