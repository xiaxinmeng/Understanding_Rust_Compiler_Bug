{"sha": "22060f20ae0b92acd056c4f2c79d19dd1b73ab5c", "node_id": "C_kwDOAAsO6NoAKDIyMDYwZjIwYWUwYjkyYWNkMDU2YzRmMmM3OWQxOWRkMWI3M2FiNWM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-28T21:22:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-28T21:22:18Z"}, "message": "Rollup merge of #105359 - flba-eb:thread_local_key_sentinel_value, r=m-ou-se\n\nMake sentinel value configurable in `library/std/src/sys_common/thread_local_key.rs`\n\nThis is an excerpt of a changeset for the QNX/Neutrino OS. To make the patch for QNX smaller and easier to review, I've extracted this change (which is OS independent). I would be surprised if no other OS is also affected.\n\nAll this patch does is to define a `const` for a sentinel value instead of using it directly at several places.\n\nThere are OSs that always return the lowest free value. The algorithm in `lazy_init` always avoids keys with the sentinel value.\nIn affected OSs, this means that each call to `lazy_init` will always request two keys from the OS and returns/frees the first one (with sentinel value) immediately afterwards.\n\nBy making the sentinel value configurable, affected OSs can use a different value than zero to prevent this performance issue.\n\nOn QNX/Neutrino, it is planned to use a different sentinel value:\n```rust\n// Define a sentinel value that is unlikely to be returned\n// as a TLS key (but it may be returned).\n#[cfg(not(target_os = \"nto\"))]\nconst KEY_SENTVAL: usize = 0;\n// On QNX/Neutrino, 0 is always returned when currently not in use.\n// Using 0 would mean to always create two keys and remote the first\n// one (with value of 0) immediately afterwards.\n#[cfg(target_os = \"nto\")]\nconst KEY_SENTVAL: usize = libc::PTHREAD_KEYS_MAX + 1;\n```\n\nIt seems like no other OS defines `PTHREAD_KEYS_MAX` in Rusts libc, but `limits.h` on unix systems does.", "tree": {"sha": "6ad221e04ee4387e35c3fb2ebf087ceb9c59838c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ad221e04ee4387e35c3fb2ebf087ceb9c59838c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22060f20ae0b92acd056c4f2c79d19dd1b73ab5c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjrLOKCRBK7hj4Ov3rIwAA/EUIACbCvfWzaOPEYvFoVhd8Ei54\n02qeT9FBH4PWv30Ji1RtGTruZhvvQW6tJBEOsyKvdBbeRPDuypSMNI/pwbxiOmvS\nAWc3ZQjjyXIMYUcOM+q9nLqaNnxO5ysLB4klfGabzEOSGjvLMPLYSR7CN795ECau\nOJXZcZ+wQ0d4kLJew4lot2kCKRPL2nxKehkdP/CR2W07ZbodfanSQlYMvDK5iwZn\nF56sdfI4AQBBRBupful6Dj0C8Ne4ov6vrFerVqdl9THF1kHeYqssE1SJ6eRQu9Vy\nTCBVImWGocr5r0CelzOdSIzoxZ8viY+X+xSzcQ0hdB4rg/xjj/3zlvGfPUMncfM=\n=UzQ3\n-----END PGP SIGNATURE-----\n", "payload": "tree 6ad221e04ee4387e35c3fb2ebf087ceb9c59838c\nparent 2dd2fb728e61a6e7912e1e2818407625ad806bb9\nparent 980065ab23650452c33bb47ef66d75fbfbcb6e04\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1672262538 +0100\ncommitter GitHub <noreply@github.com> 1672262538 +0100\n\nRollup merge of #105359 - flba-eb:thread_local_key_sentinel_value, r=m-ou-se\n\nMake sentinel value configurable in `library/std/src/sys_common/thread_local_key.rs`\n\nThis is an excerpt of a changeset for the QNX/Neutrino OS. To make the patch for QNX smaller and easier to review, I've extracted this change (which is OS independent). I would be surprised if no other OS is also affected.\n\nAll this patch does is to define a `const` for a sentinel value instead of using it directly at several places.\n\nThere are OSs that always return the lowest free value. The algorithm in `lazy_init` always avoids keys with the sentinel value.\nIn affected OSs, this means that each call to `lazy_init` will always request two keys from the OS and returns/frees the first one (with sentinel value) immediately afterwards.\n\nBy making the sentinel value configurable, affected OSs can use a different value than zero to prevent this performance issue.\n\nOn QNX/Neutrino, it is planned to use a different sentinel value:\n```rust\n// Define a sentinel value that is unlikely to be returned\n// as a TLS key (but it may be returned).\n#[cfg(not(target_os = \"nto\"))]\nconst KEY_SENTVAL: usize = 0;\n// On QNX/Neutrino, 0 is always returned when currently not in use.\n// Using 0 would mean to always create two keys and remote the first\n// one (with value of 0) immediately afterwards.\n#[cfg(target_os = \"nto\")]\nconst KEY_SENTVAL: usize = libc::PTHREAD_KEYS_MAX + 1;\n```\n\nIt seems like no other OS defines `PTHREAD_KEYS_MAX` in Rusts libc, but `limits.h` on unix systems does.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22060f20ae0b92acd056c4f2c79d19dd1b73ab5c", "html_url": "https://github.com/rust-lang/rust/commit/22060f20ae0b92acd056c4f2c79d19dd1b73ab5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22060f20ae0b92acd056c4f2c79d19dd1b73ab5c/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dd2fb728e61a6e7912e1e2818407625ad806bb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dd2fb728e61a6e7912e1e2818407625ad806bb9", "html_url": "https://github.com/rust-lang/rust/commit/2dd2fb728e61a6e7912e1e2818407625ad806bb9"}, {"sha": "980065ab23650452c33bb47ef66d75fbfbcb6e04", "url": "https://api.github.com/repos/rust-lang/rust/commits/980065ab23650452c33bb47ef66d75fbfbcb6e04", "html_url": "https://github.com/rust-lang/rust/commit/980065ab23650452c33bb47ef66d75fbfbcb6e04"}], "stats": {"total": 25, "additions": 17, "deletions": 8}, "files": [{"sha": "2672a2a75b017bc4cec15931f3f68cfad622f7ea", "filename": "library/std/src/sys_common/thread_local_key.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/22060f20ae0b92acd056c4f2c79d19dd1b73ab5c/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22060f20ae0b92acd056c4f2c79d19dd1b73ab5c/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs?ref=22060f20ae0b92acd056c4f2c79d19dd1b73ab5c", "patch": "@@ -117,10 +117,14 @@ pub struct Key {\n /// This value specifies no destructor by default.\n pub const INIT: StaticKey = StaticKey::new(None);\n \n+// Define a sentinel value that is unlikely to be returned\n+// as a TLS key (but it may be returned).\n+const KEY_SENTVAL: usize = 0;\n+\n impl StaticKey {\n     #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n     pub const fn new(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> StaticKey {\n-        StaticKey { key: atomic::AtomicUsize::new(0), dtor }\n+        StaticKey { key: atomic::AtomicUsize::new(KEY_SENTVAL), dtor }\n     }\n \n     /// Gets the value associated with this TLS key\n@@ -144,31 +148,36 @@ impl StaticKey {\n     #[inline]\n     unsafe fn key(&self) -> imp::Key {\n         match self.key.load(Ordering::Relaxed) {\n-            0 => self.lazy_init() as imp::Key,\n+            KEY_SENTVAL => self.lazy_init() as imp::Key,\n             n => n as imp::Key,\n         }\n     }\n \n     unsafe fn lazy_init(&self) -> usize {\n-        // POSIX allows the key created here to be 0, but the compare_exchange\n-        // below relies on using 0 as a sentinel value to check who won the\n+        // POSIX allows the key created here to be KEY_SENTVAL, but the compare_exchange\n+        // below relies on using KEY_SENTVAL as a sentinel value to check who won the\n         // race to set the shared TLS key. As far as I know, there is no\n         // guaranteed value that cannot be returned as a posix_key_create key,\n         // so there is no value we can initialize the inner key with to\n         // prove that it has not yet been set. As such, we'll continue using a\n-        // value of 0, but with some gyrations to make sure we have a non-0\n+        // value of KEY_SENTVAL, but with some gyrations to make sure we have a non-KEY_SENTVAL\n         // value returned from the creation routine.\n         // FIXME: this is clearly a hack, and should be cleaned up.\n         let key1 = imp::create(self.dtor);\n-        let key = if key1 != 0 {\n+        let key = if key1 as usize != KEY_SENTVAL {\n             key1\n         } else {\n             let key2 = imp::create(self.dtor);\n             imp::destroy(key1);\n             key2\n         };\n-        rtassert!(key != 0);\n-        match self.key.compare_exchange(0, key as usize, Ordering::SeqCst, Ordering::SeqCst) {\n+        rtassert!(key as usize != KEY_SENTVAL);\n+        match self.key.compare_exchange(\n+            KEY_SENTVAL,\n+            key as usize,\n+            Ordering::SeqCst,\n+            Ordering::SeqCst,\n+        ) {\n             // The CAS succeeded, so we've created the actual key\n             Ok(_) => key as usize,\n             // If someone beat us to the punch, use their key instead"}]}