{"sha": "64856e29c1c780117348c196e05902476251bc92", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ODU2ZTI5YzFjNzgwMTE3MzQ4YzE5NmUwNTkwMjQ3NjI1MWJjOTI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-10-24T19:12:32Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-11-20T09:58:30Z"}, "message": "adjust union access unsafety check logic to take into account Deref and the actual type of the assignment", "tree": {"sha": "dd7b26b4e00c47e2cca8ff0bb6ecb285cb0fc43a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd7b26b4e00c47e2cca8ff0bb6ecb285cb0fc43a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64856e29c1c780117348c196e05902476251bc92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64856e29c1c780117348c196e05902476251bc92", "html_url": "https://github.com/rust-lang/rust/commit/64856e29c1c780117348c196e05902476251bc92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64856e29c1c780117348c196e05902476251bc92/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ac1df8b99341fa781aead2f3eeef955309a12f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ac1df8b99341fa781aead2f3eeef955309a12f3", "html_url": "https://github.com/rust-lang/rust/commit/3ac1df8b99341fa781aead2f3eeef955309a12f3"}], "stats": {"total": 98, "additions": 74, "deletions": 24}, "files": [{"sha": "e78f8d4c901d38111a4ee065efee9be1a7e84968", "filename": "compiler/rustc_mir/src/transform/check_unsafety.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/64856e29c1c780117348c196e05902476251bc92/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64856e29c1c780117348c196e05902476251bc92/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs?ref=64856e29c1c780117348c196e05902476251bc92", "patch": "@@ -190,7 +190,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n         }\n \n-        for (i, elem) in place.projection.iter().enumerate() {\n+        for (i, _elem) in place.projection.iter().enumerate() {\n             let proj_base = &place.projection[..i];\n             if context.is_borrow() {\n                 if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n@@ -236,31 +236,36 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     UnsafetyViolationDetails::DerefOfRawPointer,\n                 ),\n                 ty::Adt(adt, _) if adt.is_union() => {\n-                    if context == PlaceContext::MutatingUse(MutatingUseContext::Store)\n+                    let assign_to_field = context\n+                        == PlaceContext::MutatingUse(MutatingUseContext::Store)\n                         || context == PlaceContext::MutatingUse(MutatingUseContext::Drop)\n-                        || context == PlaceContext::MutatingUse(MutatingUseContext::AsmOutput)\n-                    {\n-                        let elem_ty = match elem {\n-                            ProjectionElem::Field(_, ty) => ty,\n-                            _ => span_bug!(\n-                                self.source_info.span,\n-                                \"non-field projection {:?} from union?\",\n-                                place\n-                            ),\n-                        };\n-                        let manually_drop = elem_ty\n+                        || context == PlaceContext::MutatingUse(MutatingUseContext::AsmOutput);\n+                    // If there is a `Deref` further along the projection chain, this is *not* an\n+                    // assignment to a union field. In that case the union field is just read to\n+                    // obtain the pointer/reference.\n+                    let assign_to_field = assign_to_field\n+                        && !place.projection[i..]\n+                            .iter()\n+                            .any(|elem| matches!(elem, ProjectionElem::Deref));\n+                    // If this is just an assignment, determine if the assigned type needs dropping.\n+                    if assign_to_field {\n+                        // We have to check the actual type of the assignment, as that determines if the\n+                        // old value is being dropped.\n+                        let assigned_ty = place.ty(&self.body.local_decls, self.tcx).ty;\n+                        // To avoid semver hazard, we only consider `Copy` and `ManuallyDrop` non-dropping.\n+                        let manually_drop = assigned_ty\n                             .ty_adt_def()\n                             .map_or(false, |adt_def| adt_def.is_manually_drop());\n                         let nodrop = manually_drop\n-                            || elem_ty.is_copy_modulo_regions(\n+                            || assigned_ty.is_copy_modulo_regions(\n                                 self.tcx.at(self.source_info.span),\n                                 self.param_env,\n                             );\n                         if !nodrop {\n                             self.require_unsafe(\n                                 UnsafetyViolationKind::GeneralAndConstFn,\n                                 UnsafetyViolationDetails::AssignToDroppingUnionField,\n-                            )\n+                            );\n                         } else {\n                             // write to non-drop union field, safe\n                         }"}, {"sha": "9c7ed1f7bfc3a36add79b5836b72e50448dce0b9", "filename": "src/test/ui/union/union-unsafe.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/64856e29c1c780117348c196e05902476251bc92/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64856e29c1c780117348c196e05902476251bc92/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs?ref=64856e29c1c780117348c196e05902476251bc92", "patch": "@@ -1,4 +1,6 @@\n+#![feature(untagged_unions)]\n use std::mem::ManuallyDrop;\n+use std::cell::RefCell;\n \n union U1 {\n     a: u8\n@@ -16,6 +18,25 @@ union U4<T: Copy> {\n     a: T\n }\n \n+union URef {\n+    p: &'static mut i32,\n+}\n+\n+union URefCell { // field that does not drop but is not `Copy`, either\n+    a: (RefCell<i32>, i32),\n+}\n+\n+fn deref_union_field(mut u: URef) {\n+    // Not an assignment but an access to the union field!\n+    *(u.p) = 13; //~ ERROR access to union field is unsafe\n+}\n+\n+fn assign_noncopy_union_field(mut u: URefCell) {\n+    u.a = (RefCell::new(0), 1); //~ ERROR assignment to union field that needs dropping\n+    u.a.0 = RefCell::new(0); //~ ERROR assignment to union field that needs dropping\n+    u.a.1 = 1; // OK\n+}\n+\n fn generic_noncopy<T: Default>() {\n     let mut u3 = U3 { a: ManuallyDrop::new(T::default()) };\n     u3.a = ManuallyDrop::new(T::default()); // OK (assignment does not drop)"}, {"sha": "f80d4394f84250b2b02aa6368edbbaba45cf393f", "filename": "src/test/ui/union/union-unsafe.stderr", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/64856e29c1c780117348c196e05902476251bc92/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64856e29c1c780117348c196e05902476251bc92/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr?ref=64856e29c1c780117348c196e05902476251bc92", "patch": "@@ -1,67 +1,91 @@\n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:22:6\n+  --> $DIR/union-unsafe.rs:31:5\n+   |\n+LL |     *(u.p) = 13;\n+   |     ^^^^^^^^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error[E0133]: assignment to union field that needs dropping is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:35:5\n+   |\n+LL |     u.a = (RefCell::new(0), 1);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to union field that needs dropping\n+   |\n+   = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n+\n+error[E0133]: assignment to union field that needs dropping is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:36:5\n+   |\n+LL |     u.a.0 = RefCell::new(0);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ assignment to union field that needs dropping\n+   |\n+   = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n+\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:43:6\n    |\n LL |     *u3.a = T::default();\n    |      ^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:28:6\n+  --> $DIR/union-unsafe.rs:49:6\n    |\n LL |     *u3.a = T::default();\n    |      ^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:36:13\n+  --> $DIR/union-unsafe.rs:57:13\n    |\n LL |     let a = u1.a;\n    |             ^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:39:14\n+  --> $DIR/union-unsafe.rs:60:14\n    |\n LL |     let U1 { a } = u1;\n    |              ^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:40:20\n+  --> $DIR/union-unsafe.rs:61:20\n    |\n LL |     if let U1 { a: 12 } = u1 {}\n    |                    ^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:45:6\n+  --> $DIR/union-unsafe.rs:66:6\n    |\n LL |     *u2.a = String::from(\"new\");\n    |      ^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:49:6\n+  --> $DIR/union-unsafe.rs:70:6\n    |\n LL |     *u3.a = 1;\n    |      ^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:53:6\n+  --> $DIR/union-unsafe.rs:74:6\n    |\n LL |     *u3.a = String::from(\"new\");\n    |      ^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 11 previous errors\n \n For more information about this error, try `rustc --explain E0133`."}]}