{"sha": "7fe1005fd124fe79f4a4ea17d0056e55ff7bd3ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmZTEwMDVmZDEyNGZlNzlmNGE0ZWExN2QwMDU2ZTU1ZmY3YmQzYWU=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-21T23:37:43Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-21T23:40:47Z"}, "message": "Add msgsend-ring-{rw,mutex}-arcs bench tests", "tree": {"sha": "4da8bffa2f983416b0f2937561745917f97ac810", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4da8bffa2f983416b0f2937561745917f97ac810"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fe1005fd124fe79f4a4ea17d0056e55ff7bd3ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fe1005fd124fe79f4a4ea17d0056e55ff7bd3ae", "html_url": "https://github.com/rust-lang/rust/commit/7fe1005fd124fe79f4a4ea17d0056e55ff7bd3ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fe1005fd124fe79f4a4ea17d0056e55ff7bd3ae/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "236f8330072aec35f875f029dc215769e5fc6b91", "url": "https://api.github.com/repos/rust-lang/rust/commits/236f8330072aec35f875f029dc215769e5fc6b91", "html_url": "https://github.com/rust-lang/rust/commit/236f8330072aec35f875f029dc215769e5fc6b91"}], "stats": {"total": 229, "additions": 229, "deletions": 0}, "files": [{"sha": "172351e506fbb40fe98d0102fb95e6932f8c74b5", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/7fe1005fd124fe79f4a4ea17d0056e55ff7bd3ae/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe1005fd124fe79f4a4ea17d0056e55ff7bd3ae/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=7fe1005fd124fe79f4a4ea17d0056e55ff7bd3ae", "patch": "@@ -0,0 +1,114 @@\n+// This test creates a bunch of tasks that simultaneously send to each\n+// other in a ring. The messages should all be basically\n+// independent.\n+// This is like msgsend-ring-pipes but adapted to use ARCs.\n+\n+// This also serves as a pipes test, because ARCs are implemented with pipes.\n+\n+// xfail-pretty\n+\n+import future::future;\n+\n+use std;\n+import std::time;\n+import std::arc;\n+\n+// A poor man's pipe.\n+type pipe = arc::mutex_arc<~[uint]>;\n+\n+fn send(p: &pipe, msg: uint) {\n+    do p.access_cond |state, cond| {\n+        vec::push(*state, msg);\n+        cond.signal();\n+    }\n+}\n+fn recv(p: &pipe) -> uint {\n+    do p.access_cond |state, cond| {\n+        while vec::is_empty(*state) {\n+            cond.wait();\n+        }\n+        vec::pop(*state)\n+    }\n+}\n+\n+fn init() -> (pipe,pipe) {\n+    let m = arc::mutex_arc(~[]);\n+    ((&m).clone(), m)\n+}\n+\n+\n+fn thread_ring(i: uint,\n+               count: uint,\n+               +num_chan: pipe,\n+               +num_port: pipe) {\n+    let mut num_chan <- some(num_chan);\n+    let mut num_port <- some(num_port);\n+    // Send/Receive lots of messages.\n+    for uint::range(0u, count) |j| {\n+        //error!{\"task %?, iter %?\", i, j};\n+        let mut num_chan2 = option::swap_unwrap(&mut num_chan);\n+        let mut num_port2 = option::swap_unwrap(&mut num_port);\n+        send(&num_chan2, i * j);\n+        num_chan = some(num_chan2);\n+        let _n = recv(&num_port2);\n+        //log(error, _n);\n+        num_port = some(num_port2);\n+    };\n+}\n+\n+fn main(args: ~[~str]) {\n+    let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n+        ~[~\"\", ~\"100\", ~\"10000\"]\n+    } else if args.len() <= 1u {\n+        ~[~\"\", ~\"10\", ~\"100\"]\n+    } else {\n+        copy args\n+    }; \n+\n+    let num_tasks = option::get(uint::from_str(args[1]));\n+    let msg_per_task = option::get(uint::from_str(args[2]));\n+\n+    let (num_chan, num_port) = init();\n+    let mut num_chan = some(num_chan);\n+\n+    let start = time::precise_time_s();\n+\n+    // create the ring\n+    let mut futures = ~[];\n+\n+    for uint::range(1u, num_tasks) |i| {\n+        //error!{\"spawning %?\", i};\n+        let (new_chan, num_port) = init();\n+        let num_chan2 = ~mut none;\n+        *num_chan2 <-> num_chan;\n+        let num_port = ~mut some(num_port);\n+        futures += ~[future::spawn(|move num_chan2, move num_port| {\n+            let mut num_chan = none;\n+            num_chan <-> *num_chan2;\n+            let mut num_port1 = none;\n+            num_port1 <-> *num_port;\n+            thread_ring(i, msg_per_task,\n+                        option::unwrap(num_chan),\n+                        option::unwrap(num_port1))\n+        })];\n+        num_chan = some(new_chan);\n+    };\n+\n+    // do our iteration\n+    thread_ring(0u, msg_per_task, option::unwrap(num_chan), num_port);\n+\n+    // synchronize\n+    for futures.each |f| { future::get(&f) };\n+\n+    let stop = time::precise_time_s();\n+\n+    // all done, report stats.\n+    let num_msgs = num_tasks * msg_per_task;\n+    let elapsed = (stop - start);\n+    let rate = (num_msgs as float) / elapsed;\n+\n+    io::println(fmt!{\"Sent %? messages in %? seconds\",\n+                     num_msgs, elapsed});\n+    io::println(fmt!{\"  %? messages / second\", rate});\n+    io::println(fmt!{\"  %? \u03bcs / message\", 1000000. / rate});\n+}"}, {"sha": "6dcaabdb56e37fa50116e2ee37957e9f4c2eb47b", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/7fe1005fd124fe79f4a4ea17d0056e55ff7bd3ae/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe1005fd124fe79f4a4ea17d0056e55ff7bd3ae/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=7fe1005fd124fe79f4a4ea17d0056e55ff7bd3ae", "patch": "@@ -0,0 +1,115 @@\n+// This test creates a bunch of tasks that simultaneously send to each\n+// other in a ring. The messages should all be basically\n+// independent.\n+// This is like msgsend-ring-pipes but adapted to use ARCs.\n+\n+// This also serves as a pipes test, because ARCs are implemented with pipes.\n+\n+// xfail-pretty\n+\n+import future::future;\n+\n+use std;\n+import std::time;\n+import std::arc;\n+\n+// A poor man's pipe.\n+type pipe = arc::rw_arc<~[uint]>;\n+\n+fn send(p: &pipe, msg: uint) {\n+    do p.write_cond |state, cond| {\n+        vec::push(*state, msg);\n+        cond.signal();\n+    }\n+}\n+fn recv(p: &pipe) -> uint {\n+    do p.write_cond |state, cond| {\n+        while vec::is_empty(*state) {\n+            error!(\"have to wait\");\n+            cond.wait();\n+        }\n+        vec::pop(*state)\n+    }\n+}\n+\n+fn init() -> (pipe,pipe) {\n+    let x = arc::rw_arc(~[]);\n+    ((&x).clone(), x)\n+}\n+\n+\n+fn thread_ring(i: uint,\n+               count: uint,\n+               +num_chan: pipe,\n+               +num_port: pipe) {\n+    let mut num_chan <- some(num_chan);\n+    let mut num_port <- some(num_port);\n+    // Send/Receive lots of messages.\n+    for uint::range(0u, count) |j| {\n+        //error!{\"task %?, iter %?\", i, j};\n+        let mut num_chan2 = option::swap_unwrap(&mut num_chan);\n+        let mut num_port2 = option::swap_unwrap(&mut num_port);\n+        send(&num_chan2, i * j);\n+        num_chan = some(num_chan2);\n+        let _n = recv(&num_port2);\n+        //log(error, _n);\n+        num_port = some(num_port2);\n+    };\n+}\n+\n+fn main(args: ~[~str]) {\n+    let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n+        ~[~\"\", ~\"100\", ~\"10000\"]\n+    } else if args.len() <= 1u {\n+        ~[~\"\", ~\"10\", ~\"100\"]\n+    } else {\n+        copy args\n+    }; \n+\n+    let num_tasks = option::get(uint::from_str(args[1]));\n+    let msg_per_task = option::get(uint::from_str(args[2]));\n+\n+    let (num_chan, num_port) = init();\n+    let mut num_chan = some(num_chan);\n+\n+    let start = time::precise_time_s();\n+\n+    // create the ring\n+    let mut futures = ~[];\n+\n+    for uint::range(1u, num_tasks) |i| {\n+        //error!{\"spawning %?\", i};\n+        let (new_chan, num_port) = init();\n+        let num_chan2 = ~mut none;\n+        *num_chan2 <-> num_chan;\n+        let num_port = ~mut some(num_port);\n+        futures += ~[future::spawn(|move num_chan2, move num_port| {\n+            let mut num_chan = none;\n+            num_chan <-> *num_chan2;\n+            let mut num_port1 = none;\n+            num_port1 <-> *num_port;\n+            thread_ring(i, msg_per_task,\n+                        option::unwrap(num_chan),\n+                        option::unwrap(num_port1))\n+        })];\n+        num_chan = some(new_chan);\n+    };\n+\n+    // do our iteration\n+    thread_ring(0u, msg_per_task, option::unwrap(num_chan), num_port);\n+\n+    // synchronize\n+    for futures.each |f| { future::get(&f) };\n+\n+    let stop = time::precise_time_s();\n+\n+    // all done, report stats.\n+    let num_msgs = num_tasks * msg_per_task;\n+    let elapsed = (stop - start);\n+    let rate = (num_msgs as float) / elapsed;\n+\n+    io::println(fmt!{\"Sent %? messages in %? seconds\",\n+                     num_msgs, elapsed});\n+    io::println(fmt!{\"  %? messages / second\", rate});\n+    io::println(fmt!{\"  %? \u03bcs / message\", 1000000. / rate});\n+}"}]}