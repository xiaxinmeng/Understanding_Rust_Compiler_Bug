{"sha": "54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0NjkxZjlhNmNiNmE5MjE1MmZlNTdlNGNhNGI5ZmI2Mjk4ZGFjMGU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T05:48:10Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:54:45Z"}, "message": "Convert rustc::metadata to istrs. Issue #855", "tree": {"sha": "9c0b2ce6ac202380d404e058e5ec350e1b152a62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c0b2ce6ac202380d404e058e5ec350e1b152a62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e", "html_url": "https://github.com/rust-lang/rust/commit/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d70685eefc98668804c05428bb94f43933cca61", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d70685eefc98668804c05428bb94f43933cca61", "html_url": "https://github.com/rust-lang/rust/commit/7d70685eefc98668804c05428bb94f43933cca61"}], "stats": {"total": 252, "additions": 133, "deletions": 119}, "files": [{"sha": "4078e440bab03e6aca789f88a3b1cec7bb078d2e", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e", "patch": "@@ -491,17 +491,18 @@ fn main(args: [str]) {\n     } else if n_inputs > 1u {\n         sess.fatal(\"Multiple input filenames provided.\");\n     }\n-    let ifile = istr::to_estr(match.free[0]);\n+    let ifile = match.free[0];\n     let saved_out_filename: str = \"\";\n-    let cfg = build_configuration(sess, binary, ifile);\n+    let cfg = build_configuration(sess, binary,\n+                                  istr::to_estr(ifile));\n     let pretty =\n         option::map::<istr,\n                       pp_mode>(bind parse_pretty(sess, _),\n                                getopts::opt_default(match, ~\"pretty\",\n                                                     ~\"normal\"));\n     alt pretty {\n       some::<pp_mode>(ppm) {\n-        pretty_print_input(sess, cfg, ifile, ppm);\n+        pretty_print_input(sess, cfg, istr::to_estr(ifile), ppm);\n         ret;\n       }\n       none::<pp_mode>. {/* continue */ }\n@@ -519,8 +520,8 @@ fn main(args: [str]) {\n         // have to make up a name\n         // We want to toss everything after the final '.'\n         let parts =\n-            if !input_is_stdin(ifile) {\n-                str::split(ifile, '.' as u8)\n+            if !input_is_stdin(istr::to_estr(ifile)) {\n+                istr::to_estrs(istr::split(ifile, '.' as u8))\n             } else { [\"default\", \"rs\"] };\n         vec::pop(parts);\n         saved_out_filename = str::connect(parts, \".\");\n@@ -536,15 +537,15 @@ fn main(args: [str]) {\n               }\n             };\n         let ofile = saved_out_filename + \".\" + suffix;\n-        compile_input(sess, cfg, ifile, ofile);\n+        compile_input(sess, cfg, istr::to_estr(ifile), ofile);\n       }\n       some(ofile) {\n         let ofile = istr::to_estr(ofile);\n         // FIXME: what about windows? This will create a foo.exe.o.\n         saved_out_filename = ofile;\n         let temp_filename =\n             if !stop_after_codegen { ofile + \".o\" } else { ofile };\n-        compile_input(sess, cfg, ifile, temp_filename);\n+        compile_input(sess, cfg, istr::to_estr(ifile), temp_filename);\n       }\n     }\n \n@@ -596,23 +597,23 @@ fn main(args: [str]) {\n     }\n \n     let cstore = sess.get_cstore();\n-    for cratepath: str in cstore::get_used_crate_files(cstore) {\n-        if str::ends_with(cratepath, \".rlib\") {\n-            gcc_args += [istr::from_estr(cratepath)];\n+    for cratepath: istr in cstore::get_used_crate_files(cstore) {\n+        if istr::ends_with(cratepath, ~\".rlib\") {\n+            gcc_args += [cratepath];\n             cont;\n         }\n-        let cratepath = istr::from_estr(cratepath);\n+        let cratepath = cratepath;\n         let dir = fs::dirname(cratepath);\n         if dir != ~\"\" { gcc_args += [~\"-L\" + dir]; }\n         let libarg = unlib(sess.get_targ_cfg(), fs::basename(cratepath));\n         gcc_args += [~\"-l\" + libarg];\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for arg: str in ula { gcc_args += [istr::from_estr(arg)]; }\n+    for arg: istr in ula { gcc_args += [arg]; }\n \n     let used_libs = cstore::get_used_libraries(cstore);\n-    for l: str in used_libs { gcc_args += [~\"-l\" + istr::from_estr(l)]; }\n+    for l: istr in used_libs { gcc_args += [~\"-l\" + l]; }\n \n     if sopts.library {\n         gcc_args += [istr::from_estr(lib_cmd)];"}, {"sha": "1c607cc81975cb588cefc92de095924cd230d617", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e", "patch": "@@ -35,7 +35,8 @@ fn read_crates(sess: session::session, crate: &ast::crate) {\n     let e =\n         @{sess: sess,\n           crate_cache: @std::map::new_str_hash::<int>(),\n-          library_search_paths: sess.get_opts().library_search_paths,\n+          library_search_paths:\n+          istr::from_estrs(sess.get_opts().library_search_paths),\n           mutable next_crate_num: 1};\n     let v =\n         visit::mk_simple_visitor(@{visit_view_item:\n@@ -48,7 +49,7 @@ fn read_crates(sess: session::session, crate: &ast::crate) {\n type env =\n     @{sess: session::session,\n       crate_cache: @hashmap<istr, int>,\n-      library_search_paths: [str],\n+      library_search_paths: [istr],\n       mutable next_crate_num: ast::crate_num};\n \n fn visit_view_item(e: env, i: &@ast::view_item) {\n@@ -69,12 +70,12 @@ fn visit_item(e: env, i: &@ast::item) {\n         }\n         let cstore = e.sess.get_cstore();\n         if !cstore::add_used_library(cstore,\n-                                     istr::to_estr(m.native_name)) { ret; }\n+                                     m.native_name) { ret; }\n         for a: ast::attribute in\n             attr::find_attrs_by_name(i.attrs, ~\"link_args\") {\n             alt attr::get_meta_item_value_str(attr::attr_meta(a)) {\n               some(linkarg) {\n-                cstore::add_used_link_args(cstore, istr::to_estr(linkarg));\n+                cstore::add_used_link_args(cstore, linkarg);\n               }\n               none. {/* fallthrough */ }\n             }\n@@ -85,12 +86,12 @@ fn visit_item(e: env, i: &@ast::item) {\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-fn list_file_metadata(path: str, out: io::writer) {\n+fn list_file_metadata(path: &istr, out: io::writer) {\n     alt get_metadata_section(path) {\n       option::some(bytes) { decoder::list_crate_metadata(bytes, out); }\n       option::none. {\n         out.write_str(\n-            istr::from_estr(\"Could not find metadata in \" + path + \".\\n\"));\n+            ~\"Could not find metadata in \" + path + ~\".\\n\");\n       }\n     }\n }\n@@ -112,18 +113,18 @@ fn metadata_matches(crate_data: &@[u8], metas: &[@ast::meta_item]) -> bool {\n }\n \n fn default_native_lib_naming(sess: session::session, static: bool) ->\n-   {prefix: str, suffix: str} {\n-    if static { ret {prefix: \"lib\", suffix: \".rlib\"}; }\n+   {prefix: istr, suffix: istr} {\n+    if static { ret {prefix: ~\"lib\", suffix: ~\".rlib\"}; }\n     alt sess.get_targ_cfg().os {\n-      session::os_win32. { ret {prefix: \"\", suffix: \".dll\"}; }\n-      session::os_macos. { ret {prefix: \"lib\", suffix: \".dylib\"}; }\n-      session::os_linux. { ret {prefix: \"lib\", suffix: \".so\"}; }\n+      session::os_win32. { ret {prefix: ~\"\", suffix: ~\".dll\"}; }\n+      session::os_macos. { ret {prefix: ~\"lib\", suffix: ~\".dylib\"}; }\n+      session::os_linux. { ret {prefix: ~\"lib\", suffix: ~\".so\"}; }\n     }\n }\n \n fn find_library_crate(sess: &session::session, ident: &ast::ident,\n-                      metas: &[@ast::meta_item], library_search_paths: &[str])\n-   -> option::t<{ident: str, data: @[u8]}> {\n+                      metas: &[@ast::meta_item], library_search_paths: &[istr])\n+   -> option::t<{ident: istr, data: @[u8]}> {\n \n     attr::require_unique_names(sess, metas);\n \n@@ -145,48 +146,49 @@ fn find_library_crate(sess: &session::session, ident: &ast::ident,\n \n     let nn = default_native_lib_naming(sess, sess.get_opts().static);\n     let x =\n-        find_library_crate_aux(nn, istr::to_estr(crate_name),\n+        find_library_crate_aux(nn, crate_name,\n                                metas, library_search_paths);\n     if x != none || sess.get_opts().static { ret x; }\n     let nn2 = default_native_lib_naming(sess, true);\n-    ret find_library_crate_aux(nn2, istr::to_estr(crate_name),\n+    ret find_library_crate_aux(nn2, crate_name,\n                                metas, library_search_paths);\n }\n \n-fn find_library_crate_aux(nn: &{prefix: str, suffix: str}, crate_name: str,\n+fn find_library_crate_aux(nn: &{prefix: istr, suffix: istr},\n+                          crate_name: &istr,\n                           metas: &[@ast::meta_item],\n-                          library_search_paths: &[str]) ->\n-   option::t<{ident: str, data: @[u8]}> {\n-    let prefix: istr = istr::from_estr(nn.prefix + crate_name);\n-    let suffix: istr = istr::from_estr(nn.suffix);\n+                          library_search_paths: &[istr]) ->\n+   option::t<{ident: istr, data: @[u8]}> {\n+    let prefix: istr = nn.prefix + crate_name;\n+    let suffix: istr = nn.suffix;\n     // FIXME: we could probably use a 'glob' function in std::fs but it will\n     // be much easier to write once the unsafe module knows more about FFI\n     // tricks. Currently the glob(3) interface is a bit more than we can\n     // stomach from here, and writing a C++ wrapper is more work than just\n     // manually filtering fs::list_dir here.\n \n-    for library_search_path: str in library_search_paths {\n-        log #fmt[\"searching %s\", library_search_path];\n-        let library_search_path = istr::from_estr(library_search_path);\n+    for library_search_path: istr in library_search_paths {\n+        log #fmt[\"searching %s\", istr::to_estr(library_search_path)];\n         for path: istr in fs::list_dir(library_search_path) {\n             log #fmt[\"searching %s\", istr::to_estr(path)];\n             let f: istr = fs::basename(path);\n-            let path = istr::to_estr(path);\n             if !(istr::starts_with(f, prefix) && istr::ends_with(f, suffix))\n                {\n                 log #fmt[\"skipping %s, doesn't look like %s*%s\",\n-                         path,\n+                         istr::to_estr(path),\n                          istr::to_estr(prefix),\n                          istr::to_estr(suffix)];\n                 cont;\n             }\n             alt get_metadata_section(path) {\n               option::some(cvec) {\n                 if !metadata_matches(cvec, metas) {\n-                    log #fmt[\"skipping %s, metadata doesn't match\", path];\n+                    log #fmt[\"skipping %s, metadata doesn't match\",\n+                             istr::to_estr(path)];\n                     cont;\n                 }\n-                log #fmt[\"found %s with matching metadata\", path];\n+                log #fmt[\"found %s with matching metadata\",\n+                         istr::to_estr(path)];\n                 ret some({ident: path, data: cvec});\n               }\n               _ { }\n@@ -196,8 +198,8 @@ fn find_library_crate_aux(nn: &{prefix: str, suffix: str}, crate_name: str,\n     ret none;\n }\n \n-fn get_metadata_section(filename: str) -> option::t<@[u8]> {\n-    let mb = istr::as_buf(istr::from_estr(filename), { |buf|\n+fn get_metadata_section(filename: &istr) -> option::t<@[u8]> {\n+    let mb = istr::as_buf(filename, { |buf|\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n     });\n     if mb as int == 0 { ret option::none::<@[u8]>; }\n@@ -218,8 +220,9 @@ fn get_metadata_section(filename: str) -> option::t<@[u8]> {\n }\n \n fn load_library_crate(sess: &session::session, span: span, ident: &ast::ident,\n-                      metas: &[@ast::meta_item], library_search_paths: &[str])\n-   -> {ident: str, data: @[u8]} {\n+                      metas: &[@ast::meta_item],\n+                      library_search_paths: &[istr])\n+   -> {ident: istr, data: @[u8]} {\n \n \n     alt find_library_crate(sess, ident, metas, library_search_paths) {\n@@ -249,12 +252,13 @@ fn resolve_crate(e: env, ident: &ast::ident, metas: [@ast::meta_item],\n         // Now resolve the crates referenced by this crate\n         let cnum_map = resolve_crate_deps(e, cdata);\n \n-        let cmeta = {name: istr::to_estr(ident),\n+        let cmeta = {name: ident,\n                      data: cdata, cnum_map: cnum_map};\n \n         let cstore = e.sess.get_cstore();\n         cstore::set_crate_data(cstore, cnum, cmeta);\n-        cstore::add_used_crate_file(cstore, cfilename);\n+        cstore::add_used_crate_file(cstore,\n+                                    cfilename);\n         ret cnum;\n     } else { ret e.crate_cache.get(ident); }\n }\n@@ -268,19 +272,19 @@ fn resolve_crate_deps(e: env, cdata: &@[u8]) -> cstore::cnum_map {\n     for dep: decoder::crate_dep in decoder::get_crate_deps(cdata) {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.ident;\n-        log #fmt[\"resolving dep %s\", cname];\n-        if e.crate_cache.contains_key(istr::from_estr(cname)) {\n+        log #fmt[\"resolving dep %s\", istr::to_estr(cname)];\n+        if e.crate_cache.contains_key(cname) {\n             log \"already have it\";\n             // We've already seen this crate\n-            let local_cnum = e.crate_cache.get(istr::from_estr(cname));\n+            let local_cnum = e.crate_cache.get(cname);\n             cnum_map.insert(extrn_cnum, local_cnum);\n         } else {\n             log \"need to load it\";\n             // This is a new one so we've got to load it\n             // FIXME: Need better error reporting than just a bogus span\n             let fake_span = ast_util::dummy_sp();\n             let local_cnum = resolve_crate(e,\n-                                           istr::from_estr(cname),\n+                                           cname,\n                                            [], fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n         }"}, {"sha": "6a1c9d9a66660569c841d43046e47491c6e1e7f5", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e", "patch": "@@ -11,7 +11,7 @@ export lookup_defs;\n export get_tag_variants;\n export get_type;\n \n-fn get_symbol(cstore: &cstore::cstore, def: ast::def_id) -> str {\n+fn get_symbol(cstore: &cstore::cstore, def: ast::def_id) -> istr {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n     ret decoder::get_symbol(cdata, def.node);\n }"}, {"sha": "5ff01c9464689ec8d0aa3a652b23e9bcbac70077", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e", "patch": "@@ -4,6 +4,7 @@\n import std::vec;\n import std::map;\n import std::str;\n+import std::istr;\n import syntax::ast;\n \n export cstore;\n@@ -29,7 +30,7 @@ export get_use_stmt_cnum;\n // own crate numbers.\n type cnum_map = map::hashmap<ast::crate_num, ast::crate_num>;\n \n-type crate_metadata = {name: str, data: @[u8], cnum_map: cnum_map};\n+type crate_metadata = {name: istr, data: @[u8], cnum_map: cnum_map};\n \n // This is a bit of an experiment at encapsulating the data in cstore. By\n // keeping all the data in a non-exported tag variant, it's impossible for\n@@ -41,9 +42,9 @@ tag cstore { private(cstore_private); }\n type cstore_private =\n     @{metas: map::hashmap<ast::crate_num, crate_metadata>,\n       use_crate_map: use_crate_map,\n-      mutable used_crate_files: [str],\n-      mutable used_libraries: [str],\n-      mutable used_link_args: [str]};\n+      mutable used_crate_files: [istr],\n+      mutable used_libraries: [istr],\n+      mutable used_link_args: [istr]};\n \n // Map from node_id's of local use statements to crate numbers\n type use_crate_map = map::hashmap<ast::node_id, ast::crate_num>;\n@@ -82,34 +83,34 @@ iter iter_crate_data(cstore: &cstore) ->\n     }\n }\n \n-fn add_used_crate_file(cstore: &cstore, lib: &str) {\n+fn add_used_crate_file(cstore: &cstore, lib: &istr) {\n     if !vec::member(lib, p(cstore).used_crate_files) {\n         p(cstore).used_crate_files += [lib];\n     }\n }\n \n-fn get_used_crate_files(cstore: &cstore) -> [str] {\n+fn get_used_crate_files(cstore: &cstore) -> [istr] {\n     ret p(cstore).used_crate_files;\n }\n \n-fn add_used_library(cstore: &cstore, lib: &str) -> bool {\n-    if lib == \"\" { ret false; }\n+fn add_used_library(cstore: &cstore, lib: &istr) -> bool {\n+    if lib == ~\"\" { ret false; }\n \n     if vec::member(lib, p(cstore).used_libraries) { ret false; }\n \n     p(cstore).used_libraries += [lib];\n     ret true;\n }\n \n-fn get_used_libraries(cstore: &cstore) -> [str] {\n+fn get_used_libraries(cstore: &cstore) -> [istr] {\n     ret p(cstore).used_libraries;\n }\n \n-fn add_used_link_args(cstore: &cstore, args: &str) {\n-    p(cstore).used_link_args += str::split(args, ' ' as u8);\n+fn add_used_link_args(cstore: &cstore, args: &istr) {\n+    p(cstore).used_link_args += istr::split(args, ' ' as u8);\n }\n \n-fn get_used_link_args(cstore: &cstore) -> [str] {\n+fn get_used_link_args(cstore: &cstore) -> [istr] {\n     ret p(cstore).used_link_args;\n }\n "}, {"sha": "5a856723f0e442e6e57863d296d4614b312b2798", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e", "patch": "@@ -84,9 +84,9 @@ fn item_family(item: &ebml::doc) -> u8 {\n     ret ebml::doc_as_uint(fam) as u8;\n }\n \n-fn item_symbol(item: &ebml::doc) -> str {\n+fn item_symbol(item: &ebml::doc) -> istr {\n     let sym = ebml::get_doc(item, tag_items_data_item_symbol);\n-    ret str::unsafe_from_bytes(ebml::doc_data(sym));\n+    ret istr::unsafe_from_bytes(ebml::doc_data(sym));\n }\n \n fn variant_tag_id(d: &ebml::doc) -> ast::def_id {\n@@ -97,9 +97,9 @@ fn variant_tag_id(d: &ebml::doc) -> ast::def_id {\n fn item_type(item: &ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n              extres: &external_resolver) -> ty::t {\n     fn parse_external_def_id(this_cnum: ast::crate_num,\n-                             extres: &external_resolver, s: str) ->\n+                             extres: &external_resolver, s: &istr) ->\n        ast::def_id {\n-        let buf = str::bytes(s);\n+        let buf = istr::bytes(s);\n         let external_def_id = parse_def_id(buf);\n \n \n@@ -150,16 +150,16 @@ fn tag_variant_ids(item: &ebml::doc, this_cnum: ast::crate_num) ->\n // Given a path and serialized crate metadata, returns the ID of the\n // definition the path refers to.\n fn resolve_path(path: &[ast::ident], data: @[u8]) -> [ast::def_id] {\n-    fn eq_item(data: &[u8], s: str) -> bool {\n-        ret str::eq(str::unsafe_from_bytes(data), s);\n+    fn eq_item(data: &[u8], s: &istr) -> bool {\n+        ret istr::eq(istr::unsafe_from_bytes(data), s);\n     }\n-    let s = istr::to_estr(istr::connect(path, ~\"::\"));\n+    let s = istr::connect(path, ~\"::\");\n     let md = ebml::new_doc(data);\n     let paths = ebml::get_doc(md, tag_paths);\n     let eqer = bind eq_item(_, s);\n     let result: [ast::def_id] = [];\n     for doc: ebml::doc in lookup_hash(paths, eqer,\n-                                      hash_path(istr::from_estr(s))) {\n+                                      hash_path(s)) {\n         let did_doc = ebml::get_doc(doc, tag_def_id);\n         result += [parse_def_id(ebml::doc_data(did_doc))];\n     }\n@@ -223,7 +223,7 @@ fn get_type_param_kinds(data: @[u8], id: ast::node_id) -> [ast::kind] {\n     ret item_ty_param_kinds(lookup_item(id, data));\n }\n \n-fn get_symbol(data: @[u8], id: ast::node_id) -> str {\n+fn get_symbol(data: @[u8], id: ast::node_id) -> istr {\n     ret item_symbol(lookup_item(id, data));\n }\n \n@@ -269,31 +269,31 @@ fn family_has_type_params(fam_ch: u8) -> bool {\n         };\n }\n \n-fn read_path(d: &ebml::doc) -> {path: str, pos: uint} {\n+fn read_path(d: &ebml::doc) -> {path: istr, pos: uint} {\n     let desc = ebml::doc_data(d);\n     let pos = ebml::be_uint_from_bytes(@desc, 0u, 4u);\n     let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n-    let path = str::unsafe_from_bytes(pathbytes);\n+    let path = istr::unsafe_from_bytes(pathbytes);\n     ret {path: path, pos: pos};\n }\n \n-fn describe_def(items: &ebml::doc, id: ast::def_id) -> str {\n-    if id.crate != ast::local_crate { ret \"external\"; }\n+fn describe_def(items: &ebml::doc, id: ast::def_id) -> istr {\n+    if id.crate != ast::local_crate { ret ~\"external\"; }\n     ret item_family_to_str(item_family(find_item(id.node, items)));\n }\n \n-fn item_family_to_str(fam: u8) -> str {\n+fn item_family_to_str(fam: u8) -> istr {\n     alt fam as char {\n-      'c' { ret \"const\"; }\n-      'f' { ret \"fn\"; }\n-      'p' { ret \"pure fn\"; }\n-      'F' { ret \"native fn\"; }\n-      'y' { ret \"type\"; }\n-      'T' { ret \"native type\"; }\n-      't' { ret \"type\"; }\n-      'm' { ret \"mod\"; }\n-      'n' { ret \"native mod\"; }\n-      'v' { ret \"tag\"; }\n+      'c' { ret ~\"const\"; }\n+      'f' { ret ~\"fn\"; }\n+      'p' { ret ~\"pure fn\"; }\n+      'F' { ret ~\"native fn\"; }\n+      'y' { ret ~\"type\"; }\n+      'T' { ret ~\"native type\"; }\n+      't' { ret ~\"type\"; }\n+      'm' { ret ~\"mod\"; }\n+      'n' { ret ~\"native mod\"; }\n+      'v' { ret ~\"tag\"; }\n     }\n }\n \n@@ -368,15 +368,15 @@ fn get_crate_attributes(data: @[u8]) -> [ast::attribute] {\n     ret get_attributes(ebml::new_doc(data));\n }\n \n-type crate_dep = {cnum: ast::crate_num, ident: str};\n+type crate_dep = {cnum: ast::crate_num, ident: istr};\n \n fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n     let deps: [crate_dep] = [];\n     let cratedoc = ebml::new_doc(data);\n     let depsdoc = ebml::get_doc(cratedoc, tag_crate_deps);\n     let crate_num = 1;\n     for each depdoc: ebml::doc in ebml::tagged_docs(depsdoc, tag_crate_dep) {\n-        let depname = str::unsafe_from_bytes(ebml::doc_data(depdoc));\n+        let depname = istr::unsafe_from_bytes(ebml::doc_data(depdoc));\n         deps += [{cnum: crate_num, ident: depname}];\n         crate_num += 1;\n     }\n@@ -388,7 +388,8 @@ fn list_crate_deps(data: @[u8], out: io::writer) {\n \n     for dep: crate_dep in get_crate_deps(data) {\n         out.write_str(\n-            istr::from_estr(#fmt[\"%d %s\\n\", dep.cnum, dep.ident]));\n+            istr::from_estr(#fmt[\"%d %s\\n\", dep.cnum,\n+                                 istr::to_estr(dep.ident)]));\n     }\n \n     out.write_str(~\"\\n\");\n@@ -409,8 +410,10 @@ fn list_crate_items(bytes: &@[u8], md: &ebml::doc, out: io::writer) {\n             let did_doc = ebml::get_doc(def, tag_def_id);\n             let did = parse_def_id(ebml::doc_data(did_doc));\n             out.write_str(\n-                istr::from_estr(#fmt[\"%s (%s)\\n\", data.path,\n-                                     describe_def(items, did)]));\n+                istr::from_estr(\n+                    #fmt[\"%s (%s)\\n\",\n+                         istr::to_estr(data.path),\n+                         istr::to_estr(describe_def(items, did))]));\n         }\n     }\n     out.write_str(~\"\\n\");"}, {"sha": "c5dd0fa4cefb1893a6d16ef991160707d8c21efe", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e", "patch": "@@ -35,7 +35,7 @@ fn encode_name(ebml_w: &ebml::writer, name: &istr) {\n \n fn encode_def_id(ebml_w: &ebml::writer, id: &def_id) {\n     ebml::start_tag(ebml_w, tag_def_id);\n-    ebml_w.writer.write(str::bytes(def_to_str(id)));\n+    ebml_w.writer.write(istr::bytes(def_to_str(id)));\n     ebml::end_tag(ebml_w);\n }\n \n@@ -177,7 +177,9 @@ fn encode_inlineness(ebml_w: &ebml::writer, c: u8) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn def_to_str(did: &def_id) -> str { ret #fmt[\"%d:%d\", did.crate, did.node]; }\n+fn def_to_str(did: &def_id) -> istr {\n+    ret istr::from_estr(#fmt[\"%d:%d\", did.crate, did.node]);\n+}\n \n fn encode_type_param_kinds(ebml_w: &ebml::writer, tps: &[ty_param]) {\n     ebml::start_tag(ebml_w, tag_items_data_item_ty_param_kinds);\n@@ -196,7 +198,7 @@ fn encode_type_param_kinds(ebml_w: &ebml::writer, tps: &[ty_param]) {\n \n fn encode_variant_id(ebml_w: &ebml::writer, vid: &def_id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_variant);\n-    ebml_w.writer.write(str::bytes(def_to_str(vid)));\n+    ebml_w.writer.write(istr::bytes(def_to_str(vid)));\n     ebml::end_tag(ebml_w);\n }\n \n@@ -226,7 +228,7 @@ fn encode_discriminant(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n \n fn encode_tag_id(ebml_w: &ebml::writer, id: &def_id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_tag_id);\n-    ebml_w.writer.write(str::bytes(def_to_str(id)));\n+    ebml_w.writer.write(istr::bytes(def_to_str(id)));\n     ebml::end_tag(ebml_w);\n }\n \n@@ -550,9 +552,9 @@ fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> [attribute] {\n \n fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n \n-    fn get_ordered_names(cstore: &cstore::cstore) -> [str] {\n+    fn get_ordered_names(cstore: &cstore::cstore) -> [istr] {\n         type hashkv = @{key: crate_num, val: cstore::crate_metadata};\n-        type numname = {crate: crate_num, ident: str};\n+        type numname = {crate: crate_num, ident: istr};\n \n         // Pull the cnums and names out of cstore\n         let pairs: [mutable numname] = [mutable];\n@@ -574,7 +576,7 @@ fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n         }\n \n         // Return just the names\n-        fn name(kv: &numname) -> str { kv.ident }\n+        fn name(kv: &numname) -> istr { kv.ident }\n         // mutable -> immutable hack for vec::map\n         let immpairs = vec::slice(pairs, 0u, vec::len(pairs));\n         ret vec::map(name, immpairs);\n@@ -585,15 +587,15 @@ fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n     // FIXME: This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n     ebml::start_tag(ebml_w, tag_crate_deps);\n-    for cname: str in get_ordered_names(cstore) {\n+    for cname: istr in get_ordered_names(cstore) {\n         ebml::start_tag(ebml_w, tag_crate_dep);\n-        ebml_w.writer.write(str::bytes(cname));\n+        ebml_w.writer.write(istr::bytes(cname));\n         ebml::end_tag(ebml_w);\n     }\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_metadata(cx: &@crate_ctxt, crate: &@crate) -> str {\n+fn encode_metadata(cx: &@crate_ctxt, crate: &@crate) -> istr {\n \n     let abbrevs = map::mk_hashmap(ty::hash_ty, ty::eq_ty);\n     let ecx = @{ccx: cx, type_abbrevs: abbrevs};\n@@ -625,7 +627,7 @@ fn encode_metadata(cx: &@crate_ctxt, crate: &@crate) -> str {\n     // remaining % 4 bytes.\n \n     buf_w.write([0u8, 0u8, 0u8, 0u8]);\n-    ret istr::to_estr(string_w.get_str());\n+    ret string_w.get_str();\n }\n \n // Get the encoded string for a type"}, {"sha": "5da912257f9d19f501695ebee32aede5dc1a19cc", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e", "patch": "@@ -21,7 +21,7 @@ export parse_ty_data;\n // data buffer. Whatever format you choose should not contain pipe characters.\n \n // Callback to translate defs to strs or back:\n-type str_def = fn(str) -> ast::def_id;\n+type str_def = fn(&istr) -> ast::def_id;\n \n type pstate =\n     {data: @[u8], crate: int, mutable pos: uint, len: uint, tcx: ty::ctxt};\n@@ -344,8 +344,10 @@ fn parse_mt(st: @pstate, sd: str_def) -> ty::mt {\n }\n \n fn parse_def(st: @pstate, sd: str_def) -> ast::def_id {\n-    let def = \"\";\n-    while peek(st) as char != '|' { def += str::unsafe_from_byte(next(st)); }\n+    let def = ~\"\";\n+    while peek(st) as char != '|' {\n+        def += istr::unsafe_from_byte(next(st));\n+    }\n     st.pos = st.pos + 1u;\n     ret sd(def);\n }"}, {"sha": "af6fe4ab7aedb8a0492c206aae756c8304d6c9ed", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e", "patch": "@@ -21,7 +21,7 @@ export enc_ty;\n type ctxt =\n      // Def -> str Callback:\n      // The type context.\n-     {ds: fn(&def_id) -> str, tcx: ty::ctxt, abbrevs: abbrev_ctxt};\n+     {ds: fn(&def_id) -> istr, tcx: ty::ctxt, abbrevs: abbrev_ctxt};\n \n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n // Extra parameters are for converting to/from def_ids in the string rep.\n@@ -117,7 +117,7 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n       ty::ty_istr. { w.write_char('S'); }\n       ty::ty_tag(def, tys) {\n         w.write_str(~\"t[\");\n-        w.write_str(istr::from_estr(cx.ds(def)));\n+        w.write_str(cx.ds(def));\n         w.write_char('|');\n         for t: ty::t in tys { enc_ty(w, cx, t); }\n         w.write_char(']');\n@@ -166,7 +166,7 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n       }\n       ty::ty_res(def, ty, tps) {\n         w.write_str(~\"r[\");\n-        w.write_str(istr::from_estr(cx.ds(def)));\n+        w.write_str(cx.ds(def));\n         w.write_char('|');\n         enc_ty(w, cx, ty);\n         for t: ty::t in tps { enc_ty(w, cx, t); }\n@@ -178,7 +178,7 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n       }\n       ty::ty_native(def) {\n         w.write_char('E');\n-        w.write_str(istr::from_estr(cx.ds(def)));\n+        w.write_str(cx.ds(def));\n         w.write_char('|');\n       }\n       ty::ty_param(id, k) {\n@@ -237,7 +237,7 @@ fn enc_ty_fn(w: &io::writer, cx: &@ctxt, args: &[ty::arg], out: ty::t,\n fn enc_constr(w: &io::writer, cx: &@ctxt, c: &@ty::constr) {\n     w.write_str(istr::from_estr(path_to_str(c.node.path)));\n     w.write_char('(');\n-    w.write_str(istr::from_estr(cx.ds(c.node.id)));\n+    w.write_str(cx.ds(c.node.id));\n     w.write_char('|');\n     let semi = false;\n     for a: @constr_arg in c.node.args {\n@@ -256,7 +256,7 @@ fn enc_constr(w: &io::writer, cx: &@ctxt, c: &@ty::constr) {\n fn enc_ty_constr(w: &io::writer, cx: &@ctxt, c: &@ty::type_constr) {\n     w.write_str(istr::from_estr(path_to_str(c.node.path)));\n     w.write_char('(');\n-    w.write_str(istr::from_estr(cx.ds(c.node.id)));\n+    w.write_str(cx.ds(c.node.id));\n     w.write_char('|');\n     let semi = false;\n     for a: @ty::ty_constr_arg in c.node.args {"}, {"sha": "9cc38d0ef2434969c912a3091444f78c76a04cf8", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e", "patch": "@@ -3290,7 +3290,7 @@ fn trans_external_path(cx: &@block_ctxt, did: &ast::def_id,\n     let lcx = cx.fcx.lcx;\n     let name = csearch::get_symbol(lcx.ccx.sess.get_cstore(), did);\n     ret get_extern_const(lcx.ccx.externs, lcx.ccx.llmod,\n-                         istr::from_estr(name),\n+                         name,\n                          type_of_ty_param_kinds_and_ty(lcx, cx.sp, tpt));\n }\n \n@@ -3331,7 +3331,7 @@ fn lookup_discriminant(lcx: &@local_ctxt, vid: &ast::def_id) -> ValueRef {\n         // It's an external discriminant that we haven't seen yet.\n         assert (vid.crate != ast::local_crate);\n         let sym = csearch::get_symbol(lcx.ccx.sess.get_cstore(), vid);\n-        let gvar = istr::as_buf(istr::from_estr(sym), { |buf|\n+        let gvar = istr::as_buf(sym, { |buf|\n             llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), buf)\n         });\n         llvm::LLVMSetLinkage(gvar,\n@@ -6350,8 +6350,9 @@ fn create_crate_map(ccx: &@crate_ctxt) -> ValueRef {\n     let i = 1;\n     let cstore = ccx.sess.get_cstore();\n     while cstore::have_crate_data(cstore, i) {\n-        let nm = \"_rust_crate_map_\" + cstore::get_crate_data(cstore, i).name;\n-        let cr = istr::as_buf(istr::from_estr(nm), { |buf|\n+        let nm = ~\"_rust_crate_map_\" +\n+            cstore::get_crate_data(cstore, i).name;\n+        let cr = istr::as_buf(nm, { |buf|\n             llvm::LLVMAddGlobal(ccx.llmod, T_int(), buf)\n         });\n         subcrates += [p2i(cr)];\n@@ -6379,7 +6380,7 @@ fn create_crate_map(ccx: &@crate_ctxt) -> ValueRef {\n fn write_metadata(cx: &@crate_ctxt, crate: &@ast::crate) {\n     if !cx.sess.get_opts().library { ret; }\n     let llmeta = C_postr(\n-        istr::from_estr(metadata::encoder::encode_metadata(cx, crate)));\n+        metadata::encoder::encode_metadata(cx, crate));\n     let llconst = trans_common::C_struct([llmeta]);\n     let llglobal = istr::as_buf(~\"rust_metadata\", { |buf|\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)"}, {"sha": "07feb778dd39500f0e6f76be851ef908e7ebe27d", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=54691f9a6cb6a92152fe57e4ca4b9fb6298dac0e", "patch": "@@ -354,9 +354,9 @@ fn get_res_dtor(ccx: &@crate_ctxt, sp: &span, did: &ast::def_id,\n                           [{mode: ty::mo_alias(false), ty: inner_t}],\n                           ty::mk_nil(ccx.tcx), params);\n     ret trans::get_extern_const(ccx.externs, ccx.llmod,\n-                                istr::from_estr(csearch::get_symbol(\n+                                csearch::get_symbol(\n                                     ccx.sess.get_cstore(),\n-                                    did)),\n+                                    did),\n                                 T_fn_pair(*ccx, f_t));\n }\n "}]}