{"sha": "b082f78024961d7a66b0c02d55d1e8685ea728f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwODJmNzgwMjQ5NjFkN2E2NmIwYzAyZDU1ZDFlODY4NWVhNzI4ZjE=", "commit": {"author": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2017-11-16T20:59:27Z"}, "committer": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2017-11-20T04:19:36Z"}, "message": "initialize `Access` with macro", "tree": {"sha": "89d87581caf2f6007e46513f03ba79fb1227315f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89d87581caf2f6007e46513f03ba79fb1227315f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b082f78024961d7a66b0c02d55d1e8685ea728f1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFKBAABCAA0FiEELriChyEaiMu0yCg7viIhAz7bw3QFAloSV9gWHGFydXNzZWxs\nMTIzQGdtYWlsLmNvbQAKCRC+IiEDPtvDdBTPB/90G2cKqrkWPKFoGZ1irUUswCJt\nOBst35UkXq3wVfQX+wHsUegi/XScJBULpnEPCEWp3/c9/wWMHVbwsCOSXRslgdD3\nCgPOaLsyHrof3HCXOn4+ZV5cIovl7KW5YIKy1hNEqetc1OHKuflMWky7YlT3fcTH\n20GkFrRL2eVA3S/IzYTRAl6WWy4eSKbsUcV/HrZ3PcFQnZKThvi/zOuJDjRfuAnQ\ndiRL8Y+ywqzRdeODjYzyhCNqfSSr6atk0Y7VapzF1/QhjNZIl9aaQFP8Qp1H0Wje\nrmOYOu9b2+6aepOpfunxtRx2TJqD08Qi60HzizJcYbbLRPAOOvvQ7a9LWPZR\n=Oxml\n-----END PGP SIGNATURE-----", "payload": "tree 89d87581caf2f6007e46513f03ba79fb1227315f\nparent 409297f529dad4f297fd695b03bb63f191fe1ca9\nauthor Andy Russell <arussell123@gmail.com> 1510865967 -0500\ncommitter Andy Russell <arussell123@gmail.com> 1511151576 -0500\n\ninitialize `Access` with macro\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b082f78024961d7a66b0c02d55d1e8685ea728f1", "html_url": "https://github.com/rust-lang/rust/commit/b082f78024961d7a66b0c02d55d1e8685ea728f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b082f78024961d7a66b0c02d55d1e8685ea728f1/comments", "author": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "committer": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "409297f529dad4f297fd695b03bb63f191fe1ca9", "url": "https://api.github.com/repos/rust-lang/rust/commits/409297f529dad4f297fd695b03bb63f191fe1ca9", "html_url": "https://github.com/rust-lang/rust/commit/409297f529dad4f297fd695b03bb63f191fe1ca9"}], "stats": {"total": 71, "additions": 19, "deletions": 52}, "files": [{"sha": "d4257e35823b3b4447502709714a53b5ab0da3ef", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 19, "deletions": 52, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b082f78024961d7a66b0c02d55d1e8685ea728f1/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b082f78024961d7a66b0c02d55d1e8685ea728f1/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=b082f78024961d7a66b0c02d55d1e8685ea728f1", "patch": "@@ -59,6 +59,15 @@ macro_rules! down_cast_data {\n     };\n }\n \n+macro_rules! access_from {\n+    ($save_ctxt:expr, $item:expr) => {\n+        Access {\n+            public: $item.vis == ast::Visibility::Public,\n+            reachable: $save_ctxt.analysis.access_levels.is_reachable($item.id),\n+        }\n+    }\n+}\n+\n pub struct DumpVisitor<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n     tcx: TyCtxt<'l, 'tcx, 'tcx>,\n@@ -416,13 +425,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     fn process_struct_field_def(&mut self, field: &ast::StructField, parent_id: NodeId) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n-            self.dumper.dump_def(\n-                &Access {\n-                    public: field.vis == ast::Visibility::Public,\n-                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(field.id),\n-                },\n-                field_data,\n-            );\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, field), field_data);\n         }\n     }\n \n@@ -482,13 +485,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 |v| v.process_formals(&decl.inputs, &fn_data.qualname),\n             );\n             self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n-            self.dumper.dump_def(\n-                &Access {\n-                    public: item.vis == ast::Visibility::Public,\n-                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(item.id),\n-                },\n-                fn_data,\n-            );\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, item), fn_data);\n         }\n \n         for arg in &decl.inputs {\n@@ -511,13 +508,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         self.nest_tables(item.id, |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n-                v.dumper.dump_def(\n-                    &Access {\n-                        public: item.vis == ast::Visibility::Public,\n-                        reachable: v.save_ctxt.analysis.access_levels.is_reachable(item.id),\n-                    },\n-                    var_data,\n-                );\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item), var_data);\n             }\n             v.visit_ty(&typ);\n             v.visit_expr(expr);\n@@ -623,10 +614,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         if !self.span.filter_generated(sub_span, item.span) {\n             let span = self.span_from_span(sub_span.expect(\"No span found for struct\"));\n             self.dumper.dump_def(\n-                &Access {\n-                    public: item.vis == ast::Visibility::Public,\n-                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(item.id),\n-                },\n+                &access_from!(self.save_ctxt, item),\n                 Def {\n                     kind,\n                     id: ::id_from_node_id(item.id, &self.save_ctxt),\n@@ -665,10 +653,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         };\n         down_cast_data!(enum_data, DefData, item.span);\n \n-        let access = Access {\n-            public: item.vis == ast::Visibility::Public,\n-            reachable: self.save_ctxt.analysis.access_levels.is_reachable(item.id),\n-        };\n+        let access = access_from!(self.save_ctxt, item);\n \n         for variant in &enum_definition.variants {\n             let name = variant.node.name.name.to_string();\n@@ -817,10 +802,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 .map(|i| ::id_from_node_id(i.id, &self.save_ctxt))\n                 .collect();\n             self.dumper.dump_def(\n-                &Access {\n-                    public: item.vis == ast::Visibility::Public,\n-                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(item.id),\n-                },\n+                &access_from!(self.save_ctxt, item),\n                 Def {\n                     kind: DefKind::Trait,\n                     id,\n@@ -883,13 +865,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     fn process_mod(&mut self, item: &ast::Item) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, DefData, item.span);\n-            self.dumper.dump_def(\n-                &Access {\n-                    public: item.vis == ast::Visibility::Public,\n-                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(item.id),\n-                },\n-                mod_data,\n-            );\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, item), mod_data);\n         }\n     }\n \n@@ -1300,10 +1276,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n         self.process_macro_use(item.span);\n         match item.node {\n             Use(ref use_item) => {\n-                let access = Access {\n-                    public: item.vis == ast::Visibility::Public,\n-                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(item.id),\n-                };\n+                let access = access_from!(self.save_ctxt, item);\n \n                 match use_item.node {\n                     ast::ViewPathSimple(ident, ref path) => {\n@@ -1432,10 +1405,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     let id = ::id_from_node_id(item.id, &self.save_ctxt);\n \n                     self.dumper.dump_def(\n-                        &Access {\n-                            public: item.vis == ast::Visibility::Public,\n-                            reachable: self.save_ctxt.analysis.access_levels.is_reachable(item.id),\n-                        },\n+                        &access_from!(self.save_ctxt, item),\n                         Def {\n                             kind: DefKind::Type,\n                             id,\n@@ -1727,10 +1697,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n     }\n \n     fn visit_foreign_item(&mut self, item: &'l ast::ForeignItem) {\n-        let access = Access {\n-            public: item.vis == ast::Visibility::Public,\n-            reachable: self.save_ctxt.analysis.access_levels.is_reachable(item.id),\n-        };\n+        let access = access_from!(self.save_ctxt, item);\n \n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {"}]}