{"sha": "3020239de947ec52677e9b4e853a6a9fc073d1f9", "node_id": "C_kwDOAAsO6NoAKDMwMjAyMzlkZTk0N2VjNTI2NzdlOWI0ZTg1M2E2YTlmYzA3M2QxZjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-09T18:20:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-09T18:20:00Z"}, "message": "Auto merge of #106637 - fee1-dead-contrib:rollup-ticvmsd, r=fee1-dead\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #105292 (Change a commit_if_ok call to probe)\n - #105655 (Remove invalid case for mutable borrow suggestion)\n - #106047 (Fix ui constant tests for big-endian platforms)\n - #106061 (Enable Shadow Call Stack for Fuchsia on AArch64)\n - #106164 (Move `check_region_obligations_and_report_errors` to `TypeErrCtxt`)\n - #106291 (Fix incorrect suggestion for extra `&` in pattern)\n - #106389 (Simplify some canonical type alias names)\n - #106468 (Use FxIndexSet when updating obligation causes in `adjust_fulfillment_errors_for_expr_obligation`)\n - #106549 (Use fmt named parameters in rustc_borrowck)\n - #106614 (error-code docs improvements (No. 2))\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "393d2909249b0b800817943263806716fcd06720", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/393d2909249b0b800817943263806716fcd06720"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3020239de947ec52677e9b4e853a6a9fc073d1f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3020239de947ec52677e9b4e853a6a9fc073d1f9", "html_url": "https://github.com/rust-lang/rust/commit/3020239de947ec52677e9b4e853a6a9fc073d1f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3020239de947ec52677e9b4e853a6a9fc073d1f9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af58fc869910eae0ec525d49cbb6d953ea10a8c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/af58fc869910eae0ec525d49cbb6d953ea10a8c6", "html_url": "https://github.com/rust-lang/rust/commit/af58fc869910eae0ec525d49cbb6d953ea10a8c6"}, {"sha": "77f529bb0ae361e6948336f27ce51f686a681e7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/77f529bb0ae361e6948336f27ce51f686a681e7a", "html_url": "https://github.com/rust-lang/rust/commit/77f529bb0ae361e6948336f27ce51f686a681e7a"}], "stats": {"total": 3620, "additions": 2284, "deletions": 1336}, "files": [{"sha": "eda5588a4d52ec09a04071809ce40de54458fac7", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -156,7 +156,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 err.span_note(\n                     MultiSpan::from_spans(reinit_spans),\n                     &if reinits <= 3 {\n-                        format!(\"these {} reinitializations might get skipped\", reinits)\n+                        format!(\"these {reinits} reinitializations might get skipped\")\n                     } else {\n                         format!(\n                             \"these 3 reinitializations and {} other{} might get skipped\",\n@@ -225,9 +225,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 err.span_label(\n                     span,\n                     format!(\n-                        \"value {} here after {}move\",\n+                        \"value {} here after {partial_str}move\",\n                         desired_action.as_verb_in_past_tense(),\n-                        partial_str\n                     ),\n                 );\n             }\n@@ -257,7 +256,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         &format!(\n                             \"consider creating a fresh reborrow of {} here\",\n                             self.describe_place(moved_place)\n-                                .map(|n| format!(\"`{}`\", n))\n+                                .map(|n| format!(\"`{n}`\"))\n                                 .unwrap_or_else(|| \"the mutable reference\".to_string()),\n                         ),\n                         \"&mut *\",\n@@ -271,7 +270,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 DescribePlaceOpt { including_downcast: true, including_tuple_field: true },\n             );\n             let note_msg = match opt_name {\n-                Some(name) => format!(\"`{}`\", name),\n+                Some(name) => format!(\"`{name}`\"),\n                 None => \"value\".to_owned(),\n             };\n             if self.suggest_borrow_fn_like(&mut err, ty, &move_site_vec, &note_msg) {\n@@ -297,9 +296,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             } = use_spans\n             {\n                 err.note(&format!(\n-                    \"{} occurs due to deref coercion to `{}`\",\n+                    \"{} occurs due to deref coercion to `{deref_target_ty}`\",\n                     desired_action.as_noun(),\n-                    deref_target_ty\n                 ));\n \n                 // Check first whether the source is accessible (issue #87060)"}, {"sha": "2095747097b7660870ecdff8b32fc8820525652b", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -77,7 +77,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                     if borrow_span.map(|sp| !sp.overlaps(var_or_use_span)).unwrap_or(true) {\n                         err.span_label(\n                             var_or_use_span,\n-                            format!(\"{}borrow later {}\", borrow_desc, message),\n+                            format!(\"{borrow_desc}borrow later {message}\"),\n                         );\n                     }\n                 } else {\n@@ -90,7 +90,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                         let capture_kind_label = message;\n                         err.span_label(\n                             var_or_use_span,\n-                            format!(\"{}borrow later {}\", borrow_desc, capture_kind_label),\n+                            format!(\"{borrow_desc}borrow later {capture_kind_label}\"),\n                         );\n                         err.span_label(path_span, path_label);\n                     }\n@@ -110,7 +110,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                 };\n                 // We can use `var_or_use_span` if either `path_span` is not present, or both spans are the same\n                 if path_span.map(|path_span| path_span == var_or_use_span).unwrap_or(true) {\n-                    err.span_label(var_or_use_span, format!(\"{}{}\", borrow_desc, message));\n+                    err.span_label(var_or_use_span, format!(\"{borrow_desc}{message}\"));\n                 } else {\n                     // path_span must be `Some` as otherwise the if condition is true\n                     let path_span = path_span.unwrap();\n@@ -121,7 +121,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                         let capture_kind_label = message;\n                         err.span_label(\n                             var_or_use_span,\n-                            format!(\"{}borrow later {}\", borrow_desc, capture_kind_label),\n+                            format!(\"{borrow_desc}borrow later {capture_kind_label}\"),\n                         );\n                         err.span_label(path_span, path_label);\n                     }\n@@ -160,12 +160,8 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                 match local_names[dropped_local] {\n                     Some(local_name) if !local_decl.from_compiler_desugaring() => {\n                         let message = format!(\n-                            \"{B}borrow might be used here, when `{LOC}` is dropped \\\n-                             and runs the {DTOR} for {TYPE}\",\n-                            B = borrow_desc,\n-                            LOC = local_name,\n-                            TYPE = type_desc,\n-                            DTOR = dtor_desc\n+                            \"{borrow_desc}borrow might be used here, when `{local_name}` is dropped \\\n+                             and runs the {dtor_desc} for {type_desc}\",\n                         );\n                         err.span_label(body.source_info(drop_loc).span, message);\n \n@@ -180,18 +176,14 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                         err.span_label(\n                             local_decl.source_info.span,\n                             format!(\n-                                \"a temporary with access to the {B}borrow \\\n+                                \"a temporary with access to the {borrow_desc}borrow \\\n                                  is created here ...\",\n-                                B = borrow_desc\n                             ),\n                         );\n                         let message = format!(\n-                            \"... and the {B}borrow might be used here, \\\n+                            \"... and the {borrow_desc}borrow might be used here, \\\n                              when that temporary is dropped \\\n-                             and runs the {DTOR} for {TYPE}\",\n-                            B = borrow_desc,\n-                            TYPE = type_desc,\n-                            DTOR = dtor_desc\n+                             and runs the {dtor_desc} for {type_desc}\",\n                         );\n                         err.span_label(body.source_info(drop_loc).span, message);\n \n@@ -249,20 +241,16 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                     err.span_label(\n                         span,\n                         format!(\n-                            \"{}requires that `{}` is borrowed for `{}`\",\n+                            \"{}requires that `{desc}` is borrowed for `{region_name}`\",\n                             category.description(),\n-                            desc,\n-                            region_name,\n                         ),\n                     );\n                 } else {\n                     err.span_label(\n                         span,\n                         format!(\n-                            \"{}requires that {}borrow lasts for `{}`\",\n+                            \"{}requires that {borrow_desc}borrow lasts for `{region_name}`\",\n                             category.description(),\n-                            borrow_desc,\n-                            region_name,\n                         ),\n                     );\n                 };\n@@ -296,15 +284,14 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                 if region_name.was_named() { region_name.name } else { kw::UnderscoreLifetime };\n \n             let msg = format!(\n-                \"you can add a bound to the {}to make it last less than `'static` and match `{}`\",\n+                \"you can add a bound to the {}to make it last less than `'static` and match `{region_name}`\",\n                 category.description(),\n-                region_name,\n             );\n \n             err.span_suggestion_verbose(\n                 span.shrink_to_hi(),\n                 &msg,\n-                format!(\" + {}\", suggestable_name),\n+                format!(\" + {suggestable_name}\"),\n                 Applicability::Unspecified,\n             );\n         }"}, {"sha": "1b40b7143cbb6b671ba2faec06326c362a669de8", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -403,8 +403,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         move_prefix: &str,\n     ) {\n         let message = format!(\n-            \"{}move occurs because {} has type `{}`, which does not implement the `Copy` trait\",\n-            move_prefix, place_desc, ty,\n+            \"{move_prefix}move occurs because {place_desc} has type `{ty}`, which does not implement the `Copy` trait\",\n         );\n         if let Some(span) = span {\n             err.span_label(span, message);\n@@ -739,11 +738,11 @@ impl<'tcx> BorrowedContentSource<'tcx> {\n             BorrowedContentSource::OverloadedDeref(ty) => ty\n                 .ty_adt_def()\n                 .and_then(|adt| match tcx.get_diagnostic_name(adt.did())? {\n-                    name @ (sym::Rc | sym::Arc) => Some(format!(\"an `{}`\", name)),\n+                    name @ (sym::Rc | sym::Arc) => Some(format!(\"an `{name}`\")),\n                     _ => None,\n                 })\n-                .unwrap_or_else(|| format!(\"dereference of `{}`\", ty)),\n-            BorrowedContentSource::OverloadedIndex(ty) => format!(\"index of `{}`\", ty),\n+                .unwrap_or_else(|| format!(\"dereference of `{ty}`\")),\n+            BorrowedContentSource::OverloadedIndex(ty) => format!(\"index of `{ty}`\"),\n         }\n     }\n \n@@ -769,11 +768,11 @@ impl<'tcx> BorrowedContentSource<'tcx> {\n             BorrowedContentSource::OverloadedDeref(ty) => ty\n                 .ty_adt_def()\n                 .and_then(|adt| match tcx.get_diagnostic_name(adt.did())? {\n-                    name @ (sym::Rc | sym::Arc) => Some(format!(\"an `{}`\", name)),\n+                    name @ (sym::Rc | sym::Arc) => Some(format!(\"an `{name}`\")),\n                     _ => None,\n                 })\n-                .unwrap_or_else(|| format!(\"dereference of `{}`\", ty)),\n-            BorrowedContentSource::OverloadedIndex(ty) => format!(\"an index of `{}`\", ty),\n+                .unwrap_or_else(|| format!(\"dereference of `{ty}`\")),\n+            BorrowedContentSource::OverloadedIndex(ty) => format!(\"an index of `{ty}`\"),\n         }\n     }\n \n@@ -1033,7 +1032,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if let UseSpans::FnSelfUse { var_span, fn_call_span, fn_span, kind } = move_spans {\n             let place_name = self\n                 .describe_place(moved_place.as_ref())\n-                .map(|n| format!(\"`{}`\", n))\n+                .map(|n| format!(\"`{n}`\"))\n                 .unwrap_or_else(|| \"value\".to_owned());\n             match kind {\n                 CallKind::FnCall { fn_trait_id, .. }\n@@ -1042,8 +1041,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     err.span_label(\n                         fn_call_span,\n                         &format!(\n-                            \"{} {}moved due to this call{}\",\n-                            place_name, partially_str, loop_message\n+                            \"{place_name} {partially_str}moved due to this call{loop_message}\",\n                         ),\n                     );\n                     err.span_note(\n@@ -1056,8 +1054,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     err.span_label(\n                         fn_call_span,\n                         &format!(\n-                            \"{} {}moved due to usage in operator{}\",\n-                            place_name, partially_str, loop_message\n+                            \"{place_name} {partially_str}moved due to usage in operator{loop_message}\",\n                         ),\n                     );\n                     if self.fn_self_span_reported.insert(fn_span) {\n@@ -1089,9 +1086,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             err.span_suggestion_verbose(\n                                 move_span.shrink_to_lo(),\n                                 &format!(\n-                                    \"consider iterating over a slice of the `{}`'s content to \\\n+                                    \"consider iterating over a slice of the `{ty}`'s content to \\\n                                      avoid moving into the `for` loop\",\n-                                    ty,\n                                 ),\n                                 \"&\",\n                                 Applicability::MaybeIncorrect,\n@@ -1101,8 +1097,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         err.span_label(\n                             fn_call_span,\n                             &format!(\n-                                \"{} {}moved due to this implicit call to `.into_iter()`{}\",\n-                                place_name, partially_str, loop_message\n+                                \"{place_name} {partially_str}moved due to this implicit call to `.into_iter()`{loop_message}\",\n                             ),\n                         );\n                         // If the moved place was a `&mut` ref, then we can\n@@ -1118,7 +1113,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     &format!(\n                                         \"consider creating a fresh reborrow of {} here\",\n                                         self.describe_place(moved_place.as_ref())\n-                                            .map(|n| format!(\"`{}`\", n))\n+                                            .map(|n| format!(\"`{n}`\"))\n                                             .unwrap_or_else(|| \"the mutable reference\".to_string()),\n                                     ),\n                                     \"&mut *\",\n@@ -1130,8 +1125,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         err.span_label(\n                             fn_call_span,\n                             &format!(\n-                                \"{} {}moved due to this method call{}\",\n-                                place_name, partially_str, loop_message\n+                                \"{place_name} {partially_str}moved due to this method call{loop_message}\",\n                             ),\n                         );\n                         let infcx = tcx.infer_ctxt().build();\n@@ -1206,15 +1200,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             if move_span != span || !loop_message.is_empty() {\n                 err.span_label(\n                     move_span,\n-                    format!(\"value {}moved{} here{}\", partially_str, move_msg, loop_message),\n+                    format!(\"value {partially_str}moved{move_msg} here{loop_message}\"),\n                 );\n             }\n             // If the move error occurs due to a loop, don't show\n             // another message for the same span\n             if loop_message.is_empty() {\n                 move_spans.var_span_label(\n                     err,\n-                    format!(\"variable {}moved due to use{}\", partially_str, move_spans.describe()),\n+                    format!(\"variable {partially_str}moved due to use{}\", move_spans.describe()),\n                     \"moved\",\n                 );\n             }"}, {"sha": "b9cfc7e69610e5d83aed21b6198f245e122757a6", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -264,7 +264,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         ProjectionElem::Deref,\n                     ],\n             } => {\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_label(span, format!(\"cannot {act}\"));\n \n                 if let Some(span) = get_mut_span_in_struct_field(\n                     self.infcx.tcx,\n@@ -290,7 +290,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     .unwrap_or(false) =>\n             {\n                 let decl = &self.body.local_decls[local];\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_label(span, format!(\"cannot {act}\"));\n                 if let Some(mir::Statement {\n                     source_info,\n                     kind:\n@@ -639,7 +639,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             PlaceRef { local: _, projection: [.., ProjectionElem::Deref] } => {\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_label(span, format!(\"cannot {act}\"));\n \n                 match opt_source {\n                     Some(BorrowedContentSource::OverloadedDeref(ty)) => {\n@@ -1212,7 +1212,7 @@ fn suggest_ampmut<'tcx>(\n     {\n         let lt_name = &src[1..ws_pos];\n         let ty = &src[ws_pos..];\n-        return (true, highlight_span, format!(\"&{} mut{}\", lt_name, ty));\n+        return (true, highlight_span, format!(\"&{lt_name} mut{ty}\"));\n     }\n \n     let ty_mut = local_decl.ty.builtin_deref(true).unwrap();"}, {"sha": "1eaf0a2f15ce8ffe2468e25a387ec111cd2fe84a", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -209,14 +209,14 @@ impl OutlivesSuggestionBuilder {\n         let mut diag = if suggested.len() == 1 {\n             mbcx.infcx.tcx.sess.diagnostic().struct_help(&match suggested.last().unwrap() {\n                 SuggestedConstraint::Outlives(a, bs) => {\n-                    let bs: SmallVec<[String; 2]> = bs.iter().map(|r| format!(\"{}\", r)).collect();\n-                    format!(\"add bound `{}: {}`\", a, bs.join(\" + \"))\n+                    let bs: SmallVec<[String; 2]> = bs.iter().map(|r| r.to_string()).collect();\n+                    format!(\"add bound `{a}: {}`\", bs.join(\" + \"))\n                 }\n \n                 SuggestedConstraint::Equal(a, b) => {\n-                    format!(\"`{}` and `{}` must be the same: replace one with the other\", a, b)\n+                    format!(\"`{a}` and `{b}` must be the same: replace one with the other\")\n                 }\n-                SuggestedConstraint::Static(a) => format!(\"replace `{}` with `'static`\", a),\n+                SuggestedConstraint::Static(a) => format!(\"replace `{a}` with `'static`\"),\n             })\n         } else {\n             // Create a new diagnostic.\n@@ -231,18 +231,16 @@ impl OutlivesSuggestionBuilder {\n             for constraint in suggested {\n                 match constraint {\n                     SuggestedConstraint::Outlives(a, bs) => {\n-                        let bs: SmallVec<[String; 2]> =\n-                            bs.iter().map(|r| format!(\"{}\", r)).collect();\n-                        diag.help(&format!(\"add bound `{}: {}`\", a, bs.join(\" + \")));\n+                        let bs: SmallVec<[String; 2]> = bs.iter().map(|r| r.to_string()).collect();\n+                        diag.help(&format!(\"add bound `{a}: {}`\", bs.join(\" + \")));\n                     }\n                     SuggestedConstraint::Equal(a, b) => {\n                         diag.help(&format!(\n-                            \"`{}` and `{}` must be the same: replace one with the other\",\n-                            a, b\n+                            \"`{a}` and `{b}` must be the same: replace one with the other\",\n                         ));\n                     }\n                     SuggestedConstraint::Static(a) => {\n-                        diag.help(&format!(\"replace `{}` with `'static`\", a));\n+                        diag.help(&format!(\"replace `{a}` with `'static`\"));\n                     }\n                 }\n             }"}, {"sha": "e8a4d1c37c1877296151a84dd9e3cd5513716b2b", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -422,7 +422,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         );\n                         (desc, note)\n                     }\n-                    _ => panic!(\"Unexpected type {:?}\", ty),\n+                    _ => panic!(\"Unexpected type {ty:?}\"),\n                 };\n                 diag.note(&format!(\"requirement occurs because of {desc}\",));\n                 diag.note(&note);\n@@ -725,10 +725,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             let lifetime = if f.has_name() { fr_name.name } else { kw::UnderscoreLifetime };\n \n             let arg = match param.param.pat.simple_ident() {\n-                Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n+                Some(simple_ident) => format!(\"argument `{simple_ident}`\"),\n                 None => \"the argument\".to_string(),\n             };\n-            let captures = format!(\"captures data from {}\", arg);\n+            let captures = format!(\"captures data from {arg}\");\n \n             return nice_region_error::suggest_new_region_bound(\n                 self.infcx.tcx,"}, {"sha": "9233287cf3a75fde48da92820c9c4d52bed5e132", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -202,7 +202,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// This is _not_ idempotent. Call `give_region_a_name` when possible.\n     pub(crate) fn synthesize_region_name(&self) -> Symbol {\n         let c = self.next_region_name.replace_with(|counter| *counter + 1);\n-        Symbol::intern(&format!(\"'{:?}\", c))\n+        Symbol::intern(&format!(\"'{c:?}\"))\n     }\n \n     /// Maps from an internal MIR region vid to something that we can\n@@ -619,7 +619,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                     // programs, so we need to use delay_span_bug here. See #82126.\n                     self.infcx.tcx.sess.delay_span_bug(\n                         hir_arg.span(),\n-                        &format!(\"unmatched subst and hir arg: found {:?} vs {:?}\", kind, hir_arg),\n+                        &format!(\"unmatched subst and hir arg: found {kind:?} vs {hir_arg:?}\"),\n                     );\n                 }\n             }\n@@ -783,8 +783,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         } else {\n             span_bug!(\n                 hir_ty.span,\n-                \"bounds from lowered return type of async fn did not match expected format: {:?}\",\n-                opaque_ty\n+                \"bounds from lowered return type of async fn did not match expected format: {opaque_ty:?}\",\n             );\n         }\n     }"}, {"sha": "ada3310d8071b776215d5ce4c5c5d037d353df93", "filename": "compiler/rustc_borrowck/src/diagnostics/var_name.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -18,7 +18,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         upvars: &[Upvar<'tcx>],\n         fr: RegionVid,\n     ) -> Option<(Option<Symbol>, Span)> {\n-        debug!(\"get_var_name_and_span_for_region(fr={:?})\", fr);\n+        debug!(\"get_var_name_and_span_for_region(fr={fr:?})\");\n         assert!(self.universal_regions().is_universal_region(fr));\n \n         debug!(\"get_var_name_and_span_for_region: attempting upvar\");\n@@ -44,19 +44,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<usize> {\n         let upvar_index =\n             self.universal_regions().defining_ty.upvar_tys().position(|upvar_ty| {\n-                debug!(\"get_upvar_index_for_region: upvar_ty={:?}\", upvar_ty);\n+                debug!(\"get_upvar_index_for_region: upvar_ty={upvar_ty:?}\");\n                 tcx.any_free_region_meets(&upvar_ty, |r| {\n                     let r = r.to_region_vid();\n-                    debug!(\"get_upvar_index_for_region: r={:?} fr={:?}\", r, fr);\n+                    debug!(\"get_upvar_index_for_region: r={r:?} fr={fr:?}\");\n                     r == fr\n                 })\n             })?;\n \n         let upvar_ty = self.universal_regions().defining_ty.upvar_tys().nth(upvar_index);\n \n         debug!(\n-            \"get_upvar_index_for_region: found {:?} in upvar {} which has type {:?}\",\n-            fr, upvar_index, upvar_ty,\n+            \"get_upvar_index_for_region: found {fr:?} in upvar {upvar_index} which has type {upvar_ty:?}\",\n         );\n \n         Some(upvar_index)\n@@ -71,13 +70,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         upvar_index: usize,\n     ) -> (Symbol, Span) {\n         let upvar_hir_id = upvars[upvar_index].place.get_root_variable();\n-        debug!(\"get_upvar_name_and_span_for_region: upvar_hir_id={:?}\", upvar_hir_id);\n+        debug!(\"get_upvar_name_and_span_for_region: upvar_hir_id={upvar_hir_id:?}\");\n \n         let upvar_name = tcx.hir().name(upvar_hir_id);\n         let upvar_span = tcx.hir().span(upvar_hir_id);\n         debug!(\n-            \"get_upvar_name_and_span_for_region: upvar_name={:?} upvar_span={:?}\",\n-            upvar_name, upvar_span\n+            \"get_upvar_name_and_span_for_region: upvar_name={upvar_name:?} upvar_span={upvar_span:?}\",\n         );\n \n         (upvar_name, upvar_span)\n@@ -97,15 +95,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let argument_index =\n             self.universal_regions().unnormalized_input_tys.iter().skip(implicit_inputs).position(\n                 |arg_ty| {\n-                    debug!(\"get_argument_index_for_region: arg_ty = {:?}\", arg_ty);\n+                    debug!(\"get_argument_index_for_region: arg_ty = {arg_ty:?}\");\n                     tcx.any_free_region_meets(arg_ty, |r| r.to_region_vid() == fr)\n                 },\n             )?;\n \n         debug!(\n-            \"get_argument_index_for_region: found {:?} in argument {} which has type {:?}\",\n-            fr,\n-            argument_index,\n+            \"get_argument_index_for_region: found {fr:?} in argument {argument_index} which has type {:?}\",\n             self.universal_regions().unnormalized_input_tys[argument_index],\n         );\n \n@@ -122,13 +118,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> (Option<Symbol>, Span) {\n         let implicit_inputs = self.universal_regions().defining_ty.implicit_inputs();\n         let argument_local = Local::new(implicit_inputs + argument_index + 1);\n-        debug!(\"get_argument_name_and_span_for_region: argument_local={:?}\", argument_local);\n+        debug!(\"get_argument_name_and_span_for_region: argument_local={argument_local:?}\");\n \n         let argument_name = local_names[argument_local];\n         let argument_span = body.local_decls[argument_local].source_info.span;\n         debug!(\n-            \"get_argument_name_and_span_for_region: argument_name={:?} argument_span={:?}\",\n-            argument_name, argument_span\n+            \"get_argument_name_and_span_for_region: argument_name={argument_name:?} argument_span={argument_span:?}\",\n         );\n \n         (argument_name, argument_span)"}, {"sha": "02ffb51fbb7e3a3fb440a497e558702fefc5ba41", "filename": "compiler/rustc_borrowck/src/facts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -192,7 +192,7 @@ fn write_row(\n ) -> Result<(), Box<dyn Error>> {\n     for (index, c) in columns.iter().enumerate() {\n         let tail = if index == columns.len() - 1 { \"\\n\" } else { \"\\t\" };\n-        write!(out, \"{:?}{}\", c.to_string(location_table), tail)?;\n+        write!(out, \"{:?}{tail}\", c.to_string(location_table))?;\n     }\n     Ok(())\n }"}, {"sha": "686c22bc386dc3fff72e8366b1bab0a5c6669662", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -110,6 +110,7 @@ E0204: include_str!(\"./error_codes/E0204.md\"),\n E0205: include_str!(\"./error_codes/E0205.md\"),\n E0206: include_str!(\"./error_codes/E0206.md\"),\n E0207: include_str!(\"./error_codes/E0207.md\"),\n+E0208: include_str!(\"./error_codes/E0208.md\"),\n E0210: include_str!(\"./error_codes/E0210.md\"),\n E0211: include_str!(\"./error_codes/E0211.md\"),\n E0212: include_str!(\"./error_codes/E0212.md\"),\n@@ -387,6 +388,7 @@ E0636: include_str!(\"./error_codes/E0636.md\"),\n E0637: include_str!(\"./error_codes/E0637.md\"),\n E0638: include_str!(\"./error_codes/E0638.md\"),\n E0639: include_str!(\"./error_codes/E0639.md\"),\n+E0640: include_str!(\"./error_codes/E0640.md\"),\n E0641: include_str!(\"./error_codes/E0641.md\"),\n E0642: include_str!(\"./error_codes/E0642.md\"),\n E0643: include_str!(\"./error_codes/E0643.md\"),\n@@ -434,6 +436,8 @@ E0713: include_str!(\"./error_codes/E0713.md\"),\n E0714: include_str!(\"./error_codes/E0714.md\"),\n E0715: include_str!(\"./error_codes/E0715.md\"),\n E0716: include_str!(\"./error_codes/E0716.md\"),\n+E0711: include_str!(\"./error_codes/E0711.md\"),\n+E0717: include_str!(\"./error_codes/E0717.md\"),\n E0718: include_str!(\"./error_codes/E0718.md\"),\n E0719: include_str!(\"./error_codes/E0719.md\"),\n E0720: include_str!(\"./error_codes/E0720.md\"),\n@@ -540,7 +544,6 @@ E0791: include_str!(\"./error_codes/E0791.md\"),\n //  E0190, // deprecated: can only cast a &-pointer to an &-object\n //  E0194, // merged into E0403\n //  E0196, // cannot determine a type for this closure\n-    E0208, // internal error code\n //  E0209, // builtin traits can only be implemented on structs or enums\n //  E0213, // associated types are not accepted in this context\n //  E0215, // angle-bracket notation is not stable with `Fn`\n@@ -633,14 +636,11 @@ E0791: include_str!(\"./error_codes/E0791.md\"),\n //  E0629, // missing 'feature' (rustc_const_unstable)\n //  E0630, // rustc_const_unstable attribute must be paired with stable/unstable\n            // attribute\n-    E0640, // infer outlives requirements, internal error code\n //  E0645, // trait aliases not finished\n //  E0694, // an unknown tool name found in scoped attributes\n //  E0702, // replaced with a generic attribute input check\n //  E0707, // multiple elided lifetimes used in arguments of `async fn`\n //  E0709, // multiple different lifetimes used in arguments of `async fn`\n-    E0711, // a feature has been declared with conflicting stability attributes, internal error code\n-    E0717, // rustc_promotable without stability attribute, internal error code\n //  E0721, // `await` keyword\n //  E0723, // unstable feature in `const` context\n //  E0738, // Removed; errored on `#[track_caller] fn`s in `extern \"Rust\" { ... }`."}, {"sha": "7edd93e56a945e4e9096efee47c07e9f14b1a410", "filename": "compiler/rustc_error_codes/src/error_codes/E0208.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0208.md", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0208.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0208.md?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1 @@\n+#### This error code is internal to the compiler and will not be emitted with normal Rust code."}, {"sha": "7edd93e56a945e4e9096efee47c07e9f14b1a410", "filename": "compiler/rustc_error_codes/src/error_codes/E0640.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0640.md", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0640.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0640.md?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1 @@\n+#### This error code is internal to the compiler and will not be emitted with normal Rust code."}, {"sha": "a2150037f7856d53644d9192b25ae3c7cc311960", "filename": "compiler/rustc_error_codes/src/error_codes/E0711.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0711.md", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0711.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0711.md?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,30 @@\n+#### This error code is internal to the compiler and will not be emitted with normal Rust code.\n+\n+Feature declared with conflicting stability requirements.\n+\n+```compile_fail,E0711\n+// NOTE: this attribute is perma-unstable and should *never* be used outside of\n+//       stdlib and the compiler.\n+#![feature(staged_api)]\n+\n+#![stable(feature = \"...\", since = \"1.0.0\")]\n+\n+#[stable(feature = \"foo\", since = \"1.0.0\")]\n+fn foo_stable_1_0_0() {}\n+\n+// error: feature `foo` is declared stable since 1.29.0\n+#[stable(feature = \"foo\", since = \"1.29.0\")]\n+fn foo_stable_1_29_0() {}\n+\n+// error: feature `foo` is declared unstable\n+#[unstable(feature = \"foo\", issue = \"none\")]\n+fn foo_unstable() {}\n+```\n+\n+In the above example, the `foo` feature is first defined to be stable since\n+1.0.0, but is then re-declared stable since 1.29.0. This discrepancy in\n+versions causes an error. Furthermore, `foo` is then re-declared as unstable,\n+again the conflict causes an error.\n+\n+This error can be fixed by splitting the feature, this allows any\n+stability requirements and removes any possibility of conflict."}, {"sha": "7edd93e56a945e4e9096efee47c07e9f14b1a410", "filename": "compiler/rustc_error_codes/src/error_codes/E0717.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0717.md", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0717.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0717.md?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1 @@\n+#### This error code is internal to the compiler and will not be emitted with normal Rust code."}, {"sha": "ef563360c4cebb8d3e0265ead2be59430e5013d1", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -468,7 +468,7 @@ fn check_opaque_meets_bounds<'tcx>(\n         // Can have different predicates to their defining use\n         hir::OpaqueTyOrigin::TyAlias => {\n             let outlives_environment = OutlivesEnvironment::new(param_env);\n-            let _ = infcx.check_region_obligations_and_report_errors(\n+            let _ = infcx.err_ctxt().check_region_obligations_and_report_errors(\n                 defining_use_anchor,\n                 &outlives_environment,\n             );"}, {"sha": "b260b929bebdb664dd7fe26e01ab9a0dec48e1ab", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -615,7 +615,7 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n         Some(infcx),\n         infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys),\n     );\n-    infcx.check_region_obligations_and_report_errors(\n+    infcx.err_ctxt().check_region_obligations_and_report_errors(\n         impl_m.def_id.expect_local(),\n         &outlives_environment,\n     )?;\n@@ -1643,8 +1643,9 @@ pub(super) fn compare_impl_const_raw(\n     }\n \n     let outlives_environment = OutlivesEnvironment::new(param_env);\n-    infcx.check_region_obligations_and_report_errors(impl_const_item_def, &outlives_environment)?;\n-\n+    infcx\n+        .err_ctxt()\n+        .check_region_obligations_and_report_errors(impl_const_item_def, &outlives_environment)?;\n     Ok(())\n }\n \n@@ -1752,7 +1753,7 @@ fn compare_type_predicate_entailment<'tcx>(\n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n     let outlives_environment = OutlivesEnvironment::new(param_env);\n-    infcx.check_region_obligations_and_report_errors(\n+    infcx.err_ctxt().check_region_obligations_and_report_errors(\n         impl_ty.def_id.expect_local(),\n         &outlives_environment,\n     )?;\n@@ -1966,7 +1967,7 @@ pub(super) fn check_type_bounds<'tcx>(\n     let outlives_environment =\n         OutlivesEnvironment::with_bounds(param_env, Some(&infcx), implied_bounds);\n \n-    infcx.check_region_obligations_and_report_errors(\n+    infcx.err_ctxt().check_region_obligations_and_report_errors(\n         impl_ty.def_id.expect_local(),\n         &outlives_environment,\n     )?;"}, {"sha": "e9baab594530ececae99c5e959b0bd7b1b5eeaa6", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -116,7 +116,9 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n     let outlives_environment =\n         OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n \n-    let _ = infcx.check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n+    let _ = infcx\n+        .err_ctxt()\n+        .check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n }\n \n fn check_well_formed(tcx: TyCtxt<'_>, def_id: hir::OwnerId) {"}, {"sha": "2e2c1591e9b4472dffb5e39a22b33b92685fbbc7", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -325,7 +325,9 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n \n                 // Finally, resolve all regions.\n                 let outlives_env = OutlivesEnvironment::new(param_env);\n-                let _ = infcx.check_region_obligations_and_report_errors(impl_did, &outlives_env);\n+                let _ = infcx\n+                    .err_ctxt()\n+                    .check_region_obligations_and_report_errors(impl_did, &outlives_env);\n             }\n         }\n         _ => {\n@@ -565,7 +567,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n \n     // Finally, resolve all regions.\n     let outlives_env = OutlivesEnvironment::new(param_env);\n-    let _ = infcx.check_region_obligations_and_report_errors(impl_did, &outlives_env);\n+    let _ = infcx.err_ctxt().check_region_obligations_and_report_errors(impl_did, &outlives_env);\n \n     CoerceUnsizedInfo { custom_kind: kind }\n }"}, {"sha": "8b9034d9620e2c3debfefc0081b6f3fdcf4217c9", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -181,7 +181,8 @@ fn get_impl_substs(\n \n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_hir_id, assumed_wf_types);\n     let outlives_env = OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n-    let _ = infcx.check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n+    let _ =\n+        infcx.err_ctxt().check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n         let span = tcx.def_span(impl1_def_id);\n         tcx.sess.emit_err(SubstsOnOverriddenImpl { span });"}, {"sha": "5075d9b893b3b08e31f6e1fca1a3d38658e9898e", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -9,7 +9,7 @@ use crate::{\n     TupleArgumentsFlag,\n };\n use rustc_ast as ast;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{pluralize, Applicability, Diagnostic, DiagnosticId, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n@@ -1704,7 +1704,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // even if their `ObligationCauseCode` isn't an `Expr*Obligation` kind.\n         // This is important since if we adjust one span but not the other, then\n         // we will have \"duplicated\" the error on the UI side.\n-        let mut remap_cause = FxHashSet::default();\n+        let mut remap_cause = FxIndexSet::default();\n         let mut not_adjusted = vec![];\n \n         for error in errors {\n@@ -1732,6 +1732,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n+        // Adjust any other errors that come from other cause codes, when these\n+        // errors are of the same predicate as one we successfully adjusted, and\n+        // when their spans overlap (suggesting they're due to the same root cause).\n+        //\n+        // This is because due to normalization, we often register duplicate\n+        // obligations with misc obligations that are basically impossible to\n+        // line back up with a useful ExprBindingObligation.\n         for error in not_adjusted {\n             for (span, predicate, cause) in &remap_cause {\n                 if *predicate == error.obligation.predicate"}, {"sha": "46799245222dc45599c6fbcbb71f9c9040109b15", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -761,6 +761,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         err.span_note(sp, format!(\"{msg}: `{sugg}`\"));\n                     }\n                 }\n+                hir::Node::Pat(pt) if let PatKind::TupleStruct(_, pat_arr, _) = pt.kind => {\n+                    for i in pat_arr.iter() {\n+                        if let PatKind::Ref(the_ref, _) = i.kind\n+                        && let PatKind::Binding(mt, _, ident, _) = the_ref.kind {\n+                            let hir::BindingAnnotation(_, mtblty) = mt;\n+                            err.span_suggestion_verbose(\n+                                i.span,\n+                                format!(\"consider removing `&{mutability}` from the pattern\"),\n+                                mtblty.prefix_str().to_string() + &ident.name.to_string(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                    if let Some((sp, msg, sugg)) = mut_var_suggestion {\n+                        err.span_note(sp, format!(\"{msg}: `{sugg}`\"));\n+                    }\n+                }\n                 hir::Node::Param(_) | hir::Node::Arm(_) | hir::Node::Pat(_) => {\n                     // rely on match ergonomics or it might be nested `&&pat`\n                     err.span_suggestion_verbose("}, {"sha": "091635e6c73c0b1c18cbac1a16c83b3bb85b537a", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -6,8 +6,7 @@\n //! [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html\n \n use crate::infer::canonical::{\n-    Canonical, CanonicalTyVarKind, CanonicalVarInfo, CanonicalVarKind, Canonicalized,\n-    OriginalQueryValues,\n+    Canonical, CanonicalTyVarKind, CanonicalVarInfo, CanonicalVarKind, OriginalQueryValues,\n };\n use crate::infer::InferCtxt;\n use rustc_middle::ty::flags::FlagComputation;\n@@ -40,7 +39,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         &self,\n         value: V,\n         query_state: &mut OriginalQueryValues<'tcx>,\n-    ) -> Canonicalized<'tcx, V>\n+    ) -> Canonical<'tcx, V>\n     where\n         V: TypeFoldable<'tcx>,\n     {\n@@ -59,7 +58,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         &self,\n         value: V,\n         query_state: &mut OriginalQueryValues<'tcx>,\n-    ) -> Canonicalized<'tcx, V>\n+    ) -> Canonical<'tcx, V>\n     where\n         V: TypeFoldable<'tcx>,\n     {\n@@ -99,7 +98,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// out the [chapter in the rustc dev guide][c].\n     ///\n     /// [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html#canonicalizing-the-query-result\n-    pub fn canonicalize_response<V>(&self, value: V) -> Canonicalized<'tcx, V>\n+    pub fn canonicalize_response<V>(&self, value: V) -> Canonical<'tcx, V>\n     where\n         V: TypeFoldable<'tcx>,\n     {\n@@ -113,7 +112,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         )\n     }\n \n-    pub fn canonicalize_user_type_annotation<V>(&self, value: V) -> Canonicalized<'tcx, V>\n+    pub fn canonicalize_user_type_annotation<V>(&self, value: V) -> Canonical<'tcx, V>\n     where\n         V: TypeFoldable<'tcx>,\n     {\n@@ -135,7 +134,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         &self,\n         value: V,\n         query_state: &mut OriginalQueryValues<'tcx>,\n-    ) -> Canonicalized<'tcx, V>\n+    ) -> Canonical<'tcx, V>\n     where\n         V: TypeFoldable<'tcx>,\n     {\n@@ -524,7 +523,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         canonicalize_region_mode: &dyn CanonicalizeMode,\n         query_state: &mut OriginalQueryValues<'tcx>,\n-    ) -> Canonicalized<'tcx, V>\n+    ) -> Canonical<'tcx, V>\n     where\n         V: TypeFoldable<'tcx>,\n     {"}, {"sha": "108011013f58b686a8f6a983e57e94630f7ab204", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -9,7 +9,7 @@\n \n use crate::infer::canonical::substitute::{substitute_value, CanonicalExt};\n use crate::infer::canonical::{\n-    Canonical, CanonicalVarValues, CanonicalizedQueryResponse, Certainty, OriginalQueryValues,\n+    Canonical, CanonicalQueryResponse, CanonicalVarValues, Certainty, OriginalQueryValues,\n     QueryOutlivesConstraint, QueryRegionConstraints, QueryResponse,\n };\n use crate::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n@@ -57,7 +57,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         inference_vars: CanonicalVarValues<'tcx>,\n         answer: T,\n         fulfill_cx: &mut dyn TraitEngine<'tcx>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, T>>\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, T>>\n     where\n         T: Debug + TypeFoldable<'tcx>,\n         Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable<'tcx>,"}, {"sha": "31b546581e424832ca65c2f4709ca52d50a4b03a", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1679,13 +1679,29 @@ impl<'tcx> InferCtxt<'tcx> {\n }\n \n impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    /// Processes registered region obliations and resolves regions, reporting\n+    /// any errors if any were raised. Prefer using this function over manually\n+    /// calling `resolve_regions_and_report_errors`.\n+    pub fn check_region_obligations_and_report_errors(\n+        &self,\n+        generic_param_scope: LocalDefId,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+    ) -> Result<(), ErrorGuaranteed> {\n+        self.process_registered_region_obligations(\n+            outlives_env.region_bound_pairs(),\n+            outlives_env.param_env,\n+        );\n+\n+        self.resolve_regions_and_report_errors(generic_param_scope, outlives_env)\n+    }\n+\n     /// Process the region constraints and report any errors that\n     /// result. After this, no more unification operations should be\n     /// done -- or the compiler will panic -- but it is legal to use\n     /// `resolve_vars_if_possible` as well as `fully_resolve`.\n     ///\n     /// Make sure to call [`InferCtxt::process_registered_region_obligations`]\n-    /// first, or preferably use [`InferCtxt::check_region_obligations_and_report_errors`]\n+    /// first, or preferably use [`TypeErrCtxt::check_region_obligations_and_report_errors`]\n     /// to do both of these operations together.\n     pub fn resolve_regions_and_report_errors(\n         &self,"}, {"sha": "a85e6a19b11b65b99fdc279a195f5822cd3a4220", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -60,17 +60,14 @@\n //! imply that `'b: 'a`.\n \n use crate::infer::outlives::components::{push_outlives_components, Component};\n-use crate::infer::outlives::env::OutlivesEnvironment;\n use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::outlives::verify::VerifyBoundCx;\n use crate::infer::{\n     self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, UndoLog, VerifyBound,\n };\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::undo_log::UndoLogs;\n-use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::def_id::LocalDefId;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Region, SubstsRef, Ty, TyCtxt, TypeVisitable};\n@@ -116,7 +113,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         std::mem::take(&mut self.inner.borrow_mut().region_obligations)\n     }\n \n-    /// NOTE: Prefer using [`InferCtxt::check_region_obligations_and_report_errors`]\n+    /// NOTE: Prefer using `TypeErrCtxt::check_region_obligations_and_report_errors`\n     /// instead of calling this directly.\n     ///\n     /// Process the region obligations that must be proven (during\n@@ -170,22 +167,6 @@ impl<'tcx> InferCtxt<'tcx> {\n             outlives.type_must_outlive(origin, sup_type, sub_region, category);\n         }\n     }\n-\n-    /// Processes registered region obliations and resolves regions, reporting\n-    /// any errors if any were raised. Prefer using this function over manually\n-    /// calling `resolve_regions_and_report_errors`.\n-    pub fn check_region_obligations_and_report_errors(\n-        &self,\n-        generic_param_scope: LocalDefId,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) -> Result<(), ErrorGuaranteed> {\n-        self.process_registered_region_obligations(\n-            outlives_env.region_bound_pairs(),\n-            outlives_env.param_env,\n-        );\n-\n-        self.err_ctxt().resolve_regions_and_report_errors(generic_param_scope, outlives_env)\n-    }\n }\n \n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`"}, {"sha": "614cf1a0051da8b423c96e536cb018646518ab97", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -213,9 +213,7 @@ impl QueryRegionConstraints<'_> {\n     }\n }\n \n-pub type Canonicalized<'tcx, V> = Canonical<'tcx, V>;\n-\n-pub type CanonicalizedQueryResponse<'tcx, T> = &'tcx Canonical<'tcx, QueryResponse<'tcx, T>>;\n+pub type CanonicalQueryResponse<'tcx, T> = &'tcx Canonical<'tcx, QueryResponse<'tcx, T>>;\n \n /// Indicates whether or not we were able to prove the query to be\n /// true."}, {"sha": "028a03c0b2bdd78d525892e8c5923289af1149e6", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -626,7 +626,7 @@ pub struct CanonicalUserTypeAnnotation<'tcx> {\n     pub inferred_ty: Ty<'tcx>,\n }\n \n-/// Canonicalized user type annotation.\n+/// Canonical user type annotation.\n pub type CanonicalUserType<'tcx> = Canonical<'tcx, UserType<'tcx>>;\n \n impl<'tcx> CanonicalUserType<'tcx> {"}, {"sha": "ef2ab304f9e04f69c7b3474f4d79ddeaa4151ead", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_fuchsia.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_fuchsia.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -8,7 +8,9 @@ pub fn target() -> Target {\n         arch: \"aarch64\".into(),\n         options: TargetOptions {\n             max_atomic_width: Some(128),\n-            supported_sanitizers: SanitizerSet::ADDRESS | SanitizerSet::CFI,\n+            supported_sanitizers: SanitizerSet::ADDRESS\n+                | SanitizerSet::CFI\n+                | SanitizerSet::SHADOWCALLSTACK,\n             ..super::fuchsia_base::opts()\n         },\n     }"}, {"sha": "50c1787ef8c3d20ea323d5151a0493ffd749aa0c", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -4,7 +4,7 @@ use crate::traits::{self, ObligationCtxt};\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::arena::ArenaAllocatable;\n-use rustc_middle::infer::canonical::{Canonical, CanonicalizedQueryResponse, QueryResponse};\n+use rustc_middle::infer::canonical::{Canonical, CanonicalQueryResponse, QueryResponse};\n use rustc_middle::traits::query::Fallible;\n use rustc_middle::ty::{self, Ty, TypeFoldable, TypeVisitable};\n use rustc_middle::ty::{GenericArg, ToPredicate};\n@@ -102,7 +102,7 @@ pub trait InferCtxtBuilderExt<'tcx> {\n         &mut self,\n         canonical_key: &Canonical<'tcx, K>,\n         operation: impl FnOnce(&ObligationCtxt<'_, 'tcx>, K) -> Fallible<R>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, R>>\n     where\n         K: TypeFoldable<'tcx>,\n         R: Debug + TypeFoldable<'tcx>,\n@@ -130,7 +130,7 @@ impl<'tcx> InferCtxtBuilderExt<'tcx> for InferCtxtBuilder<'tcx> {\n         &mut self,\n         canonical_key: &Canonical<'tcx, K>,\n         operation: impl FnOnce(&ObligationCtxt<'_, 'tcx>, K) -> Fallible<R>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, R>>\n     where\n         K: TypeFoldable<'tcx>,\n         R: Debug + TypeFoldable<'tcx>,"}, {"sha": "71fb6058cd2c54e722a0be82f736dd295f7b9ceb", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -168,24 +168,27 @@ fn satisfied_from_param_env<'tcx>(\n         param_env: ty::ParamEnv<'tcx>,\n \n         infcx: &'a InferCtxt<'tcx>,\n+        single_match: Option<Result<ty::Const<'tcx>, ()>>,\n     }\n+\n     impl<'a, 'tcx> TypeVisitor<'tcx> for Visitor<'a, 'tcx> {\n         type BreakTy = ();\n         fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n             debug!(\"is_const_evaluatable: candidate={:?}\", c);\n-            if let Ok(()) = self.infcx.commit_if_ok(|_| {\n+            if self.infcx.probe(|_| {\n                 let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n-                if let Ok(()) = ocx.eq(&ObligationCause::dummy(), self.param_env, c.ty(), self.ct.ty())\n-                    && let Ok(()) = ocx.eq(&ObligationCause::dummy(), self.param_env, c, self.ct)\n+                ocx.eq(&ObligationCause::dummy(), self.param_env, c.ty(), self.ct.ty()).is_ok()\n+                    && ocx.eq(&ObligationCause::dummy(), self.param_env, c, self.ct).is_ok()\n                     && ocx.select_all_or_error().is_empty()\n-                {\n-                    Ok(())\n-                } else {\n-                    Err(())\n-                }\n             }) {\n-                ControlFlow::BREAK\n-            } else if let ty::ConstKind::Expr(e) = c.kind() {\n+                self.single_match = match self.single_match {\n+                    None => Some(Ok(c)),\n+                    Some(Ok(o)) if o == c => Some(Ok(c)),\n+                    Some(_) => Some(Err(())),\n+                };\n+            }\n+\n+            if let ty::ConstKind::Expr(e) = c.kind() {\n                 e.visit_with(self)\n             } else {\n                 // FIXME(generic_const_exprs): This doesn't recurse into `<T as Trait<U>>::ASSOC`'s substs.\n@@ -200,22 +203,29 @@ fn satisfied_from_param_env<'tcx>(\n         }\n     }\n \n+    let mut single_match: Option<Result<ty::Const<'tcx>, ()>> = None;\n+\n     for pred in param_env.caller_bounds() {\n         match pred.kind().skip_binder() {\n             ty::PredicateKind::ConstEvaluatable(ce) => {\n                 let b_ct = tcx.expand_abstract_consts(ce);\n-                let mut v = Visitor { ct, infcx, param_env };\n-                let result = b_ct.visit_with(&mut v);\n+                let mut v = Visitor { ct, infcx, param_env, single_match };\n+                let _ = b_ct.visit_with(&mut v);\n \n-                if let ControlFlow::Break(()) = result {\n-                    debug!(\"is_const_evaluatable: yes\");\n-                    return true;\n-                }\n+                single_match = v.single_match;\n             }\n             _ => {} // don't care\n         }\n     }\n \n+    if let Some(Ok(c)) = single_match {\n+        let ocx = ObligationCtxt::new(infcx);\n+        assert!(ocx.eq(&ObligationCause::dummy(), param_env, c.ty(), ct.ty()).is_ok());\n+        assert!(ocx.eq(&ObligationCause::dummy(), param_env, c, ct).is_ok());\n+        assert!(ocx.select_all_or_error().is_empty());\n+        return true;\n+    }\n+\n     debug!(\"is_const_evaluatable: no\");\n     false\n }"}, {"sha": "369f80139a806c7fb00b02de7a8caf8fd4cd0919", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -9,7 +9,7 @@ use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{\n-    Canonical, CanonicalVarValues, CanonicalizedQueryResponse, QueryResponse,\n+    Canonical, CanonicalQueryResponse, CanonicalVarValues, QueryResponse,\n };\n use rustc_infer::infer::{InferCtxt, InferOk};\n use rustc_infer::traits::query::Fallible;\n@@ -215,7 +215,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         &self,\n         inference_vars: CanonicalVarValues<'tcx>,\n         answer: T,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, T>>\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, T>>\n     where\n         T: Debug + TypeFoldable<'tcx>,\n         Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable<'tcx>,"}, {"sha": "439854958270c4851385dd0d97d930a5edf559e4", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1519,6 +1519,13 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         .source_map()\n                         .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n                     if points_at_arg && mutability.is_not() && refs_number > 0 {\n+                        // If we have a call like foo(&mut buf), then don't suggest foo(&mut mut buf)\n+                        if snippet\n+                            .trim_start_matches(|c: char| c.is_whitespace() || c == '&')\n+                            .starts_with(\"mut\")\n+                        {\n+                            return;\n+                        }\n                         err.span_suggestion_verbose(\n                             sp,\n                             \"consider changing this borrow's mutability\","}, {"sha": "2bab380dba011e4041e1212fc4fbb2142b795857", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -102,7 +102,7 @@ pub enum TraitQueryMode {\n     /// spans etc. passed in and hence can do reasonable\n     /// error reporting on their own.\n     Standard,\n-    /// Canonicalized queries get dummy spans and hence\n+    /// Canonical queries get dummy spans and hence\n     /// must generally propagate errors to\n     /// pre-canonicalization callsites.\n     Canonical,"}, {"sha": "e6db96c9e558044826e31fb7d40322fce56d6ed2", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n+use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n use crate::traits::query::Fallible;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n \n@@ -16,8 +16,8 @@ impl<'tcx> super::QueryTypeOp<'tcx> for AscribeUserType<'tcx> {\n \n     fn perform_query(\n         tcx: TyCtxt<'tcx>,\n-        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n+        canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, ()>> {\n         tcx.type_op_ascribe_user_type(canonicalized)\n     }\n }"}, {"sha": "8c9b9610cb6efe6cda5bb4c92a07defc094b8310", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/eq.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n+use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n use crate::traits::query::Fallible;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n \n@@ -16,8 +16,8 @@ impl<'tcx> super::QueryTypeOp<'tcx> for Eq<'tcx> {\n \n     fn perform_query(\n         tcx: TyCtxt<'tcx>,\n-        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n+        canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, ()>> {\n         tcx.type_op_eq(canonicalized)\n     }\n }"}, {"sha": "18d7c9b193601c161b258fa926e1c1a30763aba7", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n+use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n use crate::traits::query::Fallible;\n use rustc_infer::traits::query::OutlivesBound;\n use rustc_middle::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n@@ -27,8 +27,8 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ImpliedOutlivesBounds<'tcx> {\n \n     fn perform_query(\n         tcx: TyCtxt<'tcx>,\n-        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self::QueryResponse>> {\n+        canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, Self::QueryResponse>> {\n         // FIXME this `unchecked_map` is only necessary because the\n         // query is defined as taking a `ParamEnvAnd<Ty>`; it should\n         // take an `ImpliedOutlivesBounds` instead"}, {"sha": "97002b461aa9be0e295584b5e8737ec95f7d1863", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,10 +1,10 @@\n use crate::infer::canonical::{\n-    Canonicalized, CanonicalizedQueryResponse, OriginalQueryValues, QueryRegionConstraints,\n+    Canonical, CanonicalQueryResponse, OriginalQueryValues, QueryRegionConstraints,\n };\n use crate::infer::{InferCtxt, InferOk};\n use crate::traits::query::Fallible;\n use crate::traits::ObligationCause;\n-use rustc_infer::infer::canonical::{Canonical, Certainty};\n+use rustc_infer::infer::canonical::Certainty;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::PredicateObligations;\n use rustc_middle::ty::fold::TypeFoldable;\n@@ -73,8 +73,8 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Copy + TypeFoldable<'tcx> + 'tcx {\n     /// not captured in the return value.\n     fn perform_query(\n         tcx: TyCtxt<'tcx>,\n-        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self::QueryResponse>>;\n+        canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, Self::QueryResponse>>;\n \n     fn fully_perform_into(\n         query_key: ParamEnvAnd<'tcx, Self>,"}, {"sha": "8f0b4de31e6cf147fcad26eb51bcdc69b1850428", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/normalize.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n+use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n use crate::traits::query::Fallible;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Lift, ParamEnvAnd, Ty, TyCtxt};\n@@ -18,51 +18,51 @@ where\n \n     fn perform_query(\n         tcx: TyCtxt<'tcx>,\n-        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self::QueryResponse>> {\n+        canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, Self::QueryResponse>> {\n         T::type_op_method(tcx, canonicalized)\n     }\n }\n \n pub trait Normalizable<'tcx>: fmt::Debug + TypeFoldable<'tcx> + Lift<'tcx> + Copy {\n     fn type_op_method(\n         tcx: TyCtxt<'tcx>,\n-        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>>;\n+        canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, Self>>;\n }\n \n impl<'tcx> Normalizable<'tcx> for Ty<'tcx> {\n     fn type_op_method(\n         tcx: TyCtxt<'tcx>,\n-        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>> {\n+        canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, Self>> {\n         tcx.type_op_normalize_ty(canonicalized)\n     }\n }\n \n impl<'tcx> Normalizable<'tcx> for ty::Predicate<'tcx> {\n     fn type_op_method(\n         tcx: TyCtxt<'tcx>,\n-        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>> {\n+        canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, Self>> {\n         tcx.type_op_normalize_predicate(canonicalized)\n     }\n }\n \n impl<'tcx> Normalizable<'tcx> for ty::PolyFnSig<'tcx> {\n     fn type_op_method(\n         tcx: TyCtxt<'tcx>,\n-        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>> {\n+        canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, Self>> {\n         tcx.type_op_normalize_poly_fn_sig(canonicalized)\n     }\n }\n \n impl<'tcx> Normalizable<'tcx> for ty::FnSig<'tcx> {\n     fn type_op_method(\n         tcx: TyCtxt<'tcx>,\n-        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>> {\n+        canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, Self>> {\n         tcx.type_op_normalize_fn_sig(canonicalized)\n     }\n }"}, {"sha": "0d42cd8250a19ec0e812207fa502139a4caffa5c", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/outlives.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n+use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n use crate::traits::query::dropck_outlives::{trivial_dropck_outlives, DropckOutlivesResult};\n use crate::traits::query::Fallible;\n use rustc_middle::ty::{ParamEnvAnd, Ty, TyCtxt};\n@@ -30,8 +30,8 @@ impl<'tcx> super::QueryTypeOp<'tcx> for DropckOutlives<'tcx> {\n \n     fn perform_query(\n         tcx: TyCtxt<'tcx>,\n-        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self::QueryResponse>> {\n+        canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, Self::QueryResponse>> {\n         // Subtle: note that we are not invoking\n         // `infcx.at(...).dropck_outlives(...)` here, but rather the\n         // underlying `dropck_outlives` query. This same underlying"}, {"sha": "b63da28e27475a046b067fe40e72e25459688b6c", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n+use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n use crate::traits::query::Fallible;\n use rustc_middle::ty::{self, ParamEnvAnd, TyCtxt};\n \n@@ -32,8 +32,8 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n \n     fn perform_query(\n         tcx: TyCtxt<'tcx>,\n-        mut canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n+        mut canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, ()>> {\n         match canonicalized.value.value.predicate.kind().skip_binder() {\n             ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n                 canonicalized.value.param_env.remap_constness_with(pred.constness);"}, {"sha": "c51292eba14be183851ca6d819fa36f81300b861", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/subtype.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n+use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n use crate::traits::query::Fallible;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n \n@@ -13,8 +13,8 @@ impl<'tcx> super::QueryTypeOp<'tcx> for Subtype<'tcx> {\n \n     fn perform_query(\n         tcx: TyCtxt<'tcx>,\n-        canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n+        canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, ()>> {\n         tcx.type_op_subtype(canonicalized)\n     }\n }"}, {"sha": "1e8d8c3d3559bc3d0675054f3b1685f8eec6cbac", "filename": "src/test/ui/const-generics/ensure_is_evaluatable.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Fensure_is_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Fensure_is_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fensure_is_evaluatable.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,20 @@\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+fn foo<const N: usize, const M: usize>() -> [(); N+2]\n+where\n+    [(); N + 1]:,\n+    [(); M + 1]:,\n+{\n+    bar()\n+    //~^ ERROR: unconstrained\n+}\n+\n+fn bar<const N: usize>() -> [(); N]\n+where\n+    [(); N + 1]:,\n+{\n+    [(); N]\n+}\n+\n+fn main() {}"}, {"sha": "bf6c35ad8fd8667a92a166971261d3c48fa650bc", "filename": "src/test/ui/const-generics/ensure_is_evaluatable.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Fensure_is_evaluatable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Fensure_is_evaluatable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fensure_is_evaluatable.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,18 @@\n+error: unconstrained generic constant\n+  --> $DIR/ensure_is_evaluatable.rs:9:5\n+   |\n+LL |     bar()\n+   |     ^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); N + 1]:`\n+note: required by a bound in `bar`\n+  --> $DIR/ensure_is_evaluatable.rs:15:10\n+   |\n+LL | fn bar<const N: usize>() -> [(); N]\n+   |    --- required by a bound in this\n+LL | where\n+LL |     [(); N + 1]:,\n+   |          ^^^^^ required by this bound in `bar`\n+\n+error: aborting due to previous error\n+"}, {"sha": "0d6246a9f02c3449ecd8f112d6651787db318919", "filename": "src/test/ui/const-generics/fn_with_two_const_inputs.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Ffn_with_two_const_inputs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Ffn_with_two_const_inputs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn_with_two_const_inputs.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,23 @@\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+const fn both(_: usize, b: usize) -> usize {\n+    b\n+}\n+\n+fn foo<const N: usize, const M: usize>() -> [(); N + 2]\n+where\n+    [(); both(N + 1, M + 1)]:,\n+{\n+    bar()\n+    //~^ ERROR: unconstrained generic constant\n+}\n+\n+fn bar<const N: usize>() -> [(); N]\n+where\n+    [(); N + 1]:,\n+{\n+    [(); N]\n+}\n+\n+fn main() {}"}, {"sha": "614e7e0d2fc202617b6cf10ed123d9d38bbe43e7", "filename": "src/test/ui/const-generics/fn_with_two_const_inputs.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Ffn_with_two_const_inputs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Ffn_with_two_const_inputs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn_with_two_const_inputs.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,18 @@\n+error: unconstrained generic constant\n+  --> $DIR/fn_with_two_const_inputs.rs:12:5\n+   |\n+LL |     bar()\n+   |     ^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); N + 1]:`\n+note: required by a bound in `bar`\n+  --> $DIR/fn_with_two_const_inputs.rs:18:10\n+   |\n+LL | fn bar<const N: usize>() -> [(); N]\n+   |    --- required by a bound in this\n+LL | where\n+LL |     [(); N + 1]:,\n+   |          ^^^^^ required by this bound in `bar`\n+\n+error: aborting due to previous error\n+"}, {"sha": "f0ce093e07a4f14b268a94d8c4032ab5ee56cb13", "filename": "src/test/ui/const-generics/fn_with_two_same_const_inputs.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Ffn_with_two_same_const_inputs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Ffn_with_two_same_const_inputs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn_with_two_same_const_inputs.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+const fn both(_: usize, b: usize) -> usize {\n+    b\n+}\n+\n+fn foo<const N: usize>()\n+where\n+    [(); both(N + 1, N + 1)]:,\n+{\n+    bar::<N>();\n+}\n+\n+fn bar<const N: usize>()\n+where\n+    [(); N + 1]:,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "f7d239499439688047b95f81ad9543c989e25525", "filename": "src/test/ui/const-generics/issues/issue-105037.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-105037.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-105037.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-105037.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,35 @@\n+// run-pass\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+#![allow(dead_code)]\n+\n+trait Table<const D: usize>: Sync {\n+    const COLUMNS: usize;\n+}\n+\n+struct Table1<const D: usize>;\n+impl<const D: usize> Table<D> for Table1<D> {\n+    const COLUMNS: usize = 123;\n+}\n+\n+struct Table2<const D: usize>;\n+impl<const D: usize> Table<D> for Table2<D> {\n+    const COLUMNS: usize = 456;\n+}\n+\n+fn process_table<T: Table<D>, const D: usize>(_table: T)\n+where\n+    [(); T::COLUMNS]:,\n+{\n+}\n+\n+fn process_all_tables<const D: usize>()\n+where\n+    [(); Table2::<D>::COLUMNS]:,\n+    [(); Table1::<D>::COLUMNS]:,\n+{\n+    process_table(Table1::<D>);\n+    process_table(Table2::<D>);\n+}\n+\n+fn main() {}"}, {"sha": "de608f73e2c0c0ffb8f5d4cd0d6841c686b41927", "filename": "src/test/ui/const-generics/two_matching_preds.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Ftwo_matching_preds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Ftwo_matching_preds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftwo_matching_preds.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+fn foo<const N: usize>()\n+where\n+    [(); N + 1]:,\n+    [(); N + 1]:,\n+{\n+    bar::<N>();\n+}\n+\n+fn bar<const N: usize>()\n+where\n+    [(); N + 1]:,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "1271e0902a3bd5c06b852a7db408c94a824df91a", "filename": "src/test/ui/const-generics/unify_with_nested_expr.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Funify_with_nested_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Funify_with_nested_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Funify_with_nested_expr.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,18 @@\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+fn foo<const N: usize>()\n+where\n+    [(); N + 1 + 1]:,\n+{\n+    bar();\n+    //~^ ERROR: type annotations\n+}\n+\n+fn bar<const N: usize>()\n+where\n+    [(); N + 1]:,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "8bab0dff7f26371966ca88721c3653fe64e6a2cf", "filename": "src/test/ui/const-generics/unify_with_nested_expr.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Funify_with_nested_expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-generics%2Funify_with_nested_expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Funify_with_nested_expr.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,22 @@\n+error[E0284]: type annotations needed\n+  --> $DIR/unify_with_nested_expr.rs:8:5\n+   |\n+LL |     bar();\n+   |     ^^^ cannot infer the value of the const parameter `N` declared on the function `bar`\n+   |\n+note: required by a bound in `bar`\n+  --> $DIR/unify_with_nested_expr.rs:14:10\n+   |\n+LL | fn bar<const N: usize>()\n+   |    --- required by a bound in this\n+LL | where\n+LL |     [(); N + 1]:,\n+   |          ^^^^^ required by this bound in `bar`\n+help: consider specifying the generic argument\n+   |\n+LL |     bar::<N>();\n+   |        +++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0284`."}, {"sha": "f4f9fe69516a6a258a1abb022c7c35b5b135d37a", "filename": "src/test/ui/const-ptr/forbidden_slices.64bit.stderr", "status": "removed", "additions": 0, "deletions": 240, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -1,240 +0,0 @@\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-   = note: dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n-   |\n-note: inside `std::slice::from_raw_parts::<'_, u32>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `S0`\n-  --> $DIR/forbidden_slices.rs:18:34\n-   |\n-LL | pub static S0: &[u32] = unsafe { from_raw_parts(ptr::null(), 0) };\n-   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-   = note: dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n-   |\n-note: inside `std::slice::from_raw_parts::<'_, ()>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `S1`\n-  --> $DIR/forbidden_slices.rs:19:33\n-   |\n-LL | pub static S1: &[()] = unsafe { from_raw_parts(ptr::null(), 0) };\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-   = note: dereferencing pointer failed: allocN has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n-   |\n-note: inside `std::slice::from_raw_parts::<'_, u32>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `S2`\n-  --> $DIR/forbidden_slices.rs:22:34\n-   |\n-LL | pub static S2: &[u32] = unsafe { from_raw_parts(&D0, 2) };\n-   |                                  ^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:25:1\n-   |\n-LL | pub static S4: &[u8] = unsafe { from_raw_parts((&D1) as *const _ as _, 1) };\n-   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered uninitialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:27:1\n-   |\n-LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, size_of::<&u32>()) };\n-   | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:29:1\n-   |\n-LL | pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x11, but expected a boolean\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:32:1\n-   |\n-LL | pub static S7: &[u16] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[1]: encountered uninitialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID+0x2\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-   = note: dereferencing pointer failed: allocN has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n-   |\n-note: inside `std::slice::from_raw_parts::<'_, u64>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `S8`\n-  --> $DIR/forbidden_slices.rs:43:5\n-   |\n-LL |     from_raw_parts(ptr, 1)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-   = note: out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n-   |\n-note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `from_ptr_range::<'_, u32>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `R0`\n-  --> $DIR/forbidden_slices.rs:46:34\n-   |\n-LL | pub static R0: &[u32] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n-   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-   = note: the evaluated program panicked at 'assertion failed: 0 < pointee_size && pointee_size <= isize::MAX as usize', $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-note: inside `ptr::const_ptr::<impl *const ()>::sub_ptr`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `from_ptr_range::<'_, ()>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `R1`\n-  --> $DIR/forbidden_slices.rs:47:33\n-   |\n-LL | pub static R1: &[()] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-   = note: out-of-bounds pointer arithmetic: allocN has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n-   |\n-note: inside `ptr::const_ptr::<impl *const u32>::offset`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `ptr::const_ptr::<impl *const u32>::add`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `R2`\n-  --> $DIR/forbidden_slices.rs:50:25\n-   |\n-LL |     from_ptr_range(ptr..ptr.add(2))\n-   |                         ^^^^^^^^^^\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:52:1\n-   |\n-LL | pub static R4: &[u8] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered uninitialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:57:1\n-   |\n-LL | pub static R5: &[u8] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:62:1\n-   |\n-LL | pub static R6: &[bool] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x11, but expected a boolean\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-   = note: accessing memory with alignment 1, but alignment 2 is required\n-   |\n-note: inside `std::slice::from_raw_parts::<'_, u16>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `from_ptr_range::<'_, u16>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `R7`\n-  --> $DIR/forbidden_slices.rs:69:5\n-   |\n-LL |     from_ptr_range(ptr..ptr.add(4))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-   = note: out-of-bounds pointer arithmetic: allocN has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n-   |\n-note: inside `ptr::const_ptr::<impl *const u64>::offset`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `ptr::const_ptr::<impl *const u64>::add`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `R8`\n-  --> $DIR/forbidden_slices.rs:73:25\n-   |\n-LL |     from_ptr_range(ptr..ptr.add(1))\n-   |                         ^^^^^^^^^^\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-   = note: `ptr_offset_from_unsigned` called on pointers into different allocations\n-   |\n-note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `from_ptr_range::<'_, u32>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `R9`\n-  --> $DIR/forbidden_slices.rs:78:34\n-   |\n-LL | pub static R9: &[u32] = unsafe { from_ptr_range(&D0..(&D0 as *const u32).add(1)) };\n-   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-   = note: `ptr_offset_from_unsigned` called on pointers into different allocations\n-   |\n-note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `from_ptr_range::<'_, u32>`\n-  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-note: inside `R10`\n-  --> $DIR/forbidden_slices.rs:79:35\n-   |\n-LL | pub static R10: &[u32] = unsafe { from_ptr_range(&D0..&D0) };\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 18 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "192b6a46de6073d0e84c41064b11e837cdf2700e", "filename": "src/test/ui/const-ptr/forbidden_slices.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,5 +1,6 @@\n-// stderr-per-bitwidth\n-// normalize-stderr-test \"\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c\" -> \"\u257eALLOC_ID$2\u257c\"\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n // normalize-stderr-test \"alloc\\d+\" -> \"allocN\"\n // error-pattern: could not evaluate static initializer\n #![feature(\n@@ -78,7 +79,7 @@ pub static R8: &[u64] = unsafe {\n pub static R9: &[u32] = unsafe { from_ptr_range(&D0..(&D0 as *const u32).add(1)) };\n pub static R10: &[u32] = unsafe { from_ptr_range(&D0..&D0) };\n \n-const D0: u32 = 0x11;\n+const D0: u32 = 0x11111111; // Constant chosen for endianness-independent behavior.\n const D1: MaybeUninit<&u32> = MaybeUninit::uninit();\n const D2: Struct = Struct { a: 1, b: 2, c: 3, d: 4 };\n const D3: &u32 = &42;"}, {"sha": "b42361872c475daac8ce1360d275246eb6520772", "filename": "src/test/ui/const-ptr/forbidden_slices.stderr", "status": "renamed", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -6,7 +6,7 @@ error[E0080]: could not evaluate static initializer\n note: inside `std::slice::from_raw_parts::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `S0`\n-  --> $DIR/forbidden_slices.rs:18:34\n+  --> $DIR/forbidden_slices.rs:19:34\n    |\n LL | pub static S0: &[u32] = unsafe { from_raw_parts(ptr::null(), 0) };\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -19,7 +19,7 @@ error[E0080]: could not evaluate static initializer\n note: inside `std::slice::from_raw_parts::<'_, ()>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `S1`\n-  --> $DIR/forbidden_slices.rs:19:33\n+  --> $DIR/forbidden_slices.rs:20:33\n    |\n LL | pub static S1: &[()] = unsafe { from_raw_parts(ptr::null(), 0) };\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -32,54 +32,54 @@ error[E0080]: could not evaluate static initializer\n note: inside `std::slice::from_raw_parts::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `S2`\n-  --> $DIR/forbidden_slices.rs:22:34\n+  --> $DIR/forbidden_slices.rs:23:34\n    |\n LL | pub static S2: &[u32] = unsafe { from_raw_parts(&D0, 2) };\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:25:1\n+  --> $DIR/forbidden_slices.rs:26:1\n    |\n LL | pub static S4: &[u8] = unsafe { from_raw_parts((&D1) as *const _ as _, 1) };\n    | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered uninitialized bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:27:1\n+  --> $DIR/forbidden_slices.rs:28:1\n    |\n LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, size_of::<&u32>()) };\n    | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n    = help: this code performed an operation that depends on the underlying bytes representing a pointer\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:29:1\n+  --> $DIR/forbidden_slices.rs:30:1\n    |\n LL | pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4) };\n    | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x11, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:32:1\n+  --> $DIR/forbidden_slices.rs:33:1\n    |\n LL | pub static S7: &[u16] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[1]: encountered uninitialized bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID+0x2\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: could not evaluate static initializer\n@@ -90,7 +90,7 @@ error[E0080]: could not evaluate static initializer\n note: inside `std::slice::from_raw_parts::<'_, u64>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `S8`\n-  --> $DIR/forbidden_slices.rs:43:5\n+  --> $DIR/forbidden_slices.rs:44:5\n    |\n LL |     from_raw_parts(ptr, 1)\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n@@ -105,7 +105,7 @@ note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n note: inside `from_ptr_range::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `R0`\n-  --> $DIR/forbidden_slices.rs:46:34\n+  --> $DIR/forbidden_slices.rs:47:34\n    |\n LL | pub static R0: &[u32] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -120,7 +120,7 @@ note: inside `ptr::const_ptr::<impl *const ()>::sub_ptr`\n note: inside `from_ptr_range::<'_, ()>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `R1`\n-  --> $DIR/forbidden_slices.rs:47:33\n+  --> $DIR/forbidden_slices.rs:48:33\n    |\n LL | pub static R1: &[()] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -136,43 +136,43 @@ note: inside `ptr::const_ptr::<impl *const u32>::offset`\n note: inside `ptr::const_ptr::<impl *const u32>::add`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n note: inside `R2`\n-  --> $DIR/forbidden_slices.rs:50:25\n+  --> $DIR/forbidden_slices.rs:51:25\n    |\n LL |     from_ptr_range(ptr..ptr.add(2))\n    |                         ^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:52:1\n+  --> $DIR/forbidden_slices.rs:53:1\n    |\n LL | pub static R4: &[u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered uninitialized bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:57:1\n+  --> $DIR/forbidden_slices.rs:58:1\n    |\n LL | pub static R5: &[u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n    = help: this code performed an operation that depends on the underlying bytes representing a pointer\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/forbidden_slices.rs:62:1\n+  --> $DIR/forbidden_slices.rs:63:1\n    |\n LL | pub static R6: &[bool] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x11, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: could not evaluate static initializer\n@@ -185,7 +185,7 @@ note: inside `std::slice::from_raw_parts::<'_, u16>`\n note: inside `from_ptr_range::<'_, u16>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `R7`\n-  --> $DIR/forbidden_slices.rs:69:5\n+  --> $DIR/forbidden_slices.rs:70:5\n    |\n LL |     from_ptr_range(ptr..ptr.add(4))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -200,7 +200,7 @@ note: inside `ptr::const_ptr::<impl *const u64>::offset`\n note: inside `ptr::const_ptr::<impl *const u64>::add`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n note: inside `R8`\n-  --> $DIR/forbidden_slices.rs:73:25\n+  --> $DIR/forbidden_slices.rs:74:25\n    |\n LL |     from_ptr_range(ptr..ptr.add(1))\n    |                         ^^^^^^^^^^\n@@ -215,7 +215,7 @@ note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n note: inside `from_ptr_range::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `R9`\n-  --> $DIR/forbidden_slices.rs:78:34\n+  --> $DIR/forbidden_slices.rs:79:34\n    |\n LL | pub static R9: &[u32] = unsafe { from_ptr_range(&D0..(&D0 as *const u32).add(1)) };\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -230,7 +230,7 @@ note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n note: inside `from_ptr_range::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n note: inside `R10`\n-  --> $DIR/forbidden_slices.rs:79:35\n+  --> $DIR/forbidden_slices.rs:80:35\n    |\n LL | pub static R10: &[u32] = unsafe { from_ptr_range(&D0..&D0) };\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^", "previous_filename": "src/test/ui/const-ptr/forbidden_slices.32bit.stderr"}, {"sha": "91a426580c3cdad9e77e0a06b5794ec8a36f2568", "filename": "src/test/ui/consts/const-eval/raw-bytes.32bit.stderr", "status": "added", "additions": 596, "deletions": 0, "changes": 596, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,596 @@\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:20:1\n+   |\n+LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x00000001, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               01 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:28:1\n+   |\n+LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x00000000, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               00 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:42:1\n+   |\n+LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(B)>.0: encountered a value of the never type `!`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 1, align: 1) {\n+               01                                              \u2502 .\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:44:1\n+   |\n+LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 1, align: 1) {\n+               03                                              \u2502 .\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:50:1\n+   |\n+LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Some)>.0.1: encountered 0xffffffff, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               78 00 00 00 ff ff ff ff                         \u2502 x.......\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:54:1\n+   |\n+LL | const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               00 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:57:1\n+   |\n+LL | const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 1, align: 1) {\n+               00                                              \u2502 .\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:59:1\n+   |\n+LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               00 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:65:1\n+   |\n+LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 42, but expected something in the range 10..=30\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               2a 00 00 00                                     \u2502 *...\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:71:1\n+   |\n+LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 20, but expected something less or equal to 10, or greater or equal to 30\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               14 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:74:1\n+   |\n+LL | const NULL_FAT_PTR: NonNull<dyn Send> = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               00 00 00 00 \u257eALLOC_ID\u257c                         \u2502 ....\u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:82:1\n+   |\n+LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned reference (required 2 byte alignment but found 1)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:86:1\n+   |\n+LL | const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned box (required 2 byte alignment but found 1)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:90:1\n+   |\n+LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null reference\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               00 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:93:1\n+   |\n+LL | const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null box\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               00 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:96:1\n+   |\n+LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x539 is unallocated)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               39 05 00 00                                     \u2502 9...\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:99:1\n+   |\n+LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (address 0x539 is unallocated)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               39 05 00 00                                     \u2502 9...\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:102:1\n+   |\n+LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a function pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               00 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:104:1\n+   |\n+LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0xd[noalloc], but expected a function pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               0d 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:106:1\n+   |\n+LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a function pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:112:1\n+   |\n+LL | const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to uninhabited type Bar\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               01 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:137:1\n+   |\n+LL | const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:139:1\n+   |\n+LL | const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c ff ff ff ff                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:141:1\n+   |\n+LL | const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c ff ff ff ff                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:144:1\n+   |\n+LL | const STR_NO_INIT: &str = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered uninitialized data in `str`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:146:1\n+   |\n+LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered uninitialized data in `str`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:148:1\n+   |\n+LL | const MYSTR_NO_INIT_ISSUE83182: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:152:1\n+   |\n+LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:154:1\n+   |\n+LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c ff ff ff 7f                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:157:1\n+   |\n+LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (going beyond the bounds of its allocation)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:160:1\n+   |\n+LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x03, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+           }\n+\n+note: erroneous constant used\n+  --> $DIR/raw-bytes.rs:160:40\n+   |\n+LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:166:1\n+   |\n+LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered 0x03, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+           }\n+\n+note: erroneous constant used\n+  --> $DIR/raw-bytes.rs:166:42\n+   |\n+LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:170:1\n+   |\n+LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.1[0]: encountered 0x03, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+           }\n+\n+note: erroneous constant used\n+  --> $DIR/raw-bytes.rs:170:42\n+   |\n+LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:175:1\n+   |\n+LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:179:1\n+   |\n+LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:183:1\n+   |\n+LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered 0x4[noalloc], but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:186:1\n+   |\n+LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:190:1\n+   |\n+LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:194:1\n+   |\n+LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 00 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:196:1\n+   |\n+LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:201:1\n+   |\n+LL | const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .align.0.<enum-tag>: encountered 0x00000000, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               00 10 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:205:1\n+   |\n+LL | const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unchecked(9, 3) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .align.0.<enum-tag>: encountered 0x00000003, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               09 00 00 00 03 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:209:1\n+   |\n+LL | const _: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) };\n+   | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to uninhabited type [!; 1]\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               01 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:210:1\n+   |\n+LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 1]) };\n+   | ^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered a value of the never type `!`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               01 00 00 00 01 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:211:1\n+   |\n+LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 42]) };\n+   | ^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered a value of the never type `!`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               01 00 00 00 2a 00 00 00                         \u2502 ....*...\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:215:1\n+   |\n+LL | pub static S4: &[u8] = unsafe { from_raw_parts((&D1) as *const _ as _, 1) };\n+   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered uninitialized bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:218:1\n+   |\n+LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, mem::size_of::<&u32>()) };\n+   | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:221:1\n+   |\n+LL | pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x11, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:225:1\n+   |\n+LL | pub static S7: &[u16] = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[1]: encountered uninitialized bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID+0x2\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:232:1\n+   |\n+LL | pub static R4: &[u8] = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered uninitialized bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:237:1\n+   |\n+LL | pub static R5: &[u8] = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:242:1\n+   |\n+LL | pub static R6: &[bool] = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x11, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error: aborting due to 52 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "e4c5e62f6bd3aab7135bb345e9ddd1cd914ac286", "filename": "src/test/ui/consts/const-eval/raw-bytes.64bit.stderr", "status": "added", "additions": 596, "deletions": 0, "changes": 596, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,596 @@\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:20:1\n+   |\n+LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x0000000000000001, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               01 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:28:1\n+   |\n+LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x0000000000000000, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               00 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:42:1\n+   |\n+LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(B)>.0: encountered a value of the never type `!`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 1, align: 1) {\n+               01                                              \u2502 .\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:44:1\n+   |\n+LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 1, align: 1) {\n+               03                                              \u2502 .\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:50:1\n+   |\n+LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Some)>.0.1: encountered 0xffffffff, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               78 00 00 00 ff ff ff ff                         \u2502 x.......\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:54:1\n+   |\n+LL | const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               00 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:57:1\n+   |\n+LL | const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 1, align: 1) {\n+               00                                              \u2502 .\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:59:1\n+   |\n+LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               00 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:65:1\n+   |\n+LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 42, but expected something in the range 10..=30\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               2a 00 00 00                                     \u2502 *...\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:71:1\n+   |\n+LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 20, but expected something less or equal to 10, or greater or equal to 30\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 4, align: 4) {\n+               14 00 00 00                                     \u2502 ....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:74:1\n+   |\n+LL | const NULL_FAT_PTR: NonNull<dyn Send> = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               00 00 00 00 00 00 00 00 \u257eALLOC_ID\u257c \u2502 ........\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:82:1\n+   |\n+LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned reference (required 2 byte alignment but found 1)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:86:1\n+   |\n+LL | const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned box (required 2 byte alignment but found 1)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:90:1\n+   |\n+LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null reference\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               00 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:93:1\n+   |\n+LL | const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null box\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               00 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:96:1\n+   |\n+LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x539 is unallocated)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               39 05 00 00 00 00 00 00                         \u2502 9.......\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:99:1\n+   |\n+LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (address 0x539 is unallocated)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               39 05 00 00 00 00 00 00                         \u2502 9.......\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:102:1\n+   |\n+LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a function pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               00 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:104:1\n+   |\n+LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0xd[noalloc], but expected a function pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               0d 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:106:1\n+   |\n+LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a function pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:112:1\n+   |\n+LL | const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to uninhabited type Bar\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               01 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:137:1\n+   |\n+LL | const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:139:1\n+   |\n+LL | const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c ff ff ff ff ff ff ff ff \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:141:1\n+   |\n+LL | const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c ff ff ff ff ff ff ff ff \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:144:1\n+   |\n+LL | const STR_NO_INIT: &str = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered uninitialized data in `str`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:146:1\n+   |\n+LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered uninitialized data in `str`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:148:1\n+   |\n+LL | const MYSTR_NO_INIT_ISSUE83182: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:152:1\n+   |\n+LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:154:1\n+   |\n+LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c ff ff ff ff ff ff ff 7f \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:157:1\n+   |\n+LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (going beyond the bounds of its allocation)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:160:1\n+   |\n+LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x03, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+note: erroneous constant used\n+  --> $DIR/raw-bytes.rs:160:40\n+   |\n+LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:166:1\n+   |\n+LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered 0x03, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+note: erroneous constant used\n+  --> $DIR/raw-bytes.rs:166:42\n+   |\n+LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:170:1\n+   |\n+LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.1[0]: encountered 0x03, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+note: erroneous constant used\n+  --> $DIR/raw-bytes.rs:170:42\n+   |\n+LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:175:1\n+   |\n+LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:179:1\n+   |\n+LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:183:1\n+   |\n+LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered 0x4[noalloc], but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:186:1\n+   |\n+LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:190:1\n+   |\n+LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:194:1\n+   |\n+LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 00 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:196:1\n+   |\n+LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:201:1\n+   |\n+LL | const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .align.0.<enum-tag>: encountered 0x0000000000000000, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:205:1\n+   |\n+LL | const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unchecked(9, 3) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .align.0.<enum-tag>: encountered 0x0000000000000003, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               09 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00 \u2502 ................\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:209:1\n+   |\n+LL | const _: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) };\n+   | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to uninhabited type [!; 1]\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 8) {\n+               01 00 00 00 00 00 00 00                         \u2502 ........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:210:1\n+   |\n+LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 1]) };\n+   | ^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered a value of the never type `!`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               01 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 \u2502 ................\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:211:1\n+   |\n+LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 42]) };\n+   | ^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered a value of the never type `!`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               01 00 00 00 00 00 00 00 2a 00 00 00 00 00 00 00 \u2502 ........*.......\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:215:1\n+   |\n+LL | pub static S4: &[u8] = unsafe { from_raw_parts((&D1) as *const _ as _, 1) };\n+   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered uninitialized bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:218:1\n+   |\n+LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, mem::size_of::<&u32>()) };\n+   | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:221:1\n+   |\n+LL | pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x11, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:225:1\n+   |\n+LL | pub static S7: &[u16] = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[1]: encountered uninitialized bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID+0x2\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:232:1\n+   |\n+LL | pub static R4: &[u8] = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered uninitialized bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:237:1\n+   |\n+LL | pub static R5: &[u8] = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/raw-bytes.rs:242:1\n+   |\n+LL | pub static R6: &[bool] = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x11, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257eALLOC_ID\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error: aborting due to 52 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "6c1238c0a063e138373d32a28dad1ef272a0187b", "filename": "src/test/ui/consts/const-eval/raw-bytes.rs", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,263 @@\n+// stderr-per-bitwidth\n+// ignore-endian-big\n+// ignore-tidy-linelength\n+// normalize-stderr-test \"\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c\" -> \"\u257eALLOC_ID$2\u257c\"\n+// normalize-stderr-test \"alloc\\d+\" -> \"allocN\"\n+#![feature(never_type, rustc_attrs, ptr_metadata, slice_from_ptr_range, const_slice_from_ptr_range)]\n+#![allow(invalid_value)]\n+\n+use std::mem;\n+use std::alloc::Layout;\n+use std::ptr::NonNull;\n+use std::num::{NonZeroU8, NonZeroUsize};\n+use std::slice::{from_ptr_range, from_raw_parts};\n+\n+#[repr(usize)]\n+#[derive(Copy, Clone)]\n+enum Enum {\n+    A = 0,\n+}\n+const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n+//~^ ERROR is undefined behavior\n+\n+#[repr(usize)]\n+#[derive(Copy, Clone)]\n+enum Enum2 {\n+    A = 2,\n+}\n+const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n+//~^ ERROR is undefined behavior\n+\n+#[derive(Copy, Clone)]\n+enum Never {}\n+\n+// An enum with 3 variants of which some are uninhabited -- so the uninhabited variants *do*\n+// have a discriminant.\n+enum UninhDiscriminant {\n+    A,\n+    B(!),\n+    C,\n+    D(Never),\n+}\n+const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n+//~^ ERROR is undefined behavior\n+const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n+//~^ ERROR is undefined behavior\n+\n+// Invalid enum field content (mostly to test printing of paths for enum tuple\n+// variants and tuples).\n+// Need to create something which does not clash with enum layout optimizations.\n+const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n+//~^ ERROR is undefined behavior\n+\n+\n+const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n+//~^ ERROR it is undefined behavior to use this value\n+const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+#[rustc_layout_scalar_valid_range_start(10)]\n+#[rustc_layout_scalar_valid_range_end(30)]\n+struct RestrictedRange1(u32);\n+const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+#[rustc_layout_scalar_valid_range_start(30)]\n+#[rustc_layout_scalar_valid_range_end(10)]\n+struct RestrictedRange2(u32);\n+const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+const NULL_FAT_PTR: NonNull<dyn Send> = unsafe {\n+//~^ ERROR it is undefined behavior to use this value\n+    let x: &dyn Send = &42;\n+    let meta = std::ptr::metadata(x);\n+    mem::transmute((0_usize, meta))\n+};\n+\n+\n+const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n+//~^ ERROR it is undefined behavior to use this value\n+//~| constructing invalid value: encountered an unaligned reference (required 2 byte alignment but found 1)\n+\n+const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n+//~^ ERROR it is undefined behavior to use this value\n+//~| constructing invalid value: encountered an unaligned box (required 2 byte alignment but found 1)\n+\n+const NULL: &u16 = unsafe { mem::transmute(0usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+#[derive(Copy, Clone)]\n+enum Bar {}\n+\n+const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+\n+/// A newtype wrapper to prevent MIR generation from inserting reborrows that would affect the error\n+/// message.\n+#[repr(transparent)]\n+struct W<T>(T);\n+\n+#[repr(C)]\n+union MaybeUninit<T: Copy> {\n+    uninit: (),\n+    init: T,\n+}\n+\n+trait Trait {}\n+impl Trait for bool {}\n+\n+// custom unsized type\n+struct MyStr(str);\n+\n+// custom unsized type with sized fields\n+struct MySlice<T: ?Sized>(bool, T);\n+type MySliceBool = MySlice<[bool]>;\n+\n+const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n+//~^ ERROR it is undefined behavior to use this value\n+const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n+//~^ ERROR it is undefined behavior to use this value\n+const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+const STR_NO_INIT: &str = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n+//~^ ERROR it is undefined behavior to use this value\n+const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n+//~^ ERROR it is undefined behavior to use this value\n+const MYSTR_NO_INIT_ISSUE83182: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n+//~^ ERROR: it is undefined behavior to use this value\n+\n+// # slice\n+const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n+//~^ ERROR it is undefined behavior to use this value\n+const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n+//~^ ERROR it is undefined behavior to use this value\n+// bad slice box: length too big\n+const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n+//~^ ERROR it is undefined behavior to use this value\n+// bad data *inside* the slice\n+const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n+//~^ ERROR it is undefined behavior to use this value\n+//~| constant\n+\n+\n+// bad: sized field is not okay\n+const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n+//~^ ERROR it is undefined behavior to use this value\n+//~| constant\n+// bad: unsized part is not okay\n+const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n+//~^ ERROR it is undefined behavior to use this value\n+//~| constant\n+\n+// bad trait object\n+const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n+//~^ ERROR it is undefined behavior to use this value\n+//~| expected a vtable\n+// bad trait object\n+const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n+//~^ ERROR it is undefined behavior to use this value\n+//~| expected a vtable\n+// bad trait object\n+const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n+//~^ ERROR it is undefined behavior to use this value\n+//~| expected a vtable\n+const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n+//~^ ERROR it is undefined behavior to use this value\n+//~| expected a vtable\n+// bad data *inside* the trait object\n+const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n+//~^ ERROR it is undefined behavior to use this value\n+//~| expected a boolean\n+\n+const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n+//~^ ERROR it is undefined behavior to use this value\n+const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+\n+// not ok, since alignment needs to be non-zero.\n+const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+// not ok, since alignment needs to be a power of two.\n+const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unchecked(9, 3) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+\n+const _: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) }; //~ ERROR undefined behavior\n+const _: &[!] = unsafe { &*(1_usize as *const [!; 1]) }; //~ ERROR undefined behavior\n+const _: &[!] = unsafe { &*(1_usize as *const [!; 42]) }; //~ ERROR undefined behavior\n+\n+\n+// Reading uninitialized  data\n+pub static S4: &[u8] = unsafe { from_raw_parts((&D1) as *const _ as _, 1) };\n+//~^ ERROR: it is undefined behavior to use this value\n+// Reinterpret pointers as integers (UB in CTFE.)\n+pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, mem::size_of::<&u32>()) };\n+//~^ ERROR: it is undefined behavior to use this value\n+// Layout mismatch\n+pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4) };\n+//~^ ERROR: it is undefined behavior to use this value\n+\n+// Reading padding is not ok\n+pub static S7: &[u16] = unsafe {\n+    //~^ ERROR: it is undefined behavior to use this value\n+    let ptr = (&D2 as *const Struct as *const u16).add(1);\n+\n+    from_raw_parts(ptr, 4)\n+};\n+\n+pub static R4: &[u8] = unsafe {\n+    //~^ ERROR: it is undefined behavior to use this value\n+    let ptr = (&D1) as *const mem::MaybeUninit<&u32> as *const u8;\n+    from_ptr_range(ptr..ptr.add(1))\n+};\n+pub static R5: &[u8] = unsafe {\n+    //~^ ERROR: it is undefined behavior to use this value\n+    let ptr = &D3 as *const &u32;\n+    from_ptr_range(ptr.cast()..ptr.add(1).cast())\n+};\n+pub static R6: &[bool] = unsafe {\n+    //~^ ERROR: it is undefined behavior to use this value\n+    let ptr = &D0 as *const u32 as *const bool;\n+    from_ptr_range(ptr..ptr.add(4))\n+};\n+\n+const D0: u32 = 0x11111111; // Constant chosen for endianness-independent behavior.\n+const D1: mem::MaybeUninit<&u32> = mem::MaybeUninit::uninit();\n+const D2: Struct = Struct { a: 1, b: 2, c: 3, d: 4 };\n+const D3: &u32 = &42;\n+\n+#[repr(C)]\n+struct Struct {\n+    a: u8,\n+    // _pad: [mem::MaybeUninit<u8>; 3]\n+    b: u32,\n+    c: u16,\n+    d: u8,\n+    // _pad: [mem::MaybeUninit<u8>; 1]\n+}\n+\n+fn main() {}"}, {"sha": "2d86bd88f1c8834dd05b0fe7c86ac59bfc6fd07e", "filename": "src/test/ui/consts/const-eval/ub-enum.32bit.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,16 +1,16 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:24:1\n+  --> $DIR/ub-enum.rs:27:1\n    |\n LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n    | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x00000001, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               01 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:27:1\n+  --> $DIR/ub-enum.rs:30:1\n    |\n LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -19,7 +19,7 @@ LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:30:1\n+  --> $DIR/ub-enum.rs:33:1\n    |\n LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -28,18 +28,18 @@ LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:42:1\n+  --> $DIR/ub-enum.rs:45:1\n    |\n LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x00000000, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               00 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:44:1\n+  --> $DIR/ub-enum.rs:47:1\n    |\n LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -48,7 +48,7 @@ LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:47:1\n+  --> $DIR/ub-enum.rs:50:1\n    |\n LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -57,13 +57,13 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:56:42\n+  --> $DIR/ub-enum.rs:59:42\n    |\n LL | const BAD_ENUM2_UNDEF : Enum2 = unsafe { MaybeUninit { uninit: () }.init };\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:61:1\n+  --> $DIR/ub-enum.rs:64:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -72,46 +72,46 @@ LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:78:1\n+  --> $DIR/ub-enum.rs:81:1\n    |\n LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(B)>.0: encountered a value of the never type `!`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               01                                              \u2502 .\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:80:1\n+  --> $DIR/ub-enum.rs:83:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               03                                              \u2502 .\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:88:1\n+  --> $DIR/ub-enum.rs:91:1\n    |\n LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Some)>.0.1: encountered 0xffffffff, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               78 00 00 00 ff ff ff ff                         \u2502 x.......\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:93:77\n+  --> $DIR/ub-enum.rs:96:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:95:77\n+  --> $DIR/ub-enum.rs:98:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type"}, {"sha": "a89d7ec5f6d44cb7824d0d7d7ab4aa783231c7f3", "filename": "src/test/ui/consts/const-eval/ub-enum.64bit.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,16 +1,16 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:24:1\n+  --> $DIR/ub-enum.rs:27:1\n    |\n LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n    | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x0000000000000001, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               01 00 00 00 00 00 00 00                         \u2502 ........\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:27:1\n+  --> $DIR/ub-enum.rs:30:1\n    |\n LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -19,7 +19,7 @@ LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:30:1\n+  --> $DIR/ub-enum.rs:33:1\n    |\n LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -28,18 +28,18 @@ LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:42:1\n+  --> $DIR/ub-enum.rs:45:1\n    |\n LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x0000000000000000, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               00 00 00 00 00 00 00 00                         \u2502 ........\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:44:1\n+  --> $DIR/ub-enum.rs:47:1\n    |\n LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -48,7 +48,7 @@ LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:47:1\n+  --> $DIR/ub-enum.rs:50:1\n    |\n LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -57,13 +57,13 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:56:42\n+  --> $DIR/ub-enum.rs:59:42\n    |\n LL | const BAD_ENUM2_UNDEF : Enum2 = unsafe { MaybeUninit { uninit: () }.init };\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:61:1\n+  --> $DIR/ub-enum.rs:64:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -72,46 +72,46 @@ LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:78:1\n+  --> $DIR/ub-enum.rs:81:1\n    |\n LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(B)>.0: encountered a value of the never type `!`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               01                                              \u2502 .\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:80:1\n+  --> $DIR/ub-enum.rs:83:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               03                                              \u2502 .\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:88:1\n+  --> $DIR/ub-enum.rs:91:1\n    |\n LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Some)>.0.1: encountered 0xffffffff, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               78 00 00 00 ff ff ff ff                         \u2502 x.......\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:93:77\n+  --> $DIR/ub-enum.rs:96:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:95:77\n+  --> $DIR/ub-enum.rs:98:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type"}, {"sha": "8f26d9a00d71bf5dee97997dd6177e415e49ba54", "filename": "src/test/ui/consts/const-eval/ub-enum.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,4 +1,7 @@\n // stderr-per-bitwidth\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n #![feature(never_type)]\n #![allow(invalid_value)]\n "}, {"sha": "92b8d017c0b77e404b5a63a4f5166e6d1a3f1686", "filename": "src/test/ui/consts/const-eval/ub-nonnull.64bit.stderr", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -1,81 +0,0 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:12:1\n-   |\n-LL | const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               00 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-nonnull.rs:18:30\n-   |\n-LL |     let out_of_bounds_ptr = &ptr[255];\n-   |                              ^^^^^^^^ dereferencing pointer failed: alloc11 has size 1, so pointer to 256 bytes starting at offset 0 is out-of-bounds\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:22:1\n-   |\n-LL | const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               00                                              \u2502 .\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:24:1\n-   |\n-LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               00 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-nonnull.rs:32:36\n-   |\n-LL | const UNINIT: NonZeroU8 = unsafe { MaybeUninit { uninit: () }.init };\n-   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:41:1\n-   |\n-LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 42, but expected something in the range 10..=30\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               2a 00 00 00                                     \u2502 *...\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:47:1\n-   |\n-LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 20, but expected something less or equal to 10, or greater or equal to 30\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               14 00 00 00                                     \u2502 ....\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:50:1\n-   |\n-LL | const NULL_FAT_PTR: NonNull<dyn Send> = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               00 00 00 00 00 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc26\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ........\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error: aborting due to 8 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "a64b3a74cf6c0c0145165a50a3f280a88b39d4fc", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,4 +1,6 @@\n-// stderr-per-bitwidth\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n #![feature(rustc_attrs, ptr_metadata)]\n #![allow(invalid_value)] // make sure we cannot allow away the errors tested here\n "}, {"sha": "9616487080459a66e2d105c5c9ce424e8e89ae20", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "renamed", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,79 +1,79 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:12:1\n+  --> $DIR/ub-nonnull.rs:14:1\n    |\n LL | const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               00 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-nonnull.rs:18:30\n+  --> $DIR/ub-nonnull.rs:20:30\n    |\n LL |     let out_of_bounds_ptr = &ptr[255];\n    |                              ^^^^^^^^ dereferencing pointer failed: alloc11 has size 1, so pointer to 256 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:22:1\n+  --> $DIR/ub-nonnull.rs:24:1\n    |\n LL | const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               00                                              \u2502 .\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:24:1\n+  --> $DIR/ub-nonnull.rs:26:1\n    |\n LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               00 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-nonnull.rs:32:36\n+  --> $DIR/ub-nonnull.rs:34:36\n    |\n LL | const UNINIT: NonZeroU8 = unsafe { MaybeUninit { uninit: () }.init };\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:41:1\n+  --> $DIR/ub-nonnull.rs:43:1\n    |\n LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 42, but expected something in the range 10..=30\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               2a 00 00 00                                     \u2502 *...\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:47:1\n+  --> $DIR/ub-nonnull.rs:49:1\n    |\n LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 20, but expected something less or equal to 10, or greater or equal to 30\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               14 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:50:1\n+  --> $DIR/ub-nonnull.rs:52:1\n    |\n LL | const NULL_FAT_PTR: NonNull<dyn Send> = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               00 00 00 00 \u257e\u2500alloc26\u2500\u257c                         \u2502 ....\u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error: aborting due to 8 previous errors", "previous_filename": "src/test/ui/consts/const-eval/ub-nonnull.32bit.stderr"}, {"sha": "d53b44671e3f48eb53a2c6f1c3a085cb95b92d7b", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.64bit.stderr", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -1,186 +0,0 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:14:1\n-   |\n-LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned reference (required 2 byte alignment but found 1)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:18:1\n-   |\n-LL | const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned box (required 2 byte alignment but found 1)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:22:1\n-   |\n-LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null reference\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               00 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:25:1\n-   |\n-LL | const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null box\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               00 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:32:1\n-   |\n-LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:35:39\n-   |\n-LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n-   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-\n-note: erroneous constant used\n-  --> $DIR/ub-ref-ptr.rs:35:38\n-   |\n-LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n-   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:38:86\n-   |\n-LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[usize], _>(&[mem::transmute(&0)]) };\n-   |                                                                                      ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-\n-note: erroneous constant used\n-  --> $DIR/ub-ref-ptr.rs:38:85\n-   |\n-LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[usize], _>(&[mem::transmute(&0)]) };\n-   |                                                                                     ^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:41:1\n-   |\n-LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x539 is unallocated)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               39 05 00 00 00 00 00 00                         \u2502 9.......\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:44:1\n-   |\n-LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (address 0x539 is unallocated)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               39 05 00 00 00 00 00 00                         \u2502 9.......\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:47:41\n-   |\n-LL | const UNINIT_PTR: *const i32 = unsafe { MaybeUninit { uninit: () }.init };\n-   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:51:1\n-   |\n-LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a function pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               00 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:53:38\n-   |\n-LL | const UNINIT_FN_PTR: fn() = unsafe { MaybeUninit { uninit: () }.init };\n-   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:56:1\n-   |\n-LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0xd[noalloc], but expected a function pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               0d 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:58:1\n-   |\n-LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered alloc41, but expected a function pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc41\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error: accessing memory with alignment 1, but alignment 4 is required\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #68585 <https://github.com/rust-lang/rust/issues/104616>\n-note: inside `std::ptr::read::<u32>`\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-note: inside `ptr::const_ptr::<impl *const u32>::read`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `UNALIGNED_READ`\n-  --> $DIR/ub-ref-ptr.rs:65:5\n-   |\n-LL |     ptr.read();\n-   |     ^^^^^^^^^^\n-   = note: `#[deny(invalid_alignment)]` on by default\n-\n-error: aborting due to 15 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`.\n-Future incompatibility report: Future breakage diagnostic:\n-error: accessing memory with alignment 1, but alignment 4 is required\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #68585 <https://github.com/rust-lang/rust/issues/104616>\n-note: inside `std::ptr::read::<u32>`\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-note: inside `ptr::const_ptr::<impl *const u32>::read`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `UNALIGNED_READ`\n-  --> $DIR/ub-ref-ptr.rs:65:5\n-   |\n-LL |     ptr.read();\n-   |     ^^^^^^^^^^\n-   = note: `#[deny(invalid_alignment)]` on by default\n-"}, {"sha": "369e4519407fd24f647f27fe28a51195d3e2b068", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,5 +1,7 @@\n // ignore-tidy-linelength\n-// stderr-per-bitwidth\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n #![allow(invalid_value)]\n #![feature(const_ptr_read)]\n "}, {"sha": "ce618802bd2c62e1531b41b506d0fd6e0bf49d27", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.stderr", "status": "renamed", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,49 +1,49 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:14:1\n+  --> $DIR/ub-ref-ptr.rs:16:1\n    |\n LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n    | ^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned reference (required 2 byte alignment but found 1)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc3\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:18:1\n+  --> $DIR/ub-ref-ptr.rs:20:1\n    |\n LL | const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered an unaligned box (required 2 byte alignment but found 1)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc7\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:22:1\n+  --> $DIR/ub-ref-ptr.rs:24:1\n    |\n LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null reference\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               00 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:25:1\n+  --> $DIR/ub-ref-ptr.rs:27:1\n    |\n LL | const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null box\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               00 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:32:1\n+  --> $DIR/ub-ref-ptr.rs:34:1\n    |\n LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -52,7 +52,7 @@ LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:35:39\n+  --> $DIR/ub-ref-ptr.rs:37:39\n    |\n LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -61,13 +61,13 @@ LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n note: erroneous constant used\n-  --> $DIR/ub-ref-ptr.rs:35:38\n+  --> $DIR/ub-ref-ptr.rs:37:38\n    |\n LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:38:86\n+  --> $DIR/ub-ref-ptr.rs:40:86\n    |\n LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[usize], _>(&[mem::transmute(&0)]) };\n    |                                                                                      ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -76,76 +76,76 @@ LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[us\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n note: erroneous constant used\n-  --> $DIR/ub-ref-ptr.rs:38:85\n+  --> $DIR/ub-ref-ptr.rs:40:85\n    |\n LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[usize], _>(&[mem::transmute(&0)]) };\n    |                                                                                     ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:41:1\n+  --> $DIR/ub-ref-ptr.rs:43:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x539 is unallocated)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               39 05 00 00                                     \u2502 9...\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:44:1\n+  --> $DIR/ub-ref-ptr.rs:46:1\n    |\n LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (address 0x539 is unallocated)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               39 05 00 00                                     \u2502 9...\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:47:41\n+  --> $DIR/ub-ref-ptr.rs:49:41\n    |\n LL | const UNINIT_PTR: *const i32 = unsafe { MaybeUninit { uninit: () }.init };\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:51:1\n+  --> $DIR/ub-ref-ptr.rs:53:1\n    |\n LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               00 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-ref-ptr.rs:53:38\n+  --> $DIR/ub-ref-ptr.rs:55:38\n    |\n LL | const UNINIT_FN_PTR: fn() = unsafe { MaybeUninit { uninit: () }.init };\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:56:1\n+  --> $DIR/ub-ref-ptr.rs:58:1\n    |\n LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0xd[noalloc], but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               0d 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:58:1\n+  --> $DIR/ub-ref-ptr.rs:60:1\n    |\n LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered alloc41, but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc41\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error: accessing memory with alignment 1, but alignment 4 is required\n@@ -158,7 +158,7 @@ note: inside `std::ptr::read::<u32>`\n note: inside `ptr::const_ptr::<impl *const u32>::read`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n note: inside `UNALIGNED_READ`\n-  --> $DIR/ub-ref-ptr.rs:65:5\n+  --> $DIR/ub-ref-ptr.rs:67:5\n    |\n LL |     ptr.read();\n    |     ^^^^^^^^^^\n@@ -178,7 +178,7 @@ note: inside `std::ptr::read::<u32>`\n note: inside `ptr::const_ptr::<impl *const u32>::read`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n note: inside `UNALIGNED_READ`\n-  --> $DIR/ub-ref-ptr.rs:65:5\n+  --> $DIR/ub-ref-ptr.rs:67:5\n    |\n LL |     ptr.read();\n    |     ^^^^^^^^^^", "previous_filename": "src/test/ui/consts/const-eval/ub-ref-ptr.32bit.stderr"}, {"sha": "2b7659f5d107e8ab9471aa0c48dca935591fc2ce", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.64bit.stderr", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.64bit.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -1,32 +0,0 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:14:1\n-   |\n-LL | const BAD_BAD_BAD: Bar = unsafe { MaybeUninit { uninit: () }.init };\n-   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type Bar\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 0, align: 1) {}\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:17:1\n-   |\n-LL | const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to uninhabited type Bar\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               01 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:20:1\n-   |\n-LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { MaybeUninit { uninit: () }.init };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0]: encountered a value of uninhabited type Bar\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 0, align: 1) {}\n-\n-error: aborting due to 3 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "4c4ef216d8628b69a34ccd6a7b7690fe2038541b", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,4 +1,6 @@\n-// stderr-per-bitwidth\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n \n use std::mem;\n "}, {"sha": "0ae376d03fc37ee23db3f4414896ce840511eebe", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.stderr", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,31 +1,31 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:14:1\n+  --> $DIR/ub-uninhabit.rs:16:1\n    |\n LL | const BAD_BAD_BAD: Bar = unsafe { MaybeUninit { uninit: () }.init };\n    | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type Bar\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 0, align: 1) {}\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {}\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:17:1\n+  --> $DIR/ub-uninhabit.rs:19:1\n    |\n LL | const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to uninhabited type Bar\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               01 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:20:1\n+  --> $DIR/ub-uninhabit.rs:22:1\n    |\n LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { MaybeUninit { uninit: () }.init };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0]: encountered a value of uninhabited type Bar\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 0, align: 1) {}\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {}\n \n error: aborting due to 3 previous errors\n ", "previous_filename": "src/test/ui/consts/const-eval/ub-uninhabit.32bit.stderr"}, {"sha": "ab25303ddc0cf611df2a306a549d4fde936f52e0", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.64bit.stderr", "status": "removed", "additions": 0, "deletions": 297, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -1,297 +0,0 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:37:1\n-   |\n-LL | const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:39:1\n-   |\n-LL | const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid reference metadata: slice is bigger than largest supported object\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c ff ff ff ff ff ff ff ff \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:42:1\n-   |\n-LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:45:1\n-   |\n-LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:47:1\n-   |\n-LL | const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c ff ff ff ff ff ff ff ff \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:51:1\n-   |\n-LL | const STR_NO_INIT: &str = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered uninitialized data in `str`\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:54:1\n-   |\n-LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered uninitialized data in `str`\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:61:1\n-   |\n-LL | const SLICE_LENGTH_UNINIT: &[u8] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:68:1\n-   |\n-LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:71:1\n-   |\n-LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c ff ff ff ff ff ff ff 7f \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:74:1\n-   |\n-LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:77:1\n-   |\n-LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (going beyond the bounds of its allocation)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c e7 03 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:80:1\n-   |\n-LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:84:1\n-   |\n-LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x03, but expected a boolean\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:84:40\n-   |\n-LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n-   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:91:1\n-   |\n-LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered 0x03, but expected a boolean\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:91:42\n-   |\n-LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:95:1\n-   |\n-LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.1[0]: encountered 0x03, but expected a boolean\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:95:42\n-   |\n-LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:103:1\n-   |\n-LL | const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:112:1\n-   |\n-LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:116:1\n-   |\n-LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:120:1\n-   |\n-LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered 0x4[noalloc], but expected a vtable pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:123:57\n-   |\n-LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n-   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:126:57\n-   |\n-LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n-   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:129:56\n-   |\n-LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n-   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:132:1\n-   |\n-LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:137:1\n-   |\n-LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:142:1\n-   |\n-LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a vtable pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c 00 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:144:1\n-   |\n-LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a vtable pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:150:5\n-   |\n-LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer use: null pointer is a dangling pointer (it has no provenance)\n-\n-error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:154:5\n-   |\n-LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n-\n-error: aborting due to 29 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "a765dc71273d735c9c7b5cc1065f3da16d3e4339", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,10 +1,11 @@\n-// stderr-per-bitwidth\n // ignore-tidy-linelength\n #![allow(unused)]\n \n use std::mem;\n \n-// normalize-stderr-test \"\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c\" -> \"\u257eALLOC_ID$2\u257c\"\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n // normalize-stderr-test \"offset \\d+\" -> \"offset N\"\n // normalize-stderr-test \"alloc\\d+\" -> \"allocN\"\n // normalize-stderr-test \"size \\d+\" -> \"size N\""}, {"sha": "f38e7916b75530fb145380898775fe15b81076f0", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.stderr", "status": "renamed", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,27 +1,27 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:37:1\n+  --> $DIR/ub-wide-ptr.rs:38:1\n    |\n LL | const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:39:1\n+  --> $DIR/ub-wide-ptr.rs:40:1\n    |\n LL | const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid reference metadata: slice is bigger than largest supported object\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c ff ff ff ff                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:42:1\n+  --> $DIR/ub-wide-ptr.rs:43:1\n    |\n LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -30,7 +30,7 @@ LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:45:1\n+  --> $DIR/ub-wide-ptr.rs:46:1\n    |\n LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -39,68 +39,68 @@ LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:47:1\n+  --> $DIR/ub-wide-ptr.rs:48:1\n    |\n LL | const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c ff ff ff ff                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:51:1\n+  --> $DIR/ub-wide-ptr.rs:52:1\n    |\n LL | const STR_NO_INIT: &str = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered uninitialized data in `str`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:54:1\n+  --> $DIR/ub-wide-ptr.rs:55:1\n    |\n LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::<u8> { uninit: () }]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered uninitialized data in `str`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:61:1\n+  --> $DIR/ub-wide-ptr.rs:62:1\n    |\n LL | const SLICE_LENGTH_UNINIT: &[u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:68:1\n+  --> $DIR/ub-wide-ptr.rs:69:1\n    |\n LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:71:1\n+  --> $DIR/ub-wide-ptr.rs:72:1\n    |\n LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c ff ff ff 7f                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:74:1\n+  --> $DIR/ub-wide-ptr.rs:75:1\n    |\n LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -109,18 +109,18 @@ LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:77:1\n+  --> $DIR/ub-wide-ptr.rs:78:1\n    |\n LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c e7 03 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:80:1\n+  --> $DIR/ub-wide-ptr.rs:81:1\n    |\n LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -129,165 +129,165 @@ LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:84:1\n+  --> $DIR/ub-wide-ptr.rs:85:1\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:84:40\n+  --> $DIR/ub-wide-ptr.rs:85:40\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:91:1\n+  --> $DIR/ub-wide-ptr.rs:92:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:91:42\n+  --> $DIR/ub-wide-ptr.rs:92:42\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:95:1\n+  --> $DIR/ub-wide-ptr.rs:96:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.1[0]: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257eALLOC_ID\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n note: erroneous constant used\n-  --> $DIR/ub-wide-ptr.rs:95:42\n+  --> $DIR/ub-wide-ptr.rs:96:42\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:103:1\n+  --> $DIR/ub-wide-ptr.rs:104:1\n    |\n LL | const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:112:1\n+  --> $DIR/ub-wide-ptr.rs:113:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:116:1\n+  --> $DIR/ub-wide-ptr.rs:117:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:120:1\n+  --> $DIR/ub-wide-ptr.rs:121:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered 0x4[noalloc], but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:123:57\n+  --> $DIR/ub-wide-ptr.rs:124:57\n    |\n LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:126:57\n+  --> $DIR/ub-wide-ptr.rs:127:57\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:129:56\n+  --> $DIR/ub-wide-ptr.rs:130:56\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n    |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:132:1\n+  --> $DIR/ub-wide-ptr.rs:133:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:137:1\n+  --> $DIR/ub-wide-ptr.rs:138:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:142:1\n+  --> $DIR/ub-wide-ptr.rs:143:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c 00 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:144:1\n+  --> $DIR/ub-wide-ptr.rs:145:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eALLOC_ID\u257c \u257eALLOC_ID\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:150:5\n+  --> $DIR/ub-wide-ptr.rs:151:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer use: null pointer is a dangling pointer (it has no provenance)\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:154:5\n+  --> $DIR/ub-wide-ptr.rs:155:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable", "previous_filename": "src/test/ui/consts/const-eval/ub-wide-ptr.32bit.stderr"}, {"sha": "9e884ce12890b379b1c96115ddc767b05bd694b5", "filename": "src/test/ui/consts/issue-83182.64bit.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.64bit.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -1,15 +0,0 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/issue-83182.rs:5:1\n-   |\n-LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n-   |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-           }\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "b62f903bdc27071e7d47e660c6da927a08e17044", "filename": "src/test/ui/consts/issue-83182.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,4 +1,6 @@\n-// stderr-per-bitwidth\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n \n use std::mem;\n struct MyStr(str);"}, {"sha": "1d578f910c0408650bc7b4f1a144c68a6090c36d", "filename": "src/test/ui/consts/issue-83182.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,13 +1,13 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/issue-83182.rs:5:1\n+  --> $DIR/issue-83182.rs:7:1\n    |\n LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n    = help: this code performed an operation that depends on the underlying bytes representing a pointer\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500alloc4\u2500\u2500\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error: aborting due to previous error", "previous_filename": "src/test/ui/consts/issue-83182.32bit.stderr"}, {"sha": "8c83df53dade5045fe3053cdc154fcfc313b567a", "filename": "src/test/ui/consts/std/alloc.32bit.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.32bit.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,23 +1,23 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/alloc.rs:9:1\n+  --> $DIR/alloc.rs:12:1\n    |\n LL | const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .align.0.<enum-tag>: encountered 0x00000000, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               00 10 00 00 00 00 00 00                         \u2502 ........\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/alloc.rs:13:1\n+  --> $DIR/alloc.rs:16:1\n    |\n LL | const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unchecked(9, 3) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .align.0.<enum-tag>: encountered 0x00000003, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               09 00 00 00 03 00 00 00                         \u2502 ........\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error: aborting due to 2 previous errors"}, {"sha": "addedad17047a9be851b19c214554b4223fc157a", "filename": "src/test/ui/consts/std/alloc.64bit.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.64bit.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,23 +1,23 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/alloc.rs:9:1\n+  --> $DIR/alloc.rs:12:1\n    |\n LL | const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .align.0.<enum-tag>: encountered 0x0000000000000000, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/alloc.rs:13:1\n+  --> $DIR/alloc.rs:16:1\n    |\n LL | const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unchecked(9, 3) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .align.0.<enum-tag>: encountered 0x0000000000000003, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               09 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00 \u2502 ................\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error: aborting due to 2 previous errors"}, {"sha": "9abf35d63d30ac9d585603f895034d5f43827844", "filename": "src/test/ui/consts/std/alloc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,5 +1,8 @@\n // stderr-per-bitwidth\n // ignore-debug (the debug assertions change the error)\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n use std::alloc::Layout;\n \n // ok"}, {"sha": "dac4e200a89deaa30680e65f144c2750676be117", "filename": "src/test/ui/consts/validate_never_arrays.64bit.stderr", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af58fc869910eae0ec525d49cbb6d953ea10a8c6/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.64bit.stderr?ref=af58fc869910eae0ec525d49cbb6d953ea10a8c6", "patch": "@@ -1,36 +0,0 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_never_arrays.rs:4:1\n-   |\n-LL | const _: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) };\n-   | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to uninhabited type [!; 1]\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               01 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_never_arrays.rs:7:1\n-   |\n-LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 1]) };\n-   | ^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered a value of the never type `!`\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               01 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 \u2502 ................\n-           }\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_never_arrays.rs:8:1\n-   |\n-LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 42]) };\n-   | ^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered a value of the never type `!`\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               01 00 00 00 00 00 00 00 2a 00 00 00 00 00 00 00 \u2502 ........*.......\n-           }\n-\n-error: aborting due to 3 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "f96ca6839265ef2831734dada44987007daf5aaa", "filename": "src/test/ui/consts/validate_never_arrays.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,4 +1,6 @@\n-// stderr-per-bitwidth\n+// Strip out raw byte dumps to make comparison platform-independent:\n+// normalize-stderr-test \"(the raw bytes of the constant) \\(size: [0-9]*, align: [0-9]*\\)\" -> \"$1 (size: $$SIZE, align: $$ALIGN)\"\n+// normalize-stderr-test \"([0-9a-f][0-9a-f] |\u257e\u2500*a(lloc)?[0-9]+(\\+[a-z0-9]+)?\u2500*\u257c )+ *\u2502.*\" -> \"HEX_DUMP\"\n #![feature(never_type)]\n \n const _: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) }; //~ ERROR undefined behavior"}, {"sha": "12090e483a4e65f328eb763518d2086e4f8c3a32", "filename": "src/test/ui/consts/validate_never_arrays.stderr", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -1,34 +1,34 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_never_arrays.rs:4:1\n+  --> $DIR/validate_never_arrays.rs:6:1\n    |\n LL | const _: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) };\n    | ^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to uninhabited type [!; 1]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               01 00 00 00                                     \u2502 ....\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_never_arrays.rs:7:1\n+  --> $DIR/validate_never_arrays.rs:9:1\n    |\n LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 1]) };\n    | ^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered a value of the never type `!`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               01 00 00 00 01 00 00 00                         \u2502 ........\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_never_arrays.rs:8:1\n+  --> $DIR/validate_never_arrays.rs:10:1\n    |\n LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 42]) };\n    | ^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered a value of the never type `!`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               01 00 00 00 2a 00 00 00                         \u2502 ....*...\n+   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n+               HEX_DUMP\n            }\n \n error: aborting due to 3 previous errors", "previous_filename": "src/test/ui/consts/validate_never_arrays.32bit.stderr"}, {"sha": "7d2044a7da2dcf2d3ce4a5ec49131a58405ab720", "filename": "src/test/ui/error-codes/E0711.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Ferror-codes%2FE0711.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Ferror-codes%2FE0711.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0711.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,18 @@\n+// copied from: src/test/ui/feature-gates/stability-attribute-consistency.rs\n+\n+#![feature(staged_api)]\n+\n+#![stable(feature = \"stable_test_feature\", since = \"1.0.0\")]\n+\n+#[stable(feature = \"foo\", since = \"1.0.0\")]\n+fn foo_stable_1_0_0() {}\n+\n+#[stable(feature = \"foo\", since = \"1.29.0\")]\n+//~^ ERROR feature `foo` is declared stable since 1.29.0\n+fn foo_stable_1_29_0() {}\n+\n+#[unstable(feature = \"foo\", issue = \"none\")]\n+//~^ ERROR feature `foo` is declared unstable\n+fn foo_unstable() {}\n+\n+fn main() {}"}, {"sha": "f39cb4ecd4bdb5c699dde26fc64d037a920fd3f2", "filename": "src/test/ui/error-codes/E0711.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Ferror-codes%2FE0711.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Ferror-codes%2FE0711.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0711.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,15 @@\n+error[E0711]: feature `foo` is declared stable since 1.29.0, but was previously declared stable since 1.0.0\n+  --> $DIR/E0711.rs:10:1\n+   |\n+LL | #[stable(feature = \"foo\", since = \"1.29.0\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0711]: feature `foo` is declared unstable, but was previously declared stable\n+  --> $DIR/E0711.rs:14:1\n+   |\n+LL | #[unstable(feature = \"foo\", issue = \"none\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0711`."}, {"sha": "1b93d3c96376a81161b9661d2bae1557fefb233f", "filename": "src/test/ui/feature-gates/stability-attribute-consistency.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Ffeature-gates%2Fstability-attribute-consistency.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Ffeature-gates%2Fstability-attribute-consistency.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fstability-attribute-consistency.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -12,3 +12,4 @@ LL | #[unstable(feature = \"foo\", issue = \"none\")]\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0711`."}, {"sha": "b8ddebf6fb63957d4a3ae80a425b8fb2b5288beb", "filename": "src/test/ui/mismatched_types/issue-106182.fixed", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-106182.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-106182.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-106182.fixed?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+\n+struct _S(u32, Vec<i32>);\n+\n+fn _foo(x: &_S) {\n+    match x {\n+        _S(mut _y, _v) => {\n+        //~^ ERROR mismatched types [E0308]\n+        }\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "6eb6df13a028c9a567d3bc7c144fd640a7eaeb3b", "filename": "src/test/ui/mismatched_types/issue-106182.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-106182.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-106182.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-106182.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+\n+struct _S(u32, Vec<i32>);\n+\n+fn _foo(x: &_S) {\n+    match x {\n+        _S(& (mut _y), _v) => {\n+        //~^ ERROR mismatched types [E0308]\n+        }\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "ac3ab8e9895c4107a277d1af53c7d47b7263bcf3", "filename": "src/test/ui/mismatched_types/issue-106182.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-106182.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-106182.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-106182.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,18 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-106182.rs:7:12\n+   |\n+LL |     match x {\n+   |           - this expression has type `&_S`\n+LL |         _S(& (mut _y), _v) => {\n+   |            ^^^^^^^^^^ expected `u32`, found reference\n+   |\n+   = note:   expected type `u32`\n+           found reference `&_`\n+help: consider removing `&` from the pattern\n+   |\n+LL |         _S(mut _y, _v) => {\n+   |            ~~~~~~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "63eaa3930b1c3468f66ab51308c8562563c3cf51", "filename": "src/test/ui/mismatched_types/ref-pat-suggestions.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fmismatched_types%2Fref-pat-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fmismatched_types%2Fref-pat-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fref-pat-suggestions.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -336,9 +336,8 @@ LL |         let S(&mut _b) = S(0);\n    |               ^^^^^^^\n help: consider removing `&mut` from the pattern\n    |\n-LL -         let S(&mut _b) = S(0);\n-LL +         let S(_b) = S(0);\n-   |\n+LL |         let S(_b) = S(0);\n+   |               ~~\n \n error[E0308]: mismatched types\n   --> $DIR/ref-pat-suggestions.rs:31:14"}, {"sha": "89a8425f5e78a6adbd6a451d27f3d6f76fbc491b", "filename": "src/test/ui/stability-attribute/stability-attribute-sanity.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -132,5 +132,5 @@ LL | #[stable(feature = \"a\", since = \"1.0.0\")]\n \n error: aborting due to 20 previous errors\n \n-Some errors have detailed explanations: E0539, E0541, E0542, E0543, E0544, E0546, E0547, E0549.\n+Some errors have detailed explanations: E0539, E0541, E0542, E0543, E0544, E0546, E0547, E0549, E0711.\n For more information about an error, try `rustc --explain E0539`."}, {"sha": "681ce1c6e37a64d4466f82f36b2ac6d84f1efd66", "filename": "src/test/ui/suggestions/issue-105645.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fsuggestions%2Fissue-105645.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fsuggestions%2Fissue-105645.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-105645.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let mut buf = [0u8; 50];\n+    let mut bref = buf.as_slice();\n+    foo(&mut bref);\n+    //~^ ERROR 4:9: 4:18: the trait bound `&[u8]: std::io::Write` is not satisfied [E0277]\n+}\n+\n+fn foo(_: &mut impl std::io::Write) {}"}, {"sha": "895f5ffd1e1c74fba68aae7d08b32c1c0856e3b9", "filename": "src/test/ui/suggestions/issue-105645.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fsuggestions%2Fissue-105645.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fsuggestions%2Fissue-105645.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-105645.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `&[u8]: std::io::Write` is not satisfied\n+  --> $DIR/issue-105645.rs:4:9\n+   |\n+LL |     foo(&mut bref);\n+   |     --- ^^^^^^^^^ the trait `std::io::Write` is not implemented for `&[u8]`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `std::io::Write` is implemented for `&mut [u8]`\n+note: required by a bound in `foo`\n+  --> $DIR/issue-105645.rs:8:21\n+   |\n+LL | fn foo(_: &mut impl std::io::Write) {}\n+   |                     ^^^^^^^^^^^^^^ required by this bound in `foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "f9732d02cb285c57fa06dff908511071f3387a19", "filename": "src/test/ui/variance/variance-associated-consts.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-associated-consts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-associated-consts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-associated-consts.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -6,3 +6,4 @@ LL | struct Foo<T: Trait> {\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0208`."}, {"sha": "5ce62884e1d83ee15bf557e1a6271b6c6d34a753", "filename": "src/test/ui/variance/variance-associated-types.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-associated-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-associated-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-associated-types.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -12,3 +12,4 @@ LL | struct Bar<'a, T : Trait<'a>> {\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0208`."}, {"sha": "1c3c1a6d1f223ce564326a353016f169af01485d", "filename": "src/test/ui/variance/variance-object-types.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-object-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-object-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-object-types.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -6,3 +6,4 @@ LL | struct Foo<'a> {\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0208`."}, {"sha": "27d69b6e82575d319506341a2e3b9b6204e6c980", "filename": "src/test/ui/variance/variance-regions-direct.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-regions-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-regions-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-regions-direct.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -42,3 +42,4 @@ LL | enum Test8<'a, 'b, 'c:'b> {\n \n error: aborting due to 7 previous errors\n \n+For more information about this error, try `rustc --explain E0208`."}, {"sha": "535e97db3fb10fce823aa4a53d9182ba5e0fadbc", "filename": "src/test/ui/variance/variance-regions-indirect.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-regions-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-regions-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-regions-indirect.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -30,3 +30,4 @@ LL | struct Derived4<'a, 'b, 'c:'b> {\n \n error: aborting due to 5 previous errors\n \n+For more information about this error, try `rustc --explain E0208`."}, {"sha": "3f6ca62a64069776d37fb0c7e966ef9f8be3c4ab", "filename": "src/test/ui/variance/variance-trait-bounds.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-trait-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-trait-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-trait-bounds.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -24,3 +24,4 @@ LL | struct TestBox<U,T:Getter<U>+Setter<U>> {\n \n error: aborting due to 4 previous errors\n \n+For more information about this error, try `rustc --explain E0208`."}, {"sha": "9a2c924b96a9539fc07f2dde3508b91d12f09f96", "filename": "src/test/ui/variance/variance-trait-object-bound.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-trait-object-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-trait-object-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-trait-object-bound.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -6,3 +6,4 @@ LL | struct TOption<'a> {\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0208`."}, {"sha": "523763b8a07b44340cf9f47e16278a6516a74d71", "filename": "src/test/ui/variance/variance-types-bounds.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-types-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-types-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-types-bounds.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -30,3 +30,4 @@ LL | struct TestObject<A, R> {\n \n error: aborting due to 5 previous errors\n \n+For more information about this error, try `rustc --explain E0208`."}, {"sha": "5a5aaecffc5eb8d32ecb0b6b211cc25a66fbb1b4", "filename": "src/test/ui/variance/variance-types.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftest%2Fui%2Fvariance%2Fvariance-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-types.stderr?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -36,3 +36,4 @@ LL | enum Enum<A,B,C> {\n \n error: aborting due to 6 previous errors\n \n+For more information about this error, try `rustc --explain E0208`."}, {"sha": "9aacc07e0ab4fd9cee0380e7693ea76e981a0c5e", "filename": "src/tools/tidy/src/error_codes.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -27,7 +27,8 @@ const ERROR_DOCS_PATH: &str = \"compiler/rustc_error_codes/src/error_codes/\";\n const ERROR_TESTS_PATH: &str = \"src/test/ui/error-codes/\";\n \n // Error codes that (for some reason) can't have a doctest in their explanation. Error codes are still expected to provide a code example, even if untested.\n-const IGNORE_DOCTEST_CHECK: &[&str] = &[\"E0464\", \"E0570\", \"E0601\", \"E0602\"];\n+const IGNORE_DOCTEST_CHECK: &[&str] =\n+    &[\"E0208\", \"E0464\", \"E0570\", \"E0601\", \"E0602\", \"E0640\", \"E0717\"];\n \n // Error codes that don't yet have a UI test. This list will eventually be removed.\n const IGNORE_UI_TEST_CHECK: &[&str] = &[\n@@ -193,6 +194,7 @@ fn check_error_codes_docs(\n                 \"warning: Error code `{err_code}` doesn't have a code example, all error codes are expected to have one \\\n                 (even if untested).\"\n             );\n+            return;\n         }\n \n         let test_ignored = IGNORE_DOCTEST_CHECK.contains(&&err_code);"}, {"sha": "b293efdc585add09efac5a0b3d07de5d5d099b0d", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3020239de947ec52677e9b4e853a6a9fc073d1f9/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=3020239de947ec52677e9b4e853a6a9fc073d1f9", "patch": "@@ -65,6 +65,8 @@ const PROBLEMATIC_CONSTS: &[u32] = &[\n     3735927486, 3735932941, 4027431614, 4276992702,\n ];\n \n+const INTERNAL_COMPILER_DOCS_LINE: &str = \"#### This error code is internal to the compiler and will not be emitted with normal Rust code.\";\n+\n /// Parser states for `line_is_url`.\n #[derive(Clone, Copy, PartialEq)]\n #[allow(non_camel_case_types)]\n@@ -133,6 +135,8 @@ fn long_line_is_ok(extension: &str, is_error_code: bool, max_columns: usize, lin\n         \"ftl\" => true,\n         // non-error code markdown is allowed to be any length\n         \"md\" if !is_error_code => true,\n+        // HACK(Ezrashaw): there is no way to split a markdown header over multiple lines\n+        \"md\" if line == INTERNAL_COMPILER_DOCS_LINE => true,\n         _ => line_is_url(is_error_code, max_columns, line) || should_ignore(line),\n     }\n }"}]}