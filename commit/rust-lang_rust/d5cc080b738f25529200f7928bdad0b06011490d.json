{"sha": "d5cc080b738f25529200f7928bdad0b06011490d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1Y2MwODBiNzM4ZjI1NTI5MjAwZjc5MjhiZGFkMGIwNjAxMTQ5MGQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-14T23:50:33Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-14T23:50:33Z"}, "message": "typeck/expr.rs: extract out check_expr_addr_of.", "tree": {"sha": "cf62174dd1f06b98b9bf0998510c5ee44d6b4679", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf62174dd1f06b98b9bf0998510c5ee44d6b4679"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5cc080b738f25529200f7928bdad0b06011490d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5cc080b738f25529200f7928bdad0b06011490d", "html_url": "https://github.com/rust-lang/rust/commit/d5cc080b738f25529200f7928bdad0b06011490d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5cc080b738f25529200f7928bdad0b06011490d/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "840f3f64dc399021a35e4248e767e174f4852dc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/840f3f64dc399021a35e4248e767e174f4852dc4", "html_url": "https://github.com/rust-lang/rust/commit/840f3f64dc399021a35e4248e767e174f4852dc4"}], "stats": {"total": 86, "additions": 48, "deletions": 38}, "files": [{"sha": "4e6282161417b83b8e08a49237d4ae9469a0fde8", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 48, "deletions": 38, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d5cc080b738f25529200f7928bdad0b06011490d/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5cc080b738f25529200f7928bdad0b06011490d/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=d5cc080b738f25529200f7928bdad0b06011490d", "patch": "@@ -65,44 +65,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_expr_unary(unop, oprnd, expected, needs, expr)\n             }\n             ExprKind::AddrOf(mutbl, ref oprnd) => {\n-                let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n-                    match ty.sty {\n-                        ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                            if oprnd.is_place_expr() {\n-                                // Places may legitimately have unsized types.\n-                                // For example, dereferences of a fat pointer and\n-                                // the last field of a struct can be unsized.\n-                                ExpectHasType(ty)\n-                            } else {\n-                                Expectation::rvalue_hint(self, ty)\n-                            }\n-                        }\n-                        _ => NoExpectation\n-                    }\n-                });\n-                let needs = Needs::maybe_mut_place(mutbl);\n-                let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n-\n-                let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n-                if tm.ty.references_error() {\n-                    tcx.types.err\n-                } else {\n-                    // Note: at this point, we cannot say what the best lifetime\n-                    // is to use for resulting pointer.  We want to use the\n-                    // shortest lifetime possible so as to avoid spurious borrowck\n-                    // errors.  Moreover, the longest lifetime will depend on the\n-                    // precise details of the value whose address is being taken\n-                    // (and how long it is valid), which we don't know yet until type\n-                    // inference is complete.\n-                    //\n-                    // Therefore, here we simply generate a region variable.  The\n-                    // region inferencer will then select the ultimate value.\n-                    // Finally, borrowck is charged with guaranteeing that the\n-                    // value whose address was taken can actually be made to live\n-                    // as long as it needs to live.\n-                    let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n-                    tcx.mk_ref(region, tm)\n-                }\n+                self.check_expr_addr_of(mutbl, oprnd, expected, expr)\n             }\n             ExprKind::Path(ref qpath) => {\n                 let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id,\n@@ -712,4 +675,51 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         oprnd_t\n     }\n+\n+    fn check_expr_addr_of(\n+        &self,\n+        mutbl: hir::Mutability,\n+        oprnd: &'tcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+        expr: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n+            match ty.sty {\n+                ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n+                    if oprnd.is_place_expr() {\n+                        // Places may legitimately have unsized types.\n+                        // For example, dereferences of a fat pointer and\n+                        // the last field of a struct can be unsized.\n+                        ExpectHasType(ty)\n+                    } else {\n+                        Expectation::rvalue_hint(self, ty)\n+                    }\n+                }\n+                _ => NoExpectation\n+            }\n+        });\n+        let needs = Needs::maybe_mut_place(mutbl);\n+        let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n+\n+        let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n+        if tm.ty.references_error() {\n+            self.tcx.types.err\n+        } else {\n+            // Note: at this point, we cannot say what the best lifetime\n+            // is to use for resulting pointer.  We want to use the\n+            // shortest lifetime possible so as to avoid spurious borrowck\n+            // errors.  Moreover, the longest lifetime will depend on the\n+            // precise details of the value whose address is being taken\n+            // (and how long it is valid), which we don't know yet until type\n+            // inference is complete.\n+            //\n+            // Therefore, here we simply generate a region variable.  The\n+            // region inferencer will then select the ultimate value.\n+            // Finally, borrowck is charged with guaranteeing that the\n+            // value whose address was taken can actually be made to live\n+            // as long as it needs to live.\n+            let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n+            self.tcx.mk_ref(region, tm)\n+        }\n+    }\n }"}]}