{"sha": "685a434e0a4b432125feda745e4c4d034dc74245", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NWE0MzRlMGE0YjQzMjEyNWZlZGE3NDVlNGM0ZDAzNGRjNzQyNDU=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-01-31T04:27:16Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-31T22:29:11Z"}, "message": "Rename str::loop_chars to str::all,\nrename str::loop_chars_sub to str::substr_all, and\npropagate this change to std::rope and rustdoc's calls to these", "tree": {"sha": "98c67fbdadce8f60b7a579a2d05f2197ccc980dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98c67fbdadce8f60b7a579a2d05f2197ccc980dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/685a434e0a4b432125feda745e4c4d034dc74245", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/685a434e0a4b432125feda745e4c4d034dc74245", "html_url": "https://github.com/rust-lang/rust/commit/685a434e0a4b432125feda745e4c4d034dc74245", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/685a434e0a4b432125feda745e4c4d034dc74245/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be9129f556f8f43158ccac31dab50aa6b79115b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/be9129f556f8f43158ccac31dab50aa6b79115b6", "html_url": "https://github.com/rust-lang/rust/commit/be9129f556f8f43158ccac31dab50aa6b79115b6"}], "stats": {"total": 48, "additions": 11, "deletions": 37}, "files": [{"sha": "c05348b67e5232d0cb0eccf76a5b5d35a0cfb7ca", "filename": "src/libcore/str.rs", "status": "modified", "additions": 7, "deletions": 33, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/685a434e0a4b432125feda745e4c4d034dc74245/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a434e0a4b432125feda745e4c4d034dc74245/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=685a434e0a4b432125feda745e4c4d034dc74245", "patch": "@@ -60,7 +60,6 @@ export\n    hash,\n \n    // Iterating through strings\n-   loop_chars,\n    all,\n    any,\n    map,\n@@ -94,7 +93,7 @@ export\n    utf8_char_width,\n    char_range_at,\n    char_at,\n-   loop_chars_sub,\n+   substr_all,\n    escape_char,\n    as_buf,\n    //buf,\n@@ -741,7 +740,7 @@ Escapes special characters inside the string, making it safe for transfer.\n */\n fn escape(s: str) -> str {\n     let r = \"\";\n-    loop_chars(s, { |c| r += escape_char(c); true });\n+    all(s, { |c| r += escape_char(c); true });\n     r\n }\n \n@@ -781,37 +780,14 @@ fn hash(&&s: str) -> uint {\n Section: Iterating through strings\n */\n \n-/*\n-Function: loop_chars\n-\n-Loop through a string, char by char\n-\n-Parameters:\n-s  - A string to traverse. It may be empty.\n-it - A block to execute with each consecutive character of `s`.\n-Return `true` to continue, `false` to stop.\n-\n-Returns:\n-\n-`true` If execution proceeded correctly, `false` if it was interrupted,\n-that is if `it` returned `false` at any point.\n-\n-FIXME: rename to 'chars_loop' (change? currently a synonym to 'all')\n- */\n-fn loop_chars(s: str, it: fn(char) -> bool) -> bool{\n-    ret loop_chars_sub(s, 0u, byte_len(s), it);\n-}\n-\n /*\n Function: all\n \n Return true if a predicate matches all characters or\n if the string contains no characters\n-\n-// FIXME: a synonym to loop_chars\n */\n-fn all(ss: str, ff: fn(char) -> bool) -> bool {\n-    str::loop_chars(ss, ff)\n+fn all(s: str, it: fn(char) -> bool) -> bool{\n+    ret substr_all(s, 0u, byte_len(s), it);\n }\n \n /*\n@@ -1054,7 +1030,7 @@ Function: is_whitespace\n Returns true if the string contains only whitespace\n */\n fn is_whitespace(s: str) -> bool {\n-    ret loop_chars(s, char::is_whitespace);\n+    ret all(s, char::is_whitespace);\n }\n \n /*\n@@ -1270,7 +1246,7 @@ Pluck a character out of a string\n fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n \n /*\n-Function: loop_chars_sub\n+Function: substr_all\n \n Loop through a substring, char by char\n \n@@ -1290,10 +1266,8 @@ Safety note:\n - This function does not check whether the substring is valid.\n - This function fails if `byte_offset` or `byte_len` do not\n  represent valid positions inside `s`\n-\n-FIXME: rename to 'substr_all'\n  */\n-fn loop_chars_sub(s: str, byte_offset: uint, byte_len: uint,\n+fn substr_all(s: str, byte_offset: uint, byte_len: uint,\n               it: fn(char) -> bool) -> bool {\n    let i = byte_offset;\n    let result = true;"}, {"sha": "b181ba7475ca1a4f413ca1d8c4827416a0c693fb", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/685a434e0a4b432125feda745e4c4d034dc74245/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a434e0a4b432125feda745e4c4d034dc74245/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=685a434e0a4b432125feda745e4c4d034dc74245", "patch": "@@ -1137,7 +1137,7 @@ mod node {\n \n     fn loop_chars(node: @node, it: fn(char) -> bool) -> bool {\n         ret loop_leaves(node, {|leaf|\n-            ret str::loop_chars_sub(*leaf.content,\n+            ret str::substr_all(*leaf.content,\n                                     leaf.byte_offset,\n                                     leaf.byte_len, it)\n         })\n@@ -1494,4 +1494,4 @@ mod tests {\n \n         assert eq(r, r2);\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "8d6aec73300395aec477de1669516c60df8fc224", "filename": "src/rustdoc/unindent_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/685a434e0a4b432125feda745e4c4d034dc74245/src%2Frustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685a434e0a4b432125feda745e4c4d034dc74245/src%2Frustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Funindent_pass.rs?ref=685a434e0a4b432125feda745e4c4d034dc74245", "patch": "@@ -47,7 +47,7 @@ fn unindent(s: str) -> str {\n         } else {\n             saw_first_line = true;\n             let spaces = 0u;\n-            str::loop_chars(line) {|char|\n+            str::all(line) {|char|\n                 // Only comparing against space because I wouldn't\n                 // know what to do with mixed whitespace chars\n                 if char == ' ' {\n@@ -117,4 +117,4 @@ fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n     let s = \"line1\\n\\n    line2\";\n     let r = unindent(s);\n     assert r == \"line1\\n\\n    line2\";\n-}\n\\ No newline at end of file\n+}"}]}