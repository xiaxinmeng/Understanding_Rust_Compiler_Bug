{"sha": "6ff5b471ef7806c40e57b9e83107ce4d62012d1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmZjViNDcxZWY3ODA2YzQwZTU3YjllODMxMDdjZTRkNjIwMTJkMWI=", "commit": {"author": {"name": "Robert Xiao", "email": "brx@cs.ubc.ca", "date": "2021-08-13T08:03:31Z"}, "committer": {"name": "Robert Xiao", "email": "brx@cs.ubc.ca", "date": "2021-09-09T06:11:29Z"}, "message": "Fix issue #72649: avoid spurious \"previous iteration of loop\" errors.\n\nOnly follow backwards edges during get_moved_indexes if the move path is\ndefinitely initialized at loop entry. Otherwise, the error occurred prior to the\nloop, so we ignore the backwards edges to avoid generating misleading \"value\nmoved here, in previous iteration of loop\" errors.\n\nThis patch also slightly improves the analysis of inits, including\nNonPanicPathOnly initializations (which are ignored by\ndrop_flag_effects::for_location_inits). This is required for the definite\ninitialization analysis, but may also help find certain skipped reinits in rare\ncases.\n\nPatch passes all non-ignored src/test/ui testcases.", "tree": {"sha": "2040e2852b9d75d7c2b5ba50243603dd8d285705", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2040e2852b9d75d7c2b5ba50243603dd8d285705"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ff5b471ef7806c40e57b9e83107ce4d62012d1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ff5b471ef7806c40e57b9e83107ce4d62012d1b", "html_url": "https://github.com/rust-lang/rust/commit/6ff5b471ef7806c40e57b9e83107ce4d62012d1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ff5b471ef7806c40e57b9e83107ce4d62012d1b/comments", "author": {"login": "nneonneo", "id": 75449, "node_id": "MDQ6VXNlcjc1NDQ5", "avatar_url": "https://avatars.githubusercontent.com/u/75449?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nneonneo", "html_url": "https://github.com/nneonneo", "followers_url": "https://api.github.com/users/nneonneo/followers", "following_url": "https://api.github.com/users/nneonneo/following{/other_user}", "gists_url": "https://api.github.com/users/nneonneo/gists{/gist_id}", "starred_url": "https://api.github.com/users/nneonneo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nneonneo/subscriptions", "organizations_url": "https://api.github.com/users/nneonneo/orgs", "repos_url": "https://api.github.com/users/nneonneo/repos", "events_url": "https://api.github.com/users/nneonneo/events{/privacy}", "received_events_url": "https://api.github.com/users/nneonneo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nneonneo", "id": 75449, "node_id": "MDQ6VXNlcjc1NDQ5", "avatar_url": "https://avatars.githubusercontent.com/u/75449?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nneonneo", "html_url": "https://github.com/nneonneo", "followers_url": "https://api.github.com/users/nneonneo/followers", "following_url": "https://api.github.com/users/nneonneo/following{/other_user}", "gists_url": "https://api.github.com/users/nneonneo/gists{/gist_id}", "starred_url": "https://api.github.com/users/nneonneo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nneonneo/subscriptions", "organizations_url": "https://api.github.com/users/nneonneo/orgs", "repos_url": "https://api.github.com/users/nneonneo/repos", "events_url": "https://api.github.com/users/nneonneo/events{/privacy}", "received_events_url": "https://api.github.com/users/nneonneo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "626649ff1f33e89e471fff9e90bbb0a6d30141f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/626649ff1f33e89e471fff9e90bbb0a6d30141f9", "html_url": "https://github.com/rust-lang/rust/commit/626649ff1f33e89e471fff9e90bbb0a6d30141f9"}], "stats": {"total": 240, "additions": 212, "deletions": 28}, "files": [{"sha": "b69df438b61c556156c120c26aa92c31426bef14", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 80, "deletions": 28, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6ff5b471ef7806c40e57b9e83107ce4d62012d1b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ff5b471ef7806c40e57b9e83107ce4d62012d1b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=6ff5b471ef7806c40e57b9e83107ce4d62012d1b", "patch": "@@ -10,8 +10,7 @@ use rustc_middle::mir::{\n     ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, VarBindingForm,\n };\n use rustc_middle::ty::{self, suggest_constraining_type_param, Ty};\n-use rustc_mir_dataflow::drop_flag_effects;\n-use rustc_mir_dataflow::move_paths::{MoveOutIndex, MovePathIndex};\n+use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n@@ -1516,25 +1515,45 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n         }\n \n+        let mut mpis = vec![mpi];\n+        let move_paths = &self.move_data.move_paths;\n+        mpis.extend(move_paths[mpi].parents(move_paths).map(|(mpi, _)| mpi));\n+\n         let mut stack = Vec::new();\n-        stack.extend(predecessor_locations(self.body, location).map(|predecessor| {\n-            let is_back_edge = location.dominates(predecessor, &self.dominators);\n-            (predecessor, is_back_edge)\n-        }));\n+        let mut back_edge_stack = Vec::new();\n+\n+        predecessor_locations(self.body, location).for_each(|predecessor| {\n+            if location.dominates(predecessor, &self.dominators) {\n+                back_edge_stack.push(predecessor)\n+            } else {\n+                stack.push(predecessor);\n+            }\n+        });\n+\n+        let mut reached_start = false;\n+\n+        /* Check if the mpi is initialized as an argument */\n+        let mut is_argument = false;\n+        for arg in self.body.args_iter() {\n+            let path = self.move_data.rev_lookup.find_local(arg);\n+            if mpis.contains(&path) {\n+                is_argument = true;\n+            }\n+        }\n \n         let mut visited = FxHashSet::default();\n         let mut move_locations = FxHashSet::default();\n         let mut reinits = vec![];\n         let mut result = vec![];\n \n-        'dfs: while let Some((location, is_back_edge)) = stack.pop() {\n+        let mut dfs_iter = |result: &mut Vec<MoveSite>, location: Location, is_back_edge: bool| {\n             debug!(\n                 \"report_use_of_moved_or_uninitialized: (current_location={:?}, back_edge={})\",\n                 location, is_back_edge\n             );\n \n             if !visited.insert(location) {\n-                continue;\n+                return true;\n             }\n \n             // check for moves\n@@ -1553,10 +1572,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // worry about the other case: that is, if there is a move of a.b.c, it is already\n                 // marked as a move of a.b and a as well, so we will generate the correct errors\n                 // there.\n-                let mut mpis = vec![mpi];\n-                let move_paths = &self.move_data.move_paths;\n-                mpis.extend(move_paths[mpi].parents(move_paths).map(|(mpi, _)| mpi));\n-\n                 for moi in &self.move_data.loc_map[location] {\n                     debug!(\"report_use_of_moved_or_uninitialized: moi={:?}\", moi);\n                     let path = self.move_data.moves[*moi].path;\n@@ -1584,33 +1599,70 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // Because we stop the DFS here, we only highlight `let c = a`,\n                         // and not `let b = a`. We will of course also report an error at\n                         // `let c = a` which highlights `let b = a` as the move.\n-                        continue 'dfs;\n+                        return true;\n                     }\n                 }\n             }\n \n             // check for inits\n             let mut any_match = false;\n-            drop_flag_effects::for_location_inits(\n-                self.infcx.tcx,\n-                &self.body,\n-                self.move_data,\n-                location,\n-                |m| {\n-                    if m == mpi {\n-                        any_match = true;\n+            for ii in &self.move_data.init_loc_map[location] {\n+                let init = self.move_data.inits[*ii];\n+                match init.kind {\n+                    InitKind::Deep | InitKind::NonPanicPathOnly => {\n+                        if mpis.contains(&init.path) {\n+                            any_match = true;\n+                        }\n                     }\n-                },\n-            );\n+                    InitKind::Shallow => {\n+                        if mpi == init.path {\n+                            any_match = true;\n+                        }\n+                    }\n+                }\n+            }\n             if any_match {\n                 reinits.push(location);\n-                continue 'dfs;\n+                return true;\n             }\n+            return false;\n+        };\n \n-            stack.extend(predecessor_locations(self.body, location).map(|predecessor| {\n-                let back_edge = location.dominates(predecessor, &self.dominators);\n-                (predecessor, is_back_edge || back_edge)\n-            }));\n+        while let Some(location) = stack.pop() {\n+            if dfs_iter(&mut result, location, false) {\n+                continue;\n+            }\n+\n+            let mut has_predecessor = false;\n+            predecessor_locations(self.body, location).for_each(|predecessor| {\n+                if location.dominates(predecessor, &self.dominators) {\n+                    back_edge_stack.push(predecessor)\n+                } else {\n+                    stack.push(predecessor);\n+                }\n+                has_predecessor = true;\n+            });\n+\n+            if !has_predecessor {\n+                reached_start = true;\n+            }\n+        }\n+        if (is_argument || !reached_start) && result.is_empty() {\n+            /* Process back edges (moves in future loop iterations) only if\n+               the move path is definitely initialized upon loop entry,\n+               to avoid spurious \"in previous iteration\" errors.\n+               During DFS, if there's a path from the error back to the start\n+               of the function with no intervening init or move, then the\n+               move path may be uninitialized at loop entry.\n+            */\n+            while let Some(location) = back_edge_stack.pop() {\n+                if dfs_iter(&mut result, location, true) {\n+                    continue;\n+                }\n+\n+                predecessor_locations(self.body, location)\n+                    .for_each(|predecessor| back_edge_stack.push(predecessor));\n+            }\n         }\n \n         // Check if we can reach these reinits from a move location."}, {"sha": "e6bc4e22ec22c2ada1bade54a5cdd8d4e8d8ca36", "filename": "src/test/ui/moves/issue-72649-uninit-in-loop.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6ff5b471ef7806c40e57b9e83107ce4d62012d1b/src%2Ftest%2Fui%2Fmoves%2Fissue-72649-uninit-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ff5b471ef7806c40e57b9e83107ce4d62012d1b/src%2Ftest%2Fui%2Fmoves%2Fissue-72649-uninit-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fissue-72649-uninit-in-loop.rs?ref=6ff5b471ef7806c40e57b9e83107ce4d62012d1b", "patch": "@@ -0,0 +1,74 @@\n+// Regression test for issue #72649\n+// Tests that we don't emit spurious\n+// 'value moved in previous iteration of loop' message\n+\n+struct NonCopy;\n+\n+fn good() {\n+    loop {\n+        let value = NonCopy{};\n+        let _used = value;\n+    }\n+}\n+\n+fn moved_here_1() {\n+    loop {\n+        let value = NonCopy{};\n+        //~^ NOTE move occurs because `value` has type `NonCopy`, which does not implement the `Copy` trait\n+        let _used = value;\n+        //~^ NOTE value moved here\n+        let _used2 = value; //~ ERROR use of moved value: `value`\n+        //~^ NOTE value used here after move\n+    }\n+}\n+\n+fn moved_here_2() {\n+    let value = NonCopy{};\n+    //~^ NOTE move occurs because `value` has type `NonCopy`, which does not implement the `Copy` trait\n+    loop {\n+        let _used = value;\n+        //~^ NOTE value moved here\n+        loop {\n+            let _used2 = value; //~ ERROR use of moved value: `value`\n+            //~^ NOTE value used here after move\n+        }\n+    }\n+}\n+\n+fn moved_loop_1() {\n+    let value = NonCopy{};\n+    //~^ NOTE move occurs because `value` has type `NonCopy`, which does not implement the `Copy` trait\n+    loop {\n+        let _used = value; //~ ERROR use of moved value: `value`\n+        //~^ NOTE value moved here, in previous iteration of loop\n+    }\n+}\n+\n+fn moved_loop_2() {\n+    let mut value = NonCopy{};\n+    //~^ NOTE move occurs because `value` has type `NonCopy`, which does not implement the `Copy` trait\n+    let _used = value;\n+    value = NonCopy{};\n+    loop {\n+        let _used2 = value; //~ ERROR use of moved value: `value`\n+        //~^ NOTE value moved here, in previous iteration of loop\n+    }\n+}\n+\n+fn uninit_1() {\n+    loop {\n+        let value: NonCopy;\n+        let _used = value; //~ ERROR use of possibly-uninitialized variable: `value`\n+        //~^ NOTE use of possibly-uninitialized `value`\n+    }\n+}\n+\n+fn uninit_2() {\n+    let mut value: NonCopy;\n+    loop {\n+        let _used = value; //~ ERROR use of possibly-uninitialized variable: `value`\n+        //~^ NOTE use of possibly-uninitialized `value`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "076d3dff1408699dc7bc56df57f4f98d264773dd", "filename": "src/test/ui/moves/issue-72649-uninit-in-loop.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6ff5b471ef7806c40e57b9e83107ce4d62012d1b/src%2Ftest%2Fui%2Fmoves%2Fissue-72649-uninit-in-loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ff5b471ef7806c40e57b9e83107ce4d62012d1b/src%2Ftest%2Fui%2Fmoves%2Fissue-72649-uninit-in-loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fissue-72649-uninit-in-loop.stderr?ref=6ff5b471ef7806c40e57b9e83107ce4d62012d1b", "patch": "@@ -0,0 +1,58 @@\n+error[E0382]: use of moved value: `value`\n+  --> $DIR/issue-72649-uninit-in-loop.rs:20:22\n+   |\n+LL |         let value = NonCopy{};\n+   |             ----- move occurs because `value` has type `NonCopy`, which does not implement the `Copy` trait\n+LL |\n+LL |         let _used = value;\n+   |                     ----- value moved here\n+LL |\n+LL |         let _used2 = value;\n+   |                      ^^^^^ value used here after move\n+\n+error[E0382]: use of moved value: `value`\n+  --> $DIR/issue-72649-uninit-in-loop.rs:32:26\n+   |\n+LL |     let value = NonCopy{};\n+   |         ----- move occurs because `value` has type `NonCopy`, which does not implement the `Copy` trait\n+...\n+LL |         let _used = value;\n+   |                     ----- value moved here\n+...\n+LL |             let _used2 = value;\n+   |                          ^^^^^ value used here after move\n+\n+error[E0382]: use of moved value: `value`\n+  --> $DIR/issue-72649-uninit-in-loop.rs:42:21\n+   |\n+LL |     let value = NonCopy{};\n+   |         ----- move occurs because `value` has type `NonCopy`, which does not implement the `Copy` trait\n+...\n+LL |         let _used = value;\n+   |                     ^^^^^ value moved here, in previous iteration of loop\n+\n+error[E0382]: use of moved value: `value`\n+  --> $DIR/issue-72649-uninit-in-loop.rs:53:22\n+   |\n+LL |     let mut value = NonCopy{};\n+   |         --------- move occurs because `value` has type `NonCopy`, which does not implement the `Copy` trait\n+...\n+LL |         let _used2 = value;\n+   |                      ^^^^^ value moved here, in previous iteration of loop\n+\n+error[E0381]: use of possibly-uninitialized variable: `value`\n+  --> $DIR/issue-72649-uninit-in-loop.rs:61:21\n+   |\n+LL |         let _used = value;\n+   |                     ^^^^^ use of possibly-uninitialized `value`\n+\n+error[E0381]: use of possibly-uninitialized variable: `value`\n+  --> $DIR/issue-72649-uninit-in-loop.rs:69:21\n+   |\n+LL |         let _used = value;\n+   |                     ^^^^^ use of possibly-uninitialized `value`\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0381, E0382.\n+For more information about an error, try `rustc --explain E0381`."}]}