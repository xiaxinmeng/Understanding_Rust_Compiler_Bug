{"sha": "01bcb1d10eac97d27b3324125f7d5f3e0045a7ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxYmNiMWQxMGVhYzk3ZDI3YjMzMjQxMjVmN2Q1ZjNlMDA0NWE3YWI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-18T02:25:08Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-18T02:25:14Z"}, "message": "Split part of typeck.check_fn out into typeck.check_item_fn, then check all fns, including obj fns.", "tree": {"sha": "3ad7756c3d4c3d55f7e30b95c7cf5fba436baaf6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ad7756c3d4c3d55f7e30b95c7cf5fba436baaf6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01bcb1d10eac97d27b3324125f7d5f3e0045a7ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01bcb1d10eac97d27b3324125f7d5f3e0045a7ab", "html_url": "https://github.com/rust-lang/rust/commit/01bcb1d10eac97d27b3324125f7d5f3e0045a7ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01bcb1d10eac97d27b3324125f7d5f3e0045a7ab/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7210a31e2aadb8f7995326126d3411ebc19a7408", "url": "https://api.github.com/repos/rust-lang/rust/commits/7210a31e2aadb8f7995326126d3411ebc19a7408", "html_url": "https://github.com/rust-lang/rust/commit/7210a31e2aadb8f7995326126d3411ebc19a7408"}], "stats": {"total": 50, "additions": 33, "deletions": 17}, "files": [{"sha": "ad9e0b6870fe4022b32df19113774c7e0cd81a63", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/01bcb1d10eac97d27b3324125f7d5f3e0045a7ab/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bcb1d10eac97d27b3324125f7d5f3e0045a7ab/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=01bcb1d10eac97d27b3324125f7d5f3e0045a7ab", "patch": "@@ -2383,38 +2383,52 @@ fn check_const(&@crate_ctxt ccx, &span sp, ast.ident ident, @ast.ty t,\n     ret @fold.respan[ast.item_](sp, item);\n }\n \n-fn check_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n-            vec[ast.ty_param] ty_params, ast.def_id id,\n-            ast.ann ann) -> @ast.item {\n+fn check_fn(&@crate_ctxt ccx, ast.effect effect,\n+            vec[ast.arg] inputs,\n+            @ast.ty output, &ast.block body) -> ast._fn {\n     auto local_ty_table = @common.new_def_hash[@ty]();\n \n     // FIXME: duplicate work: the item annotation already has the arg types\n     // and return type translated to typeck.ty values. We don't need do to it\n     // again here, we can extract them.\n \n     // Store the type of each argument in the table.\n-    let vec[arg] inputs = vec();\n-    for (ast.arg arg in f.inputs) {\n+    for (ast.arg arg in inputs) {\n         auto input_ty = ast_ty_to_ty_crate(ccx, arg.ty);\n-        inputs += vec(rec(mode=arg.mode, ty=input_ty));\n         local_ty_table.insert(arg.id, input_ty);\n     }\n-\n-    auto output_ty = ast_ty_to_ty_crate(ccx, f.output);\n-    auto fn_sty = ty_fn(inputs, output_ty);\n-    auto fn_ann = ast.ann_type(plain_ty(fn_sty));\n-\n-    let fn_ctxt fcx = rec(ret_ty = output_ty,\n+    let fn_ctxt fcx = rec(ret_ty = ast_ty_to_ty_crate(ccx, output),\n                           locals = local_ty_table,\n                           ccx = ccx);\n \n     // TODO: Make sure the type of the block agrees with the function type.\n-    auto block_t = check_block(fcx, f.body);\n+    auto block_t = check_block(fcx, body);\n     auto block_wb = writeback(fcx, block_t);\n \n-    auto fn_t = rec(effect=f.effect, inputs=f.inputs, output=f.output,\n+    auto fn_t = rec(effect=effect, inputs=inputs, output=output,\n                     body=block_wb);\n-    auto item = ast.item_fn(ident, fn_t, ty_params, id, fn_ann);\n+    ret fn_t;\n+}\n+\n+fn check_item_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n+                 vec[ast.ty_param] ty_params, ast.def_id id,\n+                 ast.ann ann) -> @ast.item {\n+\n+    // FIXME: duplicate work: the item annotation already has the arg types\n+    // and return type translated to typeck.ty values. We don't need do to it\n+    // again here, we can extract them.\n+\n+    let vec[arg] inputs = vec();\n+    for (ast.arg arg in f.inputs) {\n+        auto input_ty = ast_ty_to_ty_crate(ccx, arg.ty);\n+        inputs += vec(rec(mode=arg.mode, ty=input_ty));\n+    }\n+\n+    auto output_ty = ast_ty_to_ty_crate(ccx, f.output);\n+    auto fn_sty = ty_fn(inputs, output_ty);\n+    auto fn_ann = ast.ann_type(plain_ty(fn_sty));\n+\n+    auto item = ast.item_fn(ident, f, ty_params, id, fn_ann);\n     ret @fold.respan[ast.item_](sp, item);\n }\n \n@@ -2424,8 +2438,10 @@ fn check_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n     auto ccx = @rec(sess=sess, item_types=result._1, mutable next_var_id=0);\n \n     auto fld = fold.new_identity_fold[@crate_ctxt]();\n-    auto f = check_fn;  // FIXME: trans_const_lval bug\n-    fld = @rec(fold_item_fn = f with *fld);\n+\n+    fld = @rec(fold_fn      = bind check_fn(_,_,_,_,_),\n+               fold_item_fn = bind check_item_fn(_,_,_,_,_,_,_)\n+               with *fld);\n     ret fold.fold_crate[@crate_ctxt](ccx, fld, result._0);\n }\n "}]}