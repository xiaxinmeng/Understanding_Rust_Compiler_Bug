{"sha": "69a0e1af9553ad50ee2d9c9176470ddeef70717c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5YTBlMWFmOTU1M2FkNTBlZTJkOWM5MTc2NDcwZGRlZWY3MDcxN2M=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-05-27T06:47:03Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-05-29T03:03:20Z"}, "message": "Implement RFC 1047 - socket timeouts\n\nCloses #25619", "tree": {"sha": "96d0888e821b7787c5387b1c1c55a162c07f9be7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96d0888e821b7787c5387b1c1c55a162c07f9be7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69a0e1af9553ad50ee2d9c9176470ddeef70717c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69a0e1af9553ad50ee2d9c9176470ddeef70717c", "html_url": "https://github.com/rust-lang/rust/commit/69a0e1af9553ad50ee2d9c9176470ddeef70717c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69a0e1af9553ad50ee2d9c9176470ddeef70717c/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a3cffbddfa21aac6fabd2f07f86703fbf1f26a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a3cffbddfa21aac6fabd2f07f86703fbf1f26a5", "html_url": "https://github.com/rust-lang/rust/commit/1a3cffbddfa21aac6fabd2f07f86703fbf1f26a5"}], "stats": {"total": 331, "additions": 324, "deletions": 7}, "files": [{"sha": "a0169ae000b3dc4bad98df7752246b5a9ea32f1e", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/69a0e1af9553ad50ee2d9c9176470ddeef70717c/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a0e1af9553ad50ee2d9c9176470ddeef70717c/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=69a0e1af9553ad50ee2d9c9176470ddeef70717c", "patch": "@@ -19,6 +19,7 @@ use io;\n use net::{ToSocketAddrs, SocketAddr, Shutdown};\n use sys_common::net as net_imp;\n use sys_common::{AsInner, FromInner};\n+use time::Duration;\n \n /// A structure which represents a TCP stream between a local socket and a\n /// remote socket.\n@@ -139,6 +140,50 @@ impl TcpStream {\n     pub fn set_keepalive(&self, seconds: Option<u32>) -> io::Result<()> {\n         self.0.set_keepalive(seconds)\n     }\n+\n+    /// Sets the read timeout to the timeout specified.\n+    ///\n+    /// If the value specified is `None`, then `read` calls will block\n+    /// indefinitely. It is an error to pass the zero `Duration` to this\n+    /// method.\n+    #[unstable(feature = \"socket_timeout\", reason = \"RFC 1047 - recently added\")]\n+    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n+        self.0.set_read_timeout(dur)\n+    }\n+\n+    /// Sets the write timeout to the timeout specified.\n+    ///\n+    /// If the value specified is `None`, then `write` calls will block\n+    /// indefinitely. It is an error to pass the zero `Duration` to this\n+    /// method.\n+    #[unstable(feature = \"socket_timeout\", reason = \"RFC 1047 - recently added\")]\n+    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n+        self.0.set_write_timeout(dur)\n+    }\n+\n+    /// Returns the read timeout of this socket.\n+    ///\n+    /// If the timeout is `None`, then `read` calls will block indefinitely.\n+    ///\n+    /// # Note\n+    ///\n+    /// Some platforms do not provide access to the current timeout.\n+    #[unstable(feature = \"socket_timeout\", reason = \"RFC 1047 - recently added\")]\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.read_timeout()\n+    }\n+\n+    /// Returns the write timeout of this socket.\n+    ///\n+    /// If the timeout is `None`, then `write` calls will block indefinitely.\n+    ///\n+    /// # Note\n+    ///\n+    /// Some platforms do not provide access to the current timeout.\n+    #[unstable(feature = \"socket_timeout\", reason = \"RFC 1047 - recently added\")]\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.write_timeout()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -262,6 +307,7 @@ mod tests {\n     use net::test::{next_test_ip4, next_test_ip6};\n     use sync::mpsc::channel;\n     use sys_common::AsInner;\n+    use time::Duration;\n     use thread;\n \n     fn each_ip(f: &mut FnMut(SocketAddr)) {\n@@ -855,4 +901,69 @@ mod tests {\n                               stream_inner);\n         assert_eq!(format!(\"{:?}\", stream), compare);\n     }\n+\n+    #[test]\n+    fn timeouts() {\n+        let addr = next_test_ip4();\n+        let listener = t!(TcpListener::bind(&addr));\n+\n+        let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+        let dur = Duration::new(15410, 0);\n+\n+        assert_eq!(None, t!(stream.read_timeout()));\n+\n+        t!(stream.set_read_timeout(Some(dur)));\n+        assert_eq!(Some(dur), t!(stream.read_timeout()));\n+\n+        assert_eq!(None, t!(stream.write_timeout()));\n+\n+        t!(stream.set_write_timeout(Some(dur)));\n+        assert_eq!(Some(dur), t!(stream.write_timeout()));\n+\n+        t!(stream.set_read_timeout(None));\n+        assert_eq!(None, t!(stream.read_timeout()));\n+\n+        t!(stream.set_write_timeout(None));\n+        assert_eq!(None, t!(stream.write_timeout()));\n+    }\n+\n+    #[test]\n+    fn test_read_timeout() {\n+        let addr = next_test_ip4();\n+        let listener = t!(TcpListener::bind(&addr));\n+\n+        let mut stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+        t!(stream.set_read_timeout(Some(Duration::from_millis(10))));\n+\n+        let mut buf = [0; 10];\n+        let wait = Duration::span(|| {\n+            let kind = stream.read(&mut buf).err().expect(\"expected error\").kind();\n+            assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut);\n+        });\n+        assert!(wait > Duration::from_millis(5));\n+        assert!(wait < Duration::from_millis(15));\n+    }\n+\n+    #[test]\n+    fn test_read_with_timeout() {\n+        let addr = next_test_ip4();\n+        let listener = t!(TcpListener::bind(&addr));\n+\n+        let mut stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+        t!(stream.set_read_timeout(Some(Duration::from_millis(10))));\n+\n+        let mut other_end = t!(listener.accept()).0;\n+        t!(other_end.write_all(b\"hello world\"));\n+\n+        let mut buf = [0; 11];\n+        t!(stream.read(&mut buf));\n+        assert_eq!(b\"hello world\", &buf[..]);\n+\n+        let wait = Duration::span(|| {\n+            let kind = stream.read(&mut buf).err().expect(\"expected error\").kind();\n+            assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut);\n+        });\n+        assert!(wait > Duration::from_millis(5));\n+        assert!(wait < Duration::from_millis(15));\n+    }\n }"}, {"sha": "e078f4cd44f3ac09fa3c63017cae47fb1e034241", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/69a0e1af9553ad50ee2d9c9176470ddeef70717c/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a0e1af9553ad50ee2d9c9176470ddeef70717c/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=69a0e1af9553ad50ee2d9c9176470ddeef70717c", "patch": "@@ -18,6 +18,7 @@ use io::{self, Error, ErrorKind};\n use net::{ToSocketAddrs, SocketAddr, IpAddr};\n use sys_common::net as net_imp;\n use sys_common::{AsInner, FromInner};\n+use time::Duration;\n \n /// A User Datagram Protocol socket.\n ///\n@@ -127,6 +128,42 @@ impl UdpSocket {\n     pub fn set_time_to_live(&self, ttl: i32) -> io::Result<()> {\n         self.0.time_to_live(ttl)\n     }\n+\n+    /// Sets the read timeout to the timeout specified.\n+    ///\n+    /// If the value specified is `None`, then `read` calls will block\n+    /// indefinitely. It is an error to pass the zero `Duration` to this\n+    /// method.\n+    #[unstable(feature = \"socket_timeout\", reason = \"RFC 1047 - recently added\")]\n+    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n+        self.0.set_read_timeout(dur)\n+    }\n+\n+    /// Sets the write timeout to the timeout specified.\n+    ///\n+    /// If the value specified is `None`, then `write` calls will block\n+    /// indefinitely. It is an error to pass the zero `Duration` to this\n+    /// method.\n+    #[unstable(feature = \"socket_timeout\", reason = \"RFC 1047 - recently added\")]\n+    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n+        self.0.set_write_timeout(dur)\n+    }\n+\n+    /// Returns the read timeout of this socket.\n+    ///\n+    /// If the timeout is `None`, then `read` calls will block indefinitely.\n+    #[unstable(feature = \"socket_timeout\", reason = \"RFC 1047 - recently added\")]\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.read_timeout()\n+    }\n+\n+    /// Returns the write timeout of this socket.\n+    ///\n+    /// If the timeout is `None`, then `write` calls will block indefinitely.\n+    #[unstable(feature = \"socket_timeout\", reason = \"RFC 1047 - recently added\")]\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.write_timeout()\n+    }\n }\n \n impl AsInner<net_imp::UdpSocket> for UdpSocket {\n@@ -152,6 +189,7 @@ mod tests {\n     use net::test::{next_test_ip4, next_test_ip6};\n     use sync::mpsc::channel;\n     use sys_common::AsInner;\n+    use time::Duration;\n     use thread;\n \n     fn each_ip(f: &mut FnMut(SocketAddr, SocketAddr)) {\n@@ -321,4 +359,65 @@ mod tests {\n                               socket_addr, name, udpsock_inner);\n         assert_eq!(format!(\"{:?}\", udpsock), compare);\n     }\n+\n+    #[test]\n+    fn timeouts() {\n+        let addr = next_test_ip4();\n+\n+        let stream = t!(UdpSocket::bind(&addr));\n+        let dur = Duration::new(15410, 0);\n+\n+        assert_eq!(None, t!(stream.read_timeout()));\n+\n+        t!(stream.set_read_timeout(Some(dur)));\n+        assert_eq!(Some(dur), t!(stream.read_timeout()));\n+\n+        assert_eq!(None, t!(stream.write_timeout()));\n+\n+        t!(stream.set_write_timeout(Some(dur)));\n+        assert_eq!(Some(dur), t!(stream.write_timeout()));\n+\n+        t!(stream.set_read_timeout(None));\n+        assert_eq!(None, t!(stream.read_timeout()));\n+\n+        t!(stream.set_write_timeout(None));\n+        assert_eq!(None, t!(stream.write_timeout()));\n+    }\n+\n+    #[test]\n+    fn test_read_timeout() {\n+        let addr = next_test_ip4();\n+\n+        let mut stream = t!(UdpSocket::bind(&addr));\n+        t!(stream.set_read_timeout(Some(Duration::from_millis(10))));\n+\n+        let mut buf = [0; 10];\n+        let wait = Duration::span(|| {\n+            let kind = stream.recv_from(&mut buf).err().expect(\"expected error\").kind();\n+            assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut);\n+        });\n+        assert!(wait > Duration::from_millis(5));\n+        assert!(wait < Duration::from_millis(15));\n+    }\n+\n+    #[test]\n+    fn test_read_with_timeout() {\n+        let addr = next_test_ip4();\n+\n+        let mut stream = t!(UdpSocket::bind(&addr));\n+        t!(stream.set_read_timeout(Some(Duration::from_millis(10))));\n+\n+        t!(stream.send_to(b\"hello world\", &addr));\n+\n+        let mut buf = [0; 11];\n+        t!(stream.recv_from(&mut buf));\n+        assert_eq!(b\"hello world\", &buf[..]);\n+\n+        let wait = Duration::span(|| {\n+            let kind = stream.recv_from(&mut buf).err().expect(\"expected error\").kind();\n+            assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut);\n+        });\n+        assert!(wait > Duration::from_millis(5));\n+        assert!(wait < Duration::from_millis(15));\n+    }\n }"}, {"sha": "5890e6a78892c0ae6f931066bd58a4184b6ede46", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/69a0e1af9553ad50ee2d9c9176470ddeef70717c/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a0e1af9553ad50ee2d9c9176470ddeef70717c/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=69a0e1af9553ad50ee2d9c9176470ddeef70717c", "patch": "@@ -20,12 +20,13 @@ use str::from_utf8;\n use sys::c;\n use sys::net::{cvt, cvt_r, cvt_gai, Socket, init, wrlen_t};\n use sys_common::{AsInner, FromInner, IntoInner};\n+use time::Duration;\n \n ////////////////////////////////////////////////////////////////////////////////\n // sockaddr and misc bindings\n ////////////////////////////////////////////////////////////////////////////////\n \n-fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int,\n+pub fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int,\n                      payload: T) -> io::Result<()> {\n     unsafe {\n         let payload = &payload as *const T as *const c_void;\n@@ -35,16 +36,15 @@ fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int,\n     }\n }\n \n-#[allow(dead_code)]\n-fn getsockopt<T: Copy>(sock: &Socket, opt: c_int,\n+pub fn getsockopt<T: Copy>(sock: &Socket, opt: c_int,\n                        val: c_int) -> io::Result<T> {\n     unsafe {\n         let mut slot: T = mem::zeroed();\n         let mut len = mem::size_of::<T>() as socklen_t;\n-        let ret = try!(cvt(c::getsockopt(*sock.as_inner(), opt, val,\n-                                         &mut slot as *mut _ as *mut _,\n-                                         &mut len)));\n-        assert_eq!(ret as usize, mem::size_of::<T>());\n+        try!(cvt(c::getsockopt(*sock.as_inner(), opt, val,\n+                               &mut slot as *mut _ as *mut _,\n+                               &mut len)));\n+        assert_eq!(len as usize, mem::size_of::<T>());\n         Ok(slot)\n     }\n }\n@@ -220,6 +220,22 @@ impl TcpStream {\n         Ok(())\n     }\n \n+    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n+        self.inner.set_timeout(dur, libc::SO_RCVTIMEO)\n+    }\n+\n+    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n+        self.inner.set_timeout(dur, libc::SO_SNDTIMEO)\n+    }\n+\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.inner.timeout(libc::SO_RCVTIMEO)\n+    }\n+\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.inner.timeout(libc::SO_SNDTIMEO)\n+    }\n+\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n@@ -471,6 +487,22 @@ impl UdpSocket {\n     pub fn duplicate(&self) -> io::Result<UdpSocket> {\n         self.inner.duplicate().map(|s| UdpSocket { inner: s })\n     }\n+\n+    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n+        self.inner.set_timeout(dur, libc::SO_RCVTIMEO)\n+    }\n+\n+    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n+        self.inner.set_timeout(dur, libc::SO_SNDTIMEO)\n+    }\n+\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.inner.timeout(libc::SO_RCVTIMEO)\n+    }\n+\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.inner.timeout(libc::SO_SNDTIMEO)\n+    }\n }\n \n impl FromInner<Socket> for UdpSocket {"}, {"sha": "1f40c18be2f107b3d106701e9b3b40e9dea8944c", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/69a0e1af9553ad50ee2d9c9176470ddeef70717c/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a0e1af9553ad50ee2d9c9176470ddeef70717c/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=69a0e1af9553ad50ee2d9c9176470ddeef70717c", "patch": "@@ -18,6 +18,8 @@ use sys::c;\n use net::SocketAddr;\n use sys::fd::FileDesc;\n use sys_common::{AsInner, FromInner};\n+use sys_common::net::{getsockopt, setsockopt};\n+use time::Duration;\n \n pub use sys::{cvt, cvt_r};\n \n@@ -73,6 +75,49 @@ impl Socket {\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.0.read(buf)\n     }\n+\n+    pub fn set_timeout(&self, dur: Option<Duration>, kind: libc::c_int) -> io::Result<()> {\n+        let timeout = match dur {\n+            Some(dur) => {\n+                if dur.secs() == 0 && dur.extra_nanos() == 0 {\n+                    return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                              \"cannot set a 0 duration timeout\"));\n+                }\n+\n+                let secs = if dur.secs() > libc::time_t::max_value() as u64 {\n+                    libc::time_t::max_value()\n+                } else {\n+                    dur.secs() as libc::time_t\n+                };\n+                let mut timeout = libc::timeval {\n+                    tv_sec: secs,\n+                    tv_usec: (dur.extra_nanos() / 1000) as libc::suseconds_t,\n+                };\n+                if timeout.tv_sec == 0 && timeout.tv_usec == 0 {\n+                    timeout.tv_usec = 1;\n+                }\n+                timeout\n+            }\n+            None => {\n+                libc::timeval {\n+                    tv_sec: 0,\n+                    tv_usec: 0,\n+                }\n+            }\n+        };\n+        setsockopt(self, libc::SOL_SOCKET, kind, timeout)\n+    }\n+\n+    pub fn timeout(&self, kind: libc::c_int) -> io::Result<Option<Duration>> {\n+        let raw: libc::timeval = try!(getsockopt(self, libc::SOL_SOCKET, kind));\n+        if raw.tv_sec == 0 && raw.tv_usec == 0 {\n+            Ok(None)\n+        } else {\n+            let sec = raw.tv_sec as u64;\n+            let nsec = (raw.tv_usec as u32) * 1000;\n+            Ok(Some(Duration::new(sec, nsec)))\n+        }\n+    }\n }\n \n impl AsInner<c_int> for Socket {"}, {"sha": "18c8add17a6d6d307103d93e6e00ac4c3805008d", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69a0e1af9553ad50ee2d9c9176470ddeef70717c/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a0e1af9553ad50ee2d9c9176470ddeef70717c/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=69a0e1af9553ad50ee2d9c9176470ddeef70717c", "patch": "@@ -60,6 +60,7 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n         libc::WSAEINVAL => ErrorKind::InvalidInput,\n         libc::WSAENOTCONN => ErrorKind::NotConnected,\n         libc::WSAEWOULDBLOCK => ErrorKind::WouldBlock,\n+        libc::WSAETIMEDOUT => ErrorKind::TimedOut,\n \n         _ => ErrorKind::Other,\n     }"}, {"sha": "0b9052672369d40da703be63f36969d1b39d45e9", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/69a0e1af9553ad50ee2d9c9176470ddeef70717c/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a0e1af9553ad50ee2d9c9176470ddeef70717c/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=69a0e1af9553ad50ee2d9c9176470ddeef70717c", "patch": "@@ -19,8 +19,11 @@ use num::One;\n use ops::Neg;\n use rt;\n use sync::Once;\n+use sys;\n use sys::c;\n use sys_common::{AsInner, FromInner};\n+use sys_common::net::{setsockopt, getsockopt};\n+use time::Duration;\n \n pub type wrlen_t = i32;\n \n@@ -127,6 +130,32 @@ impl Socket {\n             }\n         }\n     }\n+\n+    pub fn set_timeout(&self, dur: Option<Duration>, kind: libc::c_int) -> io::Result<()> {\n+        let timeout = match dur {\n+            Some(dur) => {\n+                let timeout = sys::dur2timeout(dur);\n+                if timeout == 0 {\n+                    return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                              \"cannot set a 0 duration timeout\"));\n+                }\n+                timeout\n+            }\n+            None => 0\n+        };\n+        setsockopt(self, libc::SOL_SOCKET, kind, timeout)\n+    }\n+\n+    pub fn timeout(&self, kind: libc::c_int) -> io::Result<Option<Duration>> {\n+        let raw: libc::DWORD = try!(getsockopt(self, libc::SOL_SOCKET, kind));\n+        if raw == 0 {\n+            Ok(None)\n+        } else {\n+            let secs = raw / 1000;\n+            let nsec = (raw % 1000) * 1000000;\n+            Ok(Some(Duration::new(secs as u64, nsec as u32)))\n+        }\n+    }\n }\n \n impl Drop for Socket {"}]}