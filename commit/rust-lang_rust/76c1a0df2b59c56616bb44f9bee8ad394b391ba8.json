{"sha": "76c1a0df2b59c56616bb44f9bee8ad394b391ba8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YzFhMGRmMmI1OWM1NjYxNmJiNDRmOWJlZThhZDM5NGIzOTFiYTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-15T02:14:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-15T02:14:21Z"}, "message": "Auto merge of #32317 - taralx:master, r=alexcrichton\n\nDeduplicate libraries on hash instead of filename.\n\nRemoves the need for canonicalization to prevent #12459.\n\n(Now with passing tests!)\n\nCanonicalization breaks certain environments where the libraries are symlinks to files that don't end in .rlib (e.g. /remote/cas/$HASH).", "tree": {"sha": "855760b2b52e76dfe71798428ad664d781ae522a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/855760b2b52e76dfe71798428ad664d781ae522a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76c1a0df2b59c56616bb44f9bee8ad394b391ba8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76c1a0df2b59c56616bb44f9bee8ad394b391ba8", "html_url": "https://github.com/rust-lang/rust/commit/76c1a0df2b59c56616bb44f9bee8ad394b391ba8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76c1a0df2b59c56616bb44f9bee8ad394b391ba8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2174bd97c1458d89a87eb2b614135d7ad68d6f18", "url": "https://api.github.com/repos/rust-lang/rust/commits/2174bd97c1458d89a87eb2b614135d7ad68d6f18", "html_url": "https://github.com/rust-lang/rust/commit/2174bd97c1458d89a87eb2b614135d7ad68d6f18"}, {"sha": "2218245a6dd8be002f5ebe2ec724568982bd44b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2218245a6dd8be002f5ebe2ec724568982bd44b2", "html_url": "https://github.com/rust-lang/rust/commit/2218245a6dd8be002f5ebe2ec724568982bd44b2"}], "stats": {"total": 148, "additions": 84, "deletions": 64}, "files": [{"sha": "1536f884b0981fc120dc97c243a3fcdae37a7b9f", "filename": "src/librustc/hir/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76c1a0df2b59c56616bb44f9bee8ad394b391ba8/src%2Flibrustc%2Fhir%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c1a0df2b59c56616bb44f9bee8ad394b391ba8/src%2Flibrustc%2Fhir%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fsvh.rs?ref=76c1a0df2b59c56616bb44f9bee8ad394b391ba8", "patch": "@@ -48,7 +48,7 @@\n \n use std::fmt;\n \n-#[derive(Clone, PartialEq, Debug)]\n+#[derive(Clone, Eq, Hash, PartialEq, Debug)]\n pub struct Svh {\n     hash: String,\n }"}, {"sha": "28e0e5746a3ee2ef4ce19cda32b23491799793b0", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 43, "deletions": 55, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/76c1a0df2b59c56616bb44f9bee8ad394b391ba8/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c1a0df2b59c56616bb44f9bee8ad394b391ba8/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=76c1a0df2b59c56616bb44f9bee8ad394b391ba8", "patch": "@@ -470,20 +470,17 @@ impl<'a> Context<'a> {\n         // A Library candidate is created if the metadata for the set of\n         // libraries corresponds to the crate id and hash criteria that this\n         // search is being performed for.\n-        let mut libraries = Vec::new();\n+        let mut libraries = HashMap::new();\n         for (_hash, (rlibs, dylibs)) in candidates {\n-            let mut metadata = None;\n-            let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut metadata);\n-            let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut metadata);\n-            match metadata {\n-                Some(metadata) => {\n-                    libraries.push(Library {\n-                        dylib: dylib,\n-                        rlib: rlib,\n-                        metadata: metadata,\n-                    })\n-                }\n-                None => {}\n+            let mut slot = None;\n+            let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n+            let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n+            if let Some((h, m)) = slot {\n+                libraries.insert(h, Library {\n+                    dylib: dylib,\n+                    rlib: rlib,\n+                    metadata: m,\n+                });\n             }\n         }\n \n@@ -492,13 +489,13 @@ impl<'a> Context<'a> {\n         // libraries or not.\n         match libraries.len() {\n             0 => None,\n-            1 => Some(libraries.into_iter().next().unwrap()),\n+            1 => Some(libraries.into_iter().next().unwrap().1),\n             _ => {\n                 let mut err = struct_span_err!(self.sess, self.span, E0464,\n                                                \"multiple matching crates for `{}`\",\n                                                self.crate_name);\n                 err.note(\"candidates:\");\n-                for lib in &libraries {\n+                for (_, lib) in libraries {\n                     match lib.dylib {\n                         Some((ref p, _)) => {\n                             err.note(&format!(\"path: {}\",\n@@ -532,13 +529,13 @@ impl<'a> Context<'a> {\n     // be read, it is assumed that the file isn't a valid rust library (no\n     // errors are emitted).\n     fn extract_one(&mut self, m: HashMap<PathBuf, PathKind>, flavor: CrateFlavor,\n-                   slot: &mut Option<MetadataBlob>) -> Option<(PathBuf, PathKind)> {\n-        let mut ret = None::<(PathBuf, PathKind)>;\n+                   slot: &mut Option<(Svh, MetadataBlob)>) -> Option<(PathBuf, PathKind)> {\n+        let mut ret: Option<(PathBuf, PathKind)> = None;\n         let mut error = 0;\n \n         if slot.is_some() {\n             // FIXME(#10786): for an optimization, we only read one of the\n-            //                library's metadata sections. In theory we should\n+            //                libraries' metadata sections. In theory we should\n             //                read both, but reading dylib metadata is quite\n             //                slow.\n             if m.is_empty() {\n@@ -551,10 +548,10 @@ impl<'a> Context<'a> {\n         let mut err: Option<DiagnosticBuilder> = None;\n         for (lib, kind) in m {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n-            let metadata = match get_metadata_section(self.target, flavor, &lib) {\n+            let (hash, metadata) = match get_metadata_section(self.target, flavor, &lib) {\n                 Ok(blob) => {\n-                    if self.crate_matches(blob.as_slice(), &lib) {\n-                        blob\n+                    if let Some(h) = self.crate_matches(blob.as_slice(), &lib) {\n+                        (h, blob)\n                     } else {\n                         info!(\"metadata mismatch\");\n                         continue\n@@ -565,12 +562,8 @@ impl<'a> Context<'a> {\n                     continue\n                 }\n             };\n-            // If we've already found a candidate and we're not matching hashes,\n-            // emit an error about duplicate candidates found. If we're matching\n-            // based on a hash, however, then if we've gotten this far both\n-            // candidates have the same hash, so they're not actually\n-            // duplicates that we should warn about.\n-            if ret.is_some() && self.hash.is_none() {\n+            // If we see multiple hashes, emit an error about duplicate candidates.\n+            if slot.as_ref().map_or(false, |s| s.0 != hash) {\n                 let mut e = struct_span_err!(self.sess, self.span, E0465,\n                                              \"multiple {} candidates for `{}` found\",\n                                              flavor, self.crate_name);\n@@ -583,7 +576,7 @@ impl<'a> Context<'a> {\n                 }\n                 err = Some(e);\n                 error = 1;\n-                ret = None;\n+                *slot = None;\n             }\n             if error > 0 {\n                 error += 1;\n@@ -592,7 +585,7 @@ impl<'a> Context<'a> {\n                                                          lib.display()));\n                 continue\n             }\n-            *slot = Some(metadata);\n+            *slot = Some((hash, metadata));\n             ret = Some((lib, kind));\n         }\n \n@@ -604,22 +597,20 @@ impl<'a> Context<'a> {\n         }\n     }\n \n-    fn crate_matches(&mut self, crate_data: &[u8], libpath: &Path) -> bool {\n+    fn crate_matches(&mut self, crate_data: &[u8], libpath: &Path) -> Option<Svh> {\n         if self.should_match_name {\n             match decoder::maybe_get_crate_name(crate_data) {\n                 Some(ref name) if self.crate_name == *name => {}\n-                _ => { info!(\"Rejecting via crate name\"); return false }\n+                _ => { info!(\"Rejecting via crate name\"); return None }\n             }\n         }\n         let hash = match decoder::maybe_get_crate_hash(crate_data) {\n-            Some(hash) => hash, None => {\n-                info!(\"Rejecting via lack of crate hash\");\n-                return false;\n-            }\n+            None => { info!(\"Rejecting via lack of crate hash\"); return None; }\n+            Some(h) => h,\n         };\n \n         let triple = match decoder::get_crate_triple(crate_data) {\n-            None => { debug!(\"triple not present\"); return false }\n+            None => { debug!(\"triple not present\"); return None }\n             Some(t) => t,\n         };\n         if triple != self.triple {\n@@ -628,24 +619,21 @@ impl<'a> Context<'a> {\n                 path: libpath.to_path_buf(),\n                 got: triple.to_string()\n             });\n-            return false;\n+            return None;\n         }\n \n-        match self.hash {\n-            None => true,\n-            Some(myhash) => {\n-                if *myhash != hash {\n-                    info!(\"Rejecting via hash: expected {} got {}\", *myhash, hash);\n-                    self.rejected_via_hash.push(CrateMismatch {\n-                        path: libpath.to_path_buf(),\n-                        got: myhash.as_str().to_string()\n-                    });\n-                    false\n-                } else {\n-                    true\n-                }\n+        if let Some(myhash) = self.hash {\n+            if *myhash != hash {\n+                info!(\"Rejecting via hash: expected {} got {}\", *myhash, hash);\n+                self.rejected_via_hash.push(CrateMismatch {\n+                    path: libpath.to_path_buf(),\n+                    got: myhash.as_str().to_string()\n+                });\n+                return None;\n             }\n         }\n+\n+        Some(hash)\n     }\n \n \n@@ -717,13 +705,13 @@ impl<'a> Context<'a> {\n         };\n \n         // Extract the rlib/dylib pair.\n-        let mut metadata = None;\n-        let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut metadata);\n-        let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut metadata);\n+        let mut slot = None;\n+        let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n+        let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n \n         if rlib.is_none() && dylib.is_none() { return None }\n-        match metadata {\n-            Some(metadata) => Some(Library {\n+        match slot {\n+            Some((_, metadata)) => Some(Library {\n                 dylib: dylib,\n                 rlib: rlib,\n                 metadata: metadata,"}, {"sha": "e22b937a0876345c05330fe24b59bff19ca8fba2", "filename": "src/test/run-make/compiler-lookup-paths/Makefile", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76c1a0df2b59c56616bb44f9bee8ad394b391ba8/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/76c1a0df2b59c56616bb44f9bee8ad394b391ba8/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths%2FMakefile?ref=76c1a0df2b59c56616bb44f9bee8ad394b391ba8", "patch": "@@ -18,13 +18,21 @@ all: $(TMPDIR)/libnative.a\n \t$(RUSTC) d.rs -L crate=$(TMPDIR)/native && exit 1 || exit 0\n \t$(RUSTC) d.rs -L native=$(TMPDIR)/native\n \t$(RUSTC) d.rs -L all=$(TMPDIR)/native\n+\t# Deduplication tests:\n+\t#   Same hash, no errors.\n \tmkdir -p $(TMPDIR)/e1\n \tmkdir -p $(TMPDIR)/e2\n \t$(RUSTC) e.rs -o $(TMPDIR)/e1/libe.rlib\n \t$(RUSTC) e.rs -o $(TMPDIR)/e2/libe.rlib\n+\t$(RUSTC) f.rs -L $(TMPDIR)/e1 -L $(TMPDIR)/e2\n+\t$(RUSTC) f.rs -L crate=$(TMPDIR)/e1 -L $(TMPDIR)/e2\n+\t$(RUSTC) f.rs -L crate=$(TMPDIR)/e1 -L crate=$(TMPDIR)/e2\n+\t#   Different hash, errors.\n+\t$(RUSTC) e2.rs -o $(TMPDIR)/e2/libe.rlib\n \t$(RUSTC) f.rs -L $(TMPDIR)/e1 -L $(TMPDIR)/e2 && exit 1 || exit 0\n \t$(RUSTC) f.rs -L crate=$(TMPDIR)/e1 -L $(TMPDIR)/e2 && exit 1 || exit 0\n \t$(RUSTC) f.rs -L crate=$(TMPDIR)/e1 -L crate=$(TMPDIR)/e2 && exit 1 || exit 0\n+\t#   Native/dependency paths don't cause errors.\n \t$(RUSTC) f.rs -L native=$(TMPDIR)/e1 -L $(TMPDIR)/e2\n \t$(RUSTC) f.rs -L dependency=$(TMPDIR)/e1 -L $(TMPDIR)/e2\n \t$(RUSTC) f.rs -L dependency=$(TMPDIR)/e1 -L crate=$(TMPDIR)/e2"}, {"sha": "f8c8c029c0bdde940ffb3ddb6dd61f4fc30ecd65", "filename": "src/test/run-make/compiler-lookup-paths/e2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76c1a0df2b59c56616bb44f9bee8ad394b391ba8/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths%2Fe2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c1a0df2b59c56616bb44f9bee8ad394b391ba8/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths%2Fe2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths%2Fe2.rs?ref=76c1a0df2b59c56616bb44f9bee8ad394b391ba8", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"e\"]\n+#![crate_type = \"rlib\"]\n+\n+pub fn f() {}"}, {"sha": "a9f25853350037b385032c6b3aae0fcae02f07ef", "filename": "src/test/run-make/extern-flag-fun/Makefile", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76c1a0df2b59c56616bb44f9bee8ad394b391ba8/src%2Ftest%2Frun-make%2Fextern-flag-fun%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/76c1a0df2b59c56616bb44f9bee8ad394b391ba8/src%2Ftest%2Frun-make%2Fextern-flag-fun%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-flag-fun%2FMakefile?ref=76c1a0df2b59c56616bb44f9bee8ad394b391ba8", "patch": "@@ -3,14 +3,15 @@\n all:\n \t$(RUSTC) bar.rs --crate-type=rlib\n \t$(RUSTC) bar.rs --crate-type=rlib -C extra-filename=-a\n+\t$(RUSTC) bar-alt.rs --crate-type=rlib\n \t$(RUSTC) foo.rs --extern hello && exit 1 || exit 0\n \t$(RUSTC) foo.rs --extern bar=no-exist && exit 1 || exit 0\n \t$(RUSTC) foo.rs --extern bar=foo.rs && exit 1 || exit 0\n \t$(RUSTC) foo.rs \\\n \t\t--extern bar=$(TMPDIR)/libbar.rlib \\\n-\t\t--extern bar=$(TMPDIR)/libbar-a.rlib \\\n+\t\t--extern bar=$(TMPDIR)/libbar-alt.rlib \\\n \t\t&& exit 1 || exit 0\n \t$(RUSTC) foo.rs \\\n \t\t--extern bar=$(TMPDIR)/libbar.rlib \\\n-\t\t--extern bar=$(TMPDIR)/libbar.rlib\n+\t\t--extern bar=$(TMPDIR)/libbar-a.rlib\n \t$(RUSTC) foo.rs --extern bar=$(TMPDIR)/libbar.rlib"}, {"sha": "d6ebd9d896fbc268a304bdbc698303f0240f62ff", "filename": "src/test/run-make/extern-flag-fun/bar-alt.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/76c1a0df2b59c56616bb44f9bee8ad394b391ba8/src%2Ftest%2Frun-make%2Fextern-flag-fun%2Fbar-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c1a0df2b59c56616bb44f9bee8ad394b391ba8/src%2Ftest%2Frun-make%2Fextern-flag-fun%2Fbar-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-flag-fun%2Fbar-alt.rs?ref=76c1a0df2b59c56616bb44f9bee8ad394b391ba8", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn f() {}"}, {"sha": "cf6572c27ad5e0b84594aaaa92c4335dca064d6b", "filename": "src/test/run-make/issue-11908/Makefile", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76c1a0df2b59c56616bb44f9bee8ad394b391ba8/src%2Ftest%2Frun-make%2Fissue-11908%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/76c1a0df2b59c56616bb44f9bee8ad394b391ba8/src%2Ftest%2Frun-make%2Fissue-11908%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-11908%2FMakefile?ref=76c1a0df2b59c56616bb44f9bee8ad394b391ba8", "patch": "@@ -9,15 +9,13 @@\n \n all:\n \tmkdir $(TMPDIR)/other\n-\t$(RUSTC) foo.rs --crate-type=dylib\n+\t$(RUSTC) foo.rs --crate-type=dylib -C prefer-dynamic\n \tmv $(call DYLIB,foo) $(TMPDIR)/other\n-\t$(RUSTC) foo.rs --crate-type=dylib\n-\t$(RUSTC) bar.rs -L $(TMPDIR)/other 2>&1 | \\\n-\t\tgrep \"multiple dylib candidates\"\n+\t$(RUSTC) foo.rs --crate-type=dylib -C prefer-dynamic\n+\t$(RUSTC) bar.rs -L $(TMPDIR)/other\n \trm -rf $(TMPDIR)\n \tmkdir -p $(TMPDIR)/other\n \t$(RUSTC) foo.rs --crate-type=rlib\n \tmv $(TMPDIR)/libfoo.rlib $(TMPDIR)/other\n \t$(RUSTC) foo.rs --crate-type=rlib\n-\t$(RUSTC) bar.rs -L $(TMPDIR)/other 2>&1 | \\\n-\t\tgrep \"multiple rlib candidates\"\n+\t$(RUSTC) bar.rs -L $(TMPDIR)/other"}]}