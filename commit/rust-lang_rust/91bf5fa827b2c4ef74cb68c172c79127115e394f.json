{"sha": "91bf5fa827b2c4ef74cb68c172c79127115e394f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYmY1ZmE4MjdiMmM0ZWY3NGNiNjhjMTcyYzc5MTI3MTE1ZTM5NGY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-02T13:20:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-02T13:20:47Z"}, "message": "Merge #7513\n\n7513: NFA parser for mbe matcher r=matklad a=edwin0cheng\n\nAlmost straight porting from rustc one, but a little bit slow :(\r\n\r\n```\r\nrust-analyzer analysis-stats -q . \r\n```\r\n\r\nFrom:\r\n```log\r\nDatabase loaded:     636.11ms, 277minstr\r\n  crates: 36, mods: 594, decls: 11527, fns: 9017\r\nItem Collection:     10.99s, 60ginstr\r\n  exprs: 249618, ??ty: 2699 (1%), ?ty: 2101 (0%), !ty: 932\r\nInference:           28.94s, 123ginstr\r\nTotal:               39.93s, 184ginstr\r\n```\r\n\r\nTo:\r\n```log\r\nDatabase loaded:     630.90ms, 277minstr\r\n  crates: 36, mods: 594, decls: 11528, fns: 9018\r\nItem Collection:     13.70s, 77ginstr\r\n  exprs: 249482, ??ty: 2699 (1%), ?ty: 2101 (0%), !ty: 932\r\nInference:           30.27s, 133ginstr\r\nTotal:               43.97s, 211ginstr\r\n```\r\n\r\nFixes #4777\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "ebbd7ebb043fe9a8bee8ac2419a461c3387b1888", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebbd7ebb043fe9a8bee8ac2419a461c3387b1888"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91bf5fa827b2c4ef74cb68c172c79127115e394f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgPjuvCRBK7hj4Ov3rIwAAdHIIAIJHq+eatX6GaH2UPeDZmRpw\nmLULDjs1h2dDaL1Msxr4DuEtQP65FrENRbR+ky9TjXww06XE8GA8i3YaVAScuIWo\nlwbwtLqHBm3cEmWsigwc/+zyL6dbUgYD6UUwAoX/rj4L7bWTCtgigXX7GxrQmWd0\nfyUyo6zvdPL0XqyBgeC5Ylj5M9ptsaJa3ukcHY4zmzsLGPd+vxQ3xIqOiySDKZb7\n/2uLt9e8atRFYSAi+9mUcKKhFgvaHK7Dc9xZ7VZymTOqDNQJHff1Bz0Dj1PryFQ2\nY5WmXb1KSOkqioEfvgZ69/2a2mBiIkDh6M9i7nGE/sSgDzoagU73RAixrrAEQj8=\n=SiwY\n-----END PGP SIGNATURE-----\n", "payload": "tree ebbd7ebb043fe9a8bee8ac2419a461c3387b1888\nparent 8eee9149e87ea58d4191d04ebe6faf57ac8485a3\nparent cff2201c30bda7b346e3b47875d95a2cf9cafaa3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1614691247 +0000\ncommitter GitHub <noreply@github.com> 1614691247 +0000\n\nMerge #7513\n\n7513: NFA parser for mbe matcher r=matklad a=edwin0cheng\n\nAlmost straight porting from rustc one, but a little bit slow :(\r\n\r\n```\r\nrust-analyzer analysis-stats -q . \r\n```\r\n\r\nFrom:\r\n```log\r\nDatabase loaded:     636.11ms, 277minstr\r\n  crates: 36, mods: 594, decls: 11527, fns: 9017\r\nItem Collection:     10.99s, 60ginstr\r\n  exprs: 249618, ??ty: 2699 (1%), ?ty: 2101 (0%), !ty: 932\r\nInference:           28.94s, 123ginstr\r\nTotal:               39.93s, 184ginstr\r\n```\r\n\r\nTo:\r\n```log\r\nDatabase loaded:     630.90ms, 277minstr\r\n  crates: 36, mods: 594, decls: 11528, fns: 9018\r\nItem Collection:     13.70s, 77ginstr\r\n  exprs: 249482, ??ty: 2699 (1%), ?ty: 2101 (0%), !ty: 932\r\nInference:           30.27s, 133ginstr\r\nTotal:               43.97s, 211ginstr\r\n```\r\n\r\nFixes #4777\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91bf5fa827b2c4ef74cb68c172c79127115e394f", "html_url": "https://github.com/rust-lang/rust/commit/91bf5fa827b2c4ef74cb68c172c79127115e394f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91bf5fa827b2c4ef74cb68c172c79127115e394f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8eee9149e87ea58d4191d04ebe6faf57ac8485a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8eee9149e87ea58d4191d04ebe6faf57ac8485a3", "html_url": "https://github.com/rust-lang/rust/commit/8eee9149e87ea58d4191d04ebe6faf57ac8485a3"}, {"sha": "cff2201c30bda7b346e3b47875d95a2cf9cafaa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cff2201c30bda7b346e3b47875d95a2cf9cafaa3", "html_url": "https://github.com/rust-lang/rust/commit/cff2201c30bda7b346e3b47875d95a2cf9cafaa3"}], "stats": {"total": 743, "additions": 580, "deletions": 163}, "files": [{"sha": "ec5aecfa09f381c8f7eb8813e153b682d88a606d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91bf5fa827b2c4ef74cb68c172c79127115e394f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/91bf5fa827b2c4ef74cb68c172c79127115e394f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=91bf5fa827b2c4ef74cb68c172c79127115e394f", "patch": "@@ -879,6 +879,7 @@ dependencies = [\n  \"profile\",\n  \"rustc-hash\",\n  \"smallvec\",\n+ \"stdx\",\n  \"syntax\",\n  \"test_utils\",\n  \"tt\","}, {"sha": "bb2656a80aaf5ca49d6f264ecb237bfe9ce777b2", "filename": "crates/mbe/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91bf5fa827b2c4ef74cb68c172c79127115e394f/crates%2Fmbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/91bf5fa827b2c4ef74cb68c172c79127115e394f/crates%2Fmbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2FCargo.toml?ref=91bf5fa827b2c4ef74cb68c172c79127115e394f", "patch": "@@ -18,6 +18,7 @@ syntax = { path = \"../syntax\", version = \"0.0.0\" }\n parser = { path = \"../parser\", version = \"0.0.0\" }\n tt = { path = \"../tt\", version = \"0.0.0\" }\n test_utils = { path = \"../test_utils\", version = \"0.0.0\" }\n+stdx = { path = \"../stdx\", version = \"0.0.0\" }\n \n [dev-dependencies]\n profile = { path = \"../profile\" }"}, {"sha": "503ad135568b5067f943879303417993a1d1127f", "filename": "crates/mbe/src/benchmark.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/91bf5fa827b2c4ef74cb68c172c79127115e394f/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bf5fa827b2c4ef74cb68c172c79127115e394f/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fbenchmark.rs?ref=91bf5fa827b2c4ef74cb68c172c79127115e394f", "patch": "@@ -40,18 +40,12 @@ fn benchmark_expand_macro_rules() {\n             .into_iter()\n             .map(|(id, tt)| {\n                 let res = rules[&id].expand(&tt);\n-                if res.err.is_some() {\n-                    // FIXME:\n-                    // Currently `invocation_fixtures` will generate some correct invocations but\n-                    // cannot be expanded by mbe. We ignore errors here.\n-                    // See: https://github.com/rust-analyzer/rust-analyzer/issues/4777\n-                    eprintln!(\"err from {} {:?}\", id, res.err);\n-                }\n+                assert!(res.err.is_none());\n                 res.value.token_trees.len()\n             })\n             .sum()\n     };\n-    assert_eq!(hash, 66995);\n+    assert_eq!(hash, 69413);\n }\n \n fn macro_rules_fixtures() -> FxHashMap<String, MacroRules> {\n@@ -77,7 +71,7 @@ fn macro_rules_fixtures_tt() -> FxHashMap<String, tt::Subtree> {\n         .collect()\n }\n \n-// Generate random invocation fixtures from rules\n+/// Generate random invocation fixtures from rules\n fn invocation_fixtures(rules: &FxHashMap<String, MacroRules>) -> Vec<(String, tt::Subtree)> {\n     let mut seed = 123456789;\n     let mut res = Vec::new();\n@@ -86,11 +80,31 @@ fn invocation_fixtures(rules: &FxHashMap<String, MacroRules>) -> Vec<(String, tt\n         for rule in &it.rules {\n             // Generate twice\n             for _ in 0..2 {\n-                let mut subtree = tt::Subtree::default();\n-                for op in rule.lhs.iter() {\n-                    collect_from_op(op, &mut subtree, &mut seed);\n+                // The input are generated by filling the `Op` randomly.\n+                // However, there are some cases generated are ambiguous for expanding, for example:\n+                // ```rust\n+                // macro_rules! m {\n+                //    ($($t:ident),* as $ty:ident) => {}\n+                // }\n+                // m!(as u32);  // error: local ambiguity: multiple parsing options: built-in NTs ident ('t') or 1 other option.\n+                // ```\n+                //\n+                // So we just skip any error cases and try again\n+                let mut try_cnt = 0;\n+                loop {\n+                    let mut subtree = tt::Subtree::default();\n+                    for op in rule.lhs.iter() {\n+                        collect_from_op(op, &mut subtree, &mut seed);\n+                    }\n+                    if it.expand(&subtree).err.is_none() {\n+                        res.push((name.clone(), subtree));\n+                        break;\n+                    }\n+                    try_cnt += 1;\n+                    if try_cnt > 100 {\n+                        panic!(\"invocaton fixture {} cannot be generated.\\n\", name);\n+                    }\n                 }\n-                res.push((name.clone(), subtree));\n             }\n         }\n     }"}, {"sha": "2efff8f52ed3ab4ab9f9073fef5bbc6a38ee11aa", "filename": "crates/mbe/src/expander.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/91bf5fa827b2c4ef74cb68c172c79127115e394f/crates%2Fmbe%2Fsrc%2Fexpander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bf5fa827b2c4ef74cb68c172c79127115e394f/crates%2Fmbe%2Fsrc%2Fexpander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander.rs?ref=91bf5fa827b2c4ef74cb68c172c79127115e394f", "patch": "@@ -5,7 +5,7 @@\n mod matcher;\n mod transcriber;\n \n-use rustc_hash::FxHashMap;\n+use smallvec::SmallVec;\n use syntax::SmolStr;\n \n use crate::{ExpandError, ExpandResult};\n@@ -28,10 +28,10 @@ pub(crate) fn expand_rules(\n                 return ExpandResult::ok(value);\n             }\n         }\n-        // Use the rule if we matched more tokens, or had fewer errors\n+        // Use the rule if we matched more tokens, or bound variables count\n         if let Some((prev_match, _)) = &match_ {\n-            if (new_match.unmatched_tts, new_match.err_count)\n-                < (prev_match.unmatched_tts, prev_match.err_count)\n+            if (new_match.unmatched_tts, -(new_match.bound_count as i32))\n+                < (prev_match.unmatched_tts, -(prev_match.bound_count as i32))\n             {\n                 match_ = Some((new_match, rule));\n             }\n@@ -94,19 +94,19 @@ pub(crate) fn expand_rules(\n /// In other words, `Bindings` is a *multi* mapping from `SmolStr` to\n /// `tt::TokenTree`, where the index to select a particular `TokenTree` among\n /// many is not a plain `usize`, but an `&[usize]`.\n-#[derive(Debug, Default)]\n+#[derive(Debug, Default, Clone, PartialEq, Eq)]\n struct Bindings {\n-    inner: FxHashMap<SmolStr, Binding>,\n+    inner: SmallVec<[(SmolStr, Binding); 4]>,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n enum Binding {\n     Fragment(Fragment),\n     Nested(Vec<Binding>),\n     Empty,\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n enum Fragment {\n     /// token fragments are just copy-pasted into the output\n     Tokens(tt::TokenTree),"}, {"sha": "9d3d280552fdf5c3c3783d5e44f96e8afffb8315", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 432, "deletions": 127, "changes": 559, "blob_url": "https://github.com/rust-lang/rust/blob/91bf5fa827b2c4ef74cb68c172c79127115e394f/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bf5fa827b2c4ef74cb68c172c79127115e394f/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=91bf5fa827b2c4ef74cb68c172c79127115e394f", "patch": "@@ -1,34 +1,94 @@\n-//! FIXME: write short doc here\n+//! An NFA-based parser, which is porting from rustc mbe parsing code\n+//!\n+//! See https://github.com/rust-lang/rust/blob/70b18bc2cbac4712020019f5bf57c00905373205/compiler/rustc_expand/src/mbe/macro_parser.rs\n+//! Here is a quick intro to how the parser works, copied from rustc:\n+//!\n+//! A 'position' is a dot in the middle of a matcher, usually represented as a\n+//! dot. For example `\u00b7 a $( a )* a b` is a position, as is `a $( \u00b7 a )* a b`.\n+//!\n+//! The parser walks through the input a character at a time, maintaining a list\n+//! of threads consistent with the current position in the input string: `cur_items`.\n+//!\n+//! As it processes them, it fills up `eof_items` with threads that would be valid if\n+//! the macro invocation is now over, `bb_items` with threads that are waiting on\n+//! a Rust non-terminal like `$e:expr`, and `next_items` with threads that are waiting\n+//! on a particular token. Most of the logic concerns moving the \u00b7 through the\n+//! repetitions indicated by Kleene stars. The rules for moving the \u00b7 without\n+//! consuming any input are called epsilon transitions. It only advances or calls\n+//! out to the real Rust parser when no `cur_items` threads remain.\n+//!\n+//! Example:\n+//!\n+//! ```text, ignore\n+//! Start parsing a a a a b against [\u00b7 a $( a )* a b].\n+//!\n+//! Remaining input: a a a a b\n+//! next: [\u00b7 a $( a )* a b]\n+//!\n+//! - - - Advance over an a. - - -\n+//!\n+//! Remaining input: a a a b\n+//! cur: [a \u00b7 $( a )* a b]\n+//! Descend/Skip (first item).\n+//! next: [a $( \u00b7 a )* a b]  [a $( a )* \u00b7 a b].\n+//!\n+//! - - - Advance over an a. - - -\n+//!\n+//! Remaining input: a a b\n+//! cur: [a $( a \u00b7 )* a b]  [a $( a )* a \u00b7 b]\n+//! Follow epsilon transition: Finish/Repeat (first item)\n+//! next: [a $( a )* \u00b7 a b]  [a $( \u00b7 a )* a b]  [a $( a )* a \u00b7 b]\n+//!\n+//! - - - Advance over an a. - - - (this looks exactly like the last step)\n+//!\n+//! Remaining input: a b\n+//! cur: [a $( a \u00b7 )* a b]  [a $( a )* a \u00b7 b]\n+//! Follow epsilon transition: Finish/Repeat (first item)\n+//! next: [a $( a )* \u00b7 a b]  [a $( \u00b7 a )* a b]  [a $( a )* a \u00b7 b]\n+//!\n+//! - - - Advance over an a. - - - (this looks exactly like the last step)\n+//!\n+//! Remaining input: b\n+//! cur: [a $( a \u00b7 )* a b]  [a $( a )* a \u00b7 b]\n+//! Follow epsilon transition: Finish/Repeat (first item)\n+//! next: [a $( a )* \u00b7 a b]  [a $( \u00b7 a )* a b]  [a $( a )* a \u00b7 b]\n+//!\n+//! - - - Advance over a b. - - -\n+//!\n+//! Remaining input: ''\n+//! eof: [a $( a )* a b \u00b7]\n+//! ```\n \n use crate::{\n     expander::{Binding, Bindings, Fragment},\n-    parser::{Op, RepeatKind, Separator},\n+    parser::{Op, OpDelimited, OpDelimitedIter, RepeatKind, Separator},\n     tt_iter::TtIter,\n     ExpandError, MetaTemplate,\n };\n \n use super::ExpandResult;\n use parser::FragmentKind::*;\n+use smallvec::{smallvec, SmallVec};\n use syntax::SmolStr;\n \n impl Bindings {\n     fn push_optional(&mut self, name: &SmolStr) {\n         // FIXME: Do we have a better way to represent an empty token ?\n         // Insert an empty subtree for empty token\n         let tt = tt::Subtree::default().into();\n-        self.inner.insert(name.clone(), Binding::Fragment(Fragment::Tokens(tt)));\n+        self.inner.push((name.clone(), Binding::Fragment(Fragment::Tokens(tt))));\n     }\n \n     fn push_empty(&mut self, name: &SmolStr) {\n-        self.inner.insert(name.clone(), Binding::Empty);\n+        self.inner.push((name.clone(), Binding::Empty));\n     }\n \n     fn push_nested(&mut self, idx: usize, nested: Bindings) -> Result<(), ExpandError> {\n         for (key, value) in nested.inner {\n-            if !self.inner.contains_key(&key) {\n-                self.inner.insert(key.clone(), Binding::Nested(Vec::new()));\n+            if self.get_mut(&key).is_none() {\n+                self.inner.push((key.clone(), Binding::Nested(Vec::new())));\n             }\n-            match self.inner.get_mut(&key) {\n+            match self.get_mut(&key) {\n                 Some(Binding::Nested(it)) => {\n                     // insert empty nested bindings before this one\n                     while it.len() < idx {\n@@ -46,6 +106,14 @@ impl Bindings {\n         }\n         Ok(())\n     }\n+\n+    fn get_mut(&mut self, name: &str) -> Option<&mut Binding> {\n+        self.inner.iter_mut().find_map(|(n, b)| if n == name { Some(b) } else { None })\n+    }\n+\n+    fn bindings(&self) -> impl Iterator<Item = &Binding> {\n+        self.inner.iter().map(|(_, b)| b)\n+    }\n }\n \n macro_rules! err {\n@@ -57,14 +125,16 @@ macro_rules! err {\n     };\n }\n \n-#[derive(Debug, Default)]\n+#[derive(Clone, Debug, Default, PartialEq, Eq)]\n pub(super) struct Match {\n     pub(super) bindings: Bindings,\n     /// We currently just keep the first error and count the rest to compare matches.\n     pub(super) err: Option<ExpandError>,\n     pub(super) err_count: usize,\n     /// How many top-level token trees were left to match.\n     pub(super) unmatched_tts: usize,\n+    /// The number of bound variables\n+    pub(super) bound_count: usize,\n }\n \n impl Match {\n@@ -76,72 +146,373 @@ impl Match {\n }\n \n /// Matching errors are added to the `Match`.\n-pub(super) fn match_(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n-    let mut res = Match::default();\n-    let mut src = TtIter::new(src);\n+pub(super) fn match_(pattern: &MetaTemplate, input: &tt::Subtree) -> Match {\n+    let mut res = match_loop(pattern, &input);\n+    res.bound_count = count(res.bindings.bindings());\n+    return res;\n+\n+    fn count<'a>(bindings: impl Iterator<Item = &'a Binding>) -> usize {\n+        bindings\n+            .map(|it| match it {\n+                Binding::Fragment(_) => 1,\n+                Binding::Empty => 1,\n+                Binding::Nested(it) => count(it.iter()),\n+            })\n+            .sum()\n+    }\n+}\n \n-    match_tokens(&mut res, pattern, &mut src);\n+#[derive(Debug, Clone)]\n+struct MatchState<'t> {\n+    /// The position of the \"dot\" in this matcher\n+    dot: OpDelimitedIter<'t>,\n \n-    if src.len() > 0 {\n-        res.unmatched_tts += src.len();\n-        res.add_err(err!(\"leftover tokens\"));\n-    }\n+    /// Token subtree stack\n+    /// When matching against matchers with nested delimited submatchers (e.g., `pat ( pat ( .. )\n+    /// pat ) pat`), we need to keep track of the matchers we are descending into. This stack does\n+    /// that where the bottom of the stack is the outermost matcher.\n+    stack: SmallVec<[OpDelimitedIter<'t>; 4]>,\n+\n+    /// The \"parent\" matcher position if we are in a repetition. That is, the matcher position just\n+    /// before we enter the repetition.\n+    up: Option<Box<MatchState<'t>>>,\n+\n+    /// The separator if we are in a repetition.\n+    sep: Option<Separator>,\n+\n+    /// The KleeneOp of this sequence if we are in a repetition.\n+    sep_kind: Option<RepeatKind>,\n \n-    res\n+    /// Number of tokens of seperator parsed\n+    sep_parsed: Option<usize>,\n+\n+    /// Matched meta variables bindings\n+    bindings: SmallVec<[Bindings; 4]>,\n+\n+    /// Cached result of meta variable parsing\n+    meta_result: Option<(TtIter<'t>, ExpandResult<Option<Fragment>>)>,\n+\n+    /// Is error occuried in this state, will `poised` to \"parent\"\n+    is_error: bool,\n }\n \n-fn match_tokens(res: &mut Match, pattern: &MetaTemplate, src: &mut TtIter) {\n-    for op in pattern.iter() {\n-        match op {\n-            Op::Leaf(lhs) => {\n-                if let Err(err) = match_leaf(lhs, src) {\n-                    res.add_err(err);\n-                    continue;\n+/// Process the matcher positions of `cur_items` until it is empty. In the process, this will\n+/// produce more items in `next_items`, `eof_items`, and `bb_items`.\n+///\n+/// For more info about the how this happens, see the module-level doc comments and the inline\n+/// comments of this function.\n+///\n+/// # Parameters\n+///\n+/// - `src`: the current token of the parser.\n+/// - `stack`: the \"parent\" frames of the token tree\n+/// - `res`: the match result to store errors\n+/// - `cur_items`: the set of current items to be processed. This should be empty by the end of a\n+///   successful execution of this function.\n+/// - `next_items`: the set of newly generated items. These are used to replenish `cur_items` in\n+///   the function `parse`.\n+/// - `eof_items`: the set of items that would be valid if this was the EOF.\n+/// - `bb_items`: the set of items that are waiting for the black-box parser.\n+/// - `error_items`: the set of items in errors, used for error-resilient parsing\n+fn match_loop_inner<'t>(\n+    src: TtIter<'t>,\n+    stack: &[TtIter<'t>],\n+    res: &mut Match,\n+    cur_items: &mut SmallVec<[MatchState<'t>; 1]>,\n+    bb_items: &mut SmallVec<[MatchState<'t>; 1]>,\n+    next_items: &mut Vec<MatchState<'t>>,\n+    eof_items: &mut SmallVec<[MatchState<'t>; 1]>,\n+    error_items: &mut SmallVec<[MatchState<'t>; 1]>,\n+) {\n+    macro_rules! try_push {\n+        ($items: expr, $it:expr) => {\n+            if $it.is_error {\n+                error_items.push($it);\n+            } else {\n+                $items.push($it);\n+            }\n+        };\n+    }\n+\n+    while let Some(mut item) = cur_items.pop() {\n+        while item.dot.is_eof() {\n+            match item.stack.pop() {\n+                Some(frame) => {\n+                    item.dot = frame;\n+                    item.dot.next();\n                 }\n+                None => break,\n             }\n-            Op::Subtree { tokens, delimiter: delim } => {\n-                let rhs = match src.expect_subtree() {\n-                    Ok(s) => s,\n-                    Err(()) => {\n-                        res.add_err(err!(\"expected subtree\"));\n-                        continue;\n+        }\n+        let op = match item.dot.peek() {\n+            None => {\n+                // We are at or past the end of the matcher of `item`.\n+                if item.up.is_some() {\n+                    if item.sep_parsed.is_none() {\n+                        // Get the `up` matcher\n+                        let mut new_pos = *item.up.clone().unwrap();\n+                        // Add matches from this repetition to the `matches` of `up`\n+                        if let Some(bindings) = new_pos.bindings.last_mut() {\n+                            for (i, b) in item.bindings.iter_mut().enumerate() {\n+                                bindings.push_nested(i, b.clone()).unwrap();\n+                            }\n+                        }\n+                        // Move the \"dot\" past the repetition in `up`\n+                        new_pos.dot.next();\n+                        new_pos.is_error = new_pos.is_error || item.is_error;\n+                        cur_items.push(new_pos);\n+                    }\n+\n+                    // Check if we need a separator.\n+                    // We check the separator one by one\n+                    let sep_idx = *item.sep_parsed.as_ref().unwrap_or(&0);\n+                    let sep_len = item.sep.as_ref().map_or(0, Separator::tt_count);\n+                    if item.sep.is_some() && sep_idx != sep_len {\n+                        let sep = item.sep.as_ref().unwrap();\n+                        if src.clone().expect_separator(&sep, sep_idx) {\n+                            item.dot.next();\n+                            item.sep_parsed = Some(sep_idx + 1);\n+                            try_push!(next_items, item);\n+                        }\n+                    }\n+                    // We don't need a separator. Move the \"dot\" back to the beginning of the matcher\n+                    // and try to match again UNLESS we are only allowed to have _one_ repetition.\n+                    else if item.sep_kind != Some(RepeatKind::ZeroOrOne) {\n+                        item.dot = item.dot.reset();\n+                        item.sep_parsed = None;\n+                        item.bindings.push(Bindings::default());\n+                        cur_items.push(item);\n+                    }\n+                } else {\n+                    // If we are not in a repetition, then being at the end of a matcher means that we have\n+                    // reached the potential end of the input.\n+                    try_push!(eof_items, item);\n+                }\n+                continue;\n+            }\n+            Some(it) => it,\n+        };\n+\n+        // We are in the middle of a matcher.\n+        match op {\n+            OpDelimited::Op(Op::Repeat { tokens, kind, separator }) => {\n+                if matches!(kind, RepeatKind::ZeroOrMore | RepeatKind::ZeroOrOne) {\n+                    let mut new_item = item.clone();\n+                    new_item.dot.next();\n+                    let mut vars = Vec::new();\n+                    let bindings = new_item.bindings.last_mut().unwrap();\n+                    collect_vars(&mut vars, tokens);\n+                    for var in vars {\n+                        bindings.push_empty(&var);\n                     }\n-                };\n-                if delim.map(|it| it.kind) != rhs.delimiter_kind() {\n-                    res.add_err(err!(\"mismatched delimiter\"));\n-                    continue;\n+                    cur_items.push(new_item);\n                 }\n-                let mut src = TtIter::new(rhs);\n-                match_tokens(res, tokens, &mut src);\n-                if src.len() > 0 {\n-                    res.add_err(err!(\"leftover tokens\"));\n+                cur_items.push(MatchState {\n+                    dot: tokens.iter_delimited(None),\n+                    stack: Default::default(),\n+                    up: Some(Box::new(item)),\n+                    sep: separator.clone(),\n+                    sep_kind: Some(*kind),\n+                    sep_parsed: None,\n+                    bindings: smallvec![Bindings::default()],\n+                    meta_result: None,\n+                    is_error: false,\n+                })\n+            }\n+            OpDelimited::Op(Op::Subtree { tokens, delimiter }) => {\n+                if let Ok(subtree) = src.clone().expect_subtree() {\n+                    if subtree.delimiter_kind() == delimiter.map(|it| it.kind) {\n+                        item.stack.push(item.dot);\n+                        item.dot = tokens.iter_delimited(delimiter.as_ref());\n+                        cur_items.push(item);\n+                    }\n                 }\n             }\n-            Op::Var { name, kind, .. } => {\n-                let kind = match kind {\n-                    Some(k) => k,\n-                    None => {\n-                        res.add_err(ExpandError::UnexpectedToken);\n-                        continue;\n+            OpDelimited::Op(Op::Var { kind, name, .. }) => {\n+                if let Some(kind) = kind {\n+                    let mut fork = src.clone();\n+                    let match_res = match_meta_var(kind.as_str(), &mut fork);\n+                    match match_res.err {\n+                        None => {\n+                            // Some meta variables are optional (e.g. vis)\n+                            if match_res.value.is_some() {\n+                                item.meta_result = Some((fork, match_res));\n+                                try_push!(bb_items, item);\n+                            } else {\n+                                item.bindings.last_mut().unwrap().push_optional(name);\n+                                item.dot.next();\n+                                cur_items.push(item);\n+                            }\n+                        }\n+                        Some(err) => {\n+                            res.add_err(err);\n+                            match match_res.value {\n+                                Some(fragment) => {\n+                                    item.bindings\n+                                        .last_mut()\n+                                        .unwrap()\n+                                        .inner\n+                                        .push((name.clone(), Binding::Fragment(fragment)));\n+                                }\n+                                _ => {}\n+                            }\n+                            item.is_error = true;\n+                            error_items.push(item);\n+                        }\n                     }\n-                };\n-                let ExpandResult { value: matched, err: match_err } =\n-                    match_meta_var(kind.as_str(), src);\n-                match matched {\n+                }\n+            }\n+            OpDelimited::Op(Op::Leaf(leaf)) => {\n+                if let Err(err) = match_leaf(&leaf, &mut src.clone()) {\n+                    res.add_err(err);\n+                    item.is_error = true;\n+                } else {\n+                    item.dot.next();\n+                }\n+                try_push!(next_items, item);\n+            }\n+            OpDelimited::Open => {\n+                if matches!(src.clone().next(), Some(tt::TokenTree::Subtree(..))) {\n+                    item.dot.next();\n+                    try_push!(next_items, item);\n+                }\n+            }\n+            OpDelimited::Close => {\n+                let is_delim_closed = src.peek_n(0).is_none() && !stack.is_empty();\n+                if is_delim_closed {\n+                    item.dot.next();\n+                    try_push!(next_items, item);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n+    let mut src = TtIter::new(src);\n+    let mut stack: SmallVec<[TtIter; 1]> = SmallVec::new();\n+    let mut res = Match::default();\n+    let mut error_reover_item = None;\n+\n+    let mut cur_items = smallvec![MatchState {\n+        dot: pattern.iter_delimited(None),\n+        stack: Default::default(),\n+        up: None,\n+        sep: None,\n+        sep_kind: None,\n+        sep_parsed: None,\n+        bindings: smallvec![Bindings::default()],\n+        is_error: false,\n+        meta_result: None,\n+    }];\n+\n+    let mut next_items = vec![];\n+\n+    loop {\n+        let mut bb_items = SmallVec::new();\n+        let mut eof_items = SmallVec::new();\n+        let mut error_items = SmallVec::new();\n+\n+        stdx::always!(next_items.is_empty());\n+\n+        match_loop_inner(\n+            src.clone(),\n+            &stack,\n+            &mut res,\n+            &mut cur_items,\n+            &mut bb_items,\n+            &mut next_items,\n+            &mut eof_items,\n+            &mut error_items,\n+        );\n+        stdx::always!(cur_items.is_empty());\n+\n+        if error_items.len() > 0 {\n+            error_reover_item = error_items.pop();\n+        } else if eof_items.len() > 0 {\n+            error_reover_item = Some(eof_items[0].clone());\n+        }\n+\n+        // We need to do some post processing after the `match_loop_inner`.\n+        // If we reached the EOF, check that there is EXACTLY ONE possible matcher. Otherwise,\n+        // either the parse is ambiguous (which should never happen) or there is a syntax error.\n+        if src.peek_n(0).is_none() && stack.is_empty() {\n+            if eof_items.len() == 1 {\n+                // remove all errors, because it is the correct answer !\n+                res = Match::default();\n+                res.bindings = eof_items[0].bindings[0].clone();\n+            } else {\n+                // Error recovery\n+                if error_reover_item.is_some() {\n+                    res.bindings = error_reover_item.unwrap().bindings[0].clone();\n+                }\n+                res.add_err(ExpandError::UnexpectedToken);\n+            }\n+            return res;\n+        }\n+\n+        // If there are no possible next positions AND we aren't waiting for the black-box parser,\n+        // then there is a syntax error.\n+        //\n+        // Another possibility is that we need to call out to parse some rust nonterminal\n+        // (black-box) parser. However, if there is not EXACTLY ONE of these, something is wrong.\n+        if (bb_items.is_empty() && next_items.is_empty())\n+            || (!bb_items.is_empty() && !next_items.is_empty())\n+            || bb_items.len() > 1\n+        {\n+            res.unmatched_tts += src.len();\n+            while let Some(it) = stack.pop() {\n+                src = it;\n+                res.unmatched_tts += src.len();\n+            }\n+            res.add_err(err!(\"leftover tokens\"));\n+\n+            if let Some(mut error_reover_item) = error_reover_item {\n+                res.bindings = error_reover_item.bindings.remove(0);\n+            }\n+            return res;\n+        }\n+        // Dump all possible `next_items` into `cur_items` for the next iteration.\n+        else if !next_items.is_empty() {\n+            // Now process the next token\n+            cur_items.extend(next_items.drain(..));\n+\n+            match src.next() {\n+                Some(tt::TokenTree::Subtree(subtree)) => {\n+                    stack.push(src.clone());\n+                    src = TtIter::new(subtree);\n+                }\n+                None if !stack.is_empty() => src = stack.pop().unwrap(),\n+                _ => (),\n+            }\n+        }\n+        // Finally, we have the case where we need to call the black-box parser to get some\n+        // nonterminal.\n+        else {\n+            stdx::always!(bb_items.len() == 1);\n+            let mut item = bb_items.pop().unwrap();\n+\n+            if let Some(OpDelimited::Op(Op::Var { name, .. })) = item.dot.peek() {\n+                let (iter, match_res) = item.meta_result.take().unwrap();\n+                let bindings = item.bindings.last_mut().unwrap();\n+                match match_res.value {\n                     Some(fragment) => {\n-                        res.bindings.inner.insert(name.clone(), Binding::Fragment(fragment));\n+                        bindings.inner.push((name.clone(), Binding::Fragment(fragment)));\n                     }\n-                    None if match_err.is_none() => res.bindings.push_optional(name),\n+                    None if match_res.err.is_none() => bindings.push_optional(name),\n                     _ => {}\n                 }\n-                if let Some(err) = match_err {\n+                if let Some(err) = match_res.err {\n                     res.add_err(err);\n                 }\n+                src = iter.clone();\n+                item.dot.next();\n+            } else {\n+                unreachable!()\n             }\n-            Op::Repeat { tokens: subtree, kind, separator } => {\n-                match_repeat(res, subtree, *kind, separator, src);\n-            }\n+            cur_items.push(item);\n         }\n+        stdx::always!(!cur_items.is_empty());\n     }\n }\n \n@@ -173,73 +544,6 @@ fn match_leaf(lhs: &tt::Leaf, src: &mut TtIter) -> Result<(), ExpandError> {\n     Ok(())\n }\n \n-fn match_repeat(\n-    res: &mut Match,\n-    pattern: &MetaTemplate,\n-    kind: RepeatKind,\n-    separator: &Option<Separator>,\n-    src: &mut TtIter,\n-) {\n-    // Dirty hack to make macro-expansion terminate.\n-    // This should be replaced by a proper macro-by-example implementation\n-    let mut limit = 65536;\n-    let mut counter = 0;\n-\n-    for i in 0.. {\n-        let mut fork = src.clone();\n-\n-        if let Some(separator) = &separator {\n-            if i != 0 && !fork.eat_separator(separator) {\n-                break;\n-            }\n-        }\n-\n-        let mut nested = Match::default();\n-        match_tokens(&mut nested, pattern, &mut fork);\n-        if nested.err.is_none() {\n-            limit -= 1;\n-            if limit == 0 {\n-                log::warn!(\n-                    \"match_lhs exceeded repeat pattern limit => {:#?}\\n{:#?}\\n{:#?}\\n{:#?}\",\n-                    pattern,\n-                    src,\n-                    kind,\n-                    separator\n-                );\n-                break;\n-            }\n-            *src = fork;\n-\n-            if let Err(err) = res.bindings.push_nested(counter, nested.bindings) {\n-                res.add_err(err);\n-            }\n-            counter += 1;\n-            if counter == 1 {\n-                if let RepeatKind::ZeroOrOne = kind {\n-                    break;\n-                }\n-            }\n-        } else {\n-            break;\n-        }\n-    }\n-\n-    match (kind, counter) {\n-        (RepeatKind::OneOrMore, 0) => {\n-            res.add_err(ExpandError::UnexpectedToken);\n-        }\n-        (_, 0) => {\n-            // Collect all empty variables in subtrees\n-            let mut vars = Vec::new();\n-            collect_vars(&mut vars, pattern);\n-            for var in vars {\n-                res.bindings.push_empty(&var)\n-            }\n-        }\n-        _ => (),\n-    }\n-}\n-\n fn match_meta_var(kind: &str, input: &mut TtIter) -> ExpandResult<Option<Fragment>> {\n     let fragment = match kind {\n         \"path\" => Path,\n@@ -303,25 +607,26 @@ fn collect_vars(buf: &mut Vec<SmolStr>, pattern: &MetaTemplate) {\n }\n \n impl<'a> TtIter<'a> {\n-    fn eat_separator(&mut self, separator: &Separator) -> bool {\n+    fn expect_separator(&mut self, separator: &Separator, idx: usize) -> bool {\n         let mut fork = self.clone();\n         let ok = match separator {\n-            Separator::Ident(lhs) => match fork.expect_ident() {\n+            Separator::Ident(lhs) if idx == 0 => match fork.expect_ident() {\n                 Ok(rhs) => rhs.text == lhs.text,\n                 _ => false,\n             },\n-            Separator::Literal(lhs) => match fork.expect_literal() {\n+            Separator::Literal(lhs) if idx == 0 => match fork.expect_literal() {\n                 Ok(rhs) => match rhs {\n                     tt::Leaf::Literal(rhs) => rhs.text == lhs.text,\n                     tt::Leaf::Ident(rhs) => rhs.text == lhs.text,\n                     tt::Leaf::Punct(_) => false,\n                 },\n                 _ => false,\n             },\n-            Separator::Puncts(lhss) => lhss.iter().all(|lhs| match fork.expect_punct() {\n-                Ok(rhs) => rhs.char == lhs.char,\n+            Separator::Puncts(lhss) if idx < lhss.len() => match fork.expect_punct() {\n+                Ok(rhs) => rhs.char == lhss[idx].char,\n                 _ => false,\n-            }),\n+            },\n+            _ => false,\n         };\n         if ok {\n             *self = fork;"}, {"sha": "ad9953a7d26c3adf89455e545af2e5445be1c79d", "filename": "crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91bf5fa827b2c4ef74cb68c172c79127115e394f/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bf5fa827b2c4ef74cb68c172c79127115e394f/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=91bf5fa827b2c4ef74cb68c172c79127115e394f", "patch": "@@ -13,13 +13,17 @@ use crate::{\n \n impl Bindings {\n     fn contains(&self, name: &str) -> bool {\n-        self.inner.contains_key(name)\n+        self.inner.iter().any(|(n, _)| n == name)\n     }\n \n     fn get(&self, name: &str, nesting: &mut [NestingState]) -> Result<&Fragment, ExpandError> {\n-        let mut b = self.inner.get(name).ok_or_else(|| {\n-            ExpandError::BindingError(format!(\"could not find binding `{}`\", name))\n-        })?;\n+        let mut b: &Binding = self\n+            .inner\n+            .iter()\n+            .find_map(|(n, b)| if n == name { Some(b) } else { None })\n+            .ok_or_else(|| {\n+                ExpandError::BindingError(format!(\"could not find binding `{}`\", name))\n+            })?;\n         for nesting_state in nesting.iter_mut() {\n             nesting_state.hit = true;\n             b = match b {"}, {"sha": "f3d2da55a7e0e38a87a4e8c4897b134c88d6ae57", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/91bf5fa827b2c4ef74cb68c172c79127115e394f/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bf5fa827b2c4ef74cb68c172c79127115e394f/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=91bf5fa827b2c4ef74cb68c172c79127115e394f", "patch": "@@ -21,7 +21,7 @@ use test_utils::mark;\n pub use tt::{Delimiter, DelimiterKind, Punct};\n \n use crate::{\n-    parser::{parse_pattern, parse_template, Op},\n+    parser::{parse_pattern, parse_template, MetaTemplate, Op},\n     tt_iter::TtIter,\n };\n \n@@ -94,15 +94,6 @@ struct Rule {\n     rhs: MetaTemplate,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n-struct MetaTemplate(Vec<Op>);\n-\n-impl<'a> MetaTemplate {\n-    fn iter(&self) -> impl Iterator<Item = &Op> {\n-        self.0.iter()\n-    }\n-}\n-\n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n struct Shift(u32);\n "}, {"sha": "8671322e1fb3190b51f0c46bdebf29e1e63f8f2e", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/91bf5fa827b2c4ef74cb68c172c79127115e394f/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bf5fa827b2c4ef74cb68c172c79127115e394f/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=91bf5fa827b2c4ef74cb68c172c79127115e394f", "patch": "@@ -5,7 +5,75 @@ use smallvec::SmallVec;\n use syntax::SmolStr;\n use tt::Delimiter;\n \n-use crate::{tt_iter::TtIter, MetaTemplate, ParseError};\n+use crate::{tt_iter::TtIter, ParseError};\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) struct MetaTemplate(pub(crate) Vec<Op>);\n+\n+#[derive(Debug, Clone, Copy)]\n+pub(crate) enum OpDelimited<'a> {\n+    Op(&'a Op),\n+    Open,\n+    Close,\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+pub(crate) struct OpDelimitedIter<'a> {\n+    inner: &'a Vec<Op>,\n+    delimited: Option<&'a Delimiter>,\n+    idx: usize,\n+}\n+\n+impl<'a> OpDelimitedIter<'a> {\n+    pub(crate) fn is_eof(&self) -> bool {\n+        let len = self.inner.len() + if self.delimited.is_some() { 2 } else { 0 };\n+        self.idx >= len\n+    }\n+\n+    pub(crate) fn peek(&self) -> Option<OpDelimited<'a>> {\n+        match self.delimited {\n+            None => self.inner.get(self.idx).map(OpDelimited::Op),\n+            Some(_) => match self.idx {\n+                0 => Some(OpDelimited::Open),\n+                i if i == self.inner.len() + 1 => Some(OpDelimited::Close),\n+                i => self.inner.get(i - 1).map(OpDelimited::Op),\n+            },\n+        }\n+    }\n+\n+    pub(crate) fn reset(&self) -> Self {\n+        Self { inner: &self.inner, idx: 0, delimited: self.delimited }\n+    }\n+}\n+\n+impl<'a> Iterator for OpDelimitedIter<'a> {\n+    type Item = OpDelimited<'a>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let res = self.peek();\n+        self.idx += 1;\n+        res\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.inner.len() + if self.delimited.is_some() { 2 } else { 0 };\n+        let remain = len.checked_sub(self.idx).unwrap_or(0);\n+        (remain, Some(remain))\n+    }\n+}\n+\n+impl<'a> MetaTemplate {\n+    pub(crate) fn iter(&self) -> impl Iterator<Item = &Op> {\n+        self.0.iter()\n+    }\n+\n+    pub(crate) fn iter_delimited(\n+        &'a self,\n+        delimited: Option<&'a Delimiter>,\n+    ) -> OpDelimitedIter<'a> {\n+        OpDelimitedIter { inner: &self.0, idx: 0, delimited }\n+    }\n+}\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum Op {\n@@ -47,6 +115,16 @@ impl PartialEq for Separator {\n     }\n }\n \n+impl Separator {\n+    pub(crate) fn tt_count(&self) -> usize {\n+        match self {\n+            Separator::Literal(_) => 1,\n+            Separator::Ident(_) => 1,\n+            Separator::Puncts(it) => it.len(),\n+        }\n+    }\n+}\n+\n pub(crate) fn parse_template(template: &tt::Subtree) -> Result<Vec<Op>, ParseError> {\n     parse_inner(&template, Mode::Template).into_iter().collect()\n }"}, {"sha": "5c641ebf28ee5f79132030f7ae3a4f7da9a5db0a", "filename": "crates/mbe/src/tests.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/91bf5fa827b2c4ef74cb68c172c79127115e394f/crates%2Fmbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bf5fa827b2c4ef74cb68c172c79127115e394f/crates%2Fmbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests.rs?ref=91bf5fa827b2c4ef74cb68c172c79127115e394f", "patch": "@@ -456,6 +456,17 @@ fn test_match_group_with_multichar_sep() {\n     .assert_expand_items(\"foo! (fn baz {true true} );\", \"fn baz () -> bool {true &&true}\");\n }\n \n+#[test]\n+fn test_match_group_with_multichar_sep2() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+            (fn $name:ident {$($i:literal)&&*} ) => ( fn $name() -> bool { $($i)&&*} );\n+        }\"#,\n+    )\n+    .assert_expand_items(\"foo! (fn baz {true && true} );\", \"fn baz () -> bool {true &&true}\");\n+}\n+\n #[test]\n fn test_match_group_zero_match() {\n     parse_macro(\n@@ -1267,6 +1278,18 @@ macro_rules! m {\n     .is_some());\n }\n \n+#[test]\n+fn test_match_is_not_greedy() {\n+    parse_macro(\n+        r#\"\n+macro_rules! foo {\n+    ($($i:ident $(,)*),*) => {};\n+}\n+\"#,\n+    )\n+    .assert_expand_items(r#\"foo!(a,b);\"#, r#\"\"#);\n+}\n+\n // The following tests are based on real world situations\n #[test]\n fn test_vec() {"}]}