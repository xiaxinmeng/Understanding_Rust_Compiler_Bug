{"sha": "98f8cce6db6c6c6660eeffee2b3903104e547ecf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZjhjY2U2ZGI2YzZjNjY2MGVlZmZlZTJiMzkwMzEwNGU1NDdlY2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-25T18:14:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-25T18:14:50Z"}, "message": "Auto merge of #82447 - Amanieu:legacy_const_generics, r=oli-obk\n\nAdd #[rustc_legacy_const_generics]\n\nThis is the first step towards removing `#[rustc_args_required_const]`: a new attribute is added which rewrites function calls of the form `func(a, b, c)` to `func::<{b}>(a, c)`. This allows previously stabilized functions in `stdarch` which use `rustc_args_required_const` to use const generics instead.\n\nThis new attribute is not intended to ever be stabilized, it is only intended for use in `stdarch` as a replacement for `#[rustc_args_required_const]`.\n\n```rust\n#[rustc_legacy_const_generics(1)]\npub fn foo<const Y: usize>(x: usize, z: usize) -> [usize; 3] {\n    [x, Y, z]\n}\n\nfn main() {\n    assert_eq!(foo(0 + 0, 1 + 1, 2 + 2), [0, 2, 4]);\n    assert_eq!(foo::<{1 + 1}>(0 + 0, 2 + 2), [0, 2, 4]);\n}\n```\n\nr? `@oli-obk`", "tree": {"sha": "0b7593868337147ef3b8b0fe6ca4125f8b28aa42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b7593868337147ef3b8b0fe6ca4125f8b28aa42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98f8cce6db6c6c6660eeffee2b3903104e547ecf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98f8cce6db6c6c6660eeffee2b3903104e547ecf", "html_url": "https://github.com/rust-lang/rust/commit/98f8cce6db6c6c6660eeffee2b3903104e547ecf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98f8cce6db6c6c6660eeffee2b3903104e547ecf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ab7c1d56f92ebc3c456a0c7c502ba1593e76f8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ab7c1d56f92ebc3c456a0c7c502ba1593e76f8c", "html_url": "https://github.com/rust-lang/rust/commit/0ab7c1d56f92ebc3c456a0c7c502ba1593e76f8c"}, {"sha": "00afbe70f2f5cb0b6455036f4b97537ff77f2052", "url": "https://api.github.com/repos/rust-lang/rust/commits/00afbe70f2f5cb0b6455036f4b97537ff77f2052", "html_url": "https://github.com/rust-lang/rust/commit/00afbe70f2f5cb0b6455036f4b97537ff77f2052"}], "stats": {"total": 433, "additions": 429, "deletions": 4}, "files": [{"sha": "82b41e13cccff4bf307fa13221bb2e05d94fe330", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/98f8cce6db6c6c6660eeffee2b3903104e547ecf/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f8cce6db6c6c6660eeffee2b3903104e547ecf/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=98f8cce6db6c6c6660eeffee2b3903104e547ecf", "patch": "@@ -9,7 +9,9 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n+use rustc_hir::definitions::DefPathData;\n use rustc_session::parse::feature_err;\n+use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{hygiene::ForLoopLoc, DUMMY_SP};\n@@ -42,8 +44,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 ExprKind::Tup(ref elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n                 ExprKind::Call(ref f, ref args) => {\n-                    let f = self.lower_expr(f);\n-                    hir::ExprKind::Call(f, self.lower_exprs(args))\n+                    if let Some(legacy_args) = self.resolver.legacy_const_generic_args(f) {\n+                        self.lower_legacy_const_generics((**f).clone(), args.clone(), &legacy_args)\n+                    } else {\n+                        let f = self.lower_expr(f);\n+                        hir::ExprKind::Call(f, self.lower_exprs(args))\n+                    }\n                 }\n                 ExprKind::MethodCall(ref seg, ref args, span) => {\n                     let hir_seg = self.arena.alloc(self.lower_path_segment(\n@@ -292,6 +298,54 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n+    fn lower_legacy_const_generics(\n+        &mut self,\n+        mut f: Expr,\n+        args: Vec<AstP<Expr>>,\n+        legacy_args_idx: &[usize],\n+    ) -> hir::ExprKind<'hir> {\n+        let path = match f.kind {\n+            ExprKind::Path(None, ref mut path) => path,\n+            _ => unreachable!(),\n+        };\n+\n+        // Split the arguments into const generics and normal arguments\n+        let mut real_args = vec![];\n+        let mut generic_args = vec![];\n+        for (idx, arg) in args.into_iter().enumerate() {\n+            if legacy_args_idx.contains(&idx) {\n+                let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n+                let node_id = self.resolver.next_node_id();\n+\n+                // Add a definition for the in-band const def.\n+                self.resolver.create_def(\n+                    parent_def_id,\n+                    node_id,\n+                    DefPathData::AnonConst,\n+                    ExpnId::root(),\n+                    arg.span,\n+                );\n+\n+                let anon_const = AnonConst { id: node_id, value: arg };\n+                generic_args.push(AngleBracketedArg::Arg(GenericArg::Const(anon_const)));\n+            } else {\n+                real_args.push(arg);\n+            }\n+        }\n+\n+        // Add generic args to the last element of the path.\n+        let last_segment = path.segments.last_mut().unwrap();\n+        assert!(last_segment.args.is_none());\n+        last_segment.args = Some(AstP(GenericArgs::AngleBracketed(AngleBracketedArgs {\n+            span: DUMMY_SP,\n+            args: generic_args,\n+        })));\n+\n+        // Now lower everything as normal.\n+        let f = self.lower_expr(&f);\n+        hir::ExprKind::Call(f, self.lower_exprs(&real_args))\n+    }\n+\n     /// Emit an error and lower `ast::ExprKind::Let(pat, scrutinee)` into:\n     /// ```rust\n     /// match scrutinee { pats => true, _ => false }"}, {"sha": "c564ada0395e9cddab97acb422584a30194f1492", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98f8cce6db6c6c6660eeffee2b3903104e547ecf/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f8cce6db6c6c6660eeffee2b3903104e547ecf/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=98f8cce6db6c6c6660eeffee2b3903104e547ecf", "patch": "@@ -175,6 +175,8 @@ pub trait ResolverAstLowering {\n \n     fn item_generics_num_lifetimes(&self, def: DefId, sess: &Session) -> usize;\n \n+    fn legacy_const_generic_args(&mut self, expr: &Expr) -> Option<Vec<usize>>;\n+\n     /// Obtains resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n "}, {"sha": "072062dd615d874942f0102884b342199bd17fd5", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98f8cce6db6c6c6660eeffee2b3903104e547ecf/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f8cce6db6c6c6660eeffee2b3903104e547ecf/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=98f8cce6db6c6c6660eeffee2b3903104e547ecf", "patch": "@@ -470,6 +470,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n \n     rustc_attr!(rustc_promotable, AssumedUsed, template!(Word), IMPL_DETAIL),\n     rustc_attr!(rustc_args_required_const, AssumedUsed, template!(List: \"N\"), INTERNAL_UNSTABLE),\n+    rustc_attr!(rustc_legacy_const_generics, AssumedUsed, template!(List: \"N\"), INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Layout related:"}, {"sha": "0f860d11dc21a551b7baa68ca42e6f1e47ab9c84", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98f8cce6db6c6c6660eeffee2b3903104e547ecf/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f8cce6db6c6c6660eeffee2b3903104e547ecf/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=98f8cce6db6c6c6660eeffee2b3903104e547ecf", "patch": "@@ -468,6 +468,10 @@ impl CStore {\n     pub fn num_def_ids(&self, cnum: CrateNum) -> usize {\n         self.get_crate_data(cnum).num_def_ids()\n     }\n+\n+    pub fn item_attrs(&self, def_id: DefId, sess: &Session) -> Vec<ast::Attribute> {\n+        self.get_crate_data(def_id.krate).get_item_attrs(def_id.index, sess).collect()\n+    }\n }\n \n impl CrateStore for CStore {"}, {"sha": "cf08881cd473da278458d0dcb849b8d1007ec1ec", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/98f8cce6db6c6c6660eeffee2b3903104e547ecf/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f8cce6db6c6c6660eeffee2b3903104e547ecf/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=98f8cce6db6c6c6660eeffee2b3903104e547ecf", "patch": "@@ -91,6 +91,8 @@ impl CheckAttrVisitor<'tcx> {\n                 self.check_rustc_allow_const_fn_unstable(hir_id, &attr, span, target)\n             } else if self.tcx.sess.check_name(attr, sym::naked) {\n                 self.check_naked(hir_id, attr, span, target)\n+            } else if self.tcx.sess.check_name(attr, sym::rustc_legacy_const_generics) {\n+                self.check_rustc_legacy_const_generics(&attr, span, target, item)\n             } else {\n                 // lint-only checks\n                 if self.tcx.sess.check_name(attr, sym::cold) {\n@@ -750,6 +752,105 @@ impl CheckAttrVisitor<'tcx> {\n         }\n     }\n \n+    /// Checks if `#[rustc_legacy_const_generics]` is applied to a function and has a valid argument.\n+    fn check_rustc_legacy_const_generics(\n+        &self,\n+        attr: &Attribute,\n+        span: &Span,\n+        target: Target,\n+        item: Option<ItemLike<'_>>,\n+    ) -> bool {\n+        let is_function = matches!(target, Target::Fn | Target::Method(..));\n+        if !is_function {\n+            self.tcx\n+                .sess\n+                .struct_span_err(attr.span, \"attribute should be applied to a function\")\n+                .span_label(*span, \"not a function\")\n+                .emit();\n+            return false;\n+        }\n+\n+        let list = match attr.meta_item_list() {\n+            // The attribute form is validated on AST.\n+            None => return false,\n+            Some(it) => it,\n+        };\n+\n+        let (decl, generics) = match item {\n+            Some(ItemLike::Item(Item {\n+                kind: ItemKind::Fn(FnSig { decl, .. }, generics, _),\n+                ..\n+            })) => (decl, generics),\n+            _ => bug!(\"should be a function item\"),\n+        };\n+\n+        for param in generics.params {\n+            match param.kind {\n+                hir::GenericParamKind::Const { .. } => {}\n+                _ => {\n+                    self.tcx\n+                        .sess\n+                        .struct_span_err(\n+                            attr.span,\n+                            \"#[rustc_legacy_const_generics] functions must \\\n+                             only have const generics\",\n+                        )\n+                        .span_label(param.span, \"non-const generic parameter\")\n+                        .emit();\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        if list.len() != generics.params.len() {\n+            self.tcx\n+                .sess\n+                .struct_span_err(\n+                    attr.span,\n+                    \"#[rustc_legacy_const_generics] must have one index for each generic parameter\",\n+                )\n+                .span_label(generics.span, \"generic parameters\")\n+                .emit();\n+            return false;\n+        }\n+\n+        let arg_count = decl.inputs.len() as u128 + generics.params.len() as u128;\n+        let mut invalid_args = vec![];\n+        for meta in list {\n+            if let Some(LitKind::Int(val, _)) = meta.literal().map(|lit| &lit.kind) {\n+                if *val >= arg_count {\n+                    let span = meta.span();\n+                    self.tcx\n+                        .sess\n+                        .struct_span_err(span, \"index exceeds number of arguments\")\n+                        .span_label(\n+                            span,\n+                            format!(\n+                                \"there {} only {} argument{}\",\n+                                if arg_count != 1 { \"are\" } else { \"is\" },\n+                                arg_count,\n+                                pluralize!(arg_count)\n+                            ),\n+                        )\n+                        .emit();\n+                    return false;\n+                }\n+            } else {\n+                invalid_args.push(meta.span());\n+            }\n+        }\n+\n+        if !invalid_args.is_empty() {\n+            self.tcx\n+                .sess\n+                .struct_span_err(invalid_args, \"arguments should be non-negative integers\")\n+                .emit();\n+            false\n+        } else {\n+            true\n+        }\n+    }\n+\n     /// Checks if `#[link_section]` is applied to a function or static.\n     fn check_link_section(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) {\n         match target {"}, {"sha": "6f24d7e9413518b6daf48b74a3b5d90fd5f28752", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98f8cce6db6c6c6660eeffee2b3903104e547ecf/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f8cce6db6c6c6660eeffee2b3903104e547ecf/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=98f8cce6db6c6c6660eeffee2b3903104e547ecf", "patch": "@@ -2326,8 +2326,22 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n             ExprKind::Call(ref callee, ref arguments) => {\n                 self.resolve_expr(callee, Some(expr));\n-                for argument in arguments {\n-                    self.resolve_expr(argument, None);\n+                let const_args = self.r.legacy_const_generic_args(callee).unwrap_or(Vec::new());\n+                for (idx, argument) in arguments.iter().enumerate() {\n+                    // Constant arguments need to be treated as AnonConst since\n+                    // that is how they will be later lowered to HIR.\n+                    if const_args.contains(&idx) {\n+                        self.with_constant_rib(\n+                            IsRepeatExpr::No,\n+                            argument.is_potential_trivial_const_param(),\n+                            None,\n+                            |this| {\n+                                this.resolve_expr(argument, None);\n+                            },\n+                        );\n+                    } else {\n+                        self.resolve_expr(argument, None);\n+                    }\n                 }\n             }\n             ExprKind::Type(ref type_expr, ref ty) => {"}, {"sha": "e63fd4ce6357db25926f89ac376eafde1eae13fa", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/98f8cce6db6c6c6660eeffee2b3903104e547ecf/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f8cce6db6c6c6660eeffee2b3903104e547ecf/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=98f8cce6db6c6c6660eeffee2b3903104e547ecf", "patch": "@@ -29,6 +29,7 @@ use rustc_ast::unwrap_or;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast::{self as ast, NodeId};\n use rustc_ast::{Crate, CRATE_NODE_ID};\n+use rustc_ast::{Expr, ExprKind, LitKind};\n use rustc_ast::{ItemKind, ModKind, Path};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n@@ -995,6 +996,8 @@ pub struct Resolver<'a> {\n     /// Some way to know that we are in a *trait* impl in `visit_assoc_item`.\n     /// FIXME: Replace with a more general AST map (together with some other fields).\n     trait_impl_items: FxHashSet<LocalDefId>,\n+\n+    legacy_const_generic_args: FxHashMap<DefId, Option<Vec<usize>>>,\n }\n \n /// Nothing really interesting here; it just provides memory for the rest of the crate.\n@@ -1076,6 +1079,10 @@ impl ResolverAstLowering for Resolver<'_> {\n         self.cstore().item_generics_num_lifetimes(def_id, sess)\n     }\n \n+    fn legacy_const_generic_args(&mut self, expr: &Expr) -> Option<Vec<usize>> {\n+        self.legacy_const_generic_args(expr)\n+    }\n+\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes> {\n         self.partial_res_map.get(&id).cloned()\n     }\n@@ -1316,6 +1323,7 @@ impl<'a> Resolver<'a> {\n             invocation_parents,\n             next_disambiguator: Default::default(),\n             trait_impl_items: Default::default(),\n+            legacy_const_generic_args: Default::default(),\n         };\n \n         let root_parent_scope = ParentScope::module(graph_root, &resolver);\n@@ -3308,6 +3316,61 @@ impl<'a> Resolver<'a> {\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n         if let Some(def_id) = def_id.as_local() { Some(self.def_id_to_span[def_id]) } else { None }\n     }\n+\n+    /// Checks if an expression refers to a function marked with\n+    /// `#[rustc_legacy_const_generics]` and returns the argument index list\n+    /// from the attribute.\n+    pub fn legacy_const_generic_args(&mut self, expr: &Expr) -> Option<Vec<usize>> {\n+        if let ExprKind::Path(None, path) = &expr.kind {\n+            // Don't perform legacy const generics rewriting if the path already\n+            // has generic arguments.\n+            if path.segments.last().unwrap().args.is_some() {\n+                return None;\n+            }\n+\n+            let partial_res = self.partial_res_map.get(&expr.id)?;\n+            if partial_res.unresolved_segments() != 0 {\n+                return None;\n+            }\n+\n+            if let Res::Def(def::DefKind::Fn, def_id) = partial_res.base_res() {\n+                // We only support cross-crate argument rewriting. Uses\n+                // within the same crate should be updated to use the new\n+                // const generics style.\n+                if def_id.is_local() {\n+                    return None;\n+                }\n+\n+                if let Some(v) = self.legacy_const_generic_args.get(&def_id) {\n+                    return v.clone();\n+                }\n+\n+                let parse_attrs = || {\n+                    let attrs = self.cstore().item_attrs(def_id, self.session);\n+                    let attr = attrs\n+                        .iter()\n+                        .find(|a| self.session.check_name(a, sym::rustc_legacy_const_generics))?;\n+                    let mut ret = vec![];\n+                    for meta in attr.meta_item_list()? {\n+                        match meta.literal()?.kind {\n+                            LitKind::Int(a, _) => {\n+                                ret.push(a as usize);\n+                            }\n+                            _ => panic!(\"invalid arg index\"),\n+                        }\n+                    }\n+                    Some(ret)\n+                };\n+\n+                // Cache the lookup to avoid parsing attributes for an iterm\n+                // multiple times.\n+                let ret = parse_attrs();\n+                self.legacy_const_generic_args.insert(def_id, ret.clone());\n+                return ret;\n+            }\n+        }\n+        None\n+    }\n }\n \n fn names_to_string(names: &[Symbol]) -> String {"}, {"sha": "6fe65a8a1cda1f4764efe66dea528fc2e637067c", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98f8cce6db6c6c6660eeffee2b3903104e547ecf/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f8cce6db6c6c6660eeffee2b3903104e547ecf/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=98f8cce6db6c6c6660eeffee2b3903104e547ecf", "patch": "@@ -981,6 +981,7 @@ symbols! {\n         rustc_layout,\n         rustc_layout_scalar_valid_range_end,\n         rustc_layout_scalar_valid_range_start,\n+        rustc_legacy_const_generics,\n         rustc_macro_transparency,\n         rustc_mir,\n         rustc_nonnull_optimization_guaranteed,"}, {"sha": "67352a2fbbb1cc689e3b0fb0939804c58a7d7981", "filename": "src/test/ui/auxiliary/legacy-const-generics.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98f8cce6db6c6c6660eeffee2b3903104e547ecf/src%2Ftest%2Fui%2Fauxiliary%2Flegacy-const-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f8cce6db6c6c6660eeffee2b3903104e547ecf/src%2Ftest%2Fui%2Fauxiliary%2Flegacy-const-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauxiliary%2Flegacy-const-generics.rs?ref=98f8cce6db6c6c6660eeffee2b3903104e547ecf", "patch": "@@ -0,0 +1,6 @@\n+#![feature(rustc_attrs)]\n+\n+#[rustc_legacy_const_generics(1)]\n+pub fn foo<const Y: usize>(x: usize, z: usize) -> [usize; 3] {\n+    [x, Y, z]\n+}"}, {"sha": "99508baeb0070b56d002896f8def14877ae83640", "filename": "src/test/ui/invalid/invalid-rustc_args_required_const-arguments.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/98f8cce6db6c6c6660eeffee2b3903104e547ecf/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_args_required_const-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f8cce6db6c6c6660eeffee2b3903104e547ecf/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_args_required_const-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_args_required_const-arguments.rs?ref=98f8cce6db6c6c6660eeffee2b3903104e547ecf", "previous_filename": "src/test/ui/invalid-rustc_args_required_const-arguments.rs"}, {"sha": "932344f0a33c5877fa1bfd357714e180bcc146ff", "filename": "src/test/ui/invalid/invalid-rustc_args_required_const-arguments.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/98f8cce6db6c6c6660eeffee2b3903104e547ecf/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_args_required_const-arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98f8cce6db6c6c6660eeffee2b3903104e547ecf/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_args_required_const-arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_args_required_const-arguments.stderr?ref=98f8cce6db6c6c6660eeffee2b3903104e547ecf", "previous_filename": "src/test/ui/invalid-rustc_args_required_const-arguments.stderr"}, {"sha": "3d8478f06db0ea0875c640774d7a3f371955ee0b", "filename": "src/test/ui/invalid/invalid-rustc_legacy_const_generics-arguments.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/98f8cce6db6c6c6660eeffee2b3903104e547ecf/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_legacy_const_generics-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f8cce6db6c6c6660eeffee2b3903104e547ecf/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_legacy_const_generics-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_legacy_const_generics-arguments.rs?ref=98f8cce6db6c6c6660eeffee2b3903104e547ecf", "patch": "@@ -0,0 +1,38 @@\n+#![feature(rustc_attrs)]\n+\n+#[rustc_legacy_const_generics(0)] //~ ERROR #[rustc_legacy_const_generics] must have one index for\n+fn foo1() {}\n+\n+#[rustc_legacy_const_generics(1)] //~ ERROR index exceeds number of arguments\n+fn foo2<const X: usize>() {}\n+\n+#[rustc_legacy_const_generics(2)] //~ ERROR index exceeds number of arguments\n+fn foo3<const X: usize>(_: u8) {}\n+\n+#[rustc_legacy_const_generics(a)] //~ ERROR arguments should be non-negative integers\n+fn foo4<const X: usize>() {}\n+\n+#[rustc_legacy_const_generics(1, a, 2, b)] //~ ERROR arguments should be non-negative integers\n+fn foo5<const X: usize, const Y: usize, const Z: usize, const W: usize>() {}\n+\n+#[rustc_legacy_const_generics(0)] //~ ERROR attribute should be applied to a function\n+struct S;\n+\n+#[rustc_legacy_const_generics(0usize)] //~ ERROR suffixed literals are not allowed in attributes\n+fn foo6<const X: usize>() {}\n+\n+extern {\n+    #[rustc_legacy_const_generics(1)] //~ ERROR attribute should be applied to a function\n+    fn foo7<const X: usize>(); //~ ERROR foreign items may not have const parameters\n+}\n+\n+#[rustc_legacy_const_generics(0)] //~ ERROR #[rustc_legacy_const_generics] functions must only have\n+fn foo8<X>() {}\n+\n+#[rustc_legacy_const_generics] //~ ERROR malformed `rustc_legacy_const_generics` attribute\n+fn bar1() {}\n+\n+#[rustc_legacy_const_generics = 1] //~ ERROR malformed `rustc_legacy_const_generics` attribute\n+fn bar2() {}\n+\n+fn main() {}"}, {"sha": "1f55a8e72d2cb29795b0c1dcc37ff071a5d4a166", "filename": "src/test/ui/invalid/invalid-rustc_legacy_const_generics-arguments.stderr", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/98f8cce6db6c6c6660eeffee2b3903104e547ecf/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_legacy_const_generics-arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98f8cce6db6c6c6660eeffee2b3903104e547ecf/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_legacy_const_generics-arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_legacy_const_generics-arguments.stderr?ref=98f8cce6db6c6c6660eeffee2b3903104e547ecf", "patch": "@@ -0,0 +1,87 @@\n+error: suffixed literals are not allowed in attributes\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:21:31\n+   |\n+LL | #[rustc_legacy_const_generics(0usize)]\n+   |                               ^^^^^^\n+   |\n+   = help: instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), use an unsuffixed version (`1`, `1.0`, etc.)\n+\n+error: malformed `rustc_legacy_const_generics` attribute input\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:32:1\n+   |\n+LL | #[rustc_legacy_const_generics]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[rustc_legacy_const_generics(N)]`\n+\n+error: malformed `rustc_legacy_const_generics` attribute input\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:35:1\n+   |\n+LL | #[rustc_legacy_const_generics = 1]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[rustc_legacy_const_generics(N)]`\n+\n+error: #[rustc_legacy_const_generics] must have one index for each generic parameter\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:3:1\n+   |\n+LL | #[rustc_legacy_const_generics(0)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | fn foo1() {}\n+   |        - generic parameters\n+\n+error: index exceeds number of arguments\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:6:31\n+   |\n+LL | #[rustc_legacy_const_generics(1)]\n+   |                               ^ there is only 1 argument\n+\n+error: index exceeds number of arguments\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:9:31\n+   |\n+LL | #[rustc_legacy_const_generics(2)]\n+   |                               ^ there are only 2 arguments\n+\n+error: arguments should be non-negative integers\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:12:31\n+   |\n+LL | #[rustc_legacy_const_generics(a)]\n+   |                               ^\n+\n+error: arguments should be non-negative integers\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:15:34\n+   |\n+LL | #[rustc_legacy_const_generics(1, a, 2, b)]\n+   |                                  ^     ^\n+\n+error: attribute should be applied to a function\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:18:1\n+   |\n+LL | #[rustc_legacy_const_generics(0)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | struct S;\n+   | --------- not a function\n+\n+error: #[rustc_legacy_const_generics] functions must only have const generics\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:29:1\n+   |\n+LL | #[rustc_legacy_const_generics(0)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | fn foo8<X>() {}\n+   |         - non-const generic parameter\n+\n+error: attribute should be applied to a function\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:25:5\n+   |\n+LL |     #[rustc_legacy_const_generics(1)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     fn foo7<const X: usize>();\n+   |     -------------------------- not a function\n+\n+error[E0044]: foreign items may not have const parameters\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:26:5\n+   |\n+LL |     fn foo7<const X: usize>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ can't have const parameters\n+   |\n+   = help: replace the const parameters with concrete consts\n+\n+error: aborting due to 12 previous errors\n+\n+For more information about this error, try `rustc --explain E0044`."}, {"sha": "538eee337cc6db3f2b0230f2ca19d126e711974b", "filename": "src/test/ui/legacy-const-generics-bad.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98f8cce6db6c6c6660eeffee2b3903104e547ecf/src%2Ftest%2Fui%2Flegacy-const-generics-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f8cce6db6c6c6660eeffee2b3903104e547ecf/src%2Ftest%2Fui%2Flegacy-const-generics-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flegacy-const-generics-bad.rs?ref=98f8cce6db6c6c6660eeffee2b3903104e547ecf", "patch": "@@ -0,0 +1,16 @@\n+// aux-build:legacy-const-generics.rs\n+\n+extern crate legacy_const_generics;\n+\n+fn foo<const N: usize>() {\n+    let a = 1;\n+    legacy_const_generics::foo(0, a, 2);\n+    //~^ ERROR attempt to use a non-constant value in a constant\n+\n+    legacy_const_generics::foo(0, N, 2);\n+\n+    legacy_const_generics::foo(0, N + 1, 2);\n+    //~^ ERROR generic parameters may not be used in const operations\n+}\n+\n+fn main() {}"}, {"sha": "5a44b8e70655352105a4694d256c60436b169032", "filename": "src/test/ui/legacy-const-generics-bad.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98f8cce6db6c6c6660eeffee2b3903104e547ecf/src%2Ftest%2Fui%2Flegacy-const-generics-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98f8cce6db6c6c6660eeffee2b3903104e547ecf/src%2Ftest%2Fui%2Flegacy-const-generics-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flegacy-const-generics-bad.stderr?ref=98f8cce6db6c6c6660eeffee2b3903104e547ecf", "patch": "@@ -0,0 +1,20 @@\n+error[E0435]: attempt to use a non-constant value in a constant\n+  --> $DIR/legacy-const-generics-bad.rs:7:35\n+   |\n+LL |     let a = 1;\n+   |     ----- help: consider using `const` instead of `let`: `const a`\n+LL |     legacy_const_generics::foo(0, a, 2);\n+   |                                   ^ non-constant value\n+\n+error: generic parameters may not be used in const operations\n+  --> $DIR/legacy-const-generics-bad.rs:12:35\n+   |\n+LL |     legacy_const_generics::foo(0, N + 1, 2);\n+   |                                   ^ cannot perform const operation using `N`\n+   |\n+   = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0435`."}, {"sha": "9abc72d98e6ce87147baf37184a86059d1f7e070", "filename": "src/test/ui/legacy-const-generics.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98f8cce6db6c6c6660eeffee2b3903104e547ecf/src%2Ftest%2Fui%2Flegacy-const-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f8cce6db6c6c6660eeffee2b3903104e547ecf/src%2Ftest%2Fui%2Flegacy-const-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flegacy-const-generics.rs?ref=98f8cce6db6c6c6660eeffee2b3903104e547ecf", "patch": "@@ -0,0 +1,18 @@\n+// aux-build:legacy-const-generics.rs\n+// run-pass\n+\n+#![feature(rustc_attrs)]\n+\n+extern crate legacy_const_generics;\n+\n+#[rustc_legacy_const_generics(1)]\n+pub fn bar<const Y: usize>(x: usize, z: usize) -> [usize; 3] {\n+    [x, Y, z]\n+}\n+\n+fn main() {\n+    assert_eq!(legacy_const_generics::foo(0 + 0, 1 + 1, 2 + 2), [0, 2, 4]);\n+    assert_eq!(legacy_const_generics::foo::<{1 + 1}>(0 + 0, 2 + 2), [0, 2, 4]);\n+    // FIXME: Only works cross-crate\n+    //assert_eq!(bar(0, 1, 2), [0, 1, 2]);\n+}"}]}