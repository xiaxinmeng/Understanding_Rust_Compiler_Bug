{"sha": "d3c4dbd85d63c8bdfa362d7cac8b3e8cbca51272", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYzRkYmQ4NWQ2M2M4YmRmYTM2MmQ3Y2FjOGIzZThjYmNhNTEyNzI=", "commit": {"author": {"name": "Daiki Ihara", "email": "sasurau4@gmail.com", "date": "2021-01-28T09:14:26Z"}, "committer": {"name": "Daiki Ihara", "email": "sasurau4@gmail.com", "date": "2021-02-05T13:12:31Z"}, "message": "Add suggest mu method for loop", "tree": {"sha": "94e4cd4211d024e633d9ea5d987df39fba0defa0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94e4cd4211d024e633d9ea5d987df39fba0defa0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3c4dbd85d63c8bdfa362d7cac8b3e8cbca51272", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3c4dbd85d63c8bdfa362d7cac8b3e8cbca51272", "html_url": "https://github.com/rust-lang/rust/commit/d3c4dbd85d63c8bdfa362d7cac8b3e8cbca51272", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3c4dbd85d63c8bdfa362d7cac8b3e8cbca51272/comments", "author": {"login": "sasurau4", "id": 13580199, "node_id": "MDQ6VXNlcjEzNTgwMTk5", "avatar_url": "https://avatars.githubusercontent.com/u/13580199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sasurau4", "html_url": "https://github.com/sasurau4", "followers_url": "https://api.github.com/users/sasurau4/followers", "following_url": "https://api.github.com/users/sasurau4/following{/other_user}", "gists_url": "https://api.github.com/users/sasurau4/gists{/gist_id}", "starred_url": "https://api.github.com/users/sasurau4/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sasurau4/subscriptions", "organizations_url": "https://api.github.com/users/sasurau4/orgs", "repos_url": "https://api.github.com/users/sasurau4/repos", "events_url": "https://api.github.com/users/sasurau4/events{/privacy}", "received_events_url": "https://api.github.com/users/sasurau4/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sasurau4", "id": 13580199, "node_id": "MDQ6VXNlcjEzNTgwMTk5", "avatar_url": "https://avatars.githubusercontent.com/u/13580199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sasurau4", "html_url": "https://github.com/sasurau4", "followers_url": "https://api.github.com/users/sasurau4/followers", "following_url": "https://api.github.com/users/sasurau4/following{/other_user}", "gists_url": "https://api.github.com/users/sasurau4/gists{/gist_id}", "starred_url": "https://api.github.com/users/sasurau4/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sasurau4/subscriptions", "organizations_url": "https://api.github.com/users/sasurau4/orgs", "repos_url": "https://api.github.com/users/sasurau4/repos", "events_url": "https://api.github.com/users/sasurau4/events{/privacy}", "received_events_url": "https://api.github.com/users/sasurau4/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e5d58fb420a487ae30f38141eccdc8d79fb8d58", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e5d58fb420a487ae30f38141eccdc8d79fb8d58", "html_url": "https://github.com/rust-lang/rust/commit/9e5d58fb420a487ae30f38141eccdc8d79fb8d58"}], "stats": {"total": 94, "additions": 85, "deletions": 9}, "files": [{"sha": "0467bf76afecc5251daaef68715de379e3a564a4", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 85, "deletions": 9, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d3c4dbd85d63c8bdfa362d7cac8b3e8cbca51272/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c4dbd85d63c8bdfa362d7cac8b3e8cbca51272/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=d3c4dbd85d63c8bdfa362d7cac8b3e8cbca51272", "patch": "@@ -376,15 +376,18 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     opt_assignment_rhs_span.and_then(|span| span.desugaring_kind());\n                                 match opt_desugaring_kind {\n                                     // on for loops, RHS points to the iterator part\n-                                    Some(DesugaringKind::ForLoop(_)) => Some((\n-                                        false,\n-                                        opt_assignment_rhs_span.unwrap(),\n-                                        format!(\n-                                            \"this iterator yields `{SIGIL}` {DESC}s\",\n-                                            SIGIL = pointer_sigil,\n-                                            DESC = pointer_desc\n-                                        ),\n-                                    )),\n+                                    Some(DesugaringKind::ForLoop(_)) => {\n+                                        self.suggest_similar_mut_method_for_for_loop(&mut err);\n+                                        Some((\n+                                            false,\n+                                            opt_assignment_rhs_span.unwrap(),\n+                                            format!(\n+                                                \"this iterator yields `{SIGIL}` {DESC}s\",\n+                                                SIGIL = pointer_sigil,\n+                                                DESC = pointer_desc\n+                                            ),\n+                                        ))\n+                                    }\n                                     // don't create labels for compiler-generated spans\n                                     Some(_) => None,\n                                     None => {\n@@ -537,6 +540,79 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         );\n     }\n \n+    // Attempt to search similar mutable assosiated items for suggestion.\n+    // In the future, attempt in all path but initially for RHS of for_loop\n+    fn suggest_similar_mut_method_for_for_loop(&self, err: &mut DiagnosticBuilder<'_>) {\n+        let hir = self.infcx.tcx.hir();\n+        let node = hir.item(self.mir_hir_id());\n+        use hir::{\n+            Expr,\n+            ExprKind::{Block, Call, DropTemps, Match, MethodCall},\n+        };\n+        if let hir::ItemKind::Fn(_, _, body_id) = node.kind {\n+            if let Block(\n+                hir::Block {\n+                    expr:\n+                        Some(Expr {\n+                            kind:\n+                                DropTemps(Expr {\n+                                    kind:\n+                                        Match(\n+                                            Expr {\n+                                                kind:\n+                                                    Call(\n+                                                        _,\n+                                                        [Expr {\n+                                                            kind: MethodCall(path_segment, ..),\n+                                                            hir_id,\n+                                                            ..\n+                                                        }, ..],\n+                                                    ),\n+                                                ..\n+                                            },\n+                                            ..,\n+                                        ),\n+                                    ..\n+                                }),\n+                            ..\n+                        }),\n+                    ..\n+                },\n+                _,\n+            ) = hir.body(body_id).value.kind\n+            {\n+                let opt_suggestions = path_segment\n+                    .hir_id\n+                    .map(|path_hir_id| self.infcx.tcx.typeck(path_hir_id.owner))\n+                    .and_then(|typeck| typeck.type_dependent_def_id(*hir_id))\n+                    .and_then(|def_id| self.infcx.tcx.impl_of_method(def_id))\n+                    .map(|def_id| self.infcx.tcx.associated_items(def_id))\n+                    .map(|assoc_items| {\n+                        assoc_items\n+                            .in_definition_order()\n+                            .map(|assoc_item_def| assoc_item_def.ident)\n+                            .filter(|&ident| {\n+                                let original_method_ident = path_segment.ident;\n+                                original_method_ident != ident\n+                                    && ident\n+                                        .as_str()\n+                                        .starts_with(&original_method_ident.name.to_string())\n+                            })\n+                            .map(|ident| format!(\"{}()\", ident))\n+                    });\n+\n+                if let Some(suggestions) = opt_suggestions {\n+                    err.span_suggestions(\n+                        path_segment.ident.span,\n+                        &format!(\"use mutable method\"),\n+                        suggestions,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        };\n+    }\n+\n     /// Targeted error when encountering an `FnMut` closure where an `Fn` closure was expected.\n     fn expected_fn_found_fn_mut_call(&self, err: &mut DiagnosticBuilder<'_>, sp: Span, act: &str) {\n         err.span_label(sp, format!(\"cannot {}\", act));"}]}