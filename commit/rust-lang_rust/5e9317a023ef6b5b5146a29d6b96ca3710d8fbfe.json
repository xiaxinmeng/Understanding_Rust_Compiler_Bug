{"sha": "5e9317a023ef6b5b5146a29d6b96ca3710d8fbfe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlOTMxN2EwMjNlZjZiNWI1MTQ2YTI5ZDZiOTZjYTM3MTBkOGZiZmU=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2019-06-15T18:51:13Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-02-21T18:41:22Z"}, "message": "Put the check into its own function", "tree": {"sha": "3f2934f9582d775a2bccb72ed5d9eb08ef7032a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f2934f9582d775a2bccb72ed5d9eb08ef7032a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e9317a023ef6b5b5146a29d6b96ca3710d8fbfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e9317a023ef6b5b5146a29d6b96ca3710d8fbfe", "html_url": "https://github.com/rust-lang/rust/commit/5e9317a023ef6b5b5146a29d6b96ca3710d8fbfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e9317a023ef6b5b5146a29d6b96ca3710d8fbfe/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f40388292765477881d95a84eb11ef47f8a69500", "url": "https://api.github.com/repos/rust-lang/rust/commits/f40388292765477881d95a84eb11ef47f8a69500", "html_url": "https://github.com/rust-lang/rust/commit/f40388292765477881d95a84eb11ef47f8a69500"}], "stats": {"total": 133, "additions": 70, "deletions": 63}, "files": [{"sha": "603d877cf53fd63586465d0d59569c5a263b9236", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 70, "deletions": 63, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/5e9317a023ef6b5b5146a29d6b96ca3710d8fbfe/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9317a023ef6b5b5146a29d6b96ca3710d8fbfe/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=5e9317a023ef6b5b5146a29d6b96ca3710d8fbfe", "patch": "@@ -425,80 +425,87 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n \n     for_item(tcx, item).with_fcx(|fcx, _| {\n         check_where_clauses(tcx, fcx, item.span, trait_def_id, None);\n+        check_associated_type_defaults(fcx, trait_def_id);\n \n-        // Type-check associated type defaults (if there are any):\n-        // Assuming the defaults are used, check that all predicates (bounds on\n-        // the assoc type and where clauses on the trait) hold.\n-\n-        let substs = InternalSubsts::identity_for_item(tcx, trait_def_id);\n-\n-        // For all assoc. types with defaults, build a map from\n-        // `<Self as Trait<...>>::Assoc` to the default type.\n-        let map = tcx.associated_items(trait_def_id)\n-            .filter_map(|item| {\n-                if item.kind == ty::AssocKind::Type && item.defaultness.has_value() {\n-                    // `<Self as Trait<...>>::Assoc`\n-                    let proj = ty::ProjectionTy {\n-                        substs,\n-                        item_def_id: item.def_id,\n-                    };\n-                    let default_ty = tcx.type_of(item.def_id);\n-                    debug!(\"assoc. type default mapping: {} -> {}\", proj, default_ty);\n-                    Some((proj, default_ty))\n-                } else {\n-                    None\n-                }\n-            })\n-            .collect::<FxHashMap<_, _>>();\n-\n-        struct DefaultNormalizer<'tcx> {\n-            tcx: TyCtxt<'tcx>,\n-            map: FxHashMap<ty::ProjectionTy<'tcx>, Ty<'tcx>>,\n-        }\n+        vec![]\n+    });\n+}\n \n-        impl<'tcx> ty::fold::TypeFolder<'tcx> for DefaultNormalizer<'tcx> {\n-            fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n-                self.tcx\n+/// Checks all associated type defaults of trait `trait_def_id`.\n+///\n+/// Assuming the defaults are used, check that all predicates (bounds on the\n+/// assoc type and where clauses on the trait) hold.\n+fn check_associated_type_defaults(\n+    fcx: &FnCtxt<'_, '_>,\n+    trait_def_id: DefId,\n+) {\n+    let tcx = fcx.tcx;\n+    let substs = InternalSubsts::identity_for_item(tcx, trait_def_id);\n+\n+    // For all assoc. types with defaults, build a map from\n+    // `<Self as Trait<...>>::Assoc` to the default type.\n+    let map = tcx.associated_items(trait_def_id)\n+        .filter_map(|item| {\n+            if item.kind == ty::AssocKind::Type && item.defaultness.has_value() {\n+                // `<Self as Trait<...>>::Assoc`\n+                let proj = ty::ProjectionTy {\n+                    substs,\n+                    item_def_id: item.def_id,\n+                };\n+                let default_ty = tcx.type_of(item.def_id);\n+                debug!(\"assoc. type default mapping: {} -> {}\", proj, default_ty);\n+                Some((proj, default_ty))\n+            } else {\n+                None\n             }\n+        })\n+        .collect::<FxHashMap<_, _>>();\n \n-            fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-                match t.sty {\n-                    ty::Projection(proj_ty) => {\n-                        if let Some(default) = self.map.get(&proj_ty) {\n-                            default\n-                        } else {\n-                            t.super_fold_with(self)\n-                        }\n+    struct DefaultNormalizer<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        map: FxHashMap<ty::ProjectionTy<'tcx>, Ty<'tcx>>,\n+    }\n+\n+    impl<'tcx> ty::fold::TypeFolder<'tcx> for DefaultNormalizer<'tcx> {\n+        fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+            self.tcx\n+        }\n+\n+        fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+            match t.sty {\n+                ty::Projection(proj_ty) => {\n+                    if let Some(default) = self.map.get(&proj_ty) {\n+                        default\n+                    } else {\n+                        t.super_fold_with(self)\n                     }\n-                    _ => t.super_fold_with(self),\n                 }\n+                _ => t.super_fold_with(self),\n             }\n         }\n+    }\n \n-        // Now take all predicates defined on the trait, replace any mention of\n-        // the assoc. types with their default, and prove them.\n-        // We only consider predicates that directly mention the assoc. type.\n-        let mut norm = DefaultNormalizer { tcx, map };\n-        let predicates = fcx.tcx.predicates_of(trait_def_id);\n-        for &(orig_pred, span) in predicates.predicates.iter() {\n-            let pred = orig_pred.fold_with(&mut norm);\n-            if pred != orig_pred {\n-                // Mentions one of the defaulted assoc. types\n-                debug!(\"default suitability check: proving predicate: {} -> {}\", orig_pred, pred);\n-                let pred = fcx.normalize_associated_types_in(span, &pred);\n-                let cause = traits::ObligationCause::new(\n-                    span,\n-                    fcx.body_id,\n-                    traits::ItemObligation(trait_def_id),\n-                );\n-                let obligation = traits::Obligation::new(cause, fcx.param_env, pred);\n+    // Now take all predicates defined on the trait, replace any mention of\n+    // the assoc. types with their default, and prove them.\n+    // We only consider predicates that directly mention the assoc. type.\n+    let mut norm = DefaultNormalizer { tcx, map };\n+    let predicates = fcx.tcx.predicates_of(trait_def_id);\n+    for &(orig_pred, span) in predicates.predicates.iter() {\n+        let pred = orig_pred.fold_with(&mut norm);\n+        if pred != orig_pred {\n+            // Mentions one of the defaulted assoc. types\n+            debug!(\"default suitability check: proving predicate: {} -> {}\", orig_pred, pred);\n+            let pred = fcx.normalize_associated_types_in(span, &pred);\n+            let cause = traits::ObligationCause::new(\n+                span,\n+                fcx.body_id,\n+                traits::ItemObligation(trait_def_id),\n+            );\n+            let obligation = traits::Obligation::new(cause, fcx.param_env, pred);\n \n-                fcx.register_predicate(obligation);\n-            }\n+            fcx.register_predicate(obligation);\n         }\n-\n-        vec![]\n-    });\n+    }\n }\n \n fn check_item_fn(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {"}]}