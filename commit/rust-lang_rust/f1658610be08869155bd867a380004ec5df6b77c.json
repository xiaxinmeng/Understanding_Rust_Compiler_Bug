{"sha": "f1658610be08869155bd867a380004ec5df6b77c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNjU4NjEwYmUwODg2OTE1NWJkODY3YTM4MDAwNGVjNWRmNmI3N2M=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-01-27T22:41:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-01-28T00:41:49Z"}, "message": "Rollup merge of #39284 - alexcrichton:manifesting, r=brson\n\nrustbuild: Add manifest generation in-tree\n\nThis commit adds a new tool, `build-manifest`, which is used to generate a\ndistribution manifest of all produced artifacts. This tool is intended to\nreplace the `build-rust-manifest.py` script that's currently located on the\nbuildmaster. The intention is that we'll have a builder which periodically:\n\n* Downloads all artifacts for a commit\n* Runs `./x.py dist hash-and-sign`. This will generate `sha256` and `asc` files\n  as well as TOML manifests.\n* Upload all generated hashes and manifests to the directory the artifacts came\n  from.\n* Upload *all* artifacts (tarballs and hashes and manifests) to an archived\n  location.\n* If necessary, upload all artifacts to the main location.\n\nThis script is intended to just be the second step here where orchestrating\nuploads and such will all happen externally from the build system itself.\n\ncc #38531", "tree": {"sha": "d190e6351a6bc27b32d1bd04ffbb1b2722edfbd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d190e6351a6bc27b32d1bd04ffbb1b2722edfbd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1658610be08869155bd867a380004ec5df6b77c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1658610be08869155bd867a380004ec5df6b77c", "html_url": "https://github.com/rust-lang/rust/commit/f1658610be08869155bd867a380004ec5df6b77c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1658610be08869155bd867a380004ec5df6b77c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2a3074fb3ae6c1e7f0ccb6b111f3e16f9312f8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2a3074fb3ae6c1e7f0ccb6b111f3e16f9312f8f", "html_url": "https://github.com/rust-lang/rust/commit/a2a3074fb3ae6c1e7f0ccb6b111f3e16f9312f8f"}, {"sha": "9e8785f01757a50e321e85adeb659a9aff6fc00e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e8785f01757a50e321e85adeb659a9aff6fc00e", "html_url": "https://github.com/rust-lang/rust/commit/9e8785f01757a50e321e85adeb659a9aff6fc00e"}], "stats": {"total": 513, "additions": 512, "deletions": 1}, "files": [{"sha": "93bbf0f227b1ba691d6500180fbdaa8e72151315", "filename": "src/Cargo.lock", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1658610be08869155bd867a380004ec5df6b77c/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f1658610be08869155bd867a380004ec5df6b77c/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=f1658610be08869155bd867a380004ec5df6b77c", "patch": "@@ -50,6 +50,14 @@ dependencies = [\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"build-manifest\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"build_helper\"\n version = \"0.1.0\""}, {"sha": "0db26ea5ae021ae7219884994b9dbc0a025c8853", "filename": "src/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1658610be08869155bd867a380004ec5df6b77c/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f1658610be08869155bd867a380004ec5df6b77c/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=f1658610be08869155bd867a380004ec5df6b77c", "patch": "@@ -10,6 +10,7 @@ members = [\n   \"tools/linkchecker\",\n   \"tools/rustbook\",\n   \"tools/tidy\",\n+  \"tools/build-manifest\",\n ]\n \n # Curiously, compiletest will segfault if compiled with opt-level=3 on 64-bit"}, {"sha": "e035f8157ffde9a6d6ecb22415fd97dbe8d139f5", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f1658610be08869155bd867a380004ec5df6b77c/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1658610be08869155bd867a380004ec5df6b77c/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=f1658610be08869155bd867a380004ec5df6b77c", "patch": "@@ -78,6 +78,11 @@ pub struct Config {\n     pub cargo: Option<PathBuf>,\n     pub local_rebuild: bool,\n \n+    // dist misc\n+    pub dist_sign_folder: Option<PathBuf>,\n+    pub dist_upload_addr: Option<String>,\n+    pub dist_gpg_password_file: Option<PathBuf>,\n+\n     // libstd features\n     pub debug_jemalloc: bool,\n     pub use_jemalloc: bool,\n@@ -123,6 +128,7 @@ struct TomlConfig {\n     llvm: Option<Llvm>,\n     rust: Option<Rust>,\n     target: Option<HashMap<String, TomlTarget>>,\n+    dist: Option<Dist>,\n }\n \n /// TOML representation of various global build decisions.\n@@ -166,6 +172,13 @@ struct Llvm {\n     targets: Option<String>,\n }\n \n+#[derive(RustcDecodable, Default, Clone)]\n+struct Dist {\n+    sign_folder: Option<String>,\n+    gpg_password_file: Option<String>,\n+    upload_addr: Option<String>,\n+}\n+\n #[derive(RustcDecodable)]\n enum StringOrBool {\n     String(String),\n@@ -352,6 +365,12 @@ impl Config {\n             }\n         }\n \n+        if let Some(ref t) = toml.dist {\n+            config.dist_sign_folder = t.sign_folder.clone().map(PathBuf::from);\n+            config.dist_gpg_password_file = t.gpg_password_file.clone().map(PathBuf::from);\n+            config.dist_upload_addr = t.upload_addr.clone();\n+        }\n+\n         return config\n     }\n "}, {"sha": "a53419ad7fd780a28b41fcf6433a5081510187bc", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f1658610be08869155bd867a380004ec5df6b77c/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/f1658610be08869155bd867a380004ec5df6b77c/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=f1658610be08869155bd867a380004ec5df6b77c", "patch": "@@ -242,3 +242,33 @@\n # that this option only makes sense for MUSL targets that produce statically\n # linked binaries\n #musl-root = \"...\"\n+\n+# =============================================================================\n+# Distribution options\n+#\n+# These options are related to distribution, mostly for the Rust project itself.\n+# You probably won't need to concern yourself with any of these options\n+# =============================================================================\n+[dist]\n+\n+# This is the folder of artifacts that the build system will sign. All files in\n+# this directory will be signed with the default gpg key using the system `gpg`\n+# binary. The `asc` and `sha256` files will all be output into the standard dist\n+# output folder (currently `build/dist`)\n+#\n+# This folder should be populated ahead of time before the build system is\n+# invoked.\n+#sign-folder = \"path/to/folder/to/sign\"\n+\n+# This is a file which contains the password of the default gpg key. This will\n+# be passed to `gpg` down the road when signing all files in `sign-folder`\n+# above. This should be stored in plaintext.\n+#gpg-password-file = \"path/to/gpg/password\"\n+\n+# The remote address that all artifacts will eventually be uploaded to. The\n+# build system generates manifests which will point to these urls, and for the\n+# manifests to be correct they'll have to have the right URLs encoded.\n+#\n+# Note that this address should not contain a trailing slash as file names will\n+# be appended to it.\n+#upload-addr = \"https://example.com/folder\""}, {"sha": "71a5f313bbd26257d5b6f384dd60ca298399c222", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f1658610be08869155bd867a380004ec5df6b77c/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1658610be08869155bd867a380004ec5df6b77c/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=f1658610be08869155bd867a380004ec5df6b77c", "patch": "@@ -22,7 +22,7 @@ use std::env;\n use std::fs::{self, File};\n use std::io::{Read, Write};\n use std::path::{PathBuf, Path};\n-use std::process::Command;\n+use std::process::{Command, Stdio};\n \n use build_helper::output;\n \n@@ -876,3 +876,34 @@ fn add_env(build: &Build, cmd: &mut Command, target: &str) {\n        cmd.env(\"CFG_PLATFORM\", \"x86\");\n     }\n }\n+\n+pub fn hash_and_sign(build: &Build) {\n+    let compiler = Compiler::new(0, &build.config.build);\n+    let mut cmd = build.tool_cmd(&compiler, \"build-manifest\");\n+    let sign = build.config.dist_sign_folder.as_ref().unwrap_or_else(|| {\n+        panic!(\"\\n\\nfailed to specify `dist.sign-folder` in `config.toml`\\n\\n\")\n+    });\n+    let addr = build.config.dist_upload_addr.as_ref().unwrap_or_else(|| {\n+        panic!(\"\\n\\nfailed to specify `dist.upload-addr` in `config.toml`\\n\\n\")\n+    });\n+    let file = build.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n+        panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n+    });\n+    let mut pass = String::new();\n+    t!(t!(File::open(&file)).read_to_string(&mut pass));\n+\n+    let today = output(Command::new(\"date\").arg(\"+%Y-%m-%d\"));\n+\n+    cmd.arg(sign);\n+    cmd.arg(distdir(build));\n+    cmd.arg(today.trim());\n+    cmd.arg(package_vers(build));\n+    cmd.arg(addr);\n+\n+    t!(fs::create_dir_all(distdir(build)));\n+\n+    let mut child = t!(cmd.stdin(Stdio::piped()).spawn());\n+    t!(child.stdin.take().unwrap().write_all(pass.as_bytes()));\n+    let status = t!(child.wait());\n+    assert!(status.success());\n+}"}, {"sha": "3932a7cf8c56376c32af9a2a6938abcf9a31cc75", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1658610be08869155bd867a380004ec5df6b77c/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1658610be08869155bd867a380004ec5df6b77c/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=f1658610be08869155bd867a380004ec5df6b77c", "patch": "@@ -513,6 +513,9 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.build(\"tool-compiletest\", \"src/tools/compiletest\")\n          .dep(|s| s.name(\"libtest\"))\n          .run(move |s| compile::tool(build, s.stage, s.target, \"compiletest\"));\n+    rules.build(\"tool-build-manifest\", \"src/tools/build-manifest\")\n+         .dep(|s| s.name(\"libstd\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"build-manifest\"));\n \n     // ========================================================================\n     // Documentation targets\n@@ -633,6 +636,13 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .dep(|d| d.name(\"dist-cargo\"))\n          .run(move |s| dist::extended(build, s.stage, s.target));\n \n+    rules.dist(\"dist-sign\", \"hash-and-sign\")\n+         .host(true)\n+         .only_build(true)\n+         .only_host_build(true)\n+         .dep(move |s| s.name(\"tool-build-manifest\").target(&build.config.build).stage(0))\n+         .run(move |_| dist::hash_and_sign(build));\n+\n     rules.verify();\n     return rules;\n }"}, {"sha": "4b876753b1fea48e92a80fe5a59a4eda790a407b", "filename": "src/tools/build-manifest/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1658610be08869155bd867a380004ec5df6b77c/src%2Ftools%2Fbuild-manifest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f1658610be08869155bd867a380004ec5df6b77c/src%2Ftools%2Fbuild-manifest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2FCargo.toml?ref=f1658610be08869155bd867a380004ec5df6b77c", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"build-manifest\"\n+version = \"0.1.0\"\n+authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n+\n+[dependencies]\n+toml = \"0.1\"\n+rustc-serialize = \"0.3\""}, {"sha": "8c15a6630a33c9139787177ed56a99b74cbc6449", "filename": "src/tools/build-manifest/src/main.rs", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/f1658610be08869155bd867a380004ec5df6b77c/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1658610be08869155bd867a380004ec5df6b77c/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=f1658610be08869155bd867a380004ec5df6b77c", "patch": "@@ -0,0 +1,404 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate toml;\n+extern crate rustc_serialize;\n+\n+use std::collections::HashMap;\n+use std::env;\n+use std::fs::File;\n+use std::io::{self, Read, Write};\n+use std::path::{PathBuf, Path};\n+use std::process::{Command, Stdio};\n+\n+static HOSTS: &'static [&'static str] = &[\n+    \"aarch64-unknown-linux-gnu\",\n+    \"arm-unknown-linux-gnueabi\",\n+    \"arm-unknown-linux-gnueabihf\",\n+    \"armv7-unknown-linux-gnueabihf\",\n+    \"i686-apple-darwin\",\n+    \"i686-pc-windows-gnu\",\n+    \"i686-pc-windows-msvc\",\n+    \"i686-unknown-linux-gnu\",\n+    \"mips-unknown-linux-gnu\",\n+    \"mips64-unknown-linux-gnuabi64\",\n+    \"mips64el-unknown-linux-gnuabi64\",\n+    \"mipsel-unknown-linux-gnu\",\n+    \"powerpc-unknown-linux-gnu\",\n+    \"powerpc64-unknown-linux-gnu\",\n+    \"powerpc64le-unknown-linux-gnu\",\n+    \"s390x-unknown-linux-gnu\",\n+    \"x86_64-apple-darwin\",\n+    \"x86_64-pc-windows-gnu\",\n+    \"x86_64-pc-windows-msvc\",\n+    \"x86_64-unknown-freebsd\",\n+    \"x86_64-unknown-linux-gnu\",\n+    \"x86_64-unknown-netbsd\",\n+];\n+\n+static TARGETS: &'static [&'static str] = &[\n+    \"aarch64-apple-ios\",\n+    \"aarch64-linux-android\",\n+    \"aarch64-unknown-linux-gnu\",\n+    \"arm-linux-androideabi\",\n+    \"arm-unknown-linux-gnueabi\",\n+    \"arm-unknown-linux-gnueabihf\",\n+    \"arm-unknown-linux-musleabi\",\n+    \"arm-unknown-linux-musleabihf\",\n+    \"armv7-apple-ios\",\n+    \"armv7-linux-androideabi\",\n+    \"armv7-unknown-linux-gnueabihf\",\n+    \"armv7-unknown-linux-musleabihf\",\n+    \"armv7s-apple-ios\",\n+    \"asmjs-unknown-emscripten\",\n+    \"i386-apple-ios\",\n+    \"i586-pc-windows-msvc\",\n+    \"i586-unknown-linux-gnu\",\n+    \"i686-apple-darwin\",\n+    \"i686-linux-android\",\n+    \"i686-pc-windows-gnu\",\n+    \"i686-pc-windows-msvc\",\n+    \"i686-unknown-freebsd\",\n+    \"i686-unknown-linux-gnu\",\n+    \"i686-unknown-linux-musl\",\n+    \"mips-unknown-linux-gnu\",\n+    \"mips-unknown-linux-musl\",\n+    \"mips64-unknown-linux-gnuabi64\",\n+    \"mips64el-unknown-linux-gnuabi64\",\n+    \"mipsel-unknown-linux-gnu\",\n+    \"mipsel-unknown-linux-musl\",\n+    \"powerpc-unknown-linux-gnu\",\n+    \"powerpc64-unknown-linux-gnu\",\n+    \"powerpc64le-unknown-linux-gnu\",\n+    \"s390x-unknown-linux-gnu\",\n+    \"wasm32-unknown-emscripten\",\n+    \"x86_64-apple-darwin\",\n+    \"x86_64-apple-ios\",\n+    \"x86_64-pc-windows-gnu\",\n+    \"x86_64-pc-windows-msvc\",\n+    \"x86_64-rumprun-netbsd\",\n+    \"x86_64-unknown-freebsd\",\n+    \"x86_64-unknown-linux-gnu\",\n+    \"x86_64-unknown-linux-musl\",\n+    \"x86_64-unknown-netbsd\",\n+];\n+\n+static MINGW: &'static [&'static str] = &[\n+    \"i686-pc-windows-gnu\",\n+    \"x86_64-pc-windows-gnu\",\n+];\n+\n+#[derive(RustcEncodable)]\n+struct Manifest {\n+    manifest_version: String,\n+    date: String,\n+    pkg: HashMap<String, Package>,\n+}\n+\n+#[derive(RustcEncodable)]\n+struct Package {\n+    version: String,\n+    target: HashMap<String, Target>,\n+}\n+\n+#[derive(RustcEncodable)]\n+struct Target {\n+    available: bool,\n+    url: Option<String>,\n+    hash: Option<String>,\n+    components: Option<Vec<Component>>,\n+    extensions: Option<Vec<Component>>,\n+}\n+\n+#[derive(RustcEncodable)]\n+struct Component {\n+    pkg: String,\n+    target: String,\n+}\n+\n+macro_rules! t {\n+    ($e:expr) => (match $e {\n+        Ok(e) => e,\n+        Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n+    })\n+}\n+\n+struct Builder {\n+    channel: String,\n+    input: PathBuf,\n+    output: PathBuf,\n+    gpg_passphrase: String,\n+    digests: HashMap<String, String>,\n+    s3_address: String,\n+    date: String,\n+    rust_version: String,\n+    cargo_version: String,\n+}\n+\n+fn main() {\n+    let mut args = env::args().skip(1);\n+    let input = PathBuf::from(args.next().unwrap());\n+    let output = PathBuf::from(args.next().unwrap());\n+    let date = args.next().unwrap();\n+    let channel = args.next().unwrap();\n+    let s3_address = args.next().unwrap();\n+    let mut passphrase = String::new();\n+    t!(io::stdin().read_to_string(&mut passphrase));\n+\n+    Builder {\n+        channel: channel,\n+        input: input,\n+        output: output,\n+        gpg_passphrase: passphrase,\n+        digests: HashMap::new(),\n+        s3_address: s3_address,\n+        date: date,\n+        rust_version: String::new(),\n+        cargo_version: String::new(),\n+    }.build();\n+}\n+\n+impl Builder {\n+    fn build(&mut self) {\n+        self.rust_version = self.version(\"rust\", \"x86_64-unknown-linux-gnu\");\n+        self.cargo_version = self.version(\"cargo\", \"x86_64-unknown-linux-gnu\");\n+\n+        self.digest_and_sign();\n+        let manifest = self.build_manifest();\n+        let manifest = toml::encode(&manifest).to_string();\n+\n+        let filename = format!(\"channel-rust-{}.toml\", self.channel);\n+        self.write_manifest(&manifest, &filename);\n+\n+        if self.channel != \"beta\" && self.channel != \"nightly\" {\n+            self.write_manifest(&manifest, \"channel-rust-stable.toml\");\n+        }\n+    }\n+\n+    fn digest_and_sign(&mut self) {\n+        for file in t!(self.input.read_dir()).map(|e| t!(e).path()) {\n+            let filename = file.file_name().unwrap().to_str().unwrap();\n+            let digest = self.hash(&file);\n+            self.sign(&file);\n+            assert!(self.digests.insert(filename.to_string(), digest).is_none());\n+        }\n+    }\n+\n+    fn build_manifest(&mut self) -> Manifest {\n+        let mut manifest = Manifest {\n+            manifest_version: \"2\".to_string(),\n+            date: self.date.to_string(),\n+            pkg: HashMap::new(),\n+        };\n+\n+        self.package(\"rustc\", &mut manifest.pkg, HOSTS);\n+        self.package(\"cargo\", &mut manifest.pkg, HOSTS);\n+        self.package(\"rust-mingw\", &mut manifest.pkg, MINGW);\n+        self.package(\"rust-std\", &mut manifest.pkg, TARGETS);\n+        self.package(\"rust-docs\", &mut manifest.pkg, TARGETS);\n+        self.package(\"rust-src\", &mut manifest.pkg, &[\"*\"]);\n+\n+        let mut pkg = Package {\n+            version: self.cached_version(\"rust\").to_string(),\n+            target: HashMap::new(),\n+        };\n+        for host in HOSTS {\n+            let filename = self.filename(\"rust\", host);\n+            let digest = match self.digests.remove(&filename) {\n+                Some(digest) => digest,\n+                None => {\n+                    pkg.target.insert(host.to_string(), Target {\n+                        available: false,\n+                        url: None,\n+                        hash: None,\n+                        components: None,\n+                        extensions: None,\n+                    });\n+                    continue\n+                }\n+            };\n+            let mut components = Vec::new();\n+            let mut extensions = Vec::new();\n+\n+            // rustc/rust-std/cargo are all required, and so is rust-mingw if it's\n+            // available for the target.\n+            components.extend(vec![\n+                Component { pkg: \"rustc\".to_string(), target: host.to_string() },\n+                Component { pkg: \"rust-std\".to_string(), target: host.to_string() },\n+                Component { pkg: \"cargo\".to_string(), target: host.to_string() },\n+            ]);\n+            if host.contains(\"pc-windows-gnu\") {\n+                components.push(Component {\n+                    pkg: \"rust-mingw\".to_string(),\n+                    target: host.to_string(),\n+                });\n+            }\n+\n+            // Docs, other standard libraries, and the source package are all\n+            // optional.\n+            extensions.push(Component {\n+                pkg: \"rust-docs\".to_string(),\n+                target: host.to_string(),\n+            });\n+            for target in TARGETS {\n+                if target != host {\n+                    extensions.push(Component {\n+                        pkg: \"rust-std\".to_string(),\n+                        target: target.to_string(),\n+                    });\n+                }\n+            }\n+            extensions.push(Component {\n+                pkg: \"rust-src\".to_string(),\n+                target: \"*\".to_string(),\n+            });\n+\n+            pkg.target.insert(host.to_string(), Target {\n+                available: true,\n+                url: Some(self.url(\"rust\", host)),\n+                hash: Some(to_hex(digest.as_ref())),\n+                components: Some(components),\n+                extensions: Some(extensions),\n+            });\n+        }\n+        manifest.pkg.insert(\"rust\".to_string(), pkg);\n+\n+        return manifest\n+    }\n+\n+    fn package(&mut self,\n+               pkgname: &str,\n+               dst: &mut HashMap<String, Package>,\n+               targets: &[&str]) {\n+        let targets = targets.iter().map(|name| {\n+            let filename = self.filename(pkgname, name);\n+            let digest = match self.digests.remove(&filename) {\n+                Some(digest) => digest,\n+                None => {\n+                    return (name.to_string(), Target {\n+                        available: false,\n+                        url: None,\n+                        hash: None,\n+                        components: None,\n+                        extensions: None,\n+                    })\n+                }\n+            };\n+\n+            (name.to_string(), Target {\n+                available: true,\n+                url: Some(self.url(pkgname, name)),\n+                hash: Some(digest),\n+                components: None,\n+                extensions: None,\n+            })\n+        }).collect();\n+\n+        dst.insert(pkgname.to_string(), Package {\n+            version: self.cached_version(pkgname).to_string(),\n+            target: targets,\n+        });\n+    }\n+\n+    fn url(&self, component: &str, target: &str) -> String {\n+        format!(\"{}/{}/{}\",\n+                self.s3_address,\n+                self.date,\n+                self.filename(component, target))\n+    }\n+\n+    fn filename(&self, component: &str, target: &str) -> String {\n+        if component == \"rust-src\" {\n+            format!(\"rust-src-{}.tar.gz\", self.channel)\n+        } else {\n+            format!(\"{}-{}-{}.tar.gz\", component, self.channel, target)\n+        }\n+    }\n+\n+    fn cached_version(&self, component: &str) -> &str {\n+        if component == \"cargo\" {\n+            &self.cargo_version\n+        } else {\n+            &self.rust_version\n+        }\n+    }\n+\n+    fn version(&self, component: &str, target: &str) -> String {\n+        let mut cmd = Command::new(\"tar\");\n+        let filename = self.filename(component, target);\n+        cmd.arg(\"xf\")\n+           .arg(self.input.join(&filename))\n+           .arg(format!(\"{}/version\", filename.replace(\".tar.gz\", \"\")))\n+           .arg(\"-O\");\n+        let version = t!(cmd.output());\n+        if !version.status.success() {\n+            panic!(\"failed to learn version:\\n\\n{:?}\\n\\n{}\\n\\n{}\",\n+                   cmd,\n+                   String::from_utf8_lossy(&version.stdout),\n+                   String::from_utf8_lossy(&version.stderr));\n+        }\n+        String::from_utf8_lossy(&version.stdout).trim().to_string()\n+    }\n+\n+    fn hash(&self, path: &Path) -> String {\n+        let sha = t!(Command::new(\"shasum\")\n+                        .arg(\"-a\").arg(\"256\")\n+                        .arg(path)\n+                        .output());\n+        assert!(sha.status.success());\n+\n+        let filename = path.file_name().unwrap().to_str().unwrap();\n+        let sha256 = self.output.join(format!(\"{}.sha256\", filename));\n+        t!(t!(File::create(&sha256)).write_all(&sha.stdout));\n+\n+        let stdout = String::from_utf8_lossy(&sha.stdout);\n+        stdout.split_whitespace().next().unwrap().to_string()\n+    }\n+\n+    fn sign(&self, path: &Path) {\n+        let filename = path.file_name().unwrap().to_str().unwrap();\n+        let asc = self.output.join(format!(\"{}.asc\", filename));\n+        println!(\"signing: {:?}\", path);\n+        let mut cmd = Command::new(\"gpg\");\n+        cmd.arg(\"--no-tty\")\n+            .arg(\"--yes\")\n+            .arg(\"--passphrase-fd\").arg(\"0\")\n+            .arg(\"--armor\")\n+            .arg(\"--output\").arg(&asc)\n+            .arg(\"--detach-sign\").arg(path)\n+            .stdin(Stdio::piped());\n+        let mut child = t!(cmd.spawn());\n+        t!(child.stdin.take().unwrap().write_all(self.gpg_passphrase.as_bytes()));\n+        assert!(t!(child.wait()).success());\n+    }\n+\n+    fn write_manifest(&self, manifest: &str, name: &str) {\n+        let dst = self.output.join(name);\n+        t!(t!(File::create(&dst)).write_all(manifest.as_bytes()));\n+        self.hash(&dst);\n+        self.sign(&dst);\n+    }\n+}\n+\n+fn to_hex(digest: &[u8]) -> String {\n+    let mut ret = String::new();\n+    for byte in digest {\n+        ret.push(hex((byte & 0xf0) >> 4));\n+        ret.push(hex(byte & 0xf));\n+    }\n+    return ret;\n+\n+    fn hex(b: u8) -> char {\n+        match b {\n+            0...9 => (b'0' + b) as char,\n+            _ => (b'a' + b - 10) as char,\n+        }\n+    }\n+}"}]}