{"sha": "b2cac5afa36d55818f741f48029d350da35be511", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyY2FjNWFmYTM2ZDU1ODE4Zjc0MWY0ODAyOWQzNTBkYTM1YmU1MTE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-09T02:38:19Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-09T02:41:54Z"}, "message": "Implement typestate checking for move-mode args. Un-XFAIL compile-fail/move-arg.rs.", "tree": {"sha": "11ebd3b451ca76c2f548a78faaf3502b04dc23fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11ebd3b451ca76c2f548a78faaf3502b04dc23fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2cac5afa36d55818f741f48029d350da35be511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2cac5afa36d55818f741f48029d350da35be511", "html_url": "https://github.com/rust-lang/rust/commit/b2cac5afa36d55818f741f48029d350da35be511", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2cac5afa36d55818f741f48029d350da35be511/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7749b16087182813afa715fa828bb674ce9ef72", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7749b16087182813afa715fa828bb674ce9ef72", "html_url": "https://github.com/rust-lang/rust/commit/f7749b16087182813afa715fa828bb674ce9ef72"}], "stats": {"total": 142, "additions": 110, "deletions": 32}, "files": [{"sha": "92a6cf9ae742b8d1c7cbf43fe34fc5e24351f4ff", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b2cac5afa36d55818f741f48029d350da35be511/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2cac5afa36d55818f741f48029d350da35be511/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=b2cac5afa36d55818f741f48029d350da35be511", "patch": "@@ -1093,14 +1093,45 @@ fn locals_to_bindings(locals : &(@local)[]) -> binding[] {\n     ivec::map(local_to_bindings, locals)\n }\n \n-fn anon_bindings(es : &(@expr)[]) -> binding[] {\n-    fn expr_to_initializer(e : &@expr) -> initializer {\n-        {op: init_assign, expr: e}\n+fn callee_modes(fcx: &fn_ctxt, callee: node_id) -> ty::mode[] {\n+    let ty = ty::type_autoderef(fcx.ccx.tcx,\n+                                ty::node_id_to_type(fcx.ccx.tcx, callee));\n+    alt ty::struct(fcx.ccx.tcx, ty) {\n+      ty::ty_fn(_, args, _, _, _)\n+      | ty::ty_native_fn(_, args, _) {\n+        let modes = ~[];\n+        for arg: ty::arg in args {\n+            modes += ~[arg.mode];\n+        }\n+        ret modes;\n+      }\n+      _ {\n+        // Shouldn't happen; callee should be ty_fn.\n+        fcx.ccx.tcx.sess.bug(\"non-fn callee type in callee_modes: \"\n+                             + util::ppaux::ty_to_str(fcx.ccx.tcx, ty));\n+      }\n+   }\n+}\n+\n+fn callee_arg_init_ops(fcx: &fn_ctxt, callee: node_id) -> init_op[] {\n+    fn mode_to_op(m: &ty::mode) -> init_op {\n+        alt m {\n+          ty::mo_move. { init_move }\n+          _ { init_assign }\n+        }\n+    }\n+    ivec::map(mode_to_op, callee_modes(fcx, callee))\n+}\n+\n+fn anon_bindings(ops: &init_op[], es : &(@expr)[]) -> binding[] {\n+    let bindings: binding[] = ~[];\n+    let i = 0;\n+    for op: init_op in ops {\n+        bindings += ~[{lhs: ~[],\n+                       rhs: some({op:op, expr: es.(i)})}];\n+        i += 1;\n     }\n-    ret ivec::map(fn (e : &@expr) -> binding {\n-        {lhs: ~[],\n-         rhs: some(expr_to_initializer(e)) } },\n-                  es);\n+    ret bindings;\n }\n \n //"}, {"sha": "bade71525e3f6502c8619f5cdf49ff28f5c064ca", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b2cac5afa36d55818f741f48029d350da35be511/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2cac5afa36d55818f741f48029d350da35be511/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=b2cac5afa36d55818f741f48029d350da35be511", "patch": "@@ -316,6 +316,18 @@ fn handle_var(fcx: &fn_ctxt, rslt: &pre_and_post, id: node_id, name: ident) {\n     }\n }\n \n+fn forget_args_moved_in(fcx: &fn_ctxt, parent: &@expr,\n+                        modes: &ty::mode[],\n+                        operands: &(@expr)[]) {\n+    let i = 0;\n+    for mode: ty::mode in modes {\n+        if mode == ty::mo_move {\n+            forget_in_postcond(fcx, parent.id, operands.(i).id);\n+        }\n+        i += 1;\n+    }\n+}\n+\n /* Fills in annotations as a side effect. Does not rebuild the expr */\n fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n     let enclosing = fcx.enclosing;\n@@ -336,6 +348,8 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n             require(i, expr_pp(fcx.ccx, e));\n         }\n \n+        forget_args_moved_in(fcx, e, callee_modes(fcx, operator.id),\n+                             operands);\n \n         /* if this is a failing call, its postcondition sets everything */\n         alt controlflow_expr(fcx.ccx, operator) {\n@@ -347,6 +361,8 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n         let /* copy */args = operands;\n         args += ~[operator];\n         find_pre_post_exprs(fcx, args, e.id);\n+        forget_args_moved_in(fcx, e, callee_modes(fcx, operator.id),\n+                             operands);\n       }\n       expr_vec(args, _, _) { find_pre_post_exprs(fcx, args, e.id); }\n       expr_path(p) {\n@@ -544,14 +560,21 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n \n       expr_bind(operator, maybe_args) {\n         let args = ~[];\n-        for expr_opt: option::t[@expr]  in maybe_args {\n+        let cmodes = callee_modes(fcx, operator.id);\n+        let modes = ~[];\n+        let i = 0;\n+        for expr_opt: option::t[@expr] in maybe_args {\n             alt expr_opt {\n               none. {/* no-op */ }\n-              some(expr) { args += ~[expr]; }\n+              some(expr) {\n+                modes += ~[cmodes.(i)];\n+                args += ~[expr];\n+              }\n             }\n+            i += 1;\n         }\n         args += ~[operator]; /* ??? order of eval? */\n-\n+        forget_args_moved_in(fcx, e, modes, args);\n         find_pre_post_exprs(fcx, args, e.id);\n       }\n       expr_break. { clear_pp(expr_pp(fcx.ccx, e)); }"}, {"sha": "420ea4cad8c441e351c669f62dca186f2c096a99", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 46, "deletions": 18, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b2cac5afa36d55818f741f48029d350da35be511/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2cac5afa36d55818f741f48029d350da35be511/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=b2cac5afa36d55818f741f48029d350da35be511", "patch": "@@ -45,9 +45,6 @@ fn handle_move_or_copy(fcx: &fn_ctxt, post: &poststate, rhs_path: &path,\n         // not a local -- do nothing\n       }\n     }\n-    if (init_op == init_move) {\n-        forget_in_poststate(fcx, post, rhs_id);\n-    }\n }\n \n fn seq_states(fcx: &fn_ctxt, pres: &prestate, bindings: &binding[])\n@@ -67,10 +64,14 @@ fn seq_states(fcx: &fn_ctxt, pres: &prestate, bindings: &binding[])\n                     handle_move_or_copy(fcx, post, p, an_init.expr.id, i,\n                                         an_init.op);\n                   }\n-                  _ {}\n+                  _ { }\n                 }\n                 set_in_poststate_ident(fcx, i.node, i.ident, post);\n             }\n+            // Forget the RHS if we just moved it.\n+            if an_init.op == init_move {\n+                forget_in_poststate(fcx, post, an_init.expr.id);\n+            }\n           }\n           none {\n             for i: inst in b.lhs {\n@@ -162,16 +163,24 @@ fn find_pre_post_state_two(fcx: &fn_ctxt, pres: &prestate, lhs: &@expr,\n }\n \n fn find_pre_post_state_call(fcx: &fn_ctxt, pres: &prestate, a: &@expr,\n-                            id: node_id, bs: &(@expr)[], cf: controlflow) ->\n-   bool {\n+                            id: node_id, ops: &init_op[], bs: &(@expr)[],\n+                            cf: controlflow) -> bool {\n     let changed = find_pre_post_state_expr(fcx, pres, a);\n-    ret find_pre_post_state_exprs(fcx, expr_poststate(fcx.ccx, a), id, bs, cf)\n+    if ivec::len(bs) != ivec::len(ops) {\n+        fcx.ccx.tcx.sess.span_bug(a.span,\n+                                  #fmt(\"mismatched arg lengths: \\\n+                                        %u exprs vs. %u ops\",\n+                                       ivec::len(bs), ivec::len(ops)));\n+    }\n+    ret find_pre_post_state_exprs(fcx, expr_poststate(fcx.ccx, a), id,\n+                                  ops, bs, cf)\n             || changed;\n }\n \n fn find_pre_post_state_exprs(fcx: &fn_ctxt, pres: &prestate, id: node_id,\n-                             es: &(@expr)[], cf: controlflow) -> bool {\n-    let rs = seq_states(fcx, pres, anon_bindings(es));\n+                             ops: &init_op[], es: &(@expr)[],\n+                             cf: controlflow) -> bool {\n+    let rs = seq_states(fcx, pres, anon_bindings(ops, es));\n     let changed = rs.changed | set_prestate_ann(fcx.ccx, id, pres);\n     /* if this is a failing call, it sets everything as initialized */\n     alt cf {\n@@ -304,23 +313,39 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n \n     alt e.node {\n       expr_vec(elts, _, _) {\n-        ret find_pre_post_state_exprs(fcx, pres, e.id, elts, return);\n+        ret find_pre_post_state_exprs(fcx, pres, e.id,\n+                                      ivec::init_elt(init_assign,\n+                                                     ivec::len(elts)),\n+                                      elts, return);\n       }\n       expr_call(operator, operands) {\n-        ret find_pre_post_state_call(fcx, pres, operator, e.id, operands,\n+        ret find_pre_post_state_call(fcx, pres, operator, e.id,\n+                                     callee_arg_init_ops(fcx, operator.id),\n+                                     operands,\n                                      controlflow_expr(fcx.ccx, operator));\n       }\n       expr_spawn(_, _, operator, operands) {\n-        ret find_pre_post_state_call(fcx, pres, operator, e.id, operands,\n-                                     return);\n+        ret find_pre_post_state_call(fcx, pres, operator, e.id,\n+                                     callee_arg_init_ops(fcx, operator.id),\n+                                     operands, return);\n       }\n       expr_bind(operator, maybe_args) {\n         let args = ~[];\n-        for a_opt: option::t[@expr]  in maybe_args {\n-            alt a_opt { none. {/* no-op */ } some(a) { args += ~[a]; } }\n+        let callee_ops = callee_arg_init_ops(fcx, operator.id);\n+        let ops = ~[];\n+        let i = 0;\n+        for a_opt: option::t[@expr] in maybe_args {\n+            alt a_opt {\n+              none. {/* no-op */ }\n+              some(a) {\n+                ops += ~[callee_ops.(i)];\n+                args += ~[a];\n+              }\n+            }\n+            i += 1;\n         }\n-\n-        ret find_pre_post_state_call(fcx, pres, operator, e.id, args, return);\n+        ret find_pre_post_state_call(fcx, pres, operator, e.id, ops, args,\n+                                     return);\n       }\n       expr_path(_) { ret pure_exp(fcx.ccx, e.id, pres); }\n       expr_log(_, ex) {\n@@ -347,7 +372,10 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n       }\n       expr_rec(fields, maybe_base) {\n         let changed =\n-            find_pre_post_state_exprs(fcx, pres, e.id, field_exprs(fields),\n+            find_pre_post_state_exprs(fcx, pres, e.id,\n+                                      ivec::init_elt(init_assign,\n+                                                     ivec::len(fields)),\n+                                      field_exprs(fields),\n                                       return);\n         alt maybe_base {\n           none. {/* do nothing */ }"}, {"sha": "cd348231d918fd971b6ac79a735a2250ff78ffd5", "filename": "src/test/compile-fail/move-arg.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2cac5afa36d55818f741f48029d350da35be511/src%2Ftest%2Fcompile-fail%2Fmove-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2cac5afa36d55818f741f48029d350da35be511/src%2Ftest%2Fcompile-fail%2Fmove-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-arg.rs?ref=b2cac5afa36d55818f741f48029d350da35be511", "patch": "@@ -1,7 +1,3 @@\n-// xfail-stage0\n-// xfail-stage1\n-// xfail-stage2\n-// xfail-stage3\n // error-pattern: Unsatisfied precondition constraint\n fn test(foo: -int) {\n     assert (foo == 10);"}]}