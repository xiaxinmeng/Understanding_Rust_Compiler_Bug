{"sha": "8f32fdecfbc56b7ddd39a418632a1149792e9033", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMzJmZGVjZmJjNTZiN2RkZDM5YTQxODYzMmExMTQ5NzkyZTkwMzM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-25T03:36:17Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-26T00:37:27Z"}, "message": "Remove `LastPrivate`", "tree": {"sha": "ca7930fbf4d70819b54d97547929282f5de9b709", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca7930fbf4d70819b54d97547929282f5de9b709"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f32fdecfbc56b7ddd39a418632a1149792e9033", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f32fdecfbc56b7ddd39a418632a1149792e9033", "html_url": "https://github.com/rust-lang/rust/commit/8f32fdecfbc56b7ddd39a418632a1149792e9033", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f32fdecfbc56b7ddd39a418632a1149792e9033/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec0fdd5a4ae480a9b298685a74c678084d5582fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec0fdd5a4ae480a9b298685a74c678084d5582fc", "html_url": "https://github.com/rust-lang/rust/commit/ec0fdd5a4ae480a9b298685a74c678084d5582fc"}], "stats": {"total": 415, "additions": 43, "deletions": 372}, "files": [{"sha": "6d4799749b93af6c5da3bf76319fa0b3092f15b8", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=8f32fdecfbc56b7ddd39a418632a1149792e9033", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use middle::def_id::DefId;\n-use middle::privacy::LastPrivate;\n use middle::subst::ParamSpace;\n use util::nodemap::NodeMap;\n use syntax::ast;\n@@ -65,7 +64,6 @@ pub enum Def {\n #[derive(Copy, Clone, Debug)]\n pub struct PathResolution {\n     pub base_def: Def,\n-    pub last_private: LastPrivate,\n     pub depth: usize\n }\n \n@@ -84,12 +82,10 @@ impl PathResolution {\n     }\n \n     pub fn new(base_def: Def,\n-               last_private: LastPrivate,\n                depth: usize)\n                -> PathResolution {\n         PathResolution {\n             base_def: base_def,\n-            last_private: last_private,\n             depth: depth,\n         }\n     }"}, {"sha": "c1dc727449ac0ca681a240a02f0071d2ed5f80d0", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=8f32fdecfbc56b7ddd39a418632a1149792e9033", "patch": "@@ -12,11 +12,6 @@\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n \n-pub use self::PrivateDep::*;\n-pub use self::ImportUse::*;\n-pub use self::LastPrivate::*;\n-\n-use middle::def_id::DefId;\n use util::nodemap::{DefIdSet, FnvHashMap};\n \n use std::hash::Hash;\n@@ -64,39 +59,3 @@ impl<Id: Hash + Eq> Default for AccessLevels<Id> {\n /// A set containing all exported definitions from external crates.\n /// The set does not contain any entries from local crates.\n pub type ExternalExports = DefIdSet;\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum LastPrivate {\n-    LastMod(PrivateDep),\n-    // `use` directives (imports) can refer to two separate definitions in the\n-    // type and value namespaces. We record here the last private node for each\n-    // and whether the import is in fact used for each.\n-    // If the Option<PrivateDep> fields are None, it means there is no definition\n-    // in that namespace.\n-    LastImport{value_priv: Option<PrivateDep>,\n-               value_used: ImportUse,\n-               type_priv: Option<PrivateDep>,\n-               type_used: ImportUse},\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum PrivateDep {\n-    AllPublic,\n-    DependsOn(DefId),\n-}\n-\n-// How an import is used.\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum ImportUse {\n-    Unused,       // The import is not used.\n-    Used,         // The import is used.\n-}\n-\n-impl LastPrivate {\n-    pub fn or(self, other: LastPrivate) -> LastPrivate {\n-        match (self, other) {\n-            (me, LastMod(AllPublic)) => me,\n-            (_, other) => other,\n-        }\n-    }\n-}"}, {"sha": "633044d7ade6ccf9891a4b0501d7c72fd89ac748", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=8f32fdecfbc56b7ddd39a418632a1149792e9033", "patch": "@@ -32,7 +32,6 @@ use middle::ty::cast;\n use middle::const_qualif::ConstQualif;\n use middle::def::{self, Def};\n use middle::def_id::DefId;\n-use middle::privacy::{AllPublic, LastMod};\n use middle::region;\n use middle::subst;\n use middle::ty::{self, Ty};\n@@ -1161,8 +1160,6 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         let def = decode_def(dcx, val_dsr);\n                         dcx.tcx.def_map.borrow_mut().insert(id, def::PathResolution {\n                             base_def: def,\n-                            // This doesn't matter cross-crate.\n-                            last_private: LastMod(AllPublic),\n                             depth: 0\n                         });\n                     }"}, {"sha": "ce5c7cf1b566ad49c1657d8e0bcb08fa3c4ddd64", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=8f32fdecfbc56b7ddd39a418632a1149792e9033", "patch": "@@ -41,9 +41,6 @@ use rustc::lint;\n use rustc::middle::def::{self, Def};\n use rustc::middle::def_id::DefId;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n-use rustc::middle::privacy::ImportUse::*;\n-use rustc::middle::privacy::LastPrivate::*;\n-use rustc::middle::privacy::PrivateDep::*;\n use rustc::middle::privacy::ExternalExports;\n use rustc::middle::ty;\n use rustc::util::nodemap::{NodeMap, NodeSet};\n@@ -718,7 +715,6 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                      source_did: Option<DefId>,\n                      msg: &str)\n                      -> CheckResult {\n-        use rustc_front::hir::Item_::ItemExternCrate;\n         debug!(\"ensure_public(span={:?}, to_check={:?}, source_did={:?}, msg={:?})\",\n                span, to_check, source_did, msg);\n         let def_privacy = self.def_privacy(to_check);\n@@ -740,20 +736,6 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         let def_id = source_did.unwrap_or(to_check);\n         let node_id = self.tcx.map.as_local_node_id(def_id);\n \n-        // Warn when using a inaccessible extern crate.\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(to_check) {\n-            match self.tcx.map.get(node_id) {\n-                ast_map::Node::NodeItem(&hir::Item { node: ItemExternCrate(_), name, .. }) => {\n-                    self.tcx.sess.add_lint(lint::builtin::INACCESSIBLE_EXTERN_CRATE,\n-                                           node_id,\n-                                           span,\n-                                           format!(\"extern crate `{}` is private\", name));\n-                    return None;\n-                }\n-                _ => {}\n-            }\n-        }\n-\n         let (err_span, err_msg) = if Some(id) == node_id {\n             return Some((span, format!(\"{} is private\", msg), None));\n         } else {\n@@ -842,90 +824,6 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                                      name)));\n     }\n \n-    // Checks that a path is in scope.\n-    fn check_path(&mut self, span: Span, path_id: ast::NodeId, last: ast::Name) {\n-        debug!(\"privacy - path {}\", self.nodestr(path_id));\n-        let path_res = *self.tcx.def_map.borrow().get(&path_id).unwrap();\n-        let ck = |tyname: &str| {\n-            let ck_public = |def: DefId| {\n-                debug!(\"privacy - ck_public {:?}\", def);\n-                let origdid = path_res.def_id();\n-                self.ensure_public(span,\n-                                   def,\n-                                   Some(origdid),\n-                                   &format!(\"{} `{}`\", tyname, last))\n-            };\n-\n-            match path_res.last_private {\n-                LastMod(AllPublic) => {},\n-                LastMod(DependsOn(def)) => {\n-                    self.report_error(ck_public(def));\n-                },\n-                LastImport { value_priv,\n-                             value_used: check_value,\n-                             type_priv,\n-                             type_used: check_type } => {\n-                    // This dance with found_error is because we don't want to\n-                    // report a privacy error twice for the same directive.\n-                    let found_error = match (type_priv, check_type) {\n-                        (Some(DependsOn(def)), Used) => {\n-                            !self.report_error(ck_public(def))\n-                        },\n-                        _ => false,\n-                    };\n-                    if !found_error {\n-                        match (value_priv, check_value) {\n-                            (Some(DependsOn(def)), Used) => {\n-                                self.report_error(ck_public(def));\n-                            },\n-                            _ => {},\n-                        }\n-                    }\n-                    // If an import is not used in either namespace, we still\n-                    // want to check that it could be legal. Therefore we check\n-                    // in both namespaces and only report an error if both would\n-                    // be illegal. We only report one error, even if it is\n-                    // illegal to import from both namespaces.\n-                    match (value_priv, check_value, type_priv, check_type) {\n-                        (Some(p), Unused, None, _) |\n-                        (None, _, Some(p), Unused) => {\n-                            let p = match p {\n-                                AllPublic => None,\n-                                DependsOn(def) => ck_public(def),\n-                            };\n-                            if p.is_some() {\n-                                self.report_error(p);\n-                            }\n-                        },\n-                        (Some(v), Unused, Some(t), Unused) => {\n-                            let v = match v {\n-                                AllPublic => None,\n-                                DependsOn(def) => ck_public(def),\n-                            };\n-                            let t = match t {\n-                                AllPublic => None,\n-                                DependsOn(def) => ck_public(def),\n-                            };\n-                            if let (Some(_), Some(t)) = (v, t) {\n-                                self.report_error(Some(t));\n-                            }\n-                        },\n-                        _ => {},\n-                    }\n-                },\n-            }\n-        };\n-        // FIXME(#12334) Imports can refer to definitions in both the type and\n-        // value namespaces. The privacy information is aware of this, but the\n-        // def map is not. Therefore the names we work out below will not always\n-        // be accurate and we can get slightly wonky error messages (but type\n-        // checking is always correct).\n-        let def = path_res.full_def();\n-        if def != Def::Err {\n-            ck(def.kind_name());\n-        }\n-    }\n-\n     // Checks that a method is in scope.\n     fn check_method(&mut self, span: Span, method_def_id: DefId,\n                     name: ast::Name) {\n@@ -1067,25 +965,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_foreign_item(self, fi);\n         self.in_foreign = false;\n     }\n-\n-    fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n-        if !path.segments.is_empty() {\n-            self.check_path(path.span, id, path.segments.last().unwrap().identifier.name);\n-            intravisit::walk_path(self, path);\n-        }\n-    }\n-\n-    fn visit_path_list_item(&mut self, prefix: &hir::Path, item: &hir::PathListItem) {\n-        let name = if let hir::PathListIdent { name, .. } = item.node {\n-            name\n-        } else if !prefix.segments.is_empty() {\n-            prefix.segments.last().unwrap().identifier.name\n-        } else {\n-            self.tcx.sess.bug(\"`self` import in an import list with empty prefix\");\n-        };\n-        self.check_path(item.span, item.node.id(), name);\n-        intravisit::walk_path_list_item(self, prefix, item);\n-    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "ea197109cabc4a08807b0926faf05f9823942b98", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=8f32fdecfbc56b7ddd39a418632a1149792e9033", "patch": "@@ -23,7 +23,6 @@ use Resolver;\n use Namespace::{TypeNS, ValueNS};\n \n use rustc::lint;\n-use rustc::middle::privacy::{DependsOn, LastImport, Used, Unused};\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n \n@@ -69,45 +68,6 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n                                   span,\n                                   \"unused import\".to_string());\n         }\n-\n-        let mut def_map = self.def_map.borrow_mut();\n-        let path_res = if let Some(r) = def_map.get_mut(&id) {\n-            r\n-        } else {\n-            return;\n-        };\n-        let (v_priv, t_priv) = match path_res.last_private {\n-            LastImport { value_priv, type_priv, .. } => (value_priv, type_priv),\n-            _ => {\n-                panic!(\"we should only have LastImport for `use` directives\")\n-            }\n-        };\n-\n-        let mut v_used = if self.used_imports.contains(&(id, ValueNS)) {\n-            Used\n-        } else {\n-            Unused\n-        };\n-        let t_used = if self.used_imports.contains(&(id, TypeNS)) {\n-            Used\n-        } else {\n-            Unused\n-        };\n-\n-        match (v_priv, t_priv) {\n-            // Since some items may be both in the value _and_ type namespaces (e.g., structs)\n-            // we might have two LastPrivates pointing at the same thing. There is no point\n-            // checking both, so lets not check the value one.\n-            (Some(DependsOn(def_v)), Some(DependsOn(def_t))) if def_v == def_t => v_used = Unused,\n-            _ => {}\n-        }\n-\n-        path_res.last_private = LastImport {\n-            value_priv: v_priv,\n-            value_used: v_used,\n-            type_priv: t_priv,\n-            type_used: t_used,\n-        };\n     }\n }\n "}, {"sha": "2897714d57432c24c7d52b6d5811f6fe627c43d4", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 28, "deletions": 100, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8f32fdecfbc56b7ddd39a418632a1149792e9033", "patch": "@@ -54,7 +54,7 @@ use rustc::middle::cstore::{CrateStore, DefLike, DlDef};\n use rustc::middle::def::*;\n use rustc::middle::def_id::DefId;\n use rustc::middle::pat_util::pat_bindings;\n-use rustc::middle::privacy::*;\n+use rustc::middle::privacy::ExternalExports;\n use rustc::middle::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::middle::ty::{Freevar, FreevarMap, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n@@ -757,8 +757,8 @@ enum AssocItemResolveResult {\n \n #[derive(Copy, Clone)]\n enum BareIdentifierPatternResolution {\n-    FoundStructOrEnumVariant(Def, LastPrivate),\n-    FoundConst(Def, LastPrivate, Name),\n+    FoundStructOrEnumVariant(Def),\n+    FoundConst(Def, Name),\n     BareIdentifierPatternUnresolved,\n }\n \n@@ -920,16 +920,6 @@ impl<'a> ModuleS<'a> {\n         self.def.as_ref().map(Def::def_id)\n     }\n \n-    // This returns the DefId of the crate local item that controls this module's visibility.\n-    // It is only used to compute `LastPrivate` data, and it differs from `def_id` only for extern\n-    // crates, whose `def_id` is the external crate's root, not the local `extern crate` item.\n-    fn local_def_id(&self) -> Option<DefId> {\n-        match self.extern_crate_did {\n-            Some(def_id) => Some(def_id),\n-            None => self.def_id(),\n-        }\n-    }\n-\n     fn is_normal(&self) -> bool {\n         match self.def {\n             Some(Def::Mod(_)) | Some(Def::ForeignMod(_)) => true,\n@@ -1040,14 +1030,6 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n-    fn local_def_id(&self) -> Option<DefId> {\n-        match self.kind {\n-            NameBindingKind::Def(def) => Some(def.def_id()),\n-            NameBindingKind::Module(ref module) => module.local_def_id(),\n-            NameBindingKind::Import { binding, .. } => binding.local_def_id(),\n-        }\n-    }\n-\n     fn defined_with(&self, modifiers: DefModifiers) -> bool {\n         self.modifiers.contains(modifiers)\n     }\n@@ -1056,13 +1038,6 @@ impl<'a> NameBinding<'a> {\n         self.defined_with(DefModifiers::PUBLIC)\n     }\n \n-    fn def_and_lp(&self) -> (Def, LastPrivate) {\n-        let def = self.def().unwrap();\n-        if let Def::Err = def { return (def, LastMod(AllPublic)) }\n-        let lp = if self.is_public() { AllPublic } else { DependsOn(self.local_def_id().unwrap()) };\n-        (def, LastMod(lp))\n-    }\n-\n     fn is_extern_crate(&self) -> bool {\n         self.module().and_then(|module| module.extern_crate_did).is_some()\n     }\n@@ -1313,9 +1288,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      module_: Module<'a>,\n                                      module_path: &[Name],\n                                      index: usize,\n-                                     span: Span,\n-                                     lp: LastPrivate)\n-                                     -> ResolveResult<(Module<'a>, LastPrivate)> {\n+                                     span: Span)\n+                                     -> ResolveResult<Module<'a>> {\n         fn search_parent_externals(needle: Name, module: Module) -> Option<Module> {\n             match module.resolve_name(needle, TypeNS, false) {\n                 Success(binding) if binding.is_extern_crate() => Some(module),\n@@ -1331,7 +1305,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut search_module = module_;\n         let mut index = index;\n         let module_path_len = module_path.len();\n-        let mut closest_private = lp;\n \n         // Resolve the module part of the path. This does not involve looking\n         // upward though scope chains; we simply resolve names directly in\n@@ -1380,14 +1353,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // so, whether there is a module within.\n                     if let Some(module_def) = binding.module() {\n                         search_module = module_def;\n-\n-                        // Keep track of the closest private module used\n-                        // when resolving this import chain.\n-                        if !binding.is_public() {\n-                            if let Some(did) = search_module.local_def_id() {\n-                                closest_private = LastMod(DependsOn(did));\n-                            }\n-                        }\n                     } else {\n                         let msg = format!(\"Not a module `{}`\", name);\n                         return Failed(Some((span, msg)));\n@@ -1398,7 +1363,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             index += 1;\n         }\n \n-        return Success((search_module, closest_private));\n+        return Success(search_module);\n     }\n \n     /// Attempts to resolve the module part of an import directive or path\n@@ -1411,9 +1376,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                            module_path: &[Name],\n                            use_lexical_scope: UseLexicalScopeFlag,\n                            span: Span)\n-                           -> ResolveResult<(Module<'a>, LastPrivate)> {\n+                           -> ResolveResult<Module<'a>> {\n         if module_path.len() == 0 {\n-            return Success((self.graph_root, LastMod(AllPublic))) // Use the crate root\n+            return Success(self.graph_root) // Use the crate root\n         }\n \n         debug!(\"(resolving module path for import) processing `{}` rooted at `{}`\",\n@@ -1425,7 +1390,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let search_module;\n         let start_index;\n-        let last_private;\n         match module_prefix_result {\n             Failed(None) => {\n                 let mpath = names_to_string(module_path);\n@@ -1459,7 +1423,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // resolution process at index zero.\n                         search_module = self.graph_root;\n                         start_index = 0;\n-                        last_private = LastMod(AllPublic);\n                     }\n                     UseLexicalScope => {\n                         // This is not a crate-relative path. We resolve the\n@@ -1478,7 +1441,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 Some(containing_module) => {\n                                     search_module = containing_module;\n                                     start_index = 1;\n-                                    last_private = LastMod(AllPublic);\n                                 }\n                                 None => return Failed(None),\n                             }\n@@ -1489,16 +1451,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Success(PrefixFound(ref containing_module, index)) => {\n                 search_module = containing_module;\n                 start_index = index;\n-                last_private = LastMod(DependsOn(containing_module.local_def_id()\n-                                                                  .unwrap()));\n             }\n         }\n \n         self.resolve_module_path_from_root(search_module,\n                                            module_path,\n                                            start_index,\n-                                           span,\n-                                           last_private)\n+                                           span)\n     }\n \n     /// Invariant: This must only be called during main resolution, not during\n@@ -1847,8 +1806,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             match self.resolve_crate_relative_path(prefix.span,\n                                                                    &prefix.segments,\n                                                                    TypeNS) {\n-                                Some((def, lp)) =>\n-                                    self.record_def(item.id, PathResolution::new(def, lp, 0)),\n+                                Some(def) =>\n+                                    self.record_def(item.id, PathResolution::new(def, 0)),\n                                 None => {\n                                     resolve_error(self,\n                                                   prefix.span,\n@@ -2399,7 +2358,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                     match self.resolve_bare_identifier_pattern(ident.unhygienic_name,\n                                                                pattern.span) {\n-                        FoundStructOrEnumVariant(def, lp) if const_ok => {\n+                        FoundStructOrEnumVariant(def) if const_ok => {\n                             debug!(\"(resolving pattern) resolving `{}` to struct or enum variant\",\n                                    renamed);\n \n@@ -2409,7 +2368,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             self.record_def(pattern.id,\n                                             PathResolution {\n                                                 base_def: def,\n-                                                last_private: lp,\n                                                 depth: 0,\n                                             });\n                         }\n@@ -2422,18 +2380,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             );\n                             self.record_def(pattern.id, err_path_resolution());\n                         }\n-                        FoundConst(def, lp, _) if const_ok => {\n+                        FoundConst(def, _) if const_ok => {\n                             debug!(\"(resolving pattern) resolving `{}` to constant\", renamed);\n \n                             self.enforce_default_binding_mode(pattern, binding_mode, \"a constant\");\n                             self.record_def(pattern.id,\n                                             PathResolution {\n                                                 base_def: def,\n-                                                last_private: lp,\n                                                 depth: 0,\n                                             });\n                         }\n-                        FoundConst(def, _, name) => {\n+                        FoundConst(def, name) => {\n                             resolve_error(\n                                 self,\n                                 pattern.span,\n@@ -2455,7 +2412,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             self.record_def(pattern.id,\n                                             PathResolution {\n                                                 base_def: def,\n-                                                last_private: LastMod(AllPublic),\n                                                 depth: 0,\n                                             });\n \n@@ -2673,10 +2629,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // considered as not having a private component because\n                     // the lookup happened only within the current module.\n                     Some(def @ Def::Variant(..)) | Some(def @ Def::Struct(..)) => {\n-                        return FoundStructOrEnumVariant(def, LastMod(AllPublic));\n+                        return FoundStructOrEnumVariant(def);\n                     }\n                     Some(def @ Def::Const(..)) | Some(def @ Def::AssociatedConst(..)) => {\n-                        return FoundConst(def, LastMod(AllPublic), name);\n+                        return FoundConst(def, name);\n                     }\n                     Some(Def::Static(..)) => {\n                         resolve_error(self, span, ResolutionError::StaticVariableReference);\n@@ -2757,7 +2713,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let span = path.span;\n         let segments = &path.segments[..path.segments.len() - path_depth];\n \n-        let mk_res = |(def, lp)| PathResolution::new(def, lp, path_depth);\n+        let mk_res = |def| PathResolution::new(def, path_depth);\n \n         if path.global {\n             let def = self.resolve_crate_relative_path(span, segments, namespace);\n@@ -2770,14 +2726,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             let unqualified_def = self.resolve_identifier(last_ident, namespace, check_ribs, true);\n             return unqualified_def.and_then(|def| self.adjust_local_def(def, span))\n                                   .map(|def| {\n-                                      PathResolution::new(def, LastMod(AllPublic), path_depth)\n+                                      PathResolution::new(def, path_depth)\n                                   });\n         }\n \n         let unqualified_def = self.resolve_identifier(last_ident, namespace, check_ribs, false);\n         let def = self.resolve_module_relative_path(span, segments, namespace);\n         match (def, unqualified_def) {\n-            (Some((ref d, _)), Some(ref ud)) if *d == ud.def => {\n+            (Some(d), Some(ref ud)) if d == ud.def => {\n                 self.session\n                     .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n                               id,\n@@ -2923,7 +2879,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     span: Span,\n                                     segments: &[hir::PathSegment],\n                                     namespace: Namespace)\n-                                    -> Option<(Def, LastPrivate)> {\n+                                    -> Option<Def> {\n         let module_path = segments.split_last()\n                                   .unwrap()\n                                   .1\n@@ -2932,7 +2888,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                   .collect::<Vec<_>>();\n \n         let containing_module;\n-        let last_private;\n         let current_module = self.current_module;\n         match self.resolve_module_path(current_module, &module_path, UseLexicalScope, span) {\n             Failed(err) => {\n@@ -2949,22 +2904,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 return None;\n             }\n             Indeterminate => return None,\n-            Success((resulting_module, resulting_last_private)) => {\n+            Success(resulting_module) => {\n                 containing_module = resulting_module;\n-                last_private = resulting_last_private;\n             }\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n-        let def = match result {\n-            Success(binding) => {\n-                let (def, lp) = binding.def_and_lp();\n-                (def, last_private.or(lp))\n-            }\n-            _ => return None,\n-        };\n-        return Some(def);\n+        result.success().map(|binding| binding.def().unwrap())\n     }\n \n     /// Invariant: This must be called only during main resolution, not during\n@@ -2973,7 +2920,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                    span: Span,\n                                    segments: &[hir::PathSegment],\n                                    namespace: Namespace)\n-                                   -> Option<(Def, LastPrivate)> {\n+                                   -> Option<Def> {\n         let module_path = segments.split_last()\n                                   .unwrap()\n                                   .1\n@@ -2984,12 +2931,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let root_module = self.graph_root;\n \n         let containing_module;\n-        let last_private;\n         match self.resolve_module_path_from_root(root_module,\n                                                  &module_path,\n                                                  0,\n-                                                 span,\n-                                                 LastMod(AllPublic)) {\n+                                                 span) {\n             Failed(err) => {\n                 let (span, msg) = match err {\n                     Some((span, msg)) => (span, msg),\n@@ -3006,20 +2951,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             Indeterminate => return None,\n \n-            Success((resulting_module, resulting_last_private)) => {\n+            Success(resulting_module) => {\n                 containing_module = resulting_module;\n-                last_private = resulting_last_private;\n             }\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n-        match self.resolve_name_in_module(containing_module, name, namespace, false, true) {\n-            Success(binding) => {\n-                let (def, lp) = binding.def_and_lp();\n-                Some((def, last_private.or(lp)))\n-            }\n-            _ => None,\n-        }\n+        let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n+        result.success().map(|binding| binding.def().unwrap())\n     }\n \n     fn resolve_identifier_in_local_ribs(&mut self,\n@@ -3105,10 +3044,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                .and_then(NameBinding::module)\n                 }\n             } else {\n-                match this.resolve_module_path(root, &name_path, UseLexicalScope, span) {\n-                    Success((module, _)) => Some(module),\n-                    _ => None,\n-                }\n+                this.resolve_module_path(root, &name_path, UseLexicalScope, span).success()\n             }\n         }\n \n@@ -3420,7 +3356,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         self.record_def(expr.id,\n                                         PathResolution {\n                                             base_def: def,\n-                                            last_private: LastMod(AllPublic),\n                                             depth: 0,\n                                         })\n                     }\n@@ -3613,12 +3548,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn record_def(&mut self, node_id: NodeId, resolution: PathResolution) {\n         debug!(\"(recording def) recording {:?} for {}\", resolution, node_id);\n-        assert!(match resolution.last_private {\n-                    LastImport{..} => false,\n-                    _ => true,\n-                },\n-                \"Import should only be used for `use` directives\");\n-\n         if let Some(prev_res) = self.def_map.borrow_mut().insert(node_id, resolution) {\n             let span = self.ast_map.opt_span(node_id).unwrap_or(codemap::DUMMY_SP);\n             self.session.span_bug(span,\n@@ -3756,7 +3685,6 @@ fn module_to_string(module: Module) -> String {\n fn err_path_resolution() -> PathResolution {\n     PathResolution {\n         base_def: Def::Err,\n-        last_private: LastMod(AllPublic),\n         depth: 0,\n     }\n }"}, {"sha": "47f4fc82ad1c5a628df3e5ab50a12f1f6c28a94a", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 12, "deletions": 44, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=8f32fdecfbc56b7ddd39a418632a1149792e9033", "patch": "@@ -25,7 +25,6 @@ use build_reduced_graph;\n \n use rustc::lint;\n use rustc::middle::def::*;\n-use rustc::middle::privacy::*;\n \n use syntax::ast::{NodeId, Name};\n use syntax::attr::AttrMetaMethods;\n@@ -296,18 +295,17 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                  &import_directive.module_path,\n                                  UseLexicalScopeFlag::DontUseLexicalScope,\n                                  import_directive.span)\n-            .and_then(|(containing_module, lp)| {\n+            .and_then(|containing_module| {\n                 // We found the module that the target is contained\n                 // within. Attempt to resolve the import within it.\n                 if let SingleImport(target, source) = import_directive.subclass {\n                     self.resolve_single_import(module_,\n                                                containing_module,\n                                                target,\n                                                source,\n-                                               import_directive,\n-                                               lp)\n+                                               import_directive)\n                 } else {\n-                    self.resolve_glob_import(module_, containing_module, import_directive, lp)\n+                    self.resolve_glob_import(module_, containing_module, import_directive)\n                 }\n             })\n             .and_then(|()| {\n@@ -333,26 +331,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                              target_module: Module<'b>,\n                              target: Name,\n                              source: Name,\n-                             directive: &ImportDirective,\n-                             lp: LastPrivate)\n+                             directive: &ImportDirective)\n                              -> ResolveResult<()> {\n-        debug!(\"(resolving single import) resolving `{}` = `{}::{}` from `{}` id {}, last \\\n-                private {:?}\",\n+        debug!(\"(resolving single import) resolving `{}` = `{}::{}` from `{}` id {}\",\n                target,\n                module_to_string(&target_module),\n                source,\n                module_to_string(module_),\n-               directive.id,\n-               lp);\n-\n-        let lp = match lp {\n-            LastMod(lp) => lp,\n-            LastImport {..} => {\n-                self.resolver\n-                    .session\n-                    .span_bug(directive.span, \"not expecting Import here, must be LastMod\")\n-            }\n-        };\n+               directive.id);\n \n         // If this is a circular import, we temporarily count it as determined so that\n         // it fails (as opposed to being indeterminate) when nothing else can define it.\n@@ -450,28 +436,12 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         module_.decrement_outstanding_references_for(target, ValueNS);\n         module_.decrement_outstanding_references_for(target, TypeNS);\n \n-        let def_and_priv = |binding: &NameBinding| {\n-            let last_private =\n-                if binding.is_public() { lp } else { DependsOn(binding.local_def_id().unwrap()) };\n-            (binding.def().unwrap(), last_private)\n-        };\n-        let value_def_and_priv = value_result.success().map(&def_and_priv);\n-        let type_def_and_priv = type_result.success().map(&def_and_priv);\n-\n-        let import_lp = LastImport {\n-            value_priv: value_def_and_priv.map(|(_, p)| p),\n-            value_used: Used,\n-            type_priv: type_def_and_priv.map(|(_, p)| p),\n-            type_used: Used,\n-        };\n-\n-        let write_path_resolution = |(def, _)| {\n-            let path_resolution =\n-                PathResolution { base_def: def, last_private: import_lp, depth: 0 };\n-            self.resolver.def_map.borrow_mut().insert(directive.id, path_resolution);\n+        let def = match type_result.success().and_then(NameBinding::def) {\n+            Some(def) => def,\n+            None => value_result.success().and_then(NameBinding::def).unwrap(),\n         };\n-        value_def_and_priv.map(&write_path_resolution);\n-        type_def_and_priv.map(&write_path_resolution);\n+        let path_resolution = PathResolution { base_def: def, depth: 0 };\n+        self.resolver.def_map.borrow_mut().insert(directive.id, path_resolution);\n \n         debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());\n@@ -484,8 +454,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     fn resolve_glob_import(&mut self,\n                            module_: Module<'b>,\n                            target_module: Module<'b>,\n-                           directive: &ImportDirective,\n-                           lp: LastPrivate)\n+                           directive: &ImportDirective)\n                            -> ResolveResult<()> {\n         // We must bail out if the node has unresolved imports of any kind (including globs).\n         if target_module.pub_count.get() > 0 {\n@@ -521,7 +490,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             self.resolver.def_map.borrow_mut().insert(directive.id,\n                                                       PathResolution {\n                                                           base_def: Def::Mod(did),\n-                                                          last_private: lp,\n                                                           depth: 0,\n                                                       });\n         }"}, {"sha": "8db04c2da20a26c884d863f73137eec761032614", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=8f32fdecfbc56b7ddd39a418632a1149792e9033", "patch": "@@ -54,7 +54,6 @@ use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::def::{self, Def};\n use middle::def_id::DefId;\n use middle::resolve_lifetime as rl;\n-use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs, ParamSpace};\n use middle::traits;\n use middle::ty::{self, Ty, ToPredicate, TypeFoldable};\n@@ -1650,7 +1649,6 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 // Create some fake resolution that can't possibly be a type.\n                 def::PathResolution {\n                     base_def: Def::Mod(tcx.map.local_def_id(ast::CRATE_NODE_ID)),\n-                    last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }\n             } else {\n@@ -1674,7 +1672,6 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 // Write back the new resolution.\n                 tcx.def_map.borrow_mut().insert(ast_ty.id, def::PathResolution {\n                     base_def: def,\n-                    last_private: path_res.last_private,\n                     depth: 0\n                 });\n             }"}, {"sha": "f837d354acd2aaf31a1603e2cff6b11a82a18763", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=8f32fdecfbc56b7ddd39a418632a1149792e9033", "patch": "@@ -12,7 +12,6 @@ use middle::def::{self, Def};\n use middle::infer::{self, TypeOrigin};\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n use middle::pat_util::pat_is_resolved_const;\n-use middle::privacy::{AllPublic, LastMod};\n use middle::subst::Substs;\n use middle::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n@@ -219,7 +218,6 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 let sentinel = fcx.tcx().map.local_def_id(ast::CRATE_NODE_ID);\n                 def::PathResolution {\n                     base_def: Def::Mod(sentinel),\n-                    last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }\n             } else {"}, {"sha": "74ee1579229e1a521f4162e7a4eebf8b5bcebcc5", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=8f32fdecfbc56b7ddd39a418632a1149792e9033", "patch": "@@ -14,7 +14,6 @@ use astconv::AstConv;\n use check::FnCtxt;\n use middle::def::Def;\n use middle::def_id::DefId;\n-use middle::privacy::{AllPublic, DependsOn, LastPrivate, LastMod};\n use middle::subst;\n use middle::traits;\n use middle::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n@@ -334,18 +333,11 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               method_name: ast::Name,\n                               self_ty: ty::Ty<'tcx>,\n                               expr_id: ast::NodeId)\n-                              -> Result<(Def, LastPrivate), MethodError<'tcx>>\n+                              -> Result<Def, MethodError<'tcx>>\n {\n     let mode = probe::Mode::Path;\n     let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, expr_id));\n-    let def_result = pick.item.def();\n-    let mut lp = LastMod(AllPublic);\n-    if let probe::InherentImplPick = pick.kind {\n-        if pick.item.vis() != hir::Public {\n-            lp = LastMod(DependsOn(def_result.def_id()));\n-        }\n-    }\n-    Ok((def_result, lp))\n+    Ok(pick.item.def())\n }\n \n "}, {"sha": "6175024066705deec76dc58fc6077df773368f6b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f32fdecfbc56b7ddd39a418632a1149792e9033/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8f32fdecfbc56b7ddd39a418632a1149792e9033", "patch": "@@ -91,7 +91,6 @@ use middle::def_id::DefId;\n use middle::infer;\n use middle::infer::{TypeOrigin, type_variable};\n use middle::pat_util::{self, pat_id_map};\n-use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n use middle::traits::{self, report_fulfillment_errors};\n use middle::ty::{GenericPredicates, TypeScheme};\n@@ -3364,7 +3363,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 // Create some fake resolution that can't possibly be a type.\n                 def::PathResolution {\n                     base_def: Def::Mod(tcx.map.local_def_id(ast::CRATE_NODE_ID)),\n-                    last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }\n             } else {\n@@ -3803,12 +3801,11 @@ pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n         let item_segment = path.segments.last().unwrap();\n         let item_name = item_segment.identifier.name;\n         match method::resolve_ufcs(fcx, span, item_name, ty, node_id) {\n-            Ok((def, lp)) => {\n+            Ok(def) => {\n                 // Write back the new resolution.\n                 fcx.ccx.tcx.def_map.borrow_mut()\n                        .insert(node_id, def::PathResolution {\n                    base_def: def,\n-                   last_private: path_res.last_private.or(lp),\n                    depth: 0\n                 });\n                 Some((Some(ty), slice::ref_slice(item_segment), def))"}]}