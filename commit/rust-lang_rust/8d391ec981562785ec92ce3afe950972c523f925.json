{"sha": "8d391ec981562785ec92ce3afe950972c523f925", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkMzkxZWM5ODE1NjI3ODVlYzkyY2UzYWZlOTUwOTcyYzUyM2Y5MjU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T17:06:25Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T17:06:25Z"}, "message": "internal: refactor mismatched args count diagnostic", "tree": {"sha": "7729eb4ae1ef7a4cf0e0be42dfc2ef36c65cec1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7729eb4ae1ef7a4cf0e0be42dfc2ef36c65cec1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d391ec981562785ec92ce3afe950972c523f925", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d391ec981562785ec92ce3afe950972c523f925", "html_url": "https://github.com/rust-lang/rust/commit/8d391ec981562785ec92ce3afe950972c523f925", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d391ec981562785ec92ce3afe950972c523f925/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bccf77f26cd504de14f7d7d03f9f2a85d0fabb3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bccf77f26cd504de14f7d7d03f9f2a85d0fabb3d", "html_url": "https://github.com/rust-lang/rust/commit/bccf77f26cd504de14f7d7d03f9f2a85d0fabb3d"}], "stats": {"total": 559, "additions": 279, "deletions": 280}, "files": [{"sha": "f839616ce43148c9d38a4390f60bf85e9856d3fd", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8d391ec981562785ec92ce3afe950972c523f925/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d391ec981562785ec92ce3afe950972c523f925/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=8d391ec981562785ec92ce3afe950972c523f925", "patch": "@@ -35,6 +35,7 @@ diagnostics![\n     BreakOutsideOfLoop,\n     InactiveCode,\n     MacroError,\n+    MismatchedArgCount,\n     MissingFields,\n     MissingUnsafe,\n     NoSuchField,\n@@ -143,36 +144,13 @@ impl Diagnostic for ReplaceFilterMapNextWithFindMap {\n     }\n }\n \n-// Diagnostic: mismatched-arg-count\n-//\n-// This diagnostic is triggered if a function is invoked with an incorrect amount of arguments.\n #[derive(Debug)]\n pub struct MismatchedArgCount {\n-    pub file: HirFileId,\n-    pub call_expr: AstPtr<ast::Expr>,\n+    pub call_expr: InFile<AstPtr<ast::Expr>>,\n     pub expected: usize,\n     pub found: usize,\n }\n \n-impl Diagnostic for MismatchedArgCount {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"mismatched-arg-count\")\n-    }\n-    fn message(&self) -> String {\n-        let s = if self.expected == 1 { \"\" } else { \"s\" };\n-        format!(\"Expected {} argument{}, found {}\", self.expected, s, self.found)\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.call_expr.clone().into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-    fn is_experimental(&self) -> bool {\n-        true\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct RemoveThisSemicolon {\n     pub file: HirFileId,"}, {"sha": "c1af5f0978acac937143ad3ed382b0ce857c0245", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8d391ec981562785ec92ce3afe950972c523f925/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d391ec981562785ec92ce3afe950972c523f925/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=8d391ec981562785ec92ce3afe950972c523f925", "patch": "@@ -1176,12 +1176,9 @@ impl Function {\n                 }\n                 BodyValidationDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n                     match source_map.expr_syntax(call_expr) {\n-                        Ok(source_ptr) => sink.push(MismatchedArgCount {\n-                            file: source_ptr.file_id,\n-                            call_expr: source_ptr.value,\n-                            expected,\n-                            found,\n-                        }),\n+                        Ok(source_ptr) => acc.push(\n+                            MismatchedArgCount { call_expr: source_ptr, expected, found }.into(),\n+                        ),\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }"}, {"sha": "4c92d0cf4c1522008baa3d62fa3a9d8c6cfa692b", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 250, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/8d391ec981562785ec92ce3afe950972c523f925/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d391ec981562785ec92ce3afe950972c523f925/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=8d391ec981562785ec92ce3afe950972c523f925", "patch": "@@ -7,6 +7,7 @@\n mod break_outside_of_loop;\n mod inactive_code;\n mod macro_error;\n+mod mismatched_arg_count;\n mod missing_fields;\n mod missing_unsafe;\n mod no_such_field;\n@@ -224,6 +225,7 @@ pub(crate) fn diagnostics(\n             AnyDiagnostic::MacroError(d) => macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MissingFields(d) => missing_fields::missing_fields(&ctx, &d),\n             AnyDiagnostic::MissingUnsafe(d) => missing_unsafe::missing_unsafe(&ctx, &d),\n+            AnyDiagnostic::MismatchedArgCount(d) => mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => no_such_field::no_such_field(&ctx, &d),\n             AnyDiagnostic::UnimplementedBuiltinMacro(d) => unimplemented_builtin_macro::unimplemented_builtin_macro(&ctx, &d),\n             AnyDiagnostic::UnresolvedExternCrate(d) => unresolved_extern_crate::unresolved_extern_crate(&ctx, &d),\n@@ -836,256 +838,6 @@ fn x(a: S) {\n         )\n     }\n \n-    #[test]\n-    fn simple_free_fn_zero() {\n-        check_diagnostics(\n-            r#\"\n-fn zero() {}\n-fn f() { zero(1); }\n-       //^^^^^^^ Expected 0 arguments, found 1\n-\"#,\n-        );\n-\n-        check_diagnostics(\n-            r#\"\n-fn zero() {}\n-fn f() { zero(); }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn simple_free_fn_one() {\n-        check_diagnostics(\n-            r#\"\n-fn one(arg: u8) {}\n-fn f() { one(); }\n-       //^^^^^ Expected 1 argument, found 0\n-\"#,\n-        );\n-\n-        check_diagnostics(\n-            r#\"\n-fn one(arg: u8) {}\n-fn f() { one(1); }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn method_as_fn() {\n-        check_diagnostics(\n-            r#\"\n-struct S;\n-impl S { fn method(&self) {} }\n-\n-fn f() {\n-    S::method();\n-} //^^^^^^^^^^^ Expected 1 argument, found 0\n-\"#,\n-        );\n-\n-        check_diagnostics(\n-            r#\"\n-struct S;\n-impl S { fn method(&self) {} }\n-\n-fn f() {\n-    S::method(&S);\n-    S.method();\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn method_with_arg() {\n-        check_diagnostics(\n-            r#\"\n-struct S;\n-impl S { fn method(&self, arg: u8) {} }\n-\n-            fn f() {\n-                S.method();\n-            } //^^^^^^^^^^ Expected 1 argument, found 0\n-            \"#,\n-        );\n-\n-        check_diagnostics(\n-            r#\"\n-struct S;\n-impl S { fn method(&self, arg: u8) {} }\n-\n-fn f() {\n-    S::method(&S, 0);\n-    S.method(1);\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn method_unknown_receiver() {\n-        // note: this is incorrect code, so there might be errors on this in the\n-        // future, but we shouldn't emit an argument count diagnostic here\n-        check_diagnostics(\n-            r#\"\n-trait Foo { fn method(&self, arg: usize) {} }\n-\n-fn f() {\n-    let x;\n-    x.method();\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_struct() {\n-        check_diagnostics(\n-            r#\"\n-struct Tup(u8, u16);\n-fn f() {\n-    Tup(0);\n-} //^^^^^^ Expected 2 arguments, found 1\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn enum_variant() {\n-        check_diagnostics(\n-            r#\"\n-enum En { Variant(u8, u16), }\n-fn f() {\n-    En::Variant(0);\n-} //^^^^^^^^^^^^^^ Expected 2 arguments, found 1\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn enum_variant_type_macro() {\n-        check_diagnostics(\n-            r#\"\n-macro_rules! Type {\n-    () => { u32 };\n-}\n-enum Foo {\n-    Bar(Type![])\n-}\n-impl Foo {\n-    fn new() {\n-        Foo::Bar(0);\n-        Foo::Bar(0, 1);\n-      //^^^^^^^^^^^^^^ Expected 1 argument, found 2\n-        Foo::Bar();\n-      //^^^^^^^^^^ Expected 1 argument, found 0\n-    }\n-}\n-        \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn varargs() {\n-        check_diagnostics(\n-            r#\"\n-extern \"C\" {\n-    fn fixed(fixed: u8);\n-    fn varargs(fixed: u8, ...);\n-    fn varargs2(...);\n-}\n-\n-fn f() {\n-    unsafe {\n-        fixed(0);\n-        fixed(0, 1);\n-      //^^^^^^^^^^^ Expected 1 argument, found 2\n-        varargs(0);\n-        varargs(0, 1);\n-        varargs2();\n-        varargs2(0);\n-        varargs2(0, 1);\n-    }\n-}\n-        \"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn arg_count_lambda() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    let f = |()| ();\n-    f();\n-  //^^^ Expected 1 argument, found 0\n-    f(());\n-    f((), ());\n-  //^^^^^^^^^ Expected 1 argument, found 2\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn cfgd_out_call_arguments() {\n-        check_diagnostics(\n-            r#\"\n-struct C(#[cfg(FALSE)] ());\n-impl C {\n-    fn new() -> Self {\n-        Self(\n-            #[cfg(FALSE)]\n-            (),\n-        )\n-    }\n-\n-    fn method(&self) {}\n-}\n-\n-fn main() {\n-    C::new().method(#[cfg(FALSE)] 0);\n-}\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn cfgd_out_fn_params() {\n-        check_diagnostics(\n-            r#\"\n-fn foo(#[cfg(NEVER)] x: ()) {}\n-\n-struct S;\n-\n-impl S {\n-    fn method(#[cfg(NEVER)] self) {}\n-    fn method2(#[cfg(NEVER)] self, arg: u8) {}\n-    fn method3(self, #[cfg(NEVER)] arg: u8) {}\n-}\n-\n-extern \"C\" {\n-    fn fixed(fixed: u8, #[cfg(NEVER)] ...);\n-    fn varargs(#[cfg(not(NEVER))] ...);\n-}\n-\n-fn main() {\n-    foo();\n-    S::method();\n-    S::method2(0);\n-    S::method3(S);\n-    S.method3();\n-    unsafe {\n-        fixed(0);\n-        varargs(1, 2, 3);\n-    }\n-}\n-            \"#,\n-        )\n-    }\n-\n     #[test]\n     fn missing_semicolon() {\n         check_diagnostics("}, {"sha": "08e1cfa5fccecd20dd368254df690b88a0005e8e", "filename": "crates/ide/src/diagnostics/mismatched_arg_count.rs", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/8d391ec981562785ec92ce3afe950972c523f925/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmismatched_arg_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d391ec981562785ec92ce3afe950972c523f925/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmismatched_arg_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmismatched_arg_count.rs?ref=8d391ec981562785ec92ce3afe950972c523f925", "patch": "@@ -0,0 +1,272 @@\n+use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: mismatched-arg-count\n+//\n+// This diagnostic is triggered if a function is invoked with an incorrect amount of arguments.\n+pub(super) fn mismatched_arg_count(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::MismatchedArgCount,\n+) -> Diagnostic {\n+    let s = if d.expected == 1 { \"\" } else { \"s\" };\n+    let message = format!(\"expected {} argument{}, found {}\", d.expected, s, d.found);\n+    Diagnostic::new(\n+        \"mismatched-arg-count\",\n+        message,\n+        ctx.sema.diagnostics_display_range(d.call_expr.clone().map(|it| it.into())).range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    #[test]\n+    fn simple_free_fn_zero() {\n+        check_diagnostics(\n+            r#\"\n+fn zero() {}\n+fn f() { zero(1); }\n+       //^^^^^^^ expected 0 arguments, found 1\n+\"#,\n+        );\n+\n+        check_diagnostics(\n+            r#\"\n+fn zero() {}\n+fn f() { zero(); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_free_fn_one() {\n+        check_diagnostics(\n+            r#\"\n+fn one(arg: u8) {}\n+fn f() { one(); }\n+       //^^^^^ expected 1 argument, found 0\n+\"#,\n+        );\n+\n+        check_diagnostics(\n+            r#\"\n+fn one(arg: u8) {}\n+fn f() { one(1); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_as_fn() {\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self) {} }\n+\n+fn f() {\n+    S::method();\n+} //^^^^^^^^^^^ expected 1 argument, found 0\n+\"#,\n+        );\n+\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self) {} }\n+\n+fn f() {\n+    S::method(&S);\n+    S.method();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_with_arg() {\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self, arg: u8) {} }\n+\n+            fn f() {\n+                S.method();\n+            } //^^^^^^^^^^ expected 1 argument, found 0\n+            \"#,\n+        );\n+\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self, arg: u8) {} }\n+\n+fn f() {\n+    S::method(&S, 0);\n+    S.method(1);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_unknown_receiver() {\n+        // note: this is incorrect code, so there might be errors on this in the\n+        // future, but we shouldn't emit an argument count diagnostic here\n+        check_diagnostics(\n+            r#\"\n+trait Foo { fn method(&self, arg: usize) {} }\n+\n+fn f() {\n+    let x;\n+    x.method();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_struct() {\n+        check_diagnostics(\n+            r#\"\n+struct Tup(u8, u16);\n+fn f() {\n+    Tup(0);\n+} //^^^^^^ expected 2 arguments, found 1\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn enum_variant() {\n+        check_diagnostics(\n+            r#\"\n+enum En { Variant(u8, u16), }\n+fn f() {\n+    En::Variant(0);\n+} //^^^^^^^^^^^^^^ expected 2 arguments, found 1\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn enum_variant_type_macro() {\n+        check_diagnostics(\n+            r#\"\n+macro_rules! Type {\n+    () => { u32 };\n+}\n+enum Foo {\n+    Bar(Type![])\n+}\n+impl Foo {\n+    fn new() {\n+        Foo::Bar(0);\n+        Foo::Bar(0, 1);\n+      //^^^^^^^^^^^^^^ expected 1 argument, found 2\n+        Foo::Bar();\n+      //^^^^^^^^^^ expected 1 argument, found 0\n+    }\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn varargs() {\n+        check_diagnostics(\n+            r#\"\n+extern \"C\" {\n+    fn fixed(fixed: u8);\n+    fn varargs(fixed: u8, ...);\n+    fn varargs2(...);\n+}\n+\n+fn f() {\n+    unsafe {\n+        fixed(0);\n+        fixed(0, 1);\n+      //^^^^^^^^^^^ expected 1 argument, found 2\n+        varargs(0);\n+        varargs(0, 1);\n+        varargs2();\n+        varargs2(0);\n+        varargs2(0, 1);\n+    }\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn arg_count_lambda() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let f = |()| ();\n+    f();\n+  //^^^ expected 1 argument, found 0\n+    f(());\n+    f((), ());\n+  //^^^^^^^^^ expected 1 argument, found 2\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn cfgd_out_call_arguments() {\n+        check_diagnostics(\n+            r#\"\n+struct C(#[cfg(FALSE)] ());\n+impl C {\n+    fn new() -> Self {\n+        Self(\n+            #[cfg(FALSE)]\n+            (),\n+        )\n+    }\n+\n+    fn method(&self) {}\n+}\n+\n+fn main() {\n+    C::new().method(#[cfg(FALSE)] 0);\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn cfgd_out_fn_params() {\n+        check_diagnostics(\n+            r#\"\n+fn foo(#[cfg(NEVER)] x: ()) {}\n+\n+struct S;\n+\n+impl S {\n+    fn method(#[cfg(NEVER)] self) {}\n+    fn method2(#[cfg(NEVER)] self, arg: u8) {}\n+    fn method3(self, #[cfg(NEVER)] arg: u8) {}\n+}\n+\n+extern \"C\" {\n+    fn fixed(fixed: u8, #[cfg(NEVER)] ...);\n+    fn varargs(#[cfg(not(NEVER))] ...);\n+}\n+\n+fn main() {\n+    foo();\n+    S::method();\n+    S::method2(0);\n+    S::method3(S);\n+    S.method3();\n+    unsafe {\n+        fixed(0);\n+        varargs(1, 2, 3);\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+}"}]}