{"sha": "48b048deb732b31d6768876074f7bc9d0e036645", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4YjA0OGRlYjczMmIzMWQ2NzY4ODc2MDc0ZjdiYzlkMGUwMzY2NDU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-16T02:50:34Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-30T21:26:35Z"}, "message": "Clean up the privacy visitor", "tree": {"sha": "19a95922ad11f2e44faa616e0e1ef85ba16aa1fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19a95922ad11f2e44faa616e0e1ef85ba16aa1fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48b048deb732b31d6768876074f7bc9d0e036645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48b048deb732b31d6768876074f7bc9d0e036645", "html_url": "https://github.com/rust-lang/rust/commit/48b048deb732b31d6768876074f7bc9d0e036645", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48b048deb732b31d6768876074f7bc9d0e036645/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8762fc31db55c641083bf31539da3f079877c8b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8762fc31db55c641083bf31539da3f079877c8b1", "html_url": "https://github.com/rust-lang/rust/commit/8762fc31db55c641083bf31539da3f079877c8b1"}], "stats": {"total": 439, "additions": 25, "deletions": 414}, "files": [{"sha": "3605de44495b1e1de9dc9538e87c509d9f772df7", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48b048deb732b31d6768876074f7bc9d0e036645/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48b048deb732b31d6768876074f7bc9d0e036645/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=48b048deb732b31d6768876074f7bc9d0e036645", "patch": "@@ -581,14 +581,6 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn get_foreign_vis(&self, id: NodeId) -> Visibility {\n-        let vis = self.expect_foreign_item(id).vis; // read recorded by `expect_foreign_item`\n-        match self.find(self.get_parent(id)) { // read recorded by `find`\n-            Some(NodeItem(i)) => vis.inherit_from(i.vis),\n-            _ => vis\n-        }\n-    }\n-\n     pub fn expect_item(&self, id: NodeId) -> &'ast Item {\n         match self.find(id) { // read recorded by `find`\n             Some(NodeItem(item)) => item,"}, {"sha": "5bef33af4521031a12bbca05d0f7ac60ff6bab84", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 25, "deletions": 406, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/48b048deb732b31d6768876074f7bc9d0e036645/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48b048deb732b31d6768876074f7bc9d0e036645/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=48b048deb732b31d6768876074f7bc9d0e036645", "patch": "@@ -27,7 +27,6 @@\n extern crate rustc;\n extern crate rustc_front;\n \n-use self::PrivacyResult::*;\n use self::FieldName::*;\n \n use std::cmp;\n@@ -43,7 +42,7 @@ use rustc::middle::def::{self, Def};\n use rustc::middle::def_id::DefId;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n use rustc::ty::{self, TyCtxt};\n-use rustc::util::nodemap::{NodeMap, NodeSet};\n+use rustc::util::nodemap::NodeSet;\n use rustc::front::map as ast_map;\n \n use syntax::ast;\n@@ -58,98 +57,6 @@ type Context<'a, 'tcx> = (&'a ty::MethodMap<'tcx>, &'a def::ExportMap);\n /// optionally the same for a note about the error.\n type CheckResult = Option<(Span, String, Option<(Span, String)>)>;\n \n-////////////////////////////////////////////////////////////////////////////////\n-/// The parent visitor, used to determine what's the parent of what (node-wise)\n-////////////////////////////////////////////////////////////////////////////////\n-\n-struct ParentVisitor<'a, 'tcx:'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n-    parents: NodeMap<ast::NodeId>,\n-    curparent: ast::NodeId,\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for ParentVisitor<'a, 'tcx> {\n-    /// We want to visit items in the context of their containing\n-    /// module and so forth, so supply a crate for doing a deep walk.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n-    }\n-    fn visit_item(&mut self, item: &hir::Item) {\n-        self.parents.insert(item.id, self.curparent);\n-\n-        let prev = self.curparent;\n-        match item.node {\n-            hir::ItemMod(..) => { self.curparent = item.id; }\n-            // Enum variants are parented to the enum definition itself because\n-            // they inherit privacy\n-            hir::ItemEnum(ref def, _) => {\n-                for variant in &def.variants {\n-                    // The parent is considered the enclosing enum because the\n-                    // enum will dictate the privacy visibility of this variant\n-                    // instead.\n-                    self.parents.insert(variant.node.data.id(), item.id);\n-                }\n-            }\n-\n-            // Trait methods are always considered \"public\", but if the trait is\n-            // private then we need some private item in the chain from the\n-            // method to the root. In this case, if the trait is private, then\n-            // parent all the methods to the trait to indicate that they're\n-            // private.\n-            hir::ItemTrait(_, _, _, ref trait_items) if item.vis != hir::Public => {\n-                for trait_item in trait_items {\n-                    self.parents.insert(trait_item.id, item.id);\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-        intravisit::walk_item(self, item);\n-        self.curparent = prev;\n-    }\n-\n-    fn visit_foreign_item(&mut self, a: &hir::ForeignItem) {\n-        self.parents.insert(a.id, self.curparent);\n-        intravisit::walk_foreign_item(self, a);\n-    }\n-\n-    fn visit_fn(&mut self, a: intravisit::FnKind<'v>, b: &'v hir::FnDecl,\n-                c: &'v hir::Block, d: Span, id: ast::NodeId) {\n-        // We already took care of some trait methods above, otherwise things\n-        // like impl methods and pub trait methods are parented to the\n-        // containing module, not the containing trait.\n-        if !self.parents.contains_key(&id) {\n-            self.parents.insert(id, self.curparent);\n-        }\n-        intravisit::walk_fn(self, a, b, c, d);\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n-        // visit_fn handles methods, but associated consts have to be handled\n-        // here.\n-        if !self.parents.contains_key(&ii.id) {\n-            self.parents.insert(ii.id, self.curparent);\n-        }\n-        intravisit::walk_impl_item(self, ii);\n-    }\n-\n-    fn visit_variant_data(&mut self, s: &hir::VariantData, _: ast::Name,\n-                        _: &'v hir::Generics, item_id: ast::NodeId, _: Span) {\n-        // Struct constructors are parented to their struct definitions because\n-        // they essentially are the struct definitions.\n-        if !s.is_struct() {\n-            self.parents.insert(s.id(), item_id);\n-        }\n-\n-        // While we have the id of the struct definition, go ahead and parent\n-        // all the fields.\n-        for field in s.fields() {\n-            self.parents.insert(field.id, self.curparent);\n-        }\n-        intravisit::walk_struct_def(self, s)\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n /// The embargo visitor, used to determine the exports of the ast\n ////////////////////////////////////////////////////////////////////////////////\n@@ -475,14 +382,6 @@ struct PrivacyVisitor<'a, 'tcx: 'a> {\n     tcx: &'a TyCtxt<'tcx>,\n     curitem: ast::NodeId,\n     in_foreign: bool,\n-    parents: NodeMap<ast::NodeId>,\n-}\n-\n-#[derive(Debug)]\n-enum PrivacyResult {\n-    Allowable,\n-    ExternallyDenied,\n-    DisallowedBy(ast::NodeId),\n }\n \n enum FieldName {\n@@ -491,271 +390,33 @@ enum FieldName {\n }\n \n impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n-    // Determines whether the given definition is public from the point of view\n-    // of the current item.\n-    fn def_privacy(&self, did: DefId) -> PrivacyResult {\n-        let node_id = if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n-            node_id\n-        } else {\n-            if self.tcx.sess.cstore.visibility(did) == hir::Public {\n-                debug!(\"privacy - {:?} was externally exported\", did);\n-                return Allowable;\n-            }\n-            debug!(\"privacy - is {:?} a public method\", did);\n-\n-            return match self.tcx.impl_or_trait_items.borrow().get(&did) {\n-                Some(&ty::ConstTraitItem(ref ac)) => {\n-                    debug!(\"privacy - it's a const: {:?}\", *ac);\n-                    match ac.container {\n-                        ty::TraitContainer(id) => {\n-                            debug!(\"privacy - recursing on trait {:?}\", id);\n-                            self.def_privacy(id)\n-                        }\n-                        ty::ImplContainer(id) => {\n-                            match self.tcx.impl_trait_ref(id) {\n-                                Some(t) => {\n-                                    debug!(\"privacy - impl of trait {:?}\", id);\n-                                    self.def_privacy(t.def_id)\n-                                }\n-                                None => {\n-                                    debug!(\"privacy - found inherent \\\n-                                            associated constant {:?}\",\n-                                            ac.vis);\n-                                    if ac.vis == hir::Public {\n-                                        Allowable\n-                                    } else {\n-                                        ExternallyDenied\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                Some(&ty::MethodTraitItem(ref meth)) => {\n-                    debug!(\"privacy - well at least it's a method: {:?}\",\n-                           *meth);\n-                    match meth.container {\n-                        ty::TraitContainer(id) => {\n-                            debug!(\"privacy - recursing on trait {:?}\", id);\n-                            self.def_privacy(id)\n-                        }\n-                        ty::ImplContainer(id) => {\n-                            match self.tcx.impl_trait_ref(id) {\n-                                Some(t) => {\n-                                    debug!(\"privacy - impl of trait {:?}\", id);\n-                                    self.def_privacy(t.def_id)\n-                                }\n-                                None => {\n-                                    debug!(\"privacy - found a method {:?}\",\n-                                            meth.vis);\n-                                    if meth.vis == hir::Public {\n-                                        Allowable\n-                                    } else {\n-                                        ExternallyDenied\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                Some(&ty::TypeTraitItem(ref typedef)) => {\n-                    match typedef.container {\n-                        ty::TraitContainer(id) => {\n-                            debug!(\"privacy - recursing on trait {:?}\", id);\n-                            self.def_privacy(id)\n-                        }\n-                        ty::ImplContainer(id) => {\n-                            match self.tcx.impl_trait_ref(id) {\n-                                Some(t) => {\n-                                    debug!(\"privacy - impl of trait {:?}\", id);\n-                                    self.def_privacy(t.def_id)\n-                                }\n-                                None => {\n-                                    debug!(\"privacy - found a typedef {:?}\",\n-                                            typedef.vis);\n-                                    if typedef.vis == hir::Public {\n-                                        Allowable\n-                                    } else {\n-                                        ExternallyDenied\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                None => {\n-                    debug!(\"privacy - nope, not even a method\");\n-                    ExternallyDenied\n-                }\n-            };\n-        };\n-\n-        debug!(\"privacy - local {} not public all the way down\",\n-               self.tcx.map.node_to_string(node_id));\n-        // return quickly for things in the same module\n-        if self.parents.get(&node_id) == self.parents.get(&self.curitem) {\n-            debug!(\"privacy - same parent, we're done here\");\n-            return Allowable;\n-        }\n-\n-        let vis = match self.tcx.map.find(node_id) {\n-            // If this item is a method, then we know for sure that it's an\n-            // actual method and not a static method. The reason for this is\n-            // that these cases are only hit in the ExprMethodCall\n-            // expression, and ExprCall will have its path checked later\n-            // (the path of the trait/impl) if it's a static method.\n-            //\n-            // With this information, then we can completely ignore all\n-            // trait methods. The privacy violation would be if the trait\n-            // couldn't get imported, not if the method couldn't be used\n-            // (all trait methods are public).\n-            //\n-            // However, if this is an impl method, then we dictate this\n-            // decision solely based on the privacy of the method\n-            // invocation.\n-            Some(ast_map::NodeImplItem(ii)) => {\n-                let imp = self.tcx.map.get_parent_did(node_id);\n-                match self.tcx.impl_trait_ref(imp) {\n-                    Some(..) => hir::Public,\n-                    _ => ii.vis,\n-                }\n-            }\n-            Some(ast_map::NodeTraitItem(_)) => hir::Public,\n-\n-            // This is not a method call, extract the visibility as one\n-            // would normally look at it\n-            Some(ast_map::NodeItem(it)) => it.vis,\n-            Some(ast_map::NodeForeignItem(_)) => {\n-                self.tcx.map.get_foreign_vis(node_id)\n-            }\n-            _ => hir::Public,\n+    fn item_is_visible(&self, did: DefId) -> bool {\n+        let visibility = match self.tcx.map.as_local_node_id(did) {\n+            Some(node_id) => self.tcx.map.expect_item(node_id).vis,\n+            None => self.tcx.sess.cstore.visibility(did),\n         };\n-        if vis == hir::Public { return Allowable }\n-\n-        if self.private_accessible(node_id) {\n-            Allowable\n-        } else {\n-            DisallowedBy(node_id)\n-        }\n+        visibility == hir::Public || self.private_accessible(did)\n     }\n \n-    /// True if `id` is both local and private-accessible\n-    fn local_private_accessible(&self, did: DefId) -> bool {\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n-            self.private_accessible(node_id)\n-        } else {\n-            false\n+    /// True if `did` is private-accessible\n+    fn private_accessible(&self, did: DefId) -> bool {\n+        match self.tcx.map.as_local_node_id(did) {\n+            Some(node_id) => self.tcx.map.private_item_is_visible_from(node_id, self.curitem),\n+            None => false,\n         }\n     }\n \n-    /// For a local private node in the AST, this function will determine\n-    /// whether the node is accessible by the current module that iteration is\n-    /// inside.\n-    fn private_accessible(&self, id: ast::NodeId) -> bool {\n-        self.tcx.map.private_item_is_visible_from(id, self.curitem)\n-    }\n-\n-    fn report_error(&self, result: CheckResult) -> bool {\n-        match result {\n-            None => true,\n-            Some((span, msg, note)) => {\n-                let mut err = self.tcx.sess.struct_span_err(span, &msg[..]);\n-                if let Some((span, msg)) = note {\n-                    err.span_note(span, &msg[..]);\n-                }\n-                err.emit();\n-                false\n-            },\n-        }\n-    }\n-\n-    /// Guarantee that a particular definition is public. Returns a CheckResult\n-    /// which contains any errors found. These can be reported using `report_error`.\n-    /// If the result is `None`, no errors were found.\n-    fn ensure_public(&self,\n-                     span: Span,\n-                     to_check: DefId,\n-                     source_did: Option<DefId>,\n-                     msg: &str)\n-                     -> CheckResult {\n-        debug!(\"ensure_public(span={:?}, to_check={:?}, source_did={:?}, msg={:?})\",\n-               span, to_check, source_did, msg);\n-        let def_privacy = self.def_privacy(to_check);\n-        debug!(\"ensure_public: def_privacy={:?}\", def_privacy);\n-        let id = match def_privacy {\n-            ExternallyDenied => {\n-                return Some((span, format!(\"{} is private\", msg), None))\n-            }\n-            Allowable => return None,\n-            DisallowedBy(id) => id,\n-        };\n-\n-        // If we're disallowed by a particular id, then we attempt to\n-        // give a nice error message to say why it was disallowed. It\n-        // was either because the item itself is private or because\n-        // its parent is private and its parent isn't in our\n-        // ancestry. (Both the item being checked and its parent must\n-        // be local.)\n-        let def_id = source_did.unwrap_or(to_check);\n-        let node_id = self.tcx.map.as_local_node_id(def_id);\n-\n-        let (err_span, err_msg) = if Some(id) == node_id {\n-            return Some((span, format!(\"{} is private\", msg), None));\n-        } else {\n-            (span, format!(\"{} is inaccessible\", msg))\n-        };\n-        let item = match self.tcx.map.find(id) {\n-            Some(ast_map::NodeItem(item)) => {\n-                match item.node {\n-                    // If an impl disallowed this item, then this is resolve's\n-                    // way of saying that a struct/enum's static method was\n-                    // invoked, and the struct/enum itself is private. Crawl\n-                    // back up the chains to find the relevant struct/enum that\n-                    // was private.\n-                    hir::ItemImpl(_, _, _, _, ref ty, _) => {\n-                        match ty.node {\n-                            hir::TyPath(..) => {}\n-                            _ => return Some((err_span, err_msg, None)),\n-                        };\n-                        let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n-                        let did = def.def_id();\n-                        let node_id = self.tcx.map.as_local_node_id(did).unwrap();\n-                        match self.tcx.map.get(node_id) {\n-                            ast_map::NodeItem(item) => item,\n-                            _ => self.tcx.sess.span_bug(item.span,\n-                                                        \"path is not an item\")\n-                        }\n-                    }\n-                    _ => item\n-                }\n-            }\n-            Some(..) | None => return Some((err_span, err_msg, None)),\n-        };\n-        let desc = match item.node {\n-            hir::ItemMod(..) => \"module\",\n-            hir::ItemTrait(..) => \"trait\",\n-            hir::ItemStruct(..) => \"struct\",\n-            hir::ItemEnum(..) => \"enum\",\n-            _ => return Some((err_span, err_msg, None))\n-        };\n-        let msg = format!(\"{} `{}` is private\", desc, item.name);\n-        Some((err_span, err_msg, Some((span, msg))))\n-    }\n-\n     // Checks that a field is in scope.\n     fn check_field(&mut self,\n                    span: Span,\n                    def: ty::AdtDef<'tcx>,\n                    v: ty::VariantDef<'tcx>,\n                    name: FieldName) {\n         let field = match name {\n-            NamedField(f_name) => {\n-                debug!(\"privacy - check named field {} in struct {:?}\", f_name, def);\n-                v.field_named(f_name)\n-            }\n+            NamedField(f_name) => v.field_named(f_name),\n             UnnamedField(idx) => &v.fields[idx]\n         };\n-        if field.vis == hir::Public || self.local_private_accessible(def.did) {\n+        if field.vis == hir::Public || self.private_accessible(def.did) {\n             return;\n         }\n \n@@ -766,40 +427,23 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             ty::AdtKind::Enum => return\n         };\n         let msg = match name {\n-            NamedField(name) => format!(\"field `{}` of {} is private\",\n-                                        name, struct_desc),\n-            UnnamedField(idx) => format!(\"field #{} of {} is private\",\n-                                         idx, struct_desc),\n+            NamedField(name) => format!(\"field `{}` of {} is private\", name, struct_desc),\n+            UnnamedField(idx) => format!(\"field #{} of {} is private\", idx, struct_desc),\n         };\n-        span_err!(self.tcx.sess, span, E0451,\n-                  \"{}\", &msg[..]);\n-    }\n-\n-    // Given the ID of a method, checks to ensure it's in scope.\n-    fn check_static_method(&mut self,\n-                           span: Span,\n-                           method_id: DefId,\n-                           name: ast::Name) {\n-        self.report_error(self.ensure_public(span,\n-                                             method_id,\n-                                             None,\n-                                             &format!(\"method `{}`\",\n-                                                     name)));\n+        span_err!(self.tcx.sess, span, E0451, \"{}\", msg);\n     }\n \n     // Checks that a method is in scope.\n-    fn check_method(&mut self, span: Span, method_def_id: DefId,\n-                    name: ast::Name) {\n+    fn check_method(&mut self, span: Span, method_def_id: DefId) {\n         match self.tcx.impl_or_trait_item(method_def_id).container() {\n-            ty::ImplContainer(_) => {\n-                self.check_static_method(span, method_def_id, name)\n-            }\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n-            ty::TraitContainer(trait_def_id) => {\n-                let msg = format!(\"source trait `{}`\", self.tcx.item_path_str(trait_def_id));\n-                self.report_error(self.ensure_public(span, trait_def_id, None, &msg));\n+            ty::TraitContainer(trait_def_id) if !self.item_is_visible(trait_def_id) => {\n+                let msg = format!(\"source trait `{}` is private\",\n+                                  self.tcx.item_path_str(trait_def_id));\n+                self.tcx.sess.span_err(span, &msg);\n             }\n+            _ => {}\n         }\n     }\n }\n@@ -819,27 +463,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n-            hir::ExprField(ref base, name) => {\n-                if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&base).sty {\n-                    self.check_field(expr.span,\n-                                     def,\n-                                     def.struct_variant(),\n-                                     NamedField(name.node));\n-                }\n-            }\n-            hir::ExprTupField(ref base, idx) => {\n-                if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&base).sty {\n-                    self.check_field(expr.span,\n-                                     def,\n-                                     def.struct_variant(),\n-                                     UnnamedField(idx.node));\n-                }\n-            }\n-            hir::ExprMethodCall(name, _, _) => {\n+            hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n                 let method = self.tcx.tables.borrow().method_map[&method_call];\n                 debug!(\"(privacy checking) checking impl method\");\n-                self.check_method(expr.span, method.def_id, name.node);\n+                self.check_method(expr.span, method.def_id);\n             }\n             hir::ExprStruct(..) => {\n                 let adt = self.tcx.expr_ty(expr).ty_adt_def().unwrap();\n@@ -862,7 +490,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         _ => expr_ty\n                     }.ty_adt_def().unwrap();\n                     let any_priv = def.struct_variant().fields.iter().any(|f| {\n-                        f.vis != hir::Public && !self.local_private_accessible(def.did)\n+                        f.vis != hir::Public && !self.private_accessible(def.did)\n                     });\n                     if any_priv {\n                         span_err!(self.tcx.sess, expr.span, E0450,\n@@ -1575,20 +1203,11 @@ pub fn check_crate(tcx: &TyCtxt, export_map: &def::ExportMap) -> AccessLevels {\n     let mut visitor = SanePrivacyVisitor { tcx: tcx };\n     krate.visit_all_items(&mut visitor);\n \n-    // Figure out who everyone's parent is\n-    let mut visitor = ParentVisitor {\n-        tcx: tcx,\n-        parents: NodeMap(),\n-        curparent: ast::DUMMY_NODE_ID,\n-    };\n-    intravisit::walk_crate(&mut visitor, krate);\n-\n     // Use the parent map to check the privacy of everything\n     let mut visitor = PrivacyVisitor {\n         curitem: ast::DUMMY_NODE_ID,\n         in_foreign: false,\n         tcx: tcx,\n-        parents: visitor.parents,\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n "}]}