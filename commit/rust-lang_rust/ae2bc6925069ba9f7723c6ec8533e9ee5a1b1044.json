{"sha": "ae2bc6925069ba9f7723c6ec8533e9ee5a1b1044", "node_id": "C_kwDOAAsO6NoAKGFlMmJjNjkyNTA2OWJhOWY3NzIzYzZlYzg1MzNlOWVlNWExYjEwNDQ", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-12-18T21:33:01Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-12-28T02:18:37Z"}, "message": "intra-doc: Use an enum to represent URL fragments\n\nThis is a step in the direction of computing the links more lazily,\nwhich I think will simplify the implementation of intra-doc links.\nThis will also make it easier to eventually use the actual `Res` for\nassociated items, enum variants, and fields, rather than their HTML\npage's `Res`.", "tree": {"sha": "6acfc2d5e8641bbd04d95fe23e68259a8a056c1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6acfc2d5e8641bbd04d95fe23e68259a8a056c1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae2bc6925069ba9f7723c6ec8533e9ee5a1b1044", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae2bc6925069ba9f7723c6ec8533e9ee5a1b1044", "html_url": "https://github.com/rust-lang/rust/commit/ae2bc6925069ba9f7723c6ec8533e9ee5a1b1044", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae2bc6925069ba9f7723c6ec8533e9ee5a1b1044/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4472d9755b3357f4d877d8f264c598d7aefbab05", "url": "https://api.github.com/repos/rust-lang/rust/commits/4472d9755b3357f4d877d8f264c598d7aefbab05", "html_url": "https://github.com/rust-lang/rust/commit/4472d9755b3357f4d877d8f264c598d7aefbab05"}], "stats": {"total": 191, "additions": 113, "deletions": 78}, "files": [{"sha": "d928b41cad49acf0893ac82a03aadcb1e61a1ce0", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae2bc6925069ba9f7723c6ec8533e9ee5a1b1044/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2bc6925069ba9f7723c6ec8533e9ee5a1b1044/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=ae2bc6925069ba9f7723c6ec8533e9ee5a1b1044", "patch": "@@ -1,5 +1,6 @@\n use std::cell::RefCell;\n use std::default::Default;\n+use std::fmt::Write;\n use std::hash::Hash;\n use std::lazy::SyncOnceCell as OnceCell;\n use std::path::PathBuf;\n@@ -40,6 +41,7 @@ use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::html::render::cache::ExternalLocation;\n use crate::html::render::Context;\n+use crate::passes::collect_intra_doc_links::UrlFragment;\n \n crate use self::FnRetTy::*;\n crate use self::ItemKind::*;\n@@ -485,8 +487,7 @@ impl Item {\n                 if let Ok((mut href, ..)) = href(*did, cx) {\n                     debug!(?href);\n                     if let Some(ref fragment) = *fragment {\n-                        href.push('#');\n-                        href.push_str(fragment);\n+                        write!(href, \"{}\", fragment).unwrap()\n                     }\n                     Some(RenderedLink {\n                         original_text: s.clone(),\n@@ -977,7 +978,7 @@ crate struct ItemLink {\n     pub(crate) link_text: String,\n     pub(crate) did: DefId,\n     /// The url fragment to append to the link\n-    pub(crate) fragment: Option<String>,\n+    pub(crate) fragment: Option<UrlFragment>,\n }\n \n pub struct RenderedLink {"}, {"sha": "ba355107ed680e211f8420e47919655c0471c3f3", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 109, "deletions": 75, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/ae2bc6925069ba9f7723c6ec8533e9ee5a1b1044/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2bc6925069ba9f7723c6ec8533e9ee5a1b1044/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=ae2bc6925069ba9f7723c6ec8533e9ee5a1b1044", "patch": "@@ -238,12 +238,65 @@ enum AnchorFailure {\n     RustdocAnchorConflict(Res),\n }\n \n+#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n+crate enum UrlFragment {\n+    Method(Symbol),\n+    TyMethod(Symbol),\n+    AssociatedConstant(Symbol),\n+    AssociatedType(Symbol),\n+\n+    StructField(Symbol),\n+    Variant(Symbol),\n+    VariantField { variant: Symbol, field: Symbol },\n+\n+    UserWritten(String),\n+}\n+\n+impl UrlFragment {\n+    /// Create a fragment for an associated item.\n+    ///\n+    /// `is_prototype` is whether this associated item is a trait method\n+    /// without a default definition.\n+    fn from_assoc_item(name: Symbol, kind: ty::AssocKind, is_prototype: bool) -> Self {\n+        match kind {\n+            ty::AssocKind::Fn => {\n+                if is_prototype {\n+                    UrlFragment::TyMethod(name)\n+                } else {\n+                    UrlFragment::Method(name)\n+                }\n+            }\n+            ty::AssocKind::Const => UrlFragment::AssociatedConstant(name),\n+            ty::AssocKind::Type => UrlFragment::AssociatedType(name),\n+        }\n+    }\n+}\n+\n+/// Render the fragment, including the leading `#`.\n+impl std::fmt::Display for UrlFragment {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"#\")?;\n+        match self {\n+            UrlFragment::Method(name) => write!(f, \"method.{}\", name),\n+            UrlFragment::TyMethod(name) => write!(f, \"tymethod.{}\", name),\n+            UrlFragment::AssociatedConstant(name) => write!(f, \"associatedconstant.{}\", name),\n+            UrlFragment::AssociatedType(name) => write!(f, \"associatedtype.{}\", name),\n+            UrlFragment::StructField(name) => write!(f, \"structfield.{}\", name),\n+            UrlFragment::Variant(name) => write!(f, \"variant.{}\", name),\n+            UrlFragment::VariantField { variant, field } => {\n+                write!(f, \"variant.{}.field.{}\", variant, field)\n+            }\n+            UrlFragment::UserWritten(raw) => write!(f, \"{}\", raw),\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n struct ResolutionInfo {\n     module_id: DefId,\n     dis: Option<Disambiguator>,\n     path_str: String,\n-    extra_fragment: Option<String>,\n+    extra_fragment: Option<UrlFragment>,\n }\n \n #[derive(Clone)]\n@@ -256,7 +309,7 @@ struct DiagnosticInfo<'a> {\n \n #[derive(Clone, Debug, Hash)]\n struct CachedLink {\n-    pub res: (Res, Option<String>),\n+    pub res: (Res, Option<UrlFragment>),\n     pub side_channel: Option<(DefKind, DefId)>,\n }\n \n@@ -287,7 +340,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &self,\n         path_str: &'path str,\n         module_id: DefId,\n-    ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n+    ) -> Result<(Res, Option<UrlFragment>), ErrorKind<'path>> {\n         let tcx = self.cx.tcx;\n         let no_res = || ResolutionFailure::NotResolved {\n             module_id,\n@@ -297,15 +350,15 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n         debug!(\"looking for enum variant {}\", path_str);\n         let mut split = path_str.rsplitn(3, \"::\");\n-        let (variant_field_str, variant_field_name) = split\n+        let variant_field_name = split\n             .next()\n-            .map(|f| (f, Symbol::intern(f)))\n+            .map(|f| Symbol::intern(f))\n             .expect(\"fold_item should ensure link is non-empty\");\n-        let (variant_str, variant_name) =\n+        let variant_name =\n             // we're not sure this is a variant at all, so use the full string\n             // If there's no second component, the link looks like `[path]`.\n             // So there's no partial res and we should say the whole link failed to resolve.\n-            split.next().map(|f| (f, Symbol::intern(f))).ok_or_else(no_res)?;\n+            split.next().map(|f|  Symbol::intern(f)).ok_or_else(no_res)?;\n         let path = split\n             .next()\n             .map(|f| f.to_owned())\n@@ -337,16 +390,16 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         if def.all_fields().any(|item| item.ident.name == variant_field_name) {\n                             Ok((\n                                 ty_res,\n-                                Some(format!(\n-                                    \"variant.{}.field.{}\",\n-                                    variant_str, variant_field_name\n-                                )),\n+                                Some(UrlFragment::VariantField {\n+                                    variant: variant_name,\n+                                    field: variant_field_name,\n+                                }),\n                             ))\n                         } else {\n                             Err(ResolutionFailure::NotResolved {\n                                 module_id,\n                                 partial_res: Some(Res::Def(DefKind::Enum, def.did)),\n-                                unresolved: variant_field_str.into(),\n+                                unresolved: variant_field_name.to_string().into(),\n                             }\n                             .into())\n                         }\n@@ -357,7 +410,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             _ => Err(ResolutionFailure::NotResolved {\n                 module_id,\n                 partial_res: Some(ty_res),\n-                unresolved: variant_str.into(),\n+                unresolved: variant_name.to_string().into(),\n             }\n             .into()),\n         }\n@@ -369,20 +422,15 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         prim_ty: PrimitiveType,\n         ns: Namespace,\n         item_name: Symbol,\n-    ) -> Option<(Res, String, Option<(DefKind, DefId)>)> {\n+    ) -> Option<(Res, UrlFragment, Option<(DefKind, DefId)>)> {\n         let tcx = self.cx.tcx;\n \n         prim_ty.impls(tcx).into_iter().find_map(|&impl_| {\n             tcx.associated_items(impl_)\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n                 .map(|item| {\n                     let kind = item.kind;\n-                    let out = match kind {\n-                        ty::AssocKind::Fn => \"method\",\n-                        ty::AssocKind::Const => \"associatedconstant\",\n-                        ty::AssocKind::Type => \"associatedtype\",\n-                    };\n-                    let fragment = format!(\"{}.{}\", out, item_name);\n+                    let fragment = UrlFragment::from_assoc_item(item_name, kind, false);\n                     (Res::Primitive(prim_ty), fragment, Some((kind.as_def_kind(), item.def_id)))\n                 })\n         })\n@@ -457,8 +505,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'path str,\n         ns: Namespace,\n         module_id: DefId,\n-        extra_fragment: &Option<String>,\n-    ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n+        extra_fragment: &Option<UrlFragment>,\n+    ) -> Result<(Res, Option<UrlFragment>), ErrorKind<'path>> {\n         if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n             match res {\n                 // FIXME(#76467): make this fallthrough to lookup the associated\n@@ -580,7 +628,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         item_name: Symbol,\n         ns: Namespace,\n         module_id: DefId,\n-    ) -> Option<(Res, String, Option<(DefKind, DefId)>)> {\n+    ) -> Option<(Res, UrlFragment, Option<(DefKind, DefId)>)> {\n         let tcx = self.cx.tcx;\n \n         match root_res {\n@@ -609,7 +657,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             imp,\n                         )\n                     })\n-                    .map(|item| (item.kind, item.def_id))\n+                    .copied()\n                     // There should only ever be one associated item that matches from any inherent impl\n                     .next()\n                     // Check if item_name belongs to `impl SomeTrait for SomeItem`\n@@ -618,26 +666,19 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // To handle that properly resolve() would have to support\n                     // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n                     .or_else(|| {\n-                        let kind =\n+                        let item =\n                             resolve_associated_trait_item(did, module_id, item_name, ns, self.cx);\n-                        debug!(\"got associated item kind {:?}\", kind);\n-                        kind\n+                        debug!(\"got associated item {:?}\", item);\n+                        item\n                     });\n \n-                if let Some((kind, id)) = assoc_item {\n-                    let out = match kind {\n-                        ty::AssocKind::Fn => \"method\",\n-                        ty::AssocKind::Const => \"associatedconstant\",\n-                        ty::AssocKind::Type => \"associatedtype\",\n-                    };\n+                if let Some(item) = assoc_item {\n+                    let kind = item.kind;\n+                    let fragment = UrlFragment::from_assoc_item(item_name, kind, false);\n                     // HACK(jynelson): `clean` expects the type, not the associated item\n                     // but the disambiguator logic expects the associated item.\n                     // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                    return Some((\n-                        root_res,\n-                        format!(\"{}.{}\", out, item_name),\n-                        Some((kind.as_def_kind(), id)),\n-                    ));\n+                    return Some((root_res, fragment, Some((kind.as_def_kind(), item.def_id))));\n                 }\n \n                 if ns != Namespace::ValueNS {\n@@ -657,34 +698,25 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     def.non_enum_variant().fields.iter().find(|item| item.ident.name == item_name)\n                 }?;\n                 let kind = if def.is_enum() { DefKind::Variant } else { DefKind::Field };\n-                Some((\n-                    root_res,\n-                    format!(\n-                        \"{}.{}\",\n-                        if def.is_enum() { \"variant\" } else { \"structfield\" },\n-                        field.ident\n-                    ),\n-                    Some((kind, field.did)),\n-                ))\n+                let fragment = if def.is_enum() {\n+                    // FIXME: how can the field be a variant?\n+                    UrlFragment::Variant(field.ident.name)\n+                } else {\n+                    UrlFragment::StructField(field.ident.name)\n+                };\n+                Some((root_res, fragment, Some((kind, field.did))))\n             }\n             Res::Def(DefKind::Trait, did) => tcx\n                 .associated_items(did)\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, did)\n                 .map(|item| {\n-                    let kind = match item.kind {\n-                        ty::AssocKind::Const => \"associatedconstant\",\n-                        ty::AssocKind::Type => \"associatedtype\",\n-                        ty::AssocKind::Fn => {\n-                            if item.defaultness.has_value() {\n-                                \"method\"\n-                            } else {\n-                                \"tymethod\"\n-                            }\n-                        }\n-                    };\n-\n+                    let fragment = UrlFragment::from_assoc_item(\n+                        item_name,\n+                        item.kind,\n+                        !item.defaultness.has_value(),\n+                    );\n                     let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n-                    (res, format!(\"{}.{}\", kind, item_name), None)\n+                    (res, fragment, None)\n                 }),\n             _ => None,\n         }\n@@ -701,7 +733,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         ns: Namespace,\n         path_str: &str,\n         module_id: DefId,\n-        extra_fragment: &Option<String>,\n+        extra_fragment: &Option<UrlFragment>,\n     ) -> Option<Res> {\n         // resolve() can't be used for macro namespace\n         let result = match ns {\n@@ -732,7 +764,7 @@ fn resolve_associated_trait_item(\n     item_name: Symbol,\n     ns: Namespace,\n     cx: &mut DocContext<'_>,\n-) -> Option<(ty::AssocKind, DefId)> {\n+) -> Option<ty::AssocItem> {\n     // FIXME: this should also consider blanket impls (`impl<T> X for T`). Unfortunately\n     // `get_auto_trait_and_blanket_impls` is broken because the caching behavior is wrong. In the\n     // meantime, just don't look for these blanket impls.\n@@ -742,14 +774,16 @@ fn resolve_associated_trait_item(\n     let traits = traits_implemented_by(cx, did, module);\n     debug!(\"considering traits {:?}\", traits);\n     let mut candidates = traits.iter().filter_map(|&trait_| {\n-        cx.tcx\n-            .associated_items(trait_)\n-            .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, trait_)\n-            .map(|assoc| (assoc.kind, assoc.def_id))\n+        cx.tcx.associated_items(trait_).find_by_name_and_namespace(\n+            cx.tcx,\n+            Ident::with_dummy_span(item_name),\n+            ns,\n+            trait_,\n+        )\n     });\n     // FIXME(#74563): warn about ambiguity\n     debug!(\"the candidates were {:?}\", candidates.clone().collect::<Vec<_>>());\n-    candidates.next()\n+    candidates.next().copied()\n }\n \n /// Given a type, return all traits in scope in `module` implemented by that type.\n@@ -940,7 +974,7 @@ impl From<AnchorFailure> for PreprocessingError<'_> {\n struct PreprocessingInfo {\n     path_str: String,\n     disambiguator: Option<Disambiguator>,\n-    extra_fragment: Option<String>,\n+    extra_fragment: Option<UrlFragment>,\n     link_text: String,\n }\n \n@@ -1026,7 +1060,7 @@ fn preprocess_link<'a>(\n     Some(Ok(PreprocessingInfo {\n         path_str,\n         disambiguator,\n-        extra_fragment: extra_fragment.map(String::from),\n+        extra_fragment: extra_fragment.map(|frag| UrlFragment::UserWritten(frag.to_owned())),\n         link_text: link_text.to_owned(),\n     }))\n }\n@@ -1144,7 +1178,7 @@ impl LinkCollector<'_, '_> {\n                 module_id,\n                 dis: disambiguator,\n                 path_str: path_str.to_owned(),\n-                extra_fragment: extra_fragment.map(String::from),\n+                extra_fragment,\n             },\n             diag_info.clone(), // this struct should really be Copy, but Range is not :(\n             matches!(ori_link.kind, LinkType::Reference | LinkType::Shortcut),\n@@ -1301,7 +1335,7 @@ impl LinkCollector<'_, '_> {\n         key: ResolutionInfo,\n         diag: DiagnosticInfo<'_>,\n         cache_resolution_failure: bool,\n-    ) -> Option<(Res, Option<String>)> {\n+    ) -> Option<(Res, Option<UrlFragment>)> {\n         // Try to look up both the result and the corresponding side channel value\n         if let Some(ref cached) = self.visited_links.get(&key) {\n             match cached {\n@@ -1349,7 +1383,7 @@ impl LinkCollector<'_, '_> {\n         &mut self,\n         key: &ResolutionInfo,\n         diag: DiagnosticInfo<'_>,\n-    ) -> Option<(Res, Option<String>)> {\n+    ) -> Option<(Res, Option<UrlFragment>)> {\n         let disambiguator = key.dis;\n         let path_str = &key.path_str;\n         let base_node = key.module_id;\n@@ -2179,8 +2213,8 @@ fn privacy_error(cx: &DocContext<'_>, diag_info: &DiagnosticInfo<'_>, path_str:\n fn handle_variant(\n     cx: &DocContext<'_>,\n     res: Res,\n-    extra_fragment: &Option<String>,\n-) -> Result<(Res, Option<String>), ErrorKind<'static>> {\n+    extra_fragment: &Option<UrlFragment>,\n+) -> Result<(Res, Option<UrlFragment>), ErrorKind<'static>> {\n     use rustc_middle::ty::DefIdTree;\n \n     if extra_fragment.is_some() {\n@@ -2192,7 +2226,7 @@ fn handle_variant(\n         .map(|parent| {\n             let parent_def = Res::Def(DefKind::Enum, parent);\n             let variant = cx.tcx.expect_variant_res(res.as_hir_res().unwrap());\n-            (parent_def, Some(format!(\"variant.{}\", variant.ident.name)))\n+            (parent_def, Some(UrlFragment::Variant(variant.ident.name)))\n         })\n         .ok_or_else(|| ResolutionFailure::NoParentItem.into())\n }"}]}