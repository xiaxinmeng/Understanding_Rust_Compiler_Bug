{"sha": "a3b6e8ef996c9e2ce31017e9df692c60fde7775a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzYjZlOGVmOTk2YzllMmNlMzEwMTdlOWRmNjkyYzYwZmRlNzc3NWE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-17T20:57:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-17T20:57:29Z"}, "message": "Rollup merge of #62451 - SimonSapin:new_uninit, r=RalfJung\n\nAdd APIs for uninitialized Box, Rc, and Arc. (Plus get_mut_unchecked)\n\nAssigning `MaybeUninit::<Foo>::uninit()` to a local variable is usually free, even when `size_of::<Foo>()` is large. However, passing it for example to `Arc::new` [causes at least one copy](https://youtu.be/F1AquroPfcI?t=4116) (from the stack to the newly allocated heap memory) even though there is no meaningful data. It is theoretically possible that a Sufficiently Advanced Compiler could optimize this copy away, but this is [reportedly unlikely to happen soon in LLVM](https://youtu.be/F1AquroPfcI?t=5431).\n\nThis PR proposes two sets of features:\n\n* Constructors for containers (`Box`, `Rc`, `Arc`) of `MaybeUninit<T>` or `[MaybeUninit<T>]` that do not initialized the data, and unsafe conversions to the known-initialized types (without `MaybeUninit`). The constructors are guaranteed not to make unnecessary copies.\n\n* On `Rc` and `Arc`, an unsafe `get_mut_unchecked` method that provides `&mut T` access without checking the reference count. `Arc::get_mut` involves multiple atomic operations whose cost can be non-trivial. `Rc::get_mut` is less costly, but we add `Rc::get_mut_unchecked` anyway for symmetry with `Arc`.\n\n  These can be useful independently, but they will presumably be typical when the new constructors of `Rc` and `Arc` are used.\n\n  An alternative with a safe API would be to introduce `UniqueRc` and `UniqueArc` types that have the same memory layout as `Rc` and `Arc` (and so zero-cost conversion to them) but are guaranteed to have only one reference. But introducing entire new types feels \u201cheavier\u201d than new constructors on existing types, and initialization of `MaybeUninit<T>` typically requires unsafe code anyway.\n\nSummary of new APIs (all unstable in this PR):\n\n```rust\nimpl<T> Box<T> { pub fn new_uninit() -> Box<MaybeUninit<T>> {\u2026} }\nimpl<T> Box<MaybeUninit<T>> { pub unsafe fn assume_init(self) -> Box<T> {\u2026} }\nimpl<T> Box<[T]> { pub fn new_uninit_slice(len: usize) -> Box<[MaybeUninit<T>]> {\u2026} }\nimpl<T> Box<[MaybeUninit<T>]> { pub unsafe fn assume_init(self) -> Box<[T]> {\u2026} }\n\nimpl<T> Rc<T> { pub fn new_uninit() -> Rc<MaybeUninit<T>> {\u2026} }\nimpl<T> Rc<MaybeUninit<T>> { pub unsafe fn assume_init(self) -> Rc<T> {\u2026} }\nimpl<T> Rc<[T]> { pub fn new_uninit_slice(len: usize) -> Rc<[MaybeUninit<T>]> {\u2026} }\nimpl<T> Rc<[MaybeUninit<T>]> { pub unsafe fn assume_init(self) -> Rc<[T]> {\u2026} }\n\nimpl<T> Arc<T> { pub fn new_uninit() -> Arc<MaybeUninit<T>> {\u2026} }\nimpl<T> Arc<MaybeUninit<T>> { pub unsafe fn assume_init(self) -> Arc<T> {\u2026} }\nimpl<T> Arc<[T]> { pub fn new_uninit_slice(len: usize) -> Arc<[MaybeUninit<T>]> {\u2026} }\nimpl<T> Arc<[MaybeUninit<T>]> { pub unsafe fn assume_init(self) -> Arc<[T]> {\u2026} }\n\nimpl<T: ?Sized> Rc<T> { pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\u2026} }\nimpl<T: ?Sized> Arc<T> { pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\u2026} }\n```", "tree": {"sha": "874f51a997d1e55b1d02189b268d96e4810fd8c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/874f51a997d1e55b1d02189b268d96e4810fd8c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3b6e8ef996c9e2ce31017e9df692c60fde7775a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdWGo5CRBK7hj4Ov3rIwAAdHIIAFlVoD+gqFUgE2SCpp6tPANg\nr8jf1OH0k9G7IoIzISvhNzW1+KqX/tC4JDQmYydIy44qUcXx+fa7SSSpEWifSERQ\nmEe9OyrKnqDqVBWnIwuW9+RmbvJ+evHJ8WGYj1KCP3BhAqIYqnEFJ3kQFJcbmGTV\n5F52k4KDvpFbEroUXF60TWcPhRkGGEOa6h1p78BnnPxey1uX/j3qWqIqqtE1+BOZ\nJpn61igdoEeMFUOVX93m0vXxusfqgZP43cyjlsZ6vAA2siHWNMjrTWd5ly7EVMH4\nyZe75ZSYJB5jeOza6FsWSajuQ2dlWnNPYxwloXvHgHme+KZ9KQvXgChOKiESeME=\n=AbAD\n-----END PGP SIGNATURE-----\n", "payload": "tree 874f51a997d1e55b1d02189b268d96e4810fd8c8\nparent d65e272a9fe3e61aa5f229c5358e35a909435575\nparent 9bd70834b0084f17d622b204a22dc80835d8d962\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1566075449 +0200\ncommitter GitHub <noreply@github.com> 1566075449 +0200\n\nRollup merge of #62451 - SimonSapin:new_uninit, r=RalfJung\n\nAdd APIs for uninitialized Box, Rc, and Arc. (Plus get_mut_unchecked)\n\nAssigning `MaybeUninit::<Foo>::uninit()` to a local variable is usually free, even when `size_of::<Foo>()` is large. However, passing it for example to `Arc::new` [causes at least one copy](https://youtu.be/F1AquroPfcI?t=4116) (from the stack to the newly allocated heap memory) even though there is no meaningful data. It is theoretically possible that a Sufficiently Advanced Compiler could optimize this copy away, but this is [reportedly unlikely to happen soon in LLVM](https://youtu.be/F1AquroPfcI?t=5431).\n\nThis PR proposes two sets of features:\n\n* Constructors for containers (`Box`, `Rc`, `Arc`) of `MaybeUninit<T>` or `[MaybeUninit<T>]` that do not initialized the data, and unsafe conversions to the known-initialized types (without `MaybeUninit`). The constructors are guaranteed not to make unnecessary copies.\n\n* On `Rc` and `Arc`, an unsafe `get_mut_unchecked` method that provides `&mut T` access without checking the reference count. `Arc::get_mut` involves multiple atomic operations whose cost can be non-trivial. `Rc::get_mut` is less costly, but we add `Rc::get_mut_unchecked` anyway for symmetry with `Arc`.\n\n  These can be useful independently, but they will presumably be typical when the new constructors of `Rc` and `Arc` are used.\n\n  An alternative with a safe API would be to introduce `UniqueRc` and `UniqueArc` types that have the same memory layout as `Rc` and `Arc` (and so zero-cost conversion to them) but are guaranteed to have only one reference. But introducing entire new types feels \u201cheavier\u201d than new constructors on existing types, and initialization of `MaybeUninit<T>` typically requires unsafe code anyway.\n\nSummary of new APIs (all unstable in this PR):\n\n```rust\nimpl<T> Box<T> { pub fn new_uninit() -> Box<MaybeUninit<T>> {\u2026} }\nimpl<T> Box<MaybeUninit<T>> { pub unsafe fn assume_init(self) -> Box<T> {\u2026} }\nimpl<T> Box<[T]> { pub fn new_uninit_slice(len: usize) -> Box<[MaybeUninit<T>]> {\u2026} }\nimpl<T> Box<[MaybeUninit<T>]> { pub unsafe fn assume_init(self) -> Box<[T]> {\u2026} }\n\nimpl<T> Rc<T> { pub fn new_uninit() -> Rc<MaybeUninit<T>> {\u2026} }\nimpl<T> Rc<MaybeUninit<T>> { pub unsafe fn assume_init(self) -> Rc<T> {\u2026} }\nimpl<T> Rc<[T]> { pub fn new_uninit_slice(len: usize) -> Rc<[MaybeUninit<T>]> {\u2026} }\nimpl<T> Rc<[MaybeUninit<T>]> { pub unsafe fn assume_init(self) -> Rc<[T]> {\u2026} }\n\nimpl<T> Arc<T> { pub fn new_uninit() -> Arc<MaybeUninit<T>> {\u2026} }\nimpl<T> Arc<MaybeUninit<T>> { pub unsafe fn assume_init(self) -> Arc<T> {\u2026} }\nimpl<T> Arc<[T]> { pub fn new_uninit_slice(len: usize) -> Arc<[MaybeUninit<T>]> {\u2026} }\nimpl<T> Arc<[MaybeUninit<T>]> { pub unsafe fn assume_init(self) -> Arc<[T]> {\u2026} }\n\nimpl<T: ?Sized> Rc<T> { pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\u2026} }\nimpl<T: ?Sized> Arc<T> { pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\u2026} }\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3b6e8ef996c9e2ce31017e9df692c60fde7775a", "html_url": "https://github.com/rust-lang/rust/commit/a3b6e8ef996c9e2ce31017e9df692c60fde7775a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3b6e8ef996c9e2ce31017e9df692c60fde7775a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d65e272a9fe3e61aa5f229c5358e35a909435575", "url": "https://api.github.com/repos/rust-lang/rust/commits/d65e272a9fe3e61aa5f229c5358e35a909435575", "html_url": "https://github.com/rust-lang/rust/commit/d65e272a9fe3e61aa5f229c5358e35a909435575"}, {"sha": "9bd70834b0084f17d622b204a22dc80835d8d962", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bd70834b0084f17d622b204a22dc80835d8d962", "html_url": "https://github.com/rust-lang/rust/commit/9bd70834b0084f17d622b204a22dc80835d8d962"}], "stats": {"total": 515, "additions": 505, "deletions": 10}, "files": [{"sha": "c61e3183409f267fcf83a9565ece1b58efdd096f", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/a3b6e8ef996c9e2ce31017e9df692c60fde7775a/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b6e8ef996c9e2ce31017e9df692c60fde7775a/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=a3b6e8ef996c9e2ce31017e9df692c60fde7775a", "patch": "@@ -91,8 +91,10 @@ use core::ops::{\n     CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Receiver, Generator, GeneratorState\n };\n use core::ptr::{self, NonNull, Unique};\n+use core::slice;\n use core::task::{Context, Poll};\n \n+use crate::alloc::{self, Global, Alloc};\n use crate::vec::Vec;\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n@@ -121,6 +123,34 @@ impl<T> Box<T> {\n         box x\n     }\n \n+    /// Constructs a new box with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut five = Box::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     five.as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n+        let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n+        let ptr = unsafe {\n+            Global.alloc(layout)\n+                .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n+        };\n+        Box(ptr.cast().into())\n+    }\n+\n     /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n     /// `x` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -130,6 +160,111 @@ impl<T> Box<T> {\n     }\n }\n \n+impl<T> Box<[T]> {\n+    /// Constructs a new boxed slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut values = Box::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     values[0].as_mut_ptr().write(1);\n+    ///     values[1].as_mut_ptr().write(2);\n+    ///     values[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n+        let layout = alloc::Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n+        let ptr = unsafe { alloc::alloc(layout) };\n+        let unique = Unique::new(ptr).unwrap_or_else(|| alloc::handle_alloc_error(layout));\n+        let slice = unsafe { slice::from_raw_parts_mut(unique.cast().as_ptr(), len) };\n+        Box(Unique::from(slice))\n+    }\n+}\n+\n+impl<T> Box<mem::MaybeUninit<T>> {\n+    /// Converts to `Box<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut five = Box::<u32>::new_uninit();\n+    ///\n+    /// let five: Box<u32> = unsafe {\n+    ///     // Deferred initialization:\n+    ///     five.as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Box<T> {\n+        Box(Box::into_unique(self).cast())\n+    }\n+}\n+\n+impl<T> Box<[mem::MaybeUninit<T>]> {\n+    /// Converts to `Box<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the values\n+    /// really are in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut values = Box::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     values[0].as_mut_ptr().write(1);\n+    ///     values[1].as_mut_ptr().write(2);\n+    ///     values[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Box<[T]> {\n+        Box(Unique::new_unchecked(Box::into_raw(self) as _))\n+    }\n+}\n+\n impl<T: ?Sized> Box<T> {\n     /// Constructs a box from a raw pointer.\n     ///"}, {"sha": "2b222caf13f3d48c3333aa35ff78a01e1ced57b1", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 181, "deletions": 5, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/a3b6e8ef996c9e2ce31017e9df692c60fde7775a/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b6e8ef996c9e2ce31017e9df692c60fde7775a/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=a3b6e8ef996c9e2ce31017e9df692c60fde7775a", "patch": "@@ -327,6 +327,37 @@ impl<T> Rc<T> {\n         }))\n     }\n \n+    /// Constructs a new `Rc` with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut five = Rc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit() -> Rc<mem::MaybeUninit<T>> {\n+        unsafe {\n+            Rc::from_ptr(Rc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |mem| mem as *mut RcBox<mem::MaybeUninit<T>>,\n+            ))\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Rc<T>>`. If `T` does not implement `Unpin`, then\n     /// `value` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -377,6 +408,118 @@ impl<T> Rc<T> {\n     }\n }\n \n+impl<T> Rc<[T]> {\n+    /// Constructs a new reference-counted slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut values = Rc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Rc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Rc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {\n+        unsafe {\n+            Rc::from_ptr(Rc::allocate_for_slice(len))\n+        }\n+    }\n+}\n+\n+impl<T> Rc<mem::MaybeUninit<T>> {\n+    /// Converts to `Rc<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut five = Rc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Rc<T> {\n+        Rc::from_inner(mem::ManuallyDrop::new(self).ptr.cast())\n+    }\n+}\n+\n+impl<T> Rc<[mem::MaybeUninit<T>]> {\n+    /// Converts to `Rc<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut values = Rc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Rc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Rc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Rc<[T]> {\n+        Rc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _)\n+    }\n+}\n+\n impl<T: ?Sized> Rc<T> {\n     /// Consumes the `Rc`, returning the wrapped pointer.\n     ///\n@@ -560,13 +703,46 @@ impl<T: ?Sized> Rc<T> {\n     pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n         if Rc::is_unique(this) {\n             unsafe {\n-                Some(&mut this.ptr.as_mut().value)\n+                Some(Rc::get_mut_unchecked(this))\n             }\n         } else {\n             None\n         }\n     }\n \n+    /// Returns a mutable reference to the inner value,\n+    /// without any check.\n+    ///\n+    /// See also [`get_mut`], which is safe and does appropriate checks.\n+    ///\n+    /// [`get_mut`]: struct.Rc.html#method.get_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// Any other `Rc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// for the duration of the returned borrow.\n+    /// This is trivially the case if no such pointers exist,\n+    /// for example immediately after `Rc::new`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut x = Rc::new(String::new());\n+    /// unsafe {\n+    ///     Rc::get_mut_unchecked(&mut x).push_str(\"foo\")\n+    /// }\n+    /// assert_eq!(*x, \"foo\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"get_mut_unchecked\", issue = \"63292\")]\n+    pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n+        &mut this.ptr.as_mut().value\n+    }\n+\n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n     /// Returns `true` if the two `Rc`s point to the same value (not\n@@ -704,11 +880,11 @@ impl Rc<dyn Any> {\n \n impl<T: ?Sized> Rc<T> {\n     /// Allocates an `RcBox<T>` with sufficient space for\n-    /// an unsized value where the value has the layout provided.\n+    /// a possibly-unsized value where the value has the layout provided.\n     ///\n     /// The function `mem_to_rcbox` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n-    unsafe fn allocate_for_unsized(\n+    unsafe fn allocate_for_layout(\n         value_layout: Layout,\n         mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>\n     ) -> *mut RcBox<T> {\n@@ -737,7 +913,7 @@ impl<T: ?Sized> Rc<T> {\n     /// Allocates an `RcBox<T>` with sufficient space for an unsized value\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n         // Allocate for the `RcBox<T>` using the given value.\n-        Self::allocate_for_unsized(\n+        Self::allocate_for_layout(\n             Layout::for_value(&*ptr),\n             |mem| set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>,\n         )\n@@ -768,7 +944,7 @@ impl<T: ?Sized> Rc<T> {\n impl<T> Rc<[T]> {\n     /// Allocates an `RcBox<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut RcBox<[T]> {\n-        Self::allocate_for_unsized(\n+        Self::allocate_for_layout(\n             Layout::array::<T>(len).unwrap(),\n             |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>,\n         )"}, {"sha": "341172136e25833f87837dd8aa5066b14d5b61de", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 181, "deletions": 5, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/a3b6e8ef996c9e2ce31017e9df692c60fde7775a/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b6e8ef996c9e2ce31017e9df692c60fde7775a/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=a3b6e8ef996c9e2ce31017e9df692c60fde7775a", "patch": "@@ -311,6 +311,37 @@ impl<T> Arc<T> {\n         Self::from_inner(Box::into_raw_non_null(x))\n     }\n \n+    /// Constructs a new `Arc` with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut five = Arc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit() -> Arc<mem::MaybeUninit<T>> {\n+        unsafe {\n+            Arc::from_ptr(Arc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |mem| mem as *mut ArcInner<mem::MaybeUninit<T>>,\n+            ))\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Arc<T>>`. If `T` does not implement `Unpin`, then\n     /// `data` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -361,6 +392,118 @@ impl<T> Arc<T> {\n     }\n }\n \n+impl<T> Arc<[T]> {\n+    /// Constructs a new reference-counted slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut values = Arc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Arc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Arc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n+        unsafe {\n+            Arc::from_ptr(Arc::allocate_for_slice(len))\n+        }\n+    }\n+}\n+\n+impl<T> Arc<mem::MaybeUninit<T>> {\n+    /// Converts to `Arc<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut five = Arc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Arc<T> {\n+        Arc::from_inner(mem::ManuallyDrop::new(self).ptr.cast())\n+    }\n+}\n+\n+impl<T> Arc<[mem::MaybeUninit<T>]> {\n+    /// Converts to `Arc<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut values = Arc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Arc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Arc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Arc<[T]> {\n+        Arc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _)\n+    }\n+}\n+\n impl<T: ?Sized> Arc<T> {\n     /// Consumes the `Arc`, returning the wrapped pointer.\n     ///\n@@ -593,11 +736,11 @@ impl<T: ?Sized> Arc<T> {\n \n impl<T: ?Sized> Arc<T> {\n     /// Allocates an `ArcInner<T>` with sufficient space for\n-    /// an unsized value where the value has the layout provided.\n+    /// a possibly-unsized value where the value has the layout provided.\n     ///\n     /// The function `mem_to_arcinner` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n-    unsafe fn allocate_for_unsized(\n+    unsafe fn allocate_for_layout(\n         value_layout: Layout,\n         mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>\n     ) -> *mut ArcInner<T> {\n@@ -625,7 +768,7 @@ impl<T: ?Sized> Arc<T> {\n     /// Allocates an `ArcInner<T>` with sufficient space for an unsized value.\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n         // Allocate for the `ArcInner<T>` using the given value.\n-        Self::allocate_for_unsized(\n+        Self::allocate_for_layout(\n             Layout::for_value(&*ptr),\n             |mem| set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>,\n         )\n@@ -656,7 +799,7 @@ impl<T: ?Sized> Arc<T> {\n impl<T> Arc<[T]> {\n     /// Allocates an `ArcInner<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut ArcInner<[T]> {\n-        Self::allocate_for_unsized(\n+        Self::allocate_for_layout(\n             Layout::array::<T>(len).unwrap(),\n             |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>,\n         )\n@@ -945,13 +1088,46 @@ impl<T: ?Sized> Arc<T> {\n             // the Arc itself to be `mut`, so we're returning the only possible\n             // reference to the inner data.\n             unsafe {\n-                Some(&mut this.ptr.as_mut().data)\n+                Some(Arc::get_mut_unchecked(this))\n             }\n         } else {\n             None\n         }\n     }\n \n+    /// Returns a mutable reference to the inner value,\n+    /// without any check.\n+    ///\n+    /// See also [`get_mut`], which is safe and does appropriate checks.\n+    ///\n+    /// [`get_mut`]: struct.Arc.html#method.get_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// Any other `Arc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// for the duration of the returned borrow.\n+    /// This is trivially the case if no such pointers exist,\n+    /// for example immediately after `Arc::new`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut x = Arc::new(String::new());\n+    /// unsafe {\n+    ///     Arc::get_mut_unchecked(&mut x).push_str(\"foo\")\n+    /// }\n+    /// assert_eq!(*x, \"foo\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"get_mut_unchecked\", issue = \"63292\")]\n+    pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n+        &mut this.ptr.as_mut().data\n+    }\n+\n     /// Determine whether this is the unique reference (including weak refs) to\n     /// the underlying data.\n     ///"}, {"sha": "3521dd799795672ab379af6cc25dab307f8ee91e", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3b6e8ef996c9e2ce31017e9df692c60fde7775a/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b6e8ef996c9e2ce31017e9df692c60fde7775a/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=a3b6e8ef996c9e2ce31017e9df692c60fde7775a", "patch": "@@ -122,6 +122,14 @@ impl<T: ?Sized> Unique<T> {\n     pub unsafe fn as_mut(&mut self) -> &mut T {\n         &mut *self.as_ptr()\n     }\n+\n+    /// Casts to a pointer of another type.\n+    #[inline]\n+    pub const fn cast<U>(self) -> Unique<U> {\n+        unsafe {\n+            Unique::new_unchecked(self.as_ptr() as *mut U)\n+        }\n+    }\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]"}]}