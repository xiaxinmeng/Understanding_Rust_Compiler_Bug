{"sha": "31e1a777e7b055b240b507a7c04719c0563852e9", "node_id": "C_kwDOAAsO6NoAKDMxZTFhNzc3ZTdiMDU1YjI0MGI1MDdhN2MwNDcxOWMwNTYzODUyZTk", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-07-01T01:27:13Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-07-08T01:45:40Z"}, "message": "Move code from rustc_trait_selection/opaque_types to better places", "tree": {"sha": "6a6a25eac386ad1da69ff7a14e3a5cd2df679459", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a6a25eac386ad1da69ff7a14e3a5cd2df679459"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31e1a777e7b055b240b507a7c04719c0563852e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31e1a777e7b055b240b507a7c04719c0563852e9", "html_url": "https://github.com/rust-lang/rust/commit/31e1a777e7b055b240b507a7c04719c0563852e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31e1a777e7b055b240b507a7c04719c0563852e9/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24714310170f0d0214ceafe114c24b8d5b6746f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/24714310170f0d0214ceafe114c24b8d5b6746f0", "html_url": "https://github.com/rust-lang/rust/commit/24714310170f0d0214ceafe114c24b8d5b6746f0"}], "stats": {"total": 1091, "additions": 542, "deletions": 549}, "files": [{"sha": "7c1fa28b8dfcc9c9e731e34b2beda85bcc2897bd", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 482, "deletions": 2, "changes": 484, "blob_url": "https://github.com/rust-lang/rust/blob/31e1a777e7b055b240b507a7c04719c0563852e9/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e1a777e7b055b240b507a7c04719c0563852e9/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=31e1a777e7b055b240b507a7c04719c0563852e9", "patch": "@@ -1,11 +1,20 @@\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::def_id::DefId;\n use rustc_hir::OpaqueTyOrigin;\n+use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n use rustc_infer::infer::InferCtxt;\n+use rustc_infer::infer::TyCtxtInferExt as _;\n+use rustc_infer::traits::{Obligation, ObligationCause, TraitEngine};\n+use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts};\n+use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n-    self, OpaqueHiddenType, OpaqueTypeKey, TyCtxt, TypeFoldable, TypeVisitable,\n+    self, OpaqueHiddenType, OpaqueTypeKey, ToPredicate, Ty, TyCtxt, TypeFoldable,\n };\n-use rustc_trait_selection::opaque_types::InferCtxtExt;\n+use rustc_span::Span;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::TraitEngineExt as _;\n \n use super::RegionInferenceContext;\n \n@@ -173,3 +182,474 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         })\n     }\n }\n+\n+pub trait InferCtxtExt<'tcx> {\n+    fn infer_opaque_definition_from_instantiation(\n+        &self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        instantiated_ty: OpaqueHiddenType<'tcx>,\n+        origin: OpaqueTyOrigin,\n+    ) -> Ty<'tcx>;\n+}\n+\n+impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n+    /// Given the fully resolved, instantiated type for an opaque\n+    /// type, i.e., the value of an inference variable like C1 or C2\n+    /// (*), computes the \"definition type\" for an opaque type\n+    /// definition -- that is, the inferred value of `Foo1<'x>` or\n+    /// `Foo2<'x>` that we would conceptually use in its definition:\n+    /// ```ignore (illustrative)\n+    /// type Foo1<'x> = impl Bar<'x> = AAA;  // <-- this type AAA\n+    /// type Foo2<'x> = impl Bar<'x> = BBB;  // <-- or this type BBB\n+    /// fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n+    /// ```\n+    /// Note that these values are defined in terms of a distinct set of\n+    /// generic parameters (`'x` instead of `'a`) from C1 or C2. The main\n+    /// purpose of this function is to do that translation.\n+    ///\n+    /// (*) C1 and C2 were introduced in the comments on\n+    /// `register_member_constraints`. Read that comment for more context.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `def_id`, the `impl Trait` type\n+    /// - `substs`, the substs  used to instantiate this opaque type\n+    /// - `instantiated_ty`, the inferred type C1 -- fully resolved, lifted version of\n+    ///   `opaque_defn.concrete_ty`\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn infer_opaque_definition_from_instantiation(\n+        &self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        instantiated_ty: OpaqueHiddenType<'tcx>,\n+        origin: OpaqueTyOrigin,\n+    ) -> Ty<'tcx> {\n+        if self.is_tainted_by_errors() {\n+            return self.tcx.ty_error();\n+        }\n+\n+        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n+\n+        // Use substs to build up a reverse map from regions to their\n+        // identity mappings. This is necessary because of `impl\n+        // Trait` lifetimes are computed by replacing existing\n+        // lifetimes with 'static and remapping only those used in the\n+        // `impl Trait` return type, resulting in the parameters\n+        // shifting.\n+        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id);\n+        debug!(?id_substs);\n+        let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> =\n+            substs.iter().enumerate().map(|(index, subst)| (subst, id_substs[index])).collect();\n+        debug!(\"map = {:#?}\", map);\n+\n+        // Convert the type from the function into a type valid outside\n+        // the function, by replacing invalid regions with 'static,\n+        // after producing an error for each of them.\n+        let definition_ty = instantiated_ty.ty.fold_with(&mut ReverseMapper::new(\n+            self.tcx,\n+            def_id,\n+            map,\n+            instantiated_ty.ty,\n+            instantiated_ty.span,\n+        ));\n+        debug!(?definition_ty);\n+\n+        if !check_opaque_type_parameter_valid(\n+            self.tcx,\n+            opaque_type_key,\n+            origin,\n+            instantiated_ty.span,\n+        ) {\n+            return self.tcx.ty_error();\n+        }\n+\n+        // Only check this for TAIT. RPIT already supports `src/test/ui/impl-trait/nested-return-type2.rs`\n+        // on stable and we'd break that.\n+        if let OpaqueTyOrigin::TyAlias = origin {\n+            // This logic duplicates most of `check_opaque_meets_bounds`.\n+            // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n+            let param_env = self.tcx.param_env(def_id);\n+            let body_id = self.tcx.local_def_id_to_hir_id(def_id.as_local().unwrap());\n+            self.tcx.infer_ctxt().enter(move |infcx| {\n+                // Require the hidden type to be well-formed with only the generics of the opaque type.\n+                // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n+                // hidden type is well formed even without those bounds.\n+                let predicate =\n+                    ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n+                        .to_predicate(infcx.tcx);\n+                let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n+\n+                // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n+                // the bounds that the function supplies.\n+                match infcx.register_hidden_type(\n+                    OpaqueTypeKey { def_id, substs: id_substs },\n+                    ObligationCause::misc(instantiated_ty.span, body_id),\n+                    param_env,\n+                    definition_ty,\n+                    origin,\n+                ) {\n+                    Ok(infer_ok) => {\n+                        for obligation in infer_ok.obligations {\n+                            fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n+                        }\n+                    }\n+                    Err(err) => {\n+                        infcx\n+                            .report_mismatched_types(\n+                                &ObligationCause::misc(instantiated_ty.span, body_id),\n+                                self.tcx.mk_opaque(def_id, id_substs),\n+                                definition_ty,\n+                                err,\n+                            )\n+                            .emit();\n+                    }\n+                }\n+\n+                fulfillment_cx.register_predicate_obligation(\n+                    &infcx,\n+                    Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n+                );\n+\n+                // Check that all obligations are satisfied by the implementation's\n+                // version.\n+                let errors = fulfillment_cx.select_all_or_error(&infcx);\n+\n+                let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+\n+                if errors.is_empty() {\n+                    definition_ty\n+                } else {\n+                    infcx.report_fulfillment_errors(&errors, None, false);\n+                    self.tcx.ty_error()\n+                }\n+            })\n+        } else {\n+            definition_ty\n+        }\n+    }\n+}\n+\n+fn check_opaque_type_parameter_valid(\n+    tcx: TyCtxt<'_>,\n+    opaque_type_key: OpaqueTypeKey<'_>,\n+    origin: OpaqueTyOrigin,\n+    span: Span,\n+) -> bool {\n+    match origin {\n+        // No need to check return position impl trait (RPIT)\n+        // because for type and const parameters they are correct\n+        // by construction: we convert\n+        //\n+        // fn foo<P0..Pn>() -> impl Trait\n+        //\n+        // into\n+        //\n+        // type Foo<P0...Pn>\n+        // fn foo<P0..Pn>() -> Foo<P0...Pn>.\n+        //\n+        // For lifetime parameters we convert\n+        //\n+        // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n+        //\n+        // into\n+        //\n+        // type foo::<'p0..'pn>::Foo<'q0..'qm>\n+        // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n+        //\n+        // which would error here on all of the `'static` args.\n+        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return true,\n+        // Check these\n+        OpaqueTyOrigin::TyAlias => {}\n+    }\n+    let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n+    let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+    for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n+        let arg_is_param = match arg.unpack() {\n+            GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n+            GenericArgKind::Lifetime(lt) if lt.is_static() => {\n+                tcx.sess\n+                    .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                    .span_label(\n+                        tcx.def_span(opaque_generics.param_at(i, tcx).def_id),\n+                        \"cannot use static lifetime; use a bound lifetime \\\n+                                    instead or remove the lifetime parameter from the \\\n+                                    opaque type\",\n+                    )\n+                    .emit();\n+                return false;\n+            }\n+            GenericArgKind::Lifetime(lt) => {\n+                matches!(*lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n+            }\n+            GenericArgKind::Const(ct) => matches!(ct.kind(), ty::ConstKind::Param(_)),\n+        };\n+\n+        if arg_is_param {\n+            seen_params.entry(arg).or_default().push(i);\n+        } else {\n+            // Prevent `fn foo() -> Foo<u32>` from being defining.\n+            let opaque_param = opaque_generics.param_at(i, tcx);\n+            tcx.sess\n+                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                .span_note(\n+                    tcx.def_span(opaque_param.def_id),\n+                    &format!(\n+                        \"used non-generic {} `{}` for generic parameter\",\n+                        opaque_param.kind.descr(),\n+                        arg,\n+                    ),\n+                )\n+                .emit();\n+            return false;\n+        }\n+    }\n+\n+    for (_, indices) in seen_params {\n+        if indices.len() > 1 {\n+            let descr = opaque_generics.param_at(indices[0], tcx).kind.descr();\n+            let spans: Vec<_> = indices\n+                .into_iter()\n+                .map(|i| tcx.def_span(opaque_generics.param_at(i, tcx).def_id))\n+                .collect();\n+            tcx.sess\n+                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                .span_note(spans, &format!(\"{} used multiple times\", descr))\n+                .emit();\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+struct ReverseMapper<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n+    opaque_type_def_id: DefId,\n+    map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n+    map_missing_regions_to_empty: bool,\n+\n+    /// initially `Some`, set to `None` once error has been reported\n+    hidden_ty: Option<Ty<'tcx>>,\n+\n+    /// Span of function being checked.\n+    span: Span,\n+}\n+\n+impl<'tcx> ReverseMapper<'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        opaque_type_def_id: DefId,\n+        map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n+        hidden_ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> Self {\n+        Self {\n+            tcx,\n+            opaque_type_def_id,\n+            map,\n+            map_missing_regions_to_empty: false,\n+            hidden_ty: Some(hidden_ty),\n+            span,\n+        }\n+    }\n+\n+    fn fold_kind_mapping_missing_regions_to_empty(\n+        &mut self,\n+        kind: GenericArg<'tcx>,\n+    ) -> GenericArg<'tcx> {\n+        assert!(!self.map_missing_regions_to_empty);\n+        self.map_missing_regions_to_empty = true;\n+        let kind = kind.fold_with(self);\n+        self.map_missing_regions_to_empty = false;\n+        kind\n+    }\n+\n+    fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n+        assert!(!self.map_missing_regions_to_empty);\n+        kind.fold_with(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            // Ignore bound regions and `'static` regions that appear in the\n+            // type, we only need to remap regions that reference lifetimes\n+            // from the function declaration.\n+            // This would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n+            ty::ReLateBound(..) | ty::ReStatic => return r,\n+\n+            // If regions have been erased (by writeback), don't try to unerase\n+            // them.\n+            ty::ReErased => return r,\n+\n+            // The regions that we expect from borrow checking.\n+            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReEmpty(ty::UniverseIndex::ROOT) => {}\n+\n+            ty::ReEmpty(_) | ty::RePlaceholder(_) | ty::ReVar(_) => {\n+                // All of the regions in the type should either have been\n+                // erased by writeback, or mapped back to named regions by\n+                // borrow checking.\n+                bug!(\"unexpected region kind in opaque type: {:?}\", r);\n+            }\n+        }\n+\n+        let generics = self.tcx().generics_of(self.opaque_type_def_id);\n+        match self.map.get(&r.into()).map(|k| k.unpack()) {\n+            Some(GenericArgKind::Lifetime(r1)) => r1,\n+            Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n+            None if self.map_missing_regions_to_empty => self.tcx.lifetimes.re_root_empty,\n+            None if generics.parent.is_some() => {\n+                if let Some(hidden_ty) = self.hidden_ty.take() {\n+                    unexpected_hidden_region_diagnostic(\n+                        self.tcx,\n+                        self.tcx.def_span(self.opaque_type_def_id),\n+                        hidden_ty,\n+                        r,\n+                    )\n+                    .emit();\n+                }\n+                self.tcx.lifetimes.re_root_empty\n+            }\n+            None => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(self.span, \"non-defining opaque type use in defining scope\")\n+                    .span_label(\n+                        self.span,\n+                        format!(\n+                            \"lifetime `{}` is part of concrete type but not used in \\\n+                                 parameter list of the `impl Trait` type alias\",\n+                            r\n+                        ),\n+                    )\n+                    .emit();\n+\n+                self.tcx().lifetimes.re_static\n+            }\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match *ty.kind() {\n+            ty::Closure(def_id, substs) => {\n+                // I am a horrible monster and I pray for death. When\n+                // we encounter a closure here, it is always a closure\n+                // from within the function that we are currently\n+                // type-checking -- one that is now being encapsulated\n+                // in an opaque type. Ideally, we would\n+                // go through the types/lifetimes that it references\n+                // and treat them just like we would any other type,\n+                // which means we would error out if we find any\n+                // reference to a type/region that is not in the\n+                // \"reverse map\".\n+                //\n+                // **However,** in the case of closures, there is a\n+                // somewhat subtle (read: hacky) consideration. The\n+                // problem is that our closure types currently include\n+                // all the lifetime parameters declared on the\n+                // enclosing function, even if they are unused by the\n+                // closure itself. We can't readily filter them out,\n+                // so here we replace those values with `'empty`. This\n+                // can't really make a difference to the rest of the\n+                // compiler; those regions are ignored for the\n+                // outlives relation, and hence don't affect trait\n+                // selection or auto traits, and they are erased\n+                // during codegen.\n+\n+                let generics = self.tcx.generics_of(def_id);\n+                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n+                    if index < generics.parent_count {\n+                        // Accommodate missing regions in the parent kinds...\n+                        self.fold_kind_mapping_missing_regions_to_empty(kind)\n+                    } else {\n+                        // ...but not elsewhere.\n+                        self.fold_kind_normally(kind)\n+                    }\n+                }));\n+\n+                self.tcx.mk_closure(def_id, substs)\n+            }\n+\n+            ty::Generator(def_id, substs, movability) => {\n+                let generics = self.tcx.generics_of(def_id);\n+                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n+                    if index < generics.parent_count {\n+                        // Accommodate missing regions in the parent kinds...\n+                        self.fold_kind_mapping_missing_regions_to_empty(kind)\n+                    } else {\n+                        // ...but not elsewhere.\n+                        self.fold_kind_normally(kind)\n+                    }\n+                }));\n+\n+                self.tcx.mk_generator(def_id, substs, movability)\n+            }\n+\n+            ty::Param(param) => {\n+                // Look it up in the substitution list.\n+                match self.map.get(&ty.into()).map(|k| k.unpack()) {\n+                    // Found it in the substitution list; replace with the parameter from the\n+                    // opaque type.\n+                    Some(GenericArgKind::Type(t1)) => t1,\n+                    Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n+                    None => {\n+                        debug!(?param, ?self.map);\n+                        self.tcx\n+                            .sess\n+                            .struct_span_err(\n+                                self.span,\n+                                &format!(\n+                                    \"type parameter `{}` is part of concrete type but not \\\n+                                          used in parameter list for the `impl Trait` type alias\",\n+                                    ty\n+                                ),\n+                            )\n+                            .emit();\n+\n+                        self.tcx().ty_error()\n+                    }\n+                }\n+            }\n+\n+            _ => ty.super_fold_with(self),\n+        }\n+    }\n+\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        trace!(\"checking const {:?}\", ct);\n+        // Find a const parameter\n+        match ct.kind() {\n+            ty::ConstKind::Param(..) => {\n+                // Look it up in the substitution list.\n+                match self.map.get(&ct.into()).map(|k| k.unpack()) {\n+                    // Found it in the substitution list, replace with the parameter from the\n+                    // opaque type.\n+                    Some(GenericArgKind::Const(c1)) => c1,\n+                    Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n+                    None => {\n+                        self.tcx\n+                            .sess\n+                            .struct_span_err(\n+                                self.span,\n+                                &format!(\n+                                    \"const parameter `{}` is part of concrete type but not \\\n+                                          used in parameter list for the `impl Trait` type alias\",\n+                                    ct\n+                                ),\n+                            )\n+                            .emit();\n+\n+                        self.tcx().const_error(ct.ty())\n+                    }\n+                }\n+            }\n+\n+            _ => ct,\n+        }\n+    }\n+}"}, {"sha": "282ee632ce5817dcf32fd54458f6663f7bf2264b", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31e1a777e7b055b240b507a7c04719c0563852e9/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e1a777e7b055b240b507a7c04719c0563852e9/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=31e1a777e7b055b240b507a7c04719c0563852e9", "patch": "@@ -37,5 +37,4 @@ extern crate smallvec;\n \n pub mod autoderef;\n pub mod infer;\n-pub mod opaque_types;\n pub mod traits;"}, {"sha": "d290f7b074cb5a894d89d704c227324ae5afa762", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "removed", "additions": 0, "deletions": 545, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/24714310170f0d0214ceafe114c24b8d5b6746f0/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24714310170f0d0214ceafe114c24b8d5b6746f0/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=24714310170f0d0214ceafe114c24b8d5b6746f0", "patch": "@@ -1,545 +0,0 @@\n-use crate::traits;\n-use crate::traits::error_reporting::InferCtxtExt as _;\n-use crate::traits::TraitEngineExt as _;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::OpaqueTyOrigin;\n-use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n-use rustc_infer::infer::{InferCtxt, TyCtxtInferExt as _};\n-use rustc_infer::traits::{Obligation, ObligationCause, TraitEngine};\n-use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts};\n-use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, OpaqueHiddenType, OpaqueTypeKey, ToPredicate, Ty, TyCtxt};\n-use rustc_span::Span;\n-\n-pub trait InferCtxtExt<'tcx> {\n-    fn infer_opaque_definition_from_instantiation(\n-        &self,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n-        instantiated_ty: OpaqueHiddenType<'tcx>,\n-        origin: OpaqueTyOrigin,\n-    ) -> Ty<'tcx>;\n-}\n-\n-impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n-    /// Given the fully resolved, instantiated type for an opaque\n-    /// type, i.e., the value of an inference variable like C1 or C2\n-    /// (*), computes the \"definition type\" for an opaque type\n-    /// definition -- that is, the inferred value of `Foo1<'x>` or\n-    /// `Foo2<'x>` that we would conceptually use in its definition:\n-    /// ```ignore (illustrative)\n-    /// type Foo1<'x> = impl Bar<'x> = AAA;  // <-- this type AAA\n-    /// type Foo2<'x> = impl Bar<'x> = BBB;  // <-- or this type BBB\n-    /// fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n-    /// ```\n-    /// Note that these values are defined in terms of a distinct set of\n-    /// generic parameters (`'x` instead of `'a`) from C1 or C2. The main\n-    /// purpose of this function is to do that translation.\n-    ///\n-    /// (*) C1 and C2 were introduced in the comments on\n-    /// `register_member_constraints`. Read that comment for more context.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `def_id`, the `impl Trait` type\n-    /// - `substs`, the substs  used to instantiate this opaque type\n-    /// - `instantiated_ty`, the inferred type C1 -- fully resolved, lifted version of\n-    ///   `opaque_defn.concrete_ty`\n-    #[instrument(level = \"debug\", skip(self))]\n-    fn infer_opaque_definition_from_instantiation(\n-        &self,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n-        instantiated_ty: OpaqueHiddenType<'tcx>,\n-        origin: OpaqueTyOrigin,\n-    ) -> Ty<'tcx> {\n-        if self.is_tainted_by_errors() {\n-            return self.tcx.ty_error();\n-        }\n-\n-        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n-\n-        // Use substs to build up a reverse map from regions to their\n-        // identity mappings. This is necessary because of `impl\n-        // Trait` lifetimes are computed by replacing existing\n-        // lifetimes with 'static and remapping only those used in the\n-        // `impl Trait` return type, resulting in the parameters\n-        // shifting.\n-        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id);\n-        debug!(?id_substs);\n-        let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> =\n-            substs.iter().enumerate().map(|(index, subst)| (subst, id_substs[index])).collect();\n-        debug!(\"map = {:#?}\", map);\n-\n-        // Convert the type from the function into a type valid outside\n-        // the function, by replacing invalid regions with 'static,\n-        // after producing an error for each of them.\n-        let definition_ty = instantiated_ty.ty.fold_with(&mut ReverseMapper::new(\n-            self.tcx,\n-            def_id,\n-            map,\n-            instantiated_ty.ty,\n-            instantiated_ty.span,\n-        ));\n-        debug!(?definition_ty);\n-\n-        if !check_opaque_type_parameter_valid(\n-            self.tcx,\n-            opaque_type_key,\n-            origin,\n-            instantiated_ty.span,\n-        ) {\n-            return self.tcx.ty_error();\n-        }\n-\n-        // Only check this for TAIT. RPIT already supports `src/test/ui/impl-trait/nested-return-type2.rs`\n-        // on stable and we'd break that.\n-        if let OpaqueTyOrigin::TyAlias = origin {\n-            // This logic duplicates most of `check_opaque_meets_bounds`.\n-            // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n-            let param_env = self.tcx.param_env(def_id);\n-            let body_id = self.tcx.local_def_id_to_hir_id(def_id.as_local().unwrap());\n-            self.tcx.infer_ctxt().enter(move |infcx| {\n-                // Require the hidden type to be well-formed with only the generics of the opaque type.\n-                // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n-                // hidden type is well formed even without those bounds.\n-                let predicate =\n-                    ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n-                        .to_predicate(infcx.tcx);\n-                let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-\n-                // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n-                // the bounds that the function supplies.\n-                match infcx.register_hidden_type(\n-                    OpaqueTypeKey { def_id, substs: id_substs },\n-                    ObligationCause::misc(instantiated_ty.span, body_id),\n-                    param_env,\n-                    definition_ty,\n-                    origin,\n-                ) {\n-                    Ok(infer_ok) => {\n-                        for obligation in infer_ok.obligations {\n-                            fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n-                        }\n-                    }\n-                    Err(err) => {\n-                        infcx\n-                            .report_mismatched_types(\n-                                &ObligationCause::misc(instantiated_ty.span, body_id),\n-                                self.tcx.mk_opaque(def_id, id_substs),\n-                                definition_ty,\n-                                err,\n-                            )\n-                            .emit();\n-                    }\n-                }\n-\n-                fulfillment_cx.register_predicate_obligation(\n-                    &infcx,\n-                    Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n-                );\n-\n-                // Check that all obligations are satisfied by the implementation's\n-                // version.\n-                let errors = fulfillment_cx.select_all_or_error(&infcx);\n-\n-                let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-\n-                if errors.is_empty() {\n-                    definition_ty\n-                } else {\n-                    infcx.report_fulfillment_errors(&errors, None, false);\n-                    self.tcx.ty_error()\n-                }\n-            })\n-        } else {\n-            definition_ty\n-        }\n-    }\n-}\n-\n-fn check_opaque_type_parameter_valid(\n-    tcx: TyCtxt<'_>,\n-    opaque_type_key: OpaqueTypeKey<'_>,\n-    origin: OpaqueTyOrigin,\n-    span: Span,\n-) -> bool {\n-    match origin {\n-        // No need to check return position impl trait (RPIT)\n-        // because for type and const parameters they are correct\n-        // by construction: we convert\n-        //\n-        // fn foo<P0..Pn>() -> impl Trait\n-        //\n-        // into\n-        //\n-        // type Foo<P0...Pn>\n-        // fn foo<P0..Pn>() -> Foo<P0...Pn>.\n-        //\n-        // For lifetime parameters we convert\n-        //\n-        // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n-        //\n-        // into\n-        //\n-        // type foo::<'p0..'pn>::Foo<'q0..'qm>\n-        // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n-        //\n-        // which would error here on all of the `'static` args.\n-        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return true,\n-        // Check these\n-        OpaqueTyOrigin::TyAlias => {}\n-    }\n-    let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n-    let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n-    for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n-        let arg_is_param = match arg.unpack() {\n-            GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n-            GenericArgKind::Lifetime(lt) if lt.is_static() => {\n-                tcx.sess\n-                    .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                    .span_label(\n-                        tcx.def_span(opaque_generics.param_at(i, tcx).def_id),\n-                        \"cannot use static lifetime; use a bound lifetime \\\n-                                    instead or remove the lifetime parameter from the \\\n-                                    opaque type\",\n-                    )\n-                    .emit();\n-                return false;\n-            }\n-            GenericArgKind::Lifetime(lt) => {\n-                matches!(*lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n-            }\n-            GenericArgKind::Const(ct) => matches!(ct.kind(), ty::ConstKind::Param(_)),\n-        };\n-\n-        if arg_is_param {\n-            seen_params.entry(arg).or_default().push(i);\n-        } else {\n-            // Prevent `fn foo() -> Foo<u32>` from being defining.\n-            let opaque_param = opaque_generics.param_at(i, tcx);\n-            tcx.sess\n-                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                .span_note(\n-                    tcx.def_span(opaque_param.def_id),\n-                    &format!(\n-                        \"used non-generic {} `{}` for generic parameter\",\n-                        opaque_param.kind.descr(),\n-                        arg,\n-                    ),\n-                )\n-                .emit();\n-            return false;\n-        }\n-    }\n-\n-    for (_, indices) in seen_params {\n-        if indices.len() > 1 {\n-            let descr = opaque_generics.param_at(indices[0], tcx).kind.descr();\n-            let spans: Vec<_> = indices\n-                .into_iter()\n-                .map(|i| tcx.def_span(opaque_generics.param_at(i, tcx).def_id))\n-                .collect();\n-            tcx.sess\n-                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                .span_note(spans, &format!(\"{} used multiple times\", descr))\n-                .emit();\n-            return false;\n-        }\n-    }\n-    true\n-}\n-\n-struct ReverseMapper<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-\n-    opaque_type_def_id: DefId,\n-    map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n-    map_missing_regions_to_empty: bool,\n-\n-    /// initially `Some`, set to `None` once error has been reported\n-    hidden_ty: Option<Ty<'tcx>>,\n-\n-    /// Span of function being checked.\n-    span: Span,\n-}\n-\n-impl<'tcx> ReverseMapper<'tcx> {\n-    fn new(\n-        tcx: TyCtxt<'tcx>,\n-        opaque_type_def_id: DefId,\n-        map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n-        hidden_ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> Self {\n-        Self {\n-            tcx,\n-            opaque_type_def_id,\n-            map,\n-            map_missing_regions_to_empty: false,\n-            hidden_ty: Some(hidden_ty),\n-            span,\n-        }\n-    }\n-\n-    fn fold_kind_mapping_missing_regions_to_empty(\n-        &mut self,\n-        kind: GenericArg<'tcx>,\n-    ) -> GenericArg<'tcx> {\n-        assert!(!self.map_missing_regions_to_empty);\n-        self.map_missing_regions_to_empty = true;\n-        let kind = kind.fold_with(self);\n-        self.map_missing_regions_to_empty = false;\n-        kind\n-    }\n-\n-    fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n-        assert!(!self.map_missing_regions_to_empty);\n-        kind.fold_with(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match *r {\n-            // Ignore bound regions and `'static` regions that appear in the\n-            // type, we only need to remap regions that reference lifetimes\n-            // from the function declaration.\n-            // This would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n-            ty::ReLateBound(..) | ty::ReStatic => return r,\n-\n-            // If regions have been erased (by writeback), don't try to unerase\n-            // them.\n-            ty::ReErased => return r,\n-\n-            // The regions that we expect from borrow checking.\n-            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReEmpty(ty::UniverseIndex::ROOT) => {}\n-\n-            ty::ReEmpty(_) | ty::RePlaceholder(_) | ty::ReVar(_) => {\n-                // All of the regions in the type should either have been\n-                // erased by writeback, or mapped back to named regions by\n-                // borrow checking.\n-                bug!(\"unexpected region kind in opaque type: {:?}\", r);\n-            }\n-        }\n-\n-        let generics = self.tcx().generics_of(self.opaque_type_def_id);\n-        match self.map.get(&r.into()).map(|k| k.unpack()) {\n-            Some(GenericArgKind::Lifetime(r1)) => r1,\n-            Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n-            None if self.map_missing_regions_to_empty => self.tcx.lifetimes.re_root_empty,\n-            None if generics.parent.is_some() => {\n-                if let Some(hidden_ty) = self.hidden_ty.take() {\n-                    unexpected_hidden_region_diagnostic(\n-                        self.tcx,\n-                        self.tcx.def_span(self.opaque_type_def_id),\n-                        hidden_ty,\n-                        r,\n-                    )\n-                    .emit();\n-                }\n-                self.tcx.lifetimes.re_root_empty\n-            }\n-            None => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(self.span, \"non-defining opaque type use in defining scope\")\n-                    .span_label(\n-                        self.span,\n-                        format!(\n-                            \"lifetime `{}` is part of concrete type but not used in \\\n-                                 parameter list of the `impl Trait` type alias\",\n-                            r\n-                        ),\n-                    )\n-                    .emit();\n-\n-                self.tcx().lifetimes.re_static\n-            }\n-        }\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match *ty.kind() {\n-            ty::Closure(def_id, substs) => {\n-                // I am a horrible monster and I pray for death. When\n-                // we encounter a closure here, it is always a closure\n-                // from within the function that we are currently\n-                // type-checking -- one that is now being encapsulated\n-                // in an opaque type. Ideally, we would\n-                // go through the types/lifetimes that it references\n-                // and treat them just like we would any other type,\n-                // which means we would error out if we find any\n-                // reference to a type/region that is not in the\n-                // \"reverse map\".\n-                //\n-                // **However,** in the case of closures, there is a\n-                // somewhat subtle (read: hacky) consideration. The\n-                // problem is that our closure types currently include\n-                // all the lifetime parameters declared on the\n-                // enclosing function, even if they are unused by the\n-                // closure itself. We can't readily filter them out,\n-                // so here we replace those values with `'empty`. This\n-                // can't really make a difference to the rest of the\n-                // compiler; those regions are ignored for the\n-                // outlives relation, and hence don't affect trait\n-                // selection or auto traits, and they are erased\n-                // during codegen.\n-\n-                let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n-                    if index < generics.parent_count {\n-                        // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_mapping_missing_regions_to_empty(kind)\n-                    } else {\n-                        // ...but not elsewhere.\n-                        self.fold_kind_normally(kind)\n-                    }\n-                }));\n-\n-                self.tcx.mk_closure(def_id, substs)\n-            }\n-\n-            ty::Generator(def_id, substs, movability) => {\n-                let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n-                    if index < generics.parent_count {\n-                        // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_mapping_missing_regions_to_empty(kind)\n-                    } else {\n-                        // ...but not elsewhere.\n-                        self.fold_kind_normally(kind)\n-                    }\n-                }));\n-\n-                self.tcx.mk_generator(def_id, substs, movability)\n-            }\n-\n-            ty::Param(param) => {\n-                // Look it up in the substitution list.\n-                match self.map.get(&ty.into()).map(|k| k.unpack()) {\n-                    // Found it in the substitution list; replace with the parameter from the\n-                    // opaque type.\n-                    Some(GenericArgKind::Type(t1)) => t1,\n-                    Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n-                    None => {\n-                        debug!(?param, ?self.map);\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                self.span,\n-                                &format!(\n-                                    \"type parameter `{}` is part of concrete type but not \\\n-                                          used in parameter list for the `impl Trait` type alias\",\n-                                    ty\n-                                ),\n-                            )\n-                            .emit();\n-\n-                        self.tcx().ty_error()\n-                    }\n-                }\n-            }\n-\n-            _ => ty.super_fold_with(self),\n-        }\n-    }\n-\n-    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n-        trace!(\"checking const {:?}\", ct);\n-        // Find a const parameter\n-        match ct.kind() {\n-            ty::ConstKind::Param(..) => {\n-                // Look it up in the substitution list.\n-                match self.map.get(&ct.into()).map(|k| k.unpack()) {\n-                    // Found it in the substitution list, replace with the parameter from the\n-                    // opaque type.\n-                    Some(GenericArgKind::Const(c1)) => c1,\n-                    Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n-                    None => {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                self.span,\n-                                &format!(\n-                                    \"const parameter `{}` is part of concrete type but not \\\n-                                          used in parameter list for the `impl Trait` type alias\",\n-                                    ct\n-                                ),\n-                            )\n-                            .emit();\n-\n-                        self.tcx().const_error(ct.ty())\n-                    }\n-                }\n-            }\n-\n-            _ => ct,\n-        }\n-    }\n-}\n-\n-/// Given a set of predicates that apply to an object type, returns\n-/// the region bounds that the (erased) `Self` type must\n-/// outlive. Precisely *because* the `Self` type is erased, the\n-/// parameter `erased_self_ty` must be supplied to indicate what type\n-/// has been used to represent `Self` in the predicates\n-/// themselves. This should really be a unique type; `FreshTy(0)` is a\n-/// popular choice.\n-///\n-/// N.B., in some cases, particularly around higher-ranked bounds,\n-/// this function returns a kind of conservative approximation.\n-/// That is, all regions returned by this function are definitely\n-/// required, but there may be other region bounds that are not\n-/// returned, as well as requirements like `for<'a> T: 'a`.\n-///\n-/// Requires that trait definitions have been processed so that we can\n-/// elaborate predicates and walk supertraits.\n-#[instrument(skip(tcx, predicates), level = \"debug\")]\n-pub(crate) fn required_region_bounds<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    erased_self_ty: Ty<'tcx>,\n-    predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n-) -> Vec<ty::Region<'tcx>> {\n-    assert!(!erased_self_ty.has_escaping_bound_vars());\n-\n-    traits::elaborate_predicates(tcx, predicates)\n-        .filter_map(|obligation| {\n-            debug!(?obligation);\n-            match obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Projection(..)\n-                | ty::PredicateKind::Trait(..)\n-                | ty::PredicateKind::Subtype(..)\n-                | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::WellFormed(..)\n-                | ty::PredicateKind::ObjectSafe(..)\n-                | ty::PredicateKind::ClosureKind(..)\n-                | ty::PredicateKind::RegionOutlives(..)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n-                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n-                    // Search for a bound of the form `erased_self_ty\n-                    // : 'a`, but be wary of something like `for<'a>\n-                    // erased_self_ty : 'a` (we interpret a\n-                    // higher-ranked bound like that as 'static,\n-                    // though at present the code in `fulfill.rs`\n-                    // considers such bounds to be unsatisfiable, so\n-                    // it's kind of a moot point since you could never\n-                    // construct such an object, but this seems\n-                    // correct even if that code changes).\n-                    if t == &erased_self_ty && !r.has_escaping_bound_vars() {\n-                        Some(*r)\n-                    } else {\n-                        None\n-                    }\n-                }\n-            }\n-        })\n-        .collect()\n-}"}, {"sha": "3dfc7a9cacd97c69016e67242cc660040724c7bb", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/31e1a777e7b055b240b507a7c04719c0563852e9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e1a777e7b055b240b507a7c04719c0563852e9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=31e1a777e7b055b240b507a7c04719c0563852e9", "patch": "@@ -1,5 +1,4 @@\n use crate::infer::InferCtxt;\n-use crate::opaque_types::required_region_bounds;\n use crate::traits;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -810,3 +809,63 @@ pub fn object_region_bounds<'tcx>(\n \n     required_region_bounds(tcx, open_ty, predicates)\n }\n+\n+/// Given a set of predicates that apply to an object type, returns\n+/// the region bounds that the (erased) `Self` type must\n+/// outlive. Precisely *because* the `Self` type is erased, the\n+/// parameter `erased_self_ty` must be supplied to indicate what type\n+/// has been used to represent `Self` in the predicates\n+/// themselves. This should really be a unique type; `FreshTy(0)` is a\n+/// popular choice.\n+///\n+/// N.B., in some cases, particularly around higher-ranked bounds,\n+/// this function returns a kind of conservative approximation.\n+/// That is, all regions returned by this function are definitely\n+/// required, but there may be other region bounds that are not\n+/// returned, as well as requirements like `for<'a> T: 'a`.\n+///\n+/// Requires that trait definitions have been processed so that we can\n+/// elaborate predicates and walk supertraits.\n+#[instrument(skip(tcx, predicates), level = \"debug\")]\n+pub(crate) fn required_region_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    erased_self_ty: Ty<'tcx>,\n+    predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n+) -> Vec<ty::Region<'tcx>> {\n+    assert!(!erased_self_ty.has_escaping_bound_vars());\n+\n+    traits::elaborate_predicates(tcx, predicates)\n+        .filter_map(|obligation| {\n+            debug!(?obligation);\n+            match obligation.predicate.kind().skip_binder() {\n+                ty::PredicateKind::Projection(..)\n+                | ty::PredicateKind::Trait(..)\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Coerce(..)\n+                | ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n+                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n+                    // Search for a bound of the form `erased_self_ty\n+                    // : 'a`, but be wary of something like `for<'a>\n+                    // erased_self_ty : 'a` (we interpret a\n+                    // higher-ranked bound like that as 'static,\n+                    // though at present the code in `fulfill.rs`\n+                    // considers such bounds to be unsatisfiable, so\n+                    // it's kind of a moot point since you could never\n+                    // construct such an object, but this seems\n+                    // correct even if that code changes).\n+                    if t == &erased_self_ty && !r.has_escaping_bound_vars() {\n+                        Some(*r)\n+                    } else {\n+                        None\n+                    }\n+                }\n+            }\n+        })\n+        .collect()\n+}"}]}