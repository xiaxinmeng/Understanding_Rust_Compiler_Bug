{"sha": "f23fd4bc029fccbcb3e56507cac8cde90a81128c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyM2ZkNGJjMDI5ZmNjYmNiM2U1NjUwN2NhYzhjZGU5MGE4MTEyOGM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-25T17:58:32Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-26T13:38:26Z"}, "message": "rustc_driver/test.rs: rustfmt", "tree": {"sha": "e4efd0347d78915e63a48682ec84bcd02f905b46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4efd0347d78915e63a48682ec84bcd02f905b46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f23fd4bc029fccbcb3e56507cac8cde90a81128c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f23fd4bc029fccbcb3e56507cac8cde90a81128c", "html_url": "https://github.com/rust-lang/rust/commit/f23fd4bc029fccbcb3e56507cac8cde90a81128c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f23fd4bc029fccbcb3e56507cac8cde90a81128c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbaf36adaf268eb4e4da7abb0ef2f4cd5380497d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbaf36adaf268eb4e4da7abb0ef2f4cd5380497d", "html_url": "https://github.com/rust-lang/rust/commit/cbaf36adaf268eb4e4da7abb0ef2f4cd5380497d"}], "stats": {"total": 382, "additions": 219, "deletions": 163}, "files": [{"sha": "f18f40bf7a1448851a6bc44b398673d86a8eb76b", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 219, "deletions": 163, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/f23fd4bc029fccbcb3e56507cac8cde90a81128c/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23fd4bc029fccbcb3e56507cac8cde90a81128c/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=f23fd4bc029fccbcb3e56507cac8cde90a81128c", "patch": "@@ -14,29 +14,29 @@ use std::path::PathBuf;\n use std::sync::mpsc;\n \n use driver;\n-use rustc_lint;\n-use rustc_resolve::MakeGlobMap;\n-use rustc::middle::region;\n-use rustc::ty::subst::Subst;\n-use rustc::traits::ObligationCause;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::query::OnDiskCache;\n-use rustc::infer::{self, InferOk, InferResult, SuppressRegionErrors};\n+use errors;\n+use errors::emitter::Emitter;\n+use errors::{DiagnosticBuilder, Level};\n+use rustc::hir::map as hir_map;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::infer::type_variable::TypeVariableOrigin;\n-use rustc_metadata::cstore::CStore;\n-use rustc::hir::map as hir_map;\n-use rustc::session::{self, config};\n+use rustc::infer::{self, InferOk, InferResult, SuppressRegionErrors};\n+use rustc::middle::region;\n use rustc::session::config::{OutputFilenames, OutputTypes};\n+use rustc::session::{self, config};\n+use rustc::traits::ObligationCause;\n+use rustc::ty::query::OnDiskCache;\n+use rustc::ty::subst::Subst;\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_data_structures::sync::{self, Lrc};\n+use rustc_lint;\n+use rustc_metadata::cstore::CStore;\n+use rustc_resolve::MakeGlobMap;\n+use rustc_target::spec::abi::Abi;\n use syntax;\n use syntax::ast;\n-use rustc_target::spec::abi::Abi;\n-use syntax::source_map::{SourceMap, FilePathMapping, FileName};\n-use errors;\n-use errors::emitter::Emitter;\n-use errors::{Level, DiagnosticBuilder};\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::source_map::{FileName, FilePathMapping, SourceMap};\n use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n@@ -90,13 +90,15 @@ impl Emitter for ExpectErrorEmitter {\n \n fn errors(msgs: &[&str]) -> (Box<dyn Emitter + sync::Send>, usize) {\n     let v = msgs.iter().map(|m| m.to_string()).collect();\n-    (box ExpectErrorEmitter { messages: v } as Box<dyn Emitter + sync::Send>, msgs.len())\n+    (\n+        box ExpectErrorEmitter { messages: v } as Box<dyn Emitter + sync::Send>,\n+        msgs.len(),\n+    )\n }\n \n-fn test_env<F>(source_string: &str,\n-               args: (Box<dyn Emitter + sync::Send>, usize),\n-               body: F)\n-    where F: FnOnce(Env)\n+fn test_env<F>(source_string: &str, args: (Box<dyn Emitter + sync::Send>, usize), body: F)\n+where\n+    F: FnOnce(Env),\n {\n     syntax::with_globals(|| {\n         let mut options = config::Options::default();\n@@ -113,34 +115,41 @@ fn test_env_with_pool<F>(\n     options: config::Options,\n     source_string: &str,\n     (emitter, expected_err_count): (Box<dyn Emitter + sync::Send>, usize),\n-    body: F\n-)\n-    where F: FnOnce(Env)\n+    body: F,\n+) where\n+    F: FnOnce(Env),\n {\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, emitter);\n-    let sess = session::build_session_(options,\n-                                       None,\n-                                       diagnostic_handler,\n-                                       Lrc::new(SourceMap::new(FilePathMapping::empty())));\n+    let sess = session::build_session_(\n+        options,\n+        None,\n+        diagnostic_handler,\n+        Lrc::new(SourceMap::new(FilePathMapping::empty())),\n+    );\n     let cstore = CStore::new(::get_codegen_backend(&sess).metadata_loader());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {\n         name: FileName::Anon,\n         input: source_string.to_string(),\n     };\n-    let krate = driver::phase_1_parse_input(&driver::CompileController::basic(),\n-                                            &sess,\n-                                            &input).unwrap();\n-    let driver::ExpansionResult { defs, resolutions, mut hir_forest, .. } = {\n-        driver::phase_2_configure_and_expand(&sess,\n-                                             &cstore,\n-                                             krate,\n-                                             None,\n-                                             \"test\",\n-                                             None,\n-                                             MakeGlobMap::No,\n-                                             |_| Ok(()))\n-            .expect(\"phase 2 aborted\")\n+    let krate =\n+        driver::phase_1_parse_input(&driver::CompileController::basic(), &sess, &input).unwrap();\n+    let driver::ExpansionResult {\n+        defs,\n+        resolutions,\n+        mut hir_forest,\n+        ..\n+    } = {\n+        driver::phase_2_configure_and_expand(\n+            &sess,\n+            &cstore,\n+            krate,\n+            None,\n+            \"test\",\n+            None,\n+            MakeGlobMap::No,\n+            |_| Ok(()),\n+        ).expect(\"phase 2 aborted\")\n     };\n \n     let arenas = ty::AllArenas::new();\n@@ -155,32 +164,39 @@ fn test_env_with_pool<F>(\n         extra: String::new(),\n         outputs: OutputTypes::new(&[]),\n     };\n-    TyCtxt::create_and_enter(&sess,\n-                             &cstore,\n-                             ty::query::Providers::default(),\n-                             ty::query::Providers::default(),\n-                             &arenas,\n-                             resolutions,\n-                             hir_map,\n-                             OnDiskCache::new_empty(sess.source_map()),\n-                             \"test_crate\",\n-                             tx,\n-                             &outputs,\n-                             |tcx| {\n-        tcx.infer_ctxt().enter(|infcx| {\n-            let mut region_scope_tree = region::ScopeTree::default();\n-            let param_env = ty::ParamEnv::empty();\n-            body(Env {\n-                infcx: &infcx,\n-                region_scope_tree: &mut region_scope_tree,\n-                param_env: param_env,\n+    TyCtxt::create_and_enter(\n+        &sess,\n+        &cstore,\n+        ty::query::Providers::default(),\n+        ty::query::Providers::default(),\n+        &arenas,\n+        resolutions,\n+        hir_map,\n+        OnDiskCache::new_empty(sess.source_map()),\n+        \"test_crate\",\n+        tx,\n+        &outputs,\n+        |tcx| {\n+            tcx.infer_ctxt().enter(|infcx| {\n+                let mut region_scope_tree = region::ScopeTree::default();\n+                let param_env = ty::ParamEnv::empty();\n+                body(Env {\n+                    infcx: &infcx,\n+                    region_scope_tree: &mut region_scope_tree,\n+                    param_env: param_env,\n+                });\n+                let outlives_env = OutlivesEnvironment::new(param_env);\n+                let def_id = tcx.hir.local_def_id(ast::CRATE_NODE_ID);\n+                infcx.resolve_regions_and_report_errors(\n+                    def_id,\n+                    &region_scope_tree,\n+                    &outlives_env,\n+                    SuppressRegionErrors::default(),\n+                );\n+                assert_eq!(tcx.sess.err_count(), expected_err_count);\n             });\n-            let outlives_env = OutlivesEnvironment::new(param_env);\n-            let def_id = tcx.hir.local_def_id(ast::CRATE_NODE_ID);\n-            infcx.resolve_regions_and_report_errors(def_id, &region_scope_tree, &outlives_env, SuppressRegionErrors::default());\n-            assert_eq!(tcx.sess.err_count(), expected_err_count);\n-        });\n-    });\n+        },\n+    );\n }\n \n fn d1() -> ty::DebruijnIndex {\n@@ -196,9 +212,15 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn create_region_hierarchy(&mut self, rh: &RH,\n-                                   parent: (region::Scope, region::ScopeDepth)) {\n-        let me = region::Scope { id: rh.id, data: region::ScopeData::Node };\n+    pub fn create_region_hierarchy(\n+        &mut self,\n+        rh: &RH,\n+        parent: (region::Scope, region::ScopeDepth),\n+    ) {\n+        let me = region::Scope {\n+            id: rh.id,\n+            data: region::ScopeData::Node,\n+        };\n         self.region_scope_tree.record_scope_parent(me, Some(parent));\n         for child_rh in rh.sub {\n             self.create_region_hierarchy(child_rh, (me, parent.1 + 1));\n@@ -211,20 +233,25 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n         let dscope = region::Scope {\n             id: hir::ItemLocalId(1),\n-            data: region::ScopeData::Destruction\n+            data: region::ScopeData::Destruction,\n         };\n         self.region_scope_tree.record_scope_parent(dscope, None);\n-        self.create_region_hierarchy(&RH {\n-            id: hir::ItemLocalId(1),\n-            sub: &[RH {\n-                id: hir::ItemLocalId(10),\n-                sub: &[],\n+        self.create_region_hierarchy(\n+            &RH {\n+                id: hir::ItemLocalId(1),\n+                sub: &[\n+                    RH {\n+                        id: hir::ItemLocalId(10),\n+                        sub: &[],\n+                    },\n+                    RH {\n+                        id: hir::ItemLocalId(11),\n+                        sub: &[],\n+                    },\n+                ],\n             },\n-            RH {\n-                id: hir::ItemLocalId(11),\n-                sub: &[],\n-            }],\n-        }, (dscope, 1));\n+            (dscope, 1),\n+        );\n     }\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n@@ -236,11 +263,12 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        fn search_mod(this: &Env,\n-                      m: &hir::Mod,\n-                      idx: usize,\n-                      names: &[String])\n-                      -> Option<ast::NodeId> {\n+        fn search_mod(\n+            this: &Env,\n+            m: &hir::Mod,\n+            idx: usize,\n+            names: &[String],\n+        ) -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n             for item in &m.item_ids {\n                 let item = this.infcx.tcx.hir.expect_item(item.id);\n@@ -257,30 +285,33 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n             }\n \n             return match it.node {\n-                hir::ItemKind::Use(..) |\n-                hir::ItemKind::ExternCrate(..) |\n-                hir::ItemKind::Const(..) |\n-                hir::ItemKind::Static(..) |\n-                hir::ItemKind::Fn(..) |\n-                hir::ItemKind::ForeignMod(..) |\n-                hir::ItemKind::GlobalAsm(..) |\n-                hir::ItemKind::Existential(..) |\n-                hir::ItemKind::Ty(..) => None,\n-\n-                hir::ItemKind::Enum(..) |\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) |\n-                hir::ItemKind::Trait(..) |\n-                hir::ItemKind::TraitAlias(..) |\n-                hir::ItemKind::Impl(..) => None,\n+                hir::ItemKind::Use(..)\n+                | hir::ItemKind::ExternCrate(..)\n+                | hir::ItemKind::Const(..)\n+                | hir::ItemKind::Static(..)\n+                | hir::ItemKind::Fn(..)\n+                | hir::ItemKind::ForeignMod(..)\n+                | hir::ItemKind::GlobalAsm(..)\n+                | hir::ItemKind::Existential(..)\n+                | hir::ItemKind::Ty(..) => None,\n+\n+                hir::ItemKind::Enum(..)\n+                | hir::ItemKind::Struct(..)\n+                | hir::ItemKind::Union(..)\n+                | hir::ItemKind::Trait(..)\n+                | hir::ItemKind::TraitAlias(..)\n+                | hir::ItemKind::Impl(..) => None,\n \n                 hir::ItemKind::Mod(ref m) => search_mod(this, m, idx, names),\n             };\n         }\n     }\n \n     pub fn make_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        match self.infcx.at(&ObligationCause::dummy(), self.param_env).sub(a, b) {\n+        match self.infcx\n+            .at(&ObligationCause::dummy(), self.param_env)\n+            .sub(a, b)\n+        {\n             Ok(_) => true,\n             Err(ref e) => panic!(\"Encountered error: {}\", e),\n         }\n@@ -302,13 +333,15 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_fn(&self, input_tys: &[Ty<'tcx>], output_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_fn_ptr(ty::Binder::bind(self.infcx.tcx.mk_fn_sig(\n-            input_tys.iter().cloned(),\n-            output_ty,\n-            false,\n-            hir::Unsafety::Normal,\n-            Abi::Rust\n-        )))\n+        self.infcx\n+            .tcx\n+            .mk_fn_ptr(ty::Binder::bind(self.infcx.tcx.mk_fn_sig(\n+                input_tys.iter().cloned(),\n+                output_ty,\n+                false,\n+                hir::Unsafety::Normal,\n+                Abi::Rust,\n+            )))\n     }\n \n     pub fn t_nil(&self) -> Ty<'tcx> {\n@@ -321,23 +354,30 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n     pub fn t_param(&self, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        self.infcx.tcx.mk_ty_param(index, Symbol::intern(&name).as_interned_str())\n+        self.infcx\n+            .tcx\n+            .mk_ty_param(index, Symbol::intern(&name).as_interned_str())\n     }\n \n     pub fn re_early_bound(&self, index: u32, name: &'static str) -> ty::Region<'tcx> {\n         let name = Symbol::intern(name).as_interned_str();\n-        self.infcx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            def_id: self.infcx.tcx.hir.local_def_id(ast::CRATE_NODE_ID),\n-            index,\n-            name,\n-        }))\n+        self.infcx\n+            .tcx\n+            .mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                def_id: self.infcx.tcx.hir.local_def_id(ast::CRATE_NODE_ID),\n+                index,\n+                name,\n+            }))\n     }\n \n-    pub fn re_late_bound_with_debruijn(&self,\n-                                       id: u32,\n-                                       debruijn: ty::DebruijnIndex)\n-                                       -> ty::Region<'tcx> {\n-        self.infcx.tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(id)))\n+    pub fn re_late_bound_with_debruijn(\n+        &self,\n+        id: u32,\n+        debruijn: ty::DebruijnIndex,\n+    ) -> ty::Region<'tcx> {\n+        self.infcx\n+            .tcx\n+            .mk_region(ty::ReLateBound(debruijn, ty::BrAnon(id)))\n     }\n \n     pub fn t_rptr(&self, r: ty::Region<'tcx>) -> Ty<'tcx> {\n@@ -349,20 +389,23 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n-    pub fn t_rptr_late_bound_with_debruijn(&self,\n-                                           id: u32,\n-                                           debruijn: ty::DebruijnIndex)\n-                                           -> Ty<'tcx> {\n+    pub fn t_rptr_late_bound_with_debruijn(\n+        &self,\n+        id: u32,\n+        debruijn: ty::DebruijnIndex,\n+    ) -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, debruijn);\n         self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_scope(&self, id: u32) -> Ty<'tcx> {\n         let r = ty::ReScope(region::Scope {\n             id: hir::ItemLocalId(id),\n-            data: region::ScopeData::Node\n+            data: region::ScopeData::Node,\n         });\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n+        self.infcx\n+            .tcx\n+            .mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n \n     pub fn re_free(&self, id: u32) -> ty::Region<'tcx> {\n@@ -378,14 +421,19 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, ()> {\n-        self.infcx.at(&ObligationCause::dummy(), self.param_env).sub(t1, t2)\n+        self.infcx\n+            .at(&ObligationCause::dummy(), self.param_env)\n+            .sub(t1, t2)\n     }\n \n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n         match self.sub(t1, t2) {\n-            Ok(InferOk { obligations, value: () }) => {\n+            Ok(InferOk {\n+                obligations,\n+                value: (),\n+            }) => {\n                 // None of these tests should require nested obligations:\n                 assert!(obligations.is_empty());\n             }\n@@ -445,8 +493,10 @@ fn sub_free_bound_false() {\n         env.create_simple_region_hierarchy();\n         let t_rptr_free1 = env.t_rptr_free(1);\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        env.check_not_sub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n-                          env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n+        env.check_not_sub(\n+            env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n+            env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+        );\n     })\n }\n \n@@ -462,8 +512,10 @@ fn sub_bound_free_true() {\n         env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(1);\n-        env.check_sub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n+        env.check_sub(\n+            env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+            env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n+        );\n     })\n }\n \n@@ -476,18 +528,20 @@ fn sub_free_bound_false_infer() {\n     //! does NOT hold for any instantiation of `_#1`.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n+        let t_infer1 = env.infcx\n+            .next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        env.check_not_sub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n-                          env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n+        env.check_not_sub(\n+            env.t_fn(&[t_infer1], env.tcx().types.isize),\n+            env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+        );\n     })\n }\n \n /// Test substituting a bound region into a function, which introduces another level of binding.\n /// This requires adjusting the Debruijn index.\n #[test]\n fn subst_ty_renumber_bound() {\n-\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         // Situation:\n         // Theta = [A -> &'a foo]\n@@ -509,11 +563,10 @@ fn subst_ty_renumber_bound() {\n             env.t_fn(&[t_ptr_bound2], env.t_nil())\n         };\n \n-        debug!(\"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n-               t_source,\n-               substs,\n-               t_substituted,\n-               t_expected);\n+        debug!(\n+            \"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n+            t_source, substs, t_substituted, t_expected\n+        );\n \n         assert_eq!(t_substituted, t_expected);\n     })\n@@ -546,11 +599,10 @@ fn subst_ty_renumber_some_bounds() {\n             env.t_pair(t_rptr_bound1, env.t_fn(&[t_rptr_bound2], env.t_nil()))\n         };\n \n-        debug!(\"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n-               t_source,\n-               substs,\n-               t_substituted,\n-               t_expected);\n+        debug!(\n+            \"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n+            t_source, substs, t_substituted, t_expected\n+        );\n \n         assert_eq!(t_substituted, t_expected);\n     })\n@@ -559,7 +611,6 @@ fn subst_ty_renumber_some_bounds() {\n /// Test that we correctly compute whether a type has escaping regions or not.\n #[test]\n fn escaping() {\n-\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         // Situation:\n         // Theta = [A -> &'a foo]\n@@ -608,11 +659,10 @@ fn subst_region_renumber_region() {\n             env.t_fn(&[t_rptr_bound2], env.t_nil())\n         };\n \n-        debug!(\"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n-               t_source,\n-               substs,\n-               t_substituted,\n-               t_expected);\n+        debug!(\n+            \"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n+            t_source, substs, t_substituted, t_expected\n+        );\n \n         assert_eq!(t_substituted, t_expected);\n     })\n@@ -627,9 +677,13 @@ fn walk_ty() {\n         let tup1_ty = tcx.intern_tup(&[int_ty, usize_ty, int_ty, usize_ty]);\n         let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, usize_ty]);\n         let walked: Vec<_> = tup2_ty.walk().collect();\n-        assert_eq!(walked,\n-                   [tup2_ty, tup1_ty, int_ty, usize_ty, int_ty, usize_ty, tup1_ty, int_ty,\n-                    usize_ty, int_ty, usize_ty, usize_ty]);\n+        assert_eq!(\n+            walked,\n+            [\n+                tup2_ty, tup1_ty, int_ty, usize_ty, int_ty, usize_ty, tup1_ty, int_ty, usize_ty,\n+                int_ty, usize_ty, usize_ty\n+            ]\n+        );\n     })\n }\n \n@@ -644,14 +698,16 @@ fn walk_ty_skip_subtree() {\n \n         // types we expect to see (in order), plus a boolean saying\n         // whether to skip the subtree.\n-        let mut expected = vec![(tup2_ty, false),\n-                                (tup1_ty, false),\n-                                (int_ty, false),\n-                                (usize_ty, false),\n-                                (int_ty, false),\n-                                (usize_ty, false),\n-                                (tup1_ty, true), // skip the isize/usize/isize/usize\n-                                (usize_ty, false)];\n+        let mut expected = vec![\n+            (tup2_ty, false),\n+            (tup1_ty, false),\n+            (int_ty, false),\n+            (usize_ty, false),\n+            (int_ty, false),\n+            (usize_ty, false),\n+            (tup1_ty, true), // skip the isize/usize/isize/usize\n+            (usize_ty, false),\n+        ];\n         expected.reverse();\n \n         let mut walker = tup2_ty.walk();"}]}