{"sha": "82e79f765ce81442f7dd3e2c878f055e95d2a34f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyZTc5Zjc2NWNlODE0NDJmN2RkM2UyYzg3OGYwNTVlOTVkMmEzNGY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-16T00:09:21Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-16T00:09:21Z"}, "message": "docs: Add Niko's borrowed pointers tutorial", "tree": {"sha": "54225a00a2e49fa2a3f38388cf5a5e5ddb0d054d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54225a00a2e49fa2a3f38388cf5a5e5ddb0d054d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82e79f765ce81442f7dd3e2c878f055e95d2a34f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82e79f765ce81442f7dd3e2c878f055e95d2a34f", "html_url": "https://github.com/rust-lang/rust/commit/82e79f765ce81442f7dd3e2c878f055e95d2a34f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82e79f765ce81442f7dd3e2c878f055e95d2a34f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0d84348efd6e574ac8b7848fbf55916dc9b9fac", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0d84348efd6e574ac8b7848fbf55916dc9b9fac", "html_url": "https://github.com/rust-lang/rust/commit/d0d84348efd6e574ac8b7848fbf55916dc9b9fac"}], "stats": {"total": 712, "additions": 712, "deletions": 0}, "files": [{"sha": "34e3bfb1947582507d1e0e82ff02b235d6d2279b", "filename": "doc/tutorial-borrowed-ptr.md", "status": "added", "additions": 702, "deletions": 0, "changes": 702, "blob_url": "https://github.com/rust-lang/rust/blob/82e79f765ce81442f7dd3e2c878f055e95d2a34f/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/82e79f765ce81442f7dd3e2c878f055e95d2a34f/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=82e79f765ce81442f7dd3e2c878f055e95d2a34f", "patch": "@@ -0,0 +1,702 @@\n+% Rust Borrowed Pointers Tutorial\n+\n+# Introduction\n+\n+Borrowed pointers are one of the more flexible and powerful tools\n+available in Rust. A borrowed pointer can be used to point anywhere:\n+into the shared and exchange heaps, into the stack, and even into the\n+interior of another data structure. With regard to flexibility, it is\n+comparable to a C pointer or C++ reference. However, unlike C and C++,\n+the Rust compiler includes special checks that ensure that borrowed\n+pointers are being used safely. Another advantage of borrowed pointers\n+is that they are invisible to the garbage collector, so working with\n+borrowed pointers helps keep things efficient.\n+\n+Despite the fact that they are completely safe, at runtime, a borrowed\n+pointer is \u201cjust a pointer\u201d. They introduce zero overhead. All safety\n+checks are done at compilation time.\n+\n+Although borrowed pointers have rather elaborate theoretical\n+underpinnings (region pointers), the core concepts will be familiar to\n+anyone who worked with C or C++. Therefore, the best way to explain\n+how they are used\u2014and their limitations\u2014is probably just to work\n+through several examples.\n+\n+# By example\n+\n+Borrowed pointers are called borrowed because they are only valid for\n+a limit duration. Borrowed pointers never claim any kind of ownership\n+over the data that they point at: instead, they are used for cases\n+where you like to make use of data for a short time.\n+\n+As an example, consider a simple record type `point`:\n+\n+~~~\n+type point = {x: float, y: float};\n+~~~\n+\n+We can use this simple definition to allocate points in many ways. For\n+example, in this code, each of these three local variables contains a\n+point, but allocated in a different place:\n+\n+~~~\n+let on_the_stack : point  =  {x: 3.0, y: 4.0};\n+let shared_box   : @point = @{x: 5.0, y: 1.0};\n+let unique_box   : ~point = ~{x: 7.0, y: 9.0};\n+~~~\n+\n+Suppose we wanted to write a procedure that computed the distance\n+between any two points, no matter where they were stored. For example,\n+we might like to compute the distance between `on_the_stack` and\n+`shared_box`, or between `shared_box` and `unique_box`. One option is\n+to define a function that takes two arguments of type point\u2014that is,\n+it takes the points by value. But this will cause the points to be\n+copied when we call the function. For points, this is probably not so\n+bad, but often copies are expensive or, worse, if there are mutable\n+fields, they can change the semantics of your program. So we\u2019d like to\n+define a function that takes the points by pointer. We can use\n+borrowed pointers to do this:\n+\n+~~~\n+fn compute_distance(p1: &point, p2: &point) -> float {\n+    let x_d = p1.x - p2.x;\n+    let y_d = p1.y - p2.y;\n+    sqrt(x_d * x_d + y_d * y_d)\n+}\n+~~~\n+\n+Now we can call `compute_distance()` in various ways:\n+\n+~~~\n+compute_distance(&on_the_stack, shared_box)\n+compute_distance(shared_box, unique_box)\n+~~~\n+\n+Here the `&` operator is used to take the address of the variable\n+`on_the_stack`; this is because `on_the_stack` has the type `point`\n+(that is, a record value) and we have to take its address to get a\n+value. We also call this _borrowing_ the local variable\n+`on_the_stack`, because we are created an alias: that is, another\n+route to the same data.\n+\n+In the case of the boxes `shared_box` and `unique_box`, however, no\n+explicit action is necessary. The compiler will automatically convert\n+a box like `@point` or `~point` to a borrowed pointer like\n+`&point`. This is another form of borrowing; in this case, the\n+contents of the shared/unique box is being lent out.\n+\n+Whenever a value is borrowed, there are some limitations on what you\n+can do with the original. For example, if the contents of a variable\n+have been lent out, you cannot send that variable to another task, nor\n+will you be permitted to take actions that might cause the borrowed\n+value to be freed or to change its type (I\u2019ll get into what kinds of\n+actions those are shortly). This rule should make intuitive sense: you\n+must wait for a borrowed value to be returned (that is, for the\n+borrowed pointer to go out of scope) before you can make full use of\n+it again.\n+\n+# Other uses for the & operator\n+\n+In the previous example, the value `on_the_stack` was defined like so:\n+\n+~~~\n+let on_the_stack : point = {x: 3.0, y: 4.0};\n+~~~\n+\n+This results in a by-value variable. As a consequence, we had to\n+explicitly take the address of `on_the_stack` to get a borrowed\n+pointer. Sometimes however it is more convenient to move the &\n+operator into the definition of `on_the_stack`:\n+\n+~~~\n+let on_the_stack2 : &point = &{x: 3.0, y: 4.0};\n+~~~\n+\n+Applying `&` to an rvalue (non-assignable location) is just a convenient\n+shorthand for creating a temporary and taking its address:\n+\n+~~~\n+let tmp = {x: 3.0, y: 4.0};\n+let on_the_stack2 : &point = &tmp;\n+~~~\n+\n+Taking the address of fields\n+\n+As in C, the `&` operator is not limited to taking the address of\n+local variables. It can also be used to take the address of fields or\n+individual array elements. For example, consider this type definition\n+for `rectangle`:\n+\n+~~~\n+type point = {x: float, y: float}; // as before\n+type size = {w: float, h: float}; // as before\n+type rectangle = {origin: point, size: size};\n+~~~\n+\n+Now again I can define rectangles in a few different ways:\n+\n+~~~\n+let rect_stack  = &{origin: {x: 1, y: 2}, size: {w: 3, h: 4}};\n+let rect_shared = @{origin: {x: 3, y: 4}, size: {w: 3, h: 4}};\n+let rect_unique = ~{origin: {x: 5, y: 6}, size: {w: 3, h: 4}};\n+~~~\n+\n+In each case I can use the `&` operator to extact out individual\n+subcomponents. For example, I could write:\n+\n+~~~\n+compute_distance(&rect_stack.origin, &rect_shared.origin);\n+~~~\n+\n+which would borrow the field `origin` from the rectangle on the stack\n+from the shared box and then compute the distance between them.\n+\n+# Borrowing shared boxes and rooting\n+\n+We\u2019ve seen a few examples so far where heap boxes (both shared and\n+unique) are borrowed. Up till this point, we\u2019ve glossed over issues of\n+safety. As stated in the introduction, at runtime a borrowed pointer\n+is simply a pointer, nothing more. Therefore, if we wish to avoid the\n+issues that C has with dangling pointers (and we do!), a compile-time\n+safety check is required.\n+\n+The basis for the check is the notion of _lifetimes_. A lifetime is\n+basically a static approximation of the period in which the pointer is\n+valid: it always corresponds to some expression or block within the\n+program. Within that expression, the pointer can be used freely, but\n+if the pointer somehow leaks outside of that expression, the compiler\n+will report an error. We\u2019ll be discussing lifetimes more in the\n+examples to come, and a more thorough introduction is also available.\n+\n+When a borrowed pointer is created, the compiler must ensure that it\n+will remain valid for its entire lifetime. Sometimes this is\n+relatively easy, such as when taking the address of a local variable\n+or a field that is stored on the stack:\n+\n+~~~\n+fn example1() {\n+    let mut x = {f: 3};\n+    let y = &mut x.f;  // -+ L\n+    ...                //  |\n+}                      // -+\n+~~~\n+\n+Here, the lifetime of the borrowed pointer is simply L, the remainder\n+of the function body. No extra work is required to ensure that `x.f`\n+will not be freed. This is true even if `x` is mutated.\n+\n+The situation gets more complex when borrowing data that resides in\n+heap boxes:\n+\n+~~~\n+fn example2() {\n+    let mut x = @{f: 3};\n+    let y = &x.f;      // -+ L\n+    ...                //  |\n+}                      // -+\n+~~~\n+\n+In this example, the value `x` is in fact a heap box, and `y` is\n+therefore a pointer into that heap box. Again the lifetime of `y` will\n+be L, the remainder of the function body. But there is a crucial\n+difference: suppose `x` were reassigned during the lifetime L? If\n+we\u2019re not careful, that could mean that the shared box would become\n+unrooted and therefore be subject to garbage collection\n+\n+> ***Note:***In our current implementation, the garbage collector is\n+> implemented using reference counting and cycle detection.\n+\n+For this reason, whenever the interior of a shared box stored in a\n+mutable location is borrowed, the compiler will insert a temporary\n+that ensures that the shared box remains live for the entire\n+lifetime. So, the above example would be compiled as:\n+\n+~~~\n+fn example2() {\n+    let mut x = @{f: 3};\n+    let x1 = x;\n+    let y = &x1.f;     // -+ L\n+    ...                //  |\n+}                      // -+\n+~~~\n+\n+Now if `x` is reassigned, the pointer `y` will still remain valid. This\n+process is called \u201crooting\u201d.\n+\n+# Borrowing unique boxes\n+\n+The previous example demonstrated `rooting`, the process by which the\n+compiler ensures that shared boxes remain live for the duration of a\n+borrow. Unfortunately, rooting does not work if the data being\n+borrowed is a unique box, as it is not possible to have two references\n+to a unique box.\n+\n+For unique boxes, therefore, the compiler will only allow a borrow `if\n+the compiler can guarantee that the unique box will not be reassigned\n+or moved for the lifetime of the pointer`. This does not necessarily\n+mean that the unique box is stored in immutable memory. For example,\n+the following function is legal:\n+\n+~~~\n+fn example3() -> int {\n+    let mut x = ~{f: 3};\n+    if some_condition {\n+        let y = &x.f;      // -+ L\n+        ret *y;            //  |\n+    }                      // -+\n+    x = ~{f: 4};\n+    ...\n+}\n+~~~\n+\n+Here, as before, the interior of the variable `x` is being borrowed\n+and `x` is declared as mutable. However, the compiler can clearly see\n+that `x` is not assigned anywhere in the lifetime L of the variable\n+`y`. Therefore, it accepts the function, even though `x` is mutable\n+and in fact is mutated later in the function.\n+\n+It may not be clear why we are so concerned about the variable which\n+was borrowed being mutated. The reason is that unique boxes are freed\n+_as soon as their owning reference is changed or goes out of\n+scope_. Therefore, a program like this is illegal (and would be\n+rejected by the compiler):\n+\n+~~~\n+fn example3() -> int {\n+    let mut x = ~{f: 3};\n+    let y = &x.f;\n+    x = ~{f: 4};  // Error reported here.\n+    *y\n+}\n+~~~\n+\n+To make this clearer, consider this diagram showing the state of\n+memory immediately before the re-assignment of `x`:\n+\n+~~~ {.notrust}\n+    Stack               Exchange Heap\n+\n+  x +----------+\n+    | ~{f:int} | ----+\n+  y +----------+     |\n+    | &int     | ----+\n+    +----------+     |    +---------+\n+                     +--> |  f: 3   |\n+                          +---------+\n+~~~\n+\n+Once the reassignment occurs, the memory will look like this:\n+\n+~~~ {.notrust}\n+    Stack               Exchange Heap\n+\n+  x +----------+          +---------+\n+    | ~{f:int} | -------> |  f: 4   |\n+  y +----------+          +---------+\n+    | &int     | ----+\n+    +----------+     |    +---------+\n+                     +--> | (freed) |\n+                          +---------+\n+~~~\n+\n+Here you can see that the variable `y` still points at the old box,\n+which has been freed.\n+\n+In fact, the compiler can apply this same kind of reasoning can be\n+applied to any memory which is _(uniquely) owned by the stack\n+frame_. So we could modify the previous example to introduce\n+additional unique pointers and records, and the compiler will still be\n+able to detect possible mutations:\n+\n+~~~\n+fn example3() -> int {\n+    let mut x = ~{mut f: ~{g: 3}};\n+    let y = &x.f.g;\n+    x = ~{mut f: ~{g: 4}}; // Error reported here.\n+    x.f = ~{g: 5};         // Error reported here.\n+    *y\n+}\n+~~~\n+\n+In this case, two errors are reported, one when the variable `x` is\n+modified and another when `x.f` is modified. Either modification would\n+cause the pointer `y` to be invalidated.\n+\n+Things get tricker when the unique box is not uniquely owned by the\n+stack frame (or when the compiler doesn\u2019t know who the owner\n+is). Consider a program like this:\n+\n+~~~\n+fn example5a(x: @{mut f: ~{g: int}}, ...) -> int {\n+    let y = &x.f.g;   // Error reported here.\n+    ...\n+}\n+~~~\n+\n+Here the heap looks something like:\n+\n+~~~ {.notrust}\n+     Stack            Shared Heap       Exchange Heap\n+\n+  x +------+        +-------------+       +------+\n+    | @... | ---->  | mut f: ~... | --+-> | g: 3 |\n+  y +------+        +-------------+   |   +------+\n+    | &int | -------------------------+\n+    +------+\n+~~~\n+\n+In this case, the owning reference to the value being borrowed is in\n+fact `x.f`. Moreover, `x.f` is both mutable and aliasable. Aliasable\n+means that it is possible that there are other pointers to that same\n+shared box, so even if the compiler were to prevent `x.f` from being\n+mutated, the field might still be changed through some alias of\n+`x`. Therefore, to be safe, the compiler only accepts pure actions\n+during the lifetime of `y`. We\u2019ll have a final example on purity but\n+inn unique fields, as in the following example:\n+\n+Besides ensuring purity, the only way to borrow the interior of a\n+unique found in aliasable memory is to ensure that it is stored within\n+unique fields, as in the following example:\n+\n+~~~\n+fn example5b(x: @{f: ~{g: int}}, ...) -> int {\n+    let y = &x.f.g;\n+    ...\n+}\n+~~~\n+\n+Here, the field `f` is not declared as mutable. But that is enough for\n+the compiler to know that, even if aliases to `x` exist, the field `f`\n+cannot be changed and hence the unique box `g` will remain valid.\n+\n+If you do have a unique box in a mutable field, and you wish to borrow\n+it, one option is to use the swap operator to bring that unique box\n+onto your stack:\n+\n+~~~\n+fn example5c(x: @{mut f: ~int}, ...) -> int {\n+    let mut v = ~0;\n+    v <-> x.f;         // Swap v and x.f\n+    let y = &v;\n+    ...\n+    x.f <- v;          // Replace x.f\n+}\n+~~~\n+\n+Of course, this has the side effect of modifying your shared box for\n+the duration of the borrow, so it works best when you know that you\n+won\u2019t be accessing that same box again.\n+\n+# Borrowing and enums\n+\n+The previous example showed that borrowing unique boxes found in\n+aliasable, mutable memory is not permitted, so as to prevent pointers\n+into freed memory. There is one other case where the compiler must be\n+very careful to ensure that pointers remain valid: pointers into the\n+interior of an enum.\n+\n+As an example, let\u2019s look at the following `shape` type that can\n+represent both rectangles and circles:\n+\n+~~~\n+type point = {x: float, y: float}; // as before\n+type size = {w: float, h: float}; // as before\n+enum shape {\n+    circle(point, float),   // origin, radius\n+    rectangle(point, size)  // upper-left, dimensions\n+}\n+~~~\n+\n+Now I might write a function to compute the area of a shape. This\n+function takes a borrowed pointer to a shape to avoid the need of\n+copying them.\n+\n+~~~\n+fn compute_area(shape: &shape) -> float {\n+    alt *shape {\n+        circle(_, radius) => 0.5 * tau * radius * radius,\n+        rectangle(_, ref size) => size.w * size.h\n+    }\n+}\n+~~~\n+\n+The first case matches against circles. Here the radius is extracted\n+from the shape variant and used to compute the area of the circle\n+(Like any up-to-date engineer, we use the [tau circle constant][tau]\n+and not that dreadfully outdated notion of pi).\n+\n+[tau]: http://www.math.utah.edu/~palais/pi.html\n+\n+The second match is more interesting. Here we match against a\n+rectangle and extract its size: but rather than copy the `size` struct,\n+we use a by-reference binding to create a pointer to it. In other\n+words, a pattern binding like `ref size` in fact creates a pointer of\n+type `&size` into the _interior of the enum_.\n+\n+To make this more clear, let\u2019s look at a diagram of how things are\n+laid out in memory in the case where `shape` points at a rectangle:\n+\n+~~~ {.notrust}\n+Stack             Memory\n+\n++-------+         +---------------+\n+| shape | ------> | rectangle(    |\n++-------+         |   {x: float,  |\n+| size  | -+      |    y: float}, |\n++-------+  +----> |   {w: float,  |\n+                  |    h: float}) |\n+                  +---------------+\n+~~~\n+\n+Here you can see that rectangular shapes are composed of five words of\n+memory. The first is a tag indicating which variant this enum is\n+(`rectangle`, in this case). The next two words are the `x` and `y`\n+fields for the point and the remaining two are the `w` and `h` fields\n+for the size. The binding `size` is then a pointer into the inside of\n+the shape.\n+\n+Perhaps you can see where the danger lies: if the shape were somehow\n+to be reassigned, perhaps to a circle, then although the memory used\n+to store that shape value would still be valid, _it would have a\n+different type_! This is shown in the following diagram, depicting what\n+the state of memory would be if shape were overwritten with a circle:\n+\n+~~~ {.notrust}\n+Stack             Memory\n+\n++-------+         +---------------+\n+| shape | ------> | circle(       |\n++-------+         |   {x: float,  |\n+| size  | -+      |    y: float}, |\n++-------+  +----> |   float)      |\n+                  |               |\n+                  +---------------+\n+~~~\n+\n+As you can see, the `size` pointer would not be pointing at a `float` and\n+not a record. This is not good.\n+\n+So, in fact, for every `ref` binding, the compiler will impose the\n+same rules as the ones we saw for borrowing the interior of a unique\n+box: it must be able to guarantee that the enum will not be\n+overwritten for the duration of the borrow.  In fact, the example I\n+gave earlier would be considered safe. This is because the shape\n+pointer has type `&shape`, which means \u201cborrowed pointer to immutable\n+memory containing a shape\u201d. If however the type of that pointer were\n+`&const shape` or `&mut shape`, then the ref binding would not be\n+permitted. Just as with unique boxes, the compiler will permit ref\n+bindings into data owned by the stack frame even if it is mutable, but\n+otherwise it requires that the data reside in immutable memory.\n+\n+> ***Note:*** Right now, all pattern bindings are by-reference. We\n+> expect this to change so that copies are the default and references\n+> must be noted explicitly.\n+\n+# Returning borrowed pointers\n+\n+So far, all of the examples we\u2019ve looked at use borrowed pointers in a\n+\u201cdownward\u201d direction. That is, the borrowed pointer is created and\n+then used during the method or code block which created it. In some\n+cases, it is also possible to return borrowed pointers to the caller,\n+but as we\u2019ll see this is more limited.\n+\n+For example, we could write a subroutine like this:\n+\n+~~~\n+type point = {x: float, y: float};\n+fn get_x(p: &point) -> &float { &p.x }\n+~~~\n+\n+Here, the function `get_x()` returns a pointer into the structure it was\n+given. You\u2019ll note that _both_ the parameter and the return value are\n+borrowed pointers; this is important. In general, it is only possible\n+to return borrowed pointers if they are derived from a borrowed\n+pointer which was given as input to the procedure.\n+\n+In the example, `get_x()` took a borrowed pointer to a `point` as\n+input. In general, for all borrowed pointers that appear in the\n+signature of a function (such as the parameter and return types), the\n+compiler assigns the same symbolic lifetime L (we will see later that\n+there are ways to differentiate the lifetimes of different parameters\n+if that should be necessary). This means that, from the compiler\u2019s\n+point of view, `get_x()` takes and returns two pointers with the same\n+lifetime. Now, unlike other lifetimes, this lifetime is a bit\n+abstract: it doesn\u2019t refer to a specific expression within `get_x()`,\n+but rather to some expression within the caller. This is called a\n+_lifetime parameter_, because the lifetime L is effectively defined by\n+the caller to `get_x()`, just as the value for the parameter `p` is\n+defined by the caller.\n+\n+In any case, whatever the lifetime L is, the pointer produced by\n+`&p.x` always has the same lifetime as `p` itself, as a pointer to a\n+field of a record is valid as long as the record is valid. Therefore,\n+the compiler is satisfied with the function `get_x()`.\n+\n+To drill in this point, let\u2019s look at a variation on the example, this\n+time one which does not compile:\n+\n+~~~\n+type point = {x: float, y: float};\n+fn get_x_sh(p: @point) -> &float {\n+    &p.x // Error reported here\n+}\n+~~~\n+\n+Here, the function `get_x_sh()` takes a shared box as input and\n+returns a borrowed pointer. As before, the lifetime of the borrowed\n+pointer that will be returned is a parameter (specified by the\n+caller). That means that effectively `get_x_sh()` is promising to\n+return a borrowed pointer that is valid for as long as the caller\n+would like: this is subtly different from the first example, which\n+promised to return a pointer that was valid for as long as the pointer\n+it was given.\n+\n+Within `get_x_sh()`, we see the expression `&p.x` which takes the\n+address of a field of a shared box. This implies that the compiler\n+must guarantee that, so long as the resulting pointer is valid, the\n+shared box will not be reclaimed by the garbage collector. But recall\n+that get_x_sh() also promised to return a pointer that was valid for\n+as long as the caller wanted it to be. Clearly, `get_x_sh()` is not in\n+a position to make both of these guarantees; in fact, it cannot\n+guarantee that the pointer will remain valid at all once it returns,\n+as the parameter `p` may or may not be live in the caller. Therefore,\n+the compiler will report an error here.\n+\n+In general, if you borrow a shared (or unique) box to create a\n+borrowed pointer, the pointer will only be valid within the function\n+and cannot be returned. Generally, the only way to return borrowed\n+pointers is to take borrowed pointers as input.\n+\n+# Named lifetimes\n+\n+So far we have always used the notation `&T` for a borrowed\n+pointer. However, sometimes if a function takes many parameters, it is\n+useful to be able to group those parameters by lifetime. For example,\n+consider this function:\n+\n+~~~\n+fn select<T>(shape: &shape, threshold: float,\n+             a: &T, b: &T) -> &T {\n+    if compute_area(shape) > threshold {a} else {b}\n+}\n+~~~\n+\n+This function takes three borrowed pointers. Because of the way that\n+the system works, each will be assigned the same lifetime: the default\n+lifetime parameter. In practice, this means that, in the caller, the\n+lifetime of the returned value will be the intersection of the\n+lifetime of the three region parameters. This may be overloy\n+conservative, as in this example:\n+\n+~~~\n+                                              // -+ L\n+fn select_based_on_unit_circle<T>(            //  |-+ B\n+    threshold: float, a: &T, b: &T) -> &T {   //  | |\n+                                              //  | |\n+    let shape = circle({x: 0, y: 0}, 1);      //  | |\n+    select(&shape, threshold, a, b)           //  | |\n+}                                             //  |-+\n+                                              // -+\n+~~~\n+\n+In this call to `select()`, the lifetime of the first parameter shape\n+is B, the function body. Both of the second two parameters `a` and `b`\n+share the same lifetime, L, which is the lifetime parameter of\n+`select_based_on_unit_circle()`. The caller will infer the\n+intersection of these three lifetimes as the lifetime of the returned\n+value, and hence the return value of `shape()` will be assigned a\n+return value of B. This will in turn lead to a compilation error,\n+because `select_based_on_unit_circle()` is supposed to return a value\n+with the lifetime L.\n+\n+To address this, we could modify the definition of `select()` to\n+distinguish the lifetime of the first parameter from the lifetime of\n+the latter two. After all, the first parameter is not being\n+returned. To do so, we make use of the notation `&lt/T`, which is a\n+borrowed pointer with an explicit lifetime. This effectively creates a\n+second lifetime parameter for the function; named lifetime parameters\n+do not need to be declared, you just use them. Here is how the new\n+`select()` might look:\n+\n+~~~\n+fn select<T>(shape: &tmp/shape, threshold: float,\n+             a: &T, b: &T) -> &T {\n+    if compute_area(shape) > threshold {a} else {b}\n+}\n+~~~\n+\n+Here you can see the lifetime of shape is now being called `tmp`. The\n+parameters `a`, `b`, and the return value all remain with the default\n+lifetime parameter.\n+\n+You could also write `select()` using all named lifetime parameters,\n+which might look like:\n+\n+~~~\n+fn select<T>(shape: &tmp/shape, threshold: float,\n+             a: &r/T, b: &r/T) -> &r/T {\n+    if compute_area(shape) > threshold {a} else {b}\n+}\n+~~~\n+\n+This is equivalent to the previous definition.\n+\n+# Purity\n+\n+As mentioned before, the Rust compiler offers a kind of escape hatch\n+that permits borrowing of any data, but only if the actions that occur\n+during the lifetime of the borrow are pure. Pure actions are those\n+which only modify data owned by the current stack frame. The compiler\n+can therefore permit arbitrary pointers into the heap, secure in the\n+knowledge that no pure action will ever cause them to become\n+invalidated (the compiler must still track data on the stack which is\n+borrowed and enforce those rules normally, of course).\n+\n+Let\u2019s revisit a previous example and show how purity can affect the\n+compiler\u2019s result. Here is `example5a()`, which borrows the interior of\n+a unique box found in an aliasable, mutable location, only now we\u2019ve\n+replaced the `...` with some specific code:\n+\n+~~~\n+fn example5a(x: @{mut f: ~{g: int}}, ...) -> int {\n+    let y = &x.f.g;   // Unsafe\n+    *y + 1        \n+}\n+~~~\n+\n+The new code simply returns an incremented version of `y`. This clearly\n+doesn\u2019t do mutate anything in the heap, so the compiler is satisfied.\n+\n+But suppose we wanted to pull the increment code into a helper, like\n+this:\n+\n+~~~\n+fn add_one(x: &int) -> int { *x + 1 }\n+~~~\n+\n+We can now update `example5a()` to use `add_one()`:\n+\n+~~~\n+fn example5a(x: @{mut f: ~{g: int}}, ...) -> int {\n+    let y = &x.f.g;\n+    add_one(y)        // Error reported here\n+}\n+~~~\n+\n+But now the compiler will report an error again. The reason is that it\n+only considers one function at a time (like most type checkers), and\n+so it does not know that `add_one()` only takes pure actions. We can\n+help the compiler by labeling `add_one()` as pure:\n+\n+~~~\n+pure fn add_one(x: &int) -> int { *x + 1 }\n+~~~\n+\n+With this change, the modified version of `example5a()` will again compile.\n+\n+# Conclusion\n+\n+So there you have it. A (relatively) brief tour of borrowed pointer\n+system. For more details, I refer to the (yet to be written) reference\n+document on borrowed pointers, which will explain the full notation\n+and give more examples.\n\\ No newline at end of file"}, {"sha": "084f027b4340b94a4c31f21244127e3ec9df7361", "filename": "mk/docs.mk", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82e79f765ce81442f7dd3e2c878f055e95d2a34f/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/82e79f765ce81442f7dd3e2c878f055e95d2a34f/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=82e79f765ce81442f7dd3e2c878f055e95d2a34f", "patch": "@@ -103,6 +103,16 @@ doc/tutorial-ffi.html: tutorial-ffi.md doc/version_info.html doc/rust.css\n \t   --include-before-body=doc/version_info.html \\\n            --output=$@\n \n+DOCS += doc/tutorial-borrowed-ptr.html\n+doc/tutorial-borrowed-ptr.html: tutorial-borrowed-ptr.md doc/version_info.html doc/rust.css\n+\t@$(call E, pandoc: $@)\n+\t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n+          $(CFG_PANDOC) --standalone --toc \\\n+           --section-divs --number-sections \\\n+           --from=markdown --to=html --css=rust.css \\\n+\t   --include-before-body=doc/version_info.html \\\n+           --output=$@\n+\n   endif\n endif\n "}]}